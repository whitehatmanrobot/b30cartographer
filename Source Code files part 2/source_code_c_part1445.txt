d,&dwLenOfBuffAvailable) )
    {
        return RETURNCODETOHRESULT(GetLastError());
    }

    dwLenOfBuffer += dwLenOfBuffAvailable;
    pszPlaceToAppend = pszContainerName + dwLenOfBuffer - 1;
    dwLenOfBuffAvailable = dwBufferLen - dwLenOfBuffer - 1;


    //
    // obtain current process token
    //

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken ))
    {
        if(GetLastError() != ERROR_NO_TOKEN)
        {
            return RETURNCODETOHRESULT(GetLastError());
        }

        //
        // retry against process token if no thread token exists
        //
        if(!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
        {
            return RETURNCODETOHRESULT(GetLastError());
        }
    }


    //
    // obtain user identified by current process' access token
    //

    bSuccess = GetTokenInformation( hToken,    // identifies access token
                                    TokenUser, // TokenUser info type
                                    ptgUser,   // retrieved info buffer
                                    cbBuffer,  // size of buffer passed-in
                                    &cbBuffer  // required buffer size
                                    );

    if (!bSuccess)
    {
        retVal = GetLastError();

        // close token handle.  do this even if error above
        CloseHandle(hToken);
        return RETURNCODETOHRESULT(retVal);
    }

    // close token handle
    CloseHandle(hToken);

    //
    // obtain the textual representaion of the Sid
    //
    return GetTextualSid( ptgUser->User.Sid,        // user binary Sid
                          pszPlaceToAppend,         // buffer for TextualSid
                          &dwLenOfBuffAvailable     // size/required buffer
                          );
}

HRESULT
ADM_SECURE_DATA::GetTextualSid(
    PSID pSid,          // binary Sid
    LPTSTR TextualSid,  // buffer for Textual representaion of Sid
    LPDWORD cchSidSize  // required/provided TextualSid buffersize
    )
/*++

Routine Description:

    Thsi method converts bianry SID to text representation

Arguments:

    pSid -  binary SID

    TextualSid - buffer for Textual representaiton of SID

    cchSidSize - required/provided TextualSid buffersize


Return Value:

    HRESULT

--*/
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD cchSidCopy;

    //
    // test if Sid passed in is valid
    //
    if(!IsValidSid(pSid))
    {
        return RETURNCODETOHRESULT(ERROR_INVALID_SID);
    }

    // obtain SidIdentifierAuthority
    psia = GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute approximate buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    cchSidCopy = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if(*cchSidSize < cchSidCopy)
    {
        *cchSidSize = cchSidCopy;
        return RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER);
    }

    //
    // prepare S-SID_REVISION-
    //
    cchSidCopy = wsprintf(TextualSid, "S-%lu-", SID_REVISION );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )
    {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy,
            "0x%02hx%02hx%02hx%02hx%02hx%02hx",
            (USHORT)psia->Value[0],
            (USHORT)psia->Value[1],
            (USHORT)psia->Value[2],
            (USHORT)psia->Value[3],
            (USHORT)psia->Value[4],
            (USHORT)psia->Value[5]);
    }
    else
    {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy,
            "%lu",
            (ULONG)(psia->Value[5]      )   +
            (ULONG)(psia->Value[4] <<  8)   +
            (ULONG)(psia->Value[3] << 16)   +
            (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for(dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++)
    {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy, "-%lu",
            *GetSidSubAuthority(pSid, dwCounter) );
    }

    //
    // tell the caller how many chars we provided, not including NULL
    //
    *cchSidSize = cchSidCopy;

    return NO_ERROR;
}




ADM_GUID_MAP::ADM_GUID_MAP(
        IN IUnknown * Object,
        IN GUID guidServer
        ):m_Object( Object ),
          m_ReferenceCount( 1 ),
          m_guidServer(guidServer)
/*++

Routine Description:

    ADM_GUID_MAP object constructor.

Arguments:

    Object - Pointer to the object to associate.

Return Value:

    None.

--*/
{
    //
    // Sanity check.
    //

    DBG_ASSERT( Object != NULL );
    DBG_ASSERT( guidServer != GUID_NULL );

    //
    // Initialize any complex data members.
    //

    INITIALIZE_CRITICAL_SECTION( &m_ObjectLock );

    //
    // Put ourselves on the list.
    //

    AcquireDataLock();
        InsertHeadList( &sm_GuidMapListHead, &m_GuidMapListEntry );
    ReleaseDataLock();

}   // ADM_GUID_MAP::ADM_GUID_MAP


ADM_GUID_MAP::~ADM_GUID_MAP()
/*++

Routine Description:

    ADM_SECURE_DATA object destructor.

Arguments:

    None.

Return Value:

    None.

--*/
{

    //
    // Sanity check.
    //

    DBG_ASSERT( m_ReferenceCount == 0 );

    //
    // AddRef the ADM_SECURE_DATA
    // Do this here instead of constructor to
    // all handing of errors.
    //

    ADM_SECURE_DATA *psecdatData;
    psecdatData = ADM_SECURE_DATA::FindAndReferenceClientSecureData(m_Object,
                                                                    FALSE,
                                                                    this);
    if (psecdatData != NULL) {
        psecdatData->Dereference();
        psecdatData->Dereference();
    }


    //
    // Cleanup.
    //

    AcquireDataLock();
    RemoveEntryList( &m_GuidMapListEntry );
    ReleaseDataLock();

    DeleteCriticalSection( &m_ObjectLock );

}   // ADM_SECURE_DATA::~ADM_SECURE_DATA

VOID
ADM_GUID_MAP::Initialize( VOID
    )
/*++

Routine Description:

    Initializes static global data private to ADM_SECURE_DATA.

Arguments:

    hDll - Handle to this DLL.

Return Value:

    None.

--*/
{

    INITIALIZE_CRITICAL_SECTION( &sm_GuidMapDataLock );

#if DBG
    sm_GuidMapLockOwner = 0;
    sm_RefTraceLog = CreateRefTraceLog( 1024, 0 );
#endif

    InitializeListHead( &sm_GuidMapListHead );

}   // ADM_SECURE_DATA::Initialize

VOID
ADM_GUID_MAP::Terminate()
{
    PLIST_ENTRY entry;
    ADM_GUID_MAP * data;
    HRESULT result;

    //
    // Free any secure data objects on our list.
    //

    AcquireDataLock();

    entry = sm_GuidMapListHead.Flink;

    while( entry != &sm_GuidMapListHead ) {

        data = CONTAINING_RECORD(
                   entry,
                   ADM_GUID_MAP,
                   m_GuidMapListEntry
                   );
        entry = entry->Flink;

        data->Dereference();

    }


    ReleaseDataLock();

    DBG_ASSERT( IsListEmpty( &sm_GuidMapListHead ) );

    //
    // Final cleanup.
    //

    DeleteCriticalSection( &sm_GuidMapDataLock );

#if DBG
    if( sm_RefTraceLog != NULL ) {
        DestroyRefTraceLog( sm_RefTraceLog );
    }
#endif
}

    //
    // Find and reference the ADM_GUID_MAP object associatd with the
    // given object; create if not found.
    //

ADM_GUID_MAP *
ADM_GUID_MAP::FindAndReferenceGuidMap(
        IN IUnknown * Object,
        IN BOOL CreateIfNotFound
        )
{

    PLIST_ENTRY entry;
    ADM_GUID_MAP * data;

    AcquireDataLock();

    for( entry = sm_GuidMapListHead.Flink ;
         entry != &sm_GuidMapListHead ;
         entry = entry->Flink ) {

        data = CONTAINING_RECORD(
                   entry,
                   ADM_GUID_MAP,
                   m_GuidMapListEntry
                   );

        if( data->m_Object == Object ) {

            data->Reference();
            ReleaseDataLock();
            return data;

        }

    }

    data = NULL;
    if( CreateIfNotFound ) {

        GUID guidServer;
        HRESULT hresError;

        hresError = IMSAdminBaseW_R_GetServerGuid_Proxy((IMSAdminBaseW *)Object,
                                                        &guidServer);

        if (SUCCEEDED(hresError)) {
            data = new ADM_GUID_MAP( Object,
                                     guidServer );

            if( data == NULL ) {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "ADM_SECURE_DATA::FindAndReferenceServerSecureData: out of memory\n"
                    ));

            } else {

                //
                // AddRef the ADM_SECURE_DATA
                // Do this here instead of constructor to
                // all handing of errors.
                // this may create the ADM_SECURE_DATA
                //

                ADM_SECURE_DATA *psecdatData;
                psecdatData = ADM_SECURE_DATA::FindAndReferenceClientSecureData(Object,
                                                                                TRUE,
                                                                                data);
                if (psecdatData == NULL) {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "ADM_SECURE_DATA::FindAndReferenceServerSecureData: out of memory\n"
                        ));
                    data->Dereference();
                    data = NULL;

                }
                else {
                    data->Reference();
                }

            }
        }
        else {
            DBGPRINTF((
                DBG_CONTEXT,
                "ADM_SECURE_DATA::FindAndReferenceServerSecureData: CoCreateGuid failed\n"
                ));
        }
    }

    ReleaseDataLock();
    return data;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\interf2\security.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    security.cxx

Abstract:

    This module contains the code necessary to implement secure DCOM data
    transfers on-the-wire. It includes the implementation of the "hooked"
    (call_as) methods from IMSAdminBase.

Author:

    Keith Moore (keithmo)       17-Feb-1997

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ole2.h>
#include <windows.h>
#include <dbgutil.h>
#include <iadmw.h>
#include <icrypt.hxx>
#include <secdat.hxx>
#include <secpriv.h>


//
// Private constants.
//

#define ALLOC_MEM(cb) (LPVOID)::LocalAlloc( LPTR, (cb) )
#define FREE_MEM(ptr) (VOID)::LocalFree( (HLOCAL)(ptr) )

#if DBG
BOOL g_fEnableSecureChannel = TRUE;
#define ENABLE_SECURE_CHANNEL g_fEnableSecureChannel
#else
#define ENABLE_SECURE_CHANNEL TRUE
#endif

BOOL g_fStopOnKeyset = TRUE;

//
// Private prototypes.
//

VOID
CalculateGetAllBufferAttributes(
    IN PMETADATA_GETALL_RECORD Data,
    IN DWORD NumEntries,
    OUT DWORD * TotalBufferLength,
    OUT BOOL * IsBufferSecure
    );



HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_SetData_Proxy(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData
    )
/*++

Routine Description:

    Set a data object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data to set

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * sendCrypto;
    PIIS_CRYPTO_BLOB dataBlob;
    METADATA_RECORD capturedRecord;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    sendCrypto = NULL;
    dataBlob = NULL;
    result = NO_ERROR;

    //
    // Trap the case of a null METADATA_RECORD
    //

    if( pmdrMDData == NULL )
    {
        result = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    //
    // Capture the METADATA_RECORD so we can muck with it.
    //

    __try {
        capturedRecord = *pmdrMDData;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        result = HRESULT_FROM_NT( GetExceptionCode() );
    }

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // If this is a secure data item, then encrypt the data before
    // sending.
    //

    if( ENABLE_SECURE_CHANNEL &&
        (capturedRecord.dwMDAttributes & METADATA_SECURE) &&
        ((PVOID)capturedRecord.pbMDData != NULL) ) {

        //
        // Find an ADM_SECURE_DATA object for "This".
        //

        secureData = ADM_SECURE_DATA::FindAndReferenceClientSecureData(
                         This,
                         TRUE       // CreateIfNotFound
                         );

        if( secureData == NULL ) {
            result = MD_ERROR_SECURE_CHANNEL_FAILURE;
            goto cleanup;
        }

        //
        // Get the appropriate crypto storage object. This will perform
        // key exchange if necessary.
        //

        result = secureData->GetClientSendCryptoStorage( &sendCrypto,
                                                         This );

        if( FAILED(result) ) {
            if (g_fStopOnKeyset) {
                DBG_ASSERT(FALSE);
            }
            goto cleanup;
        }

        //
        // Protect ourselves from malicious users.
        //

        __try {

            //
            // Encrypt the data.
            //

            result = sendCrypto->EncryptData(
                         &dataBlob,
                         (PVOID)capturedRecord.pbMDData,
                         capturedRecord.dwMDDataLen,
                         0                                      // dwRegType
                         );

        } __except( EXCEPTION_EXECUTE_HANDLER ) {

            result = HRESULT_FROM_NT(GetExceptionCode());

        }

        if( FAILED(result) ) {
            if (g_fStopOnKeyset) {
                DBG_ASSERT(FALSE);
            }
            goto cleanup;
        }

        //
        // Update the fields of the captured metadata record so the
        // RPC runtime will send the data to the server.
        //

        capturedRecord.pbMDData = (PBYTE)dataBlob;
        capturedRecord.dwMDDataLen = IISCryptoGetBlobLength( dataBlob );

    }

    //
    // Call through to the "real" remoted API to get this over to the
    // server.
    //

    result = IMSAdminBaseW_R_SetData_Proxy(
                 This,
                 hMDHandle,
                 pszMDPath,
                 &capturedRecord
                 );

cleanup:

    if (g_fStopOnKeyset &&
        ((result == NTE_BAD_KEYSET) ||
         (result == NTE_KEYSET_NOT_DEF) ||
         (result == NTE_KEYSET_ENTRY_BAD) ||
         (result == NTE_BAD_KEYSET_PARAM))) {
        DBG_ASSERT(FALSE);
    }

    if( dataBlob != NULL ) {
        IISCryptoFreeBlob( dataBlob );
    }

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    return result;

}   // IMSAdminBaseW_SetData_Proxy


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_SetData_Stub(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData
    )
/*++

Routine Description:

    Set a data object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data to set

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * recvCrypto;
    METADATA_RECORD capturedRecord;
    DWORD clearDataType;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    recvCrypto = NULL;
    result = NO_ERROR;

    //
    // Capture the metadata record so we can muck with it.
    //

    capturedRecord = *pmdrMDData;

    //
    // If this is a secure data item, then decrypt the data before
    // passing it to the actual implementation object.
    //

    if( ENABLE_SECURE_CHANNEL &&
        (capturedRecord.dwMDAttributes & METADATA_SECURE) &&
        (capturedRecord.pbMDData != NULL) ) {

        //
        // Find an ADM_SECURE_DATA object for "This".
        //

        secureData = ADM_SECURE_DATA::FindAndReferenceServerSecureData(
                         This,
                         TRUE       // CreateIfNotFound
                         );

        if( secureData == NULL ) {
            result = MD_ERROR_SECURE_CHANNEL_FAILURE;
            goto cleanup;
        }

        //
        // Get the appropriate crypto storage object.
        //

        result = secureData->GetServerReceiveCryptoStorage( &recvCrypto );

        if ( FAILED(result) ) {
            if (g_fStopOnKeyset) {
                DBG_ASSERT(FALSE);
            }
            goto cleanup;
        }

        //
        // Decrypt the data, then replace the pointer in the metadata
        // record.
        //

        result = recvCrypto->DecryptData(
                     (PVOID *)&capturedRecord.pbMDData,
                     &capturedRecord.dwMDDataLen,
                     &clearDataType,
                     (PIIS_CRYPTO_BLOB)capturedRecord.pbMDData
                     );


        if( FAILED(result) ) {
            if (g_fStopOnKeyset) {
                DBG_ASSERT(FALSE);
            }
            goto cleanup;
        }

    }

    //
    // Call through to the "real" server stub to set the data.
    //

    result = This->SetData(
                 hMDHandle,
                 pszMDPath,
                 &capturedRecord
                 );

cleanup:

   if (g_fStopOnKeyset &&
       ((result == NTE_BAD_KEYSET) ||
        (result == NTE_KEYSET_NOT_DEF) ||
        (result == NTE_KEYSET_ENTRY_BAD) ||
        (result == NTE_BAD_KEYSET_PARAM))) {
       DBG_ASSERT(FALSE);
   }


    if( secureData != NULL ) {
        secureData->Dereference();
    }

    return result;

}   // IMSAdminBaseW_SetData_Stub


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_GetData_Proxy(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen
    )
/*++

Routine Description:

    Get one metadata value

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data structure

    pdwMDRequiredDataLen - updated with required length

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * recvCrypto;
    IIS_CRYPTO_BLOB *dataBlob;
    METADATA_RECORD capturedRecord;
    PVOID dataBuffer;
    DWORD dataBufferLength;
    DWORD dataBufferType;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    recvCrypto = NULL;
    dataBlob = NULL;

    //
    // Trap the case of a null METADATA_RECORD
    //

    if( pmdrMDData == NULL )
    {
        result = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        goto cleanup;
    }

    //
    // Find an ADM_SECURE_DATA object for "This".
    //

    secureData = ADM_SECURE_DATA::FindAndReferenceClientSecureData(
                     This,
                     TRUE       // CreateIfNotFound
                     );

    if( secureData == NULL ) {
        result = MD_ERROR_SECURE_CHANNEL_FAILURE;
        goto cleanup;
    }

    //
    // Get the appropriate crypto storage object. This will perform
    // key exchange if necessary.
    //

    result = secureData->GetClientReceiveCryptoStorage( &recvCrypto,
                                                        This );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Capture the METADATA_RECORD so we can muck with it.
    //

    __try {
        capturedRecord = *pmdrMDData;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        result = HRESULT_FROM_NT( GetExceptionCode() );
    }

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Call through to the "real" remoted API to get the data from
    // the server. Note that we set the data pointer to NULL before
    // calling the remoted API. This prevents the RPC runtime from
    // sending plaintext data over to the server.
    //

    capturedRecord.pbMDData = NULL;

    result = IMSAdminBaseW_R_GetData_Proxy(
                 This,
                 hMDHandle,
                 pszMDPath,
                 &capturedRecord,
                 pdwMDRequiredDataLen,
                 &dataBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Decrypt the data if necessary. This method properly handles
    // cleartext (unencrypted) blobs.
    //

    result = recvCrypto->DecryptData(
                 &dataBuffer,
                 &dataBufferLength,
                 &dataBufferType,
                 dataBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Copy it back to the user.
    //

    __try {

        if( pmdrMDData->dwMDDataLen >= dataBufferLength ) {

            RtlCopyMemory(
                pmdrMDData->pbMDData,
                dataBuffer,
                dataBufferLength
                );

            pmdrMDData->dwMDDataLen = dataBufferLength;
            pmdrMDData->dwMDIdentifier = capturedRecord.dwMDIdentifier;
            pmdrMDData->dwMDAttributes = capturedRecord.dwMDAttributes;
            pmdrMDData->dwMDUserType = capturedRecord.dwMDUserType;
            pmdrMDData->dwMDDataType = capturedRecord.dwMDDataType;
            pmdrMDData->dwMDDataTag = capturedRecord.dwMDDataTag;

        } else {

            *pdwMDRequiredDataLen = dataBufferLength;
            result = RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );

        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        result = HRESULT_FROM_NT( GetExceptionCode() );

    }

    if( FAILED(result) ) {
        goto cleanup;
    }

cleanup:

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    if( dataBlob != NULL ) {
        ::IISCryptoFreeBlob( dataBlob );
    }

    return result;

}   // IMSAdminBaseW_GetData_Proxy


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_GetData_Stub(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob
    )
/*++

Routine Description:

    Get one metadata value

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data structure

    pdwMDRequiredDataLen - updated with required length

    ppDataBlob - Receives a blob for the encrypted data.

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * sendCrypto;
    IIS_CRYPTO_BLOB *dataBlob;
    DWORD clearDataType;
    PVOID dataBuffer;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    sendCrypto = NULL;
    dataBuffer = NULL;
    dataBlob = NULL;

    //
    // Allocate a temporary memory block for the meta data. Use the
    // same size as the user passed into the API.
    //

    dataBuffer = ALLOC_MEM( pmdrMDData->dwMDDataLen );

    if( dataBuffer == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    pmdrMDData->pbMDData = (PBYTE)dataBuffer;

    //
    // Call through to the "real" server stub to get the data.
    //

    result = This->GetData(
                 hMDHandle,
                 pszMDPath,
                 pmdrMDData,
                 pdwMDRequiredDataLen
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // If this is a secure data item, then we'll need to encrypt it
    // before returning it to the client. Otherwise, we'll build a
    // cleartext blob to contain the data.
    //

    if( ENABLE_SECURE_CHANNEL &&
        pmdrMDData->dwMDAttributes & METADATA_SECURE ) {

        //
        // Find an ADM_SECURE_DATA object for "This".
        //

        secureData = ADM_SECURE_DATA::FindAndReferenceServerSecureData(
                         This,
                         TRUE       // CreateIfNotFound
                         );

        if( secureData == NULL ) {
            result = MD_ERROR_SECURE_CHANNEL_FAILURE;
            goto cleanup;
        }

        //
        // Get the appropriate crypto storage object.
        //

        result = secureData->GetServerSendCryptoStorage( &sendCrypto );

        if( FAILED(result) ) {
            goto cleanup;
        }

        //
        // Encrypt the data.
        //

        result = sendCrypto->EncryptData(
                     &dataBlob,
                     (PVOID)pmdrMDData->pbMDData,
                     pmdrMDData->dwMDDataLen,
                     0
                     );

        if( FAILED(result) ) {
            goto cleanup;
        }

    } else {

        result = ::IISCryptoCreateCleartextBlob(
                       &dataBlob,
                       (PVOID)pmdrMDData->pbMDData,
                       pmdrMDData->dwMDDataLen
                       );

        if( FAILED(result) ) {
            goto cleanup;
        }

    }

    //
    // Success!
    //

    DBG_ASSERT( SUCCEEDED(result) );
    *ppDataBlob = dataBlob;

cleanup:

    //
    // NULL the data pointer in the METADATA_RECORD so the RPC runtime
    // won't send the plaintext data back to the client.
    //

    pmdrMDData->pbMDData = NULL;

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    if( dataBuffer != NULL ) {
        FREE_MEM( dataBuffer );
    }

    if( FAILED(result) && dataBlob != NULL ) {
        ::IISCryptoFreeBlob( dataBlob );
    }

    return result;

}   // IMSAdminBaseW_GetData_Stub


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_EnumData_Proxy(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen
    )
/*++

Routine Description:

    Enumerate properties of object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data structure

    pdwMDRequiredDataLen - updated with required length

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * recvCrypto;
    IIS_CRYPTO_BLOB *dataBlob;
    METADATA_RECORD capturedRecord;
    PVOID dataBuffer;
    DWORD dataBufferLength;
    DWORD dataBufferType;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    recvCrypto = NULL;
    dataBlob = NULL;

    //
    // Trap the case of a null METADATA_RECORD
    //

    if( pmdrMDData == NULL )
    {
        result = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        goto cleanup;
    }


    //
    // Find an ADM_SECURE_DATA object for "This".
    //

    secureData = ADM_SECURE_DATA::FindAndReferenceClientSecureData(
                     This,
                     TRUE       // CreateIfNotFound
                     );

    if( secureData == NULL ) {
        result = MD_ERROR_SECURE_CHANNEL_FAILURE;
        goto cleanup;
    }

    //
    // Get the appropriate crypto storage object. This will perform
    // key exchange if necessary.
    //

    result = secureData->GetClientReceiveCryptoStorage( &recvCrypto,
                                                        This );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Capture the METADATA_RECORD so we can muck with it.
    //

    __try {
        capturedRecord = *pmdrMDData;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        result = HRESULT_FROM_NT( GetExceptionCode() );
    }

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Call through to the "real" remoted API to get the data from
    // the server. Note that we set the data pointer to NULL before
    // calling the remoted API. This prevents the RPC runtime from
    // sending plaintext data over to the server.
    //

    capturedRecord.pbMDData = NULL;

    result = IMSAdminBaseW_R_EnumData_Proxy(
                 This,
                 hMDHandle,
                 pszMDPath,
                 &capturedRecord,
                 dwMDEnumDataIndex,
                 pdwMDRequiredDataLen,
                 &dataBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Decrypt the data if necessary. This method properly handles
    // cleartext (unencrypted) blobs.
    //

    result = recvCrypto->DecryptData(
                 &dataBuffer,
                 &dataBufferLength,
                 &dataBufferType,
                 dataBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Copy it back to the user.
    //

    __try {

        if( pmdrMDData->dwMDDataLen >= dataBufferLength ) {

            RtlCopyMemory(
                pmdrMDData->pbMDData,
                dataBuffer,
                dataBufferLength
                );

            pmdrMDData->dwMDDataLen = dataBufferLength;
            pmdrMDData->dwMDIdentifier = capturedRecord.dwMDIdentifier;
            pmdrMDData->dwMDAttributes = capturedRecord.dwMDAttributes;
            pmdrMDData->dwMDUserType = capturedRecord.dwMDUserType;
            pmdrMDData->dwMDDataType = capturedRecord.dwMDDataType;
            pmdrMDData->dwMDDataTag = capturedRecord.dwMDDataTag;

        } else {

            *pdwMDRequiredDataLen = dataBufferLength;
            result = RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );

        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        result = HRESULT_FROM_NT( GetExceptionCode() );

    }

    if( FAILED(result) ) {
        goto cleanup;
    }

cleanup:

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    if( dataBlob != NULL ) {
        ::IISCryptoFreeBlob( dataBlob );
    }

    return result;

}   // IMSAdminBaseW_EnumData_Proxy


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_EnumData_Stub(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob
    )
/*++

Routine Description:

    Enumerate properties of object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data structure

    pdwMDRequiredDataLen - updated with required length

    ppDataBlob - Receives a blob for the encrypted data.

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * sendCrypto;
    IIS_CRYPTO_BLOB *dataBlob;
    METADATA_RECORD capturedRecord;
    DWORD clearDataType;
    PVOID dataBuffer;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    sendCrypto = NULL;
    dataBuffer = NULL;
    dataBlob = NULL;

    //
    // Allocate a temporary memory block for the meta data. Use the
    // same size as the user passed into the API.
    //

    dataBuffer = ALLOC_MEM( pmdrMDData->dwMDDataLen );

    if( dataBuffer == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    pmdrMDData->pbMDData = (PBYTE)dataBuffer;

    //
    // Call through to the "real" server stub to get the data.
    //

    result = This->EnumData(
                 hMDHandle,
                 pszMDPath,
                 pmdrMDData,
                 dwMDEnumDataIndex,
                 pdwMDRequiredDataLen
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // If this is a secure data item, then we'll need to encrypt it
    // before returning it to the client. Otherwise, we'll build a
    // cleartext blob to contain the data.
    //

    if( ENABLE_SECURE_CHANNEL &&
        pmdrMDData->dwMDAttributes & METADATA_SECURE ) {

        //
        // Find an ADM_SECURE_DATA object for "This".
        //

        secureData = ADM_SECURE_DATA::FindAndReferenceServerSecureData(
                         This,
                         TRUE       // CreateIfNotFound
                         );

        if( secureData == NULL ) {
            result = MD_ERROR_SECURE_CHANNEL_FAILURE;
            goto cleanup;
        }

        //
        // Get the appropriate crypto storage object.
        //

        result = secureData->GetServerSendCryptoStorage( &sendCrypto );

        if( FAILED(result) ) {
            goto cleanup;
        }

        //
        // Encrypt the data.
        //

        result = sendCrypto->EncryptData(
                     &dataBlob,
                     (PVOID)pmdrMDData->pbMDData,
                     pmdrMDData->dwMDDataLen,
                     0
                     );

        if( FAILED(result) ) {
            goto cleanup;
        }

    } else {

        result = ::IISCryptoCreateCleartextBlob(
                       &dataBlob,
                       (PVOID)pmdrMDData->pbMDData,
                       pmdrMDData->dwMDDataLen
                       );

        if( FAILED(result) ) {
            goto cleanup;
        }

    }

    //
    // Success!
    //

    DBG_ASSERT( SUCCEEDED(result) );
    *ppDataBlob = dataBlob;

cleanup:

    //
    // NULL the data pointer in the METADATA_RECORD so the RPC runtime
    // won't send the plaintext data back to the client.
    //

    pmdrMDData->pbMDData = NULL;

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    if( dataBuffer != NULL ) {
        FREE_MEM( dataBuffer );
    }

    if( FAILED(result) && dataBlob != NULL ) {
        ::IISCryptoFreeBlob( dataBlob );
    }

    return result;

}   // IMSAdminBaseW_EnumData_Stub


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_GetAllData_Proxy(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize
    )
/*++

Routine Description:

    Gets all data associated with a Meta Object

Arguments:

    hMDHandle - open  handle

    pszMDPath - path of the meta object with which this data is associated

    dwMDAttributes - flags for the data

    dwMDUserType - user Type for the data

    dwMDDataType - type of the data

    pdwMDNumDataEntries - number of entries copied to Buffer

    pdwMDDataSetNumber - number associated with this data set

    dwMDBufferSize - size in bytes of buffer

    pbBuffer - buffer to store the data

    pdwMDRequiredBufferSize - updated with required length of buffer

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * recvCrypto;
    IIS_CRYPTO_BLOB *dataBlob;
    PVOID dataBuffer;
    DWORD dataBufferLength;
    DWORD dataBufferType;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    recvCrypto = NULL;
    dataBlob = NULL;

    //
    // Find an ADM_SECURE_DATA object for "This".
    //

    secureData = ADM_SECURE_DATA::FindAndReferenceClientSecureData(
                     This,
                     TRUE       // CreateIfNotFound
                     );

    if( secureData == NULL ) {
        result = MD_ERROR_SECURE_CHANNEL_FAILURE;
        goto cleanup;
    }

    //
    // Get the appropriate crypto storage object. This will perform
    // key exchange if necessary.
    //

    result = secureData->GetClientReceiveCryptoStorage( &recvCrypto,
                                                        This );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Call through to the "real" remoted API to get the data from
    // the server.
    //

    result = IMSAdminBaseW_R_GetAllData_Proxy(
                 This,
                 hMDHandle,
                 pszMDPath,
                 dwMDAttributes,
                 dwMDUserType,
                 dwMDDataType,
                 pdwMDNumDataEntries,
                 pdwMDDataSetNumber,
                 dwMDBufferSize,
                 pdwMDRequiredBufferSize,
                 &dataBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Decrypt the data if necessary. This method properly handles
    // cleartext (unencrypted) blobs.
    //

    result = recvCrypto->DecryptData(
                 &dataBuffer,
                 &dataBufferLength,
                 &dataBufferType,
                 dataBlob
                 );


    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Copy it back to the user.
    //

    __try {

        if( dwMDBufferSize >= dataBufferLength ) {

            RtlCopyMemory(
                pbBuffer,
                dataBuffer,
                dataBufferLength
                );

        } else {

            *pdwMDRequiredBufferSize = dataBufferLength;
            result = RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );

        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        result = HRESULT_FROM_NT( GetExceptionCode() );

    }

    if( FAILED(result) ) {
        goto cleanup;
    }

cleanup:

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    if( dataBlob != NULL ) {
        ::IISCryptoFreeBlob( dataBlob );
    }

    return result;

}   // IMSAdminBaseW_GetAllData_Proxy

HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_GetAllData_Stub(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob
    )
/*++

Routine Description:

    Gets all data associated with a Meta Object

Arguments:

    hMDHandle - open  handle

    pszMDPath - path of the meta object with which this data is associated

    dwMDAttributes - flags for the data

    dwMDUserType - user Type for the data

    dwMDDataType - type of the data

    pdwMDNumDataEntries - number of entries copied to Buffer

    pdwMDDataSetNumber - number associated with this data set

    dwMDBufferSize - size in bytes of buffer

    pdwMDRequiredBufferSize - updated with required length of buffer

    ppDataBlob - Receives a blob for the encrypted data.

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * sendCrypto;
    IIS_CRYPTO_BLOB *dataBlob;
    METADATA_RECORD capturedRecord;
    DWORD clearDataType;
    PVOID dataBuffer;
    DWORD getAllBufferLength;
    BOOL getAllBufferIsSecure;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    sendCrypto = NULL;
    dataBuffer = NULL;
    dataBlob = NULL;

    //
    // Allocate a temporary memory block for the meta data. Use the
    // same size as the user passed into the API.
    //

    dataBuffer = ALLOC_MEM( dwMDBufferSize );

    if( dataBuffer == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    //
    // Call through to the "real" server stub to get the data.
    //

    result = This->GetAllData(
                 hMDHandle,
                 pszMDPath,
                 dwMDAttributes,
                 dwMDUserType,
                 dwMDDataType,
                 pdwMDNumDataEntries,
                 pdwMDDataSetNumber,
                 dwMDBufferSize,
                 (PBYTE)dataBuffer,
                 pdwMDRequiredBufferSize
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Compute the total size of the METADATA_GETALL_RECORD. Also
    // take this opportunity to determine if any of the data items
    // within the record are marked as secure. We'll encrypt the
    // entire record if any entry is secure.
    //

    CalculateGetAllBufferAttributes(
        (PMETADATA_GETALL_RECORD)dataBuffer,
        *pdwMDNumDataEntries,
        &getAllBufferLength,
        &getAllBufferIsSecure
        );

    //
    // Encrypt if necessary.
    //

    if( getAllBufferIsSecure ) {

        //
        // Find an ADM_SECURE_DATA object for "This".
        //

        secureData = ADM_SECURE_DATA::FindAndReferenceServerSecureData(
                         This,
                         TRUE       // CreateIfNotFound
                         );

        if( secureData == NULL ) {
            result = MD_ERROR_SECURE_CHANNEL_FAILURE;
            goto cleanup;
        }

        //
        // Get the appropriate crypto storage object.
        //

        result = secureData->GetServerSendCryptoStorage( &sendCrypto );

        if( FAILED(result) ) {
            goto cleanup;
        }

        //
        // Encrypt the data.
        //

        result = sendCrypto->EncryptData(
                     &dataBlob,
                     dataBuffer,
                     getAllBufferLength,
                     0
                     );

        if( FAILED(result) ) {
            goto cleanup;
        }

    } else {

        result = ::IISCryptoCreateCleartextBlob(
                       &dataBlob,
                       dataBuffer,
                       getAllBufferLength
                       );

        if( FAILED(result) ) {
            goto cleanup;
        }

    }

    //
    // Success!
    //

    DBG_ASSERT( SUCCEEDED(result) );
    *ppDataBlob = dataBlob;

cleanup:

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    if( dataBuffer != NULL ) {
        FREE_MEM( dataBuffer );
    }

    if( FAILED(result) && dataBlob != NULL ) {
        ::IISCryptoFreeBlob( dataBlob );
    }

    return result;

}   // IMSAdminBaseW_GetAllData_Stub


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_GetServerGuid_Proxy(
    IMSAdminBaseW __RPC_FAR * This
    )
{

    return E_FAIL;

}   // IMSAdminBaseW_GetServerGuid_Proxy



HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_GetServerGuid_Stub(
    IMSAdminBaseW __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pServerGuid)
{
    ADM_SECURE_DATA * secureData;

    //
    // Find an ADM_SECURE_DATA object for "This".
    //

    secureData = ADM_SECURE_DATA::FindAndReferenceServerSecureData(
                     This,
                     TRUE       // CreateIfNotFound
                     );

    if( secureData == NULL ) {
        return MD_ERROR_SECURE_CHANNEL_FAILURE;
    }

    *pServerGuid = secureData->GetGuid();

    secureData->Dereference();

    return ERROR_SUCCESS;

}


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_KeyExchangePhase1_Proxy(
    IMSAdminBaseW __RPC_FAR * This
    )
{

    return E_FAIL;

}   // IMSAdminBaseW_KeyExchangePhase1_Proxy

HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_KeyExchangePhase1_Stub(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientKeyExchangeKeyBlob,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientSignatureKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerKeyExchangeKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerSignatureKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerSessionKeyBlob
    )
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;

    //
    // Find an ADM_SECURE_DATA object for "This".
    //

    secureData = ADM_SECURE_DATA::FindAndReferenceServerSecureData(
                     This,
                     TRUE       // CreateIfNotFound
                     );

    if( secureData == NULL ) {
        return MD_ERROR_SECURE_CHANNEL_FAILURE;
    }

    //
    // Do the phase 1 server-side key exchange.
    //

    result = secureData->DoServerSideKeyExchangePhase1(
                 pClientKeyExchangeKeyBlob,
                 pClientSignatureKeyBlob,
                 ppServerKeyExchangeKeyBlob,
                 ppServerSignatureKeyBlob,
                 ppServerSessionKeyBlob
                 );

    secureData->Dereference();

    return result;

}   // IMSAdminBaseW_KeyExchangePhase1_Stub


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_KeyExchangePhase2_Proxy(
    IMSAdminBaseW __RPC_FAR * This
    )
{

    return E_FAIL;

}   // IMSAdminBaseW_KeyExchangePhase2_Proxy


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseW_KeyExchangePhase2_Stub(
    IMSAdminBaseW __RPC_FAR * This,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientSessionKeyBlob,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientHashBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerHashBlob
    )
{



    HRESULT result;
    ADM_SECURE_DATA * secureData;

    //
    // Find an ADM_SECURE_DATA object for "This".
    //

    secureData = ADM_SECURE_DATA::FindAndReferenceServerSecureData(
                     This,
                     FALSE      // CreateIfNotFound
                     );

    if( secureData == NULL ) {
        return MD_ERROR_SECURE_CHANNEL_FAILURE;
    }

    //
    // Do the phase 2 server-side key exchange.
    //

    result = secureData->DoServerSideKeyExchangePhase2(
                 pClientSessionKeyBlob,
                 pClientHashBlob,
                 ppServerHashBlob
                 );

    secureData->Dereference();

    return result;

}   // IMSAdminBaseW_KeyExchangePhase2_Stub


VOID
CalculateGetAllBufferAttributes(
    IN PMETADATA_GETALL_RECORD Data,
    IN DWORD NumEntries,
    OUT DWORD * TotalBufferLength,
    OUT BOOL * IsBufferSecure
    )
/*++

Routine Description:

    This routine performs three major functions:

        1. It calculates the total size of the METADATA_GETALL_RECORD,
           including all data.

        2. It determines if any of the METADATA_GETALL_RECORDs are marked
           as secure.

Arguments:

    Data - Pointer to the METADATA_GETALL_RECORD buffer.

    NumEntries - The number of entries in the buffer.

    TotalBufferLength - Receives the total buffer length.

    IsBufferSecure - Receives TRUE if any of the entries are marked secure.

Return Value:

    None.

--*/
{

    PMETADATA_GETALL_RECORD scan;
    DWORD i;
    DWORD_PTR usedBufferLength;
    DWORD_PTR nextOffset;
    BOOL isSecure;

    //
    // Setup.
    //

    usedBufferLength = NumEntries * sizeof(METADATA_GETALL_RECORD);
    isSecure = FALSE;

    //
    // Scan the entries, accumulating the total data length.
    //
    // Because the individual data entries may be padded. We will
    // consider the amount of buffer used to be the highest offset
    // + the length of that record's data.
    //
    // While we're at it, determine if any are marked as secure.
    //

    for( scan = Data, i = NumEntries ; i > 0 ; scan++, i-- ) {

        nextOffset = scan->dwMDDataOffset + scan->dwMDDataLen;

        if( nextOffset > usedBufferLength ) {
            usedBufferLength = nextOffset;
        }

        if( scan->dwMDAttributes & METADATA_SECURE ) {
            isSecure = ENABLE_SECURE_CHANNEL;
        }

    }

    *TotalBufferLength = static_cast<DWORD>(usedBufferLength);
    *IsBufferSecure = isSecure;

}   // CalculateGetAllBufferAttributes


VOID
WINAPI
ReleaseObjectSecurityContextW(
    IUnknown * Object
    )
/*++

Routine Description:

    Releases any security context associated with the specified object.

Arguments:

    Object - The object.

Return Value:

    None.

--*/
{

    ADM_SECURE_DATA * data;

    //
    // Find the data associated with the object.
    //

    data = ADM_SECURE_DATA::FindAndReferenceServerSecureData(
               Object,
               FALSE                // CreateIfNotFound
               );

    if( data != NULL ) {

        //
        // Dereference the secure data object *twice*, once
        // to remove the reference added above, and once to
        // remove the "active" reference.
        //

        data->Dereference();
        data->Dereference();
    }
    else {

        ADM_GUID_MAP *pguidmapData;

        pguidmapData = ADM_GUID_MAP::FindAndReferenceGuidMap(
                   Object,
                   FALSE                // CreateIfNotFound
                   );

        if( pguidmapData == NULL ) {
#if 0       // stop whining
            DBGPRINTF((
                DBG_CONTEXT,
                "ReleaseObjectSecurityContextW: cannot find data for %08lx\n",
                Object
                ));
#endif      // stop whining
        }

        else {
            //
            // Dereference the secure data object *twice*, once
            // to remove the reference added above, and once to
            // remove the "active" reference.
            //

            pguidmapData->Dereference();
            pguidmapData->Dereference();

        }

    }

}   // ReleaseObjectSecurityContextW


extern "C" {

ULONG
STDMETHODCALLTYPE
Hooked_IUnknown_Release_Proxy(
    IUnknown __RPC_FAR * This
    )
/*++

Routine Description:

    This is the hooked IUnknown::Release() method (see IADMXP.C for
    details).

Arguments:

    This - The object being released.

Return Value:

    ULONG - The updated reference count.

--*/
{

    ULONG result;

    //
    // AddRef and Release to find out if this is the final release. If so,
    // destroy any security context associated with this object.
    // This must be done before the final Release, to avoid a window
    // between the object getting freed and the security info getting
    // removed from the lists.
    //

    IUnknown_AddRef_Proxy( This );
    result = IUnknown_Release_Proxy( This );

    if( result == 1 ) {
        ReleaseObjectSecurityContextW( This );
    }

    //
    // Call the original release method.
    //

    result = IUnknown_Release_Proxy( This );

    return result;

}   // Hooked_IUnknown_Release_Proxy

}   // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\interfac\makefile.inc ===
#
#   makefile.inc
#       Makefile for generating files from the .idl file
#
#   Specify the following in the file for use
#
#   IDL_FILE_NAME   ( without the .idl suffix)
#   IDL_FLAGS       if any thing specific required
#

!INCLUDE $(NTMAKEENV)\makefile.plt


IDL_FILE_NAME   = iadm
IDL_FLAGS       = /I $(BASEDIR)\public\sdk\inc /I ..\..\metadata\interfac /I ..\interf2 -DREGISTER_PROXY_DLL


SDKINC          = $(BASEDIR)\public\sdk\inc

INCS            = -I. -I..\..\..\..\inc

CLIENT_STUB     =$(IDL_FILE_NAME)_i.c
SERVER_STUB     =$(IDL_FILE_NAME)_p.c
DLL_STUB        =dlldata.c
HEADER_FILE     =..\..\..\..\inc\$(IDL_FILE_NAME).h

CLIENT_TARGETS  = $(CLIENT_STUB) \

SERVER_TARGETS  = $(SERVER_STUB) \

DLL_TARGETS     = $(DLL_STUB) \

TARGETS         = $(CLIENT_TARGETS)  $(SERVER_TARGETS)  \
                  $(HEADER_FILE) $(DLL_TARGETS)
#                  $(HEADER_FILE) dlldata.c

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) $(NET_C_DEFINES) -DMIDL_PASS

MSC_WARNING_LEVEL= /W3 /WX

#
#  Define output and dependencies
#


all:    $(TARGETS) $(EXTRN_DEPENDS)
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF

$(BASEDIR)\public\sdk\inc\$(IDL_FILE_NAME).h: ..\..\..\..\inc\$(IDL_FILE_NAME).h
    copy ..\..\..\..\inc\$(IDL_FILE_NAME).h $(BASEDIR)\public\sdk\inc\$(IDL_FILE_NAME).h

clean: delsrc all

delsrc:
        -erase $(TARGETS) $(BASEDIR)\public\sdk\inc\$(IDL_FILE_NAME).h

obj\$(TARGETCPU)\iadmxp.obj: iadm_p.c

#
#  MIDL Compile stuff
#
#$(HEADER_FILE) $(CLIENT_TARGETS) $(SERVER_TARGETS):  .\$(IDL_FILE_NAME).idl
$(HEADER_FILE) $(CLIENT_TARGETS) $(SERVER_TARGETS) $(DLL_TARGETS) :  .\$(IDL_FILE_NAME).idl
    midl -Oi -error allocation -error ref -h $(HEADER_FILE) $(IDL_FLAGS) $(CPP) .\$(IDL_FILE_NAME).idl  $(INCS)
    munge postmidl.scr -t $(HEADER_FILE) >nul
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\interfac\main.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    DLL startup routine.

Author:

    Keith Moore (keithmo)       17-Feb-1997

Revision History:

--*/


extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <dbgutil.h>

}   // extern "C"

#include <iadm.h>
#include <icrypt.hxx>
#include <secdat.hxx>


//
// Private globals.
//

DECLARE_DEBUG_PRINTS_OBJECT();


//
// Private prototypes.
//


//
// DLL Entrypoint.
//

extern "C" {

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpReserved
    )
{

    BOOL status = TRUE;

    switch( dwReason ) {

    case DLL_PROCESS_ATTACH :
        CREATE_DEBUG_PRINT_OBJECT( "admprox" );
        status = ADM_SECURE_DATA::Initialize( hDll );
        DisableThreadLibraryCalls( hDll );
        break;

    case DLL_PROCESS_DETACH :
        ADM_SECURE_DATA::Terminate();
        DELETE_DEBUG_PRINT_OBJECT();
        break;

    }

    return status;

}   // DLLEntry

}   // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\interfac\secdat.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    secdat.cxx

Abstract:

    This module implements the ADM_SECURE_DATA class.

Author:

    Keith Moore (keithmo)       17-Feb-1997

Revision History:

--*/


extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ole2.h>
#include <windows.h>
#include <dbgutil.h>

}   // extern "C"

#include <iadm.h>
#include <icrypt.hxx>
#include <secdat.hxx>


//
// Private constants.
//

#define FREE_BLOB(blob)                                                 \
            if( blob != NULL ) {                                        \
                HRESULT _res;                                           \
                _res = ::IISCryptoFreeBlob( blob );                     \
                DBG_ASSERT( SUCCEEDED(_res) );                          \
            } else

#if DBG
#define ENABLE_ADM_COUNTERS 1
#define ADM_NOISY           0
#else
#define ENABLE_ADM_COUNTERS 0
#define ADM_NOISY           0
#endif

#if ADM_NOISY
#define NOISYPRINTF(x) DBGPRINTF(x)
#else
#define NOISYPRINTF(x)
#endif


//
// Private types.
//

#if ENABLE_ADM_COUNTERS

typedef struct _ADM_COUNTERS {
    LONG ObjectsCreated;
    LONG ObjectsDestroyed;
} ADM_COUNTERS, *PADM_COUNTERS;

#define DECLARE_ADM_COUNTERS() ADM_COUNTERS g_AdmCounters

#define UpdateObjectsCreated() InterlockedIncrement( &g_AdmCounters.ObjectsCreated )
#define UpdateObjectsDestroyed() InterlockedIncrement( &g_AdmCounters.ObjectsDestroyed )

#else

#define DECLARE_ADM_COUNTERS()

#define UpdateObjectsCreated()
#define UpdateObjectsDestroyed()

#endif


//
// Private globals.
//

LIST_ENTRY ADM_SECURE_DATA::sm_SecureDataListHead;
CRITICAL_SECTION ADM_SECURE_DATA::sm_SecureDataLock;
#if DBG
DWORD ADM_SECURE_DATA::sm_SecureDataLockOwner;
PTRACE_LOG ADM_SECURE_DATA::sm_RefTraceLog;
#endif
HCRYPTPROV ADM_SECURE_DATA::sm_ServerCryptoProvider;
HCRYPTPROV ADM_SECURE_DATA::sm_ClientCryptoProvider;

DECLARE_ADM_COUNTERS();


//
// ADM_SECURE_DATA methods.
//


ADM_SECURE_DATA::ADM_SECURE_DATA(
    IN IUnknown * Object
    ) :
    m_Object( Object ),
    m_KeyExchangeClient( NULL ),
    m_KeyExchangeServer( NULL ),
    m_SendCryptoStorage( NULL ),
    m_ReceiveCryptoStorage( NULL ),
    m_ReferenceCount( 1 )
/*++

Routine Description:

    ADM_SECURE_DATA object constructor.

Arguments:

    Object - Pointer to the object to associate.

Return Value:

    None.

--*/
{

    NOISYPRINTF((
        DBG_CONTEXT,
        "ADM_SECURE_DATA: creating %08lx,%08lx\n",
        this,
        Object
        ));

    //
    // Sanity check.
    //

    DBG_ASSERT( Object != NULL );

    //
    // Initialize any complex data members.
    //

    InitializeCriticalSection( &m_ObjectLock );

    //
    // Put ourselves on the list.
    //

    AcquireDataLock();
    InsertHeadList( &sm_SecureDataListHead, &m_SecureDataListEntry );
    ReleaseDataLock();

    UpdateObjectsCreated();

}   // ADM_SECURE_DATA::ADM_SECURE_DATA


ADM_SECURE_DATA::~ADM_SECURE_DATA()
/*++

Routine Description:

    ADM_SECURE_DATA object destructor.

Arguments:

    None.

Return Value:

    None.

--*/
{

    NOISYPRINTF((
        DBG_CONTEXT,
        "~ADM_SECURE_DATA: destroying %08lx,%08lx\n",
        this,
        m_Object
        ));

    //
    // Sanity check.
    //

    DBG_ASSERT( m_ReferenceCount == 0 );

    //
    // Cleanup.
    //

    m_Object = NULL;

    CleanupCryptoData();

    AcquireDataLock();
    RemoveEntryList( &m_SecureDataListEntry );
    ReleaseDataLock();

    DeleteCriticalSection( &m_ObjectLock );
    UpdateObjectsDestroyed();

}   // ADM_SECURE_DATA::~ADM_SECURE_DATA


BOOL
ADM_SECURE_DATA::Initialize(
    HINSTANCE hDll
    )
/*++

Routine Description:

    Initializes static global data private to ADM_SECURE_DATA.

Arguments:

    hDll - Handle to this DLL.

Return Value:

    None.

--*/
{

    HRESULT result;

    //
    // Initialize the crypto stuff.
    //

    result = ::IISCryptoInitialize();

    if( SUCCEEDED(result) ) {

        InitializeCriticalSection( &sm_SecureDataLock );

#if DBG
        sm_SecureDataLockOwner = 0;
        sm_RefTraceLog = CreateRefTraceLog( 1024, 0 );
#endif

        InitializeListHead( &sm_SecureDataListHead );

    } else {
        DBGPRINTF((
            DBG_CONTEXT,
            "ADM_SECURE_DATA::Initialize: error %lx\n",
            result
            ));
    }

    return SUCCEEDED(result);

}   // ADM_SECURE_DATA::Initialize


VOID
ADM_SECURE_DATA::Terminate()
/*++

Routine Description:

    Terminates static global data private to ADM_SECURE_DATA.

Arguments:

    None.

Return Value:

    None.

--*/
{

    PLIST_ENTRY entry;
    ADM_SECURE_DATA * data;
    HRESULT result;

    //
    // Free any secure data objects on our list.
    //

    AcquireDataLock();

    entry = sm_SecureDataListHead.Flink;

    while( entry != &sm_SecureDataListHead ) {

        data = CONTAINING_RECORD(
                   entry,
                   ADM_SECURE_DATA,
                   m_SecureDataListEntry
                   );
        entry = entry->Flink;

        data->Dereference();

    }

    ReleaseDataLock();

    DBG_ASSERT( IsListEmpty( &sm_SecureDataListHead ) );

    //
    // Terminate the crypto stuff.
    //

    if( sm_ServerCryptoProvider != CRYPT_NULL ) {
        result = ::IISCryptoCloseContainer( sm_ServerCryptoProvider );
        DBG_ASSERT( SUCCEEDED(result) );
        sm_ServerCryptoProvider = CRYPT_NULL;
    }

    if( sm_ClientCryptoProvider != CRYPT_NULL ) {
        result = ::IISCryptoCloseContainer( sm_ClientCryptoProvider );
        DBG_ASSERT( SUCCEEDED(result) );
        sm_ClientCryptoProvider = CRYPT_NULL;
    }

    result = ::IISCryptoTerminate();
    DBG_ASSERT( SUCCEEDED(result) );

    //
    // Final cleanup.
    //

    DeleteCriticalSection( &sm_SecureDataLock );

#if DBG
    if( sm_RefTraceLog != NULL ) {
        DestroyRefTraceLog( sm_RefTraceLog );
    }
#endif

}   // ADM_SECURE_DATA::Terminate


ADM_SECURE_DATA *
ADM_SECURE_DATA::FindAndReferenceSecureData(
    IN IUnknown * Object,
    IN BOOL CreateIfNotFound
    )
/*++

Routine Description:

    Finds the ADM_SECURE_DATA object associated with Object. If it
    cannot be found, then a new ADM_SECURE_DATA object is created
    and put on the global list.

Arguments:

    Object - The object to search for.

    CreateIfNotFound - If the object is not on the list, a new association
        will only be created if this flag is TRUE.

Return Value:

    ADM_SECURE_DATA * - Pointer to the ADM_SECURE_DATA object if
        successful, NULL otherwise.

--*/
{

    PLIST_ENTRY entry;
    ADM_SECURE_DATA * data;

    AcquireDataLock();

    for( entry = sm_SecureDataListHead.Flink ;
         entry != &sm_SecureDataListHead ;
         entry = entry->Flink ) {

        data = CONTAINING_RECORD(
                   entry,
                   ADM_SECURE_DATA,
                   m_SecureDataListEntry
                   );

        if( data->m_Object == Object ) {

            data->Reference();
            ReleaseDataLock();
            return data;

        }

    }

    if( CreateIfNotFound ) {

        data = new ADM_SECURE_DATA( Object );

        if( data == NULL ) {

            DBGPRINTF((
                DBG_CONTEXT,
                "ADM_SECURE_DATA::FindAndReferenceSecureData: out of memory\n"
                ));

        } else {

            data->Reference();

        }

    } else {

        data = NULL;
    }

    ReleaseDataLock();
    return data;

}   // ADM_SECURE_DATA::FindAndReferenceSecureData


HRESULT
ADM_SECURE_DATA::GetClientSendCryptoStorage(
    OUT IIS_CRYPTO_STORAGE ** SendCryptoStorage
    )
/*++

Routine Description:

    Retrieves the client-side IIS_CRYPTO_STORAGE object to be used for
    sending data to the server. This routine will perform the client-side
    key exchange if necessary.

Arguments:

    SendCryptoStorage - Receives a pointer to the newly created
        IIS_CRYPTO_STORAGE object if successful.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( SendCryptoStorage != NULL );

    //
    // Do that key exchange thang if we don't yet have it.
    //

    if( m_KeyExchangeClient == NULL ) {

        LockThis();

        if( m_KeyExchangeClient == NULL ) {

            result = DoClientSideKeyExchange();

            if( FAILED(result) ) {

                UnlockThis();
                return result;

            }

        }

        UnlockThis();

    }

    DBG_ASSERT( m_SendCryptoStorage != NULL );

    *SendCryptoStorage = m_SendCryptoStorage;
    return NO_ERROR;

}   // ADM_SECURE_DATA::GetClientSendCryptoStorage


HRESULT
ADM_SECURE_DATA::GetClientReceiveCryptoStorage(
    OUT IIS_CRYPTO_STORAGE ** ReceiveCryptoStorage
    )
/*++

Routine Description:

    Retrieves the client-side IIS_CRYPTO_STORAGE object to be used for
    receiving data from the server. This routine will perform the
    client-side key exchange if necessary.

Arguments:

    ReceiveCryptoStorage - Receives a pointer to the newly created
        IIS_CRYPTO_STORAGE object if successful.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( ReceiveCryptoStorage != NULL );

    //
    // Do that key exchange thang if we don't yet have it.
    //

    if( m_KeyExchangeClient == NULL ) {

        LockThis();

        if( m_KeyExchangeClient == NULL ) {

            result = DoClientSideKeyExchange();

            if( FAILED(result) ) {

                UnlockThis();
                return result;

            }

        }

        UnlockThis();

    }

    DBG_ASSERT( m_ReceiveCryptoStorage != NULL );

    *ReceiveCryptoStorage = m_ReceiveCryptoStorage;
    return NO_ERROR;

}   // ADM_SECURE_DATA::GetClientReceiveCryptoStorage


HRESULT
ADM_SECURE_DATA::GetServerSendCryptoStorage(
    OUT IIS_CRYPTO_STORAGE ** SendCryptoStorage
    )
/*++

Routine Description:

    Retrieves the server-side IIS_CRYPTO_STORAGE object to be used for
    sending data to the client.

Arguments:

    SendCryptoStorage - Receives a pointer to the newly created
        IIS_CRYPTO_STORAGE object if successful.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    if( m_SendCryptoStorage != NULL ) {

        *SendCryptoStorage = m_SendCryptoStorage;
        return NO_ERROR;

    }

    return MD_ERROR_SECURE_CHANNEL_FAILURE;

}   // ADM_SECURE_DATA::GetServerSendCryptoStorage


HRESULT
ADM_SECURE_DATA::GetServerReceiveCryptoStorage(
    OUT IIS_CRYPTO_STORAGE ** ReceiveCryptoStorage
    )
/*++

Routine Description:

    Retrieves the server-side IIS_CRYPTO_STORAGE object to be used for
    receiving data from the client.

Arguments:

    ReceiveCryptoStorage - Receives a pointer to the newly created
        IIS_CRYPTO_STORAGE object if successful.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    if( m_ReceiveCryptoStorage != NULL ) {

        *ReceiveCryptoStorage = m_ReceiveCryptoStorage;
        return NO_ERROR;

    }

    return MD_ERROR_SECURE_CHANNEL_FAILURE;

}   // ADM_SECURE_DATA::GetServerReceiveCryptoStorage


HRESULT
ADM_SECURE_DATA::DoClientSideKeyExchange()
/*++

Routine Description:

    Performs all the client-side magic necessary to exchange session
    keys with the server.

Arguments:

    None.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result;
    HCRYPTPROV prov;
    IIS_CRYPTO_EXCHANGE_CLIENT * keyExchangeClient;
    PIIS_CRYPTO_BLOB clientKeyExchangeKeyBlob;
    PIIS_CRYPTO_BLOB clientSignatureKeyBlob;
    PIIS_CRYPTO_BLOB clientSessionKeyBlob;
    PIIS_CRYPTO_BLOB clientHashBlob;
    PIIS_CRYPTO_BLOB serverKeyExchangeKeyBlob;
    PIIS_CRYPTO_BLOB serverSignatureKeyBlob;
    PIIS_CRYPTO_BLOB serverSessionKeyBlob;
    PIIS_CRYPTO_BLOB serverHashBlob;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_Object != NULL );
    DBG_ASSERT( m_KeyExchangeClient == NULL );
    DBG_ASSERT( m_SendCryptoStorage == NULL );
    DBG_ASSERT( m_ReceiveCryptoStorage == NULL );

    //
    // Setup locals so we know how to cleanup on exit.
    //

    keyExchangeClient = NULL;
    clientKeyExchangeKeyBlob = NULL;
    clientSignatureKeyBlob = NULL;
    clientSessionKeyBlob = NULL;
    clientHashBlob = NULL;
    serverKeyExchangeKeyBlob = NULL;
    serverSignatureKeyBlob = NULL;
    serverSessionKeyBlob = NULL;
    serverHashBlob = NULL;

    //
    // Get the crypto provider to use.
    //

    DBG_CODE( prov = CRYPT_NULL );

    result = GetClientCryptoProvider( &prov );

    if( FAILED(result) ) {
        goto cleanup;
    }

    DBG_ASSERT( prov != CRYPT_NULL );

    //
    // Create & initialize the client-side key exchange object.
    //
    // N.B. Do not set the m_KeyExchangeClient to a non-NULL value
    // until key exchange is complete.
    //

    keyExchangeClient = new IIS_CRYPTO_EXCHANGE_CLIENT;

    if( keyExchangeClient == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    result = keyExchangeClient->Initialize(
                 prov,                      // hProv
                 CRYPT_NULL,                // hKeyExchangeKey
                 CRYPT_NULL,                // hSignatureKey
                 FALSE                      // fUseMachineKeyset
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Phase 1: Get the client's key exchange and signature key blobs,
    // send them to the server, and get the server's key exchange,
    // signature, and session key blobs.
    //

    result = keyExchangeClient->ClientPhase1(
                 &clientKeyExchangeKeyBlob,
                 &clientSignatureKeyBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    result = IMSAdminBaseA_R_KeyExchangePhase1_Proxy(
                 (IMSAdminBase *)m_Object,
                 clientKeyExchangeKeyBlob,
                 clientSignatureKeyBlob,
                 &serverKeyExchangeKeyBlob,
                 &serverSignatureKeyBlob,
                 &serverSessionKeyBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Phase 2: Import the server's key exchange, signature, and session
    // key blobs, get the client's session key and hash blobs, send them
    // to the server, and get the server's hash blob.
    //

    result = keyExchangeClient->ClientPhase2(
                 serverKeyExchangeKeyBlob,
                 serverSignatureKeyBlob,
                 serverSessionKeyBlob,
                 &clientSessionKeyBlob,
                 &clientHashBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    result = IMSAdminBaseA_R_KeyExchangePhase2_Proxy(
                 (IMSAdminBase *)m_Object,
                 clientSessionKeyBlob,
                 clientHashBlob,
                 &serverHashBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Phase 3: Import the server's hash blob.
    //

    result = keyExchangeClient->ClientPhase3(
                 serverHashBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // OK, the key exchange is complete. We just need to create the
    // appropriate storage objects.
    //

    m_SendCryptoStorage = new IIS_CRYPTO_STORAGE;

    if( m_SendCryptoStorage == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    result = m_SendCryptoStorage->Initialize(
                 keyExchangeClient->QueryProviderHandle(),      // hProv
                 keyExchangeClient->AssumeClientSessionKey(),   // hSessionKey
                 CRYPT_NULL,                                    // hKeyExchangeKey
                 CRYPT_NULL,                                    // hSignatureKey
                 FALSE                                          // fUseMachineKeyset
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    m_ReceiveCryptoStorage = new IIS_CRYPTO_STORAGE;

    if( m_ReceiveCryptoStorage == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    result = m_ReceiveCryptoStorage->Initialize(
                 keyExchangeClient->QueryProviderHandle(),        // hProv
                 keyExchangeClient->AssumeServerSessionKey(),     // hSessionKey
                 CRYPT_NULL,                                      // hKeyExchangeKey
                 keyExchangeClient->AssumeServerSignatureKey(),   // hSignatureKey
                 FALSE                                            // fUseMachineKeyset
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Success!
    //

    m_KeyExchangeClient = keyExchangeClient;

cleanup:

    //
    // Free any blobs we allocated.
    //

    FREE_BLOB( clientKeyExchangeKeyBlob );
    FREE_BLOB( clientSignatureKeyBlob );
    FREE_BLOB( clientSessionKeyBlob );
    FREE_BLOB( clientHashBlob );
    FREE_BLOB( serverKeyExchangeKeyBlob );
    FREE_BLOB( serverSignatureKeyBlob );
    FREE_BLOB( serverSessionKeyBlob );
    FREE_BLOB( serverHashBlob );

    //
    // If we're failing the call, then free the associated objects we
    // created.
    //

    if( FAILED(result) ) {

        delete keyExchangeClient;
        CleanupCryptoData();

    }

    return result;

}   // ADM_SECURE_DATA::DoClientSideKeyExchange


HRESULT
ADM_SECURE_DATA::DoServerSideKeyExchangePhase1(
    IN PIIS_CRYPTO_BLOB pClientKeyExchangeKeyBlob,
    IN PIIS_CRYPTO_BLOB pClientSignatureKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerKeyExchangeKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerSignatureKeyBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerSessionKeyBlob
    )
/*++

Routine Description:

    Performs the first phase of server-side key exchange.

Arguments:

    pClientKeyExchangeKeyBlob - The client-side key exchange key blob.

    pClientSignatureKeyBlob - The client-side signature key blob.

    ppServerKeyExchangeKeyBlob - Receives a pointer to the server-side
        key exchange key blob if successful.

    ppServerSignatureKeyBlob - Receives a pointer to the server-side
        signature key blob if successful.

    ppServerSessionKeyBlob - Receives a pointer to the server-side session
        key blob if successful.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result;
    HCRYPTPROV prov;
    IIS_CRYPTO_EXCHANGE_SERVER * keyExchangeServer;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_Object != NULL );
    DBG_ASSERT( m_KeyExchangeServer == NULL );
    DBG_ASSERT( m_SendCryptoStorage == NULL );
    DBG_ASSERT( m_ReceiveCryptoStorage == NULL );
    DBG_ASSERT( pClientKeyExchangeKeyBlob != NULL );
    DBG_ASSERT( pClientSignatureKeyBlob != NULL );
    DBG_ASSERT( ppServerKeyExchangeKeyBlob != NULL );
    DBG_ASSERT( ppServerSignatureKeyBlob != NULL );
    DBG_ASSERT( ppServerSessionKeyBlob != NULL );

    //
    // Setup locals so we know how to cleanup on exit.
    //

    keyExchangeServer = NULL;

    //
    // Get the crypto provider to use.
    //

    DBG_CODE( prov = CRYPT_NULL );

    result = GetServerCryptoProvider( &prov );

    if( FAILED(result) ) {
        goto cleanup;
    }

    DBG_ASSERT( prov != CRYPT_NULL );

    //
    // Create & initialize the server-side key exchange object.
    //
    // N.B. Do not set the m_KeyExchangeServer to a non-NULL value
    // until key exchange is complete.
    //

    keyExchangeServer = new IIS_CRYPTO_EXCHANGE_SERVER;

    if( keyExchangeServer == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    result = keyExchangeServer->Initialize(
                 prov,                      // hProv
                 CRYPT_NULL,                // hKeyExchangeKey
                 CRYPT_NULL,                // hSignatureKey
                 FALSE                      // fUseMachineKeyset
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Do the first phase of the key exchange.
    //

    result = keyExchangeServer->ServerPhase1(
                 pClientKeyExchangeKeyBlob,
                 pClientSignatureKeyBlob,
                 ppServerKeyExchangeKeyBlob,
                 ppServerSignatureKeyBlob,
                 ppServerSessionKeyBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Success!
    //

    m_KeyExchangeServer = keyExchangeServer;

cleanup:

    //
    // If we're failing the call, then free the associated objects we
    // created.
    //

    if( FAILED(result) ) {

        delete keyExchangeServer;

    }

    return result;

}   // ADM_SECURE_DATA::DoServerSideKeyExchangePhase1


HRESULT
ADM_SECURE_DATA::DoServerSideKeyExchangePhase2(
    IN PIIS_CRYPTO_BLOB pClientSessionKeyBlob,
    IN PIIS_CRYPTO_BLOB pClientHashBlob,
    OUT PIIS_CRYPTO_BLOB * ppServerHashBlob
    )
/*++

Routine Description:

    Performs the second phase of server-side key exchange.

Arguments:

    pClientSessionKeyBlob - The client-side session key blob.

    pClientHashBlob - The client-side hash blob.

    ppServerHashBlob - Receives a pointer to the server-side hash blob
        if successful.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result;

    //
    // Sanity check.
    //

    DBG_ASSERT( m_Object != NULL );
    DBG_ASSERT( m_KeyExchangeServer != NULL );
    DBG_ASSERT( m_SendCryptoStorage == NULL );
    DBG_ASSERT( m_ReceiveCryptoStorage == NULL );
    DBG_ASSERT( pClientSessionKeyBlob != NULL );
    DBG_ASSERT( pClientHashBlob != NULL );
    DBG_ASSERT( ppServerHashBlob != NULL );

    //
    // Do the second phase of the key exchange.
    //

    result = m_KeyExchangeServer->ServerPhase2(
                 pClientSessionKeyBlob,
                 pClientHashBlob,
                 ppServerHashBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // OK, the key exchange is complete. We just need to create the
    // appropriate storage objects.
    //

    m_SendCryptoStorage = new IIS_CRYPTO_STORAGE;

    if( m_SendCryptoStorage == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    result = m_SendCryptoStorage->Initialize(
                 m_KeyExchangeServer->QueryProviderHandle(),    // hProv
                 m_KeyExchangeServer->AssumeServerSessionKey(), // hSessionKey
                 CRYPT_NULL,                                    // hKeyExchangeKey
                 CRYPT_NULL,                                    // hSignatureKey
                 FALSE                                          // fUseMachineKeyset
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    m_ReceiveCryptoStorage = new IIS_CRYPTO_STORAGE;

    if( m_ReceiveCryptoStorage == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    result = m_ReceiveCryptoStorage->Initialize(
                 m_KeyExchangeServer->QueryProviderHandle(),      // hProv
                 m_KeyExchangeServer->AssumeClientSessionKey(),   // hSessionKey
                 CRYPT_NULL,                                      // hKeyExchangeKey
                 m_KeyExchangeServer->AssumeClientSignatureKey(), // hSignatureKey
                 FALSE                                            // fUseMachineKeyset
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Success!
    //

cleanup:

    //
    // If we're failing the call, then free the associated objects we
    // created.
    //

    if( FAILED(result) ) {

        CleanupCryptoData();

    }

    return result;

}   // ADM_SECURE_DATA::DoServerSideKeyExchangePhase2


HRESULT
ADM_SECURE_DATA::GetCryptoProviderHelper(
    OUT HCRYPTPROV * UserProvider,
    OUT HCRYPTPROV * CachedProvider,
    IN DWORD CryptoFlags
    )
/*++

Routine Description:

    Helper routine for GetServerCryptoProvider and GetClientCryptoProvider().
    Provides necessary locking to ensure exactly one provider of each type
    is opened.

Arguments:

    UserProvider - Receives the handle to the provider.

    CachedProvider - Also receives the handle to the provider.

    CryptoFlags - Flags to pass into IISCryptoGetStandardContainer().

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result = NO_ERROR;
    HANDLE token = NULL;
    LONG forcedFlags = 0;
    HCRYPTPROV hprov;

    //
    // Sanity check.
    //

    DBG_ASSERT( UserProvider != NULL );
    DBG_ASSERT( CachedProvider != NULL );

    LockThis();

    hprov = *CachedProvider;

    if( hprov == CRYPT_NULL ) {

        //
        // Before we can get the provider, we must play some security
        // games.
        //
        // The problem is that an ISAPI application (like, say, ASP)
        // could be trying to access metadata via the ADMCOM object.
        // In this situation, the current thread is impersonating a
        // logged-on user, and that logged-on user probably doesn't have
        // access to the necessary Win32 crypto registry keys. And,
        // without access to these keys, we cannot establish a secure
        // channel for the DCOM object.
        //
        // This is the infamous Sophia Bug.
        //
        // The solution implemented here is to get the current thread's
        // impersonation token. If that token is !NULL, then set the
        // token to NULL ("revert to self") before calling the crypto
        // APIs. After calling the crypto APIs, reset the impersonation
        // token to its original value.
        //
        // We'll start by retrieving the current impersonation token.
        //

        result = GetThreadImpersonationToken( &token );

        if( SUCCEEDED(result) ) {

            //
            // If we actually have a token, then force the "machine
            // keyset flag" in the crypto flags, then remove the
            // impersonation token from this thread before calling
            // the crypto routines.
            //

            if( token != NULL ) {
                forcedFlags |= CRYPT_MACHINE_KEYSET;
                result = SetThreadImpersonationToken( NULL );
            }

            if( SUCCEEDED(result) ) {

                result = ::IISCryptoGetStandardContainer(
                               &hprov,
                               CryptoFlags | forcedFlags
                               );

                //
                // It's possible that the current thread had an
                // impersonation token, but the current process is
                // not a service (i.e. it's not running in the local
                // system context).
                //
                // If the above call failed with NET_BAD_KEYSET (which,
                // in this context, generally means the current thread
                // did not have access to the necessary parts of the
                // registry) AND we forced the CRYPT_MACHINE_KEYSET flag
                // because of the impersonation token AND the caller
                // didn't ask for the CRYPT_MACHINE_KEYSET flag, then
                // retry the call without the CRYPT_MACHINE_KEYSET flag.
                //

                if( result == NTE_BAD_KEYSET &&
                    ( ( forcedFlags & CRYPT_MACHINE_KEYSET ) != 0 ) &&
                    ( ( CryptoFlags & CRYPT_MACHINE_KEYSET ) == 0 ) ) {

                    result = ::IISCryptoGetStandardContainer(
                                   &hprov,
                                   CryptoFlags
                                   );

                }

            }

            if( token != NULL ) {

                HRESULT result2;

                //
                // The thread had an impersonation token before we
                // removed it, so restore it now. If the restoration
                // fails, we're in trouble.
                //

                result2 = SetThreadImpersonationToken( token );

                if( FAILED(result2) ) {

                    //
                    // This is really, really, really bad news. The current
                    // thread, which does not have an impersonation token
                    // (and is therefore running in the system context)
                    // cannot reset its impersonation token to the original
                    // value.
                    //

                    DBG_ASSERT( !"SetThreadImpersonationToken() failed!!!" );

                }

                //
                // Regardless of the completion status, we must close
                // the token handle before proceeding.
                //

                DBG_REQUIRE( CloseHandle( token ) );

            }

        }

    }

    if( SUCCEEDED(result) ) {
        DBG_ASSERT( hprov != CRYPT_NULL );
        *CachedProvider = hprov;
        *UserProvider = hprov;
    }

    UnlockThis();
    return result;

}   // ADM_SECURE_DATA::GetCryptoProviderHelper


HRESULT
ADM_SECURE_DATA::GetThreadImpersonationToken(
    OUT HANDLE * Token
    )
/*++

Routine Description:

    Gets the impersonation token for the current thread.

Arguments:

    Token - Receives a handle to the impersonation token if successful.
        If successful, it is the caller's responsibility to CloseHandle()
        the token when no longer needed.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result = NO_ERROR;

    DBG_ASSERT( Token != NULL );

    //
    // Open the token.
    //

    if( !OpenThreadToken(
            GetCurrentThread(),
            TOKEN_ALL_ACCESS,
            TRUE,
            Token
            ) ) {

        DWORD err = GetLastError();

        //
        // There are a couple of "expected" errors here:
        //
        //     ERROR_NO_TOKEN - The thread has no impersonation token.
        //     ERROR_CALL_NOT_IMPLEMENTED - We're probably on Win9x.
        //     ERROR_NOT_SUPPORTED - Ditto.
        //
        // If OpenThreadToken() failed with any of the above error codes,
        // then succeed the call, but return a NULL token handle.
        //

        if( err != ERROR_NO_TOKEN &&
            err != ERROR_CALL_NOT_IMPLEMENTED &&
            err != ERROR_NOT_SUPPORTED ) {

            result = HRESULT_FROM_WIN32(err);

        }

        *Token = NULL;
    }

    return result;

}   // ADM_SECURE_DATA::GetThreadImpersonationToken


HRESULT
ADM_SECURE_DATA::SetThreadImpersonationToken(
    IN HANDLE Token
    )
/*++

Routine Description:

    Sets the impersonation token for the current thread.

Arguments:

    Token - A handle to the impersonation token.

Return Value:

    HRESULT - 0 if successful, !0 otherwise.

--*/
{

    HRESULT result = NO_ERROR;

    //
    // Set it.
    //

    if( !SetThreadToken(
            NULL,
            Token
            ) ) {
        DWORD err = GetLastError();
        result = HRESULT_FROM_WIN32(err);
    }

    return result;

}   // ADM_SECURE_DATA::SetThreadImpersonationToken


VOID
ADM_SECURE_DATA::CleanupCryptoData()
/*++

Routine Description:

    Frees any crypto data associated with the current object.

Arguments:

    None.

Return Value:

    None.

--*/
{

    delete m_KeyExchangeClient;
    m_KeyExchangeClient = NULL;

    delete m_KeyExchangeServer;
    m_KeyExchangeServer = NULL;

    delete m_SendCryptoStorage;
    m_SendCryptoStorage = NULL;

    delete m_ReceiveCryptoStorage;
    m_ReceiveCryptoStorage = NULL;

}   // ADM_SECURE_DATA::CleanupCryptoData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\ansimeta.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       ansimeta.h

   Abstract:

        WRAPPER functions for ANSI calls of UNICODE ADMCOM interface

   Environment:

      Win32 User Mode

   Author:

      jaroslad  (jan 1997)

--*/

#ifndef _ANSIMETA__H
#define _ANSIMETA__H

#include <tchar.h>
#include <afx.h>

#include <iadmw.h>




class ANSI_smallIMSAdminBase
    {

        
    public:
		IMSAdminBase * m_pcAdmCom;   //interface pointer to Metabase Admin

		ANSI_smallIMSAdminBase (){m_pcAdmCom=0;};

	  void SetInterfacePointer(IMSAdminBase * a_pcAdmCom) {a_pcAdmCom = m_pcAdmCom;}
          virtual HRESULT STDMETHODCALLTYPE AddKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) ;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) ;
        
        
        virtual HRESULT STDMETHODCALLTYPE EnumKeys( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
            /* [in] */ DWORD dwMDEnumObjectIndex) ;
        
        virtual HRESULT STDMETHODCALLTYPE CopyKey( 
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ BOOL bMDOverwriteFlag,
            /* [in] */ BOOL bMDCopyFlag) ;
        
        virtual HRESULT STDMETHODCALLTYPE RenameKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName) ;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ PMETADATA_RECORD pmdrMDData) ;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) ;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType) ;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE EnumData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [in] */ DWORD dwMDEnumDataIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) ;
        
        
        virtual HRESULT STDMETHODCALLTYPE CopyData( 
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ BOOL bMDCopyFlag) ;
        
        virtual HRESULT STDMETHODCALLTYPE OpenKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDAccessRequested,
            /* [in] */ DWORD dwMDTimeOut,
            /* [out] */ PMETADATA_HANDLE phMDNewHandle) ;
        
        virtual HRESULT STDMETHODCALLTYPE CloseKey( 
            /* [in] */ METADATA_HANDLE hMDHandle) ;
        
        
        virtual HRESULT STDMETHODCALLTYPE SaveData( void) ;
        
     };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\admutil.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       admutil.cpp

   Abstract:

        IMSAdminBase interface WRAPPER functions definition

   Environment:

      Win32 User Mode

   Author:

          jaroslad  (jan 1997)

--*/


#if !defined (ADMUTIL_H)
#define ADMUTIL_H

#include <afx.h>
#ifdef UNICODE
	#include <iadmw.h>
#else
	#include "ansimeta.h"
#endif
#include <iwamreg.h>

class CAdmUtil;

//************************************************************************
//CAdmNode DEFINITION
//- store all the complex information about accessing MetaObject or MetaData


class CAdmNode
{
        CString strComputer; //computer to access
        CString strService;
        CString strInstance;
        CString strIPath; //path relative to instance
                                          //(/LM/{strService}/{strInstance}/{strIPath} gives the full path to MEtaObject
        CString strProperty; // name of the MetaData within given Path


        static INT              GetSlashIndex(const CString& strPath, INT iSeqNumber);
        static INT              GetCountOfSlashes(const CString& strPath);
        static CString  GetPartOfPath(const CString& strPath, INT iStart, INT iEnd=-1);

public:
        CAdmNode(const CString& a_strPath=CString("")) {SetPath(a_strPath);};
        void SetPath(CString a_strPath);

        //magic functions to provide various kinds of paths within metabase
        CString GetLMRootPath(void);
        CString GetLMServicePath(void);
        CString GetLMInstancePath(void);
        CString GetLMNodePath(void);
        CString GetServicePath(void);
        CString GetInstancePath(void);
        CString GetNodePath(void);
        CString GetRelPathFromService(void);
        CString GetRelPathFromInstance(void);

        CString GetParentNodePath(void);
        CString GetCurrentNodeName(void);

        //access to METADATA_RECORD items
        CString GetComputer(void)  {return strComputer;};
        CString GetService(void)  {return strService;};
        CString GetInstance(void)  {return strInstance;};
        CString GetIPath(void)  {return strIPath;};
        CString GetProperty(void)  {return strProperty;};

        //setting the METADATA_RECORD items
        void SetComputer(const CString& a_strComputer)  {strComputer=a_strComputer;};
        void SetService(const CString& a_strService)    {strService=a_strService;};
        void SetInstance(const CString& a_strInstance)  {strInstance=a_strInstance;};
        void SetIPath(const CString& a_strIPath)        {strIPath=a_strIPath;};
        void SetProperty(const CString& a_strProperty)  {strProperty=a_strProperty;};


        friend CAdmUtil;
};


//************************************************************************
//CAdmProp DEFINITION
//
// -convenience wrapper for METADATA_RECORD


class CAdmProp
{
        enum {USERTYPESET=0x01,DATATYPESET=0x02,ATTRIBSET=0x04}; //value indicates that the variable was not set
                                                           //0 cannot be used, because that is valid value
        METADATA_RECORD mdr;
        DWORD dwFlags;

public:
        CAdmProp(){dwFlags=0;mdr.dwMDIdentifier=0; mdr.dwMDAttributes=0; mdr.dwMDUserType=0;
                                        mdr.dwMDDataType=0;mdr.pbMDData=0; mdr.dwMDDataLen=0;};
        CAdmProp(METADATA_RECORD &a_mdr);
	CAdmProp(const CString &a_strProperty);
        void SetIdentifier(DWORD a_dwIdentif) {mdr.dwMDIdentifier=a_dwIdentif;};
        void SetAttrib(DWORD a_dwAttrib) {mdr.dwMDAttributes=a_dwAttrib;dwFlags|=ATTRIBSET;};
        void SetUserType(DWORD a_dwUserType) {mdr.dwMDUserType=a_dwUserType;dwFlags|=USERTYPESET;};
        void SetDataType(DWORD a_dwDataType) {mdr.dwMDDataType=a_dwDataType;dwFlags|=DATATYPESET;};

        BOOL IsSetAttrib(void)
                { return (((dwFlags&ATTRIBSET)!=0)?TRUE:FALSE); };
        BOOL IsSetUserType(void)
                {return (((dwFlags&USERTYPESET)!=0)?TRUE:FALSE); };
        BOOL IsSetDataType(void)
                {return (((dwFlags&DATATYPESET)!=0)?TRUE:FALSE); };


        DWORD GetAttrib(void) {return mdr.dwMDAttributes;};
        DWORD GetDataType(void) {return mdr.dwMDDataType;};
        DWORD GetUserType(void) {return mdr.dwMDUserType;};
        DWORD GetIdentifier(void) {return mdr.dwMDIdentifier;};
        PBYTE GetMDData(void) {return mdr.pbMDData;};
        DWORD GetMDDataLen(void) {return mdr.dwMDDataLen;};

        void SetValue(DWORD a_dwValue);
        void SetValue(CString a_strValue);
        void SetValue(LPCTSTR *a_lplpszValue, DWORD a_dwValueCount); //for multisz
        void SetValue(LPBYTE pbValue, DWORD dwValueLength ); //for binary
        BOOL SetValueByDataType(LPCTSTR *a_lplpszPropValue,DWORD* a_lpdwPropValueLength,WORD a_wPropValueCount);

        void PrintProperty(void);


        virtual void Print(const _TCHAR *format,...);


        friend CAdmUtil;
};

//************************************************************************
//CAdmUtil DEFINITION
//
//-convenience wrapper for calling IMSAdminBase interface functions

//defined in admutil.cpp
extern DWORD g_dwTIMEOUT_VALUE;
extern DWORD g_dwDELAY_AFTER_OPEN_VALUE;


class CAdmUtil
{
        static enum {
                DEFAULTBufferSize=4
        };

#ifdef UNICODE
        IMSAdminBase * pcAdmCom;   //interface pointer to Metabase Admin
#else
		ANSI_smallIMSAdminBase * pcAdmCom;   //interface pointer to Metabase Admin Ansi Wrapper
#endif
		IWamAdmin*	pIWamAdm; //interface pointer to Wam Admin
		IWamAdmin2*	pIWamAdm2; //interface pointer to Wam Admin

		METADATA_HANDLE m_hmd;    //metabase handle that micht be reused for sequence of commands
		CString m_strNodePath;    //related to m_hmd - if h_hmd!=NULL it points to m_strNodePath
		DWORD m_dwPermissionOfhmd; //related to m_hmd  

        PBYTE pbDataBuffer;   //buffer to get data from METABASE (used for METADATA_RECORD)
        WORD wDataBufferSize; //size of the above buffer
protected:
        BOOL fPrint ; //print Error messages
        HRESULT hresError;    //store the last HRESULT of calling interface IMSAdminBase interface function
                                                  // this is used to store some other error as is OUT_OF_MEMORY or INVALID_PARAMETER



        //with wIndex it is possible to open more than one METADATA object, opening multiple object is not available outside the class
        void OpenObject(WORD wIndex, LPCSTR lpszService,WORD wInstance, LPCSTR lpszPath, DWORD dwPermission=METADATA_PERMISSION_WRITE+METADATA_PERMISSION_READ, BOOL fCreate=TRUE);
        void CloseObject(WORD wIndex);

        METADATA_HANDLE OpenObjectTo_hmd(CAdmNode & a_AdmNode,
                        DWORD dwPermission=METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE,
                        BOOL fCreate=FALSE);
		void CloseObject_hmd(void);
      
public:
        CAdmUtil(const CString & strComputer=CString(""));
        ~CAdmUtil();
#ifdef UNICODE
		IMSAdminBase * GetpcAdmCom(void) {return pcAdmCom;}; 
#else
		IMSAdminBase * GetpcAdmCom(void) {return (pcAdmCom==0)?0:pcAdmCom->m_pcAdmCom;}; 
#endif

        //connect to computer, call class factory for IMSAdminBase
        void Open(const CString & strComputer);
        //close connection to computer, throw away IMSAdminBase
        void Close(void);


        //OPEN , CLOSE, CREATE, DELETE, COPY METAOBJECT
        METADATA_HANDLE OpenObject(CAdmNode & a_AdmNode,
                                                DWORD dwPermission=METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE,
                                                BOOL fCreate=FALSE);
        void CloseObject(METADATA_HANDLE hmd);
        void CreateObject(CAdmNode & a_AdmNode);
        void DeleteObject(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp);
        void DeleteObject(METADATA_HANDLE a_hmd, CString& a_strNodeNameToDelete);
        void CopyObject(CAdmNode&       a_AdmNode,  CAdmNode&   a_AdmNodeDst);
        void RenameObject(CAdmNode&     a_AdmNode,  CAdmNode&   a_AdmNodeDst);

        void GetProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp);

        void SetProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp);
        void SetProperty(PMETADATA_RECORD a_pmdrData, METADATA_HANDLE a_hmd);

        void DeleteProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp);
        void DeleteProperty(PMETADATA_RECORD a_pmdrData, METADATA_HANDLE a_hmd);

        //ENUMERATE
        void EnumPropertiesAndPrint(CAdmNode& a_AdmNode,
                                                                          CAdmProp a_AdmProp,
                                                                          BYTE bRecurLevel=0,
                                                                          METADATA_HANDLE a_hmd=0,
                                                                          CString & a_strRelPath=CString(""));
        void EnumAndPrint(CAdmNode&     a_AdmNode,
                                                        CAdmProp&       a_AdmProp,
                                                        BOOL            a_fRecursive=FALSE,
                                                        BYTE            a_bRecurLevel=0,
                                                        METADATA_HANDLE a_hmd=0,
                                                        CString&        a_strRelPath=CString(""));
        //SAVE METABASE DATA
        void SaveData(void);

        //FUNCTION TO RUN CHOSEN METABASE COMMAND WITH GIVEN PARAMATERS
        void Run(CString& strCommand,  //command to run
                         CAdmNode& a_AdmNode,        //PATH TO METABASE OBJECT
                         CAdmProp& a_AdmProp,        //METADATA object
                         CAdmNode& a_AdmDstNode=CAdmNode(""), //DESTINATION PATH (as used for COPY)
                         LPCTSTR *a_lplpszPropValue=0,   //VALUES TO BE STORED (for SET command)
                         DWORD *a_lpdwPropValueLength=0,        //LENGTH OF VALUES TO BE STORED (for SET command)
                         WORD wPropValueCount=0);       //NUMBER OF VALUES TO BE STORED

        //virtual functions for Error and regular messages to be printed.
        // these can be redefined in order to fit custom needs
        virtual void Error(const _TCHAR * format,...);
        virtual void Print(const _TCHAR * format,...);

        //Disable and enable to print error or regular messages
        void EnablePrint(void) {fPrint=TRUE;};
        void DisablePrint(void) {fPrint=FALSE;};

        HRESULT QueryLastHresError(void) {return hresError;};
        void SetLastHresError(HRESULT hr) {hresError=hr;};

	//defined in vptool
	void OpenWamAdm(const CString & strComputer);
	void CloseWamAdm(void);
	void AppCreateInProc(const _TCHAR* szPath,const CString & strComputer);
	void AppCreateOutPool(const _TCHAR* szPath,const CString & strComputer);
	void AppCreateOutProc(const _TCHAR* szPath,const CString & strComputer);
	void AppDelete(const _TCHAR* szPath,const CString & strComputer);
        void AppRename(CAdmNode& a_AdmNode, CAdmNode& a_AdmDstNode, const CString & strComputer);
	void AppUnLoad(const _TCHAR* szPath,const CString & strComputer);
	void AppGetStatus(const _TCHAR* szPath,const CString & strComputer);

};


//runs administration command based on given parameters



LPTSTR ConvertHresToString(HRESULT hRes);
DWORD ConvertHresToDword(HRESULT hRes);
LPTSTR ConvertReturnCodeToString(DWORD ReturnCode);

CString FindCommonPath(CString a_strPath1,CString a_strPath2);

#define M_LOCAL_MACHINE "/LM/"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\interfac\security.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    security.cxx

Abstract:

    This module contains the code necessary to implement secure DCOM data
    transfers on-the-wire. It includes the implementation of the "hooked"
    (call_as) methods from IMSAdminBase.

Author:

    Keith Moore (keithmo)       17-Feb-1997

Revision History:

--*/


extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ole2.h>
#include <windows.h>
#include <dbgutil.h>

}   // extern "C"

#include <iadm.h>
#include <icrypt.hxx>
#include <secdat.hxx>
#include <secpriv.h>


//
// Private constants.
//

#define ALLOC_MEM(cb) (LPVOID)::LocalAlloc( LPTR, (cb) )
#define FREE_MEM(ptr) (VOID)::LocalFree( (HLOCAL)(ptr) )

#if DBG
BOOL g_fEnableSecureChannel = TRUE;
#define ENABLE_SECURE_CHANNEL g_fEnableSecureChannel
#else
#define ENABLE_SECURE_CHANNEL TRUE
#endif


//
// Private prototypes.
//

VOID
CalculateGetAllBufferAttributes(
    IN PMETADATA_GETALL_RECORD Data,
    IN DWORD NumEntries,
    OUT DWORD * TotalBufferLength,
    OUT BOOL * IsBufferSecure
    );



HRESULT
STDMETHODCALLTYPE
IMSAdminBaseA_SetData_Proxy(
    IMSAdminBase __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData
    )
/*++

Routine Description:

    Set a data object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data to set

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * sendCrypto;
    PIIS_CRYPTO_BLOB dataBlob;
    METADATA_RECORD capturedRecord;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    sendCrypto = NULL;
    dataBlob = NULL;
    result = NO_ERROR;

    //
    // Capture the METADATA_RECORD so we can muck with it.
    //

    __try {
        capturedRecord = *pmdrMDData;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        result = HRESULT_FROM_NT( GetExceptionCode() );
    }

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // If this is a secure data item, then encrypt the data before
    // sending.
    //

    if( ENABLE_SECURE_CHANNEL &&
        capturedRecord.dwMDAttributes & METADATA_SECURE ) {

        //
        // Find an ADM_SECURE_DATA object for "This".
        //

        secureData = ADM_SECURE_DATA::FindAndReferenceSecureData(
                         This,
                         TRUE       // CreateIfNotFound
                         );

        if( secureData == NULL ) {
            result = MD_ERROR_SECURE_CHANNEL_FAILURE;
            goto cleanup;
        }

        //
        // Get the appropriate crypto storage object. This will perform
        // key exchange if necessary.
        //

        result = secureData->GetClientSendCryptoStorage( &sendCrypto );

        if( FAILED(result) ) {
            goto cleanup;
        }

        //
        // Protect ourselves from malicious users.
        //

        __try {

            //
            // Encrypt the data.
            //

            result = sendCrypto->EncryptData(
                         &dataBlob,
                         (PVOID)capturedRecord.pbMDData,
                         capturedRecord.dwMDDataLen,
                         0                                      // dwRegType
                         );

        } __except( EXCEPTION_EXECUTE_HANDLER ) {

            result = HRESULT_FROM_NT(GetExceptionCode());

        }

        if( FAILED(result) ) {
            goto cleanup;
        }

        //
        // Update the fields of the captured metadata record so the
        // RPC runtime will send the data to the server.
        //

        capturedRecord.pbMDData = (PBYTE)dataBlob;
        capturedRecord.dwMDDataLen = IISCryptoGetBlobLength( dataBlob );

    }

    //
    // Call through to the "real" remoted API to get this over to the
    // server.
    //

    result = IMSAdminBaseA_R_SetData_Proxy(
                 This,
                 hMDHandle,
                 pszMDPath,
                 &capturedRecord
                 );

cleanup:

    if( dataBlob != NULL ) {
        IISCryptoFreeBlob( dataBlob );
    }

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    return result;

}   // IMSAdminBaseA_SetData_Proxy


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseA_SetData_Stub(
    IMSAdminBase __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData
    )
/*++

Routine Description:

    Set a data object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data to set

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * recvCrypto;
    METADATA_RECORD capturedRecord;
    DWORD clearDataType;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    recvCrypto = NULL;
    result = NO_ERROR;

    //
    // Capture the metadata record so we can muck with it.
    //

    capturedRecord = *pmdrMDData;

    //
    // If this is a secure data item, then decrypt the data before
    // passing it to the actual implementation object.
    //

    if( ENABLE_SECURE_CHANNEL &&
        capturedRecord.dwMDAttributes & METADATA_SECURE ) {

        //
        // Find an ADM_SECURE_DATA object for "This".
        //

        secureData = ADM_SECURE_DATA::FindAndReferenceSecureData(
                         This,
                         TRUE       // CreateIfNotFound
                         );

        if( secureData == NULL ) {
            result = MD_ERROR_SECURE_CHANNEL_FAILURE;
            goto cleanup;
        }

        //
        // Get the appropriate crypto storage object.
        //

        result = secureData->GetServerReceiveCryptoStorage( &recvCrypto );

        if( FAILED(result) ) {
            goto cleanup;
        }

        //
        // Decrypt the data, then replace the pointer in the metadata
        // record.
        //

        result = recvCrypto->DecryptData(
                     (PVOID *)&capturedRecord.pbMDData,
                     &capturedRecord.dwMDDataLen,
                     &clearDataType,
                     (PIIS_CRYPTO_BLOB)capturedRecord.pbMDData
                     );


        if( FAILED(result) ) {
            goto cleanup;
        }

    }

    //
    // Call through to the "real" server stub to set the data.
    //

    result = This->SetData(
                 hMDHandle,
                 pszMDPath,
                 &capturedRecord
                 );

cleanup:

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    return result;

}   // IMSAdminBaseA_SetData_Stub


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseA_GetData_Proxy(
    IMSAdminBase __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen
    )
/*++

Routine Description:

    Get one metadata value

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data structure

    pdwMDRequiredDataLen - updated with required length

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * recvCrypto;
    PIIS_CRYPTO_BLOB dataBlob;
    METADATA_RECORD capturedRecord;
    PVOID dataBuffer;
    DWORD dataBufferLength;
    DWORD dataBufferType;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    recvCrypto = NULL;
    dataBlob = NULL;

    //
    // Find an ADM_SECURE_DATA object for "This".
    //

    secureData = ADM_SECURE_DATA::FindAndReferenceSecureData(
                     This,
                     TRUE       // CreateIfNotFound
                     );

    if( secureData == NULL ) {
        result = MD_ERROR_SECURE_CHANNEL_FAILURE;
        goto cleanup;
    }

    //
    // Get the appropriate crypto storage object. This will perform
    // key exchange if necessary.
    //

    result = secureData->GetClientReceiveCryptoStorage( &recvCrypto );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Capture the METADATA_RECORD so we can muck with it.
    //

    __try {
        capturedRecord = *pmdrMDData;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        result = HRESULT_FROM_NT( GetExceptionCode() );
    }

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Call through to the "real" remoted API to get the data from
    // the server. Note that we set the data pointer to NULL before
    // calling the remoted API. This prevents the RPC runtime from
    // sending plaintext data over to the server.
    //

    capturedRecord.pbMDData = NULL;

    result = IMSAdminBaseA_R_GetData_Proxy(
                 This,
                 hMDHandle,
                 pszMDPath,
                 &capturedRecord,
                 pdwMDRequiredDataLen,
                 &dataBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Decrypt the data if necessary. This method properly handles
    // cleartext (unencrypted) blobs.
    //

    result = recvCrypto->DecryptData(
                 &dataBuffer,
                 &dataBufferLength,
                 &dataBufferType,
                 dataBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Copy it back to the user.
    //

    __try {

        if( pmdrMDData->dwMDDataLen >= dataBufferLength ) {

            RtlCopyMemory(
                pmdrMDData->pbMDData,
                dataBuffer,
                dataBufferLength
                );

            pmdrMDData->dwMDDataLen = dataBufferLength;
            pmdrMDData->dwMDIdentifier = capturedRecord.dwMDIdentifier;
            pmdrMDData->dwMDAttributes = capturedRecord.dwMDAttributes;
            pmdrMDData->dwMDUserType = capturedRecord.dwMDUserType;
            pmdrMDData->dwMDDataType = capturedRecord.dwMDDataType;
            pmdrMDData->dwMDDataTag = capturedRecord.dwMDDataTag;

        } else {

            *pdwMDRequiredDataLen = dataBufferLength;
            result = RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );

        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        result = HRESULT_FROM_NT( GetExceptionCode() );

    }

    if( FAILED(result) ) {
        goto cleanup;
    }

cleanup:

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    if( dataBlob != NULL ) {
        ::IISCryptoFreeBlob( dataBlob );
    }

    return result;

}   // IMSAdminBaseA_GetData_Proxy


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseA_GetData_Stub(
    IMSAdminBase __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob
    )
/*++

Routine Description:

    Get one metadata value

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data structure

    pdwMDRequiredDataLen - updated with required length

    ppDataBlob - Receives a blob for the encrypted data.

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * sendCrypto;
    PIIS_CRYPTO_BLOB dataBlob;
    DWORD clearDataType;
    PVOID dataBuffer;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    sendCrypto = NULL;
    dataBuffer = NULL;
    dataBlob = NULL;

    //
    // Allocate a temporary memory block for the meta data. Use the
    // same size as the user passed into the API.
    //

    dataBuffer = ALLOC_MEM( pmdrMDData->dwMDDataLen );

    if( dataBuffer == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    pmdrMDData->pbMDData = (PBYTE)dataBuffer;

    //
    // Call through to the "real" server stub to get the data.
    //

    result = This->GetData(
                 hMDHandle,
                 pszMDPath,
                 pmdrMDData,
                 pdwMDRequiredDataLen
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // If this is a secure data item, then we'll need to encrypt it
    // before returning it to the client. Otherwise, we'll build a
    // cleartext blob to contain the data.
    //

    if( ENABLE_SECURE_CHANNEL &&
        pmdrMDData->dwMDAttributes & METADATA_SECURE ) {

        //
        // Find an ADM_SECURE_DATA object for "This".
        //

        secureData = ADM_SECURE_DATA::FindAndReferenceSecureData(
                         This,
                         TRUE       // CreateIfNotFound
                         );

        if( secureData == NULL ) {
            result = MD_ERROR_SECURE_CHANNEL_FAILURE;
            goto cleanup;
        }

        //
        // Get the appropriate crypto storage object.
        //

        result = secureData->GetServerSendCryptoStorage( &sendCrypto );

        if( FAILED(result) ) {
            goto cleanup;
        }

        //
        // Encrypt the data.
        //

        result = sendCrypto->EncryptData(
                     &dataBlob,
                     (PVOID)pmdrMDData->pbMDData,
                     pmdrMDData->dwMDDataLen,
                     0
                     );

        if( FAILED(result) ) {
            goto cleanup;
        }

    } else {

        result = ::IISCryptoCreateCleartextBlob(
                       &dataBlob,
                       (PVOID)pmdrMDData->pbMDData,
                       pmdrMDData->dwMDDataLen
                       );

        if( FAILED(result) ) {
            goto cleanup;
        }

    }

    //
    // Success!
    //

    DBG_ASSERT( SUCCEEDED(result) );
    *ppDataBlob = dataBlob;

cleanup:

    //
    // NULL the data pointer in the METADATA_RECORD so the RPC runtime
    // won't send the plaintext data back to the client.
    //

    pmdrMDData->pbMDData = NULL;

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    if( dataBuffer != NULL ) {
        FREE_MEM( dataBuffer );
    }

    if( FAILED(result) && dataBlob != NULL ) {
        ::IISCryptoFreeBlob( dataBlob );
    }

    return result;

}   // IMSAdminBaseA_GetData_Stub


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseA_EnumData_Proxy(
    IMSAdminBase __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen
    )
/*++

Routine Description:

    Enumerate properties of object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data structure

    pdwMDRequiredDataLen - updated with required length

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * recvCrypto;
    PIIS_CRYPTO_BLOB dataBlob;
    METADATA_RECORD capturedRecord;
    PVOID dataBuffer;
    DWORD dataBufferLength;
    DWORD dataBufferType;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    recvCrypto = NULL;
    dataBlob = NULL;

    //
    // Find an ADM_SECURE_DATA object for "This".
    //

    secureData = ADM_SECURE_DATA::FindAndReferenceSecureData(
                     This,
                     TRUE       // CreateIfNotFound
                     );

    if( secureData == NULL ) {
        result = MD_ERROR_SECURE_CHANNEL_FAILURE;
        goto cleanup;
    }

    //
    // Get the appropriate crypto storage object. This will perform
    // key exchange if necessary.
    //

    result = secureData->GetClientReceiveCryptoStorage( &recvCrypto );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Capture the METADATA_RECORD so we can muck with it.
    //

    __try {
        capturedRecord = *pmdrMDData;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        result = HRESULT_FROM_NT( GetExceptionCode() );
    }

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Call through to the "real" remoted API to get the data from
    // the server. Note that we set the data pointer to NULL before
    // calling the remoted API. This prevents the RPC runtime from
    // sending plaintext data over to the server.
    //

    capturedRecord.pbMDData = NULL;

    result = IMSAdminBaseA_R_EnumData_Proxy(
                 This,
                 hMDHandle,
                 pszMDPath,
                 &capturedRecord,
                 dwMDEnumDataIndex,
                 pdwMDRequiredDataLen,
                 &dataBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Decrypt the data if necessary. This method properly handles
    // cleartext (unencrypted) blobs.
    //

    result = recvCrypto->DecryptData(
                 &dataBuffer,
                 &dataBufferLength,
                 &dataBufferType,
                 dataBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Copy it back to the user.
    //

    __try {

        if( pmdrMDData->dwMDDataLen >= dataBufferLength ) {

            RtlCopyMemory(
                pmdrMDData->pbMDData,
                dataBuffer,
                dataBufferLength
                );

            pmdrMDData->dwMDDataLen = dataBufferLength;
            pmdrMDData->dwMDIdentifier = capturedRecord.dwMDIdentifier;
            pmdrMDData->dwMDAttributes = capturedRecord.dwMDAttributes;
            pmdrMDData->dwMDUserType = capturedRecord.dwMDUserType;
            pmdrMDData->dwMDDataType = capturedRecord.dwMDDataType;
            pmdrMDData->dwMDDataTag = capturedRecord.dwMDDataTag;

        } else {

            *pdwMDRequiredDataLen = dataBufferLength;
            result = RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );

        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        result = HRESULT_FROM_NT( GetExceptionCode() );

    }

    if( FAILED(result) ) {
        goto cleanup;
    }

cleanup:

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    if( dataBlob != NULL ) {
        ::IISCryptoFreeBlob( dataBlob );
    }

    return result;

}   // IMSAdminBaseA_EnumData_Proxy


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseA_EnumData_Stub(
    IMSAdminBase __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob
    )
/*++

Routine Description:

    Enumerate properties of object.

Arguments:

    hMDHandle - open handle

    pszMDPath - path of the meta object with which this data is associated

    pmdrMDData - data structure

    pdwMDRequiredDataLen - updated with required length

    ppDataBlob - Receives a blob for the encrypted data.

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * sendCrypto;
    PIIS_CRYPTO_BLOB dataBlob;
    METADATA_RECORD capturedRecord;
    DWORD clearDataType;
    PVOID dataBuffer;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    sendCrypto = NULL;
    dataBuffer = NULL;
    dataBlob = NULL;

    //
    // Allocate a temporary memory block for the meta data. Use the
    // same size as the user passed into the API.
    //

    dataBuffer = ALLOC_MEM( pmdrMDData->dwMDDataLen );

    if( dataBuffer == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    pmdrMDData->pbMDData = (PBYTE)dataBuffer;

    //
    // Call through to the "real" server stub to get the data.
    //

    result = This->EnumData(
                 hMDHandle,
                 pszMDPath,
                 pmdrMDData,
                 dwMDEnumDataIndex,
                 pdwMDRequiredDataLen
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // If this is a secure data item, then we'll need to encrypt it
    // before returning it to the client. Otherwise, we'll build a
    // cleartext blob to contain the data.
    //

    if( ENABLE_SECURE_CHANNEL &&
        pmdrMDData->dwMDAttributes & METADATA_SECURE ) {

        //
        // Find an ADM_SECURE_DATA object for "This".
        //

        secureData = ADM_SECURE_DATA::FindAndReferenceSecureData(
                         This,
                         TRUE       // CreateIfNotFound
                         );

        if( secureData == NULL ) {
            result = MD_ERROR_SECURE_CHANNEL_FAILURE;
            goto cleanup;
        }

        //
        // Get the appropriate crypto storage object.
        //

        result = secureData->GetServerSendCryptoStorage( &sendCrypto );

        if( FAILED(result) ) {
            goto cleanup;
        }

        //
        // Encrypt the data.
        //

        result = sendCrypto->EncryptData(
                     &dataBlob,
                     (PVOID)pmdrMDData->pbMDData,
                     pmdrMDData->dwMDDataLen,
                     0
                     );

        if( FAILED(result) ) {
            goto cleanup;
        }

    } else {

        result = ::IISCryptoCreateCleartextBlob(
                       &dataBlob,
                       (PVOID)pmdrMDData->pbMDData,
                       pmdrMDData->dwMDDataLen
                       );

        if( FAILED(result) ) {
            goto cleanup;
        }

    }

    //
    // Success!
    //

    DBG_ASSERT( SUCCEEDED(result) );
    *ppDataBlob = dataBlob;

cleanup:

    //
    // NULL the data pointer in the METADATA_RECORD so the RPC runtime
    // won't send the plaintext data back to the client.
    //

    pmdrMDData->pbMDData = NULL;

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    if( dataBuffer != NULL ) {
        FREE_MEM( dataBuffer );
    }

    if( FAILED(result) && dataBlob != NULL ) {
        ::IISCryptoFreeBlob( dataBlob );
    }

    return result;

}   // IMSAdminBaseA_EnumData_Stub


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseA_GetAllData_Proxy(
    IMSAdminBase __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize
    )
/*++

Routine Description:

    Gets all data associated with a Meta Object

Arguments:

    hMDHandle - open  handle

    pszMDPath - path of the meta object with which this data is associated

    dwMDAttributes - flags for the data

    dwMDUserType - user Type for the data

    dwMDDataType - type of the data

    pdwMDNumDataEntries - number of entries copied to Buffer

    pdwMDDataSetNumber - number associated with this data set

    dwMDBufferSize - size in bytes of buffer

    pbBuffer - buffer to store the data

    pdwMDRequiredBufferSize - updated with required length of buffer

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * recvCrypto;
    PIIS_CRYPTO_BLOB dataBlob;
    PVOID dataBuffer;
    DWORD dataBufferLength;
    DWORD dataBufferType;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    recvCrypto = NULL;
    dataBlob = NULL;

    //
    // Find an ADM_SECURE_DATA object for "This".
    //

    secureData = ADM_SECURE_DATA::FindAndReferenceSecureData(
                     This,
                     TRUE       // CreateIfNotFound
                     );

    if( secureData == NULL ) {
        result = MD_ERROR_SECURE_CHANNEL_FAILURE;
        goto cleanup;
    }

    //
    // Get the appropriate crypto storage object. This will perform
    // key exchange if necessary.
    //

    result = secureData->GetClientReceiveCryptoStorage( &recvCrypto );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Call through to the "real" remoted API to get the data from
    // the server.
    //

    result = IMSAdminBaseA_R_GetAllData_Proxy(
                 This,
                 hMDHandle,
                 pszMDPath,
                 dwMDAttributes,
                 dwMDUserType,
                 dwMDDataType,
                 pdwMDNumDataEntries,
                 pdwMDDataSetNumber,
                 dwMDBufferSize,
                 pdwMDRequiredBufferSize,
                 &dataBlob
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Decrypt the data if necessary. This method properly handles
    // cleartext (unencrypted) blobs.
    //

    result = recvCrypto->DecryptData(
                 &dataBuffer,
                 &dataBufferLength,
                 &dataBufferType,
                 dataBlob
                 );


    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Copy it back to the user.
    //

    __try {

        if( dwMDBufferSize >= dataBufferLength ) {

            RtlCopyMemory(
                pbBuffer,
                dataBuffer,
                dataBufferLength
                );

        } else {

            *pdwMDRequiredBufferSize = dataBufferLength;
            result = RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER );

        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        result = HRESULT_FROM_NT( GetExceptionCode() );

    }

    if( FAILED(result) ) {
        goto cleanup;
    }

cleanup:

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    if( dataBlob != NULL ) {
        ::IISCryptoFreeBlob( dataBlob );
    }

    return result;

}   // IMSAdminBaseA_GetAllData_Proxy

HRESULT
STDMETHODCALLTYPE
IMSAdminBaseA_GetAllData_Stub(
    IMSAdminBase __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob
    )
/*++

Routine Description:

    Gets all data associated with a Meta Object

Arguments:

    hMDHandle - open  handle

    pszMDPath - path of the meta object with which this data is associated

    dwMDAttributes - flags for the data

    dwMDUserType - user Type for the data

    dwMDDataType - type of the data

    pdwMDNumDataEntries - number of entries copied to Buffer

    pdwMDDataSetNumber - number associated with this data set

    dwMDBufferSize - size in bytes of buffer

    pdwMDRequiredBufferSize - updated with required length of buffer

    ppDataBlob - Receives a blob for the encrypted data.

Return Value:

    Status.

--*/
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;
    IIS_CRYPTO_STORAGE * sendCrypto;
    PIIS_CRYPTO_BLOB dataBlob;
    METADATA_RECORD capturedRecord;
    DWORD clearDataType;
    PVOID dataBuffer;
    DWORD getAllBufferLength;
    BOOL getAllBufferIsSecure;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    secureData = NULL;
    sendCrypto = NULL;
    dataBuffer = NULL;
    dataBlob = NULL;

    //
    // Allocate a temporary memory block for the meta data. Use the
    // same size as the user passed into the API.
    //

    dataBuffer = ALLOC_MEM( dwMDBufferSize );

    if( dataBuffer == NULL ) {
        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto cleanup;
    }

    //
    // Call through to the "real" server stub to get the data.
    //

    result = This->GetAllData(
                 hMDHandle,
                 pszMDPath,
                 dwMDAttributes,
                 dwMDUserType,
                 dwMDDataType,
                 pdwMDNumDataEntries,
                 pdwMDDataSetNumber,
                 dwMDBufferSize,
                 (PBYTE)dataBuffer,
                 pdwMDRequiredBufferSize
                 );

    if( FAILED(result) ) {
        goto cleanup;
    }

    //
    // Compute the total size of the METADATA_GETALL_RECORD. Also
    // take this opportunity to determine if any of the data items
    // within the record are marked as secure. We'll encrypt the
    // entire record if any entry is secure.
    //

    CalculateGetAllBufferAttributes(
        (PMETADATA_GETALL_RECORD)dataBuffer,
        *pdwMDNumDataEntries,
        &getAllBufferLength,
        &getAllBufferIsSecure
        );

    //
    // Encrypt if necessary.
    //

    if( getAllBufferIsSecure ) {

        //
        // Find an ADM_SECURE_DATA object for "This".
        //

        secureData = ADM_SECURE_DATA::FindAndReferenceSecureData(
                         This,
                         TRUE       // CreateIfNotFound
                         );

        if( secureData == NULL ) {
            result = MD_ERROR_SECURE_CHANNEL_FAILURE;
            goto cleanup;
        }

        //
        // Get the appropriate crypto storage object.
        //

        result = secureData->GetServerSendCryptoStorage( &sendCrypto );

        if( FAILED(result) ) {
            goto cleanup;
        }

        //
        // Encrypt the data.
        //

        result = sendCrypto->EncryptData(
                     &dataBlob,
                     dataBuffer,
                     getAllBufferLength,
                     0
                     );

        if( FAILED(result) ) {
            goto cleanup;
        }

    } else {

        result = ::IISCryptoCreateCleartextBlob(
                       &dataBlob,
                       dataBuffer,
                       getAllBufferLength
                       );

        if( FAILED(result) ) {
            goto cleanup;
        }

    }

    //
    // Success!
    //

    DBG_ASSERT( SUCCEEDED(result) );
    *ppDataBlob = dataBlob;

cleanup:

    if( secureData != NULL ) {
        secureData->Dereference();
    }

    if( dataBuffer != NULL ) {
        FREE_MEM( dataBuffer );
    }

    if( FAILED(result) && dataBlob != NULL ) {
        ::IISCryptoFreeBlob( dataBlob );
    }

    return result;

}   // IMSAdminBaseA_GetAllData_Stub


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseA_KeyExchangePhase1_Proxy(
    IMSAdminBase __RPC_FAR * This
    )
{

    return E_FAIL;

}   // IMSAdminBaseA_KeyExchangePhase1_Proxy


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseA_KeyExchangePhase1_Stub(
    IMSAdminBase __RPC_FAR * This,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientKeyExchangeKeyBlob,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientSignatureKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerKeyExchangeKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerSignatureKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerSessionKeyBlob
    )
{

    HRESULT result;
    ADM_SECURE_DATA * secureData;

    //
    // Find an ADM_SECURE_DATA object for "This".
    //

    secureData = ADM_SECURE_DATA::FindAndReferenceSecureData(
                     This,
                     TRUE       // CreateIfNotFound
                     );

    if( secureData == NULL ) {
        return MD_ERROR_SECURE_CHANNEL_FAILURE;
    }

    //
    // Do the phase 1 server-side key exchange.
    //

    result = secureData->DoServerSideKeyExchangePhase1(
                 pClientKeyExchangeKeyBlob,
                 pClientSignatureKeyBlob,
                 ppServerKeyExchangeKeyBlob,
                 ppServerSignatureKeyBlob,
                 ppServerSessionKeyBlob
                 );

    secureData->Dereference();

    return result;

}   // IMSAdminBaseA_KeyExchangePhase1_Stub


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseA_KeyExchangePhase2_Proxy(
    IMSAdminBase __RPC_FAR * This
    )
{

    return E_FAIL;

}   // IMSAdminBaseA_KeyExchangePhase2_Proxy


HRESULT
STDMETHODCALLTYPE
IMSAdminBaseA_KeyExchangePhase2_Stub(
    IMSAdminBase __RPC_FAR * This,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientSessionKeyBlob,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientHashBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerHashBlob
    )
{



    HRESULT result;
    ADM_SECURE_DATA * secureData;

    //
    // Find an ADM_SECURE_DATA object for "This".
    //

    secureData = ADM_SECURE_DATA::FindAndReferenceSecureData(
                     This,
                     FALSE      // CreateIfNotFound
                     );

    if( secureData == NULL ) {
        return MD_ERROR_SECURE_CHANNEL_FAILURE;
    }

    //
    // Do the phase 2 server-side key exchange.
    //

    result = secureData->DoServerSideKeyExchangePhase2(
                 pClientSessionKeyBlob,
                 pClientHashBlob,
                 ppServerHashBlob
                 );

    secureData->Dereference();

    return result;

}   // IMSAdminBaseA_KeyExchangePhase2_Stub


VOID
CalculateGetAllBufferAttributes(
    IN PMETADATA_GETALL_RECORD Data,
    IN DWORD NumEntries,
    OUT DWORD * TotalBufferLength,
    OUT BOOL * IsBufferSecure
    )
/*++

Routine Description:

    This routine performs three major functions:

        1. It calculates the total size of the METADATA_GETALL_RECORD,
           including all data.

        2. It determines if any of the METADATA_GETALL_RECORDs are marked
           as secure.

        3. It compacts the buffer so that the data can be encrypted and
           sent using a minimum amount of data.

Arguments:

    Data - Pointer to the METADATA_GETALL_RECORD buffer.

    NumEntries - The number of entries in the buffer.

    TotalBufferLength - Receives the total buffer length.

    IsBufferSecure - Receives TRUE if any of the entries are marked secure.

Return Value:

    Status.

--*/
{

    PMETADATA_GETALL_RECORD scan;
    DWORD i;
    DWORD recordLength;
    DWORD dataLength;
    DWORD lowestOffset;
    DWORD newOffset;
    DWORD offsetAdjustment;
    BOOL isSecure;

    //
    // Setup.
    //

    recordLength = NumEntries * sizeof(METADATA_GETALL_RECORD);
    dataLength = 0;
    isSecure = FALSE;

    newOffset = recordLength;
    lowestOffset = (DWORD)-1L;

    //
    // Scan the entries, accumulating the total data length. While
    // we're at it, determine if any are marked as secure, and also
    // calculate the lowest data offset within the array.
    //

    for( scan = Data, i = NumEntries ; i > 0 ; scan++, i-- ) {

        dataLength += scan->dwMDDataLen;

        if( scan->dwMDAttributes & METADATA_SECURE ) {
            isSecure = ENABLE_SECURE_CHANNEL;
        }

        if( scan->dwMDDataOffset < lowestOffset ) {
            lowestOffset = scan->dwMDDataOffset;
        }

    }

    //
    // If we need to compact the buffer...
    //

    if( newOffset < lowestOffset ) {

        //
        // Move the data area so that it comes immediately after the
        // METADATA_GETALL_BUFFER structures. Note that we must use
        // RtlMoveMemory(), not RtlCopyMemory(), as the source and
        // destination buffers may overlap.
        //

        RtlMoveMemory(
            (BYTE *)Data + newOffset,
            (BYTE *)Data + lowestOffset,
            dataLength
            );

        //
        // Fixup the data offset fields in the entries.
        //

        offsetAdjustment = lowestOffset - newOffset;

        for( scan = Data, i = NumEntries ; i > 0 ; scan++, i-- ) {
            scan->dwMDDataOffset -= offsetAdjustment;
        }

    }

    *TotalBufferLength = recordLength + dataLength;
    *IsBufferSecure = isSecure;

}   // CalculateGetAllBufferAttributes


VOID
WINAPI
ReleaseObjectSecurityContextA(
    IUnknown * Object
    )
/*++

Routine Description:

    Releases any security context associated with the specified object.

Arguments:

    Object - The object.

Return Value:

    None.

--*/
{

    ADM_SECURE_DATA * data;

    //
    // Find the data associated with the object.
    //

    data = ADM_SECURE_DATA::FindAndReferenceSecureData(
               Object,
               FALSE                // CreateIfNotFound
               );

    if( data == NULL ) {

#if 0   // stop whining
        DBGPRINTF((
            DBG_CONTEXT,
            "ReleaseObjectSecurityContextA: cannot find data for %08lx\n",
            Object
            ));
#endif  // stop whining

    } else {

        //
        // Dereference the secure data object *twice*, once
        // to remove the reference added above, and once to
        // remove the "active" reference.
        //

        data->Dereference();
        data->Dereference();

    }

}   // ReleaseObjectSecurityContextA


extern "C" {

ULONG
STDMETHODCALLTYPE
Hooked_IUnknown_Release_Proxy(
    IUnknown __RPC_FAR * This
    )
/*++

Routine Description:

    This is the hooked IUnknown::Release() method (see IADMXP.C for
    details).

Arguments:

    This - The object being released.

Return Value:

    ULONG - The updated reference count.

--*/
{

    ULONG result;

    //
    // Call the original release method. If this is the final release,
    // destroy any security context associated with this object.
    //

    result = IUnknown_Release_Proxy( This );

    if( result == 0 ) {
        ReleaseObjectSecurityContextA( This );
    }

    return result;

}   // Hooked_IUnknown_Release_Proxy

}   // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\admutil.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       admutil.cpp

   Abstract:

        IADMCOM interface WRAPPER functions implemetation

   Environment:

      Win32 User Mode

   Author:

      jaroslad  (jan 1997)

--*/



#define INITGUID

#include <tchar.h>
#include <afx.h>

#ifdef UNICODE
    #include <iadmw.h>
    #define IADM_PBYTE
#else
    #include "ansimeta.h"
    //convert when using ANSI interface
    #define IADM_PBYTE   (PBYTE)
#endif

//#define SPECIAL_SHOW_ALL_METABASE

#include <iiscnfg.h>

#include <ole2.h>

#include <ctype.h>  //import toupper
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>

#include "admutil.h"
#include "tables.h"
#include <jd_misc.h>

#undef SHOW_SECURE
//////////////////////////////
//global variable definition
DWORD g_dwTIMEOUT_VALUE =30000;

DWORD g_dwDELAY_AFTER_OPEN_VALUE=0;
//////////////////////////////

//*********************

CString FindCommonPath(CString a_strPath1, CString a_strPath2)
{
    CString strCommonPath=_TEXT("");
    int MinLength=a_strPath1.GetLength();
    int i;
    //find shorter from strings
    if(a_strPath2.GetLength() < MinLength)
            MinLength=a_strPath2.GetLength();
    for(i=0; i<MinLength; i++)
    {
        if(a_strPath1.GetAt(i)!=a_strPath2.GetAt(i) )
            // common path cannot be any longer;
            break;
    }
    //  now find the previous '/' and all before '/' is the common path
    for(i=i-1; i>=0;i--)
    {
        if(a_strPath1.GetAt(i)==_T('/'))
        {
            strCommonPath=a_strPath1.Left(i+1);//take the trailing '/' with you
            //strRelSrcPath=strPath1.Mid(i+1);
            //strRelDstPath=strPath2.Mid(i+1);
            break;
        }
    }
    return strCommonPath;
}


//**********************************************************************
//IMPLEMENTATION  of CAdmNode
//**********************************************************************



//return the position of '/' that is iSeqNumber in the order
//e.g: GetSlashIndex("aaa/bbb/ccc/ddd",2) returns position of 2nd index that equals 7)
INT CAdmNode::GetSlashIndex(const CString& strPath, INT iSeqNumber)
{
    INT count=0;
    if (iSeqNumber==0)
        return 0;
    for(INT i=0; i<strPath.GetLength();i++)
    {
        if(strPath[i]==_T('/'))
            if((++count)==iSeqNumber)
                return i;
    }
    return -1;

}

//return the count of '/' in strPath

INT CAdmNode::GetCountOfSlashes(const CString& strPath)
{
    INT count=0;
    for(INT i=0; i<strPath.GetLength();i++)
    {
        if(strPath[i]==_T('/'))
            count++;
    }
    return count;
}

//return selement within the given string with sequence number wIndex
//e.g.: GetPartOfPath("aaa/bbb/ccc",1,1) will return "bbb"
//e.g.: GetPartOfPath("aaa/bbb/ccc",1) will return "bbb/ccc"
//e.g.: GetPartOfPath("aaa/bbb/ccc",0,1) will return "aaa/bbb"

//iStart- sequence number of first slash
//iEnd- sequence number of last slash
CString CAdmNode::GetPartOfPath(const CString& strPath, INT iStart, INT iEnd)
{
    if(iEnd!=-1 && iEnd <= iStart)
        return _TEXT("");
    INT i=0;
    INT iPosBegin = GetSlashIndex(strPath,iStart);
    if(iPosBegin==-1) //not found (exceeds number of slashes available in strPath
    {
        return _TEXT("");
    }
    iPosBegin+=((iStart==0)?0:1); //adjust iPosBegin

    INT iPosEnd = GetSlashIndex(strPath,iEnd);
    CString strToReturn;
    if(iEnd==-1 || iPosEnd==-1)
        strToReturn = strPath.Mid(iPosBegin);
    else
        strToReturn = strPath.Mid(iPosBegin,iPosEnd-iPosBegin);
    if(iStart==0 && strToReturn==_TEXT("") && strPath!=_TEXT(""))
        return _TEXT("/"); //this had to be root
    else
        return strToReturn;
}


//within path can be given computer name, service, instance number
// function will split the path to Computer, Service, Instance, Path relative to instance
//

void CAdmNode::SetPath(CString a_strPath)
{
    if(a_strPath.IsEmpty())
        return;

    // change backslashes
    for(int i=0; i<a_strPath.GetLength(); i++)
    {
        // skip DBCS
        if(IsDBCSLeadByte(a_strPath[i]))
        {
            i++;
            continue;
        }
        if(a_strPath[i]==_T('\\'))
            a_strPath.SetAt(i,_T('/'));
    }

    //trim  leading '/'
    while (a_strPath.GetLength()!=0 && a_strPath[0]==_T('/'))
        a_strPath=a_strPath.Mid(1);


    int iSvc=-1;

    if( IsServiceName(GetPartOfPath(a_strPath,1,2))) //get the second name within path
    { //if second is service then first has to be computer name
        strComputer = GetPartOfPath(a_strPath,0,1);
        strService  = GetPartOfPath(a_strPath,1,2);
        if( IsNumber(GetPartOfPath(a_strPath,2,3))) {
            strInstance = GetPartOfPath(a_strPath,2,3);
            strIPath = GetPartOfPath(a_strPath,3); //store the rest
        }
        else {
            strIPath = GetPartOfPath(a_strPath,2); //store the rest

        }
    }
    else if( IsServiceName(GetPartOfPath(a_strPath,0,1))) //get the second name within path
    { //if second is service then first has to be computer name
        strComputer = _TEXT("");
        strService  = GetPartOfPath(a_strPath,0,1);
        if( IsNumber(GetPartOfPath(a_strPath,1,2))) {
            strInstance = GetPartOfPath(a_strPath,1,2);
            strIPath = GetPartOfPath(a_strPath,2); //store the rest
        }
        else {
            strIPath = GetPartOfPath(a_strPath,1); //store the rest
        }
    }
    else
    {
        strIPath = a_strPath;
    }

    //in IPath there can be Property name at the end
    INT iCount= GetCountOfSlashes(strIPath);
    CString LastName= GetPartOfPath(strIPath,iCount); //get last name within path;

     if(MapPropertyNameToCode(LastName)!=NAME_NOT_FOUND)
     {  //the Last name in the path is valid Property name
        strProperty = LastName;
        strIPath = GetPartOfPath(strIPath,0,iCount); //Strip Last name from IPath
     }
}

CString CAdmNode::GetLMRootPath(void)
{
#ifdef SPECIAL_SHOW_ALL_METABASE
    return _T("/");
#else
    return _T("/")+CString(IIS_MD_LOCAL_MACHINE_PATH);
#endif
}



CString CAdmNode::GetLMServicePath(void)
{
    if(strService.IsEmpty())
        return GetLMRootPath();
    else
        return GetLMRootPath()+_T("/")+strService;
}

CString CAdmNode::GetLMInstancePath(void)
{
    if(strInstance.IsEmpty())
        return GetLMServicePath();
    else
        return GetLMServicePath()+_T("/")+strInstance;
}

CString CAdmNode::GetLMNodePath(void)
{
    if(strIPath.IsEmpty())
        return GetLMInstancePath();
    else
        return GetLMInstancePath()+_T("/")+strIPath;
}

CString CAdmNode::GetServicePath(void)
{
    if(strService.IsEmpty())
        return _TEXT("");
    else
        return _T("/")+strService;
}

CString CAdmNode::GetInstancePath(void)
{
    if(!strInstance.IsEmpty())
        return GetServicePath() + _T("/")+ strInstance;
    else
        return GetServicePath();
}

CString CAdmNode::GetNodePath(void)
{

    if(!strIPath.IsEmpty())
        return GetInstancePath() + _T("/")+ strIPath;
    else
        return GetInstancePath();
}



CString CAdmNode::GetParentNodePath(void)
{
    CString strNodePath;
    strNodePath = GetNodePath();

    if(strNodePath.IsEmpty())
        return strNodePath;
    else
    {
        INT i= strNodePath.GetLength()-1; //point to the end of strNodePath
        if (strNodePath.Right(1)==_T("/"))
            i--;
        for(; i>=0; i--)
        {
            if(strNodePath.GetAt(i)==_T('/'))
                return strNodePath.Left(i+1);
        }
        return _TEXT("");
    }
}
//can return _TEXT("") for nonamed
CString CAdmNode::GetCurrentNodeName(void)
{
    CString strNodePath;
    strNodePath = GetNodePath();

    if(strNodePath.IsEmpty())
        return strNodePath;
    else
    {
        INT i= strNodePath.GetLength()-1; //point to the end of strNodePath
        if (strNodePath.Right(1)==_T("/"))
            i--;
        for(int count=0; i>=0; i--, count++) //search backward for '/'
        {
            if(strNodePath.GetAt(i)==_T('/'))
                return strNodePath.Mid(i+1,count);
        }
        return strNodePath;
    }
}


CString CAdmNode::GetRelPathFromService(void)
{
    CString str=strService;
    if (!strInstance.IsEmpty())
        str=str+_T("/")+strInstance;
    if (!strIPath.IsEmpty())
        str=str+_T("/")+strIPath;
    return str;
}

CString CAdmNode::GetRelPathFromInstance(void)
{
    if(strInstance.IsEmpty())
        return strIPath;
    else
        return  strInstance+_T("/")+strIPath;
}

//**********************************************************************
//**********************************************************************
//IMPLEMENTATION  of CAdmProp object
//**********************************************************************
//**********************************************************************

CAdmProp::CAdmProp(METADATA_RECORD &a_mdr)
{
    memcpy (&mdr,&a_mdr,sizeof(METADATA_RECORD));
}

void CAdmProp::SetValue(DWORD a_dwValue)
{
    if(mdr.pbMDData!=0)
        delete mdr.pbMDData;
    mdr.dwMDDataLen= sizeof(DWORD);
    mdr.pbMDData = (PBYTE) new char[mdr.dwMDDataLen];
    memcpy(mdr.pbMDData,&a_dwValue,mdr.dwMDDataLen);


}


void CAdmProp::SetValue(CString a_strValue)
{
    if(mdr.pbMDData!=0)
        delete mdr.pbMDData;
    mdr.dwMDDataLen = (a_strValue.GetLength()+1)*sizeof(_TCHAR);
    mdr.pbMDData = (PBYTE) new _TCHAR [mdr.dwMDDataLen/sizeof(_TCHAR)];
    memcpy(mdr.pbMDData,LPCTSTR(a_strValue),mdr.dwMDDataLen-sizeof(_TCHAR));
    ((_TCHAR *)mdr.pbMDData)[mdr.dwMDDataLen/sizeof(_TCHAR)-1]=0; //terminate with zero
}

void CAdmProp::SetValue(LPCTSTR *a_lplpszValue, DWORD a_dwValueCount)
{
    if(mdr.pbMDData!=NULL)
    {
        delete mdr.pbMDData;
        mdr.pbMDData=0;
    }
    mdr.dwMDDataLen=0;
    for(DWORD i=0; i< a_dwValueCount; i++)
    {
        if(a_lplpszValue[i]==NULL)
            break;

        mdr.dwMDDataLen += (_tcslen(a_lplpszValue[i])+1)*sizeof(_TCHAR);
    }
    mdr.dwMDDataLen+=sizeof(_TCHAR); // two 0 at the end
    mdr.pbMDData = (PBYTE) new char[mdr.dwMDDataLen];
    //merge strings in one area of memory
    DWORD j=0; //index to destination where stings will be merged
    for( i=0; i< a_dwValueCount; i++) //index to aray of strings
    {
        if(a_lplpszValue[i]==NULL)
            break;
        DWORD k=0; //index within string
        while(a_lplpszValue[i][k]!=0)
            ((_TCHAR *)mdr.pbMDData)[j++]=a_lplpszValue[i][k++];
        ((_TCHAR *)mdr.pbMDData)[j++]=0;
    }
    ((_TCHAR *)mdr.pbMDData)[j++]=0;
}

void
CAdmProp::SetValue(
    LPBYTE pbValue,
    DWORD dwValueLength
    )
{
    if( mdr.pbMDData != NULL )
    {
        delete mdr.pbMDData;
    }
    mdr.dwMDDataLen = dwValueLength;
    mdr.pbMDData = (PBYTE) new BYTE[mdr.dwMDDataLen];
    memcpy( mdr.pbMDData, pbValue, mdr.dwMDDataLen );
}


//sets the value depending on GetDataType()

BOOL CAdmProp::SetValueByDataType(LPCTSTR *a_lplpszPropValue, DWORD* a_lpdwPropValueLength, WORD a_wPropValueCount)
{
//process the value
    WORD i;
    if(a_wPropValueCount!=0)
    {   DWORD dwValue=0;
        switch(GetDataType())
        {
        case DWORD_METADATA:
            {
                for (i=0;i<a_wPropValueCount;i++)
                {
                    if( _tcslen(a_lplpszPropValue[i]) > 2 && a_lplpszPropValue[i][0]==_T('0') && _toupper(a_lplpszPropValue[i][1])==_T('X'))
                    {   _TCHAR * lpszX;
                        dwValue += _tcstoul(a_lplpszPropValue[i]+2, &lpszX, 16);
                    }
                    else if(IsNumber(a_lplpszPropValue[i]))
                        dwValue += _ttol(a_lplpszPropValue[i]);
                    else
                    {
                        DWORD dwMapped=MapValueNameToCode(a_lplpszPropValue[i],GetIdentifier());

                        if(dwMapped==NAME_NOT_FOUND)
                        {
                            printf/*Print*/(_TEXT("value not resolved: %s\n"),a_lplpszPropValue[i]);
                            return FALSE;
                        }
                        else
                        // it has to be checked if adding can be performed
                            dwValue |= dwMapped;
                    }
                }
                SetValue(dwValue);
            }
            break;
        case STRING_METADATA:
        case EXPANDSZ_METADATA:
            {
                CString strValue=_TEXT("");
                for (i=0;i<a_wPropValueCount;i++)
                {
                    strValue += a_lplpszPropValue[i];
                }
                SetValue(strValue);
            }
            break;
        case MULTISZ_METADATA:
            {
                SetValue(a_lplpszPropValue, a_wPropValueCount);
            }
            break;
        case BINARY_METADATA:
            SetValue( (LPBYTE)a_lplpszPropValue[0], a_lpdwPropValueLength[0] );
            break;
        default:
            return FALSE;
        }
    }
    return TRUE;
}

void CAdmProp::Print(const _TCHAR * format,...)
{
   _TCHAR buffer[2000];
   va_list marker;
   va_start( marker, format );     /* Initialize variable arguments. */
   //_vstprintf(buffer,format, marker);
   _vsnprintf(buffer,1500,format, marker);
   _tprintf(_TEXT("%s"),buffer);

   va_end( marker );              /* Reset variable arguments.      */

}


void CAdmProp::PrintProperty(void)
{
    CString strPropName=tPropertyNameTable::MapCodeToName(mdr.dwMDIdentifier);
    BOOL    fSecure =(mdr.dwMDAttributes&METADATA_SECURE);

    //print code or name of property
    if(strPropName.IsEmpty())
        printf/*Print*/(_TEXT("%-30ld: "), mdr.dwMDIdentifier);
    else
    {
	if(getenv("MDUTIL_PRINT_ID")!=NULL) //let's print out Identifier numeric values when environment variable is set
        	printf/*Print*/(_TEXT("%ld %-25s: "), mdr.dwMDIdentifier,LPCTSTR(strPropName));
	else
	        printf/*Print*/(_TEXT("%-30s: "), LPCTSTR(strPropName));
    }
    CString strFlagsToPrint=_TEXT("");

    strFlagsToPrint+=_TEXT("[");
    if(mdr.dwMDAttributes&METADATA_INHERIT)
        strFlagsToPrint+=_TEXT("I");
    if(mdr.dwMDAttributes&METADATA_SECURE)
        strFlagsToPrint+=_TEXT("P");
    if(mdr.dwMDAttributes&METADATA_REFERENCE)
        strFlagsToPrint+=_TEXT("R");
    if(mdr.dwMDUserType==IIS_MD_UT_SERVER)
        strFlagsToPrint+=_TEXT("S");
    if(mdr.dwMDUserType==IIS_MD_UT_FILE)
        strFlagsToPrint+=_TEXT("F");
    if(mdr.dwMDUserType==IIS_MD_UT_WAM)
        strFlagsToPrint+=_TEXT("W");
    if(mdr.dwMDUserType==ASP_MD_UT_APP)
        strFlagsToPrint+=_TEXT("A");
    strFlagsToPrint+=_TEXT("]");
    printf/*Print*/(_TEXT("%-8s"),LPCTSTR(strFlagsToPrint));

    //print property value
    DWORD i;
    switch (mdr.dwMDDataType) {
    case DWORD_METADATA:
#ifndef SHOW_SECURE
        if ( fSecure && getenv("MDUTIL_PRINT_SECURE")==NULL)

        {
            printf/*Print*/(_TEXT("(DWORD)  ********"), *(DWORD *)(mdr.pbMDData));
        }
        else
#endif
        {
            printf/*Print*/(_TEXT("(DWORD)  0x%x"), *(DWORD *)(mdr.pbMDData));
            // try to convert to readable info
            CString strNiceContent;
            strNiceContent=tValueTable::MapValueContentToString(*(DWORD *)(mdr.pbMDData), mdr.dwMDIdentifier);
            if(!strNiceContent.IsEmpty())
                printf/*Print*/(_TEXT("={%s}"),LPCTSTR(strNiceContent));
            else //at least decimal value can be useful
                printf/*Print*/(_TEXT("={%ld}"),*(DWORD *)(mdr.pbMDData));
        }
        break;
    case BINARY_METADATA:

        printf/*Print*/(_TEXT("(BINARY) 0x"));
#ifndef SHOW_SECURE
	if ( fSecure && getenv("MDUTIL_PRINT_SECURE")==NULL)
        {
                printf/*Print*/(_TEXT(" * " ));
        }
	else
#endif
        {
	        for (i = 0; i < mdr.dwMDDataLen; i++) 
		{
	       	        printf/*Print*/(_TEXT("%02x "), ((PBYTE)(mdr.pbMDData))[i]);
	        }
	}
        break;

    case STRING_METADATA:
    case EXPANDSZ_METADATA:
        if(mdr.dwMDDataType==STRING_METADATA)
                printf/*Print*/(_TEXT("(STRING) "));
        else
                printf/*Print*/(_TEXT("(EXPANDSZ) "));
#ifndef SHOW_SECURE
        if( fSecure && getenv("MDUTIL_PRINT_SECURE")==NULL)
        { //do not expose the length of secure data
           printf/*Print*/( _TEXT("\"********************\"" ));
        }
        else
#endif
        {
          printf/*Print*/(_TEXT("\""));
          for (i = 0; i < mdr.dwMDDataLen/sizeof(_TCHAR); i++) {
            if(((_TCHAR *)(mdr.pbMDData))[i]==0)
            {
                if( i+1 == mdr.dwMDDataLen/sizeof(_TCHAR))
                { //we are at the end print only terminating "
                    printf/*Print*/(_TEXT("\""));
                }
                else
                {
                    printf/*Print*/(_TEXT("\" \""));
                }
            }
            else
            {
	            if(((_TCHAR *)(mdr.pbMDData))[i]=='\r')
        	        printf/*Print*/(_TEXT("\t"));
	            else
        	    {
                	printf/*Print*/( _TEXT("%c"), ((_TCHAR *)(mdr.pbMDData))[i]);
	            }
            }
          }
        }
        break;
    case MULTISZ_METADATA:
        printf/*Print*/(_TEXT("(MULTISZ) ")); //0 should be separator of mulisz strings

#ifndef SHOW_SECURE
        if( fSecure && getenv("MDUTIL_PRINT_SECURE")==NULL)
        { //do not expose the length of secure data
           printf/*Print*/( _TEXT("\"********************\"" ));
            }
        else
#endif
        {
            printf/*Print*/(_TEXT("\""));
            for (i = 0; i < mdr.dwMDDataLen/sizeof(_TCHAR); i++) {
                if(((_TCHAR *)(mdr.pbMDData))[i]==0)
                {
                    if( i+1 == mdr.dwMDDataLen/sizeof(_TCHAR) || (mdr.dwMDDataLen/sizeof(_TCHAR)-i==2 && ((_TCHAR *)(mdr.pbMDData))[i]==0 && ((_TCHAR *)(mdr.pbMDData))[i+1]==0))
                    { //we are at the end print only terminating "
                        printf/*Print*/(_TEXT("\"")); break;
                    }
                    else
                    {
                        printf/*Print*/(_TEXT("\" \""));
                    }
                }
                else
                    printf/*Print*/(_TEXT("%c"),((_TCHAR *)(mdr.pbMDData))[i]);
            }
        }
        break;
    default:
        printf/*Print*/(_TEXT("(UNKNOWN) "));
        break;
    }
    printf/*Print*/(_TEXT("\n"));
}

//**********************************************************************
//**********************************************************************
//IMPLEMENTATION  of CAdmUtil object
//**********************************************************************
//**********************************************************************


//nesting for recursive enumeration
static void nest_print(BYTE bLevel)
{
    for(int i=0; i<=bLevel;i++)
        _tprintf(_T(" "));
}

CAdmUtil::CAdmUtil (const CString & strComputer)
{
    EnablePrint(); // by default print error messages


    pIWamAdm=0; //interface pointer to Wam Admin 
    pIWamAdm2=0; //interface pointer to Wam Admin2 
    pcAdmCom=0;
    m_hmd=0;
    pbDataBuffer=new BYTE [DEFAULTBufferSize];
    wDataBufferSize=DEFAULTBufferSize;

#if UNICODE
    pcAdmCom=0;
#else
    pcAdmCom=new ANSI_smallIMSAdminBase;  //we will access metabase through wrapper class
#endif

    //Open (strComputer);
}

void CAdmUtil::Open (const CString & strComputer)
{
    IClassFactory * pcsfFactory = NULL;
    COSERVERINFO csiMachineName;
    COSERVERINFO *pcsiParam = NULL;
    OLECHAR rgchMachineName[MAX_PATH];


#if UNICODE
   //release previous interface if needed
    if(pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->Release();
        pcAdmCom=0;
    }
    //convert to OLECHAR[];
    if (!strComputer.IsEmpty())
    {
           wsprintf( rgchMachineName, L"%s", LPCTSTR(strComputer));

#else
   //release previous interface if needed
    if(pcAdmCom!=0 &&pcAdmCom->m_pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->m_pcAdmCom->Release();
        pcAdmCom->m_pcAdmCom=0;
    }
    //convert to OLECHAR[];
    if (!strComputer.IsEmpty())
    {
            wsprintfW( rgchMachineName, L"%S", LPCTSTR(strComputer));
#endif
    }
    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;
    pcsiParam = &csiMachineName;
    csiMachineName.pwszName =  (strComputer.IsEmpty())?NULL:rgchMachineName;

    hresError = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);

    if (FAILED(hresError))
    {
     Error(_TEXT("CoGetClassObject"));
    }
    else {
        hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase,
#if UNICODE
                         (void **) &pcAdmCom);
#else
                         (void **) &pcAdmCom->m_pcAdmCom);
#endif
        if (FAILED(hresError)) Error(_TEXT("CreateInstance"));
        pcsfFactory->Release();
    }
}



void CAdmUtil::Close (void)
{
    //release the interface
#if UNICODE
    if(pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->Release();
        pcAdmCom=0;
    }

#else
    if(pcAdmCom!=0 &&pcAdmCom->m_pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->m_pcAdmCom->Release();
        pcAdmCom->m_pcAdmCom=0;
    }
#endif
}



CAdmUtil::~CAdmUtil (void)
{
    //release the interface
    if(pbDataBuffer!=NULL)
        delete [] pbDataBuffer;
    //the following may fail if class is static
#if UNICODE
    if(pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->Release();
        pcAdmCom=0;
    }

#else
    if(pcAdmCom!=0 &&pcAdmCom->m_pcAdmCom!=0)
    {
                if (m_hmd!=0) CloseObject(m_hmd);
                m_hmd=0;
        pcAdmCom->m_pcAdmCom->Release();
        pcAdmCom->m_pcAdmCom=0;
    }
#endif
}

//*******************************************************************************
//with fCreate set to TRUE the node will be created if it doesn't exist

METADATA_HANDLE CAdmUtil::OpenObject(CAdmNode & a_AdmNode, DWORD dwPermission, BOOL fCreate)
{
    METADATA_HANDLE hmdToReturn = 0;

    //try to open the full path
    CString strPathToOpen=a_AdmNode.GetLMNodePath();

    hresError = pcAdmCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
        IADM_PBYTE LPCTSTR(strPathToOpen), dwPermission, g_dwTIMEOUT_VALUE, &hmdToReturn);
    
    if (FAILED(hresError)) {
        if ( ((dwPermission==(dwPermission|METADATA_PERMISSION_READ)) || fCreate==FALSE) ||(hresError != RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND))) {
            CString strErrMsg=_TEXT("OpenKey");
            strErrMsg += _TEXT("(\"")+a_AdmNode.GetNodePath()+_TEXT("\")");
            Error(LPCTSTR(strErrMsg));
        }
        else {
            //!!!!!!!!!!!!!Place the dialog to ask to create the path
            // open the service object for write
            METADATA_HANDLE hmdServicePathHandle;
            hresError = pcAdmCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                IADM_PBYTE LPCTSTR(a_AdmNode.GetLMServicePath()), METADATA_PERMISSION_WRITE, g_dwTIMEOUT_VALUE, &hmdServicePathHandle);
		
            if (FAILED(hresError))
            {
                CString strErrMsg=_TEXT("OpenKey");
                strErrMsg += _TEXT("(\"")+a_AdmNode.GetServicePath()+_TEXT(",WRITE")+_TEXT("\")");
                Error(LPCTSTR(strErrMsg));
            }
            else {
                // create the node
                hresError = pcAdmCom->AddKey(hmdServicePathHandle,
                                    IADM_PBYTE LPCTSTR(a_AdmNode.GetRelPathFromInstance()));
                if (FAILED(hresError)) {
                    CString strErrMsg=_TEXT("AddKey");
                    strErrMsg += _TEXT("(\"")+a_AdmNode.GetRelPathFromInstance()+_TEXT("\")");
                    Error(LPCTSTR(strErrMsg));
                }

                //close the service object
                pcAdmCom->CloseKey(hmdServicePathHandle);
                if (FAILED(hresError))  Error(_TEXT("CloseKey"));
                else {
                    // now finally we can open the full path
                    hresError = pcAdmCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                        IADM_PBYTE LPCTSTR(strPathToOpen), dwPermission, g_dwTIMEOUT_VALUE, &hmdToReturn);
                    if (FAILED(hresError))
                    {
                        CString strErrMsg=_TEXT("OpenKey");
                        strErrMsg += _TEXT("(\"")+a_AdmNode.GetServicePath()+_TEXT(",WRITE")+_TEXT("\")");
                        Error(LPCTSTR(strErrMsg));
                    }
                }
            }
        }
    }
    Sleep(g_dwDELAY_AFTER_OPEN_VALUE);
    return hmdToReturn;
}

//*******************************************************************************
void CAdmUtil::CloseObject(METADATA_HANDLE hmd)
{
    HRESULT hresStore=hresError;
    hresError=pcAdmCom->CloseKey(hmd);
    if (FAILED(hresError)) Error(_TEXT("CloseData"));
    else    hresError=hresStore; //restore the previous hresError


}
//*******************************************************************************

void CAdmUtil::CreateObject(CAdmNode & a_AdmNode)
{
        OpenObjectTo_hmd(a_AdmNode, METADATA_PERMISSION_WRITE, TRUE/* fCreate*/);
}

#if 0
    METADATA_HANDLE hmdToReturn = 0;

    //try to open the full path
    CString strPathToOpen=a_AdmNode.GetLMNodePath();

    METADATA_HANDLE hmdServicePathHandle;
    hresError = pcAdmCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
            IADM_PBYTE LPCTSTR(a_AdmNode.GetLMServicePath()), METADATA_PERMISSION_WRITE, g_dwTIMEOUT_VALUE, &hmdServicePathHandle);
    if (FAILED(hresError))
    {
        CString strErrMsg=_TEXT("OpenKey");
        strErrMsg += _TEXT("(\"")+a_AdmNode.GetServicePath()+_TEXT(",WRITE")+_TEXT("\")");
        Error(LPCTSTR(strErrMsg));
    }
    else
    {
        // create the node
        hresError = pcAdmCom->AddKey(hmdServicePathHandle,
                            IADM_PBYTE LPCTSTR(a_AdmNode.GetRelPathFromInstance()));
        if (FAILED(hresError)) {
            CString strErrMsg=_TEXT("AddKey");
            strErrMsg += _TEXT("(\"")+a_AdmNode.GetRelPathFromInstance()+_TEXT("\")");
            Error(LPCTSTR(strErrMsg));
        }
        //close the service object
        CloseObject(hmdServicePathHandle);
    }
#endif


// This function enables to reuse open handles in order to improve performance
// !!it supports only one acticve handle (otherwise the processing may fail)

METADATA_HANDLE CAdmUtil::OpenObjectTo_hmd(CAdmNode & a_AdmNode, DWORD dwPermission, BOOL fCreate)
{
        CString strPathToOpen=a_AdmNode.GetLMNodePath();
        if(m_hmd!=0 && strPathToOpen.CompareNoCase(m_strNodePath)==0 && m_dwPermissionOfhmd == dwPermission )
        {  //we can reuse already opened node

        }
        else
        {
                if(m_hmd != 0)
                {
                        CloseObject(m_hmd);
                        m_hmd=0;
                }
                m_hmd = OpenObject(a_AdmNode, dwPermission, fCreate);
                m_dwPermissionOfhmd = dwPermission;
                m_strNodePath = strPathToOpen;
        }
    return m_hmd;
}

void CAdmUtil::CloseObject_hmd(void)
{
	if(m_hmd != 0) 
	{
		CloseObject(m_hmd);
		m_hmd=0;
	}
}
//*******************************************************************************

void CAdmUtil::GetProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp)
{
    DWORD dwRequiredDataLen=0;
    WORD wDataBufferSize=0;
    PBYTE DataBuffer=0;

    DWORD dwPropertyCode=a_AdmProp.GetIdentifier();

    if(dwPropertyCode==0)   Error(_TEXT("Property name not found"));
    else
    {
        //MD_SET_DATA_RECORD(&a_AdmProp.mdr,
        //                 0,
        //                 METADATA_INHERIT | METADATA_PARTIAL_PATH,
        //                 0,
        //                 0,
        //                 wDataBufferSize,
        //                 pbDataBuffer);

        //a_AdmProp.SetIdentifier(dwPropertyCode); //has to be set beforehand
        a_AdmProp.SetDataType(0);
        a_AdmProp.SetUserType(0);
        a_AdmProp.SetAttrib(0);

        METADATA_HANDLE hmd = OpenObjectTo_hmd(a_AdmNode,
                                         METADATA_PERMISSION_READ);
        if (SUCCEEDED(hresError))
        {
            hresError = pcAdmCom->GetData(hmd,
                IADM_PBYTE  _TEXT(""),
        &a_AdmProp.mdr, &dwRequiredDataLen);
            if (FAILED(hresError)) {
                if (hresError == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {
    ///////////             delete []pbDataBuffer;
                    pbDataBuffer=new BYTE[dwRequiredDataLen];
                    if (pbDataBuffer==0) {
                        hresError = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                        Error(_TEXT("Buffer resize failed"));
                    }
                    else {
                        a_AdmProp.mdr.dwMDDataLen = dwRequiredDataLen;
                        a_AdmProp.mdr.pbMDData = pbDataBuffer;
                        hresError = pcAdmCom->GetData(hmd,
                        IADM_PBYTE _TEXT(""), &a_AdmProp.mdr, &dwRequiredDataLen);
                        if (FAILED(hresError)) Error(_TEXT("GetData"));
                    }
                }
                else
                     Error(_TEXT("GetData"));;

            }
            //CloseObject (hmd);  we might reuse it
        }

    }
}

//if lplpszPropertyValue[1]==NULL it means there is only one value (it is not a multistring)


void CAdmUtil::SetProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp)
{
    METADATA_HANDLE hmd = OpenObjectTo_hmd(a_AdmNode,
                                         METADATA_PERMISSION_WRITE,TRUE/*create node if doesn't exist*/);
    if (SUCCEEDED(hresError))
    {
        SetProperty(&a_AdmProp.mdr,hmd);
        //CloseObject(hmd); we will reuse it
    }
}


void CAdmUtil::SetProperty(PMETADATA_RECORD a_pmdrData,METADATA_HANDLE a_hmd)
{
    hresError = pcAdmCom->SetData(a_hmd,
                            IADM_PBYTE _TEXT(""), a_pmdrData);
    if (FAILED(hresError))  Error(_TEXT("SetData"));

}

void CAdmUtil::SaveData(void)
{
        if (m_hmd!=0)
        {  //we have to close reusable handle in order to save successfully
                CloseObject(m_hmd);
                m_hmd=0;
        }
    hresError = pcAdmCom->SaveData();
        if (FAILED(hresError)) Error(_TEXT("SaveData"));
}

//****************************************************************************
//DELETE PROPERTY

void CAdmUtil::DeleteProperty(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp)
{
    METADATA_HANDLE hmd = OpenObjectTo_hmd(a_AdmNode,
                                         METADATA_PERMISSION_WRITE,TRUE/*create node if doesn't exist*/);
    if (SUCCEEDED(hresError))
    {
        DeleteProperty(&a_AdmProp.mdr,hmd);
        // CloseObject(hmd); we will reuse it
    }
}


void CAdmUtil::DeleteProperty(PMETADATA_RECORD a_pmdrData,METADATA_HANDLE a_hmd)
{
    hresError = pcAdmCom->DeleteData(a_hmd,
                IADM_PBYTE  _TEXT(""), a_pmdrData->dwMDIdentifier,ALL_METADATA);
    if (FAILED(hresError))  Error(_TEXT("DeleteData"));

}

//****************************************************************************
//DELETE OBJECT

void CAdmUtil::DeleteObject(CAdmNode& a_AdmNode, CAdmProp& a_AdmProp)
{
    CAdmNode NodeToOpen = a_AdmNode.GetParentNodePath();
    METADATA_HANDLE hmd = OpenObjectTo_hmd(NodeToOpen,
                                         METADATA_PERMISSION_WRITE,FALSE/*create node if doesn't exist*/);
    if (SUCCEEDED(hresError))
    {
        CString strToDelete=a_AdmNode.GetCurrentNodeName();
        if(strToDelete==_TEXT(""))
            strToDelete=_TEXT("//"); //empty name has to be wrapped with '/'
        DeleteObject(hmd,strToDelete);
        //CloseObject(hmd); we will reuse it
    }
}

void CAdmUtil::DeleteObject(METADATA_HANDLE a_hmd, CString& a_strObjectName)
{
    hresError = pcAdmCom->DeleteKey(a_hmd, IADM_PBYTE LPCTSTR(a_strObjectName));
    if (FAILED(hresError))  Error(_TEXT("DeleteKey"));

}






void CAdmUtil::EnumPropertiesAndPrint(CAdmNode& a_AdmNode,
                                      CAdmProp a_AdmProp, //cannot be passed by reference
                                      BYTE bRecurLevel,
                                      METADATA_HANDLE a_hmd,
                                      CString & a_strRelPath)
{
    CAdmProp mdrData=a_AdmProp;
    DWORD dwRequiredDataLen=0;
    PBYTE DataBuffer=0;
    METADATA_HANDLE hmdMain;

    if(a_hmd==0) //if handle was not passed then open one
    {
        hmdMain = OpenObjectTo_hmd(a_AdmNode, METADATA_PERMISSION_READ);
        if (FAILED(hresError))
                return;
    }
    else
        hmdMain = a_hmd;

    for (int j=0;;j++) { //cycle for properties
        MD_SET_DATA_RECORD(&mdrData.mdr,
                       0,
                       a_AdmProp.mdr.dwMDAttributes,
                       a_AdmProp.mdr.dwMDUserType,
                       a_AdmProp.mdr.dwMDDataType,
                       dwRequiredDataLen,
                       pbDataBuffer);

        hresError = pcAdmCom->EnumData(hmdMain,
            IADM_PBYTE LPCTSTR(a_strRelPath), &mdrData.mdr,j, &dwRequiredDataLen);
        if (FAILED(hresError))
        {
            if(hresError == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS))
            {
                hresError=0; //NO MORE ITEMS IS NOT ERROR FOR US
                break; //end of items
            }
            else if (hresError == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER))
            {
                delete pbDataBuffer;
                pbDataBuffer=new BYTE[dwRequiredDataLen];
                if (pbDataBuffer==0)
                {
                    hresError = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                    Error(_TEXT("Buffer resize failed"));
                }
                else
                {
                    mdrData.mdr.dwMDDataLen = dwRequiredDataLen;
                    mdrData.mdr.pbMDData = pbDataBuffer;
                    hresError = pcAdmCom->EnumData(hmdMain,
                            IADM_PBYTE LPCTSTR(a_strRelPath), &mdrData.mdr,j, &dwRequiredDataLen);
                    if (FAILED(hresError)) Error(_TEXT("GetData"));
                }
            }
            else
                Error(_TEXT("EnumData"));
        }
        //else
          //  Error(_TEXT("EnumData"));

        if(SUCCEEDED(hresError)) //we  enumerated successfully, let's print
        {
            nest_print(bRecurLevel+1);

            mdrData.PrintProperty();
        }
        else
        {
            break;
        }
    }  //end for j   - cycle for properties
    //if(a_hmd==0)
    //    CloseObject(hmdMain); we will reuse it //close only if we opened at the beginning
}


void CAdmUtil::EnumAndPrint(CAdmNode&   a_AdmNode,
                            CAdmProp&   a_AdmProp,
                            BOOL        a_fRecursive,
                            BYTE        a_bRecurLevel,
                            METADATA_HANDLE a_hmd,
                            CString&    a_strRelPath)
{
    _TCHAR NameBuf[METADATA_MAX_NAME_LEN];

    METADATA_HANDLE hmdMain;

    if(a_hmd==0) //if handle was not passed then open one
    {
        hmdMain = OpenObjectTo_hmd(a_AdmNode, METADATA_PERMISSION_READ);
        if (FAILED(hresError))
                return;
    }
    else
        hmdMain = a_hmd;


    //printf("[RELATIVE PATH : \"%s\"]\n",LPCTSTR(a_strRelPath));
    //print the properties of the node
    EnumPropertiesAndPrint(a_AdmNode,a_AdmProp,a_bRecurLevel,hmdMain,a_strRelPath);


    for (int i=0; ;i++) {  //cycle for subnodes
        hresError = pcAdmCom->EnumKeys(hmdMain,
            IADM_PBYTE LPCTSTR(a_strRelPath), IADM_PBYTE NameBuf, i);
        if(FAILED(hresError)) {
            if(hresError == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS)) {
                hresError=0; //NO MORE ITEMS IS NOT ERROR FOR US
                break; //end of cycle
            }
            else
            {
                Error(_TEXT("EnumKeys"));
                break;
            }

        }
        else {

          //process and print node info

            CString strNewRelPath( a_strRelPath );
            if(NameBuf[0]==0) //empty name
                strNewRelPath+=_TEXT("//"); //add two slashes -> this is required by metabase
            else
            {
                UINT  nLen;
                //if(strNewRelPath.GetLength()>=1 && strNewRelPath.Right(1)==_TEXT("/")) {
                if( (nLen=strNewRelPath.GetLength())>=1 && (strNewRelPath.GetAt(nLen-1)=='/') ) {
                }
                else {
                    strNewRelPath+=_TEXT("/"); //add only if it is not at the end of string.
                }
                strNewRelPath+=NameBuf;
            }
            CString strStringToPrint( a_AdmNode.GetNodePath() );
            UINT  nLen = strStringToPrint.GetLength();

            //if (strStringToPrint.Right(2)==_TEXT("//"))
            if ((nLen > 2) && strStringToPrint.GetAt(nLen-1)=='/'
                           && strStringToPrint.GetAt(nLen-2)=='/' )
            {
                strStringToPrint += strNewRelPath.Mid(1); //strip first '/'
            }
            else
            {
                strStringToPrint += strNewRelPath;
            }
            LPCTSTR lpszStr=LPCTSTR(strStringToPrint);
            this->Print(_TEXT("[%s]\n"),lpszStr );

            if(a_fRecursive)
            {
                EnumAndPrint(a_AdmNode,a_AdmProp ,a_fRecursive, a_bRecurLevel+1, hmdMain,strNewRelPath);
            }
            else
            {  //no recursion

            }
        }
    } //end for i  - cycle for nodes
    //if(a_hmd==0)
    //    CloseObject(hmdMain); //we will reuse it //close only if we opened at the beginning
}


//****************************************************************
//  the following function is somehow complicated because
//  metadata copy function doesn't support copying of one object to another place with different name
//  e.g. ComAdmCopyKey will copy /W3SVC/1//scripts/oldscripts1 /W3SVC/1//oldscripts2
//                          will create /W3SVC/1//oldscripts2/oldscripts1
//

void CAdmUtil::CopyObject(CAdmNode& a_AdmNode,
                          CAdmNode& a_AdmNodeDst)
{
    CString strSrcPath=a_AdmNode.GetNodePath();
    CString strDstPath=a_AdmNodeDst.GetNodePath();


    CString strCommonPath; //=_TEXT("");
    CString strRelSrcPath=strSrcPath; //relative to common path
    CString strRelDstPath=strDstPath; //relative to common path


    //we cannot open Source Path for reading because if will diable wrining to all parent nodes
    //e.g. copy /W3SVC/1//scripts/oldscripts /W3SVC/1//oldscripts would fail
    //It is necessary to find common partial path and open metabase object for that common partial path for READ/WRITE

    //!!!!!!!!!!!!!!!!! assume that paths are not case sensitive

    int MinLength=strSrcPath.GetLength();
    int i;
    //find shorter from strings
    if(strDstPath.GetLength() < MinLength)
            MinLength=strDstPath.GetLength();
    for(i=0; i<MinLength; i++)
    {
        if(strSrcPath.GetAt(i)!=strDstPath.GetAt(i) )
            // common path cannot be any longer;
            break;
    }
    //  now find the previous '/' and all before '/' is the common path
    for(i=i-1; i>=0;i--)
    {
        if(strSrcPath.GetAt(i)==_T('/'))
        {
            strCommonPath=strSrcPath.Left(i+1);//take the trailing '/' with you
            strRelSrcPath=strSrcPath.Mid(i+1);
            strRelDstPath=strDstPath.Mid(i+1);
            break;
        }
    }




    _TCHAR NameBuf[METADATA_MAX_NAME_LEN];

    METADATA_HANDLE hmdCommon=0;

    CAdmNode CommonNode;
    CommonNode.SetPath(strCommonPath);


    hmdCommon = OpenObjectTo_hmd(CommonNode, METADATA_PERMISSION_READ+METADATA_PERMISSION_WRITE);
    if (FAILED(hresError))
            return;

// Altered by Adam Stone on 30-Jan-97  The following code was changed to comply with
// the changes to the metabase ComMDCopyKey function.
    // Copy the metadata to the destination
    hresError = pcAdmCom->CopyKey (hmdCommon,
                                    IADM_PBYTE LPCTSTR(strRelSrcPath),
                                    hmdCommon,
                                    IADM_PBYTE LPCTSTR(strRelDstPath),
                                    FALSE, // Do NOT overwrite
                                    TRUE); // Copy do NOT move

    if (FAILED(hresError)) // if the node already exists, it is error
    {
        CString strErrMsg=_TEXT("CopyKey");
        strErrMsg += _TEXT("(\"")+a_AdmNodeDst.GetRelPathFromInstance()+_TEXT("\")");
        Error(LPCTSTR(strErrMsg));
    }

// All of the commented out code has become unneccessary as of 30-Jan-97  because of a change
// in the metabase.  ComMDCopyKey now copies to the destination, overwriting if
// requested.  It used to copy to a child of the destination object.
/*  // create the node
*   hresError = pcAdmCom->AddKey(hmdCommon,
*                       IADM_PBYTE LPCTSTR(strRelDstPath));
*   if (FAILED(hresError)) { //if the node exists, it is error)
*       CString strErrMsg=_TEXT("AddKey");
*       strErrMsg += _TEXT("(\"")+a_AdmNodeDst.GetRelPathFromInstance()+_TEXT("\")");
*       Error(LPCTSTR(strErrMsg));
*   }
*   else //no error when creating new node
*   {
*       for (i=0; ;i++) {  //cycle for subnodes
*           hresError = pcAdmCom->EnumKeys(hmdCommon,
*               IADM_PBYTE LPCTSTR(strRelSrcPath), (PBYTE)NameBuf, i);
*           if(FAILED(hresError)) {
*               if(hresError == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS)) {
*                   hresError=0; //this is not an error
*                   break; //end of cycle
*               }
*               else
*               {
*                   Error(_TEXT("EnumKeys"));
*                   break;
*               }
*
*           }
*           else {
*
*             //process and copy node child node
*
*               CString strNewRelSrcPath=strRelSrcPath;
*               if(NameBuf[0]==0) //empty name
*                   strNewRelSrcPath+=_TEXT("//"); //add two slashes -> this is required by metabase
*               else
*               {   if(strNewRelSrcPath.GetLength()>=1 && strNewRelSrcPath.Right(1)==_TEXT("/")) {
*                   }
*                   else {
*                       strNewRelSrcPath+=_TEXT("/"); //add only if it is not at the end of string.
*                   }
*                   strNewRelSrcPath+=NameBuf;
*               }
*               hresError = pcAdmCom->CopyKey(
*                   hmdCommon, (PBYTE) LPCTSTR(strNewRelSrcPath),
*                   hmdCommon, (PBYTE) LPCTSTR(strRelDstPath),TRUE,TRUE);
*               if(FAILED(hresError)) {
*                   Error(_TEXT("CopyKey"));
*               }
*
*
*           }
*       } //end for i  - cycle for nodes
*
*
*       //WE COPIED ALL NODES, COPY PARAMETERS NOW
*       CAdmProp mdrData;
*       DWORD dwRequiredDataLen=0;
*       PBYTE DataBuffer=0;
*
*
*
*       for (int j=0;;j++) { //cycle for properties
*           MD_SET_DATA_RECORD(&mdrData.mdr,
*                          0,
*                          0,
*                          0,
*                          0,
*                          dwRequiredDataLen,
*                          pbDataBuffer);
*
*           hresError = pcAdmCom->EnumData(hmdCommon,
*                           (PBYTE) LPCTSTR(strRelSrcPath)
*                           , &mdrData.mdr,j, &dwRequiredDataLen);
*           if (FAILED(hresError))
*           {
*               if(hresError == RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS))
*               {
*                   hresError=0; //NO MORE ITEMS IS NOT ERROR FOR US
*                   break; //end of items
*               }
*               else if (hresError == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER))
*               {
///////////                 delete pbDataBuffer;
*                   pbDataBuffer=new BYTE[dwRequiredDataLen];
*                   if (pbDataBuffer==0)
*                   {
*                       hresError = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
*                       Error(_TEXT("Buffer resize failed"));
*                   }
*                   else
*                   {
*                       mdrData.mdr.dwMDDataLen = dwRequiredDataLen;
*                       mdrData.mdr.pbMDData = pbDataBuffer;
*                       hresError = pcAdmCom->EnumData(hmdCommon,
*                           (PBYTE) LPCTSTR(strRelSrcPath)
*                           , &mdrData.mdr,j, &dwRequiredDataLen);
*                       if (FAILED(hresError)) Error(_TEXT("GetData"));
*                   }
*               }
*               else
*                   Error(_TEXT("EnumData"));
*           }
*           else
*               Error(_TEXT("EnumData"));
*
*           if(SUCCEEDED(hresError)) //we  enumerated successfully, let's print
*           {
*               hresError = pcAdmCom->SetData(hmdCommon, (PBYTE) LPCTSTR(strRelDstPath),&mdrData.mdr);
*               if (FAILED(hresError))  Error(_TEXT("SetData"));
*           }
*           else
*           {
*               break;
*           }
*       }  //end for j   - cycle for properties
*   }
*/


    //CloseObject(hmdCommon); //we will reuse handle //close only if we opened at the beginning

}

void CAdmUtil::RenameObject(CAdmNode& a_AdmNode,
                          CAdmNode& a_AdmNodeDst)
{
    CString strSrcPath=a_AdmNode.GetNodePath();
    CString strDstPath=a_AdmNodeDst.GetNodePath();


    CString strCommonPath=_TEXT("");
    CString strRelSrcPath=strSrcPath; //relative to common path
    CString strRelDstPath=strDstPath; //relative to common path


    //we cannot open Source Path for reading because if will diable wrining to all parent nodes
    //e.g. copy /W3SVC/1//scripts/oldscripts /W3SVC/1//oldscripts would fail
    //It is necessary to find common partial path and open metabase object for that common partial path for READ/WRITE

    //!!!!!!!!!!!!!!!!! assume that paths are not case sensitive

    int MinLength=strSrcPath.GetLength();
    int i;
    //find shorter from strings
    if(strDstPath.GetLength() < MinLength)
            MinLength=strDstPath.GetLength();
    for(i=0; i<MinLength; i++)
    {
        if(strSrcPath.GetAt(i)!=strDstPath.GetAt(i) )
            // common path cannot be any longer;
            break;
    }
    //  now find the previous '/' and all before '/' is the common path
    for(i=i-1; i>=0;i--)
    {
        if(strSrcPath.GetAt(i)==_T('/'))
        {
            strCommonPath=strSrcPath.Left(i+1);//take the trailing '/' with you
            strRelSrcPath=strSrcPath.Mid(i); // keep the trailing '/' in case it's "//"
            strRelDstPath=strDstPath.Mid(i+1);
            break;
        }
    }




    _TCHAR NameBuf[METADATA_MAX_NAME_LEN];

    METADATA_HANDLE hmdCommon=0;

    CAdmNode CommonNode;
    CommonNode.SetPath(strCommonPath);


    hmdCommon = OpenObjectTo_hmd(CommonNode, METADATA_PERMISSION_READ+METADATA_PERMISSION_WRITE);
    if (FAILED(hresError))
            return;

    hresError = pcAdmCom->RenameKey (hmdCommon,
                                    IADM_PBYTE LPCTSTR(strRelSrcPath),
                                    IADM_PBYTE LPCTSTR(strRelDstPath)
                                   );


    if (FAILED(hresError)) // if the node already exists, it is error
    {
        CString strErrMsg=_TEXT("RenameKey");
        strErrMsg += _TEXT("(\"")+a_AdmNodeDst.GetRelPathFromInstance()+_TEXT("\")");
        Error(LPCTSTR(strErrMsg));
    }

    //CloseObject(hmdCommon); //we will reuse it//close only if we opened at the beginning

}



//**********************************************************************
//IMPLEMENTATION  of AdmUtil
//**********************************************************************


void CAdmUtil::Run(CString& strCommand, CAdmNode& a_AdmNode, CAdmProp& a_AdmProp, CAdmNode& a_AdmDstNode,
                LPCTSTR *a_lplpszPropValue,
                DWORD *a_lpdwPropValueLength,
                WORD wPropValueCount)

{

    DWORD dwCommandCode=0;

    dwCommandCode = tCommandNameTable::MapNameToCode(strCommand);

    switch(dwCommandCode)
    {

    case CMD_SAVE:
    SaveData();
    if (FAILED(hresError)) {}
    else{
        printf/*Print*/(_TEXT("saved\n"));
    }
    break;

    case CMD_CREATE:
    {
        if (a_AdmNode.GetProperty()!=_TEXT("")) //property name cannot be used
            Error(_TEXT("property name for CREATE not supported"));
    //    else if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
    //        Error(_TEXT("service name for CREATE is missing"));
        else
        {
            CreateObject(a_AdmNode);
            if( SUCCEEDED(QueryLastHresError()))
            {
              //  SaveData(); //end of transaction
                if( SUCCEEDED(QueryLastHresError()))
                {
                    printf/*Print*/(_TEXT("created \"%s\"\n"), LPCTSTR(a_AdmNode.GetNodePath()));
                }
            }
        }
    }
    break;
    case CMD_SET:
    {
        CAdmProp AdmPropToGet;
        AdmPropToGet = a_AdmProp;
        AdmPropToGet.SetAttrib(0);
        AdmPropToGet.SetUserType(0);
        AdmPropToGet.SetDataType(0);

        DisablePrint(); //do not print any error message
        GetProperty(a_AdmNode, AdmPropToGet);
        EnablePrint(); //continue printing error messages

        //*************************SETTING ATTRIB, DATATYPE, USERTYPE
        // if the parameter exists in the metabase, then existing ATTRIB, DATATYPE, USERTYPE
        //              will be used , but this can be overwritten from a_AdmProp
        // if the parameter doesn't exists in the metabase, then default ATTRIB, DATATYPE, USERTYPE
        //              (see tables.cpp) will be used , but this can be overwritten from a_AdmProp

        if(FAILED(QueryLastHresError()))
        {  //store the value to be set into a_AdmProp
                //FIND DEFAULT SETTINGS
                DWORD dwPropCode=a_AdmProp.GetIdentifier();
                tPropertyNameTable * PropNameTableRecord = tPropertyNameTable::FindRecord(dwPropCode);
                if (PropNameTableRecord!=NULL)
                {
                        AdmPropToGet.SetIdentifier(PropNameTableRecord->dwCode);
                        AdmPropToGet.SetAttrib(PropNameTableRecord->dwDefAttributes) ;
                        AdmPropToGet.SetUserType(PropNameTableRecord->dwDefUserType);
                        AdmPropToGet.SetDataType(PropNameTableRecord->dwDefDataType);
                }
        }
        else
        {  //reuse the existing settings
                if( a_AdmProp.GetDataType()!=0 &&(a_AdmProp.GetDataType()!= AdmPropToGet.GetDataType()))
                {
                        Error(_TEXT("Cannot redefine data type from %s to %s"),
                                tDataTypeNameTable::MapCodeToName(AdmPropToGet.GetDataType()),
                                tDataTypeNameTable::MapCodeToName(a_AdmProp.GetDataType()));
                        break;
                }
        }
        // use settings passed to the function if set
        if(!a_AdmProp.IsSetDataType())
                a_AdmProp.SetDataType(AdmPropToGet.GetDataType()); //reuse existing data type
        if(!a_AdmProp.IsSetUserType())
                a_AdmProp.SetUserType(AdmPropToGet.GetUserType()); //reuse existing user type
        if(!a_AdmProp.IsSetAttrib())
                a_AdmProp.SetAttrib(AdmPropToGet.GetAttrib()); //reuse exixting attrib




        if(a_AdmProp.SetValueByDataType( (LPCTSTR *)a_lplpszPropValue, a_lpdwPropValueLength, wPropValueCount)==0)
             Error(_TEXT("SetValueByDataType failed"));
        else
        {
           // if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
           //     Error(_TEXT("service name for SET is missing"));
           // else
            if (a_AdmNode.GetProperty()!=_TEXT(""))
            {
                SetProperty(a_AdmNode, a_AdmProp);
                if( SUCCEEDED(QueryLastHresError()))
                {
                    //SaveData(); //end of transaction
                    if( SUCCEEDED(QueryLastHresError()))
                    {
                        GetProperty(a_AdmNode, a_AdmProp);
                        if(SUCCEEDED(QueryLastHresError()))
                            a_AdmProp.PrintProperty();
                    }
                }
            }else
                Error(_TEXT("property name missing for SET command"));
        }
        break;
    }
    case CMD_DELETE:

        //if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
        //    Error(_TEXT("service name for DELETE is missing"));
        if (IsServiceName(a_AdmNode.GetService()) && a_AdmNode.GetInstance()==_TEXT("") && a_AdmNode.GetIPath()==_TEXT("") && a_AdmNode.GetProperty()==_TEXT(""))
            Error(_TEXT("cannot delete service"));
        else if (a_AdmNode.GetInstance()==_TEXT("1") && a_AdmNode.GetIPath()==_TEXT("") && a_AdmNode.GetProperty()==_TEXT("")) //property name cannot be used
            Error(_TEXT("cannot delete 1. instance"));
        else if (a_AdmNode.GetProperty()!=_TEXT(""))
        {
            DeleteProperty(a_AdmNode, a_AdmProp);
        }
        else
        {
            DeleteObject(a_AdmNode, a_AdmProp);
        }
            //if( SUCCEEDED(QueryLastHresError()))
            //{
            //  GetProperty(a_AdmNode, a_AdmProp);
            //  if(SUCCEEDED(QueryLastHresError()))
            //      a_AdmProp.PrintProperty();
            //}
        if(SUCCEEDED(QueryLastHresError()))
        {
            //SaveData(); //end of transaction
            if( SUCCEEDED(QueryLastHresError()))
            {
                printf/*Print*/(_TEXT("deleted \"%s"), LPCTSTR(a_AdmNode.GetNodePath()));
                if(a_AdmNode.GetProperty()!=_TEXT(""))
                    printf/*Print*/(_TEXT("%s"),LPCTSTR(((a_AdmNode.GetNodePath().Right(1)==_TEXT("/"))?_TEXT(""):_TEXT("/"))+
                                    a_AdmNode.GetProperty()));
                printf/*Print*/(_TEXT("\"\n"));
            }

        }
        break;

    case CMD_GET:
        //    if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
        //        Error(_TEXT("service name for GET is missing"));

        //    else
            if (a_AdmNode.GetProperty()!=_TEXT(""))
            {
                GetProperty(a_AdmNode, a_AdmProp);
                if(SUCCEEDED(QueryLastHresError()))
                    a_AdmProp.PrintProperty();
            }
            else
            {
                EnumPropertiesAndPrint(a_AdmNode, a_AdmProp);
            }
        break;
    case CMD_COPY:

            if(a_AdmDstNode.GetNodePath()==_TEXT(""))
                Error(_TEXT("destination path is missing"));
            else if(a_AdmNode.GetProperty()!=_TEXT("") || a_AdmDstNode.GetProperty()!=_TEXT(""))
                Error(_TEXT("copying of properties (parameters) not supported\n"));
            //else if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("service name in source path for COPY is missing"));
            //else if (a_AdmDstNode.GetService()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("service name for destination path COPY is missing"));
            //else if (a_AdmNode.GetInstance()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("instance number in source path for COPY is missing"));
            //else if (a_AdmDstNode.GetInstance()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("instance number in destination path for COPY is missing"));

            else
            {
                CopyObject(a_AdmNode,a_AdmDstNode);
                if(SUCCEEDED(QueryLastHresError()))
                {
                    //SaveData(); //end of transaction
                    if( SUCCEEDED(QueryLastHresError()))
                    {

                        printf/*Print*/(_TEXT("copied from %s to %s\n"), LPCTSTR(a_AdmNode.GetNodePath()),LPCTSTR(a_AdmDstNode.GetNodePath()));
                    }
                }
                break;
            }
        break;
    case CMD_RENAME:
            if(a_AdmDstNode.GetNodePath()==_TEXT(""))
                Error(_TEXT("destination path is missing"));
            else if(a_AdmNode.GetProperty()!=_TEXT("") || a_AdmDstNode.GetProperty()!=_TEXT(""))
                Error(_TEXT("renaming of properties (parameters) not supported"));
            //else if (a_AdmNode.GetService()==_TEXT("")) //property name cannot be used
            //    Error(_TEXT("service name in source path for RENAME is missing"));
            //else if (a_AdmDstNode.GetService()==_TEXT(""))
            //    Error(_TEXT("service name for destination path RENAME is missing"));
            //else if (a_AdmNode.GetInstance()==_TEXT(""))
            //    Error(_TEXT("instance number in source path for RENAME is missing"));
            //else if (a_AdmDstNode.GetInstance()==_TEXT(""))
            //   Error(_TEXT("instance number in destination path for RENAME is missing"));
            else if (a_AdmNode.GetInstance()==_TEXT("1") && a_AdmNode.GetIPath()==_TEXT(""))
                Error(_TEXT("cannot rename 1. instance"));
            else if (a_AdmNode.GetRelPathFromService().CompareNoCase(a_AdmDstNode.GetRelPathFromService())==0)
                Error(_TEXT("cannot rename to itself"));
            else
            {  //check if one of the paths is not the child of the other one
                CString str1=a_AdmNode.GetRelPathFromService();
                CString str2=a_AdmDstNode.GetRelPathFromService();

                CString strCommonPath=FindCommonPath(str1,str2);

                if(strCommonPath.CompareNoCase(str1)==0 ||
                        strCommonPath.CompareNoCase(str1)==0)
                    Error(_TEXT("cannot rename - one path is the child of the other"));
                else
                { //O.K.
                    //CopyObject(a_AdmNode,a_AdmDstNode);
                    //if(SUCCEEDED(QueryLastHresError()))
                    //{
                    //    DeleteObject(a_AdmNode,a_AdmProp);
                    //    if(SUCCEEDED(QueryLastHresError()))
                    //    {
                    //       // SaveData(); //end of transaction
                    //        if( SUCCEEDED(QueryLastHresError()))
                    //        {
                    //            printf/*Print*/("renamed from %s to %s\n", LPCTSTR(a_AdmNode.GetNodePath()),LPCTSTR(a_AdmDstNode.GetNodePath()));
                    //        }
                    //    }
                    // }
                    RenameObject(a_AdmNode,a_AdmDstNode);
                    if(SUCCEEDED(QueryLastHresError()))
                    {
                      // SaveData(); //end of transaction
                       if( SUCCEEDED(QueryLastHresError()))
                       {

                           printf/*Print*/(_TEXT("renamed from %s to %s\n"), LPCTSTR(a_AdmNode.GetNodePath()),LPCTSTR(a_AdmDstNode.GetNodePath()));
                       }
                    }
                }
            }

            break;

    case CMD_ENUM:
            EnumAndPrint(a_AdmNode, a_AdmProp, FALSE/*no recursion*/);
            break;
    case CMD_ENUM_ALL:
            EnumAndPrint(a_AdmNode, a_AdmProp,TRUE/*no recursion*/);
            break;
    case CMD_APPCREATEINPROC:
            AppCreateInProc(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;

    case CMD_APPCREATEOUTPOOL:
            AppCreateOutPool(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;

    case CMD_APPDELETE:
            AppDelete(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;

    case CMD_APPRENAME:
            AppRename(a_AdmNode,a_AdmDstNode,a_AdmNode.GetComputer());
            break;

    case CMD_APPCREATEOUTPROC:
            AppCreateOutProc(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;

    case CMD_APPGETSTATUS:
            AppGetStatus(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;

    case CMD_APPUNLOAD:
            AppUnLoad(LPCTSTR(a_AdmNode.GetLMNodePath()),a_AdmNode.GetComputer());
            break;


    default:
        printf/*Print*/(_TEXT("Command not recognized: %s\n"),strCommand);
        hresError=RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
        return ;

    }
    return;
}


//if hresError is 0, we will set it to invalid parameter

void CAdmUtil::Error(const _TCHAR * format,...)
{
   _TCHAR buffer[2000];
   va_list marker;
   va_start( marker, format );     /* Initialize variable arguments. */

   int x=_vstprintf(buffer, format, marker);

   va_end( marker );              /* Reset variable arguments.      */
    if(hresError==0)
    {
        if(fPrint)
    {
            _ftprintf(stderr,_TEXT("Error: %s\n"),buffer);
    }

        hresError=RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER); //little trick
    }
    else
    {
	

        if(fPrint)
        {
            _ftprintf(stderr,_TEXT("Error: %s - HRES(0x%x)   %s\n"), buffer, hresError/*, ConvertHresToDword(hresError),ConvertHresToDword(hresError)*/,ConvertReturnCodeToString(ConvertHresToDword(hresError)));
	    if(getenv("MDUTIL_ASCENT_LOG")!=NULL)
	    {
		//we got to do some ascent logging
		
		FILE *fpAscent;
		fpAscent=fopen("Ascent.log","a");
		if (fpAscent)
		{
			//new variation description
			fprintf(fpAscent,"Variation1: METADATA ACCESS (by mdutil.exe)\n");
			fprintf(fpAscent,"Explain: READ OR WRITE OPERATION TO METADATA \n");
		
			//variation summary
			fprintf(fpAscent,"Attempted: 1 \n");
			fprintf(fpAscent,"Passed: 0 \n");
			fprintf(fpAscent,"Failed: 1 \n");

			
			_ftprintf(fpAscent,_TEXT("Error: Operation failed with HRES(0x%x)\n"), hresError);

			fclose(fpAscent);
		}	
	    }
	}	
    }

    if(fPrint)
    {
	  if(getenv("MDUTIL_BLOCK_ON_ERROR")!=NULL && hresError!=0x80070003)  //path not found
	  {
		_ftprintf(stdout,_TEXT("\nHit SPACE to continue or Ctrl-C to abort.\n"));
		while(1)
		{
			while(!_kbhit())
			{
				;
			}
            	
			if(_getch()==' ')
			{
				_ftprintf(stdout,_TEXT("Continuing...\n"));
				break;
			}
		}
	  }
     }

}

void CAdmUtil::Print(const _TCHAR * format,...)
{

   va_list marker;
   va_start( marker, format );     /* Initialize variable arguments. */
   if(fPrint)
    _vtprintf(format, marker);
   va_end( marker );              /* Reset variable arguments.      */
}


LPTSTR ConvertReturnCodeToString(DWORD ReturnCode)
{
    LPTSTR RetCode = NULL;
    switch (ReturnCode) {
    case ERROR_SUCCESS:
        RetCode = _TEXT("ERROR_SUCCESS");
        break;
    case ERROR_PATH_NOT_FOUND:
        RetCode = _TEXT("ERROR_PATH_NOT_FOUND");
        break;
    case ERROR_INVALID_HANDLE:
        RetCode = _TEXT("ERROR_INVALID_HANDLE");
        break;
    case ERROR_INVALID_DATA:
        RetCode =_TEXT("ERROR_INVALID_DATA");
        break;
    case ERROR_INVALID_PARAMETER:
        RetCode =_TEXT("ERROR_INVALID_PARAMETER");
        break;
    case ERROR_NOT_SUPPORTED:
        RetCode =_TEXT("ERROR_NOT_SUPPORTED");
        break;
    case ERROR_ACCESS_DENIED:
        RetCode =_TEXT("ERROR_ACCESS_DENIED");
        break;
    case ERROR_NOT_ENOUGH_MEMORY:
        RetCode =_TEXT("ERROR_NOT_ENOUGH_MEMORY");
        break;
    case ERROR_FILE_NOT_FOUND:
        RetCode =_TEXT("ERROR_FILE_NOT_FOUND");
        break;
    case ERROR_DUP_NAME:
        RetCode =_TEXT("ERROR_DUP_NAME");
        break;
    case ERROR_PATH_BUSY:
        RetCode =_TEXT("ERROR_PATH_BUSY");
        break;
    case ERROR_NO_MORE_ITEMS:
        RetCode =_TEXT("ERROR_NO_MORE_ITEMS");
        break;
    case ERROR_INSUFFICIENT_BUFFER:
        RetCode =_TEXT("ERROR_INSUFFICIENT_BUFFER");
        break;
    case ERROR_PROC_NOT_FOUND:
        RetCode =_TEXT("ERROR_PROC_NOT_FOUND");
        break;
    case ERROR_INTERNAL_ERROR:
        RetCode =_TEXT("ERROR_INTERNAL_ERROR");
        break;
    case MD_ERROR_NOT_INITIALIZED:
        RetCode =_TEXT("MD_ERROR_NOT_INITIALIZED");
        break;
    case MD_ERROR_DATA_NOT_FOUND:
        RetCode =_TEXT("MD_ERROR_DATA_NOT_FOUND");
        break;
    case ERROR_ALREADY_EXISTS:
        RetCode =_TEXT("ERROR_ALREADY_EXISTS");
        break;
    case MD_WARNING_PATH_NOT_FOUND:
        RetCode =_TEXT("MD_WARNING_PATH_NOT_FOUND");
        break;
    case MD_WARNING_DUP_NAME:
        RetCode =_TEXT("MD_WARNING_DUP_NAME");
        break;
    case MD_WARNING_INVALID_DATA:
        RetCode =_TEXT("MD_WARNING_INVALID_DATA");
        break;
    case ERROR_INVALID_NAME:
        RetCode =_TEXT("ERROR_INVALID_NAME");
        break;
    default:
        RetCode= _TEXT("");//RetCode = "Unrecognized Error Code");
        break;
    }
    return (RetCode);
}

DWORD ConvertHresToDword(HRESULT hRes)
{
    return HRESULTTOWIN32(hRes);
}

LPTSTR ConvertHresToString(HRESULT hRes)
{
    LPTSTR strReturn = NULL;

    if ((HRESULT_FACILITY(hRes) == FACILITY_WIN32) ||
        (HRESULT_FACILITY(hRes) == FACILITY_ITF) ||
        (hRes == 0)) {
        strReturn = ConvertReturnCodeToString(ConvertHresToDword(hRes));
    }
    else {
        switch (hRes) {
        case CO_E_SERVER_EXEC_FAILURE:
            strReturn =_TEXT("CO_E_SERVER_EXEC_FAILURE");
            break;
        default:
            strReturn =_TEXT("Unrecognized hRes facility");
        }
    }
    return(strReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\jd_misc.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    jd_misc.cpp

Abstract:
	variety of assisting functions
	  - command line parameters parsing
	  - displaying the error messages
	  - creating the random file
          - creating the unique identifier based on thread and process
Author:

    jaroslad  

Revision History:
     06-01-96      ( Jaroslad ) Original.

--*/

#include <tchar.h>
#include "jd_misc.h"

#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>

int random (int low, int high)
{
	return ( low+((long)rand()*(long)high)/RAND_MAX );
}


/* Sample structure demonstating how to use comand line definition structure

  TParamDef CmdLineParam[]=
{
 {"c" ,1, &FtpServerIpAddr,TYPE_TCHAR,OPT, "ftp server computer name", "computer"},
 {"b", 0, &fStop,       TYPE_INT,  OPT, "binary flag"},
 {"start", 0, &fStart,     TYPE_INT,  OPT, "start service"},
 {"pause", 0, &fPause,     TYPE_INT,  OPT, "pause service"},
 {"s" ,1, &ServiceName,    TYPE_TCHAR, MAND,"service name","svc"},

 { {NULL,0, NULL ,         TYPE_TCHAR, OPT, "Place the description of the program here" };

*/

void DisplayUsage( _TCHAR **argv, TParamDef *tt)
{
	_tprintf(_T("Usage:\n\t%s "), argv[0]);
	for(int i=0; tt[i].sw!=0;i++)
	{
		if(tt[i].sw[0]==0) //default (do not need switch) parameters
		{
			_tprintf(_T("%s "),(tt[i].text_param!=NULL)?tt[i].text_param:_T("parm"));
		}
		else
		{
			_tprintf(_T("-%s "),tt[i].sw);
			if(tt[i].param_number==1)
				_tprintf(_T("[%s] "),(tt[i].text_param!=NULL)?tt[i].text_param:_T("parm"));
			else if(tt[i].param_number>1)
				_tprintf(_T("[[%s]...] "),(tt[i].text_param!=NULL)?tt[i].text_param:_T("parm"));
		}
	}

	_tprintf(_T("\n\n"));
	for(i=0; tt[i].sw!=0; i++)
	{
		if(tt[i].sw[0]==0) //default parameters
		{
			_tprintf(_T("\"no switch\"  %s\n"),tt[i].text_desc);
		}
		else if(tt[i].text_desc!=NULL)
		{
			_tprintf(_T("-%-6s %s\n"),tt[i].sw,tt[i].text_desc);
		}
	}
	//print description
	if( tt[i].text_desc!=NULL && tt[i].text_desc[0]!=0)
	{
		_tprintf(_T("\nDescription:\n"));
		_tprintf(_T("%s \n"), tt[i].text_desc);
	}
}

void DisplayUsageAndExit( _TCHAR **argv, TParamDef *tt)
{
	DisplayUsage( argv, tt);
	
	exit(1);
}

//structure that makes easy lexical parsing of the command line arguments

struct sParamLex
{
	int argc;
	TCHAR **argv;
	_TCHAR ParamBuffer[400];
	int iCurrentParamChar;  //character index within the current parameter being processed
	int iCurrentParam;      //index to the current parameter that is processed 
public:
	sParamLex(int argc,_TCHAR **argv):argc(argc),argv(argv){iCurrentParamChar=0; iCurrentParam=1;};
	BOOL IsNextSwitch();
	BOOL IsEnd();
	LPTSTR ReadNext();
};

BOOL sParamLex::IsNextSwitch()
{
	if(IsEnd())
		return FALSE;
	if (argv[iCurrentParam][iCurrentParamChar]==_T('-'))
		return TRUE;
	else
		return FALSE;
}

BOOL sParamLex::IsEnd()
{
	if(iCurrentParam>=argc)
		return TRUE;
	else
		return FALSE;
}

LPTSTR sParamLex::ReadNext()
{
	LPTSTR lpszRetval;
	if (IsEnd())
		return NULL;
	if(IsNextSwitch())
	{	int i=0;
		iCurrentParamChar++; //skip '/' or '-'
		while (argv[iCurrentParam][iCurrentParamChar]!=0 && argv[iCurrentParam][iCurrentParamChar]!=_T(':'))
			ParamBuffer[i++]=argv[iCurrentParam][iCurrentParamChar++];
		if(argv[iCurrentParam][iCurrentParamChar]==_T(':'))
			iCurrentParamChar++;
		if(argv[iCurrentParam][iCurrentParamChar]==0)
		{
			iCurrentParam++; iCurrentParamChar=0;
		}
		ParamBuffer[i]=0;
		lpszRetval=ParamBuffer;
	}
	else
	{
		lpszRetval=&argv[iCurrentParam][iCurrentParamChar];
		iCurrentParam++; iCurrentParamChar=0;
	}
	return lpszRetval;
}


void ParseParam(int argc, _TCHAR ** argv, TParamDef * tt)
{
	
	for(int i=0; tt[i].sw!=NULL ; i++)
	{
		tt[i].curr_param_read=0; //initialize 
	}
	
	sParamLex paramLex(argc,argv);
	
	BOOL fParseBegin=TRUE;
	while(!paramLex.IsEnd())
	{
		int k;
		if(paramLex.IsNextSwitch())
		{
			_TCHAR * sw = paramLex.ReadNext();
			/*find the switch in switch table*/ 
			for( k=0; tt[k].sw!=NULL ;k++)
			{ 
				if(tt[k].sw[0]==0) continue; //skip the default parameters
				if(_tcscmp(tt[k].sw, sw)==0 /*equal*/ )
					break;	
			}
			if(tt[k].sw == NULL) //switch not found
			{	_tprintf(_T("invalid switch \"%s\"\n"),sw);/*error*/
				DisplayUsageAndExit(argv,tt);
			}
		}
		else if( fParseBegin==TRUE && (_tcscmp(tt[0].sw, _T(""))==0 /*equal*/ ) )
		{ //default parameters (has to be the first record in arg description)
			k=0; 
		}
		else
		{
			_tprintf(_T("default arguments not expected\n"));/*error*/
			DisplayUsageAndExit(argv,tt);
		}
			
		
		if(tt[k].param_number==0) //switch without parameters
		{
			if(paramLex.IsEnd()==FALSE && paramLex.IsNextSwitch()==FALSE)
			{
				_tprintf(_T("switch \"%s\" takes no parameters \n"),tt[k].sw);
				DisplayUsageAndExit(argv,tt);
			}
			tt[k].curr_param_read++;
			*((int *)tt[k].ptr)=1;
		}
		else if(tt[k].param_number>0) //swith with more then 0ne parameter
		{
			if(paramLex.IsEnd()==TRUE || paramLex.IsNextSwitch()==TRUE)
			{  _tprintf(_T(" switch \"%s\" expects parameter\n"),tt[k].sw);//error
				DisplayUsageAndExit(argv,tt);
			}
			else
			{
				_TCHAR * prm;
			
				do
				{	
					prm=paramLex.ReadNext();
				
					if(tt[k].param_number <= tt[k].curr_param_read)
					{
						_tprintf(_T("number of parameters for switch -%s exceeds maximum allowed (%d)\n"),tt[k].sw,tt[k].param_number); 
						DisplayUsageAndExit(argv,tt);
					}		
					

					if(tt[k].ptr_type==TYPE_TCHAR || tt[k].ptr_type==TYPE_LPCTSTR)
						*(((_TCHAR **)tt[k].ptr) + tt[k].curr_param_read++)=prm;
					else if(tt[k].ptr_type==TYPE_INT ||tt[k].ptr_type==TYPE_WORD)
						*(((int *)tt[k].ptr) + tt[k].curr_param_read++)=_ttoi(prm);
					else if(tt[k].ptr_type==TYPE_LONG || tt[k].ptr_type==TYPE_DWORD)
						*(((long *)tt[k].ptr) + tt[k].curr_param_read++)=_ttol(prm);
					
				}while (paramLex.IsEnd()==FALSE && paramLex.IsNextSwitch()==FALSE);
		
			}
		}//end tt[k].param_number
		
	} // end while
	for(i=0; tt[i].sw!=0;i++) //check for mandatory switches
	{
		if (tt[i].opt_mand==MAND && tt[i].curr_param_read==0)
		{
			_tprintf(_T("mandatory switch -%s missing\n"),tt[i].sw);
			DisplayUsageAndExit(argv,tt);
		}

		if(tt[i].param_read!=NULL) // set number of params for switch
			*tt[i].param_read=tt[i].curr_param_read;

	}
}




/******************************************
  time_printf
*******************************************/


int time_printf(_TCHAR *format, ...)
{
   static CRITICAL_SECTION cs;
   static BOOL fInit=0;
   va_list marker;

   if(fInit==0)
   {
	   fInit=1;
	   InitializeCriticalSection(&cs);
   }

   _TCHAR buf[80]; 	
   
   EnterCriticalSection(&cs);
   va_start( marker, format );     /* Initialize variable arguments. */
   _tprintf(_TEXT("%s - "),_tstrtime(buf));
   _vtprintf(format,marker);
   LeaveCriticalSection(&cs);
   va_end( marker );              /* Reset variable arguments.      */
 //  printf("%s%s",bufa,bufb); //for multithreaded will be printed as one line
   return 1;
}

void error_printf(_TCHAR *format, ...)
{
   va_list marker;

   va_start( marker, format );     /* Initialize variable arguments. */
   _tprintf(_TEXT("Error: "));
   int x=_vftprintf(stderr,format,marker);
   va_end( marker );              /* Reset variable arguments.      */
   
}

void fatal_error_printf(_TCHAR *format, ...)
{
   va_list marker;
 
   va_start( marker, format );     /* Initialize variable arguments. */
   _tprintf(_TEXT("Error: "));
   int x=_vftprintf(stderr,format,marker);
   va_end( marker );              /* Reset variable arguments.      */
   exit(EXIT_FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\main.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       main.cpp

   Abstract:

       command line admin tool main function

   Environment:

      Win32 User Mode

   Author: 
     
      jaroslad  (jan 1997)

--*/

#include <tchar.h>

#include <afx.h>

#include <string.h>
#include <stdlib.h>
#include <stdio.h>   


#include "admutil.h"
#include "tables.h"
#include "jd_misc.h"    



CAdmUtil oAdmin;  //admin object

#define MAX_NUMBER_OF_SMALL_VALUES  100
#define MAX_NUMBER_OF_VALUES  10100
#define MAX_NUMBER_OF_DEFAULT_ARGS  10110


//structure stores the command line arguments

struct tAdmutilParams
{
    WORD fHelp; //print help - flag
    WORD fFullHelp; //print help - flag
    WORD fNoSave; //do not save metabase
    LPCTSTR lpszCommand;
    LPCTSTR lpszComputer;
    WORD  wInstance;
    LPCTSTR lpszService;
    LPCTSTR lpszPath;
    LPCTSTR lpszComputerDst; //for COPY destination
    WORD  wInstanceDst;     //for COPY destination
    LPCTSTR lpszServiceDst; //for COPY destination
    LPCTSTR lpszPathDst;        //for COPY destination

    LPCTSTR lplpszDefaultArg[MAX_NUMBER_OF_DEFAULT_ARGS];
    WORD wDefaultArgCount;

    LPCTSTR lpszPropName;

    LPCTSTR lplpszPropAttrib[MAX_NUMBER_OF_SMALL_VALUES];
    WORD  wPropAttribCount;
    LPCTSTR lplpszPropDataType[MAX_NUMBER_OF_SMALL_VALUES];
    WORD wPropDataTypeCount;
    LPCTSTR lplpszPropUserType[MAX_NUMBER_OF_SMALL_VALUES];
    WORD wPropUserTypeCount;
    LPCTSTR lplpszPropValue[MAX_NUMBER_OF_VALUES]; //pointer to array of values (e.g multisz type allows the multiple values for one property
    DWORD lpdwPropValueLength[MAX_NUMBER_OF_VALUES];
    WORD  wPropValueCount;
    WORD  wPropFileValueCount;
};

tAdmutilParams Params;
_TCHAR **g_argv;
int g_argc;

static BOOL CompareOutput(_TCHAR *FileToCompare,_TCHAR* FileTemplate);

// definition of command line syntax with some help text -this is the input for ParseParam()

TParamDef CmdLineArgDesc[]=
{
 {_TEXT(""),MAX_NUMBER_OF_DEFAULT_ARGS, (void *) Params.lplpszDefaultArg,TYPE_LPCTSTR,OPT, _TEXT("Command [param ...]"),_TEXT("CMD [param param]"),&Params.wDefaultArgCount},
 {_TEXT("svc") ,1, (void *) &Params.lpszService,TYPE_LPCTSTR,OPT,_TEXT("service (MSFTPSVC, W3SVC)")},
 {_TEXT("s"), 1, (void *) &Params.lpszComputer,TYPE_LPCTSTR,OPT, _TEXT("name of computer to administer"),_TEXT("comp"),},          
 {_TEXT("i") ,1, &Params.wInstance, TYPE_WORD, OPT,_TEXT("instance number"),_TEXT("inst")},
 {_TEXT("path"),1, (void *) &Params.lpszPath,   TYPE_LPCTSTR,OPT, _TEXT("path "),_TEXT("path")},
 {_TEXT("pathdst"),1, (void *) &Params.lpszPathDst, TYPE_LPCTSTR,OPT, _TEXT("destination path (use for COPY only)"),_TEXT("path")},
 {_TEXT("prop"),1, (void *) &Params.lpszPropName, TYPE_LPCTSTR,OPT, _T("property (IIS parameter) name")},
 {_TEXT("attrib"),MAX_NUMBER_OF_SMALL_VALUES, (void *) Params.lplpszPropAttrib,TYPE_LPCTSTR,OPT, _T("property attributes"),_T(""),&Params.wPropAttribCount},
 {_TEXT("utype"),MAX_NUMBER_OF_SMALL_VALUES, (void *) Params.lplpszPropUserType,TYPE_LPCTSTR,OPT, _T("property user type"),_T(""),&Params.wPropUserTypeCount},
 {_TEXT("dtype"),MAX_NUMBER_OF_SMALL_VALUES, (void *) Params.lplpszPropDataType,TYPE_LPCTSTR,OPT, _T("property data type"),_T(""),&Params.wPropDataTypeCount},
 {_TEXT("value"),MAX_NUMBER_OF_VALUES, (void *) Params.lplpszPropValue,TYPE_LPCTSTR,OPT, _T("property values"),_T(""),&Params.wPropValueCount},
 {_TEXT("fvalue"),MAX_NUMBER_OF_VALUES, (void *) Params.lplpszPropValue,TYPE_LPCTSTR,OPT, _T("property values as files"),_T(""),&Params.wPropFileValueCount},
 {_TEXT("nosave"),0, &Params.fNoSave,TYPE_WORD,OPT, _T("do not save metabase"),_T("")},
 {_TEXT("timeout"),1, &g_dwTIMEOUT_VALUE,TYPE_DWORD,OPT, _T("timeout for metabase access in ms (default is 30000 sec"),_T("")},
 {_TEXT("delayafteropen"),1, &g_dwDELAY_AFTER_OPEN_VALUE,TYPE_DWORD,OPT, _T("delay after opening node (default is 0 sec)"),_T("")},
 {_TEXT("help"),0, &Params.fFullHelp,TYPE_WORD,OPT, _T("print full help"),_T("")},
 {_TEXT("?"),0, &Params.fHelp,TYPE_WORD,OPT, _T("print help"),_T("")},  
  {NULL,0, NULL ,         TYPE_TCHAR, OPT, 
   _T("IIS K2 administration utility that enables the manipulation with metabase parameters\n")
   _T("\n")
   _T("Notes:\n")
   _T(" Simpified usage of mdutil doesn't require any switches.\n")
   _T(" \n")
   _T(" mdutil GET      path             - display chosen parameter\n")
   _T(" mdutil SET      path value ...   - assign the new value\n")
   _T(" mdutil ENUM     path             - enumerate all parameters for given path\n")
   _T(" mdutil ENUM_ALL path             - recursively enumerate all parameters\n")
   _T(" mdutil DELETE   path             - delete given path or parameter\n")
   _T(" mdutil CREATE   path             - create given path\n")
   _T(" mdutil COPY     pathsrc pathdst  - copy all from pathsrc to pathdst (will create pathdst)\n")
   _T(" mdutil RENAME   pathsrc pathdst  - rename chosen path\n")
   _T(" mdutil SCRIPT   scriptname       - runs the script\n")
   _T(" mdutil APPCREATEINPROC  w3svc/1/root - Create an in-proc application \n")
   _T(" mdutil APPCREATEOUTPOOL  w3svc/1/root - Create an pooled out-proc application \n")
   _T(" mdutil APPCREATEOUTPROC w3svc/1/root - Create an out-proc application\n")
   _T(" mdutil APPDELETE        w3svc/1/root - Delete the application if there is one\n")
   _T(" mdutil APPRENAME        w3svc/1/root/dira w3svc/1/root/dirb - Rename the application \n")
   _T(" mdutil APPUNLOAD        w3svc/1/root - Unload an application from w3svc runtime lookup table.\n")
   _T(" mdutil APPGETSTATUS     w3svc/1/root - Get status of the application\n")
   _T("\n")
   _T("  -path has format: {computer}/{service}/{instance}/{URL}/{Parameter}\n")
   _T("\n")
   _T("Samples:\n")
   _T("  mdutil GET W3SVC/1/ServerBindings     \n")
   _T("  mdutil SET JAROSLAD2/W3SVC/1/ServerBindings \":81:\"\n")
   _T("  mdutil COPY W3SVC/1/ROOT/iisadmin W3SVC/2/ROOT/adm\n")
   _T("  mdutil ENUM_ALL W3SVC\n")
   _T("  mdutil ENUM W3SVC/1\n")
   _T("\n")
   _T("Additional features\n")
   _T("  set MDUTIL_BLOCK_ON_ERROR environment variable to block mdutil.exe after error (except ERROR_PATH_NOT_FOUND)\n")
   _T("  set MDUTIL_ASCENT_LOG environment variable to force mdutil.exe to append errors to ascent log\n")
   _T("  set MDUTIL_PRINT_ID environment variable to force mdutil.exe to print metadata numeric identifiers along with friendly names\n")
 }
};


BOOL
ReadFromFiles( 
    LPTSTR*  lplpszPropValue,
    DWORD*  lpdwPropValueLength,
    DWORD   dwPropFileValueCount 
    )
{
    DWORD dwL;

    while ( dwPropFileValueCount-- )
    {
        FILE* fIn = _tfopen( lplpszPropValue[dwPropFileValueCount], _T("rb") );
        if ( fIn == NULL )
        {
            return FALSE;
        }
        if ( fseek( fIn, 0, SEEK_END ) == 0 )
        {
            dwL = ftell( fIn );
            fseek( fIn, 0, SEEK_SET );
        }
        else
        {
            fclose( fIn );
            return FALSE;
        }
        if ( (lplpszPropValue[dwPropFileValueCount] = (LPTSTR)malloc( dwL )) == NULL )
        {
            fclose( fIn );
            return FALSE;
        }
        if ( fread( lplpszPropValue[dwPropFileValueCount], 1, dwL, fIn ) != dwL )
        {
            fclose( fIn );
            return FALSE;
        }
        fclose( fIn );
        lpdwPropValueLength[dwPropFileValueCount] = dwL;
    }

    return TRUE;
}

///////////////////////////////

class CScript
{
    FILE * m_fpScript;
    void GetNextToken(/*OUT*/ LPTSTR * lplpszToken);
    DWORD CleanWhiteSpaces(void);
public:
    CScript(void) {m_fpScript=0;};
    DWORD Open(LPCTSTR lpszFile);
    DWORD Close(void);
    DWORD GetNextLineTokens(int *argc, /*OUT*/ _TCHAR *** argv);
};



DWORD CScript::CleanWhiteSpaces()
{

    if(m_fpScript!=NULL)
    {
        int LastChar=0;
        _TINT c=0;
        while(1)
        {   
            LastChar=c;
            c=_fgettc(m_fpScript);
            if(c==_T('\t') || c==_T(' ') || c==_T('\r'))
            {   continue;
            }
            if(c==_T('\\'))
            {
                int cc=_fgettc(m_fpScript);
                if (cc==_T('\r')) //continue with the next line of the file
                {
                    if(_fgettc(m_fpScript)!=_T('\n'))
                    {
                        fseek( m_fpScript, -1, SEEK_CUR );
                    }
                    continue;
                }
                else if (cc==_T('\n')) //continue with the next line of the file
                {   
                    continue;
                }   
                else
                {
                    fseek( m_fpScript, -2, SEEK_CUR );
                    break;
                }
            }
            if(c==WEOF)
            {   break;
            }
            else
            {   fseek( m_fpScript, -1, SEEK_CUR ); //return back one position
                break;
            }
        }
    }
    return 0;
}

void CScript::GetNextToken(LPTSTR * lplpszToken)
{
    enum {TERMINATE_QUOTE, TERMINATE_WHITESPACE};
    long flag=TERMINATE_WHITESPACE;

    //clean white spaces
    CleanWhiteSpaces();
    //store the beginning offset of token
    long Offset = ftell(m_fpScript);
    _TINT c=_fgettc(m_fpScript);
    long CurrentOffset=0;
    
    if(c==WEOF)
    {
        *lplpszToken=NULL;
        return ;
    }
    if (c==_T('\n')){
        *lplpszToken=_T("\n");
        return ;
    }
    else
    {
        if (c==_T('\"')) { //token ends with " or the end of the line
            flag=TERMINATE_QUOTE;
            Offset = ftell(m_fpScript);
        }
        else {
            flag=TERMINATE_WHITESPACE;
        }
        
        // find the end of the token
        while(1) {
            CurrentOffset=ftell(m_fpScript);
            c=_fgettc(m_fpScript);
            
            if(c==_T('\n')){
                break;
            }

            if(c==WEOF)
            {
                break;
            }

            
            if( (flag==TERMINATE_QUOTE && c==_T('\"')) || (
                    flag==TERMINATE_WHITESPACE && (c==_T(' ') || c==_T('\t') || c==_T('\r')) ) ){
                break;
            }
        }
        

        //get the token size
        long TokenSize = CurrentOffset - Offset;
        
        if(TokenSize!=0)
        {
            // allocate mamory for the token
            *lplpszToken = new _TCHAR[ TokenSize+1 ];
            //read the token
            fseek( m_fpScript, Offset, SEEK_SET);
            for(int i=0;i<TokenSize;i++)
                (*lplpszToken)[i]=(TCHAR)_fgettc(m_fpScript);
            //terminate the token
            (*lplpszToken)[i]=0; 
        }
        else
        { //empty string
            *lplpszToken=new _TCHAR[1 ];
            (*lplpszToken)[0]=0;
        }
        //discard double quote if it was at the end of the token
        c=_fgettc(m_fpScript);
        if(c!=_T('\"'))
            fseek( m_fpScript, ((c==WEOF)?0:-1), SEEK_CUR );
    }
}
    


DWORD CScript::Open(LPCTSTR lpszFile)
{
    m_fpScript = _tfopen(  lpszFile, _T("rt") );
    if(m_fpScript==NULL)
        return GetLastError();
    else
        return ERROR_SUCCESS;
}

DWORD CScript::Close()
{
    if( m_fpScript!=NULL)
        fclose( m_fpScript);
    return GetLastError();
}


DWORD CScript::GetNextLineTokens(int *argc, /*OUT*/ _TCHAR *** argv)
{
    for(int i=1;i<*argc;i++) {
        delete  (*argv)[i];
        (*argv)[i]=0;
    }
    *argc=0;
    if(*argv==NULL)
        (*argv)=new LPTSTR [ MAX_NUMBER_OF_VALUES ];

    (*argv)[(*argc)++]=_T("mdutil"); //set zero parameter
    
    LPTSTR lpszNextToken=NULL;
    while((*argc)<MAX_NUMBER_OF_VALUES) 
    {
        GetNextToken( &lpszNextToken );
        if( lpszNextToken==NULL )  //end of file
        {
            break;
        }
    
        if(_tcscmp(lpszNextToken,_T("\n"))==0)  //new line
        {
            delete lpszNextToken;
            lpszNextToken = NULL;

            break;
        }
        
        (*argv)[(*argc)++]=lpszNextToken;
        
        lpszNextToken = NULL;
    }

    return GetLastError();
}


int  MainFunc(int argc, _TCHAR **argv); //declaration



//MAIN FUNCTION
int __cdecl main(int argc, CHAR **_argv)
{


    //  convert parameters from SBCS to UNICODE;
    _TCHAR **argv= new LPTSTR [argc];
    for (int i=0;i<argc;i++)
    {
        argv[i]=new _TCHAR[strlen(_argv[i])+1];
        #ifdef UNICODE
            MultiByteToWideChar(0, 0, _argv[i], -1, argv[i],strlen(_argv[i])+1 );
        #else
            strcpy(argv[i],_argv[i]);
        #endif  
    }
    

    DWORD dwCommandCode=0;

    DWORD retval=0;
    HRESULT hRes;
    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (FAILED(hRes)) {
        fatal_error_printf(_T("CoInitializeEx\n"));
    }

    //extract command line parameters
    ParseParam(argc,argv,CmdLineArgDesc); 
    //**************************
    //PRINT HELP ON REQUEST
    if(Params.fFullHelp)
    {
        //print help
        DisplayUsage(argv,CmdLineArgDesc);
        PrintTablesInfo();
    }
    else if(Params.wDefaultArgCount==0 || Params.fHelp)
    {
        //print help
        DisplayUsage(argv,CmdLineArgDesc);
    }
    else
    {
            if (Params.wDefaultArgCount>0)
    { 
        //first default has to be command
        Params.lpszCommand=Params.lplpszDefaultArg[0];
        dwCommandCode = tCommandNameTable::MapNameToCode(Params.lplpszDefaultArg[0]);
        if( Params.wDefaultArgCount>1)
        {   //second default 
                Params.lpszPath=Params.lplpszDefaultArg[1];
        }
            if(dwCommandCode==CMD_SCRIPT)  //process script
            { 
                tAdmutilParams StoredParams=Params;

                CScript Script;
                DWORD dwRes;
                if((dwRes=Script.Open(Params.lpszPath))!=ERROR_SUCCESS)
                    fatal_error_printf(_T("cannot open script file %s (error %d)\n"),Params.lpszPath,dwRes);

                int l_argc=0;
                _TCHAR ** l_argv=NULL;
                while(1)
                {
                    Script.GetNextLineTokens(&l_argc,&l_argv);
                    if(l_argc==1) //end of script file
                        break;
                    Params=StoredParams; 
                    _tprintf(_T(">"));
                    for(int i=1;i<l_argc;i++)
                        _tprintf(_T("%s "),l_argv[i]);
                    _tprintf(_T("\n"));
                    DWORD retval1=MainFunc(l_argc,l_argv);
                    retval = ((retval==0) ? retval1:retval);
                }
                if (oAdmin.GetpcAdmCom()!=NULL)
                {
                    if(Params.fNoSave)
                    {}
                    else
                        oAdmin.SaveData();
                }

            }
            else
            {
                retval=MainFunc(argc,argv); //run only one command typed on the command line
                if (oAdmin.GetpcAdmCom()!=NULL)
                {
                    if(Params.fNoSave)
                    {}
                    else
                        oAdmin.SaveData();
                }
            }
        }   
    
        
    }

    //close admin object
    oAdmin.Close(); 
    //close wam adm object
    oAdmin.CloseWamAdm();

    CoUninitialize();
    //Cleanup of parameters
    if(argv!=0)
    {
        for (int i=0;i<argc;i++)
        {
            delete [] argv[i];
        }
        delete argv;
    }

    return retval;

}

int  MainFunc(int argc, _TCHAR **argv)
{   
    g_argc=argc;
    g_argv=argv;
    DWORD retval;
    
    LPCTSTR lpszCommand=0;

    CAdmNode AdmNode;
    CAdmProp AdmProp;
    CAdmNode AdmDstNode;

    int i;
    
    DWORD dwCommandCode=0;

    //extract command line parameters
    ParseParam(argc,argv,CmdLineArgDesc); 
    

    //PROCESS THE DEFAULT PARAMETERS
    // trick: place the default arguments into variables that apply for non default one (see Params structure)
    
    if (Params.wDefaultArgCount>0)
    { //first default has to be command
        Params.lpszCommand=Params.lplpszDefaultArg[0];
        dwCommandCode = tCommandNameTable::MapNameToCode(Params.lplpszDefaultArg[0]);
        if( Params.wDefaultArgCount>1)
        {//second deault has to be path
                Params.lpszPath=Params.lplpszDefaultArg[1];
        }
        if( Params.wDefaultArgCount>2)
        {
            switch(dwCommandCode)
            { 

            case CMD_SET:
                //the rest of default args are values
                Params.wPropValueCount=0;
                for(i=2;i<Params.wDefaultArgCount;i++)
                {
                    Params.lplpszPropValue[i-2] = Params.lplpszDefaultArg[i];
                    Params.wPropValueCount++;
                }
                break;
             case CMD_DELETE:
             case CMD_CREATE:
             case CMD_GET:
             case CMD_ENUM:
             case CMD_ENUM_ALL:
                 if( Params.wDefaultArgCount>2)
                 {
                    error_printf(_T("maximum default arguments number exceeds expected (2)\n"));
                    return 1;
                 }
                 
                        break;
             case CMD_COPY:
             case CMD_RENAME: 
             case CMD_APPRENAME: 
                 if( Params.wDefaultArgCount>3)
                 {
                    error_printf(_T("maximum default arguments number exceeds expected (3)\n"));
                    return 1;
                 }

                 else
                    Params.lpszPathDst=Params.lplpszDefaultArg[2];
                 break;

             default:
                error_printf(_T("command not recognized: %s or number of parameters doesn't match\n"),Params.lpszCommand);
                return 1;

            }
        }
    } //end of default argument handling

        
    //extract computer,service,instance, if stored in Path
    AdmNode.SetPath(Params.lpszPath);

    //valid only for copy function
    AdmDstNode.SetPath(Params.lpszPathDst);

    //process computer, service, instance, property name arguments
    if(Params.lpszComputer!=NULL) {
        if(!AdmNode.GetComputer().IsEmpty()) {
            error_printf(_T("computer name entered more than once\n"));
            return 1;
        }
        else
            AdmNode.SetComputer(Params.lpszComputer);
    }

    if(Params.lpszService!=NULL) {
        if(!AdmNode.GetService().IsEmpty()) {
            error_printf(_T("service name entered more than once\n"));
            return 1;
        }
        else {
            if(IsServiceName(Params.lpszService))
                AdmNode.SetService(Params.lpszService);
            else {
                error_printf(_T("service name not recognized: %s\n"), Params.lpszService);
                return 1;
            }
        }
    }

    if(Params.wInstance!=0) 
    {
        if(!AdmNode.GetInstance().IsEmpty()) {
            error_printf(_T("instance entered more than once\n"));
            return 1;
        }
        else {
            _TCHAR buf[30];
            //!!! maybe ltoa should be used
            AdmNode.SetInstance(_itot(Params.wInstance,buf,10));
        }
    }

    //******************************************        
    //process attrib, utype, dtype, value

    //property name first
    CString strProp=AdmNode.GetProperty();
    if(Params.lpszPropName!=NULL && !strProp.IsEmpty())
    {
        error_printf(_T("property name entered more than once\n"));
        return 1;
    }
    else if (Params.lpszPropName!=NULL)
    {
        AdmNode.SetProperty(Params.lpszPropName);

    }
    if(IsNumber(AdmNode.GetProperty()))
    {
        AdmProp.SetIdentifier(_ttol(AdmNode.GetProperty()));
    }
    else
    {
        DWORD dwIdentifier=MapPropertyNameToCode(AdmNode.GetProperty());
        if(dwIdentifier==NAME_NOT_FOUND)
        {}
        else
            AdmProp.SetIdentifier(dwIdentifier) ;
    }
    
    //process the attrib entered on command line
    if(Params.wPropAttribCount!=0)
    {   DWORD dwAttrib=0;
        for (i=0;i<Params.wPropAttribCount;i++)
        {
            if(IsNumber(Params.lplpszPropAttrib[i]))
                dwAttrib += _ttol(Params.lplpszPropAttrib[i]);
            else
            {
                DWORD dwMapped=MapAttribNameToCode(Params.lplpszPropAttrib[i]);
                if(dwMapped==NAME_NOT_FOUND)
                {
                    error_printf(_T("attribute name not resolved: %s\n"), Params.lplpszPropAttrib[i]);
                    return 1;
                }
                else
                    dwAttrib |= dwMapped;
            }
        }
        //overwrite the default attrib
        AdmProp.SetAttrib(dwAttrib) ;
    }

    //process the usertype entered on command line
    if(Params.wPropUserTypeCount!=0)
    {   DWORD dwUserType=0;
        for (i=0;i<Params.wPropUserTypeCount;i++)
        {
            if(IsNumber(Params.lplpszPropUserType[i]))
                dwUserType += _ttol(Params.lplpszPropUserType[i]);
            else
            {
                DWORD dwMapped=MapUserTypeNameToCode(Params.lplpszPropUserType[i]);
                if(dwMapped==NAME_NOT_FOUND)
                {
                    error_printf(_T("user type not resolved: %s\n"), Params.lplpszPropUserType[i]);
                    return 1;
                }
                else
                    dwUserType |= dwMapped;
            }
        }
        //overwrite the default UserType
        AdmProp.SetUserType(dwUserType) ;
    }


    //process the datatype entered on command line
    if(Params.wPropDataTypeCount!=0)
    {   DWORD dwDataType=0;
        for (i=0;i<Params.wPropDataTypeCount;i++)
        {
            if(IsNumber(Params.lplpszPropDataType[i]))
                dwDataType += _ttol(Params.lplpszPropDataType[i]);
            else
            {
                DWORD dwMapped=MapDataTypeNameToCode(Params.lplpszPropDataType[i]);
                if(dwMapped==NAME_NOT_FOUND)
                {
                    error_printf(_T("DataType type not resolved: %s\n"), Params.lplpszPropDataType[i]);
                    return 1;

                }
                else
                    dwDataType |= dwMapped;
            }
        }
        //overwrite the default DataTypeType
        AdmProp.SetDataType(dwDataType) ;
    }
//LPCTSTR lplpszPropValue[MAX_NUMBER_OF_PROPERTY_VALUES]; //pointer to array of values (e.g multisz type allows the multiple values for one property
//WORD  wPropValueCount;

    
    //create admin object
    if(oAdmin.GetpcAdmCom()==NULL)
    {
        oAdmin.Open(AdmNode.GetComputer());
        if( FAILED(oAdmin.QueryLastHresError()))
        {
            retval= ConvertHresToDword(oAdmin.QueryLastHresError());
        }
    }
    
    
    if(oAdmin.GetpcAdmCom()!=NULL)
    {
        //
        // read from files if Params.wPropFileValueCount != 0
        //

        if ( Params.wPropFileValueCount )
        {
            if ( !ReadFromFiles( (LPTSTR*)Params.lplpszPropValue, Params.lpdwPropValueLength, Params.wPropFileValueCount ) )
            {
                error_printf(_T("Can't read value from file %s"), Params.lplpszPropValue[0] );
                return 1;
            }
            Params.wPropValueCount = Params.wPropFileValueCount;
        }

        oAdmin.Run(CString(Params.lpszCommand), 
            AdmNode, 
            AdmProp, 
            AdmDstNode,
            Params.lplpszPropValue,
            Params.lpdwPropValueLength,
            Params.wPropValueCount);
            retval=ConvertHresToDword(oAdmin.QueryLastHresError());
        
    }
    return ((retval==0)?0:1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\ansimeta.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       ansimeta.cpp

   Abstract:

        WRAPPER functions for ANSI calls of UNICODE ADMCOM interface

   Environment:

      Win32 User Mode

   Author:

      jaroslad  (jan 1997)

--*/


#include "ansimeta.h"

#include <mbstring.h>


WCHAR * ConvertToUnicode(unsigned char * pszString);


WCHAR * ConvertToUnicode(CHAR * pszString)
{
    return ConvertToUnicode((unsigned char *) pszString);
}

WCHAR * ConvertToUnicode(unsigned char * pszString)
{ 
    if (pszString==NULL)
        return NULL;
    int Size_wszString = (_mbslen((const unsigned char *) pszString)+1)*sizeof(WCHAR);
    WCHAR * pwszString = new WCHAR[Size_wszString];
    if (pwszString== NULL)
    {
        return NULL;
    }
    MultiByteToWideChar(0, 0, (char *) pszString, -1, pwszString, Size_wszString);
    return pwszString;
}


CHAR * ConvertToMultiByte(WCHAR * pwszString)
{
    if(pwszString==NULL)
        return NULL;
    int Size_szString = (wcslen(pwszString)*sizeof(WCHAR)+1);
    CHAR * pszString = new CHAR[Size_szString];
    if (pszString== NULL)
    {
        return NULL;
    }
    WideCharToMultiByte(0, 0, pwszString, -1, pszString,Size_szString, NULL,NULL );
    return pszString;
}


HRESULT ConvertMetadataToAnsi(PMETADATA_RECORD pmdrMDData)
{        
        HRESULT hRes=ERROR_SUCCESS;
     
        //convert data if STRING, EXPAND STRING or MULTISZ
        switch(pmdrMDData->dwMDDataType )
        {
        case STRING_METADATA:
            case EXPANDSZ_METADATA:
        {
            CHAR * pszData= ConvertToMultiByte((WCHAR *) pmdrMDData->pbMDData);
            if (pszData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
            strcpy((char *)pmdrMDData->pbMDData,pszData);
            pmdrMDData->dwMDDataLen=strlen((char *)pmdrMDData->pbMDData)+1;
            delete [] pszData;
            break;
        }
        case MULTISZ_METADATA:
        {
            WCHAR *pwszMultiString = (WCHAR *) pmdrMDData->pbMDData;
            DWORD dwAnsiDataLen=0;
            do
            {
                CHAR * pszData= ConvertToMultiByte(pwszMultiString);
                if (pszData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
                strcpy((char *)(pmdrMDData->pbMDData)+dwAnsiDataLen,pszData);
                dwAnsiDataLen+=strlen(pszData)+1;
                pwszMultiString+=_mbslen((const unsigned char *)pszData)+1; //move pointer to the next string in MULTISZ
                delete [] pszData;

            }while((void *) pwszMultiString < (void *) (pmdrMDData->pbMDData+pmdrMDData->dwMDDataLen));
        
            pmdrMDData->dwMDDataLen=dwAnsiDataLen;
            break;
        }
        }
Exit:
    return hRes;
}

HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::AddKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) 
{
    HRESULT hRes=0;
    WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);
    if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->AddKey(hMDHandle, pwszMDPath);
    
Exit:
    //release memory
    if( pwszMDPath!=0) delete [] pwszMDPath;
    return hRes;
}

        
HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::DeleteKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath) 
{
    HRESULT hRes=0;
    WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

    if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->DeleteKey(hMDHandle, pwszMDPath);
    
Exit:
    //release memory
    if( pwszMDPath!=0) delete [] pwszMDPath;
    return hRes;

}
        
        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::EnumKeys( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
            /* [in] */ DWORD dwMDEnumObjectIndex) 
{
    HRESULT hRes=0;
    CHAR * pszMDName1=0;

    WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);
    WCHAR pwszMDName[METADATA_MAX_NAME_LEN];


    if ((pwszMDPath==0) || (pwszMDName==0)) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->EnumKeys(hMDHandle, pwszMDPath,pwszMDName,dwMDEnumObjectIndex);

    //convert pszMDName to ANSI
    pszMDName1=ConvertToMultiByte(pwszMDName);
    strcpy((char *)pszMDName,pszMDName1); 
Exit:
    //release memory
    if( pwszMDPath!=0) delete [] pwszMDPath;
    if( pszMDName1!=0) delete [] pszMDName1;
    return hRes;
}


        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::CopyKey( 
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ BOOL bMDOverwriteFlag,
            /* [in] */ BOOL bMDCopyFlag) 

{
    HRESULT hRes=0;

    WCHAR * pwszMDSourcePath=ConvertToUnicode(pszMDSourcePath);
    WCHAR * pwszMDDestPath=ConvertToUnicode(pszMDDestPath);

    if ((pwszMDSourcePath==0) || (pwszMDDestPath==0) ){ hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->CopyKey(hMDSourceHandle, pwszMDSourcePath, 
                    hMDDestHandle, pwszMDDestPath, bMDOverwriteFlag, bMDCopyFlag);
Exit:
    //release memory
    if( pwszMDSourcePath!=0) delete [] pwszMDSourcePath;
    if( pwszMDDestPath!=0) delete [] pwszMDDestPath;
    return hRes;
}



        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::RenameKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName) 
{
    HRESULT hRes=0;

    WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);
    WCHAR * pwszMDNewName=ConvertToUnicode(pszMDNewName);

    if ((pwszMDPath==0) || (pwszMDNewName==0)) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->RenameKey(hMDHandle, pwszMDPath,pwszMDNewName);
Exit:
    //release memory
    if( pwszMDPath!=0) delete [] pwszMDPath;
    if( pwszMDNewName!=0) delete [] pwszMDNewName;
    return hRes;
}




        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::SetData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ PMETADATA_RECORD pmdrMDData) 
{
    HRESULT hRes=0;
    WCHAR *pwszMDData = NULL;
    WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

    if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    
     
    //convert data if STRING, EXPAND STRING or MULTISZ
    switch(pmdrMDData->dwMDDataType )
    {
    case STRING_METADATA:
    case EXPANDSZ_METADATA:
    {
        WCHAR * pwszData= ConvertToUnicode((CHAR *) pmdrMDData->pbMDData);
        if (pwszData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
        PBYTE  pbMDStoreData=pmdrMDData->pbMDData;
        DWORD dwMDStoreDataLen=pmdrMDData->dwMDDataLen;
        pmdrMDData->pbMDData= (PBYTE) pwszData;
        pmdrMDData->dwMDDataLen=(wcslen((WCHAR *)pmdrMDData->pbMDData)+1)*sizeof(WCHAR);

        hRes= this->m_pcAdmCom->SetData(hMDHandle, pwszMDPath,pmdrMDData);

        pmdrMDData->dwMDDataLen = dwMDStoreDataLen;
        pmdrMDData->pbMDData = pbMDStoreData;
        delete [] pwszData;
        break;
    }
    case MULTISZ_METADATA:
    {
        CHAR *pszMultiString = (CHAR *) pmdrMDData->pbMDData;
        pwszMDData=new WCHAR[(pmdrMDData->dwMDDataLen)];
        if (pwszMDData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
        DWORD dwUniDataLen=0;
        do
        {
            WCHAR * pwszData= ConvertToUnicode(pszMultiString);
            if (pwszData==0)  {hRes=E_OUTOFMEMORY; goto Exit;}
            wcscpy(pwszMDData+dwUniDataLen,pwszData);
            dwUniDataLen+=wcslen(pwszData)+1;
            delete [] pwszData;

            while(*(pszMultiString++)!=0); //move pointer to the next string in MULTISZ
        }while(*pszMultiString!=0);
        pwszMDData[dwUniDataLen++]=0;

        //store original values
        PBYTE pbMDStoreData=pmdrMDData->pbMDData;
        DWORD dwMDStoreDataLen=pmdrMDData->dwMDDataLen;
        
        pmdrMDData->dwMDDataLen=dwUniDataLen*sizeof(WCHAR);
        pmdrMDData->pbMDData= (PBYTE) pwszMDData;

        hRes= this->m_pcAdmCom->SetData(hMDHandle, pwszMDPath,pmdrMDData);

        delete [] pwszMDData;
        pwszMDData = NULL;

        //restore original values
        pmdrMDData->dwMDDataLen = dwMDStoreDataLen;
        pmdrMDData->pbMDData = pbMDStoreData;
        break;
    }
    default:
    {
        hRes= this->m_pcAdmCom->SetData(hMDHandle, pwszMDPath,pmdrMDData);
    }
    } //end of switch

Exit:
    //release memory
    if( pwszMDPath!=0) delete [] pwszMDPath;
    if( pwszMDData ) delete [] pwszMDData;
    return hRes;
}


        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::GetData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) 
{
    HRESULT hRes=0;
    WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

    if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->GetData(hMDHandle, pwszMDPath,pmdrMDData,pdwMDRequiredDataLen);
    if(SUCCEEDED(hRes))
    {
        ConvertMetadataToAnsi(pmdrMDData);
    }
    
Exit:
    //release memory
    if( pwszMDPath!=0) delete [] pwszMDPath;
    return hRes;
}


        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::DeleteData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType) 
{
    HRESULT hRes=0;
    WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

    if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->DeleteData(hMDHandle, pwszMDPath,dwMDIdentifier,dwMDDataType);
    
Exit:
    //release memory
    if( pwszMDPath!=0) delete [] pwszMDPath;
    return hRes;
}

        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::EnumData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [in] */ DWORD dwMDEnumDataIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) 
        
{
    HRESULT hRes=0;
    WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

    if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->EnumData(hMDHandle, pwszMDPath,pmdrMDData,dwMDEnumDataIndex,pdwMDRequiredDataLen);
    if(SUCCEEDED(hRes))
    {
        ConvertMetadataToAnsi(pmdrMDData);
    }
    
Exit:
    //release memory
    if( pwszMDPath!=0) delete [] pwszMDPath;
    return hRes;
}        
        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::CopyData( 
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ BOOL bMDCopyFlag) 
{
    HRESULT hRes=0;

    WCHAR * pwszMDSourcePath=ConvertToUnicode(pszMDSourcePath);
    WCHAR * pwszMDDestPath=ConvertToUnicode(pszMDDestPath);


    if ((pwszMDSourcePath==0) || (pwszMDDestPath==0) ) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->CopyData(hMDSourceHandle, pwszMDSourcePath, 
                    hMDDestHandle, pwszMDDestPath, dwMDAttributes,
                    dwMDUserType,dwMDDataType,bMDCopyFlag);
Exit:
    //release memory
    if( pwszMDSourcePath!=0) delete [] pwszMDSourcePath;
    if( pwszMDDestPath!=0) delete [] pwszMDDestPath;

    return hRes;
}
        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::OpenKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
            /* [in] */ DWORD dwMDAccessRequested,
            /* [in] */ DWORD dwMDTimeOut,
            /* [out] */ PMETADATA_HANDLE phMDNewHandle) 
{
    HRESULT hRes=0;
    WCHAR * pwszMDPath=ConvertToUnicode(pszMDPath);

    if (pwszMDPath==0) { hRes=E_OUTOFMEMORY; goto Exit;}

    //call real interface function
    if(this->m_pcAdmCom==0) {hRes=CO_E_NOTINITIALIZED;goto Exit;}
    hRes= this->m_pcAdmCom->OpenKey(hMDHandle, pwszMDPath, dwMDAccessRequested, dwMDTimeOut, phMDNewHandle);
    
Exit:
    //release memory
    if( pwszMDPath!=0) delete [] pwszMDPath;
    return hRes;
}
        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::CloseKey( 
            /* [in] */ METADATA_HANDLE hMDHandle) 
{
    if(this->m_pcAdmCom==0) { return CO_E_NOTINITIALIZED;}
    return this->m_pcAdmCom->CloseKey(hMDHandle);
    
}        
        
 HRESULT STDMETHODCALLTYPE ANSI_smallIMSAdminBase::SaveData( void) 
{
    if(this->m_pcAdmCom==0) {return CO_E_NOTINITIALIZED;}
    return this->m_pcAdmCom->SaveData();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\jd_misc.h ===
#if !defined (JD_MISC_H)
#define JD_MISC_H 

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    jd_misc.h

Abstract:
	header file for jd_misc.cpp


Author:

    jaroslad  

Revision History:
    06-01-96      ( Jaroslad ) Original.

--*/

#include <windows.h>

int random(int low, int high);


enum Tptr_type {TYPE_TCHAR,TYPE_INT,TYPE_LONG, TYPE_WORD,TYPE_DWORD,TYPE_LPCTSTR};
enum Topt_mand {OPT,MAND}; // switches can be optional or mandatory


struct SParamDef
{
	_TCHAR *sw;     // letter for switch
	int  param_number; //number of parameters (0-zero,1 means exactly one,
					   // >1 means not more param than
	void * ptr;  // pointer to assign value of switch (depends on sw_type)
    
	enum Tptr_type  ptr_type;
	enum Topt_mand  opt_mand;

	_TCHAR * text_desc;  //description for usage print
	_TCHAR * text_param; //what param the switch requires 
					   //(if in usage is '...-c [file]' text_param is "file" )
	WORD * param_read; //same as curr_param_read, but used to export value to caller
	WORD  curr_param_read; // current nuber of params already assigned to ptr;
						// applies only with param_number >1
};
typedef struct SParamDef TParamDef;


void DisplayUsageAndExit( _TCHAR **argv, TParamDef *tt);
void DisplayUsage( _TCHAR **argv, TParamDef *tt);

void ParseParam(int argc, _TCHAR ** argv, TParamDef * tt);

int time_printf(_TCHAR *format, ...);

void fatal_error_printf(_TCHAR *format, ...);
void error_printf(_TCHAR *format, ...);




#define YES			TRUE
#define NO			FALSE

#define SUCCESS     TRUE
#define FAILURE     FALSE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\vptool.cpp ===
/*===================================================================
Microsoft ASP

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Package Management Tool

File: main.cpp

Owner: leijin

Note:
===================================================================*/


#include <tchar.h>

#include "admutil.h"
#include <stdio.h>
#include <objbase.h>
#include <initguid.h>

//#ifdef _WAMREG_LINK_DIRECT
//#include "..\wmrgexp.h"
//#endif

#include <iwamreg.h>

#define SIZE_STRING_BUFFER  1024


void CAdmUtil::OpenWamAdm (const CString & strComputer)
{
    IClassFactory * pcsfFactory = NULL;
    COSERVERINFO csiMachineName;
    COSERVERINFO *pcsiParam = NULL;
    OLECHAR rgchMachineName[MAX_PATH];

    //release previous interface if needed
    if(pIWamAdm!=0 && pIWamAdm2!=0)
    {
	//reuse the interface
	return;
        //pIWamAdm->Release();
        //pIWamAdm=0;
    }
    //convert to OLECHAR[];
    #if UNICODE
        wsprintfW( rgchMachineName, L"%s", LPCTSTR(strComputer));
    #else
            wsprintfW( rgchMachineName, L"%S", LPCTSTR(strComputer));
    #endif
            
    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;
    pcsiParam = &csiMachineName;
    csiMachineName.pwszName =  (strComputer.IsEmpty())?NULL:rgchMachineName;

    hresError = CoGetClassObject(CLSID_WamAdmin, CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);

    if (FAILED(hresError))
    {
     Error(_T("Failed to CoGetClassObject of WamAdm object"));
    }
    else {
        hresError = pcsfFactory->CreateInstance(NULL, IID_IWamAdmin, (void **) &pIWamAdm);
        if (FAILED(hresError)) Error(_T("Failed to CreateInstance of WamAdm object"));
        hresError = pcsfFactory->CreateInstance(NULL, IID_IWamAdmin2, (void **) &pIWamAdm2);
        if (FAILED(hresError)) Error(_T("Failed to CreateInstance of WamAdm2 object"));

        pcsfFactory->Release();
    }
}

void CAdmUtil::CloseWamAdm (void)
{
	if(pIWamAdm!=0)
    {
        pIWamAdm->Release();
	pIWamAdm2->Release();
        pIWamAdm=0;        pIWamAdm2=0;
    }
}

void CAdmUtil::AppCreateInProc(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT     hr = NOERROR;
    //  
    INT         cSize = 0;
    INT         cch = 0;
#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    
    OpenWamAdm(strComputer);

    if (pIWamAdm!=0)
    {
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm2->AppCreate2(wszMetabasePath, eAppRunInProc);
        if (FAILED(hresError))
            {
            Error(_T("create failed"));
            }
        else
            {
            Print(_T("inproc application created\n"));
            }
    }

    //CloseWamAdm();

    return;
}


void CAdmUtil::AppCreateOutPool(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];
    HRESULT     hr = NOERROR;
    //  
    INT         cSize = 0;
    INT         cch = 0;
#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    
    OpenWamAdm(strComputer);

    if (pIWamAdm!=0)
    {
	CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm2->AppCreate2(wszMetabasePath, eAppRunOutProcInDefaultPool);
        if (FAILED(hresError))
            {
            Error(_T("pooled create failed"));
            }
        else
            {
            Print(_T("pooled application created\n"));
            }
    }

    //CloseWamAdm();

    return;
}


void CAdmUtil::AppCreateOutProc(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];
    
    
    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    OpenWamAdm(strComputer);
    if (pIWamAdm!=0)
    {
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm->AppCreate(wszMetabasePath, FALSE);
        if (FAILED(hresError))
        {
            Error(_T("create failed"));
        }
        else
        {
            Print(_T("application created\n"));
        }
    }
    //CloseWamAdm();
    return;
}

void CAdmUtil::AppDelete(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];


    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    OpenWamAdm(strComputer);
    if (pIWamAdm!=0)
        {
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm->AppDelete(wszMetabasePath,FALSE);
        if (FAILED(hresError))
            {
            Error(_T("delete failed"));
            }   
        else
            {
            Print(_T("application deleted\n"));
            }
        }
    //CloseWamAdm();
    return;
}

void CAdmUtil::AppRename(CAdmNode& a_AdmNode, CAdmNode& a_AdmDstNode, const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];

    WCHAR       wszMetabaseDstPath[SIZE_STRING_BUFFER];

    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, LPCTSTR(a_AdmNode.GetLMNodePath()), -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }

    wcscat(wszMetabaseDstPath,L"/");
    cSize = MultiByteToWideChar(0, 0, LPCTSTR(a_AdmDstNode.GetLMNodePath()), -1, wszMetabaseDstPath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
    wcscat(wszMetabaseDstPath,L"/");

#else
    wcscpy(wszMetabasePath,LPCTSTR(a_AdmNode.GetLMNodePath()));
    wcscpy(wszMetabaseDstPath,LPCTSTR(a_AdmDstNode.GetLMNodePath()));
#endif


    OpenWamAdm(strComputer);
    if (pIWamAdm!=0)
        {
	    CloseObject_hmd(); //close reusable handle; it may conflict with WAM
            hresError = pIWamAdm->AppDeleteRecoverable(wszMetabasePath,TRUE /*Recursive*/);
            if (FAILED(hresError))
            {
                Error(_T("AppDeleteRecoverable() failed"));
            }   
            else
            {
                RenameObject(a_AdmNode,a_AdmDstNode);
                if(FAILED(QueryLastHresError()))
                {
                   Error(_T("node failed to be renamed"));
                }
                else
                {  
	          CloseObject_hmd(); //close reusable handle; it may conflict with WAM
                  hresError = pIWamAdm->AppRecover(wszMetabaseDstPath,TRUE /*Recursive*/);
 	          if (FAILED(hresError))
                  {
                     Error(_T("AppRecover() failed"));
                  }
		  else
                  {
                     Print(_T("application renamed\n"));
                  }
                }
             }
        }
    //CloseWamAdm();
    return;
}


void CAdmUtil::AppUnLoad(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];


    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    OpenWamAdm(strComputer);
    if (pIWamAdm!=0)
        {
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm->AppUnLoad(wszMetabasePath,FALSE);
        if (FAILED(hresError))
            {
            Error(_T("Unload application failed"));
            }
        else
            {
            Print(_T("application unloaded\n"));
            }

        }
    //CloseWamAdm();
    return;
}

void CAdmUtil::AppGetStatus(const _TCHAR* szPath,const CString & strComputer)
{
    WCHAR       wszMetabasePath[SIZE_STRING_BUFFER];
    

    INT         cSize = 0;
    INT         cch = 0;

#ifndef UNICODE
    cSize = MultiByteToWideChar(0, 0, szPath, -1, wszMetabasePath, SIZE_STRING_BUFFER);
    if (cSize == 0)
    {
        hresError =  GetLastError();
        if (hresError == ERROR_INSUFFICIENT_BUFFER)
        {
            Error(_T("The Metabase path exceeds 1024 chars"));
        }
        else
            Error("");
        return;
    }
#else
    wcscpy(wszMetabasePath,szPath);
#endif
    OpenWamAdm(strComputer);
    if (pIWamAdm!=0)
        {
        DWORD dwStatus;
		CloseObject_hmd(); //close reusable handle; it may conflict with WAM
        hresError = pIWamAdm->AppGetStatus(wszMetabasePath, &dwStatus);
        if (FAILED(hresError))
            {
            Error(_T("GetStatus of application  %s failed"));
            }
        else
            {
            if (dwStatus == APPSTATUS_NOTDEFINED)
                {
                Print(_T("Application is not defined\n"));
                }
            else if (dwStatus == APPSTATUS_STOPPED)
                {
                Print(_T("Application is stopped\n"));
                }
            else if (dwStatus == APPSTATUS_RUNNING)
                {
                Print(_T("Application is running\n"));
                }
            else
                {
                Print(_T("Application is in unknown state\n"));
                }
            }                   
        }
    //CloseWamAdm();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\unitest\main.cxx ===
#define UNICODE
#include <windows.h>
#define INITGUID
#include <ole2.h>
#include <stdio.h>
#include <sink.hxx>
#include <iadmw.h>

#define MD_TEST_MAX_STRING_LEN   2048
#define MD_TEST_MAX_BINARY_LEN   2048

#define FILL_RETURN_BUFF   for(ReturnIndex=0;ReturnIndex<sizeof(ReturnBuf);ReturnIndex++)ReturnBuf[ReturnIndex]=0xff;
#define SET_RETURN_DATA    {ReturnDataLen=sizeof(ReturnBuf);ReturnUserType=0;ReturnDataType=0;ReturnAttributes=(METADATA_INHERIT | METADATA_PARTIAL_PATH);FILL_RETURN_BUFF}
#define MD_SET_DATA_RECORD(PMDR, ID, ATTR, UTYPE, DTYPE, DLEN, PD) \
            { \
            (PMDR)->dwMDIdentifier=ID; \
            (PMDR)->dwMDAttributes=ATTR; \
            (PMDR)->dwMDUserType=UTYPE; \
            (PMDR)->dwMDDataType=DTYPE; \
            (PMDR)->dwMDDataLen=DLEN; \
            (PMDR)->pbMDData=PD; \
            }

#define TIMEOUT_VALUE      1000
#define INITIAL_TIMEOUT_VALUE 15000

#define DWORD_DATA_NAME    1
#define BINARY_DATA_NAME   2
#define STRING_DATA_NAME   3
#define BAD_BINARY_DATA_NAME 4

#define DWORD_DATA_NAME_INHERIT 5

#define DWORD_DATA_NAME_NO_INHERIT 6

#define REFERENCE_DATA_NAME  7

#define EXPANDSZ_DATA_NAME   8

#define MULTISZ_DATA_NAME   9

#define VOLATILE_DATA_NAME 10

#define INSERT_PATH_DATA_NAME  11

#define UNUSED_DATA_NAME     0xfe98f123

#define MAX_DATA_ENTRIES   5
#define MY_GREATEROF(p1,p2) ((p1) > (p2))?(p1):(p2)
#define MAX_BUFFER_LEN     MY_GREATEROF((MD_TEST_MAX_STRING_LEN * sizeof(WCHAR)), MD_TEST_MAX_BINARY_LEN)
#define BUFFER_SIZE        5000

#define HUNDREDNANOSECONDSPERSECOND (DWORDLONG)10000000
#define HUNDREDNANOSECONDSPERMINUTE (HUNDREDNANOSECONDSPERSECOND * (DWORDLONG)60)
#define HUNDREDNANOSECONDSPERHOUR (HUNDREDNANOSECONDSPERMINUTE * (DWORDLONG)60)
#define HUNDREDNANOSECONDSPERDAY (HUNDREDNANOSECONDSPERHOUR * (DWORDLONG)24)
#define HUNDREDNANOSECONDSPERYEAR ((HUNDREDNANOSECONDSPERDAY * (DWORDLONG)365) + (HUNDREDNANOSECONDSPERDAY / (DWORDLONG)4))

#define INSERT_PATH_DATA L##"The path be inserted here: " MD_INSERT_PATH_STRINGW L##":Before here"

#define SET_GETALL_PARMS(p1) dwBufferSize = BUFFER_SIZE;dwNumDataEntries = MAX_DATA_ENTRIES;dwDataSetNumber=0;for (i=0;i<p1;i++){structDataEntries[i].pbMDData=binDataEntries[i];}

#define RELEASE_INTERFACE(p)\
{\
  IUnknown* pTmp = (IUnknown*)p;\
  p = NULL;\
  if (NULL != pTmp)\
    pTmp->Release();\
}

#define CHECK_SHUTDOWN \
{ \
    if (g_bShutdown) { \
        goto SHUTDOWN; \
    } \
}

typedef struct _SinkParams {
//    LPSTREAM  pStream;
    IMSAdminBaseW * pcCom;
//    IConnectionPoint* pConnPoint;
    DWORD dwCookie;
    BOOL bSinkConnected;
} SINKPARAMS, *PSINKPARAMS;


BOOL g_bShutdown;

VOID
PrintTime(PFILETIME pftTime)
{
    DWORDLONG dwlTime = *(PDWORDLONG)pftTime;
    printf("Year = %d\n", ((DWORD)(dwlTime / (DWORDLONG)HUNDREDNANOSECONDSPERYEAR)) + 1601);
    printf("Day = %d\n", (DWORD)((dwlTime % (DWORDLONG)HUNDREDNANOSECONDSPERYEAR) / (DWORDLONG)HUNDREDNANOSECONDSPERDAY));
    printf("Time = %d minutes\n", (DWORD)((dwlTime % (DWORDLONG)HUNDREDNANOSECONDSPERDAY) / (DWORDLONG)HUNDREDNANOSECONDSPERMINUTE));

    ULARGE_INTEGER uliTime = *(PULARGE_INTEGER)pftTime;
    printf("Time High Word = %X, Low Word = %X\n", uliTime.HighPart, uliTime.LowPart);

}

LPSTR
ConvertDataTypeToString(DWORD dwDataType)
{
    LPSTR strReturn;
    switch (dwDataType) {
    case DWORD_METADATA:
        strReturn = "DWORD";
        break;
    case STRING_METADATA:
        strReturn = "STRING";
        break;
    case BINARY_METADATA:
        strReturn = "BINARY";
        break;
    case EXPANDSZ_METADATA:
        strReturn = "EXPANDSZ";
        break;
    case MULTISZ_METADATA:
        strReturn = "MULTISZ";
        break;
    case ALL_METADATA:
        strReturn = "ALL";
        break;
    default:
        strReturn = "Invalid Data Type";
    }
    return (strReturn);
}

VOID
PrintDataBuffer(PMETADATA_RECORD pmdrData, BOOL bPrintData, LPSTR strInitialString)
{
    DWORD i;
    if (strInitialString != NULL) {
        printf("%s\n", strInitialString);
    }
    printf("Identifier = %x, Attributes = %x, UserType = %x, DataType = %s, DataLen = %x, DataTag = %x",
        pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes, pmdrData->dwMDUserType,
        ConvertDataTypeToString(pmdrData->dwMDDataType), pmdrData->dwMDDataLen, pmdrData->dwMDDataTag);
    if (bPrintData) {
        printf(", Data = ");
        if (pmdrData->pbMDData != NULL) {
            switch (pmdrData->dwMDDataType) {
            case DWORD_METADATA:
                printf("%x", *(DWORD *)(pmdrData->pbMDData));
                break;
            case STRING_METADATA:
            case EXPANDSZ_METADATA:
                printf("%S", (LPTSTR)(pmdrData->pbMDData));
                break;
            case BINARY_METADATA:
                for (i = 0; i < pmdrData->dwMDDataLen; i++) {
                    printf("%.2x ", ((PBYTE)(pmdrData->pbMDData))[i]);
                }
                break;
            case MULTISZ_METADATA:
                printf("\n\t");
                LPTSTR pszData = (LPTSTR) pmdrData->pbMDData;
                for (i = 0; i < (pmdrData->dwMDDataLen / sizeof(TCHAR)); i++) {
                    if (pszData[i] != '\0') {
                        printf("%C", pszData[i]);
                    }
                    else {
                        printf("\n\t");
                    }
                }
                break;
            }
        }
        else {
            printf("NULL");
        }
    }
    printf("\n");
}

VOID
PrintGetAllDataBuffer(PBYTE pbBase, PMETADATA_GETALL_RECORD pmdgarData, BOOL bPrintData, LPSTR strInitialString)
{
    DWORD i;
    if (strInitialString != NULL) {
        printf("%s\n", strInitialString);
    }
    printf("Identifier = %x, Attributes = %x, UserType = %x, DataType = %s, DataLen = %x, DataTag = %x",
        pmdgarData->dwMDIdentifier, pmdgarData->dwMDAttributes, pmdgarData->dwMDUserType,
        ConvertDataTypeToString(pmdgarData->dwMDDataType), pmdgarData->dwMDDataLen, pmdgarData->dwMDDataTag);
    if (bPrintData) {
        PBYTE pbData;
        if (pmdgarData->dwMDDataTag != 0) {
            printf(", Reference Data Address = 0x%x", (DWORD)pmdgarData->pbMDData);
        }
        else {
            printf(", Data = ");
            pbData = pbBase + (pmdgarData->dwMDDataOffset);
            switch (pmdgarData->dwMDDataType) {
            case DWORD_METADATA:
                printf("%x", *(DWORD *)pbData);
                break;
            case STRING_METADATA:
            case EXPANDSZ_METADATA:
                printf("%S", (LPTSTR)pbData);
                break;
            case BINARY_METADATA:
                for (i = 0; i < pmdgarData->dwMDDataLen; i++) {
                    printf("%.2x ", ((PBYTE)pbData)[i]);
                }
                break;
            case MULTISZ_METADATA:
                printf("\n\t");
                LPTSTR pszData = (LPTSTR) pbData;
                for (i = 0; i < (pmdgarData->dwMDDataLen / sizeof(TCHAR)); i++) {
                    if (pszData[i] != '\0') {
                        printf("%C", pszData[i]);
                    }
                    else {
                        printf("\n\t");
                    }
                }
                break;
            }
        }
    }
    printf("\n");
}

LPSTR ConvertReturnCodeToString(DWORD ReturnCode)
{
    LPSTR RetCode = NULL;
    switch (ReturnCode) {
    case ERROR_SUCCESS:
        RetCode = "ERROR_SUCCESS";
        break;
    case ERROR_PATH_NOT_FOUND:
        RetCode = "ERROR_PATH_NOT_FOUND";
        break;
    case ERROR_INVALID_HANDLE:
        RetCode = "ERROR_INVALID_HANDLE";
        break;
    case ERROR_INVALID_DATA:
        RetCode = "ERROR_INVALID_DATA";
        break;
    case ERROR_INVALID_PARAMETER:
        RetCode = "ERROR_INVALID_PARAMETER";
        break;
    case ERROR_NOT_SUPPORTED:
        RetCode = "ERROR_NOT_SUPPORTED";
        break;
    case ERROR_ACCESS_DENIED:
        RetCode = "ERROR_ACCESS_DENIED";
        break;
    case ERROR_NOT_ENOUGH_MEMORY:
        RetCode = "ERROR_NOT_ENOUGH_MEMORY";
        break;
    case ERROR_FILE_NOT_FOUND:
        RetCode = "ERROR_FILE_NOT_FOUND";
        break;
    case ERROR_DUP_NAME:
        RetCode = "ERROR_DUP_NAME";
        break;
    case ERROR_PATH_BUSY:
        RetCode = "ERROR_PATH_BUSY";
        break;
    case ERROR_NO_MORE_ITEMS:
        RetCode = "ERROR_NO_MORE_ITEMS";
        break;
    case ERROR_INSUFFICIENT_BUFFER:
        RetCode = "ERROR_INSUFFICIENT_BUFFER";
        break;
    case ERROR_PROC_NOT_FOUND:
        RetCode = "ERROR_PROC_NOT_FOUND";
        break;
    case ERROR_INTERNAL_ERROR:
        RetCode = "ERROR_INTERNAL_ERROR";
        break;
    case MD_ERROR_NOT_INITIALIZED:
        RetCode = "MD_ERROR_NOT_INITIALIZED";
        break;
    case MD_ERROR_DATA_NOT_FOUND:
        RetCode = "MD_ERROR_DATA_NOT_FOUND";
        break;
    case MD_ERROR_INVALID_VERSION:
        RetCode = "MD_ERROR_INVALID_VERSION";
        break;
    case MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE:
        RetCode = "MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE";
        break;
    case ERROR_ALREADY_EXISTS:
        RetCode = "ERROR_ALREADY_EXISTS";
        break;
    case MD_WARNING_PATH_NOT_FOUND:
        RetCode = "MD_WARNING_PATH_NOT_FOUND";
        break;
    case MD_WARNING_DUP_NAME:
        RetCode = "MD_WARNING_DUP_NAME";
        break;
    case MD_WARNING_INVALID_DATA:
        RetCode = "MD_WARNING_INVALID_DATA";
        break;
    case MD_WARNING_SAVE_FAILED:
        RetCode = "MD_WARNING_SAVE_FAILED";
        break;
    case MD_WARNING_PATH_NOT_INSERTED:
        RetCode = "MD_WARNING_PATH_NOT_INSERTED";
        break;
    case ERROR_INVALID_NAME:
        RetCode = "ERROR_INVALID_NAME";
        break;
    case REGDB_E_CLASSNOTREG:
        RetCode = "REGDB_E_CLASSNOTREG";
        break;
    case ERROR_NO_SYSTEM_RESOURCES:
        RetCode = "ERROR_NO_SYSTEM_RESOURCES";
        break;
    case RPC_E_WRONG_THREAD:
        RetCode = "RPC_E_WRONG_THREAD";
        break;
    default:
        RetCode = "Unrecognized Error Code";
        break;
    }
    return (RetCode);
}

DWORD ConvertHresToDword(HRESULT hRes)
{
    return HRESULTTOWIN32(hRes);
}

LPSTR ConvertHresToString(HRESULT hRes)
{
    LPSTR strReturn = NULL;

    if ((HRESULT_FACILITY(hRes) == FACILITY_WIN32) ||
        (HRESULT_FACILITY(hRes) == FACILITY_INTERNET) ||
        (hRes == 0)) {
        strReturn = ConvertReturnCodeToString(ConvertHresToDword(hRes));
    }
    else {
        switch (hRes) {
        case RPC_E_WRONG_THREAD:
            strReturn = "RPC_E_WRONG_THREAD";
            break;
        default:
            strReturn = "Unrecognized Error Code";
            break;
        }
    }
    return(strReturn);
}

DWORD
SetMultisz(LPWSTR pszBuffer, LPWSTR ppszStrings[], DWORD dwNumStrings)
{
    DWORD i;
    LPWSTR pszIndex = pszBuffer;

    for (i = 0; i < dwNumStrings; i++) {
        wcscpy(pszIndex, ppszStrings[i]);
        pszIndex += wcslen(pszIndex) + 1;
    }

    *pszIndex = (WCHAR)'\0';

    return (((pszIndex - pszBuffer) + 1) * sizeof(WCHAR));

}

VOID
RunThread(
    IN LPTHREAD_START_ROUTINE pStartAddress,
    IN PVOID pvParamBlock
    )
{
    HANDLE hThread = NULL;
    DWORD dwThreadID;

    hThread = CreateThread(NULL,
                       0,
                       pStartAddress,
                       pvParamBlock,
                       0,
                       &dwThreadID);

    if (hThread != NULL) {
        WaitForSingleObject(hThread,30000);
    }
    else {
        printf("Create Thread failed, error = %x\n", GetLastError());
    }
    return ;
}

/*
        bReturn = StartThread(ComHackThread, &g_hComHackThread);

        err = WaitForSingleObject(g_hComHackThread,10000);
*/


DWORD
ReleaseSinkThread(
    PVOID pvParamBlock
    )
{
    PSINKPARAMS pspParamBlock = (PSINKPARAMS) pvParamBlock;
    IConnectionPoint* pConnPoint = NULL;
    IConnectionPointContainer* pConnPointContainer = NULL;
    HRESULT hRes;
    IMSAdminBaseW * pcCom = NULL;

    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
//    hRes = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    if (FAILED(hRes)) {
        printf("CoInitializeEx Failed, hRes = %x\n", hRes);
    }
    else {

/*
        hRes = CoGetInterfaceAndReleaseStream(pspParamBlock->pStream,
                                             IID_IConnectionPoint,
                                             (PVOID *)&pConnPoint);

        if (SUCCEEDED(hRes)) {
*/

            if (pspParamBlock->bSinkConnected) {

                // First query the object for its Connection Point Container. This
                // essentially asks the object in the server if it is connectable.
                hRes = pspParamBlock->pcCom->QueryInterface(
                       IID_IConnectionPointContainer,
                       (PVOID *)&pConnPointContainer);
                if SUCCEEDED(hRes)
                {
                  // Find the requested Connection Point. This AddRef's the
                  // returned pointer.
                  hRes = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink_W, &pConnPoint);
                  if (SUCCEEDED(hRes)) {

                      hRes = pConnPoint->Unadvise(pspParamBlock->dwCookie);
//                      hRes = pspParamBlock->pConnPoint->Unadvise(pspParamBlock->dwCookie);
                      printf("pConnPoint->Unadvise((IUnknown *)pEventSink, &dwCookie); Returns %s\n", ConvertHresToString(hRes));
                      pConnPoint->Release();

                  }
                  else {
                      printf("pConnPointContainer->FindConnectionPoint(...); Returns %s\n", ConvertHresToString(hRes));
                  }

                  RELEASE_INTERFACE(pConnPointContainer);
                }
                else {
                    printf("pcCom->QueryInterface(...); Returns %s\n", ConvertHresToString(hRes));
                }

            }
/*
        }

        else {
            printf("CoGetInterfaceAndRelaseStream(...); Returns %s\n", ConvertHresToString(hRes));
        }
*/
        CoUninitialize();
    }
    return hRes;
}


DWORD __cdecl
main( INT    cArgs,
      char * pArgs[] )
{
    DWORD RetCode;
    DWORD TestDword = 3;
    int TestBinary[] = {1,2,3,4};
    int i, ReturnIndex;
    DWORD ReturnDword = 0;
    DWORD ReturnAttributes = 0;
    DWORD ReturnDataType = 0;
    DWORD ReturnUserType = 0;
    METADATA_RECORD mdrData;
    UCHAR ReturnBuf[MAX_BUFFER_LEN];
    DWORD ReturnDataLen = sizeof(ReturnBuf);
    DWORD dwRequiredDataLen = 0;
    DWORD dwRequiredBufferLen = 0;
    TCHAR NameBuf[METADATA_MAX_NAME_LEN];
    METADATA_HANDLE OpenHandle, RootHandle;
    DWORD ReturnDataIdentifier;
    METADATA_RECORD structDataEntries[MAX_DATA_ENTRIES];
    BYTE binDataEntries[MAX_DATA_ENTRIES][MAX_BUFFER_LEN];
    DWORD dwNumDataEntries;
    BYTE pbBuffer[BUFFER_SIZE];
    DWORD dwBufferSize = BUFFER_SIZE;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam;
    OLECHAR rgchName[256];
    DWORD dwSystemChangeNumber;
    DWORD dwDataSetNumber;
    METADATA_HANDLE_INFO mhiInfo;
    FILETIME ftTime;
    LPWSTR ppszData[10];
    DWORD dwMultiszLen;

    IClassFactory * pcsfFactory = NULL;
    IClassFactory * pcsfFactory2 = NULL;
    IMSAdminBaseW * pcCom = NULL;
    HRESULT hRes;
    CImpIADMCOMSINKW *pEventSink = new CImpIADMCOMSINKW();
    IConnectionPoint* pConnPoint = NULL;
    IConnectionPointContainer* pConnPointContainer = NULL;
    DWORD dwCookie;
    BOOL bSinkConnected = FALSE;

    g_bShutdown = FALSE;

    if (cArgs > 1) {
        for (i = 0; pArgs[1][i] != '\0'; i++) {
            rgchName[i] = (OLECHAR) pArgs[1][i];
        }
        csiName.pwszName =  rgchName;
        csiName.pAuthInfo = NULL;
        pcsiParam = &csiName;
    }
    else {
        pcsiParam = NULL;
    }

    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
//    hRes = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

    if (FAILED(hRes)) {
        printf("CoInitializeEx Failed\n");
    }

    hRes = CoInitializeSecurity(NULL,
                                -1,
                                NULL,
                                NULL,
                                RPC_C_AUTHN_LEVEL_NONE,
                                0,
                                NULL,
                                EOAC_NONE,
                                0);

/*
    hRes = CoCreateInstance(GETAdminBaseCLSIDW(TRUE), NULL, CLSCTX_SERVER, IID_IMSAdminBase_W, (void**) &pcCom);
    if (FAILED(hRes)) {
        printf("CoCreateInstance Attaching to service failed, hRes = %X\n", hRes);
        hRes = CoCreateInstance(GETAdminBaseCLSIDW(FALSE), NULL, CLSCTX_SERVER, IID_IMSAdminBase_W, (void**) &pcCom);
    }
    if (FAILED(hRes)) {
        printf("CoCreateInstance attaching to exe failed, hRes = %X\n", hRes);
    }
    else {{
*/


    hRes = CoGetClassObject(CLSID_MSAdminBase_W, CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);
    printf("CoGetClassObject(GETMDCLSID(TRUE), ...; Returns hRes = %x, %s\n",
        hRes, ConvertHresToString(hRes));
    if (FAILED(hRes)) {
        hRes = CoGetClassObject(GETAdminBaseCLSID(FALSE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);
        printf("CoGetClassObject(GETMDCLSID(FALSE), ...; Returns hRes = %x, %s\n",
            hRes, ConvertHresToString(hRes));
    }

    if (FAILED(hRes)) {
    }
    else {
        hRes = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **) &pcCom);
        printf("Factory->CreateInstance(...); Returns hRes = %X, %s\n",
            hRes, ConvertHresToString(hRes));

        pcsfFactory->Release();
        printf("Factory->Release() called\n");

        if (FAILED(hRes)) {
            printf("Factory->CreateInstance failed, hRes = %X\n", hRes);
        }
        else {


/*
        hRes = pcCom->Initialize();

        hRes = pcCom->AddKey(METADATA_MASTER_ROOT_HANDLE, sizeof("Garbage"), (unsigned char *)"Garbage");

        hRes = pcCom->Terminate(FALSE);

        hRes = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE, sizeof(""), (PBYTE)"", METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle);
        printf("MDOpenKey(METADATA_MASTER_ROOT_HANDLE, NULL, METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle); Returns %s\n",
            ConvertHresToString(hRes));
*/


        // First query the object for its Connection Point Container. This
        // essentially asks the object in the server if it is connectable.
        hRes = pcCom->QueryInterface(
               IID_IConnectionPointContainer,
               (PVOID *)&pConnPointContainer);
        if SUCCEEDED(hRes)
        {
          // Find the requested Connection Point. This AddRef's the
          // returned pointer.
          hRes = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink_W, &pConnPoint);
          if (SUCCEEDED(hRes)) {
              hRes = pConnPoint->Advise((IMSAdminBaseW *)pEventSink, &dwCookie);
              if (SUCCEEDED(hRes)) {
                  bSinkConnected = TRUE;
              }
              printf("pConnPoint->Advise((IUnknown *)pEventSink, &dwCookie); Returns %s\n", ConvertHresToString(hRes));
//              pConnPoint->Release();
          }

          RELEASE_INTERFACE(pConnPointContainer);
        }
        // Give pcCom to Sink for write test
        pEventSink->SetMDPointer(pcCom);

/*
        hRes = pcCom->Initialize();
        printf("MDInitialize(); Returns %s\n", ConvertHresToString(hRes));

        if (SUCCEEDED(hRes))  {

            hRes = pcCom->Initialize();
            printf("MDInitialize(); Returns %s\n", ConvertHresToString(hRes));

            if (SUCCEEDED(hRes))  {
                hRes = pcCom->Terminate(FALSE);
                printf("\nMDTerminate(FALSE); Returns %s\n",
                    ConvertHresToString(hRes));
            }
*/
        hRes = pcCom->GetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, TEXT("Root Object"), &ftTime, FALSE);
        printf("MDGetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
            ConvertHresToString(hRes));
        if (SUCCEEDED(hRes)) {
            PrintTime(&ftTime);
        }

        hRes = pcCom->GetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, NULL, &ftTime, FALSE);
        printf("MDGetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, NULL, &ftTime); Returns %s\n",
            ConvertHresToString(hRes));
        if (SUCCEEDED(hRes)) {
            PrintTime(&ftTime);
        }

        hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
        printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
            ConvertHresToString(hRes));
        if (!FAILED(hRes)) {
            printf("System Change Number = %d\n", dwSystemChangeNumber);
        }

        CHECK_SHUTDOWN

        hRes = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE, NULL, METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, INITIAL_TIMEOUT_VALUE, &RootHandle);
        printf("MDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, \"\", METADATA_PERMISSION_WRITE || METADATA_PERMISSION_READ, TIMEOUT_VALUE, &RootHandle); Returns %s\n",
            ConvertHresToString(hRes));

        if (!FAILED(hRes)) {

            hRes = pcCom->DeleteAllData(RootHandle, TEXT("Root Object"), ALL_METADATA, ALL_METADATA);
            printf("MDDeleteAllMetaData(RootHandle, (PBYTE)\"Root Object\", ALL_METADATA, ALL_METADATA); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteAllData(RootHandle, TEXT("junk 1"), ALL_METADATA, ALL_METADATA);
            printf("MDDeleteAllMetaData(RootHandle, (PBYTE)\"junk 1\", ALL_METADATA, ALL_METADATA); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteChildKeys(RootHandle, TEXT("junk 1"));
            printf("MDDeleteChildObjects(RootHandle, (PBYTE)\"junk 1\"); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteChildKeys(RootHandle, TEXT("Root Object"));
            printf("MDDeleteChildObjects(RootHandle, (PBYTE)\"Root Object\"); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteKey(RootHandle, TEXT("Root Object"));
            printf("MDDeleteMetaObject(RootHandle, TEXT(\"Root Object\")); Returns %s\n",
                ConvertHresToString(hRes));

            //
            // Delete everything we created last time.
            //

            hRes = pcCom->DeleteKey(RootHandle, TEXT("junk 1"));
            printf("MDDeleteMetaObject(RootHandle, TEXT(\"junk 1\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetHandleInfo(RootHandle, &mhiInfo);
            printf("MDGetHandleInfo(RootHandle, &mhiInfo); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("Handle Change Number = %d, Handle Permissions = %X\n", mhiInfo.dwMDSystemChangeNumber, mhiInfo.dwMDPermissions);
            }

            hRes = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE, TEXT(""), METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle);
            printf("MDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, \"\", METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->AddKey(RootHandle, TEXT("junk 1\\junk 2/junk 3/junk 4"));
            printf("MDAddMetaObject(RootHandle, \"junk 1/junk 2/junk 3/junk 4\"); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            hRes = pcCom->AddKey(RootHandle,
                TEXT("junk 1/This is a very long name for a metaobject and should generate an error")
                TEXT(" qwerq asf asf asdf asdf asdf fasd asdf fasd asdf asdf dfas fasd asdf sdfa asdf fsd asdf")
                TEXT(" fsd sdf asdf asdf  fsd fasd sdfa sdfa asdf fas  sdf fasd asdf asfd asfl  asfpok sadfop asf 012345"));

            printf("MDAddMetaObject(RootHandle, \"junk 1/This is a very long name for a metaobject and should generate"
                   " an error qwerq asf asf asdf asdf asdf fasd asdf fasd asdf asdf dfas fasd asdf sdfa asdf fsd asdf"
                   " fsd sdf asdf asdf  fsd fasd sdfa sdfa asdf fas  sdf fasd asdf asfd asfl  asfpok sadfop asf\"));"
                   " Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

        CHECK_SHUTDOWN

            hRes = pcCom->AddKey(RootHandle, TEXT("Root Object"));
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object\")); Returns %s\n",
                ConvertHresToString(hRes));

//            ConsumeRegistry(pcCom, RootHandle, "Root Object");

            hRes = pcCom->AddKey(RootHandle, TEXT("Root Object/Child Object1"));
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object1\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, TEXT("Root Object/Child Object1"), &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->AddKey(RootHandle, TEXT("Root Object/Child Object2"));
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object2\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->AddKey(RootHandle, TEXT("Root Object/Child Object2"));
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object2\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, TEXT("Root Object/Child Object1"), &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->AddKey(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"));
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, TEXT("Root Object/Child Object1"), &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->AddKey(RootHandle, TEXT("Root Object/Reference Object1"));
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Reference Object1\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->AddKey(RootHandle, TEXT("Root Object/Subject Object1"));
            printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Subject Object1\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetDataSetNumber(RootHandle, TEXT("Root Object/Child Object1"), &dwDataSetNumber);
            printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1\", &dwDataSetNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("Data Set Number = %d\n", dwDataSetNumber);
            }

            hRes = pcCom->GetDataSetNumber(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &dwDataSetNumber);
            printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &dwDataSetNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("Data Set Number = %d\n", dwDataSetNumber);
            }

            hRes = pcCom->GetDataSetNumber(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1/Doesn't Exist"), &dwDataSetNumber);
            printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1/GrandChild Object1/Doesn't Exist\", &dwDataSetNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("Data Set Number = %d\n", dwDataSetNumber);
            }

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));




            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, METADATA_SECURE, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                DWORD_DATA_NAME,
                ALL_METADATA);
            printf("MDDeleteData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), %u, ALL_METADATA); Returns %s\n",
                DWORD_DATA_NAME, ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            CHECK_SHUTDOWN

            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, 4, (PBYTE)NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, 0, (PBYTE)NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),&mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            ppszData[0] = TEXT("Hello ");
            ppszData[1] = TEXT("World ");
            ppszData[2] = TEXT("Test ");
            dwMultiszLen = SetMultisz((LPWSTR)binDataEntries, ppszData, 3);
            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, dwMultiszLen - 1, (PBYTE)binDataEntries)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            ppszData[0] = TEXT("Hello ");
            ppszData[1] = TEXT("World ");
            ppszData[2] = TEXT("Test ");
            dwMultiszLen = SetMultisz((LPWSTR)binDataEntries, ppszData, 3);
            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, dwMultiszLen, (PBYTE)binDataEntries)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),&mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            ppszData[0] = TEXT("Hello ");
            ppszData[1] = INSERT_PATH_DATA;
            ppszData[2] = TEXT("Test ");
            dwMultiszLen = SetMultisz((LPWSTR)binDataEntries, ppszData, 3);
            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_INSERT_PATH | METADATA_INHERIT, 0, MULTISZ_METADATA, dwMultiszLen, (PBYTE)binDataEntries)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME,  METADATA_INSERT_PATH | METADATA_INHERIT, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),&mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Enum should include the MULTISZ Data %x without path replacement ID. Get normally.\n", MULTISZ_DATA_NAME);
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, 0, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Enum should include the MULTISZ Data %x with path replacement ID. Get normally.\n", MULTISZ_DATA_NAME);
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, 0, METADATA_INSERT_PATH, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            hRes = pcCom->GetDataSetNumber(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1/Doesn't Exist"), &dwDataSetNumber);
            printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1/GrandChild Object1/Doesn't Exist\", &dwDataSetNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("Data Set Number = %d\n", dwDataSetNumber);
            }

            hRes = pcCom->DeleteData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                DWORD_DATA_NAME, ALL_METADATA);

            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), DWORD_DATA_NAME, ALL_METADATA); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetDataSetNumber(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1/Doesn't Exist"), &dwDataSetNumber);
            printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1/GrandChild Object1/Doesn't Exist\", &dwDataSetNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("Data Set Number = %d\n", dwDataSetNumber);
            }

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }


/*
            hRes = pcCom->SetReferenceObject(RootHandle, TEXT("Root Object/Reference Object1"),
                RootHandle, TEXT("Root Object/Reference Object1"));
            printf("MDSetReferenceObject(RootHandle, TEXT(\"Root Object/Reference Object1\"),\n\tRootHandle, TEXT(\"Root Object/Reference Object1\")); Returns %s\n",
                ConvertHresToString(hRes));
*/

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),&mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, METADATA_INHERIT, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword);
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, TEXT("Root Object"), &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, METADATA_NO_ATTRIBUTES, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, TEXT("Root Object"), &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, METADATA_INHERIT, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }
            // Test NULL String Data
            MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, 0, NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, sizeof(TEXT("STRING Data")), (PBYTE)(TEXT("STRING Data")))
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, METADATA_INHERIT, 0, EXPANDSZ_METADATA, sizeof(TEXT("STRING Data")), (PBYTE)(TEXT("STRING Data")))
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE)ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, sizeof(TEXT("STRING Data for Binary Name")), (PBYTE)(TEXT("STRING Data for Binary Name")))
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));


            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, 0, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, BAD_BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, 0x80000000, (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, FALSE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            CHECK_SHUTDOWN

            if (pcsiParam == NULL) {
                //
                // Reference data doesn't work remotely.
                // But it sort of works on the same machine so test it here.
                //
/*
                printf("\nTESTING REFERENCE DATA\n\n");

                MD_SET_DATA_RECORD(&mdrData, REFERENCE_DATA_NAME, METADATA_REFERENCE, 0, STRING_METADATA, sizeof(TEXT("STRING Data")), TEXT("STRING Data"))
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->SetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, REFERENCE_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, REFERENCE_DATA_NAME, METADATA_REFERENCE, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    hRes = pcCom->ReleaseReferenceData(mdrData.dwMDDataTag);
                    printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                        ConvertHresToString(hRes));
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                hRes = ERROR_SUCCESS;
                printf("\nThis Enum should include the reference ID %x. Get normally.\n", REFERENCE_DATA_NAME);
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, 0, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->EnumData(RootHandle,
                        TEXT("Root Object/Child Object1/GrandChild Object1"),
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                        if (mdrData.dwMDDataTag != 0) {
                            hRes = pcCom->ReleaseReferenceData(mdrData.dwMDDataTag);
                            printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                                ConvertHresToString(hRes));

                        }
                    }
                }

                hRes = ERROR_SUCCESS;
                printf("\nThis Enum should include the reference ID %x. Get by reference.\n", REFERENCE_DATA_NAME);
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, 0, METADATA_REFERENCE, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->EnumData(RootHandle,
                        TEXT("Root Object/Child Object1/GrandChild Object1"),
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                        if (mdrData.dwMDDataTag != 0) {
                            hRes = pcCom->ReleaseReferenceData(mdrData.dwMDDataTag);
                            printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                                ConvertHresToString(hRes));

                        }
                    }
                }

                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                printf("\nThis GetAll should include the reference ID %x. Get normally.\n", REFERENCE_DATA_NAME);
                hRes = pcCom->GetAllData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    METADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                       "\tMETADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                       " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                       ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))), TRUE, "GetAll Output Values");
                        DWORD dwDT = ((PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))))->dwMDDataTag;
                        if (dwDT != 0) {
                            hRes = pcCom->ReleaseReferenceData(dwDT);
                            printf("MDReleaseReferenceData(dwDT); Returns %s\n",
                                ConvertHresToString(hRes));

                        }
                    }
                }

                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                printf("\nThis GetAll should include the reference ID %x. Get by reference.\n", REFERENCE_DATA_NAME);
                hRes = pcCom->GetAllData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    METADATA_REFERENCE, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                       "\tMETADATA_REFERENCE, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                       " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                       ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))), TRUE, "GetAll Output Values");
                        DWORD dwDT = ((PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))))->dwMDDataTag;
                        if (dwDT != 0) {
                            hRes = pcCom->ReleaseReferenceData(dwDT);
                            printf("MDReleaseReferenceData(dwDT); Returns %s\n",
                                ConvertHresToString(hRes));

                        }
                    }
                }

                hRes = pcCom->DeleteData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    REFERENCE_DATA_NAME, ALL_METADATA);
                printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), REFERENCE_DATA_NAME, ALL_METADATA); returns %s\n",
                    ConvertHresToString(hRes));

                printf("\nEND TESTING REFERENCE DATA\n\n");
*/
            }

            MD_SET_DATA_RECORD(&mdrData, INSERT_PATH_DATA_NAME, METADATA_INSERT_PATH | METADATA_INHERIT, 0, STRING_METADATA, sizeof(INSERT_PATH_DATA), (PBYTE)INSERT_PATH_DATA)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle, TEXT("Root Object/Child Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, INSERT_PATH_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, TEXT("Root Object/Child Object1"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, INSERT_PATH_DATA_NAME, METADATA_INSERT_PATH, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, TEXT("Root Object/Child Object1"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            printf("\nThis Enum should include the INSERT_PATH Data %x with path replacement ID.\n", INSERT_PATH_DATA_NAME);
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, 0, METADATA_INSERT_PATH | METADATA_INHERIT, 0, STRING_METADATA, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }
            }

            dwBufferSize = 0;
            printf("\nThis GetAll should return ERROR_INSUFFICIENT_BUFFER.\n");
            hRes = pcCom->GetAllData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                METADATA_INSERT_PATH | METADATA_INHERIT, ALL_METADATA, STRING_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, NULL, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_INSERT_PATH | METADATA_INHERIT, ALL_METADATA, STRING_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, NULL, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));

            for (i = 0; i < BUFFER_SIZE; i++) {
                pbBuffer[i] = 0xff;
            }
            dwBufferSize = 0;
            printf("\nThis GetAll should return ERROR_INSUFFICIENT_BUFFER.\n");
            hRes = pcCom->GetAllData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                METADATA_INSERT_PATH | METADATA_INHERIT, ALL_METADATA, STRING_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_INSERT_PATH | METADATA_INHERIT, ALL_METADATA, STRING_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            for (i = 0; i < BUFFER_SIZE; i++) {
                pbBuffer[i] = 0xff;
            }
            dwBufferSize = (dwRequiredBufferLen < BUFFER_SIZE) ? dwRequiredBufferLen : BUFFER_SIZE;
            printf("\nThis GetAll should include the INSERT_PATH Data %x with path replacement ID.\n", INSERT_PATH_DATA_NAME);
            hRes = pcCom->GetAllData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                METADATA_INSERT_PATH | METADATA_INHERIT, ALL_METADATA, STRING_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_INSERT_PATH | METADATA_INHERIT, ALL_METADATA, STRING_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, 0, (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should SUCCEED.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should SUCCEED and set ISINHERITED.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_ISINHERITED), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should SUCCEED and set ISINHERITED, PARTIAL_PATH only.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_ISINHERITED), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                TEXT("Root Object/Should't Exist"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Should't Exist\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should SUCCEED.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                TEXT("Root Object/Doesn't Exist"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with ERROR_PATH_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                TEXT("Root Object/Doesn't Exist"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), DWORD_DATA_NAME_NO_INHERIT,\n\t &ReturnAttributes, &ReturnUserType, &ReturnDataType, &ReturnDataLen, (PVOID) ReturnBuf); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                TEXT("Root Object/Doesn't Exist"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            printf("\nThis Get should FAIL with ERROR_PATH_NOT_FOUND.\n");
            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle,
                TEXT("Root Object/Doesn't Exist"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Enum should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Enum should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            printf("\nThis Enum should set METADATA_ISINHERITED.\n");
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_ISINHERITED), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Enum should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            printf("\nThis Enum should set METADATA_ISINHERITED, PARTIAL_PATH only.\n");
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_ISINHERITED), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    TEXT("Root Object/Shouldn't Exist"),
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Shouldn't Exist\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            printf("\nThis GetAll is a test case of a failure reported by Philippe\n");
            hRes = pcCom->GetAllData(RootHandle,
                TEXT("LM/W3SVC/1/Root/Scripts"),
                METADATA_INHERIT | METADATA_PARTIAL_PATH, 2, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"LM/W3SVC/1/Root/Scripts\"),\n"
                   "\tMETADATA_INHERIT | METADATA_PARTIAL_PATH,2, ALL_METADATA, &dwNumDataEntries,"
                   "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);"
                   " Returns %s\n", ConvertHresToString(hRes));
            printf("dwBufferSize = %d, dwDataSetNumber = %d\n", dwBufferSize, dwDataSetNumber);
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            printf("\nThis GetAll is a test case of a failure reported by Philippe\n");
            hRes = pcCom->GetAllData(RootHandle,
                TEXT("LM/W3SVC/1/Root/Scripts/garbage/"),
                METADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"LM/W3SVC/1/Root/Scripts/garbage/\"),\n"
                   "\tMETADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                   "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            printf("dwBufferSize = %d, dwDataSetNumber = %d\n", dwBufferSize, dwDataSetNumber);
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            CHECK_SHUTDOWN

            //SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            dwBufferSize = 0;
            printf("\nThis GetAll should return ERROR_INSUFFICIENT_BUFFER");
            hRes = pcCom->GetAllData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, "
                   "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen));"
                   " Returns %s\n", ConvertHresToString(hRes));
            printf("dwRequiredBufferLen = %d, dwDataSetNumber = %d\n", dwRequiredBufferLen, dwDataSetNumber);

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            dwBufferSize = 101;
            printf("\nThis GetAll should return ERROR_INSUFFICIENT_BUFFER");
            hRes = pcCom->GetAllData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, "
                   "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen));"
                   " Returns %s\n", ConvertHresToString(hRes));
            printf("dwRequiredBufferLen = %d\n", dwRequiredBufferLen);

            for (i = 0; i < BUFFER_SIZE; i++) {
                pbBuffer[i] = 0xff;
            }
            dwBufferSize = (dwRequiredBufferLen < BUFFER_SIZE)? dwRequiredBufferLen : BUFFER_SIZE;
            printf("\nThis GetAll should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            hRes = pcCom->GetAllData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            for (i = 0; i < BUFFER_SIZE; i++) {
                pbBuffer[i] = 0xff;
            }
            dwBufferSize = BUFFER_SIZE;
            printf("\nThis GetAll should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            printf("\nThis GetAll should set METADATA_ISINHERITED.\n");
            hRes = pcCom->GetAllData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                METADATA_INHERIT | METADATA_ISINHERITED, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_INHERIT | METADATA_ISINHERITED, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            for (i = 0; i < BUFFER_SIZE; i++) {
                pbBuffer[i] = 0xff;
            }
            dwBufferSize = BUFFER_SIZE;
            printf("\nThis GetAll should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            printf("\nThis GetAll should set METADATA_ISINHERITED, PARTIAL_PATH only.\n");
            hRes = pcCom->GetAllData(RootHandle,
                TEXT("Root Object/Shouldn't Exist"),
                METADATA_INHERIT | METADATA_ISINHERITED | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Shouldn't Exist\"),\n"
                   "\tMETADATA_INHERIT | METADATA_ISINHERITED, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Enum should not include ID %x or %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    TEXT("Root Object/Child Object1/GrandChild Object1"),
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            printf("\nThis GetAll should not include ID %x or %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            hRes = pcCom->GetAllData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                METADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                   "\tMETADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Partial Path Enum should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    TEXT("Root Object/Doesn't Exist"),
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            printf("\nThis Partial Path GetAll should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
            hRes = pcCom->GetAllData(RootHandle,
                TEXT("Root Object/Doesn't Exist"),
                METADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"),\n"
                   "\tMETADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                   " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                   ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            hRes = ERROR_SUCCESS;
            printf("\nThis Partial Path Enum should FAIL with ERROR_PATH_NOT_FOUND\n");
            for (i=0;hRes == ERROR_SUCCESS; i++) {
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf);
                PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                hRes = pcCom->EnumData(RootHandle,
                    TEXT("Root Object/Doesn't Exist"),
                    &mdrData, i, &dwRequiredDataLen);
                printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData, i); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                }
            }

            SET_GETALL_PARMS(MAX_DATA_ENTRIES);
            printf("\nThis Partial Path GetAll should FAIL with ERROR_PATH_NOT_FOUND\n");
            hRes = pcCom->GetAllData(RootHandle,
                TEXT("Root Object/Doesn't Exist"),
                METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwDataSetNumber,
                dwBufferSize, pbBuffer, &dwRequiredBufferLen);
            printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"),\n"
                   "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwDataSetNumber,"
                   " dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                    PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                }
            }

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            hRes = pcCom->CopyData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                RootHandle,
                TEXT("Root Object/Child Object1"),
                METADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, TRUE);
            printf("\nMDCopyMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), RootHandle,\n\tTEXT(\"Root Object/Child Object1\"), METADATA_INHERIT | METADATA_PARTIAL_PATH, 0, TRUE); Returns %s\n",
                ConvertHresToString(hRes));

            CHECK_SHUTDOWN

           dwBufferSize = 0;
           printf("\nThis GetDataPaths should return ERROR_INSUFFICIENT_BUFFER");
           hRes = pcCom->GetDataPaths(
               RootHandle,
               TEXT("Root Object/Child Object1"),
               DWORD_DATA_NAME,
               ALL_METADATA,
               dwBufferSize,
               NULL,
               &dwRequiredBufferLen);
           printf("\nMDGetDataPaths(...) Returns %s\n", ConvertHresToString(hRes));
           printf("dwRequiredBufferLen = %d\n", dwRequiredBufferLen);

            dwBufferSize = 10;
            printf("\nThis GetDataPaths should return ERROR_INSUFFICIENT_BUFFER");
            hRes = pcCom->GetDataPaths(
                RootHandle,
                TEXT("Root Object/Child Object1"),
                DWORD_DATA_NAME,
                ALL_METADATA,
                dwBufferSize,
                (LPWSTR)pbBuffer,
                &dwRequiredBufferLen);
            printf("\nMDGetDataPaths(...) Returns %s\n", ConvertHresToString(hRes));
            printf("dwRequiredBufferLen = %d\n", dwRequiredBufferLen);

            for (i = 0; i < BUFFER_SIZE; i++) {
                pbBuffer[i] = 0xff;
            }
            dwBufferSize = (dwRequiredBufferLen < (BUFFER_SIZE/ sizeof(WCHAR)))? dwRequiredBufferLen : (BUFFER_SIZE/sizeof(WCHAR));
            printf("\nThis GetDataPaths should return ERROR_SUCCESS");
            hRes = pcCom->GetDataPaths(
                RootHandle,
                TEXT("Root Object/Child Object1"),
                DWORD_DATA_NAME,
                ALL_METADATA,
                dwBufferSize,
                (LPWSTR)pbBuffer,
                &dwRequiredBufferLen);
            printf("\nMDGetDataPaths(...) Returns %s\n", ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                for (LPWSTR pszString = (LPWSTR)pbBuffer;
                     *pszString != (WCHAR)'\0';
                     pszString += (wcslen(pszString) + 1)) {
                    printf("\tReturned Path = %S\n", pszString);
                }
            }

            hRes = pcCom->CopyKey(RootHandle, TEXT("/Root Object"), RootHandle, TEXT("junk 1/Root Object"), TRUE, TRUE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"/Root Object\", RootHandle, (PBYTE)\"junk 1/Root Object\", TRUE, TRUE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CopyKey(RootHandle, TEXT("junk 1/Root Object"), RootHandle, TEXT("junk 1/junk 2/NewCopyName"), TRUE, TRUE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", TRUE, TRUE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CopyKey(RootHandle, TEXT("junk 1/Root Object"), RootHandle, TEXT("junk 1/junk 2/NewCopyName"), TRUE, TRUE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", TRUE, TRUE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CopyKey(RootHandle, TEXT("junk 1/Root Object"), RootHandle, TEXT("junk 1/NewCopyTree/NewCopyName"), TRUE, TRUE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/NewCopyTree/NewCopyName\", TRUE, TRUE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CopyKey(RootHandle, TEXT("junk 1/Root Object"), RootHandle, TEXT("junk 1/NewCopyTree2/Root Object"), TRUE, TRUE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/NewCopyTree2/Root Object\", TRUE, TRUE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CopyKey(RootHandle, TEXT("junk 1/Root Object"), RootHandle, TEXT("junk 1/junk 2/NewCopyName"), FALSE, TRUE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", FALSE, TRUE); returns %s\n",
                ConvertHresToString(hRes));

            dwBufferSize = 1;
            printf("\nThis GetDataPaths should return ERROR_INSUFFICIENT_BUFFER, length = 2");
            hRes = pcCom->GetDataPaths(
                RootHandle,
                TEXT("junk 1"),
                UNUSED_DATA_NAME,
                ALL_METADATA,
                dwBufferSize,
                (LPWSTR)pbBuffer,
                &dwRequiredBufferLen);
            printf("\nMDGetDataPaths(...) Returns %s\n", ConvertHresToString(hRes));
            printf("dwRequiredBufferLen = %d\n", dwRequiredBufferLen);

            dwBufferSize = 2;
            printf("\nThis GetDataPaths should SUCCEED");
            hRes = pcCom->GetDataPaths(
                RootHandle,
                TEXT("junk 1"),
                UNUSED_DATA_NAME,
                ALL_METADATA,
                dwBufferSize,
                (LPWSTR)pbBuffer,
                &dwRequiredBufferLen);
            printf("\nMDGetDataPaths(...) Returns %s\n", ConvertHresToString(hRes));
            printf("dwRequiredBufferLen = %d\n", dwRequiredBufferLen);

            dwBufferSize = 10;
            printf("\nThis GetDataPaths should return ERROR_INSUFFICIENT_BUFFER");
            hRes = pcCom->GetDataPaths(
                RootHandle,
                TEXT("junk 1"),
                DWORD_DATA_NAME,
                ALL_METADATA,
                dwBufferSize,
                (LPWSTR)pbBuffer,
                &dwRequiredBufferLen);
            printf("\nMDGetDataPaths(...) Returns %s\n", ConvertHresToString(hRes));
            printf("dwRequiredBufferLen = %d\n", dwRequiredBufferLen);

            for (i = 0; i < BUFFER_SIZE; i++) {
                pbBuffer[i] = 0xff;
            }
            dwBufferSize = (dwRequiredBufferLen < (BUFFER_SIZE/ sizeof(WCHAR)))? dwRequiredBufferLen : (BUFFER_SIZE/sizeof(WCHAR));
            printf("\nThis GetDataPaths should return ERROR_SUCCESS");
            hRes = pcCom->GetDataPaths(
                RootHandle,
                TEXT("junk 1"),
                DWORD_DATA_NAME,
                ALL_METADATA,
                dwBufferSize,
                (LPWSTR)pbBuffer,
                &dwRequiredBufferLen);
            printf("\nGetDataPaths(...) Returns %s\n", ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                for (LPWSTR pszString = (LPWSTR)pbBuffer;
                     *pszString != (WCHAR)'\0';
                     pszString += (wcslen(pszString) + 1)) {
                    printf("\tReturned Path = %S\n", pszString);
                }
            }

            hRes = pcCom->CopyKey(RootHandle, TEXT("junk 1/Root Object"), RootHandle, TEXT("junk 1/junk 2/NewCopyName"), FALSE, FALSE);
            printf("ADMCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", FALSE, FALSE); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->RenameKey(RootHandle, TEXT("junk 1/junk 2/NewCopyName"), TEXT("Renamed Object"));
            printf("ADMRenameMetaObject(RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", (PBYTE)\"Renamed Object\"); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->RenameKey(RootHandle, TEXT("junk 1/junk 2/Renamed Object"), TEXT("Bad Name/"));
            printf("RenameKey(RootHandle, TEXT(\"junk 1/junk 2/Renamed Object\"), TEXT(\"Bad Name/\")); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetSystemChangeNumber(&dwSystemChangeNumber);
            printf("ADMGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            ftTime.dwHighDateTime = 1;
            ftTime.dwLowDateTime = 2;

            hRes = pcCom->SetLastChangeTime(RootHandle, TEXT("Root Object"), &ftTime, FALSE);
            printf("ADMSetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->SetLastChangeTime(RootHandle, NULL, &ftTime, FALSE);
            printf("ADMSetLastChangeTime(RootHandle, NULL, &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            printf("This SetData should set volatle and not get saved");
            MD_SET_DATA_RECORD(&mdrData, VOLATILE_DATA_NAME, METADATA_VOLATILE, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,TEXT(""),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"\"), &mdrData); Returns %s\n\n",
                ConvertHresToString(hRes));

            hRes = pcCom->ChangePermissions(RootHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ);
            printf("ADMChangePermissions(RootHandle, METADATA_PERMISSION_READ); Returns %s\n\n",
                ConvertHresToString(hRes));

            hRes = pcCom->OpenKey(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle);
            printf("ADMOpenMetaObject(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), METADATA_PERMISSION_READ, &OpenHandle); Returns %s\n\n",
                ConvertHresToString(hRes));

            if (hRes == ERROR_SUCCESS) {

                hRes = pcCom->GetHandleInfo(OpenHandle, &mhiInfo);
                printf("ADMGetHandleInfo(RootHandle, &mhiInfo); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("Handle Change Number = %d, Handle Permissions = %X\n", mhiInfo.dwMDSystemChangeNumber, mhiInfo.dwMDPermissions);
                }

                for (i=0;hRes == ERROR_SUCCESS;i++) {
                    hRes = pcCom->EnumKeys(OpenHandle, TEXT(""), NameBuf, i);
                    printf("MDEnumMetaObjects(OpenHandle, NULL, (LPTSTR)NameBuf, i); returns %s\n",
                        ConvertHresToString(hRes));
                }

                hRes = pcCom->ChangePermissions(RootHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
                printf("\nMDChangePermissions(RootHandle, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE); Returns %s\n\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ChangePermissions(OpenHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
                printf("MDChangePermissions(OpenHandle, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE); Returns %s\n\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->CloseKey(OpenHandle);
                printf("MDCloseMetaObject(OpenHandle); Returns %s\n\n",
                    ConvertHresToString(hRes));
            }

            for (i=0;hRes == ERROR_SUCCESS;i++) {
                hRes = pcCom->EnumKeys(RootHandle, TEXT(""), NameBuf, i);
                printf("MDEnumMetaObjects(RootHandle, NULL, (LPTSTR)NameBuf, i); returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    printf("Object Name = %S\n", NameBuf);
                }
            }

            CHECK_SHUTDOWN

            hRes = pcCom->SaveData();
            printf("\nMDSaveData(); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->ChangePermissions(RootHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
            printf("\nMDChangePermissions(RootHandle, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE); Returns %s\n\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, 0, 0, BINARY_METADATA, 0, NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, 0, 0, BINARY_METADATA, 1, NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                ConvertHresToString(hRes));

            MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, STRING_METADATA, 0, NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                ConvertHresToString(hRes));

            FILL_RETURN_BUFF;
            MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
            PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
            hRes = pcCom->GetData(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData, &dwRequiredDataLen);
            printf("MDGetMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &mdrData, &dwRequiredDataLen); Returns %s\n",
                ConvertHresToString(hRes));
            if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
            }
            else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                printf("DataLen = %X\n", dwRequiredDataLen);
            }

            MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, 0, 0, DWORD_METADATA, 0, NULL)
            PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
            hRes = pcCom->SetData(RootHandle,TEXT("Root Object/Child Object1/GrandChild Object1"),
                &mdrData);
            printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                BINARY_DATA_NAME, BINARY_METADATA);
            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), BINARY_DATA_NAME, BINARY_METADATA); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->GetLastChangeTime(RootHandle, TEXT("Root Object"), &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->GetLastChangeTime(RootHandle, TEXT("Root Object/Child Object1/GrandChild Object1"), &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->SetLastChangeTime(RootHandle, TEXT("Root Object"), &ftTime, FALSE);
            printf("MDSetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->GetLastChangeTime(RootHandle, TEXT("Root Object"), &ftTime, FALSE);
            printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->DeleteData(RootHandle,
                TEXT("Root Object/Child Object1/GrandChild Object1"),
                BINARY_DATA_NAME, STRING_METADATA);
            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), BINARY_DATA_NAME, STRING_METADATA); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteData(RootHandle,
                TEXT("Root Object"),
                BINARY_DATA_NAME, ALL_METADATA);
            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object\"), BINARY_DATA_NAME, ALL_METADATA); returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteData(RootHandle,
                TEXT("Root Object/Trash"),
                BINARY_DATA_NAME, ALL_METADATA);
            printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Trash\"), BINARY_DATA_NAME, ALL_METADATA); returns %s\n\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteAllData(RootHandle,
                                                 TEXT("Root Object/Child Object1/GrandChild Object1"),
                                                  ALL_METADATA,
                                                  ALL_METADATA);
            printf("MDDeleteAllMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", ALL_METADATA, ALL_METADATA); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteAllData(RootHandle,
                                                 TEXT("Root Object"),
                                                  ALL_METADATA,
                                                  ALL_METADATA);
            printf("MDDeleteAllMetaData(RootHandle, (PBYTE)\"Root Object\", ALL_METADATA, ALL_METADATA); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteKey(RootHandle, TEXT("Root Object/Child Object1"));
            printf("MDDeleteMetaObject(RootHandle, TEXT(\"Root Object/Child Object1\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteKey(RootHandle, TEXT("Root Object"));
            printf("MDDeleteMetaObject(RootHandle, TEXT(\"Root Object\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->DeleteChildKeys(RootHandle, TEXT("junk 1"));
            printf("MDDeleteChildObjects(RootHandle, (PBYTE)\"junk 1\"); Returns %s\n",
                ConvertHresToString(hRes));

            CHECK_SHUTDOWN

            hRes = pcCom->Backup(NULL,
                                 MD_BACKUP_NEXT_VERSION,
                                 MD_BACKUP_OVERWRITE | MD_BACKUP_SAVE_FIRST);

            printf("\nBackup(...); Returns %s\n",
                ConvertHresToString(hRes));

            CHECK_SHUTDOWN

            hRes = pcCom->Backup(NULL,
                                 MD_BACKUP_NEXT_VERSION,
                                 MD_BACKUP_OVERWRITE | MD_BACKUP_SAVE_FIRST | MD_BACKUP_FORCE_BACKUP);

            printf("\nBackup(...); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CloseKey(RootHandle);
            printf("MDCloseMetaObject(RootHandle); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->Backup(TEXT("NamedBackup"),
                                 MD_BACKUP_NEXT_VERSION,
                                 MD_BACKUP_OVERWRITE | MD_BACKUP_SAVE_FIRST);

            printf("\nBackup(...); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->Backup(TEXT("NamedBackup"),
                                 27,
                                 MD_BACKUP_OVERWRITE | MD_BACKUP_SAVE_FIRST);

            printf("\nBackup(...); Returns %s\n",
                ConvertHresToString(hRes));

            WCHAR pszBackupName[MD_BACKUP_MAX_LEN];
            DWORD dwBackupVersion;
            FILETIME ftBackupTime;
            hRes = ERROR_SUCCESS;
            for (i = 0;SUCCEEDED(hRes);i++) {
                pszBackupName[0] = (WCHAR)'\0';
                hRes = pcCom->EnumBackups(pszBackupName,
                                          &dwBackupVersion,
                                          &ftBackupTime,
                                          i);

                printf("\nEnumBackups(...); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    printf("\tBackupName = %S, Backup Version = %d\n", pszBackupName, dwBackupVersion);
                }
            }


            hRes = pcCom->Backup(TEXT("Invalid Name /"),
                                 MD_BACKUP_NEXT_VERSION,
                                 MD_BACKUP_OVERWRITE | MD_BACKUP_SAVE_FIRST);

            printf("\nBackup(\"Invalid Name /\"...); Returns %s\n",
                ConvertHresToString(hRes));

            CHECK_SHUTDOWN

            //
            // Open a handle to make sure it's Closed by Restore
            //

            hRes = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                                  TEXT("junk 1"),
                                  METADATA_PERMISSION_READ,
                                  TIMEOUT_VALUE,
                                  &OpenHandle);

            printf("\n\nMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, TEXT(\"junk 1\"), METADATA_PERMISSION_READ, TIMEOUT_VALUE, &RootHandle); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->Restore(TEXT("NamedBackup"),
                                       MD_BACKUP_HIGHEST_VERSION,
                                       0);
            //
            // Restore calls ShutdownNotify, but not really a shutdown, so reset flag.
            //

            g_bShutdown = FALSE;
            printf("\nRestore(...); Returns %s\n",
                ConvertHresToString(hRes));

            //
            // Make sure handle was really closed.
            // This should return ERROR_INVALID_HANDLE
            //

            hRes = pcCom->CloseKey(OpenHandle);
            printf("MDCloseMetaObject(OpenHandle); Returns %s\n",
                    ConvertHresToString(hRes));

            hRes = pcCom->DeleteBackup(TEXT("NamedBackup"),
                                            27);

            printf("\nDeleteBackup(...); Returns %s\n",
                ConvertHresToString(hRes));

        }
/*
        hRes = pcCom->RemoveCallBack(&MDCallBack);
        printf("\nMDRemoveCallBack(&MDCallBack); Returns %s\n",
            ConvertHresToString(hRes));
*/

        hRes = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE, TEXT(""), METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, TIMEOUT_VALUE, &RootHandle);
        printf("\n\nMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, sizeof(\"\"), \"\", METADATA_PERMISSION_WRITE || METADATA_PERMISSION_READ, TIMEOUT_VALUE, &RootHandle); Returns %s\n",
            ConvertHresToString(hRes));

        if (hRes == ERROR_SUCCESS) {

            hRes = pcCom->AddKey(RootHandle, TEXT("/Root/"));
            printf("\nMDAddMetaObject(RootHandle, TEXT(\"/Root/\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->AddKey(RootHandle, TEXT("Root Object/instance1/Root/"));
            printf("\nMDAddMetaObject(RootHandle, TEXT(\"Root Object/instance1/Root/\")); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->CloseKey(RootHandle);
            printf("MDCloseMetaObject(OpenHandle); Returns %s\n",
                ConvertHresToString(hRes));

            hRes = pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE, TEXT("Root Object/instance1/"), METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, TIMEOUT_VALUE, &OpenHandle);
            printf("\nMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, sizeof(\"Root Object/instance1/\"), (PBYTE)\"Root Object/instance1/\", METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, TIMEOUT_VALUE, &OpenHandle); Returns %s\n",
                ConvertHresToString(hRes));

            if (hRes == ERROR_SUCCESS) {

                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, METADATA_INHERIT, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword);
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->SetData(OpenHandle, TEXT("/Root/"), &mdrData);
                printf("MDSetMetaData(OpenHandle, sizeof(\"/Root/\"), (PBYTE)\"/Root/\", &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, sizeof(TEXT("STRING Data")), (PBYTE)(TEXT("STRING Data")))
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->SetData(OpenHandle,
                    TEXT("/"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, sizeof(\"/\"), TEXT(\"Root Object/instance1/\", &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, METADATA_INHERIT, 0, EXPANDSZ_METADATA, sizeof(TEXT("STRING Data")), (PBYTE)(TEXT("STRING Data")))
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->SetData(OpenHandle,
                    TEXT("/"),
                    &mdrData);
                printf("MDSetMetaData(RootHandle, sizeof(\"/\"), TEXT(\"Root Object/instance1/\", &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    TEXT("/Root/"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/Root/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with ERROR_DATA_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    TEXT("/"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    TEXT("/"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    TEXT("/"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, METADATA_INHERIT, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    TEXT("/Root/"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/Root/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, METADATA_INHERIT, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    TEXT("/Root/"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/Root/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with ERROR_DATA_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    TEXT("/Root/"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/Root/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with ERROR_DATA_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->GetData(OpenHandle,
                    TEXT("/Root/"),
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(OpenHandle, TEXT(\"/Root/\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                CHECK_SHUTDOWN

                hRes = pcCom->CloseKey(OpenHandle);
                printf("MDCloseMetaObject(OpenHandle); Returns %s\n",
                    ConvertHresToString(hRes));
            }
        }
SHUTDOWN:
/*
            hRes = pcCom->Terminate(FALSE);
            printf("\nMDTerminate(FALSE); Returns %s\n",
                ConvertHresToString(hRes));
        }
*/


/*
        LPSTREAM pStream;
        hRes = CoMarshalInterThreadInterfaceInStream(IID_IConnectionPoint,
                                                     pConnPoint,
                                                     &pStream);

        if (SUCCEEDED(hRes)) {
*/
            SINKPARAMS spParamBlock;
//            spParamBlock.pStream = pStream;
            spParamBlock.pcCom = pcCom;

            spParamBlock.dwCookie = dwCookie;
            spParamBlock.bSinkConnected = bSinkConnected;


            RunThread(ReleaseSinkThread, (PVOID)&spParamBlock);
/*
        }
        else {
            printf("CoMarshalInterThreadInterfaceInStream(...) return %s\n",
                   ConvertHresToString(hRes));
        }
*/
/*
        if (bSinkConnected) {

            // First query the object for its Connection Point Container. This
            // essentially asks the object in the server if it is connectable.
            hRes = pcCom->QueryInterface(
                   IID_IConnectionPointContainer,
                   (PVOID *)&pConnPointContainer);
            if SUCCEEDED(hRes)
            {
              // Find the requested Connection Point. This AddRef's the
              // returned pointer.
              hRes = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink_W, &pConnPoint);
              if (SUCCEEDED(hRes)) {
                  hRes = pConnPoint->Unadvise(dwCookie);
                  printf("pConnPoint->Unadvise((IUnknown *)pEventSink, &dwCookie); Returns %s\n", ConvertHresToString(hRes));
                  pConnPoint->Release();
              }

              RELEASE_INTERFACE(pConnPointContainer);
            }
        }
*/

        pcCom->Release();
    }

    }
    CoFreeUnusedLibraries();

    CoUninitialize();

    delete (pEventSink);

    return (0);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\unitest\sink.cxx ===
#define UNICODE
#include <windows.h>
#include <ole2.h>
#include <iadmw.h>
#include <stdio.h>
#include <sink.hxx>

extern BOOL g_bShutdown;

//extern HANDLE          hevtDone;

CImpIADMCOMSINKW::CImpIADMCOMSINKW()
{
    m_dwRefCount=0;
    m_pcCom = NULL;
}

CImpIADMCOMSINKW::~CImpIADMCOMSINKW()
{
}

HRESULT
CImpIADMCOMSINKW::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IMSAdminBaseSink) {
        *ppObject = (IMSAdminBaseSink *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CImpIADMCOMSINKW::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CImpIADMCOMSINKW::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}

HRESULT STDMETHODCALLTYPE
CImpIADMCOMSINKW::SinkNotify(
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList[  ])
{
    DWORD i, j;
    HRESULT hresReturn;

    printf("*************Recieved callback \n");
    for (i = 0; i < dwMDNumElements; i++) {
        printf("Change Type = %X, Path = %S\n", pcoChangeList[i].dwMDChangeType, pcoChangeList[i].pszMDPath);
        for (j = 0; j < pcoChangeList[i].dwMDNumDataIDs; j++) {
            printf("\tData Changed ID = %X\n", pcoChangeList[i].pdwMDDataIDs[j]);
        }
    }
    printf("\n");

    if (m_pcCom != NULL) {
        // Test metabase access
        METADATA_HANDLE RootHandle;
#if 0
        hresReturn = m_pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE, NULL, METADATA_PERMISSION_READ, 2000, &RootHandle);
        printf("OpenKey within SinkNotify returns %X\n", hresReturn);
        if (SUCCEEDED(hresReturn)) {
            hresReturn = m_pcCom->CloseKey(RootHandle);
            printf("CloseKey within SinkNotify returns %X\n", hresReturn);
        }
#endif
    }

    return (0);
}

HRESULT STDMETHODCALLTYPE
CImpIADMCOMSINKW::ShutdownNotify( void)
{
    HRESULT hresResult;
    printf("*************Recieved shutdown callback \n");
    if (m_pcCom != NULL) {
        // Test metabase access
        METADATA_HANDLE RootHandle;

        hresResult = m_pcCom->OpenKey(METADATA_MASTER_ROOT_HANDLE, NULL, METADATA_PERMISSION_READ, 2000, &RootHandle);
        printf("OpenKey within ShutdownNotify returns %X\n", hresResult);
        if (SUCCEEDED(hresResult)) {
            hresResult = m_pcCom->CloseKey(RootHandle);
            printf("CloseKey within ShutdownNotify returns %X\n", hresResult);
        }
    }
    g_bShutdown = TRUE;
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\tables.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       tables.h

   Abstract:

        mapping tables to convert various info between text and binary

   Environment:

      Win32 User Mode

   Author: 
     
	  jaroslad  (jan 1997)

--*/

#if !defined (__JD_TABLES_H)
#define __JD_TABLES_H 


#include <afx.h>
#ifdef UNICODE
	#include <iadmw.h>
#else
	#include "ansimeta.h"
#endif

//constanst to be returned by functions that map name to code
//
#define NAME_NOT_FOUND 0xFFFFFFFE

BOOL IsNumber(const CString& name);



BOOL IsServiceName(const CString& name);


//**********************************************************************
// PROPERTY NAME TABLE DEFINITION
//**********************************************************************
struct tPropertyNameTable;
 
tPropertyNameTable gPropertyNameTable[];

struct tPropertyNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwDefAttributes; //default attributes (metadata compatible)
	DWORD dwDefUserType;   //default user type (metadata compatible)
	DWORD dwDefDataType;   //default data type (metadata compatible)
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static tPropertyNameTable * FindRecord(DWORD dwCode, tPropertyNameTable * PropertyNameTable=::gPropertyNameTable);
	static tPropertyNameTable * FindRecord(const CString strName, tPropertyNameTable * PropertyNameTable=::gPropertyNameTable);
	
	static DWORD MapNameToCode(const CString& strName, tPropertyNameTable * PropertyNameTable=::gPropertyNameTable);
	static CString MapCodeToName(DWORD dwCode, tPropertyNameTable * PropertyNameTable=::gPropertyNameTable);
};

DWORD MapPropertyNameToCode(const CString & strName);



//**********************************************************************
// VALUE TABLE DEFINITION
//**********************************************************************

struct tValueTable ;
tValueTable gValueTable[];

struct tValueTable 
{
	enum {TYPE_EXCLUSIVE=1};
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwRelatedPropertyCode; // code of the Property this value can be used for
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD  MapNameToCode(const CString& strName, DWORD dwRelatedPropertyCode, tValueTable * ValueTable=::gValueTable);
	static CString MapValueContentToString(DWORD dwValueContent, DWORD dwRelatedPropertyCode, tValueTable * ValueTable=::gValueTable);

};

DWORD  MapValueNameToCode(const CString & strName, DWORD dwRelatedPropertyCode);



//**********************************************************************
// COMMAND NAME TABLE DEFINITION 
//**********************************************************************

struct tCommandNameTable ;
tCommandNameTable gCommandNameTable[];

struct tCommandNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD  MapNameToCode(const CString& strName, tCommandNameTable * CommandNameTable=::gCommandNameTable);
};

DWORD MapCommandNameToCode(const CString & strName);

enum
{	CMD_SET=1,
	CMD_GET,
	CMD_COPY,
	CMD_DELETE,
	CMD_ENUM,
	CMD_ENUM_ALL,
	CMD_CREATE,
	CMD_RENAME,
	CMD_SCRIPT,
	CMD_SAVE,
	CMD_APPCREATEINPROC,
	CMD_APPCREATEOUTPOOL,
	CMD_APPCREATEOUTPROC,
	CMD_APPDELETE,
        CMD_APPRENAME,
	CMD_APPUNLOAD,
	CMD_APPGETSTATUS,
};

//**********************************************************************
// PROPERTY ATTRIB NAME TABLE DEFINITION
//**********************************************************************
struct tAttribNameTable ;
tAttribNameTable gAttribNameTable[];


struct tAttribNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD MapNameToCode(const CString& strName, tAttribNameTable * AttribNameTable=::gAttribNameTable);
};

DWORD MapAttribNameToCode(const CString & strName);


//**********************************************************************
// PROPERTY DATA TYPE NAME TABLE DEFINITION 
//**********************************************************************

struct tDataTypeNameTable ;
tDataTypeNameTable gDataTypeNameTable[];

struct tDataTypeNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD  MapNameToCode(const CString& strName, tDataTypeNameTable * DataTypeNameTable=::gDataTypeNameTable);
	static CString MapCodeToName(DWORD a_dwCode, tDataTypeNameTable * DataTypeNameTable=::gDataTypeNameTable);

};

DWORD MapDataTypeNameToCode(const CString & strName);

//**********************************************************************
// PROPERTY USER TYPE NAME TABLE DEFINITION AND IMPLEMENTATION
//**********************************************************************

struct tUserTypeNameTable ;
tUserTypeNameTable gUserTypeNameTable[];


struct tUserTypeNameTable 
{
	DWORD dwCode;
	LPCTSTR lpszName;
	DWORD dwFlags;         //internal flags (nothing to do with metadata)

	static DWORD  MapNameToCode(const CString& strName, tUserTypeNameTable * UserTypeNameTable=::gUserTypeNameTable);
};

DWORD MapUserTypeNameToCode(const CString & strName);



void PrintTablesInfo(void);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\extend\checker.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    checker.cxx

Abstract:

    IIS Services IISADMIN Extension
    Unicode Metadata Sink.

Author:

    Michael W. Thomas            11-19-98

--*/
#include <cominc.hxx>
#include <lmaccess.h>
#include <lmserver.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <ntlsa.h>
#include <time.h>

#include <ntsam.h>
#include <netlib.h>
#include <resource.h>

#define SECURITY_WIN32
#define ISSP_LEVEL  32
#define ISSP_MODE   1
#include <sspi.h>
#include <sspi.h>
#include <eventlog.hxx>
#include "extend.h"

#include <comadmin.h>
#include <sddl.h>

#include "wmrgexp.h"

typedef TCHAR USERNAME_STRING_TYPE[MAX_PATH];
typedef TCHAR PASSWORD_STRING_TYPE[LM20_PWLEN+1];

const LPCWSTR ROOTMDPath = L"/LM/W3SVC";

#define IIS_WP_GROUP        L"IIS_WPG"

typedef enum {
    GUFM_SUCCESS,
    GUFM_NO_PATH,
    GUFM_NO_PASSWORD,
    GUFM_NO_USER_ID
} GUFM_RETURN;

BOOL  ValidatePassword(IN LPCTSTR UserName,IN LPCTSTR Domain,IN LPCTSTR Password);
void  InitLsaString(PLSA_UNICODE_STRING LsaString,LPWSTR String);
DWORD GetPrincipalSID (LPCTSTR Principal,PSID *Sid,BOOL *pbWellKnownSID);
DWORD OpenPolicy(LPTSTR ServerName,DWORD DesiredAccess,PLSA_HANDLE PolicyHandle);
DWORD AddRightToUserAccount(LPCTSTR szAccountName, LPTSTR PrivilegeName);
DWORD DoesUserHaveThisRight(LPCTSTR szAccountName, LPTSTR PrivilegeName,BOOL *fHaveThatRight);
HRESULT UpdateComApplications(IMDCOM * pcCom,LPCTSTR szWamUserName,LPCTSTR szWamUserPass);
int   IsDomainController(void);
BOOL  WaitForDCAvailability(void);
HRESULT UpdateAdminAcl(IMDCOM *pcCom, LPCWSTR szPath, LPCWSTR szAccountName);


// these two lines for logging event about account recreation
EVENT_LOG *g_eventLogForAccountRecreation = NULL; 
BOOL CreateEventLogObject();



VOID  UpdateUserRights (LPCTSTR  account,LPTSTR pstrRights[],DWORD dwNofRights)
{
    DWORD status;
    BOOL  fPresence;

    
    for (DWORD i=0;i<dwNofRights;i++)
    {
        
        
        status = DoesUserHaveThisRight(account,pstrRights[i],&fPresence);
        if (!NT_SUCCESS(status))
        {
            DBGPRINTF(( DBG_CONTEXT,"[UpdateAnonymousUser] DoesUserHaveThisRight returned err=0x%0X for account %s right %s\n",status,account,pstrRights[i]));
        }
        else
        {
            if (!fPresence)
            {
                status = AddRightToUserAccount(account,pstrRights[i]);
                if (!NT_SUCCESS(status))
                {
                    DBGPRINTF(( DBG_CONTEXT,"[UpdateAnonymousUser] AddRightToUserAccount returned err=0x%0X for account %s right %s\n",status,account,pstrRights[i]));
                }
            }
        }
    }
}

DWORD AddRightToUserAccount(LPCTSTR szAccountName, LPTSTR PrivilegeName)
{
    BOOL fEnabled = FALSE;
    NTSTATUS status;
	LSA_UNICODE_STRING UserRightString;
    LSA_HANDLE PolicyHandle = NULL;

    // Create a LSA_UNICODE_STRING for the privilege name.
    InitLsaString(&UserRightString, PrivilegeName);

    // get the sid of szAccountName
    PSID pSID = NULL;
    BOOL bWellKnownSID = FALSE;

    status = GetPrincipalSID ((LPTSTR)szAccountName, &pSID, &bWellKnownSID);

    if (status != ERROR_SUCCESS) 
    {
        DBGPRINTF(( DBG_CONTEXT,"[AddRightToUserAccount] GetPrincipalSID returned err=0x%0X\n",status));
        return (status);
    }


    status = OpenPolicy(NULL, POLICY_ALL_ACCESS,&PolicyHandle);
    if ( status == NERR_Success )
    {
		UINT i;
        LSA_UNICODE_STRING *rgUserRights = NULL;
		ULONG cRights;
	
		status = LsaAddAccountRights (
				 PolicyHandle,
				 pSID,
				 &UserRightString,
				 1);
    }

    if (PolicyHandle)
    {
        LsaClose(PolicyHandle);
    }
    if (pSID) 
    {
        if (bWellKnownSID)
        {
            FreeSid (pSID);
        }
        else
        {
            free (pSID);
        }
    }
    return status;
}



DWORD DoesUserHaveThisRight(LPCTSTR szAccountName, LPTSTR PrivilegeName,BOOL *fHaveThatRight)
{
    BOOL fEnabled = FALSE;
    NTSTATUS status;
	LSA_UNICODE_STRING UserRightString;
    LSA_HANDLE PolicyHandle = NULL;


    *fHaveThatRight = FALSE;

    // Create a LSA_UNICODE_STRING for the privilege name.
    InitLsaString(&UserRightString, PrivilegeName);

    // get the sid of szAccountName
    PSID pSID = NULL;
    BOOL bWellKnownSID = FALSE;

    status = GetPrincipalSID ((LPTSTR)szAccountName, &pSID, &bWellKnownSID);

    if (status != ERROR_SUCCESS) 
    {
        return status;
    }


    status = OpenPolicy(NULL, POLICY_ALL_ACCESS,&PolicyHandle);
    if ( status == NERR_Success )
    {
		UINT i;
        LSA_UNICODE_STRING *rgUserRights = NULL;
		ULONG cRights;
	
		status = LsaEnumerateAccountRights(
				 PolicyHandle,
				 pSID,
				 &rgUserRights,
				 &cRights);

		if (status==STATUS_OBJECT_NAME_NOT_FOUND)
        {
			// no rights/privileges for this account
            status = ERROR_SUCCESS;
			fEnabled = FALSE;
		}
		else if (!NT_SUCCESS(status)) 
        {
            //iisDebugOut((LOG_TYPE_ERROR, _T("DoesUserHaveBasicRights:GetPrincipalSID:Failed to enumerate rights: status 0x%08lx\n"), status));
			goto DoesUserHaveBasicRights_Exit;
		}

		for(i=0; i < cRights; i++) 
        {
            if ( RtlEqualUnicodeString(&rgUserRights[i],&UserRightString,FALSE) ) 
            {
                fEnabled = TRUE;
                break;
            }
		}
		
        if (rgUserRights) 
        {
            LsaFreeMemory(rgUserRights);
        }
    }

DoesUserHaveBasicRights_Exit:

    if (PolicyHandle)
    {
        LsaClose(PolicyHandle);
    }
    if (pSID) 
    {
        if (bWellKnownSID)
        {
            FreeSid (pSID);
        }
        else
        {
            free (pSID);
        }
    }

    *fHaveThatRight = fEnabled;
    return status;
}



DWORD
GetCurrentUserSID (
    PSID *Sid
    )
{
    DWORD dwReturn = ERROR_SUCCESS;
    TOKEN_USER  *tokenUser = NULL;
    HANDLE      tokenHandle = NULL;
    DWORD       tokenSize;
    DWORD       sidLength;

    if (OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &tokenHandle))
    {
        GetTokenInformation (tokenHandle, TokenUser, tokenUser, 0, &tokenSize);

        tokenUser = (TOKEN_USER *) malloc (tokenSize);
        if (!tokenUser)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return GetLastError();
        }

        if (GetTokenInformation (tokenHandle, TokenUser, tokenUser, tokenSize, &tokenSize))
        {
            sidLength = GetLengthSid (tokenUser->User.Sid);
            *Sid = (PSID) malloc (sidLength);
            if (*Sid)
            {
                memcpy (*Sid, tokenUser->User.Sid, sidLength);
            }
            CloseHandle (tokenHandle);
        } else
            dwReturn = GetLastError();

        if (tokenUser)
            free(tokenUser);

    } else
        dwReturn = GetLastError();

    return dwReturn;
}

DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    )
{
    PACL    dacl;
    DWORD   sidLength;
    PSID    sid = NULL;
    PSID    groupSID;
    PSID    ownerSID;
    DWORD   returnValue;

    *SD = NULL;

    returnValue = GetCurrentUserSID (&sid);
    if (returnValue != ERROR_SUCCESS) {
        if (sid)
            free(sid);
        return returnValue;
    }

    sidLength = GetLengthSid (sid);

    *SD = (SECURITY_DESCRIPTOR *) malloc (
        (sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength) +
        (2 * sidLength) +
        sizeof (SECURITY_DESCRIPTOR));
    if (!*SD)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return GetLastError();
    }

    groupSID = (SID *) (*SD + 1);
    ownerSID = (SID *) (((BYTE *) groupSID) + sidLength);
    dacl = (ACL *) (((BYTE *) ownerSID) + sidLength);

    if (!InitializeSecurityDescriptor (*SD, SECURITY_DESCRIPTOR_REVISION))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!InitializeAcl (dacl,
                        sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength,
                        ACL_REVISION2))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!AddAccessAllowedAce (dacl,
                              ACL_REVISION2,
                              COM_RIGHTS_EXECUTE,
                              sid))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!SetSecurityDescriptorDacl (*SD, TRUE, dacl, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    memcpy (groupSID, sid, sidLength);
    if (!SetSecurityDescriptorGroup (*SD, groupSID, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    memcpy (ownerSID, sid, sidLength);
    if (!SetSecurityDescriptorOwner (*SD, ownerSID, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (sid)
        free(sid);
    return ERROR_SUCCESS;
}

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD
    )
{
    DWORD               returnValue;
    HKEY                registryKey;
    DWORD               valueType;
    DWORD               valueSize = 0;

    *NewSD = FALSE;

    //
    // Get the security descriptor from the named value. If it doesn't
    // exist, create a fresh one.
    //

    returnValue = RegOpenKeyEx (RootKey, KeyName, 0, KEY_ALL_ACCESS, &registryKey);

    if (returnValue != ERROR_SUCCESS)
    {
        if (returnValue == ERROR_FILE_NOT_FOUND)
        {
            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) {
                if (*SD)
                    free(*SD);
                return returnValue;
            }

            *NewSD = TRUE;
            return ERROR_SUCCESS;
        } else
            return returnValue;
    }

    returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, NULL, &valueSize);

    if (returnValue && returnValue != ERROR_INSUFFICIENT_BUFFER)
    {
        *SD = NULL;
        returnValue = CreateNewSD (SD);
        if (returnValue != ERROR_SUCCESS) {
            if (*SD)
                free(*SD);
            return returnValue;
        }

        *NewSD = TRUE;
    } else
    {
        *SD = (SECURITY_DESCRIPTOR *) malloc (valueSize);
        if (!*SD)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return GetLastError();
        }

        returnValue = RegQueryValueEx (registryKey,
                                       ValueName,
                                       NULL,
                                       &valueType,
                                       (LPBYTE) *SD,
                                       &valueSize);
        if (returnValue)
        {
            if (*SD)
                free (*SD);

            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) {
                if (*SD)
                    free(*SD);
                return returnValue;
            }

            *NewSD = TRUE;
        }
    }

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
GetPrincipalSID (
    LPCTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    )
{

    DWORD returnValue=ERROR_SUCCESS;
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority;
    BYTE Count;
    DWORD dwRID[8];
    TCHAR pszPrincipal[MAX_PATH];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));

    DBG_ASSERT(wcslen(Principal) < MAX_PATH);
    wcscpy(pszPrincipal, Principal);
    _wcslwr(pszPrincipal);
    if ( wcsstr(pszPrincipal, TEXT("administrators")) != NULL ) {
        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;
    } else if ( wcsstr(pszPrincipal, TEXT("system")) != NULL) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;
    } else if ( wcsstr(pszPrincipal, TEXT("interactive")) != NULL) {
        // INTERACTIVE
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;
    } else if ( wcsstr(pszPrincipal, TEXT("everyone")) != NULL) {
        // Everyone
        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;
    } else {
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID) {
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority,
                                    (BYTE)Count,
                                            dwRID[0],
                                            dwRID[1],
                                            dwRID[2],
                                            dwRID[3],
                                            dwRID[4],
                                            dwRID[5],
                                            dwRID[6],
                                            dwRID[7],
                                    Sid) ) {
            returnValue = GetLastError();
        }
    } else {
        // get regular account sid
        DWORD        sidSize;
        TCHAR        refDomain [256];
        DWORD        refDomainSize;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountName (NULL,
                           pszPrincipal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();

        if (returnValue == ERROR_INSUFFICIENT_BUFFER) {
            *Sid = (PSID) malloc (sidSize);
            if (!*Sid)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return GetLastError();
            }
            refDomainSize = 255;

            if (!LookupAccountName (NULL,
                                    pszPrincipal,
                                    *Sid,
                                    &sidSize,
                                    refDomain,
                                    &refDomainSize,
                                    &snu))
            {
                returnValue = GetLastError();
            } else {
                returnValue = ERROR_SUCCESS;
            }
        }
    }

    return returnValue;
}

DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    LPVOID                ace;
    ACE_HEADER            *aceHeader;
    ULONG                 i;

    GetAclInformation (OldACL,
                       (LPVOID) &aclSizeInfo,
                       (DWORD) sizeof (aclSizeInfo),
                       AclSizeInformation);

    //
    // Copy all of the ACEs to the new ACL
    //

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        //
        // Get the ACE and header info
        //

        if (!GetAce (OldACL, i, &ace))
            return GetLastError();

        aceHeader = (ACE_HEADER *) ace;

        //
        // Add the ACE to the new list
        //

        if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
            return GetLastError();
    }

    return ERROR_SUCCESS;
}


DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID = NULL;
    PACL                  oldACL, newACL;
    BOOL                  bWellKnownSID = FALSE;

    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (oldACL,
                       (LPVOID) &aclSizeInfo,
                       (DWORD) sizeof (ACL_SIZE_INFORMATION),
                       AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if (!AddAccessAllowedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    *Acl = newACL;
	newACL = NULL;

cleanup:

	// BugFix: 57654 Whistler
	//         Prefix bug leaking memory in error condition.
	//         By setting the newACL to NULL above if we have
	//         relinquished the memory to *Acl, we avoid releasing
	//         memory we have passed back to the caller.
	//         EBK 5/5/2000		
	if (newACL)
	{
		delete [] newACL;
		newACL = NULL;
	}

    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION    aclSizeInfo;
    ULONG                   i;
    LPVOID                  ace;
    ACCESS_ALLOWED_ACE      *accessAllowedAce;
    ACCESS_DENIED_ACE       *accessDeniedAce;
    SYSTEM_AUDIT_ACE        *systemAuditAce;
    PSID                    principalSID = NULL;
    DWORD                   returnValue = ERROR_SUCCESS;
    ACE_HEADER              *aceHeader;
    BOOL                    bWellKnownSID = FALSE;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (Acl,
                       (LPVOID) &aclSizeInfo,
                       (DWORD) sizeof (ACL_SIZE_INFORMATION),
                       AclSizeInformation);

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce (Acl, i, &ace))
        {
            returnValue = GetLastError();
            break;
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        } else

        if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessDeniedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        } else

        if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &systemAuditAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        }
    }

    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    )
{
    PSECURITY_DESCRIPTOR  sd = NULL;
    DWORD                 descriptorSize;
    DWORD                 daclSize;
    DWORD                 saclSize;
    DWORD                 ownerSIDSize;
    DWORD                 groupSIDSize;
    PACL                  dacl = NULL;
    PACL                  sacl = NULL;
    PSID                  ownerSID = NULL;
    PSID                  groupSID = NULL;
    BOOL                  present;
    BOOL                  systemDefault;

    //
    // Get SACL
    //

    if (!GetSecurityDescriptorSacl (OldSD, &present, &sacl, &systemDefault))
        return GetLastError();

    if (sacl && present)
    {
        saclSize = sacl->AclSize;
    } else saclSize = 0;

    //
    // Get DACL
    //

    if (!GetSecurityDescriptorDacl (OldSD, &present, &dacl, &systemDefault))
        return GetLastError();

    if (dacl && present)
    {
        daclSize = dacl->AclSize;
    } else daclSize = 0;

    //
    // Get Owner
    //

    if (!GetSecurityDescriptorOwner (OldSD, &ownerSID, &systemDefault))
        return GetLastError();

    ownerSIDSize = GetLengthSid (ownerSID);

    //
    // Get Group
    //

    if (!GetSecurityDescriptorGroup (OldSD, &groupSID, &systemDefault))
        return GetLastError();

    groupSIDSize = GetLengthSid (groupSID);

    //
    // Do the conversion
    //

    descriptorSize = 0;

    MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                    &saclSize, ownerSID, &ownerSIDSize, groupSID,
                    &groupSIDSize);

    sd = (PSECURITY_DESCRIPTOR) new BYTE [SECURITY_DESCRIPTOR_MIN_LENGTH];
    if (!sd)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return GetLastError();
    }
    if (!InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION))
        return GetLastError();

    if (!MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                         &saclSize, ownerSID, &ownerSIDSize, groupSID,
                         &groupSIDSize))
        return GetLastError();

    *NewSD = sd;
    return ERROR_SUCCESS;
}

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    )
{
    DWORD   returnValue;
    DWORD   disposition;
    HKEY    registryKey;

    //
    // Create new key or open existing key
    //

    returnValue = RegCreateKeyEx (RootKey,
                                  KeyName,
                                  0,
                                  TEXT(""),
                                  0,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &registryKey,
                                  &disposition);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    //
    // Write the security descriptor
    //

    returnValue = RegSetValueEx (registryKey,
                                 ValueName,
                                 0,
                                 REG_BINARY,
                                 (LPBYTE) SD,
                                 GetSecurityDescriptorLength (SD));
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}


DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl = NULL;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;

    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // If the security descriptor is new, add the required Principals to it
    //

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("INTERACTIVE"));
    }

    //
    // Remove the Principal that the caller wants removed
    //

    returnValue = RemovePrincipalFromACL (dacl, Principal);
    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute);
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!sdSelfRelative)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        goto Cleanup;
    }

    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute)
        free (sdAbsolute);

    return returnValue;
}

DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID = NULL;
    PACL                  oldACL, newACL;
    BOOL                  bWellKnownSID = FALSE;
    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (oldACL,
                       (LPVOID) &aclSizeInfo,
                       (DWORD) sizeof (ACL_SIZE_INFORMATION),
                       AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_DENIED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    if (!AddAccessDeniedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    *Acl = newACL;
	newACL = NULL;

cleanup:

	// BugFix: 57654 Whistler
	//         Prefix bug leaking memory in error condition.
	//         By setting the newACL to NULL above if we have
	//         relinquished the memory to *Acl, we avoid releasing
	//         memory we have passed back to the caller.
	//         EBK 5/5/2000		
	if (newACL)
	{
		delete[] newACL;
		newACL = NULL;
	}

    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;


    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("INTERACTIVE"));
    }

    //
    // Add the Principal that the caller wants added
    //

    if (Permit)
        returnValue = AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, Principal);
    else
        returnValue = AddAccessDeniedACEToACL (&dacl, GENERIC_ALL, Principal);

    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute);
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!sdSelfRelative)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        goto Cleanup;
    }


    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute)
        free (sdAbsolute);

    return returnValue;
}


DWORD
ChangeDCOMAccessACL (
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{

    DWORD   err;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE,
                                               TEXT("Software\\Microsoft\\OLE"),
                                               TEXT("DefaultAccessPermission"),
                                               Principal);
        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE,
                                          TEXT("Software\\Microsoft\\OLE"),
                                          TEXT("DefaultAccessPermission"),
                                          Principal,
                                          Permit);
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE,
                                               TEXT("Software\\Microsoft\\OLE"),
                                               TEXT("DefaultAccessPermission"),
                                               Principal);
    }
    return err;
}

DWORD
ChangeDCOMLaunchACL (
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{

    TCHAR   keyName [256] = TEXT("Software\\Microsoft\\OLE");
    DWORD   err;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE,
                                               keyName,
                                               TEXT("DefaultLaunchPermission"),
                                               Principal);
        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE,
                                          keyName,
                                          TEXT("DefaultLaunchPermission"),
                                          Principal,
                                          Permit);
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE,
                                               keyName,
                                               TEXT("DefaultLaunchPermission"),
                                               Principal);
    }
    return err;
}



GUFM_RETURN GetUserFromMetabase(IMDCOM *pcCom,
                                LPWSTR pszPath,
                                DWORD dwUserMetaId,
                                DWORD dwPasswordMetaId,
                                USERNAME_STRING_TYPE ustUserBuf,
                                PASSWORD_STRING_TYPE pstPasswordBuf)
{

    HRESULT hresTemp;
    GUFM_RETURN  gufmReturn = GUFM_SUCCESS;
    METADATA_RECORD mdrData;
    DWORD dwRequiredDataLen;

    METADATA_HANDLE mhOpenHandle;


    hresTemp = pcCom->ComMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE,
                                            pszPath,
                                            METADATA_PERMISSION_READ,
                                            OPEN_TIMEOUT_VALUE,
                                            &mhOpenHandle);
    if (FAILED(hresTemp)) {
        gufmReturn = GUFM_NO_PATH;
    }
    else {
        MD_SET_DATA_RECORD_EXT(&mdrData,
                               dwUserMetaId,
                               METADATA_NO_ATTRIBUTES,
                               ALL_METADATA,
                               STRING_METADATA,
                               MAX_PATH * sizeof(TCHAR),
                               (PBYTE)ustUserBuf)

        hresTemp = pcCom->ComMDGetMetaData(mhOpenHandle,
                                           NULL,
                                           &mdrData,
                                           &dwRequiredDataLen);

        if (FAILED(hresTemp) || (ustUserBuf[0] == (TCHAR)'\0')) {
            gufmReturn = GUFM_NO_USER_ID;
        }
        else {

            MD_SET_DATA_RECORD_EXT(&mdrData,
                                   dwPasswordMetaId,
                                   METADATA_NO_ATTRIBUTES,
                                   ALL_METADATA,
                                   STRING_METADATA,
                                   MAX_PATH * sizeof(TCHAR),
                                   (PBYTE)pstPasswordBuf)

            hresTemp = pcCom->ComMDGetMetaData(mhOpenHandle,
                                               NULL,
                                               &mdrData,
                                               &dwRequiredDataLen);
            if (FAILED(hresTemp)) {
                gufmReturn = GUFM_NO_PASSWORD;
            }
        }
        pcCom->ComMDCloseMetaObject(mhOpenHandle);
    }

    return gufmReturn;
}

BOOL WritePasswordToMetabase(IMDCOM *pcCom,
                             LPWSTR pszPath,
                             DWORD dwPasswordMetaId,
                             PASSWORD_STRING_TYPE pstPasswordBuf)
{

    HRESULT hresReturn;
    BOOL fReturn = FALSE;
    METADATA_RECORD mdrData;

    METADATA_HANDLE mhOpenHandle;


    hresReturn = pcCom->ComMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE,
                                            pszPath,
                                            METADATA_PERMISSION_WRITE,
                                            OPEN_TIMEOUT_VALUE,
                                            &mhOpenHandle);
    if (SUCCEEDED(hresReturn)) {
        MD_SET_DATA_RECORD_EXT(&mdrData,
                               dwPasswordMetaId,
                               METADATA_INHERIT | METADATA_SECURE,
                               IIS_MD_UT_FILE,
                               STRING_METADATA,
                               sizeof(pstPasswordBuf),
                               (PBYTE)pstPasswordBuf)

        hresReturn = pcCom->ComMDSetMetaData(mhOpenHandle,
                                             NULL,
                                             &mdrData);

        pcCom->ComMDCloseMetaObject(mhOpenHandle);
    }

    return SUCCEEDED(hresReturn);
}

BOOL DoesUserExist( LPWSTR strUsername, BOOL *fDisabled )
{
    BYTE *pBuffer;
    INT err = NERR_Success;
    BOOL fReturn = FALSE;

    *fDisabled = FALSE;

    err = NetUserGetInfo( NULL, strUsername, 3, &pBuffer );

    if ( err == NERR_Success )
    {
        *fDisabled = !!(((PUSER_INFO_3)pBuffer)->usri3_flags  & UF_ACCOUNTDISABLE);
        NetApiBufferFree( pBuffer );
        fReturn = TRUE;
    }

    return( fReturn );
}


NET_API_STATUS
NetpNtStatusToApiStatus (
    IN NTSTATUS NtStatus
    )

/*++

Routine Description:

    This function takes an NT status code and maps it to the appropriate
    LAN Man error code.

Arguments:

    NtStatus - Supplies the NT status.

Return Value:

    Returns the appropriate LAN Man error code for the NT status.

--*/
{
    NET_API_STATUS error;

    //
    // A small optimization for the most common case.
    //
    if ( NtStatus == STATUS_SUCCESS ) {
        return NERR_Success;
    }


    switch ( NtStatus ) {

        case STATUS_BUFFER_TOO_SMALL :
            return NERR_BufTooSmall;

        case STATUS_FILES_OPEN :
            return NERR_OpenFiles;

        case STATUS_CONNECTION_IN_USE :
            return NERR_DevInUse;

        case STATUS_INVALID_LOGON_HOURS :
            return NERR_InvalidLogonHours;

        case STATUS_INVALID_WORKSTATION :
            return NERR_InvalidWorkstation;

        case STATUS_PASSWORD_EXPIRED :
            return NERR_PasswordExpired;

        case STATUS_ACCOUNT_EXPIRED :
            return NERR_AccountExpired;

        case STATUS_REDIRECTOR_NOT_STARTED :
            return NERR_NetNotStarted;

        case STATUS_GROUP_EXISTS:
                return NERR_GroupExists;

        case STATUS_INTERNAL_DB_CORRUPTION:
                return NERR_InvalidDatabase;

        case STATUS_INVALID_ACCOUNT_NAME:
                return NERR_BadUsername;

        case STATUS_INVALID_DOMAIN_ROLE:
        case STATUS_INVALID_SERVER_STATE:
        case STATUS_BACKUP_CONTROLLER:
                return NERR_NotPrimary;

        case STATUS_INVALID_DOMAIN_STATE:
                return NERR_ACFNotLoaded;

        case STATUS_MEMBER_IN_GROUP:
                return NERR_UserInGroup;

        case STATUS_MEMBER_NOT_IN_GROUP:
                return NERR_UserNotInGroup;

        case STATUS_NONE_MAPPED:
        case STATUS_NO_SUCH_GROUP:
                return NERR_GroupNotFound;

        case STATUS_SPECIAL_GROUP:
        case STATUS_MEMBERS_PRIMARY_GROUP:
                return NERR_SpeGroupOp;

        case STATUS_USER_EXISTS:
                return NERR_UserExists;

        case STATUS_NO_SUCH_USER:
                return NERR_UserNotFound;

        case STATUS_PRIVILEGE_NOT_HELD:
                return ERROR_ACCESS_DENIED;

        case STATUS_LOGON_SERVER_CONFLICT:
                return NERR_LogonServerConflict;

        case STATUS_TIME_DIFFERENCE_AT_DC:
                return NERR_TimeDiffAtDC;

        case STATUS_SYNCHRONIZATION_REQUIRED:
                return NERR_SyncRequired;

        case STATUS_WRONG_PASSWORD_CORE:
                return NERR_BadPasswordCore;

        case STATUS_DOMAIN_CONTROLLER_NOT_FOUND:
                return NERR_DCNotFound;

        case STATUS_PASSWORD_RESTRICTION:
                return NERR_PasswordTooShort;

        case STATUS_ALREADY_DISCONNECTED:
                return NERR_Success;

        default:

            //
            // Use the system routine to do the mapping to ERROR_ codes.
            //

#ifndef WIN32_CHICAGO 
            error = RtlNtStatusToDosError( NtStatus );

            if ( error != (NET_API_STATUS)NtStatus ) {
                return error;
            }
#endif // WIN32_CHICAGO

            //
            // Could not map the NT status to anything appropriate.
            //

            return NERR_InternalError;
    }
} // NetpNtStatusToApiStatus


NET_API_STATUS
UaspGetDomainId(
    IN LPCWSTR ServerName OPTIONAL,
    OUT PSAM_HANDLE SamServerHandle OPTIONAL,
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO * AccountDomainInfo
    )
/*++
Routine Description:
    Return a domain ID of the account domain of a server.
Arguments:
    ServerName - A pointer to a string containing the name of the
        Domain Controller (DC) to query.  A NULL pointer
        or string specifies the local machine.
    SamServerHandle - Returns the SAM connection handle if the caller wants it.
    DomainId - Receives a pointer to the domain ID.
        Caller must deallocate buffer using NetpMemoryFree.
Return Value:
    Error code for the operation.
--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    SAM_HANDLE LocalSamHandle = NULL;

    ACCESS_MASK LSADesiredAccess;
    LSA_HANDLE  LSAPolicyHandle = NULL;
    OBJECT_ATTRIBUTES LSAObjectAttributes;

    UNICODE_STRING ServerNameString;


    //
    // Connect to the SAM server
    //
    RtlInitUnicodeString( &ServerNameString, ServerName );

    Status = SamConnect(
                &ServerNameString,
                &LocalSamHandle,
                SAM_SERVER_LOOKUP_DOMAIN,
                NULL);

    if ( !NT_SUCCESS(Status))
    {
        LocalSamHandle = NULL;
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }


    //
    // Open LSA to read account domain info.
    //

    if ( AccountDomainInfo != NULL) {
        //
        // set desired access mask.
        //
        LSADesiredAccess = POLICY_VIEW_LOCAL_INFORMATION;

        InitializeObjectAttributes( &LSAObjectAttributes,
                                      NULL,             // Name
                                      0,                // Attributes
                                      NULL,             // Root
                                      NULL );           // Security Descriptor

        Status = LsaOpenPolicy( &ServerNameString,
                                &LSAObjectAttributes,
                                LSADesiredAccess,
                                &LSAPolicyHandle );

        if( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }


        //
        // now read account domain info from LSA.
        //

        Status = LsaQueryInformationPolicy(
                        LSAPolicyHandle,
                        PolicyAccountDomainInformation,
                        (PVOID *) AccountDomainInfo );

        if( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }
    }

    //
    // Return the SAM connection handle to the caller if he wants it.
    // Otherwise, disconnect from SAM.
    //

    if ( ARGUMENT_PRESENT( SamServerHandle ) ) {
        *SamServerHandle = LocalSamHandle;
        LocalSamHandle = NULL;
    }

    NetStatus = NERR_Success;

    //
    // Cleanup locally used resources
    //
Cleanup:
    if ( LocalSamHandle != NULL ) {
        (VOID) SamCloseHandle( LocalSamHandle );
    }

    if( LSAPolicyHandle != NULL ) {
        LsaClose( LSAPolicyHandle );
    }

    return NetStatus;
} // UaspGetDomainId


NET_API_STATUS
SampCreateFullSid(
    IN PSID DomainSid,
    IN ULONG Rid,
    OUT PSID *AccountSid
    )
/*++
Routine Description:
    This function creates a domain account sid given a domain sid and
    the relative id of the account within the domain.
    The returned Sid may be freed with LocalFree.
--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS    IgnoreStatus;
    UCHAR       AccountSubAuthorityCount;
    ULONG       AccountSidLength;
    PULONG      RidLocation;

    //
    // Calculate the size of the new sid
    //
    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(DomainSid) + (UCHAR)1;
    AccountSidLength = RtlLengthRequiredSid(AccountSubAuthorityCount);

    //
    // Allocate space for the account sid
    //
    *AccountSid = LocalAlloc(LMEM_ZEROINIT,AccountSidLength);
    if (*AccountSid == NULL)
    {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        //
        // Copy the domain sid into the first part of the account sid
        //
        IgnoreStatus = RtlCopySid(AccountSidLength, *AccountSid, DomainSid);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Increment the account sid sub-authority count
        //
        *RtlSubAuthorityCountSid(*AccountSid) = AccountSubAuthorityCount;

        //
        // Add the rid as the final sub-authority
        //
        RidLocation = RtlSubAuthoritySid(*AccountSid, AccountSubAuthorityCount-1);
        *RidLocation = Rid;

        NetStatus = NERR_Success;
    }

    return(NetStatus);
}



int GetGuestUserNameForDomain_FastWay(LPTSTR szDomainToLookUp,LPTSTR lpGuestUsrName)
{
    int iReturn = FALSE;
    NET_API_STATUS NetStatus;

    // for UaspGetDomainId()
    SAM_HANDLE SamServerHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO pAccountDomainInfo = NULL;

    PSID pAccountSid = NULL;
    PSID pDomainSid = NULL;

    // for LookupAccountSid()
    SID_NAME_USE sidNameUse = SidTypeUser;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    TCHAR szUserName[UNLEN+1];
    DWORD cbName = UNLEN+1;
    // use UNLEN because DNLEN is too small
    TCHAR szReferencedDomainName[UNLEN+1];
    DWORD cbReferencedDomainName = sizeof(szReferencedDomainName);

    // make sure not to return back gobble-d-gook
    wcscpy(lpGuestUsrName, TEXT(""));

    //
    // Get the Sid for the specified Domain
    //
    // szDomainToLookUp=NULL for local machine
    NetStatus = UaspGetDomainId( szDomainToLookUp,&SamServerHandle,&pAccountDomainInfo );
    if ( NetStatus != NERR_Success )
    {
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }
    pDomainSid = pAccountDomainInfo->DomainSid;
    //
    // Use the Domain Sid and the well known Guest RID to create the Real Guest Sid
    //
    // Well-known users ...
    // DOMAIN_USER_RID_ADMIN          (0x000001F4L)
    // DOMAIN_USER_RID_GUEST          (0x000001F5L)
    NetStatus = NERR_InternalError;
    NetStatus = SampCreateFullSid(pDomainSid, DOMAIN_USER_RID_GUEST, &pAccountSid);
    if ( NetStatus != NERR_Success )
    {
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }

    //
    // Check if the SID is valid
    //
    if (0 == IsValidSid(pAccountSid))
    {
        DWORD dwErr = GetLastError();
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }

    //
    // Retrieve the UserName for the specified SID
    //
    wcscpy(szUserName, TEXT(""));
    wcscpy(szReferencedDomainName, TEXT(""));
    // szDomainToLookUp=NULL for local machine
    if (!LookupAccountSid(szDomainToLookUp,
                          pAccountSid,
                          szUserName,
                          &cbName,
                          szReferencedDomainName,
                          &cbReferencedDomainName,
                          &sidNameUse))
    {
        DWORD dwErr = GetLastError();
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }


    // Return the guest user name that we got.
    wcscpy(lpGuestUsrName, szUserName);

    // Wow, after all that, we must have succeeded
    iReturn = TRUE;

GetGuestUserNameForDomain_FastWay_Exit:
    // Free the Domain info if we got some
    if (pAccountDomainInfo) {NetpMemoryFree(pAccountDomainInfo);}
    // Free the sid if we had allocated one
    if (pAccountSid) {LocalFree(pAccountSid);}
    return iReturn;
}

int GetGuestUserName_SlowWay(LPWSTR lpGuestUsrName)
{

    LPWSTR ServerName = NULL; // default to local machine
    DWORD Level = 1; // to retrieve info of all local and global normal user accounts
    DWORD Index = 0;
    DWORD EntriesRequested = 5;
    DWORD PreferredMaxLength = 1024;
    DWORD ReturnedEntryCount = 0;
    PVOID SortedBuffer = NULL;
    NET_DISPLAY_USER *p = NULL;
    DWORD i=0;
    int err = 0;
    BOOL fStatus = TRUE;

    while (fStatus)
    {
        err = NetQueryDisplayInformation(ServerName,
                                         Level,
                                         Index,
                                         EntriesRequested,
                                         PreferredMaxLength,
                                         &ReturnedEntryCount,
                                         &SortedBuffer);
        if (err == NERR_Success)
            fStatus = FALSE;
        if (err == NERR_Success || err == ERROR_MORE_DATA)
        {
            p = (NET_DISPLAY_USER *)SortedBuffer;
            i = 0;
            while (i < ReturnedEntryCount && (p[i].usri1_user_id != DOMAIN_USER_RID_GUEST))
                i++;
            if (i == ReturnedEntryCount)
            {
                if (err == ERROR_MORE_DATA)
                { // need to get more entries
                    Index = p[i-1].usri1_next_index;
                }
            }
            else
            {
                wcscpy(lpGuestUsrName, p[i].usri1_name);
                fStatus = FALSE;
            }
        }
        NetApiBufferFree(SortedBuffer);
    }

    return 0;
}

void GetGuestUserName(LPTSTR lpOutGuestUsrName)
{
    // try to retrieve the guest username the fast way
    // meaning = lookup the domain sid, and the well known guest rid, to get the guest sid.
    // then look it up.  The reason for this function is that on large domains with mega users
    // the account can be quickly looked up.
    TCHAR szGuestUsrName[UNLEN+1];
    LPTSTR pszComputerName = NULL;
    if (!GetGuestUserNameForDomain_FastWay(pszComputerName,szGuestUsrName))
    {

        // if the fast way failed for some reason, then let's do it
        // the slow way, since this way always used to work, only on large domains (1 mil users)
        // it could take 24hrs (since this function actually enumerates thru the domain)
        GetGuestUserName_SlowWay(szGuestUsrName);
    }

    // Return back the username
    wcscpy(lpOutGuestUsrName,szGuestUsrName);
    return;
}

int GetGuestGrpName(LPTSTR lpGuestGrpName)
{
    LPCTSTR ServerName = NULL; // local machine
    // use UNLEN because DNLEN is too small
    DWORD cbName = UNLEN+1;
    TCHAR ReferencedDomainName[UNLEN+1];
    DWORD cbReferencedDomainName = sizeof(ReferencedDomainName);
    SID_NAME_USE sidNameUse = SidTypeUser;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID GuestsSid = NULL;

    AllocateAndInitializeSid(&NtAuthority,
                             2,
                             SECURITY_BUILTIN_DOMAIN_RID,
                             DOMAIN_ALIAS_RID_GUESTS,
                             0,
                             0,
                             0,
                             0,
                             0,
                             0,
                             &GuestsSid);

    LookupAccountSid(ServerName,
                     GuestsSid,
                     lpGuestGrpName,
                     &cbName,
                     ReferencedDomainName,
                     &cbReferencedDomainName,
                     &sidNameUse);

    if (GuestsSid)
        FreeSid(GuestsSid);

    return 0;
}

INT RegisterAccountToLocalGroup(LPCTSTR szAccountName,
                                LPCTSTR szLocalGroupName,
                                BOOL fAction)
{
    int err;

    // get the sid of szAccountName
    PSID pSID = NULL;
    BOOL bWellKnownSID = FALSE;
    err = GetPrincipalSID ((LPTSTR)szAccountName, &pSID, &bWellKnownSID);
    if (err != ERROR_SUCCESS)
    {
        return (err);
    }

    // Get the localized LocalGroupName
    TCHAR szLocalizedLocalGroupName[GNLEN + 1];
    if (_wcsicmp(szLocalGroupName, TEXT("Guests")) == 0)
    {
        GetGuestGrpName(szLocalizedLocalGroupName);
    }
    else
    {
        wcscpy(szLocalizedLocalGroupName, szLocalGroupName);
    }

    // transfer szLocalGroupName to WCHAR
    WCHAR wszLocalGroupName[_MAX_PATH];
    wcscpy(wszLocalGroupName, szLocalizedLocalGroupName);

    LOCALGROUP_MEMBERS_INFO_0 buf;

    buf.lgrmi0_sid = pSID;

    if (fAction)
    {
        err = NetLocalGroupAddMembers(NULL, wszLocalGroupName, 0, (LPBYTE)&buf, 1);
    }
    else
    {
        err = NetLocalGroupDelMembers(NULL, wszLocalGroupName, 0, (LPBYTE)&buf, 1);
    }

    if (pSID)
    {
        if (bWellKnownSID)
            FreeSid (pSID);
        else
            free (pSID);
    }

    return (err);
}

void InitLsaString(PLSA_UNICODE_STRING LsaString,LPWSTR String)
{
    DWORD StringLength;

    if (String == NULL)
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = wcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}

DWORD OpenPolicy(LPTSTR ServerName,DWORD DesiredAccess,PLSA_HANDLE PolicyHandle)
{
    DWORD Error;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server = NULL;
    SECURITY_QUALITY_OF_SERVICE QualityOfService;

    QualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    QualityOfService.ImpersonationLevel = SecurityImpersonation;
    QualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    QualityOfService.EffectiveOnly = FALSE;

    //
    // The two fields that must be set are length and the quality of service.
    //
    ObjectAttributes.Length = sizeof(LSA_OBJECT_ATTRIBUTES);
    ObjectAttributes.RootDirectory = NULL;
    ObjectAttributes.ObjectName = NULL;
    ObjectAttributes.Attributes = 0;
    ObjectAttributes.SecurityDescriptor = NULL;
    ObjectAttributes.SecurityQualityOfService = &QualityOfService;

    if (ServerName != NULL)
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString,ServerName);
        Server = &ServerString;
    }
    //
    // Attempt to open the policy for all access
    //
    Error = LsaOpenPolicy(Server,&ObjectAttributes,DesiredAccess,PolicyHandle);
    return(Error);

}


INT RegisterAccountUserRights(LPCTSTR szAccountName, BOOL fAction, BOOL fSpecicaliWamAccount)
{
    int err;

    // get the sid of szAccountName
    PSID pSID = NULL;
    BOOL bWellKnownSID = FALSE;
    err = GetPrincipalSID ((LPTSTR)szAccountName, &pSID, &bWellKnownSID);
    if (err != ERROR_SUCCESS)
    {
        return (err);
    }

    LSA_UNICODE_STRING UserRightString;
    LSA_HANDLE PolicyHandle = NULL;

    err = OpenPolicy(NULL, POLICY_ALL_ACCESS,&PolicyHandle);
    if ( err == NERR_Success )
    {
        if (fAction) 
        {
// defined in ntsecapi.h and ntlsa.h
//#define SE_INTERACTIVE_LOGON_NAME       TEXT("SeInteractiveLogonRight")
//#define SE_NETWORK_LOGON_NAME           TEXT("SeNetworkLogonRight")
//#define SE_BATCH_LOGON_NAME             TEXT("SeBatchLogonRight")
//#define SE_SERVICE_LOGON_NAME           TEXT("SeServiceLogonRight")
// Defined in winnt.h
//#define SE_CREATE_TOKEN_NAME              TEXT("SeCreateTokenPrivilege")
//#define SE_ASSIGNPRIMARYTOKEN_NAME        TEXT("SeAssignPrimaryTokenPrivilege")
//#define SE_LOCK_MEMORY_NAME               TEXT("SeLockMemoryPrivilege")
//#define SE_INCREASE_QUOTA_NAME            TEXT("SeIncreaseQuotaPrivilege")
//#define SE_UNSOLICITED_INPUT_NAME         TEXT("SeUnsolicitedInputPrivilege")
//#define SE_MACHINE_ACCOUNT_NAME           TEXT("SeMachineAccountPrivilege")
//#define SE_TCB_NAME                       TEXT("SeTcbPrivilege")
//#define SE_SECURITY_NAME                  TEXT("SeSecurityPrivilege")
//#define SE_TAKE_OWNERSHIP_NAME            TEXT("SeTakeOwnershipPrivilege")
//#define SE_LOAD_DRIVER_NAME               TEXT("SeLoadDriverPrivilege")
//#define SE_SYSTEM_PROFILE_NAME            TEXT("SeSystemProfilePrivilege")
//#define SE_SYSTEMTIME_NAME                TEXT("SeSystemtimePrivilege")
//#define SE_PROF_SINGLE_PROCESS_NAME       TEXT("SeProfileSingleProcessPrivilege")
//#define SE_INC_BASE_PRIORITY_NAME         TEXT("SeIncreaseBasePriorityPrivilege")
//#define SE_CREATE_PAGEFILE_NAME           TEXT("SeCreatePagefilePrivilege")
//#define SE_CREATE_PERMANENT_NAME          TEXT("SeCreatePermanentPrivilege")
//#define SE_BACKUP_NAME                    TEXT("SeBackupPrivilege")
//#define SE_RESTORE_NAME                   TEXT("SeRestorePrivilege")
//#define SE_SHUTDOWN_NAME                  TEXT("SeShutdownPrivilege")
//#define SE_DEBUG_NAME                     TEXT("SeDebugPrivilege")
//#define SE_AUDIT_NAME                     TEXT("SeAuditPrivilege")
//#define SE_SYSTEM_ENVIRONMENT_NAME        TEXT("SeSystemEnvironmentPrivilege")
//#define SE_CHANGE_NOTIFY_NAME             TEXT("SeChangeNotifyPrivilege")
//#define SE_REMOTE_SHUTDOWN_NAME           TEXT("SeRemoteShutdownPrivilege")
//#define SE_UNDOCK_NAME                    TEXT("SeUndockPrivilege")
//#define SE_SYNC_AGENT_NAME                TEXT("SeSyncAgentPrivilege")
//#define SE_ENABLE_DELEGATION_NAME         TEXT("SeEnableDelegationPrivilege")
            if (fSpecicaliWamAccount)
            {
                // no interactive logon for iwam!
                InitLsaString(&UserRightString, SE_NETWORK_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                InitLsaString(&UserRightString, SE_BATCH_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
            }
            else
            {
                InitLsaString(&UserRightString, SE_INTERACTIVE_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                InitLsaString(&UserRightString, SE_NETWORK_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                InitLsaString(&UserRightString, SE_BATCH_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
            }
        }
        else 
        {
            InitLsaString(&UserRightString, SE_INTERACTIVE_LOGON_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_NETWORK_LOGON_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_BATCH_LOGON_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
        }

        LsaClose(PolicyHandle);
    }

    if (pSID)
    {
        if (bWellKnownSID)
            FreeSid (pSID);
        else
            free (pSID);
    }

    return (err);
}


int ChangeUserPassword(IN LPTSTR szUserName, IN LPTSTR szNewPassword)
{
    int iReturn = TRUE;
    USER_INFO_1003  pi1003; 
    NET_API_STATUS  nas; 

    TCHAR szRawComputerName[CNLEN + 10];
    DWORD dwLen = CNLEN + 10;
    TCHAR szComputerName[CNLEN + 10];
    TCHAR szCopyOfUserName[UNLEN+10];
    TCHAR szTempFullUserName[(CNLEN + 10) + (UNLEN+1)];
    LPTSTR pch = NULL;

    wcscpy(szCopyOfUserName, szUserName);

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeUserPassword().Start.name=%s,pass=%s"),szCopyOfUserName,szNewPassword));

    if ( !GetComputerName( szRawComputerName, &dwLen ))
        {goto ChangeUserPassword_Exit;}

    // Make a copy to be sure not to move the pointer around.
    wcscpy(szTempFullUserName, szCopyOfUserName);
    // Check if there is a "\" in there.
    pch = wcschr(szTempFullUserName, '\\');
    if (pch) 
        {
            // szCopyOfUserName should now go from something like this:
            // mycomputer\myuser
            // to this myuser
            wcscpy(szCopyOfUserName,pch+1);
            // trim off the '\' character to leave just the domain\computername so we can check against it.
            *pch = '\0';
            // compare the szTempFullUserName with the local computername.
            if (0 == _wcsicmp(szRawComputerName, szTempFullUserName))
            {
                // the computername\username has a hardcoded computername in it.
                // lets try to get only the username
                // look szCopyOfusername is already set
            }
            else
            {
                // the local computer machine name
                // and the specified username are different, so get out
                // and don't even try to change this user\password since
                // it's probably a domain\username

                // return true -- saying that we did in fact change the passoword.
                // we really didn't but we can't
                iReturn = TRUE;
                goto ChangeUserPassword_Exit;
            }
        }

    // Make sure the computername has a \\ in front of it
    if ( szRawComputerName[0] != '\\' )
        {wcscpy(szComputerName,L"\\\\");}
    wcscat(szComputerName,szRawComputerName);
    // 
    // administrative over-ride of existing password 
    // 
    // by this time szCopyOfUserName
    // should not look like mycomputername\username but it should look like username.
    pi1003.usri1003_password = szNewPassword;
     nas = NetUserSetInfo(
            szComputerName,   // computer name 
            szCopyOfUserName, // username 
            1003,             // info level 
            (LPBYTE)&pi1003,  // new info 
            NULL 
            ); 

    if(nas != NERR_Success) 
    {
        iReturn = FALSE;
        goto ChangeUserPassword_Exit;
    }

ChangeUserPassword_Exit:
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeUserPassword().End.Ret=%d"),iReturn));
    return iReturn; 
} 


//
// Create InternetGuest Account
//
BOOL CreateUser( LPCTSTR szUsername,
                LPCTSTR szPassword,
                LPCTSTR szComment,
                LPCTSTR szFullName,
                BOOL fSpecialiWamAccount
                )
{

    INT err = NERR_Success;

    BYTE *pBuffer;
    WCHAR defGuest[UNLEN+1];
    TCHAR defGuestGroup[GNLEN+1];
    WCHAR wchGuestGroup[GNLEN+1];
    WCHAR wchUsername[UNLEN+1];
    WCHAR wchPassword[LM20_PWLEN+1];

    GetGuestUserName(defGuest);

    GetGuestGrpName(defGuestGroup);

    memset((PVOID)wchUsername, 0, sizeof(wchUsername));
    memset((PVOID)wchPassword, 0, sizeof(wchPassword));
    wcsncpy(wchGuestGroup, defGuestGroup, GNLEN);
    wcsncpy(wchUsername, szUsername, UNLEN);
    wcsncpy(wchPassword, szPassword, LM20_PWLEN);

    err = NetUserGetInfo( NULL, defGuest, 3, &pBuffer );

    if ( err == NERR_Success )
    {
        do
        {
            WCHAR wchComment[MAXCOMMENTSZ+1];
            WCHAR wchFullName[UNLEN+1];

            memset((PVOID)wchComment, 0, sizeof(wchComment));
            memset((PVOID)wchFullName, 0, sizeof(wchFullName));
            wcsncpy(wchComment, szComment, MAXCOMMENTSZ);
            wcsncpy(wchFullName, szFullName, UNLEN);

            USER_INFO_3 *lpui3 = (USER_INFO_3 *)pBuffer;

            lpui3->usri3_name = wchUsername;
            lpui3->usri3_password = wchPassword;
            lpui3->usri3_flags &= ~ UF_ACCOUNTDISABLE;
            lpui3->usri3_flags |= UF_DONT_EXPIRE_PASSWD;
            lpui3->usri3_acct_expires = TIMEQ_FOREVER;

            lpui3->usri3_comment = wchComment;
            lpui3->usri3_usr_comment = wchComment;
            lpui3->usri3_full_name = wchFullName;
            lpui3->usri3_primary_group_id = DOMAIN_GROUP_RID_USERS;

            DWORD parm_err;

            err = NetUserAdd( NULL, 3, pBuffer, &parm_err );

            if ( err != NERR_Success )
            {
              if ( err == NERR_UserExists )
              {
                  // see if we can just change the password.
                  if (TRUE == ChangeUserPassword((LPTSTR) szUsername, (LPTSTR) szPassword))
                     {err = NERR_Success;}
              }
              else
              {
                break;
              }
            }


        } while (FALSE);

        NetApiBufferFree( pBuffer );
    }
    if ( err == NERR_Success )
    {
        // add it to the guests or IIS_WPG group
        if (fSpecialiWamAccount)
        {
            RegisterAccountToLocalGroup(szUsername, IIS_WP_GROUP, TRUE);
        }
        else
        {
            RegisterAccountToLocalGroup(szUsername, TEXT("Guests"), TRUE);
        }

        // add certain user rights to this account
        RegisterAccountUserRights(szUsername, TRUE, fSpecialiWamAccount);
    }

    return err == NERR_Success;
}

INT DeleteGuestUser( LPCTSTR szUsername )
{

    INT err = NERR_Success;
    BYTE *pBuffer;
    BOOL fDisabled;

    WCHAR wchUsername[UNLEN+1];

    wcsncpy(wchUsername, szUsername, UNLEN);

    if (FALSE == DoesUserExist(wchUsername,&fDisabled))
    {
        return err;
    }

    // remove it from the guests group
    RegisterAccountToLocalGroup(szUsername, TEXT("Guests"), FALSE);

    // remove certain user rights of this account
    RegisterAccountUserRights(szUsername, FALSE, TRUE);

    err = ::NetUserDel( TEXT(""), wchUsername );

    return err;
}

#define MAX_REALISTIC_RESOURCE_LEN  MAX_PATH
BOOL CreateUserAccount(LPTSTR pszAnonyName,
                       LPTSTR pszAnonyPass,
                       DWORD  dwUserCommentResourceId,
                       DWORD  dwUserFullNameResourceId,
                       BOOL   fSpecicaliWamAccount
                       )
{

    BOOL fReturn = FALSE;
    WCHAR pszComment[MAX_REALISTIC_RESOURCE_LEN];
    WCHAR pszFullName[MAX_REALISTIC_RESOURCE_LEN];

    //
    // First Load the Resources
    //

    HMODULE hBinary;

    hBinary = GetModuleHandle(TEXT("svcext"));

    if (hBinary != NULL) {
        fReturn = LoadString(hBinary,
                             dwUserCommentResourceId,
                             pszComment,
                             MAX_REALISTIC_RESOURCE_LEN);
        if (fReturn) {
            fReturn = LoadString(hBinary,
                                 dwUserFullNameResourceId,
                                 pszFullName,
                                 MAX_REALISTIC_RESOURCE_LEN);
        }

    }

    if (fReturn) {
        fReturn = CreateUser(pszAnonyName,
                             pszAnonyPass,
                             pszComment,
                             pszFullName,
                             fSpecicaliWamAccount
                             );
    }

    if (fReturn) {
        ChangeDCOMLaunchACL(pszAnonyName,
                            TRUE,
                            TRUE);
        /* removed when fixing bug 355249
        ChangeDCOMAccessACL(pszAnonyName,
                            TRUE,
                            TRUE);
        */        
    }

    return fReturn;
}

typedef void (*P_SslGenerateRandomBits)( PUCHAR pRandomData, LONG size );
P_SslGenerateRandomBits ProcSslGenerateRandomBits = NULL;

int GetRandomNum(void)
{
    int RandomNum;
    UCHAR cRandomByte;

    if ( ProcSslGenerateRandomBits != NULL )
    {
        (*ProcSslGenerateRandomBits)( &cRandomByte, 1 );
        RandomNum = cRandomByte;
    } else
    {
        RandomNum = rand();
    }

    return(RandomNum);
}

void ShuffleCharArray(int iSizeOfTheArray, TCHAR * lptsTheArray)
{
    int i;
    int iTotal;
    int RandomNum;

    iTotal = iSizeOfTheArray / sizeof(TCHAR);
    for (i=0; i<iTotal;i++ )
    {
        // shuffle the array
        RandomNum=GetRandomNum();
        TCHAR c = lptsTheArray[i];
        lptsTheArray[i]=lptsTheArray[RandomNum%iTotal];
        lptsTheArray[RandomNum%iTotal]=c;
    }
    return;
}

//
// Create a random password
//
void CreatePassword( TCHAR *pszPassword )
{
    //
    // Use Maximum available password length, as
    // setting any other length might run afoul
    // of the minimum password length setting
    //
    int nLength = LM20_PWLEN;
    int iTotal = 0;
    int RandomNum = 0;
    int i;
    TCHAR six2pr[64] =
    {
        TEXT('A'), TEXT('B'), TEXT('C'), TEXT('D'), TEXT('E'), TEXT('F'), TEXT('G'), TEXT('H'),
        TEXT('I'), TEXT('J'), TEXT('K'), TEXT('L'), TEXT('M'),
        TEXT('N'), TEXT('O'), TEXT('P'), TEXT('Q'), TEXT('R'), TEXT('S'), TEXT('T'), TEXT('U'),
        TEXT('V'), TEXT('W'), TEXT('X'), TEXT('Y'), TEXT('Z'),
        TEXT('a'), TEXT('b'), TEXT('c'), TEXT('d'), TEXT('e'), TEXT('f'), TEXT('g'), TEXT('h'),
        TEXT('i'), TEXT('j'), TEXT('k'), TEXT('l'), TEXT('m'),
        TEXT('n'), TEXT('o'), TEXT('p'), TEXT('q'), TEXT('r'), TEXT('s'), TEXT('t'), TEXT('u'),
        TEXT('v'), TEXT('w'), TEXT('x'), TEXT('y'), TEXT('z'),
        TEXT('0'), TEXT('1'), TEXT('2'), TEXT('3'), TEXT('4'), TEXT('5'), TEXT('6'), TEXT('7'),
        TEXT('8'), TEXT('9'), TEXT('*'), TEXT('_')
    };

    // create a random password
    ProcSslGenerateRandomBits = NULL;

    HINSTANCE hSslDll = LoadLibraryEx(TEXT("schannel.dll"), NULL, 0 );
    if ( hSslDll )
        {
        ProcSslGenerateRandomBits = (P_SslGenerateRandomBits)GetProcAddress( hSslDll,
                                                                             "SslGenerateRandomBits");
        }

    // See the random number generation for rand() call in GetRandomNum()
    time_t timer;
    time( &timer );
    srand( (unsigned int) timer );

    // shuffle around the global six2pr[] array
    ShuffleCharArray(sizeof(six2pr), (TCHAR*) &six2pr);
    // assign each character of the password array
    iTotal = sizeof(six2pr) / sizeof(TCHAR);
    for ( i=0;i<nLength;i++ )
    {
        RandomNum=GetRandomNum();
        pszPassword[i]=six2pr[RandomNum%iTotal];
    }

    //
    // in order to meet a possible
    // policy set upon passwords..
    //
    // replace the last 4 chars with these:
    //
    // 1) something from !@#$%^&*()-+=
    // 2) something from 1234567890
    // 3) an uppercase letter
    // 4) a lowercase letter
    //
    TCHAR something1[12] = {TEXT('!'), TEXT('@'), TEXT('#'), TEXT('$'), TEXT('^'), TEXT('&'),
                            TEXT('*'), TEXT('('), TEXT(')'), TEXT('-'), TEXT('+'), TEXT('=')};
    ShuffleCharArray(sizeof(something1), (TCHAR*) &something1);
    TCHAR something2[10] = {TEXT('0'), TEXT('1'), TEXT('2'), TEXT('3'), TEXT('4'), TEXT('5'),
                            TEXT('6'), TEXT('7'), TEXT('8'), TEXT('9')};
    ShuffleCharArray(sizeof(something2),(TCHAR*) &something2);
    TCHAR something3[26] = {TEXT('A'), TEXT('B'), TEXT('C'), TEXT('D'), TEXT('E'), TEXT('F'),
                            TEXT('G'), TEXT('H'), TEXT('I'), TEXT('J'), TEXT('K'), TEXT('L'),
                            TEXT('M'), TEXT('N'), TEXT('O'), TEXT('P'), TEXT('Q'), TEXT('R'),
                            TEXT('S'), TEXT('T'), TEXT('U'), TEXT('V'), TEXT('W'), TEXT('X'),
                            TEXT('Y'), TEXT('Z')};
    ShuffleCharArray(sizeof(something3),(TCHAR*) &something3);
    TCHAR something4[26] = {TEXT('a'), TEXT('b'), TEXT('c'), TEXT('d'), TEXT('e'), TEXT('f'),
                            TEXT('g'), TEXT('h'), TEXT('i'), TEXT('j'), TEXT('k'), TEXT('l'),
                            TEXT('m'), TEXT('n'), TEXT('o'), TEXT('p'), TEXT('q'), TEXT('r'),
                            TEXT('s'), TEXT('t'), TEXT('u'), TEXT('v'), TEXT('w'), TEXT('x'),
                            TEXT('y'), TEXT('z')};
    ShuffleCharArray(sizeof(something4),(TCHAR*)&something4);

    RandomNum=GetRandomNum();
    iTotal = sizeof(something1) / sizeof(TCHAR);
    pszPassword[nLength-4]=something1[RandomNum%iTotal];

    RandomNum=GetRandomNum();
    iTotal = sizeof(something2) / sizeof(TCHAR);
    pszPassword[nLength-3]=something2[RandomNum%iTotal];

    RandomNum=GetRandomNum();
    iTotal = sizeof(something3) / sizeof(TCHAR);
    pszPassword[nLength-2]=something3[RandomNum%iTotal];

    RandomNum=GetRandomNum();
    iTotal = sizeof(something4) / sizeof(TCHAR);
    pszPassword[nLength-1]=something4[RandomNum%iTotal];

    pszPassword[nLength]=TEXT('\0');

    if (hSslDll)
        {FreeLibrary( hSslDll );}
}



BOOL ValidatePassword(IN LPCTSTR UserName,IN LPCTSTR Domain,IN LPCTSTR Password)
/*++
Routine Description:
    Uses SSPI to validate the specified password
Arguments:
    UserName - Supplies the user name
    Domain - Supplies the user's domain
    Password - Supplies the password
Return Value:
    TRUE if the password is valid.
    FALSE otherwise.
--*/
{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS AcceptStatus;
    SECURITY_STATUS InitStatus;
    CredHandle ClientCredHandle;
    CredHandle ServerCredHandle;
    BOOL ClientCredAllocated = FALSE;
    BOOL ServerCredAllocated = FALSE;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    PSecPkgInfo PackageInfo = NULL;
    ULONG ClientFlags;
    ULONG ServerFlags;
    TCHAR TargetName[100];
    SEC_WINNT_AUTH_IDENTITY_W AuthIdentity;
    BOOL Validated = FALSE;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    AuthIdentity.User = (LPWSTR)UserName;
    AuthIdentity.UserLength = lstrlenW(UserName);
    AuthIdentity.Domain = (LPWSTR)Domain;
    AuthIdentity.DomainLength = lstrlenW(Domain);
    AuthIdentity.Password = (LPWSTR)Password;
    AuthIdentity.PasswordLength = lstrlenW(Password);
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( TEXT("NTLM"), &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }

    //
    // Acquire a credential handle for the server side
    //
    SecStatus = AcquireCredentialsHandle(
                    NULL,
                    TEXT("NTLM"),
                    SECPKG_CRED_INBOUND,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &ServerCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }
    ServerCredAllocated = TRUE;

    //
    // Acquire a credential handle for the client side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    TEXT("NTLM"),
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &ClientCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }
    ClientCredAllocated = TRUE;

    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        goto error_exit;
    }

    ClientFlags = ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT;

    InitStatus = InitializeSecurityContext(
                    &ClientCredHandle,
                    NULL,               // No Client context yet
                    NULL,
                    ClientFlags,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( !NT_SUCCESS(InitStatus) ) {
        goto error_exit;
    }

    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        goto error_exit;
    }
    ServerFlags = ASC_REQ_EXTENDED_ERROR;

    AcceptStatus = AcceptSecurityContext(
                    &ServerCredHandle,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ServerFlags,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( !NT_SUCCESS(AcceptStatus) ) {
        goto error_exit;
    }

    if (InitStatus != STATUS_SUCCESS)
    {

        //
        // Get the AuthenticateMessage (ClientSide)
        //

        ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
        AuthenticateDesc.ulVersion = 0;
        AuthenticateDesc.cBuffers = 1;
        AuthenticateDesc.pBuffers = &AuthenticateBuffer;

        AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
        AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
        AuthenticateBuffer.pvBuffer = LocalAlloc( 0, AuthenticateBuffer.cbBuffer );
        if ( AuthenticateBuffer.pvBuffer == NULL ) {
            goto error_exit;
        }

        SecStatus = InitializeSecurityContext(
                        NULL,
                        &ClientContextHandle,
                        TargetName,
                        0,
                        0,                      // Reserved 1
                        SECURITY_NATIVE_DREP,
                        &ChallengeDesc,
                        0,                  // Reserved 2
                        &ClientContextHandle,
                        &AuthenticateDesc,
                        &ContextAttributes,
                        &Lifetime );

        if ( !NT_SUCCESS(SecStatus) ) {
            goto error_exit;
        }

        if (AcceptStatus != STATUS_SUCCESS) {

            //
            // Finally authenticate the user (ServerSide)
            //

            AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

            SecStatus = AcceptSecurityContext(
                            NULL,
                            &ServerContextHandle,
                            &AuthenticateDesc,
                            ServerFlags,
                            SECURITY_NATIVE_DREP,
                            &ServerContextHandle,
                            NULL,
                            &ContextAttributes,
                            &Lifetime );

            if ( !NT_SUCCESS(SecStatus) ) {
                goto error_exit;
            }
            Validated = TRUE;

        }

    }

error_exit:
    if (ServerCredAllocated) {
        FreeCredentialsHandle( &ServerCredHandle );
    }
    if (ClientCredAllocated) {
        FreeCredentialsHandle( &ClientCredHandle );
    }

    //
    // Final Cleanup
    //

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
    return(Validated);
}



DWORD
ChangeAppIDAccessACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256];
    DWORD   err;

    wcscpy(keyName, TEXT("APPID\\"));
    wcscat(keyName, AppID);

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                               keyName,
                                               TEXT("AccessPermission"),
                                               Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT,
                                          keyName,
                                          TEXT("AccessPermission"),
                                          Principal,
                                          Permit);
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                               keyName,
                                               TEXT("AccessPermission"),
                                               Principal);
    }

    return err;
}

DWORD
ChangeAppIDLaunchACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{

    TCHAR   keyName [256];
    DWORD   err;

    wcscpy(keyName, TEXT("APPID\\"));
    wcscat(keyName, AppID);

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                               keyName,
                                               TEXT("LaunchPermission"),
                                               Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT,
                                          keyName,
                                          TEXT("LaunchPermission"),
                                          Principal,
                                          Permit);
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                               keyName,
                                               TEXT("LaunchPermission"),
                                               Principal);
    }

    return err;
}

//
//  Function will open the metabase and check the iusr_ and iwam_ usernames.
//  it will check if the names are still valid and if the passwords are still valid.
//
VOID UpdateAnonymousUser(IMDCOM *pcCom,
                         LPTSTR pszPath,
                         DWORD dwUserMetaId,
                         DWORD dwPasswordMetaId,
                         DWORD dwUserCommentResourceId,
                         DWORD dwUserFullNameResourceId,
                         LPTSTR pszDefaultUserNamePrefix,
                         USERNAME_STRING_TYPE ustSyncName,
                         PASSWORD_STRING_TYPE pstSyncPass,
                         BOOL fPerformPasswordValidate)
{
    int iReturn = FALSE;
    USERNAME_STRING_TYPE ustAnonyName = L"\0";
    PASSWORD_STRING_TYPE pstAnonyPass = L"\0";
    GUFM_RETURN gufmTemp;
    BOOL fRet;
    BOOL fExistence;
    BOOL fDisabled;
    BOOL fUpdateComApplications = FALSE;

    LPTSTR  pstrRightsFor_IUSR[] = 
        {
        L"SeInteractiveLogonRight",
    	L"SeNetworkLogonRight",
        L"SeBatchLogonRight"
    };

    LPTSTR  pstrRightsFor_IWAM[] = 
        {
    	L"SeNetworkLogonRight",
        L"SeBatchLogonRight",
        L"SeAssignPrimaryTokenPrivilege",
        L"SeIncreaseQuotaPrivilege"
    };


/*
    TCHAR szEntry[_MAX_PATH];
    TCHAR szPassword[LM20_PWLEN+1];


    CreatePassword(szPassword);
*/

    //
    // Get the WAM username and password
    //

    gufmTemp = GetUserFromMetabase(pcCom,
                                   pszPath,
                                   dwUserMetaId,
                                   dwPasswordMetaId,
                                   ustAnonyName,
                                   pstAnonyPass);

    //
    // If the metabase path doesn't exist, then
    // service doesn't exist, punt
    // If ID doesn't exist in the metabase, then punt, assume they
    // don't want an anonymous User. We may want to revisit this.
    //
    //

    if ((gufmTemp != GUFM_NO_PATH) && (gufmTemp != GUFM_NO_USER_ID)) {

        BOOL fCreateAccount = FALSE;

        //
        // See if this is our default account. Otherwise do nothing.
        //

        if (_wcsnicmp(pszDefaultUserNamePrefix,
                      ustAnonyName,
                      wcslen(pszDefaultUserNamePrefix)) == 0) {

            // Check if this user actually exists...
            fExistence = DoesUserExist(ustAnonyName,&fDisabled);

            if (fExistence) 
            {
                if (fDisabled)
                {
                    fCreateAccount = FALSE;
                    if (!g_eventLogForAccountRecreation)
                    {
                        CreateEventLogObject ();
                    }
                    
                    if (g_eventLogForAccountRecreation)
                    {
                        CHAR  szAnsiUserName[MAX_PATH];
                        const CHAR  *pszUserNames[1];
                        
                        
                        if (! WideCharToMultiByte(CP_ACP,
                            0,
                            ustAnonyName,
                            -1,
                            szAnsiUserName,
                            MAX_PATH-1,
                            NULL,
                            NULL))
                        {
                            memset (szAnsiUserName,0,sizeof(szAnsiUserName));
                        }
                        
                        pszUserNames[0] = szAnsiUserName;
                        
                        g_eventLogForAccountRecreation->LogEvent(
                            INET_SVC_ACCOUNT_DISABLED,
                            1,
                            pszUserNames,
                            0 );
                    }
                    
                }
                else
                {
                        if (gufmTemp != GUFM_NO_PASSWORD) {
                        DBG_ASSERT(gufmTemp == GUFM_SUCCESS);

                        if (fPerformPasswordValidate)
                        {
                            BOOL fCheckPassword = TRUE;

                            //
                            // Make sure this is the same password as other
                            // instances of this account. If not, set it.
                            //

                            if ((pstSyncPass[0] != (TCHAR)'\0') &&
                                (_wcsicmp(ustSyncName, ustAnonyName) == 0)) {

                                if (wcscmp(pstSyncPass,
                                             pstAnonyPass) != 0) {

                                    //
                                    // Passwords are different.
                                    //

                                    if (WritePasswordToMetabase(pcCom,
                                                                pszPath,
                                                                dwPasswordMetaId,
                                                                pstSyncPass)) {
                                        wcscpy(pstAnonyPass,
                                               pstSyncPass);
                                    }
                                    else {
                                        fCheckPassword = FALSE;
                                    }
                                }
                            }

                            if (fCheckPassword) {
                                if (ValidatePassword(ustAnonyName,
                                                     TEXT(""),
                                                     pstAnonyPass)) 
                                {
                                    // thats a good case account is ok, do nothing there
                                }
                                else 
                                {
                                    // we comment out  DeleteGuestUser because we try to change pswd on that user
                                    // DeleteGuestUser(ustAnonyName);
                                    fCreateAccount = TRUE;
                                }
                            }
                        }

                        //
                        // Set the sync password here
                        //

                        wcscpy(pstSyncPass,
                               pstAnonyPass);

                        wcscpy(ustSyncName,
                               ustAnonyName);

                    }
                }
            }
            else {
                fCreateAccount = TRUE;
            }

            if (fCreateAccount) {

                //
                // The user does not exist, so let's create it.
                // Make sure there's a password first.
                //

                if (gufmTemp == GUFM_NO_PASSWORD) {
#if 0
                    //
                    // If it's not there then subauth should be set
                    // and the password should not be in the metabase.
                    // Also, if we add it in, then it could cause
                    // a synchronization problem in the IUSR password
                    // between W3 and FTP.
                    //

                    CreatePassword(pstAnonyPass);

                    fCreateAccount = WritePasswordToMetabase(pcCom,
                                                             pszPath,
                                                             dwPasswordMetaId,
                                                             pstAnonyPass);
#endif
                }

                if (fCreateAccount) {
                    if (MD_WAM_USER_NAME == dwUserMetaId)
                    {
                        fRet = CreateUserAccount(ustAnonyName,pstAnonyPass,dwUserCommentResourceId,dwUserFullNameResourceId,TRUE);
                        if( fRet )
                        {
                            fUpdateComApplications = TRUE;
                        }
                        // if this is a domain controller.
                        // we have to wait for the domain controller
                        // replication to be finished, otherwise The CreateUserAccount
                        // call will fail
                        //
                        // if we failed to create the user
                        // it could be because this is a DC and we need
                        // to wait for the sysvol to be ready.
                        if (!fRet)
                        {
                            if (TRUE == WaitForDCAvailability())
                            {
                                // try again...
                                fRet = CreateUserAccount(ustAnonyName,pstAnonyPass,dwUserCommentResourceId,dwUserFullNameResourceId,TRUE);
                                if( fRet )
                                {
                                    fUpdateComApplications = TRUE;
                                }
                            }
                        }
                    }
                    else
                    {
                        fRet = CreateUserAccount(ustAnonyName,pstAnonyPass,dwUserCommentResourceId,dwUserFullNameResourceId,FALSE);
                        if (!fRet)
                        {
                            if (TRUE == WaitForDCAvailability())
                            {
                                // try again...
                                fRet = CreateUserAccount(ustAnonyName,pstAnonyPass,dwUserCommentResourceId,dwUserFullNameResourceId,FALSE);
                            }
                        }
                    }


                    if (!g_eventLogForAccountRecreation)
                    {
                        CreateEventLogObject ();
                    }

                    if (g_eventLogForAccountRecreation)
                    {
                        CHAR  szAnsiUserName[MAX_PATH];
                        const CHAR  *pszUserNames[1];

                        if (! WideCharToMultiByte(CP_ACP,
                                                      0,
                                                      ustAnonyName,
                                                      -1,
                                                      szAnsiUserName,
                                                      MAX_PATH-1,
                                                      NULL,
                                                      NULL))
                        {
                            memset (szAnsiUserName,0,sizeof(szAnsiUserName));
                        }

                        pszUserNames[0] = szAnsiUserName;

                        // if succeded to recreate an account then log an event
                        if (fRet)
                        {
                            g_eventLogForAccountRecreation->LogEvent(
                                                INET_SVC_ACCOUNT_RECREATED,
                                                1,
                                                pszUserNames,
                                                0 );
                        }
                        else
                        {
                            // if the creation of the account failed, then log that too.
                            g_eventLogForAccountRecreation->LogEvent(
                                                INET_SVC_ACCOUNT_CREATE_FAILED,
                                                1,
                                                pszUserNames,
                                                0 );
                        }
                    }

                    if (dwUserMetaId == MD_WAM_USER_NAME) {
                        ChangeAppIDLaunchACL(TEXT("{9209B1A6-964A-11D0-9372-00A0C9034910}"),
                                             ustAnonyName,
                                             TRUE,
                                             TRUE);
                        ChangeAppIDAccessACL(TEXT("{9209B1A6-964A-11D0-9372-00A0C9034910}"),
                                             ustAnonyName,
                                             TRUE,
                                             TRUE);
                    }
                } // fCreateAccount == TRUE
            } // fCreateAccount == TRUE

            //
            // check if user has enough rights   otherwise add some (bug 361833)
            //

            if (wcscmp(pszDefaultUserNamePrefix,TEXT("IUSR_")) == 0) 
            {
                UpdateUserRights (ustAnonyName,pstrRightsFor_IUSR,sizeof(pstrRightsFor_IUSR)/sizeof(LPTSTR));
            }
            else
            if (wcscmp(pszDefaultUserNamePrefix,TEXT("IWAM_")) == 0) 
            {
                UpdateUserRights (ustAnonyName,pstrRightsFor_IWAM,sizeof(pstrRightsFor_IWAM)/sizeof(LPTSTR));
            }


            // Update the com applications with the new wam user information
            if( fUpdateComApplications )
            {
                HRESULT hr =
                    UpdateComApplications( pcCom, ustAnonyName, pstAnonyPass );

                if( hr != S_OK )
                {
                    if( !g_eventLogForAccountRecreation )
                    {
                        CreateEventLogObject();
                    }

                    if ( g_eventLogForAccountRecreation )
                    {
                        g_eventLogForAccountRecreation->LogEvent(
                            INET_SVC_ACCOUNT_COMUPDATE_FAILED,
                            0,
                            NULL,
                            hr
                            );
                    }
                }
            }
        }
        else
        {
            // This is not one of our accouts.
            // in other words -- it doesn't start with
            // iusr_ or iwam_
            //
            // however there is a problem here.
            //
            // on machines that are made to be replica domain controllers or
            // backup domain controllers, when dcpromo is run to create those types
            // of machines, all the local accounts are wiped out.
            //
            // this is fine if the usernames are iusr_ or iwam_, since they are just
            // re-created in the above code (or the user is warned that they were unable
            // to be crated).  however in the case where these are
            // user created accounts, the user has no way of knowing that 
            // they're iusr/iwam accounts have been hosed.
            //
            // the code here is just to warn the user of that fact.
            if (TRUE == IsDomainController())
            {
                // check if they are valid.
                // Check if this user actually exists...
                fExistence = DoesUserExist(ustAnonyName,&fDisabled);
                if (!fExistence) 
                {
                    if (!fDisabled)
                    {
                        // the user doesn't exist
                        // log SOMETHING at least
                        if (!g_eventLogForAccountRecreation)
                        {
                            CreateEventLogObject ();
                        }

                        if (g_eventLogForAccountRecreation)
                        {
                            CHAR  szAnsiUserName[MAX_PATH];
                            const CHAR  *pszUserNames[1];
                                
                            if (! WideCharToMultiByte(CP_ACP,
                                0,
                                ustAnonyName,
                                -1,
                                szAnsiUserName,
                                MAX_PATH-1,
                                NULL,
                                NULL))
                            {
                                memset (szAnsiUserName,0,sizeof(szAnsiUserName));
                            }
            
                            pszUserNames[0] = szAnsiUserName;

                            g_eventLogForAccountRecreation->LogEvent(
                                                INET_SVC_ACCOUNT_NOT_EXIST,
                                                1,
                                                pszUserNames,
                                                0 );

                        }
                    }
                }
            }
        }
    }
}


HRESULT CreateGroup(LPWSTR szGroupName, LPWSTR szGroupComment)
{
    HRESULT           hr = S_OK;
    NET_API_STATUS    dwRes;
    LOCALGROUP_INFO_1 MyLocalGroup;

    MyLocalGroup.lgrpi1_name    = szGroupName;
    MyLocalGroup.lgrpi1_comment = szGroupComment;

    dwRes = NetLocalGroupAdd(NULL, 1, (LPBYTE)&MyLocalGroup, NULL);
    if(dwRes != NERR_Success &&
       dwRes != NERR_GroupExists &&
       dwRes != ERROR_ALIAS_EXISTS)
    {
        hr = HRESULT_FROM_WIN32(dwRes);
    }

    return hr;
}



VOID 
UpdateUsers(
    BOOL fRestore /* = FALSE */ 
    )
{
    HRESULT hresTemp;
    IMDCOM *pcCom;
    BOOL    fPerformUpdate = TRUE;
    BOOL    fPerformPasswordValidate = FALSE;
    HKEY    hkRegistryKey = NULL;
    DWORD   dwRegReturn,dwBuffer, dwSize, dwType;
    HRESULT hr;

    //
    // First get the metabase interface
    //
    
    
    dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                    L"SOFTWARE\\Microsoft\\InetStp",
                     &hkRegistryKey);
    if (dwRegReturn == ERROR_SUCCESS) 
    {
        dwSize = sizeof(dwBuffer);

        dwRegReturn = RegQueryValueEx(hkRegistryKey,
                        L"DisableUserAccountRestore",
                        NULL,
                        &dwType,
                        (BYTE *)&dwBuffer,
                        &dwSize);
        if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_DWORD)) 
        {
            fPerformUpdate = FALSE;
        }

        if (fPerformUpdate)
        {
            // we are doing the check to see if the user exists...
            // see if we need to verify that the password is ssynced as well...
            dwRegReturn = RegQueryValueEx(hkRegistryKey,
                            L"EnableUserAccountRestorePassSync",
                            NULL,
                            &dwType,
                            (BYTE *)&dwBuffer,
                            &dwSize);
            if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_DWORD)) 
            {
                fPerformPasswordValidate = TRUE;
            }
        }

        RegCloseKey( hkRegistryKey );
    }


    if( fRestore )
    {
        fPerformPasswordValidate = TRUE;    
    }

    if (fPerformUpdate)
    {
        hresTemp = CoCreateInstance(CLSID_MDCOM,
                                    NULL,
                                    CLSCTX_SERVER,
                                    IID_IMDCOM,
                                    (void**) &pcCom);

        if (SUCCEEDED(hresTemp)) {

            //
            // Make sure the IIS_WPG group exists
            //
            hr = CreateGroup(IIS_WP_GROUP, L"IIS Worker Process Group");

            DBGPRINTF((DBG_CONTEXT, "Called into CreateGroup, hr %x\n", hr));

            RegisterAccountToLocalGroup(L"NT Authority\\Local Service",
                                        IIS_WP_GROUP,
                                        TRUE);

            RegisterAccountToLocalGroup(L"NT Authority\\Network Service",
                                        IIS_WP_GROUP,
                                        TRUE);

            PASSWORD_STRING_TYPE pstAnonyPass;
            USERNAME_STRING_TYPE ustAnonyName;

            pstAnonyPass[0] = (TCHAR)'\0';
            ustAnonyName[0] = (TCHAR)'\0';

            UpdateAnonymousUser(pcCom,
                                TEXT("LM/W3SVC"),
                                MD_WAM_USER_NAME,
                                MD_WAM_PWD,
                                IDS_WAMUSER_COMMENT,
                                IDS_WAMUSER_FULLNAME,
                                TEXT("IWAM_"),
                                ustAnonyName,
                                pstAnonyPass,
                                fPerformPasswordValidate);

            DBGPRINTF((DBG_CONTEXT, "Called into Updating IWAM user, hr %x\n", hr));

            pstAnonyPass[0] = (TCHAR)'\0';
            ustAnonyName[0] = (TCHAR)'\0';
            UpdateAnonymousUser(pcCom,
                                TEXT("LM/W3SVC"),
                                MD_ANONYMOUS_USER_NAME,
                                MD_ANONYMOUS_PWD,
                                IDS_USER_COMMENT,
                                IDS_USER_FULLNAME,
                                TEXT("IUSR_"),
                                ustAnonyName,
                                pstAnonyPass,
                                fPerformPasswordValidate);

            DBGPRINTF((DBG_CONTEXT, "Called into Updating IUSR user, hr %x\n", hr));

            //
            // At this point pstAnonyPass should contain the web server password.
            //

            UpdateAnonymousUser(pcCom,
                                TEXT("LM/MSFTPSVC"),
                                MD_ANONYMOUS_USER_NAME,
                                MD_ANONYMOUS_PWD,
                                IDS_USER_COMMENT,
                                IDS_USER_FULLNAME,
                                TEXT("IUSR_"),
                                ustAnonyName,
                                pstAnonyPass,
                                fPerformPasswordValidate);

            DBGPRINTF((DBG_CONTEXT, "Called into Updating IUSR user, hr %x\n", hr));

            hr = UpdateAdminAcl(pcCom,
                                L"/LM/W3SVC",
                                IIS_WP_GROUP);

            DBGPRINTF((DBG_CONTEXT, "Called into UpdateAdminAcl, hr %x\n", hr));

            pcCom->Release();
        }
    }

    if (g_eventLogForAccountRecreation)
    {
        delete g_eventLogForAccountRecreation;
        g_eventLogForAccountRecreation = NULL;
    }
}

void DumpAdminACL(PSECURITY_DESCRIPTOR pSD)
{
    BOOL b= FALSE, bDaclPresent = FALSE, bDaclDefaulted = FALSE;;
    PACL pDacl = NULL;
    ACCESS_ALLOWED_ACE* pAce;
    ACCESS_MASK dwOldMask, dwNewMask,  dwExtraMask, dwMask;

    DBGPRINTF((DBG_CONTEXT, "Dumping AdminAcl %p\n", pSD));

    b = GetSecurityDescriptorDacl(pSD, &bDaclPresent, &pDacl, &bDaclDefaulted);
    if (b) 
    {
        DBGPRINTF((DBG_CONTEXT, "DumpAdminACL:ACE count: %d\n", (int)pDacl->AceCount));

        // get dacl length  
        DWORD cbDacl = pDacl->AclSize;
        // now check if SID's ACE is there  
        for (int i = 0; i < pDacl->AceCount; i++)  
        {
            if (!GetAce(pDacl, i, (LPVOID *) &pAce))
            {
                DBGPRINTF((DBG_CONTEXT, "DumpAdminACL:GetAce failed with 0x%x\n", GetLastError()));
                continue;
            }

            if (IsValidSid(   (PSID) &(pAce->SidStart)   ) )
            {
                LPTSTR pszSid;

                LPCTSTR ServerName = NULL; // local machine
                DWORD cbName = UNLEN+1;
                TCHAR ReferencedDomainName[200];
                DWORD cbReferencedDomainName = sizeof(ReferencedDomainName);
                SID_NAME_USE sidNameUse = SidTypeUser;
                TCHAR szUserName[UNLEN + 1];

                // dump out the sid in string format
                if (ConvertSidToStringSid(  (PSID) &(pAce->SidStart)  , &pszSid))
                {
                    wcscpy(szUserName, L"(unknown...)");
                    if (LookupAccountSid(ServerName, (PSID) &(pAce->SidStart), szUserName, &cbName, ReferencedDomainName, &cbReferencedDomainName, &sidNameUse))
                    {
                        // echo to logfile
                        DBGPRINTF((DBG_CONTEXT, "DumpAdminACL:Sid[%i]=%S,%S,0x%x,0x%x,0x%x,0x%x\n",i,
                                pszSid,
                                szUserName,
                                pAce->Header.AceType,
                                pAce->Header.AceFlags,
                                pAce->Header.AceSize,
                                pAce->Mask
                                ));
                    }
                    else
                    {
                        DBGPRINTF((DBG_CONTEXT, "DumpAdminACL:Sid[%i]=%S='%S'\n",i,pszSid,szUserName));
                    }

                    
                    LocalFree(LocalHandle(pszSid));
                }
            }
            else
            {
                DBGPRINTF((DBG_CONTEXT, "DumpAdminACL:IsValidSid failed with 0x%x\n", GetLastError()));
            }
        }
    }

    return;
}

BOOL
MakeAbsoluteCopyFromRelative(
    PSECURITY_DESCRIPTOR  psdOriginal,
    PSECURITY_DESCRIPTOR* ppsdNew
    )
{
    // we have to find out whether the original is already self-relative
    SECURITY_DESCRIPTOR_CONTROL         sdc = 0;
    PSECURITY_DESCRIPTOR                psdAbsoluteCopy = NULL;
    DWORD                               dwRevision = 0;
    DWORD                               cb = 0;
    PACL Dacl = NULL, Sacl = NULL;
    PSID Owner = NULL, Group = NULL;
    DWORD                               dwDaclSize = 0;
    DWORD                               dwSaclSize = 0;
    DWORD                               dwOwnerSize = 0;
    DWORD                               dwPrimaryGroupSize = 0;

    if( !IsValidSecurityDescriptor( psdOriginal ) ) {
        goto cleanup;
    }

    if( !GetSecurityDescriptorControl( psdOriginal, &sdc, &dwRevision ) ) {
        DWORD err = GetLastError();
        goto cleanup;
    }

    if( sdc & SE_SELF_RELATIVE ) {
        // the original is in self-relative format, build an absolute copy

        // get required buffer size
        cb = 0;
        MakeAbsoluteSD(
                      psdOriginal,              // address of self-relative SD
                      psdAbsoluteCopy,          // address of absolute SD
                      &cb,                      // address of size of absolute SD
                      NULL,                     // address of discretionary ACL
                      &dwDaclSize,              // address of size of discretionary ACL
                      NULL,                     // address of system ACL
                      &dwSaclSize,              // address of size of system ACL
                      NULL,                     // address of owner SID
                      &dwOwnerSize,             // address of size of owner SID
                      NULL,                     // address of primary-group SID
                      &dwPrimaryGroupSize       // address of size of group SID
                      );

        // alloc the memory
        psdAbsoluteCopy = (PSECURITY_DESCRIPTOR) malloc( cb );
        Dacl = (PACL) malloc( dwDaclSize );
        Sacl = (PACL) malloc( dwSaclSize );
        Owner = (PSID) malloc( dwOwnerSize );
        Group = (PSID) malloc( dwPrimaryGroupSize );

        if(NULL == psdAbsoluteCopy ||
           NULL == Dacl ||
           NULL == Sacl ||
           NULL == Owner ||
           NULL == Group
          ) {
            goto cleanup;
        }

        // make the copy
        if( !MakeAbsoluteSD(
                 psdOriginal,            // address of self-relative SD
                 psdAbsoluteCopy,        // address of absolute SD
                 &cb,                    // address of size of absolute SD
                 Dacl,                  // address of discretionary ACL
                 &dwDaclSize,            // address of size of discretionary ACL
                 Sacl,                  // address of system ACL
                 &dwSaclSize,            // address of size of system ACL
                 Owner,                 // address of owner SID
                 &dwOwnerSize,           // address of size of owner SID
                 Group,          // address of primary-group SID
                 &dwPrimaryGroupSize     // address of size of group SID
                 )
          ) {
            goto cleanup;
        }
    } else {
        // the original is in absolute format, fail
        goto cleanup;
    }

    // paranoia check
    if( !IsValidSecurityDescriptor( psdAbsoluteCopy ) ) {
        goto cleanup;
    }
    if( !IsValidSecurityDescriptor( psdOriginal ) ) {
        goto cleanup;
    }

    *ppsdNew = psdAbsoluteCopy;

    return(TRUE);

cleanup:
    if( Dacl != NULL ) {
        free((PVOID) Dacl );
        Dacl = NULL;
    }
    if( Sacl != NULL ) {
        free((PVOID) Sacl );
        Sacl = NULL;
    }
    if( Owner != NULL ) {
        free((PVOID) Owner );
        Owner = NULL;
    }
    if( Group != NULL ) {
        free((PVOID) Group );
        Group = NULL;
    }
    if( psdAbsoluteCopy != NULL ) {
        free((PVOID) psdAbsoluteCopy );
        psdAbsoluteCopy = NULL;
    }

    *ppsdNew = NULL;

    return (FALSE);
}

BOOL
AddUserAccessToSD(
    IN  PSECURITY_DESCRIPTOR pSd,
    IN  PSID  pSid,
    IN  DWORD NewAccess,
    IN  UCHAR TheAceType,
    OUT PSECURITY_DESCRIPTOR *ppSdNew
    )
{
    ULONG i;
    BOOL bReturn = FALSE;
    BOOL Result;
    BOOL DaclPresent;
    BOOL DaclDefaulted;
    DWORD Length;
    DWORD NewAclLength;
    ACCESS_ALLOWED_ACE* OldAce;
    PACE_HEADER NewAce;
    ACL_SIZE_INFORMATION AclInfo;
    PACL Dacl = NULL;
    PACL NewDacl = NULL;
    PACL NewAceDacl = NULL;
    PSECURITY_DESCRIPTOR NewSD = NULL;
    PSECURITY_DESCRIPTOR OldSD = NULL;
    PSECURITY_DESCRIPTOR outpSD = NULL;
    DWORD cboutpSD = 0;
    BOOL fAceForGroupPresent = FALSE;
    DWORD dwMask;

    OldSD = pSd;

    // only do if the ace is allowed/denied
    if (ACCESS_ALLOWED_ACE_TYPE != TheAceType && ACCESS_DENIED_ACE_TYPE != TheAceType)
    {
        goto Exit;
    }

    // Convert SecurityDescriptor to absolute format. It generates
    // a new SecurityDescriptor for its output which we must free.
    if ( !MakeAbsoluteCopyFromRelative(OldSD, &NewSD) ) 
    {
        goto Exit;
    }

    // Must get DACL pointer from new (absolute) SD
    if(!GetSecurityDescriptorDacl(NewSD,&DaclPresent,&Dacl,&DaclDefaulted)) 
    {
        goto Exit;
    }

    // If no DACL, no need to add the user since no DACL
    // means all accesss
    if( !DaclPresent ) 
    {
        bReturn = TRUE;
        goto Exit;
    }

    // Code can return DaclPresent, but a NULL which means
    // a NULL Dacl is present. This allows all access to the object.
    if( Dacl == NULL )
    {
        bReturn = TRUE;
        goto Exit;
    }

    // Get the current ACL's size
    if( !GetAclInformation(Dacl,&AclInfo,sizeof(AclInfo),AclSizeInformation) ) 
    {
        goto Exit;
    }

    // Check if access is already there
    // --------------------------------
    // Check to see if this SID already exists in there
    // if it does (and it has the right access we want) then forget it, we don't have to do anything more.
    for (i = 0; i < AclInfo.AceCount; i++)  
    {
        ACE_HEADER *pAceHeader;
        ACCESS_ALLOWED_ACE* pAce = NULL;

        if (!GetAce(Dacl, i, (LPVOID *) &pAce))
        {
            goto Exit;
        }

        pAceHeader = (ACE_HEADER *)pAce;

        // check if group sid is already there
        if (EqualSid((PSID) &(pAce->SidStart), pSid))
        {
            if (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
            {
                // If the correct access is present, return success
                if ((pAce->Mask & NewAccess) == NewAccess)
                {
                    bReturn = TRUE;
                    goto Exit;
                }
                else
                {
                    // the ace that exist doesn't have the permissions that we want.
                    // If an ACE for our SID exists, we just need to bump
                    // up the access level instead of creating a new ACE
                    fAceForGroupPresent = TRUE;
                }
            }
            break;  
        }
    }
    
    // If we have to create a new ACE
    // (because our user isn't listed in the existing ACL)
    // then let's Create a new ACL to put the new access allowed ACE on
    // --------------------------------
    if (!fAceForGroupPresent)
    {
        NewAclLength = sizeof(ACL) +
                       sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG) +
                       GetLengthSid( pSid );

        NewAceDacl = (PACL) LocalAlloc( LMEM_FIXED, NewAclLength );
        if ( NewAceDacl == NULL ) 
        {
            goto Exit;
        }

        if(!InitializeAcl( NewAceDacl, NewAclLength, ACL_REVISION )) 
        {
            goto Exit;
        }

        if (ACCESS_DENIED_ACE_TYPE == TheAceType)
        {
            Result = AddAccessDeniedAce(NewAceDacl,ACL_REVISION,NewAccess,pSid);
        }
        else 
        {
            Result = AddAccessAllowedAce(NewAceDacl,ACL_REVISION,NewAccess,pSid);
        }
        if( !Result ) 
        {
            goto Exit;
        }
        // Grab the 1st ace from the Newly created Dacl
        if(!GetAce( NewAceDacl, 0, (void **)&NewAce )) 
        {
            goto Exit;
        }

        // add CONTAINER_INHERIT_ACE TO AceFlags
        //NewAce->AceFlags |= CONTAINER_INHERIT_ACE;

        Length = AclInfo.AclBytesInUse + NewAce->AceSize;
    }
    else
    {
        Length = AclInfo.AclBytesInUse;
    }

    // Allocate new DACL
    NewDacl = (PACL) LocalAlloc( LMEM_FIXED, Length );
    if(NewDacl == NULL) 
    {
        goto Exit;
    }
    if(!InitializeAcl( NewDacl, Length, ACL_REVISION )) 
    {
        goto Exit;
    }

    // Insert new ACE at the front of the new DACL
    if (!fAceForGroupPresent)
    {
        if(!AddAce( NewDacl, ACL_REVISION, 0, NewAce, NewAce->AceSize )) 
        {
            goto Exit;
        }
    }

    // ----------------------------------------
    // Read thru the old Dacl and get the ACE's
    // add it to the new Dacl
    // ----------------------------------------
    for ( i = 0; i < AclInfo.AceCount; i++ ) 
    {
        ACE_HEADER *pAceHeader;

        Result = GetAce( Dacl, i, (LPVOID*) &OldAce );
        if( !Result ) 
        {
            goto Exit;
        }

        pAceHeader = (ACE_HEADER *)OldAce;

        // If an ACE for our SID exists, we just need to bump
        // up the access level instead of creating a new ACE
        //
        if (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            dwMask = OldAce->Mask;
            if (fAceForGroupPresent)
            {
                if (EqualSid((PSID) &(OldAce->SidStart), pSid))
                {
                    dwMask = NewAccess | OldAce->Mask;
                }
            }

            // now add ace to new dacl   
            Result = AddAccessAllowedAceEx(NewDacl, ACL_REVISION, OldAce->Header.AceFlags,dwMask,(PSID) &(OldAce->SidStart));
            if( !Result ) 
            {
                goto Exit;
            }
        }
        else
        {
            // copy denied or audit ace.
            if (!AddAce(NewDacl, ACL_REVISION, 0xFFFFFFFF,OldAce, pAceHeader->AceSize ))
            {
                goto Exit;
            }
        }
    }


    // Set new DACL for Security Descriptor
    if(!SetSecurityDescriptorDacl(NewSD,TRUE,NewDacl,FALSE)) 
    {
        goto Exit;
    }

    // The new SD is in absolute format. change it to Relative before we pass it back
    cboutpSD = 0;
    MakeSelfRelativeSD(NewSD, outpSD, &cboutpSD);
    outpSD = (PSECURITY_DESCRIPTOR)GlobalAlloc(GPTR, cboutpSD);
    if ( !outpSD )
    {
        goto Exit;
    }

    if (!MakeSelfRelativeSD(NewSD, outpSD, &cboutpSD))
    {
        goto Exit;
    }

    // The new SD is passed back in relative format,
    *ppSdNew = outpSD;

    bReturn = TRUE;

 Exit:
    if (NewSD){free( NewSD );NewSD = NULL;}
    if (NewDacl){LocalFree( NewDacl );NewDacl = NULL;}
    if (NewAceDacl){LocalFree( NewAceDacl );NewAceDacl = NULL;}
    return bReturn;
}

HRESULT
UpdateAdminAcl(
    IMDCOM *    pcCom,
    LPCWSTR     szPath, 
    LPCWSTR     szAccountName
    )
/*++
Routine Description:

    After DCPromo, need to update the AdminAcl in the metabase
--*/
{
    METADATA_HANDLE      hMetabase = NULL;
    METADATA_RECORD      mdrAdminAcl;
    BUFFER               buffSid;
    BUFFER               buffDomainName;
    PSECURITY_DESCRIPTOR pOldSd = NULL;
    PSECURITY_DESCRIPTOR pNewSd = NULL;
    HRESULT              hr;
    DWORD                dwMDGetDataLen;
    DWORD                cbSid;
    DWORD                cchDomainName;
    SID_NAME_USE         peUse;

    hr = pcCom->ComMDOpenMetaObject( METADATA_MASTER_ROOT_HANDLE,
                                     szPath,
                                     METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                                     OPEN_TIMEOUT_VALUE,
                                     &hMetabase
                                     );
    if( FAILED(hr) )
    {
        DBGPRINTF((DBG_CONTEXT, "Error opening metabase path %S, hr %x\n", szPath, hr));
        goto cleanup;
    }

    MD_SET_DATA_RECORD_EXT( &mdrAdminAcl,
                            MD_ADMIN_ACL,
                            METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE,
                            IIS_MD_UT_SERVER,
                            BINARY_METADATA,
                            0,
                            NULL
                            );

    hr = pcCom->ComMDGetMetaData(hMetabase,
                                 NULL,
                                 &mdrAdminAcl,
                                 &dwMDGetDataLen);

    if (FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Error retrieving data, hr %x\n", hr));
        goto cleanup;
    }

    pOldSd = (PSECURITY_DESCRIPTOR)mdrAdminAcl.pbMDData;

    //
    // obtain the logon sid of the user/group
    //
    cbSid = buffSid.QuerySize();
    cchDomainName = buffDomainName.QuerySize() / sizeof(WCHAR);
    while(!LookupAccountName(NULL,
                             szAccountName,
                             buffSid.QueryPtr(),
                             &cbSid,
                             (LPWSTR)buffDomainName.QueryPtr(),
                             &cchDomainName,
                             &peUse))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        {
            DBGPRINTF((DBG_CONTEXT, "Error retrieving account %S, hr %x\n", szAccountName, hr));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto cleanup;
        }

        if (!buffSid.Resize(cbSid) ||
            !buffDomainName.Resize(cchDomainName * sizeof(WCHAR)))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto cleanup;
        }
    }

    DWORD AccessMask = (MD_ACR_READ | MD_ACR_WRITE | MD_ACR_RESTRICTED_WRITE | MD_ACR_UNSECURE_PROPS_READ | MD_ACR_ENUM_KEYS | MD_ACR_WRITE_DAC);

    DumpAdminACL(pOldSd);

    if (!AddUserAccessToSD(pOldSd,
                           buffSid.QueryPtr(),
                           AccessMask,
                           ACCESS_ALLOWED_ACE_TYPE,
                           &pNewSd))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF((DBG_CONTEXT, "Error adding user to AdminAcl, hr %x\n", hr));
        goto cleanup;
    }

    if (pNewSd)
    {
        DumpAdminACL(pNewSd);

        DWORD dwNewSd = GetSecurityDescriptorLength(pNewSd);

        MD_SET_DATA_RECORD_EXT( &mdrAdminAcl,
                                MD_ADMIN_ACL,
                                METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE,
                                IIS_MD_UT_SERVER,
                                BINARY_METADATA,
                                dwNewSd,
                                pNewSd
                                );

        hr = pcCom->ComMDSetMetaData(hMetabase,
                                     NULL,
                                     &mdrAdminAcl);

        if (FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "Error setting adminacl, hr %x\n", hr));
            goto cleanup;
        }
    }

 cleanup:
    if (pNewSd)
    {
        GlobalFree(pNewSd);
        pNewSd = NULL;
    }

    if (hMetabase)
    {
        // Done with the metabase
        pcCom->ComMDCloseMetaObject(hMetabase);
        hMetabase = NULL;
    }

    return hr;
}

HRESULT 
UpdateComApplications( 
    IMDCOM *    pcCom,
    LPCTSTR     szWamUserName, 
    LPCTSTR     szWamUserPass 
    )
/*++
Routine Description:

    If the IWAM account has been modified, it is necessary to update the
    the out of process com+ applications with the correct account
    information. This routine will collect all the com+ applications and
    reset the activation information.

Arguments:

    pcCom               - metabase object
    szWamUserName       - the new user name
    szWamUserPass       - the new user password

Note:

    This routine is a royal pain in the butt. I take back
    all the good things I may have said about com automation.

Return Value:
    
    HRESULT             - Return value from failed API call
                        - E_OUTOFMEMORY
                        - S_OK - everything worked
                        - S_FALSE - encountered a non-fatal error, unable
                          to reset at least one application.
--*/                       
{
    HRESULT     hr = NOERROR;
    BOOL        fNoErrors = TRUE;

    METADATA_HANDLE     hMetabase = NULL;
    WCHAR *             pwszDataPaths = NULL;
    DWORD               cchDataPaths = 0;
    BOOL                fTryAgain;
    DWORD               cMaxApplications;
    WCHAR *             pwszCurrentPath;
    STACK_BUFFER(       bufMDPath, 64 );
    WCHAR *             pwszMDPath = NULL;
    DWORD               dwMDPathLen;

    SAFEARRAY *     psaApplications = NULL;
    SAFEARRAYBOUND  rgsaBound[1];
    DWORD           cApplications;
    VARIANT         varAppKey;
    LONG            rgIndices[1];

    METADATA_RECORD     mdrAppIsolated;
    METADATA_RECORD     mdrAppPackageId;
    METADATA_RECORD     mdrWamClsid;
    DWORD               dwAppIsolated;
    WCHAR               wszAppPackageId[ 40 ];
    WCHAR               wszWamClsid[ 40 ];
    DWORD               dwMDGetDataLen = 0;

    ICOMAdminCatalog *      pComCatalog = NULL;
    ICatalogCollection *    pComAppCollection = NULL;
    ICatalogObject *        pComApp = NULL;
    BSTR                    bstrAppCollectionName = NULL;
    LONG                    nAppsInCollection;
    LONG                    iCurrentApp;
    LONG                    nChanges;
    BOOL                    fAppCreated = FALSE;

    VARIANT     varOldAppIdentity;
    VARIANT     varNewAppIdentity;
    VARIANT     varNewAppPassword;

    // This is built unicode right now. Since all the com apis I need
    // are unicode only I'm using wide characters here. I should get
    // plenty of compiler errors if _UNICODE isn't defined, but just
    // in case....
    DBG_ASSERT( sizeof(TCHAR) == sizeof(WCHAR) );

    DBGPRINTF(( DBG_CONTEXT,
                "Updating activation identity for out of process apps.\n"
                ));

    // Init variants
    VariantInit( &varAppKey );
    VariantInit( &varOldAppIdentity );
    VariantInit( &varNewAppIdentity );
    VariantInit( &varNewAppPassword );

    //
    // Get the applications to be reset by querying the metabase paths
    //

    hr = pcCom->ComMDOpenMetaObject( METADATA_MASTER_ROOT_HANDLE,
                                     ROOTMDPath,
                                     METADATA_PERMISSION_READ,
                                     OPEN_TIMEOUT_VALUE,
                                     &hMetabase
                                     );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT, 
                   "Failed to open metabase (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    // Get the data paths string

    fTryAgain = TRUE;
    do
    {
        hr = pcCom->ComMDGetMetaDataPaths( hMetabase,
                                           NULL,
                                           MD_APP_PACKAGE_ID,
                                           STRING_METADATA,
                                           cchDataPaths,
                                           pwszDataPaths,
                                           &cchDataPaths 
                                           );

        if( HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr )
        {
            delete[] pwszDataPaths;
            pwszDataPaths = NULL;

            pwszDataPaths = new WCHAR[cchDataPaths];
            if( !pwszDataPaths )
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }
        }
        else
        {
            fTryAgain = FALSE;
        }
    }
    while( fTryAgain );

    //
    // Done with the metabase for now
    //
    pcCom->ComMDCloseMetaObject(hMetabase);
    hMetabase = NULL;

    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT, 
                   "Failed to find metadata (%08x) Data(%d)\n",
                   hr,
                   MD_APP_PACKAGE_ID
                   ));
        goto cleanup;
    }
    else if (pwszDataPaths == NULL)
    {
        //
        // If we found no isolated apps, make the path list an empty multisz
        //
        cchDataPaths = 1;
        pwszDataPaths = new WCHAR[cchDataPaths];
        if( !pwszDataPaths )
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
        pwszDataPaths[0] = L'\0';
    }

    // Determine the maximum number of applications

    cMaxApplications = 1; // The pooled application

    for( pwszCurrentPath = pwszDataPaths; 
         *pwszCurrentPath != L'\0';
         pwszCurrentPath += wcslen(pwszCurrentPath) + 1
         )
    {
        cMaxApplications++;
    }

    //
    // Build a key array and load the com applications.
    //

    // Create an array to hold the keys

    rgsaBound[0].cElements = cMaxApplications;
    rgsaBound[0].lLbound = 0;

    psaApplications = SafeArrayCreate( VT_VARIANT, 1, rgsaBound );
    if( psaApplications == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    // Set the out of process pool application key
    varAppKey.vt = VT_BSTR;
    varAppKey.bstrVal = SysAllocString( W3_OOP_POOL_PACKAGE_ID );
    if( !varAppKey.bstrVal )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    rgIndices[0] = 0;
    hr = SafeArrayPutElement( psaApplications, rgIndices, &varAppKey );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT, 
                   "Failed setting an element in a safe array (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    // For each of the application paths determine if an out of process
    // application is defined there and set the appropriate key into
    // our array    

    MD_SET_DATA_RECORD_EXT( &mdrAppIsolated,
                            MD_APP_ISOLATED,
                            METADATA_NO_ATTRIBUTES,
                            ALL_METADATA,
                            DWORD_METADATA,
                            sizeof(DWORD),
                            (PBYTE)&dwAppIsolated
                            );

    MD_SET_DATA_RECORD_EXT( &mdrAppPackageId,
                            MD_APP_PACKAGE_ID,
                            METADATA_NO_ATTRIBUTES,
                            ALL_METADATA,
                            STRING_METADATA,
                            sizeof(wszAppPackageId),
                            (PBYTE)wszAppPackageId
                            );

    wszAppPackageId[0] = L'\0';

    MD_SET_DATA_RECORD_EXT( &mdrWamClsid,
                            MD_APP_WAM_CLSID,
                            METADATA_NO_ATTRIBUTES,
                            ALL_METADATA,
                            STRING_METADATA,
                            sizeof(wszWamClsid),
                            (PBYTE)wszWamClsid
                            );

    wszWamClsid[0] = L'\0';

    // Go through each data path and set it into our array if
    // it is an isolated application

    cApplications = 1;  // Actual # of applications - 1 for pool

    for( pwszCurrentPath = pwszDataPaths; 
         *pwszCurrentPath != L'\0';
         pwszCurrentPath += wcslen(pwszCurrentPath) + 1
         )
    {
        if( hMetabase != NULL )
        {            
            pcCom->ComMDCloseMetaObject(hMetabase);
            hMetabase = NULL;
        }

        //
        // 20 is the size of L"/LM/W3SVC"
        //
        if( !bufMDPath.Resize( wcslen( pwszCurrentPath ) * 
                               sizeof( WCHAR ) + 20 ) ) 
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
        
        pwszMDPath = ( WCHAR* )bufMDPath.QueryPtr();
        
        wcscpy( pwszMDPath, ROOTMDPath );
        wcscat( pwszMDPath, pwszCurrentPath );

        //
        // Get rid of the trailing '/' or '\\'
        //
        dwMDPathLen = wcslen( pwszMDPath );
        if( pwszMDPath[ dwMDPathLen - 1 ] == L'\\' || 
            pwszMDPath[ dwMDPathLen - 1 ] == L'/' )
        {
            pwszMDPath[ dwMDPathLen - 1 ] = L'\0';
        }
        
        hr = pcCom->ComMDOpenMetaObject( METADATA_MASTER_ROOT_HANDLE,
                                         pwszMDPath,
                                         METADATA_PERMISSION_READ,
                                         OPEN_TIMEOUT_VALUE,
                                         &hMetabase
                                         );
        if( FAILED(hr) )
        {
            DBGERROR(( DBG_CONTEXT, 
                       "Failed to open metabase (%08x)\n",
                       hr
                       ));
            goto cleanup;
        }

        hr = pcCom->ComMDGetMetaData( hMetabase,
                                      NULL,
                                      &mdrAppIsolated,
                                      &dwMDGetDataLen
                                      );
        if( FAILED(hr) )
        {
            DBGERROR(( DBG_CONTEXT, 
                       "Failed to get data from the metabase (%08x)"
                       " Path(%S) Data(%d)\n",
                       hr,
                       pwszMDPath,
                       mdrAppIsolated.dwMDIdentifier
                       ));

            fNoErrors = FALSE;
            continue;
        }

        // Is the application out of process
        if( dwAppIsolated == 1 )
        {
            // Get the application id

            hr = pcCom->ComMDGetMetaData( hMetabase,
                                          NULL,
                                          &mdrAppPackageId,
                                          &dwMDGetDataLen
                                          );
            if( FAILED(hr) )
            {
                DBGERROR(( DBG_CONTEXT, 
                           "Failed to get data from the metabase (%08x)"
                           " Path(%S) Data(%d)\n",
                           hr,
                           pwszMDPath,
                           mdrAppPackageId.dwMDIdentifier
                           ));

                fNoErrors = FALSE;
                continue;
            }

            // Get the wam class id

            hr = pcCom->ComMDGetMetaData( hMetabase,
                                          NULL,
                                          &mdrWamClsid,
                                          &dwMDGetDataLen
                                          );
            if( FAILED(hr) )
            {
                DBGERROR(( DBG_CONTEXT, 
                           "Failed to get data from the metabase (%08x)"
                           " Path(%S) Data(%d)\n",
                           hr,
                           pwszMDPath,
                           mdrWamClsid.dwMDIdentifier
                           ));

                fNoErrors = FALSE;
                continue;
            }

            //
            // Close meta object since we may need to write to it after we 
            // create a new COM+ application.
            //
            pcCom->ComMDCloseMetaObject(hMetabase);
            hMetabase = NULL;
            
            hr = CreateCOMPlusApplication( pwszMDPath,
                                           wszAppPackageId,
                                           wszWamClsid,
                                           &fAppCreated );
            if( FAILED( hr ) )
            {
                fNoErrors = FALSE;
                continue;
            }

            if( fAppCreated )
            {
                //
                // We don't need to fix the password for this 
                // COM+ application
                //
                continue;
            }
            
            // Add the application id to the array

            VariantClear( &varAppKey );
            varAppKey.vt = VT_BSTR;
            varAppKey.bstrVal = SysAllocString( wszAppPackageId );
            if( !varAppKey.bstrVal )
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }

            rgIndices[0]++;
            hr = SafeArrayPutElement( psaApplications, 
                                      rgIndices, 
                                      &varAppKey 
                                      );
            if( FAILED(hr) )
            {
                DBGERROR(( DBG_CONTEXT, 
                           "Failed to set safe array element (%08x)\n",
                           hr
                           ));
                VariantClear( &varAppKey );
                rgIndices[0]--;
                fNoErrors = FALSE;
                continue;
            }
            cApplications++;
        }
    }

    // Shrink the size of the safe-array if necessary
    if( cApplications < cMaxApplications )
    {
        rgsaBound[0].cElements = cApplications;

        hr = SafeArrayRedim( psaApplications, rgsaBound );
        if( FAILED(hr) )
        {
            DBGERROR(( DBG_CONTEXT, 
                       "Failed to redim safe array (%08x)\n",
                       hr
                       ));
            goto cleanup;
        }
    }

    //
    // For each application reset the activation identity
    //

    // Use our key array to get the application collection

    hr = CoCreateInstance( CLSID_COMAdminCatalog,
                           NULL,
                           CLSCTX_SERVER,
                           IID_ICOMAdminCatalog,
                           (void**)&pComCatalog
                           );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT, 
                   "Failed to create COM catalog (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    hr = pComCatalog->GetCollection( L"Applications", 
                                     (IDispatch **)&pComAppCollection
                                     );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT, 
                   "Failed to get Applications collection (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    hr = pComAppCollection->PopulateByKey( psaApplications );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT, 
                   "Failed to populate Applications collection (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    // Iterate over the application collection and update all the
    // applications that use IWAM.

    hr = pComAppCollection->get_Count( &nAppsInCollection );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT, 
                   "Failed to get Applications count (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    // Init our new app identity and password.

    varNewAppIdentity.vt = VT_BSTR;
    varNewAppIdentity.bstrVal = SysAllocString( szWamUserName );
    if( !varNewAppIdentity.bstrVal )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    varNewAppPassword.vt = VT_BSTR;
    varNewAppPassword.bstrVal = SysAllocString( szWamUserPass );
    if( !varNewAppPassword.bstrVal )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    for( iCurrentApp = 0; iCurrentApp < nAppsInCollection; ++iCurrentApp )
    {
        if( pComApp )
        {
            pComApp->Release();
            pComApp = NULL;
        }
        if( varOldAppIdentity.vt != VT_EMPTY )
        {
            VariantClear( &varOldAppIdentity );
        }

        hr = pComAppCollection->get_Item( iCurrentApp, 
                                          (IDispatch **)&pComApp );
        if( FAILED(hr) )
        {
            DBGERROR(( DBG_CONTEXT, 
                       "Failed to get item from Applications collection (%08x)\n",
                       hr
                       ));
            fNoErrors = FALSE;
            continue;
        }

        // If the user has set this to something other than the IWAM_
        // user, then we will respect that and not reset the identiy.

        hr = pComApp->get_Value( L"Identity", &varOldAppIdentity );
        if( FAILED(hr) )
        {
            DBGERROR(( DBG_CONTEXT, 
                       "Failed to get Identify from Application (%08x)\n",
                       hr
                       ));
            fNoErrors = FALSE;
            continue;
        }

        DBG_ASSERT( varOldAppIdentity.vt == VT_BSTR );
        if( varOldAppIdentity.vt == VT_BSTR )
        {
            if( memcmp( L"IWAM_", varOldAppIdentity.bstrVal, 10 ) == 0 )
            {
                hr = pComApp->put_Value( L"Identity", varNewAppIdentity );
                if( FAILED(hr) )
                {
                    DBGERROR(( DBG_CONTEXT, 
                               "Failed to set new Identify (%08x)\n",
                               hr
                               ));
                    fNoErrors = FALSE;
                    continue;
                }

                hr = pComApp->put_Value( L"Password", varNewAppPassword );
                if( FAILED(hr) )
                {
                    DBGERROR(( DBG_CONTEXT, 
                               "Failed to set new Password (%08x)\n",
                               hr
                               ));
                    fNoErrors = FALSE;
                    continue;
                }
            }
            else
            {
                DBGINFO(( DBG_CONTEXT,
                          "Unrecognized application identity (%S)\n",
                          varOldAppIdentity.bstrVal
                          ));
            }
        }
    }

    hr = pComAppCollection->SaveChanges( &nChanges );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT,
                   "Failed to save changes (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }
    
cleanup:

    if( hMetabase != NULL )
    {
        pcCom->ComMDCloseMetaObject(hMetabase);
        hMetabase = NULL;
    }

    if( psaApplications != NULL )
    {
        SafeArrayDestroy( psaApplications );
    }

    if( pComCatalog != NULL )
    {
        pComCatalog->Release();
    }

    if( pComAppCollection != NULL )
    {
        pComAppCollection->Release();
    }

    if( pComApp != NULL )
    {
        pComApp->Release();
    }

    if( varAppKey.vt != VT_EMPTY )
    {
        VariantClear( &varAppKey );
    }

    if( varOldAppIdentity.vt != VT_EMPTY )
    {
        VariantClear( &varOldAppIdentity );
    }

    if( varNewAppIdentity.vt != VT_EMPTY )
    {
        VariantClear( &varNewAppIdentity );
    }

    if( varNewAppPassword.vt != VT_EMPTY )
    {
        VariantClear( &varNewAppPassword );
    }

    delete [] pwszDataPaths;

    // return
    if( FAILED(hr) )
    {
        return hr;
    }
    else if( fNoErrors == FALSE )
    {
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}

int
IsDomainController(void)
{
    int iReturn = FALSE;

    OSVERSIONINFOEX VerInfo;
    ZeroMemory(&VerInfo, sizeof VerInfo);
    VerInfo.dwOSVersionInfoSize = sizeof VerInfo;
    if (GetVersionEx(reinterpret_cast<OSVERSIONINFO *>(&VerInfo)))
    {
        if (VER_NT_DOMAIN_CONTROLLER == VerInfo.wProductType)
        {
            iReturn = TRUE;
        }
    }

    return iReturn;
}

BOOL
WaitForDCAvailability(void)
{
    BOOL    bRetVal = FALSE;
    HANDLE  hEvent;
    DWORD   dwResult;
    DWORD   dwCount = 0, dwMax;
    DWORD   dwMaxWait = 20000; // 20 second max wait
    HKEY    hKeyNetLogonParams;

    if (FALSE == IsDomainController())
    {
        // not a domain controller
        // so we don't have to worry about replication delays...
        return TRUE;
    }

    dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,TEXT("SYSTEM\\CurrentControlSet\\Services\\netlogon\\parameters"),0,KEY_READ,&hKeyNetLogonParams );
    if ( dwResult == ERROR_SUCCESS ) 
    {
        //
        // value exists
        //
        DWORD   dwSysVolReady = 0,
                dwSize = sizeof( DWORD ),
                dwType = REG_DWORD;

        dwResult = RegQueryValueEx( hKeyNetLogonParams,TEXT("SysVolReady"),0,&dwType,(LPBYTE) &dwSysVolReady,&dwSize );
        if ( dwResult == ERROR_SUCCESS ) 
        {
            //
            // SysVolReady?
            //
            if ( dwSysVolReady == 0 ) 
            {
                HANDLE hEvent;
                //
                // wait for SysVol to become ready
                //
                hEvent = CreateEvent( 0, TRUE, FALSE, TEXT("IISSysVolReadyEvent") );
                if ( hEvent ) 
                {

                    dwResult = RegNotifyChangeKeyValue( hKeyNetLogonParams, FALSE, REG_NOTIFY_CHANGE_LAST_SET, hEvent, TRUE );

                    if ( dwResult == ERROR_SUCCESS )
                    {
                        const DWORD dwMaxCount = 3;
                        do {
                            //
                            // wait for SysVolReady to change
                            // hEvent is signaled for any changes in hKeyNetLogonParams
                            // not just the SysVolReady value.
                            //
                            WaitForSingleObject (hEvent, dwMaxWait / dwMaxCount );
                            dwResult = RegQueryValueEx( hKeyNetLogonParams,TEXT("SysVolReady"),0,&dwType,(LPBYTE) &dwSysVolReady,&dwSize );
                        } while ( dwSysVolReady == 0 && ++dwCount < dwMaxCount );

                        if ( dwSysVolReady ) 
                        {
                            bRetVal = TRUE;
                        }
                    }
                    CloseHandle( hEvent );
                }
            }
            else
            {
                // sysvol is ready
                bRetVal = TRUE;
            }

        }
        else  
        {
            //
            // value is non-existent, SysVol is assumed to be ready
            //
            if ( dwResult == ERROR_FILE_NOT_FOUND ) 
            {
                bRetVal = TRUE;
            }
        }

        RegCloseKey( hKeyNetLogonParams );
    }
    else
    {
        // error opening regkey, maybe it's not even there
        bRetVal = TRUE;
    }

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\dcomadm\mdutil\tables.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       tables.cpp

   Abstract:

        mapping tables to convert various info between text and binary

   Environment:

      Win32 User Mode

   Author:

      jaroslad  (jan 1997)

--*/


#include "tables.h"

#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#include <iiscnfgp.h>  //get MD_* constants



BOOL IsNumber(const CString & name)
{
    for(INT i=0;i<name.GetLength();i++)
    {
        if (name[i]<_T('0') || name[i]>_T('9'))
            return FALSE;
    }
    return TRUE;
}



BOOL IsServiceName(const CString& name)
{
    BOOL fRetval=FALSE;

    if(name.CompareNoCase(_T("W3SVC"))==0 || name.CompareNoCase(_T("MSFTPSVC"))==0 ||
        name.CompareNoCase(_T("NNTPSVC"))==0 || name.CompareNoCase(_T("SMTPSVC"))==0)
    {
        fRetval=TRUE;
    }
    return fRetval;
}





//**********************************************************************
// COMMAND NAME TABLE IMPLEMENTATION
//**********************************************************************


//constants defined in tables.h
struct tCommandNameTable gCommandNameTable[]=
{
    {CMD_SET, _T("SET")},
    {CMD_GET, _T("GET")},
    {CMD_GET, _T("G")},
    {CMD_COPY, _T("COPY")},
    {CMD_DELETE, _T("DELETE")},
    {CMD_DELETE, _T("DEL")},
    {CMD_ENUM, _T("ENUM")},
    {CMD_ENUM, _T("E")},
    {CMD_ENUM_ALL,_T("ENUM_ALL")},
    {CMD_CREATE, _T("CREATE")},
    {CMD_RENAME, _T("RENAME")},
    {CMD_SCRIPT, _T("SCRIPT")},
    {CMD_SAVE, _T("SAVE")},
    {CMD_APPCREATEINPROC, _T("APPCREATEINPROC")},
    {CMD_APPCREATEOUTPOOL, _T("APPCREATEOUTPOOL")},
    {CMD_APPCREATEOUTPROC, _T("APPCREATEOUTPROC")},
    {CMD_APPDELETE, _T("APPDELETE")},
    {CMD_APPRENAME, _T("APPRENAME")},
    {CMD_APPUNLOAD, _T("APPUNLOAD")},
    {CMD_APPGETSTATUS, _T("APPGETSTATUS")},

    //the end
    {0,0}

};

DWORD MapCommandNameToCode(const CString & strName)
{
    return tCommandNameTable::MapNameToCode(strName);
}


DWORD tCommandNameTable::MapNameToCode(const CString & strName, tCommandNameTable * CommandNameTable)
{
    for(int i=0; CommandNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(CommandNameTable[i].lpszName)==0)
            return CommandNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}

#if 0
CString tCommandNameTable::MapCodeToName(DWORD dwCode, tCommandNameTable * CommandNameTable)
{
    for(int i=0; CommandNameTable[i].lpszName!=0;i++)
    {
        if(dwCode==CommandNameTable[i].dwCode)
            return CommandNameTable[i].dwName;
    }
    return 0;
}
#endif



//**********************************************************************
// PROPERTY NAME TABLE IMPLEMENTATION
//**********************************************************************


tPropertyNameTable  gPropertyNameTable[]=
{
//  These are global to all services and should only be set at
//  the IIS root
    {/**/MD_MAX_BANDWIDTH                ,_T("MaxBandwidth"),           METADATA_NO_ATTRIBUTES, /*SHOULD BE GLOBAL*/IIS_MD_UT_SERVER,       DWORD_METADATA},
    {/**/MD_KEY_TYPE                     ,_T("KeyType"),        METADATA_NO_ATTRIBUTES, /*SHOULD BE GLOBAL*/IIS_MD_UT_SERVER,       STRING_METADATA},
//  These properties are applicable to both HTTP and FTP virtual
//  servers
    {/**/MD_CONNECTION_TIMEOUT           ,_T("ConnectionTimeout"),      METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_MAX_CONNECTIONS              ,_T("MaxConnections"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_COMMENT               ,_T("ServerComment"),          METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   STRING_METADATA},
    {/**/MD_SERVER_STATE                 ,_T("ServerState"),            METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_COMMAND               ,_T("ServerCommand"),          METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_AUTOSTART             ,_T("ServerAutostart"),        METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_CLUSTER_SERVER_COMMAND       ,_T("ClusterServerCommand"),   METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_CLUSTER_ENABLED              ,_T("ClusterEnabled"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_SIZE                  ,_T("ServerSize"),             METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_LISTEN_BACKLOG        ,_T("ServerListenBacklog"),    METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_LISTEN_TIMEOUT        ,_T("ServerListenTimeout"),    METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_DOWNLEVEL_ADMIN_INSTANCE     ,_T("DownlevelAdminInstance"), METADATA_INHERIT      , IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_BINDINGS              ,_T("ServerBindings"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   MULTISZ_METADATA},
        { MD_SERVER_CONFIGURATION_INFO    ,   _T("ServerConfigurationInfo"),METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},

        //internals
    {/**/MD_SERVER_PLATFORM              ,_T("ServerPlatform"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_VERSION_MAJOR         ,_T("MajorVersion"),           METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_VERSION_MINOR         ,_T("MinorVersion"),           METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},
    {/**/MD_SERVER_CAPABILITIES          ,_T("Capabilities"),           METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   DWORD_METADATA},

//  These properties are specific to HTTP and belong to the virtual
//  server
    {/**/MD_SECURE_BINDINGS              ,_T("SecureBindings"),         METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,   MULTISZ_METADATA},
    {/**/MD_NTAUTHENTICATION_PROVIDERS   ,_T("NTAuthenticationProviders"),  METADATA_INHERIT,       IIS_MD_UT_FILE,/*??*/STRING_METADATA},
    {/**/MD_SCRIPT_TIMEOUT               ,_T("ScriptTimeout"),              METADATA_INHERIT,IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_CACHE_EXTENSIONS             ,_T("CacheExtensions"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,/*??*/DWORD_METADATA},
    {/**/MD_CREATE_PROCESS_AS_USER       ,_T("CreateProcessAsUser"),        METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_CREATE_PROC_NEW_CONSOLE      ,_T("CreateProcNewConsole"),   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_POOL_IDC_TIMEOUT             ,_T("PoolIDCTimeout"),         METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_ALLOW_KEEPALIVES             ,_T("AllowKeepAlives"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_FILTER_LOAD_ORDER            ,_T("FilterLoadOrder"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,/*??*/STRING_METADATA},
    {/**/MD_FILTER_IMAGE_PATH            ,_T("FilterImagePath"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_FILTER_STATE                 ,_T("FilterState"),                METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_FILTER_ENABLED                   ,_T("FilterEnabled"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_FILTER_FLAGS                     ,_T("FilterFlags"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_FILTER_DESCRIPTION               ,_T("FilterDescription"),        METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},

    { MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS, _T("AllowPathInfoForScriptMappings"), METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA },
    { MD_AUTH_CHANGE_URL                 ,_T("AuthChangeUrl"),  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_AUTH_EXPIRED_URL, _T("AuthExpiredUrl"),     METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_AUTH_NOTIFY_PWD_EXP_URL, _T("NotifyPwdExpUrl"), METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_AUTH_EXPIRED_UNSECUREURL, _T("AuthExpiredUnsecureUrl"),     METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_AUTH_NOTIFY_PWD_EXP_UNSECUREURL, _T("NotifyPwdExpUnsecureUrl"), METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {MD_ADV_NOTIFY_PWD_EXP_IN_DAYS, _T("NotifyPwdExpInDays"),   METADATA_INHERIT,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_AUTH_CHANGE_FLAGS, _T("AuthChangeFlags"),   METADATA_INHERIT,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_ADV_CACHE_TTL, _T("AdvCacheTTL"),   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_NET_LOGON_WKS, _T("NetLogonWks"),METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_USE_HOST_NAME, _T("UseHostName"),METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
#if defined(CAL_ENABLED)
    {MD_CAL_VC_PER_CONNECT, "CalVcPerConnect",METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_CAL_AUTH_RESERVE_TIMEOUT, "CalAuthReserveTimeout",METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_CAL_SSL_RESERVE_TIMEOUT, "CalSslReserveTimeout",METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_CAL_W3_ERROR, "CalW3Error",METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
#endif
        { MD_IN_PROCESS_ISAPI_APPS        , _T("InProcessIsapiApps") ,METADATA_INHERIT, IIS_MD_UT_SERVER, MULTISZ_METADATA},
        { MD_CUSTOM_ERROR_DESC            , _T("CustomErrorDesc")    ,METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, MULTISZ_METADATA},

    {/**/MD_MAPCERT                      ,_T("MapCert"),                    METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_MAPNTACCT                    ,_T("MaPNTAccT"),                  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_MAPNAME                      ,_T("MapName"),                    METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_MAPENABLED                   ,_T("MapEnabled"),                 METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_MAPREALM                     ,_T("MapRealm"),                   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_MAPPWD                       ,_T("MapPwd"),                     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_ITACCT                       ,_T("ITACCT"),                     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_CPP_CERT11                   ,_T("CppCert11"),                  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {/**/MD_SERIAL_CERT11                ,_T("SerialCert11"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {/**/MD_CPP_CERTW                    ,_T("CppCertw"),                   METADATA_SECURE,IIS_MD_UT_SERVER, BINARY_METADATA},
    {/**/MD_SERIAL_CERTW                 ,_T("SerialCertw"),                METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {/**/MD_CPP_DIGEST                   ,_T("CppDigest"),                  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {/**/MD_SERIAL_DIGEST                ,_T("SerialDigest"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {/**/MD_CPP_ITA                      ,_T("CppIta"),                 METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},
    {/**/MD_SERIAL_ITA                   ,_T("SerialIta"),                  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER, BINARY_METADATA},

// Compression Filter Properties
    {/**/MD_HC_COMPRESSION_DIRECTORY     ,_T("HcCompressionDirectory"),     IIS_MD_UT_SERVER, EXPANDSZ_METADATA},
    {/**/MD_HC_CACHE_CONTROL_HEADER      ,_T("HcCacheControlHeader"),       IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_HC_EXPIRES_HEADER            ,_T("HcExpiresHeader"),            IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_HC_DO_DYNAMIC_COMPRESSION    ,_T("HcDoDynamicCompression"),     IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_DO_STATIC_COMPRESSION     ,_T("HcDoStaticCompression"),      IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_DO_ON_DEMAND_COMPRESSION  ,_T("HcDoOnDemandCompression"),    IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_DO_DISK_SPACE_LIMITING    ,_T("HcDoDiskSpaceLimiting"),      IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_NO_COMPRESSION_FOR_HTTP_10 ,_T("HcNoCompressionForHttp10"),  IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_NO_COMPRESSION_FOR_PROXIES ,_T("HcNoCompressionForProxies"), IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_NO_COMPRESSION_FOR_RANGE  ,_T("HcNoCompressionForRange"),    IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_SEND_CACHE_HEADERS        ,_T("HcSendCacheHeaders"),         IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_MAX_DISK_SPACE_USAGE      ,_T("HcMaxDiskSpaceUsage"),        IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_IO_BUFFER_SIZE            ,_T("HcIoBufferSize"),             IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_COMPRESSION_BUFFER_SIZE   ,_T("HcCompressionBufferSize"),    IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_MAX_QUEUE_LENGTH          ,_T("HcMaxQueueLength"),           IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_FILES_DELETED_PER_DISK_FREE ,_T("HcFilesDeletedPerDiskFree"), IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_MIN_FILE_SIZE_FOR_COMP    ,_T("HcMinFileSizeForComp"),       IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_COMPRESSION_DLL           ,_T("HcCompressionDll"),           IIS_MD_UT_SERVER, EXPANDSZ_METADATA},
    {/**/MD_HC_FILE_EXTENSIONS           ,_T("HcFileExtensions"),           IIS_MD_UT_SERVER, MULTISZ_METADATA},
    {/**/MD_HC_MIME_TYPE                 ,_T("HcMimeType"),                 IIS_MD_UT_SERVER, STRING_METADATA},
    {/**/MD_HC_PRIORITY                  ,_T("HcPriority"),                 IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_DYNAMIC_COMPRESSION_LEVEL ,_T("HcDynamicCompressionLevel"),  IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_ON_DEMAND_COMP_LEVEL      ,_T("HcOnDemandCompLevel"),        IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_HC_CREATE_FLAGS              ,_T("HcCreateFlags"),              IIS_MD_UT_SERVER, DWORD_METADATA},
// Job Object Site Properties
    {/**/MD_CPU_LIMITS_ENABLED           ,_T("CpuLimitsEnabled"),           METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CPU_RESET_INTERVAL           ,_T("CpuResetInterval"),           METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CPU_LOGGING_INTERVAL         ,_T("CpuLoggingInterval"),         METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CPU_LOGGING_OPTIONS          ,_T("CpuLoggingOptions"),          METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CPU_LOGGING_MASK             ,_T("CpuLoggingMask"),             METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CPU_CGI_LIMIT                ,_T("CpuCgiLimit"),                METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CPU_LIMIT_LOGEVENT           ,_T("CpuLimitLogEvent"),           METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CPU_LIMIT_PRIORITY           ,_T("CpuLimitPriority"),           METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CPU_LIMIT_PROCSTOP           ,_T("CpuLimitProcStop"),           METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CPU_LIMIT_PAUSE              ,_T("CpuLimitPause"),              METADATA_INHERIT,IIS_MD_UT_SERVER, DWORD_METADATA},
// Job Object per file properties
    {/**/MD_CPU_CGI_ENABLED              ,_T("CpuCgiEnabled"),              METADATA_INHERIT,IIS_MD_UT_FILE, DWORD_METADATA},
    {/**/MD_CPU_APP_ENABLED              ,_T("CpuAppEnabled"),              METADATA_INHERIT,IIS_MD_UT_FILE, DWORD_METADATA},
    {/**/MD_CERT_CHECK_MODE              ,_T("CertCheckMode"),              METADATA_INHERIT,IIS_MD_UT_SERVER,DWORD_METADATA},


// Virtual root properties - note MD_ACCESS_PERM is also generally set at
// the virtual directory.  These are used for both HTTP and FTP
    {/**/MD_VR_PATH                   ,_T("VrPath"),                    METADATA_INHERIT,IIS_MD_UT_FILE,STRING_METADATA},
    {/**/MD_VR_USERNAME               ,_T("VrUsername"),                METADATA_INHERIT,IIS_MD_UT_FILE,STRING_METADATA},
    {/**/MD_VR_PASSWORD               ,_T("VrPassword") ,           METADATA_INHERIT|METADATA_SECURE,IIS_MD_UT_FILE,     STRING_METADATA},
    {/**/MD_VR_ACL                    ,_T("VrAcl"),                 METADATA_INHERIT,IIS_MD_UT_FILE,BINARY_METADATA},
// This is used to flag down updated vr entries - Used for migrating vroots
    {/**/MD_VR_UPDATE                    ,_T("VrUpdate"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_FILE,DWORD_METADATA},
//  Logging related attributes
    {MD_LOG_TYPE                      ,_T("LogType"),                   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGFILE_DIRECTORY            ,_T("LogFileDirectory"),           METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGFILE_PERIOD               ,_T("LogFilePeriod"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGFILE_TRUNCATE_SIZE        ,_T("LogFileTruncateSize"),        METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGSQL_DATA_SOURCES          ,_T("LogSqlDataSources"),          METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGSQL_TABLE_NAME            ,_T("LogSqlTableName"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGSQL_USER_NAME             ,_T("LogSqlUserName"),             METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGSQL_PASSWORD              ,_T("LogSqlPassword"),             METADATA_SECURE,IIS_MD_UT_FILE,DWORD_METADATA},
//  {MD_LOG_CLSID                       ,_T("LogClsid"),                   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
//  {MD_LOG_STATE                       ,_T("LogState"),                   METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGEXT_FIELD_MASK               ,_T("ExtLogFieldMask"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOGEXT_FIELD_MASK2              ,_T("ExtLogFieldMask2"),           METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {MD_LOG_PLUGIN_ORDER                ,_T("LogPluginOrder"),             METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
//  These are FTP specific properties
    {/**/MD_EXIT_MESSAGE                 ,_T("ExitMessage"),                METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_GREETING_MESSAGE             ,_T("GreetingMessage"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,/*!!*/MULTISZ_METADATA},
    {/**/MD_MAX_CLIENTS_MESSAGE          ,_T("MaxClientsMessage"),      METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_MSDOS_DIR_OUTPUT             ,_T("MSDOSDirOutput"),         METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_ALLOW_ANONYMOUS              ,_T("AllowAnonymous"),         METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_ANONYMOUS_ONLY               ,_T("AnonymousOnly"),              METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_LOG_ANONYMOUS                ,_T("LogAnonymous"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_LOG_NONANONYMOUS             ,_T("LogNonAnonymous"),            METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
//  These are SSL specific properties
    {/**/MD_SSL_PUBLIC_KEY               ,_T("SslPublicKey"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,BINARY_METADATA},
    {/**/MD_SSL_PRIVATE_KEY              ,_T("SslPrivateKey"),          METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,BINARY_METADATA},
    {/**/MD_SSL_KEY_PASSWORD             ,_T("SslKeyPassword"),         METADATA_SECURE,IIS_MD_UT_SERVER,BINARY_METADATA},
    {/**/MD_SSL_KEY_REQUEST             ,_T("SslKeyRequest"),         METADATA_SECURE,IIS_MD_UT_SERVER,BINARY_METADATA},
    {/**/MD_SSL_FRIENDLY_NAME           ,_T("SslFriendlyName"),         METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_IDENT                   ,_T("SslIdent"),                 METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
//FTP specific
    {MD_SHOW_4_DIGIT_YEAR          ,_T("FtpDirBrowseShowLongDate"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},

//
// These are server certificate properties
//
    {/**/MD_SSL_CERT_HASH                ,_T("SslCertHash"),         METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,BINARY_METADATA},
    {/**/MD_SSL_CERT_CONTAINER           ,_T("SslCertContainer"),    METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_PROVIDER            ,_T("SslCertProvider"),     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_PROVIDER_TYPE       ,_T("SslCertProviderType"),     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_SSL_CERT_OPEN_FLAGS          ,_T("SslCertOpenFlags"),     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_STORE_NAME          ,_T("SslCertStoreName"),     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
//
// These are Certificate Trust List properties
//
    {/**/MD_SSL_CTL_IDENTIFIER          ,_T("SslCtlIdentifier"),    METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CTL_CONTAINER           ,_T("SslCtlContainer"),     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CTL_PROVIDER            ,_T("SslCtlProvider"),      METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CTL_PROVIDER_TYPE       ,_T("SslCtlProviderType"),  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_SSL_CTL_OPEN_FLAGS          ,_T("SslCtlOpenFlags"),     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CTL_STORE_NAME          ,_T("SslCtlStoreName"),     METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CTL_SIGNER_HASH         ,_T("SslCtlSignerHash"),    METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
//
// Metabase property that defines whether to use DS mapper or not
//
    {/**/MD_SSL_USE_DS_MAPPER           ,_T("SslUseDSMapper"),     METADATA_INHERIT,IIS_MD_UT_FILE,DWORD_METADATA},
//
// Metabase property that holds SSL replication information
//
    {/**/MD_SSL_REPLICATION_INFO        ,_T("SslReplicationInfo"),  METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,STRING_METADATA},
//
// Metabase properties that are used by the CertWiz ActiveX control, that
// is used for the Certificate/CTL UI management tool
//
    {/**/MD_SSL_CERT_ENROLL_HISTORY     ,_T("SslCertEnrollHistory"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_ENROLL_TIME        ,_T("SslCertEnrollTime"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_ENROLL_STATE       ,_T("SslCertEnrollState"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_ENROLL_STATE_ERROR ,_T("SslCertEnrollStateError"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},

//
// Metabase properties used for Fortezza certificates
//
    {/**/MD_SSL_CERT_IS_FORTEZZA        ,_T("IsFortezza"), METADATA_NO_ATTRIBUTES,IIS_MD_UT_SERVER,DWORD_METADATA},
    {/**/MD_SSL_CERT_FORTEZZA_PIN       ,_T("FortezzaPin"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER     ,_T("FortezzaPin"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_FORTEZZA_PERSONALITY       ,_T("FortezzaPersonality"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_FORTEZZA_PROG_PIN          ,_T("FortezzaProgPin"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},

//
// Metabase properties that are used by the CertWiz ActiveX control to keep
// track of the user's entry history, and whether DEBUG is enabled.  We keep
// these private properties on a per VS basis.
//

    {/**/MD_SSL_CERT_WIZ_DEBUG                  ,_T("WizDebug"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_TARGET_CA       ,_T("WizhistTargetCA"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_FILE_NAME_USED_LAST     ,_T("WizhistFileNameUsedLast"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_DN_COMMON_NAME  ,_T("WizhistCN"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_DN_O            ,_T("WizhistO"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_DN_OU           ,_T("WizhistOU"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_DN_C            ,_T("WizhistC"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_DN_L            ,_T("WizhistL"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_DN_S            ,_T("WizhistS"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_USER_NAME       ,_T("WizhistUserName"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_USER_PHONE      ,_T("WizhistUserPhone"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZHIST_SZ_USER_EMAIL      ,_T("WizhistUserEmail"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},

    {/**/MD_SSL_CERT_WIZGUID_ICERTGETCONFIG     ,_T("WizguidICERTGETCONFIG"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZGUID_ICERTREQUEST       ,_T("WizguidICERTREQUEST"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},
    {/**/MD_SSL_CERT_WIZGUID_XENROLL            ,_T("WizguidXENROLL"),  METADATA_INHERIT,IIS_MD_UT_SERVER,STRING_METADATA},

//  File and Directory related properties - these should be added in the
//  metabase with a user type of IIS_MD_UT_FILE
    {/**/MD_AUTHORIZATION                ,_T("Authorization"),              METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_AUTHORIZATION_PERSISTENCE    ,_T("AuthorizationPersistence"),   METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_REALM                        ,_T("Realm"),                      METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {/**/MD_HTTP_EXPIRES                 ,_T("HttpExpires"),                METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {/**/MD_HTTP_PICS                    ,_T("HtpPics"),                    METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {/**/MD_HTTP_CUSTOM                  ,_T("HttpCustom"),             METADATA_INHERIT,   IIS_MD_UT_FILE,MULTISZ_METADATA},
    {/**/MD_DIRECTORY_BROWSING           ,_T("DirectoryBrowsing"),          METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_DEFAULT_LOAD_FILE            ,_T("DefaultLoadFile"),            METADATA_INHERIT,   IIS_MD_UT_FILE,/**/STRING_METADATA},
    {MD_CONTENT_NEGOTIATION          ,    _T("ContentNegotiation"),     METADATA_INHERIT    ,IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_CUSTOM_ERROR                 ,_T("CustomError"),                METADATA_INHERIT,   IIS_MD_UT_FILE,MULTISZ_METADATA},
    {/**/MD_FOOTER_DOCUMENT              ,_T("FooterDocument"),         METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    /**/{MD_FOOTER_ENABLED               ,_T("FooterEnabled"),              METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_HTTP_REDIRECT                    ,_T("HttpRedirect"),               METADATA_NO_ATTRIBUTES,IIS_MD_UT_FILE,STRING_METADATA},
    {/**/MD_DEFAULT_LOGON_DOMAIN         ,_T("DefaultLogonDomain"), METADATA_INHERIT,      IIS_MD_UT_FILE,STRING_METADATA},
    {/**/MD_LOGON_METHOD                 ,_T("LogonMethod"),            METADATA_INHERIT,      IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_SCRIPT_MAPS                     ,_T("ScriptMaps"),              METADATA_INHERIT,IIS_MD_UT_FILE,MULTISZ_METADATA},
    {MD_SCRIPT_TIMEOUT                     ,_T("ScriptTimeout"),        METADATA_INHERIT,IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_MIME_MAP                     ,_T("MimeMap"),                    METADATA_INHERIT,IIS_MD_UT_FILE,MULTISZ_METADATA},
    {/**/MD_ACCESS_PERM                  ,_T("AccessPerm"),             METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_SSL_ACCESS_PERM          ,_T("SslAccessPerm"),             METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_IP_SEC                       ,_T("IpSec")   ,                   METADATA_INHERIT,IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_ANONYMOUS_USER_NAME          ,_T("AnonymousUserName"),      METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {/**/MD_ANONYMOUS_PWD                ,_T("AnonymousPwd"),               METADATA_INHERIT|METADATA_SECURE,IIS_MD_UT_FILE,STRING_METADATA},
    {MD_ANONYMOUS_USE_SUBAUTH        ,_T("AnonymousUseSubAuth"),        METADATA_INHERIT,IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_DONT_LOG                     ,_T("DontLOG"),                    METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_ADMIN_ACL                    ,_T("AdminAcl"),                   METADATA_INHERIT,   IIS_MD_UT_FILE,BINARY_METADATA},
    {MD_SSI_EXEC_DISABLED                ,_T("SSIExecDisabled"),            METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_DO_REVERSE_DNS                   ,_T("DoReverseDns"),               METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_WIN32_ERROR                  ,_T("Win32Error"),            0,   IIS_MD_UT_FILE,DWORD_METADATA},
    {MD_ALLOW_REPLACE_ON_RENAME          ,_T("AllowReplaceOnRename"),       METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, DWORD_METADATA},
    {/**/MD_CC_NO_CACHE                  ,_T("CacheControlNoCache"),             METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_CC_MAX_AGE                  ,_T("CacheControlMaxAge"),             METADATA_INHERIT,   IIS_MD_UT_FILE,DWORD_METADATA},
    {/**/MD_CC_OTHER                  ,_T("CacheControlOther"),             METADATA_INHERIT,   IIS_MD_UT_FILE,STRING_METADATA},
    {MD_FRONTPAGE_WEB          ,_T("FrontPageWeb"),       METADATA_INHERIT, IIS_MD_UT_SERVER, DWORD_METADATA},
    {MD_IS_CONTENT_INDEXED      ,_T("IsContentIndexed"),       METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},
    {MD_ISM_ACCESS_CHECK          ,_T("IsmAccessCheck"),       METADATA_NO_ATTRIBUTES, IIS_MD_UT_FILE, DWORD_METADATA},


////////ASP and WAM params

        { MD_ASP_BUFFERINGON                  , _T("AspBufferingOn"),           METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_LOGERRORREQUESTS             , _T("AspLogErrorRequests"),      METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_SCRIPTERRORSSENTTOBROWSER    , _T("AspScriptErrorSentToBrowser"),METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_SCRIPTERRORMESSAGE           , _T("AspScriptErrorMessage"),METADATA_INHERIT, ASP_MD_UT_APP, STRING_METADATA},
        { MD_ASP_SCRIPTFILECACHESIZE          , _T("AspScriptFileCacheSize"),METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_SCRIPTENGINECACHEMAX         , _T("AspScriptEngineCacheMax"),METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_SCRIPTTIMEOUT                , _T("AspScriptTimeout"),         METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_SESSIONTIMEOUT               , _T("AspSessionTimeout"),        METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_ENABLEPARENTPATHS            , _T("AspEnableParentPaths"), METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_MEMFREEFACTOR                , _T("AspMemFreeFactor"),         METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_MINUSEDBLOCKS                , _T("AspMinUseDblocks"),         METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_ALLOWSESSIONSTATE            , _T("AspAllowSessionState"),     METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_SCRIPTLANGUAGE               , _T("AspScriptLanguage")         ,METADATA_INHERIT, ASP_MD_UT_APP, STRING_METADATA},
        { MD_ASP_QUEUETIMEOUT                 , _T("AspQueueTimeout")           ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        //{ MD_ASP_STARTCONNECTIONPOOL          , _T("AspStartConnectionPool"),METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_ALLOWOUTOFPROCCMPNTS         , _T("AspAllowOutOfProcComponents"),METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_EXCEPTIONCATCHENABLE         , _T("AspExceptionCatchEnable"),METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_CODEPAGE                     , _T("AspCodepage")                       ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_SCRIPTLANGUAGELIST           , _T("AspScriptLanguages")        ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_ENABLESERVERDEBUG                        , _T("AspEnableServerDebug")  ,METADATA_INHERIT,ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_ENABLECLIENTDEBUG                        , _T("AspEnableClientDebug")  ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_TRACKTHREADINGMODEL              , _T("AspTrackThreadingModel") ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},

        // new 5.0 ASP params
        { MD_ASP_ENABLEASPHTMLFALLBACK        , _T("AspEnableAspHTMLFallback") ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_ENABLECHUNKEDENCODING        , _T("AspEnableChunkedEncoding") ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_ENABLETYPELIBCACHE           , _T("AspEnableTypeLibCache")    ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_ERRORSTONTLOG                , _T("AspErrorsToNTLog")         ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_PROCESSORTHREADMAX           , _T("AspProcessorThreadMax")    ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_REQEUSTQUEUEMAX              , _T("AspRequestQueueMax")       ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_ENABLEAPPLICATIONRESTART     , _T("AspEnableApplicationRestart") ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_QUEUECONNECTIONTESTTIME      , _T("AspQueueConnectionTestTime") ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_SESSIONMAX                   , _T("AspSessionMax")            ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_KEEPSESSIONIDSECURE          , _T("AspKeepSessionIDSecure")   ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},     

        // Thread gate params
        { MD_ASP_THREADGATEENABLED            , _T("AspThreadGateEnabled")     ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_THREADGATETIMESLICE          , _T("AspThreadGateTimeSlice")   ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_THREADGATESLEEPDELAY         , _T("AspThreadGateSleepDelay")  ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_THREADGATESLEEPMAX           , _T("AspThreadGateSleepMax")    ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_THREADGATELOADLOW            , _T("AspThreadGateLoadLow")     ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_ASP_THREADGATELOADHIGH           , _T("AspThreadGateLoadHigh")    ,METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},

        // persist template cache....
        { MD_ASP_DISKTEMPLATECACHEDIRECTORY   , _T("AspDiskTemplateCacheDirectory"),METADATA_INHERIT, IIS_MD_UT_WAM, EXPANDSZ_METADATA},
        { MD_ASP_MAXDISKTEMPLATECACHEFILES    , _T("AspMaxDiskTemplateCacheFiles"),METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},

        { MD_ASP_EXECUTEINMTA                 , _T("AspExecuteInMTA"),METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},

        { MD_ASP_LCID                         , _T("AspLCID")                  ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},

        { MD_ASP_SERVICE_FLAGS                , _T("AspAppServiceFlags")       ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_SERVICE_FLAG_TRACKER         , _T("AspEnableTracker")         ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_SERVICE_FLAG_FUSION          , _T("AspEnableSxs")             ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_SERVICE_FLAG_PARTITIONS      , _T("AspUsePartition")          ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},
        { MD_ASP_SERVICE_PARTITION_ID         , _T("AspPartitionID")           ,METADATA_INHERIT, ASP_MD_UT_APP, DWORD_METADATA},

        //////// WAM params
        //{ MD_APP_COMMAND                  , _T("AppCommand") ,        METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        //{ MD_APP_STATUS                   , _T("AppStatus")  ,        METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        //{ MD_APP_ERRORCODE                , _T("AppErrorCode"),       METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_APP_ROOT                     , _T("AppRoot"),              METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA},
        { MD_APP_ISOLATED                 , _T("AppIsolated"),  METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        { MD_APP_WAM_CLSID                , _T("AppWamClsid"),  METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA},
        { MD_APP_PACKAGE_ID               , _T("AppPackageId"), METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA},
        { MD_APP_PACKAGE_NAME             , _T("ApPackageName"),METADATA_INHERIT, IIS_MD_UT_WAM, STRING_METADATA},
        { MD_APP_LAST_OUTPROC_PID         , _T("AppLastOutprocId"),     METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
  //{ MD_APP_WAM_RUNTIME_FLAG         , _T("AppWamRuntimmeFlag"),METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},
        //{ MD_APP_OOP_CRASH_LIMIT                , _T("AppOopCrashLimit"),METADATA_INHERIT, IIS_MD_UT_WAM, DWORD_METADATA},

        { MD_VR_NO_CACHE,                   _T("NoCache"),      METADATA_INHERIT, IIS_MD_UT_FILE, DWORD_METADATA},

        {0,0}
};


DWORD MapPropertyNameToCode(const CString & strName)
{
    return tPropertyNameTable::MapNameToCode(strName);
}

// function finds the record within given property name table,
// with the name equal to parameter lpszName
tPropertyNameTable * tPropertyNameTable::FindRecord(const CString strName, tPropertyNameTable * PropertyNameTable)
{
    for(int i=0; PropertyNameTable[i].lpszName!=0;i++)
    {
        if( strName.CompareNoCase(PropertyNameTable[i].lpszName)==0)
            return PropertyNameTable+i;
    }
    return 0;
}

tPropertyNameTable * tPropertyNameTable::FindRecord(DWORD dwCode, tPropertyNameTable * PropertyNameTable)
{
    if(dwCode==0)
            return NULL;
    for(int i=0; PropertyNameTable[i].lpszName!=0;i++)
    {
        if( dwCode==PropertyNameTable[i].dwCode)
            return PropertyNameTable+i;
    }
    return 0;
}

DWORD tPropertyNameTable::MapNameToCode(const CString & strName, tPropertyNameTable * PropertyNameTable)
{
    for(int i=0; PropertyNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(PropertyNameTable[i].lpszName)==0)
            return PropertyNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}

CString tPropertyNameTable::MapCodeToName(DWORD dwCode, tPropertyNameTable * PropertyNameTable)
{
    for(int i=0; PropertyNameTable[i].lpszName!=0;i++)
    {
        if(dwCode == PropertyNameTable[i].dwCode)
            return PropertyNameTable[i].lpszName;
    }
    return _T("");
}


//**********************************************************************
// PROPERTY ATTRIB NAME TABLE  IMPLEMENTATION
//**********************************************************************


//constants defined in imd.h
struct tAttribNameTable gAttribNameTable[]=
{
    {METADATA_NO_ATTRIBUTES, _T("NO_ATTRIBUTES")},
    {METADATA_INHERIT, _T("INHERIT")},
    {METADATA_PARTIAL_PATH, _T("PARTIAL_PATH")},
    {METADATA_SECURE,_T("SECURE")},
    {METADATA_INSERT_PATH,_T("INSERT_PATH")},
//  {METADATA_REFERENCE,_T("REFERENCE")},
//  {METADATA_MASTER_ROOT_HANDLE, _T("MASTER_ROOT_HANDLE")},
//the end
    {0,0}
};

DWORD MapAttribNameToCode(const CString & strName)
{
    return tAttribNameTable::MapNameToCode(strName);
}


DWORD tAttribNameTable::MapNameToCode(const CString& strName, tAttribNameTable * AttribNameTable)
{
    for(int i=0; AttribNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(AttribNameTable[i].lpszName)==0)
            return AttribNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}


//**********************************************************************
// PROPERTY DATA TYPE NAME TABLE MPLEMENTATION
//**********************************************************************

//constants defined in imd.h
tDataTypeNameTable  gDataTypeNameTable[]=
{
    {DWORD_METADATA,    _T("DWORD")},
    {STRING_METADATA,   _T("STRING")},
    {BINARY_METADATA,   _T("BINARY")},
    {EXPANDSZ_METADATA, _T("EXPANDSZ")},
    {MULTISZ_METADATA,  _T("MULTISZ")},
//the end
    {0,0}
};

DWORD MapDataTypeNameToCode(const CString & strName)
{
    return tDataTypeNameTable::MapNameToCode(strName);
}


DWORD tDataTypeNameTable::MapNameToCode(const CString& strName, tDataTypeNameTable * DataTypeNameTable)
{
    for(int i=0; DataTypeNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(DataTypeNameTable[i].lpszName)==0)
            return DataTypeNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}

CString tDataTypeNameTable::MapCodeToName(DWORD a_dwCode, tDataTypeNameTable * DataTypeNameTable)
{
    for(int i=0; DataTypeNameTable[i].lpszName!=0;i++)
    {
        if(a_dwCode==DataTypeNameTable[i].dwCode)
            return DataTypeNameTable[i].lpszName;
    }
    return _T("");
}


//**********************************************************************
// PROPERTY USER TYPE NAME TABLE  IMPLEMENTATION
//**********************************************************************

//constants defined in iiscnfg.h
struct tUserTypeNameTable gUserTypeNameTable[]=
{
    {IIS_MD_UT_SERVER, _T("UT_SERVER")},
    {IIS_MD_UT_FILE, _T("UT_FILE")},
    {IIS_MD_UT_WAM,  _T("UT_WAM")},
    {ASP_MD_UT_APP,  _T("UT_APP")},
//the end
    {0,0}

};

DWORD MapUserTypeNameToCode(const CString & strName)
{
    return tUserTypeNameTable::MapNameToCode(strName);
}


DWORD tUserTypeNameTable::MapNameToCode(const CString& strName, tUserTypeNameTable * UserTypeNameTable)
{
    for(int i=0; UserTypeNameTable[i].lpszName!=0;i++)
    {
        if(strName.CompareNoCase(UserTypeNameTable[i].lpszName)==0)
            return UserTypeNameTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}



//**********************************************************************
// PROPERTY PREDEFINED VALUES TABLE IMPLEMENTATION
//**********************************************************************

//constants defined in iiscnfg.h

//Predefined values table
struct tValueTable gValueTable[]=
{
//  Valid values for MD_AUTHORIZATION
    {MD_AUTH_ANONYMOUS               ,_T("Anonymous"),  MD_AUTHORIZATION},
    {MD_AUTH_BASIC                   ,_T("Basic"),      MD_AUTHORIZATION},
    {MD_AUTH_NT                      ,_T("NT"),     MD_AUTHORIZATION},
    {MD_AUTH_MD5                     ,_T("MD5"),        MD_AUTHORIZATION},
    {MD_AUTH_MAPBASIC                ,_T("MapBasic"),   MD_AUTHORIZATION},
//  Valid values for MD_ACCESS_PERM
    {MD_ACCESS_READ                  ,_T("Read"),   MD_ACCESS_PERM},
    {MD_ACCESS_WRITE                 ,_T("Write"),  MD_ACCESS_PERM},
    {MD_ACCESS_EXECUTE               ,_T("Execute"),    MD_ACCESS_PERM},
    {MD_ACCESS_SSL                   ,_T("SSL"),        MD_ACCESS_PERM},// Require SSL
    {MD_ACCESS_NEGO_CERT             ,_T("NegoCert"),   MD_ACCESS_PERM},// Allow client SSL certs
    {MD_ACCESS_REQUIRE_CERT          ,_T("RequireCert"),MD_ACCESS_PERM},// Require client SSL certs
    {MD_ACCESS_MAP_CERT              ,_T("MapCert"),MD_ACCESS_PERM},// Map SSL cert to NT account
    {MD_ACCESS_SSL128                ,_T("SSL128"), MD_ACCESS_PERM},// Require 128 bit SSL
    {MD_ACCESS_SCRIPT                ,_T("Script"), MD_ACCESS_PERM},// Script
    {MD_ACCESS_NO_REMOTE_READ        ,_T("NoRemoteRead"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_WRITE       ,_T("NoRemoteWrite"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_EXECUTE     ,_T("NoRemoteExecute"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_SCRIPT      ,_T("NoRemoteScript"), MD_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_MASK                  ,_T("MaskAll"),    MD_ACCESS_PERM},
//  Valid values for MD_SSL_ACCESS_PERM
    {MD_ACCESS_READ                  ,_T("Read"),   MD_SSL_ACCESS_PERM},
    {MD_ACCESS_WRITE                 ,_T("Write"),  MD_SSL_ACCESS_PERM},
    {MD_ACCESS_EXECUTE               ,_T("Execute"),    MD_SSL_ACCESS_PERM},
    {MD_ACCESS_SSL                   ,_T("SSL"),        MD_SSL_ACCESS_PERM},// Require SSL
    {MD_ACCESS_NEGO_CERT             ,_T("NegoCert"),   MD_SSL_ACCESS_PERM},// Allow client SSL certs
    {MD_ACCESS_REQUIRE_CERT          ,_T("RequireCert"),MD_SSL_ACCESS_PERM},// Require client SSL certs
    {MD_ACCESS_MAP_CERT              ,_T("MapCert"),MD_SSL_ACCESS_PERM},// Map SSL cert to NT account
    {MD_ACCESS_SSL128                ,_T("SSL128"), MD_SSL_ACCESS_PERM},// Require 128 bit SSL
    {MD_ACCESS_SCRIPT                ,_T("Script"), MD_SSL_ACCESS_PERM},// Script
    {MD_ACCESS_NO_REMOTE_READ        ,_T("NoRemoteRead"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_WRITE       ,_T("NoRemoteWrite"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_EXECUTE     ,_T("NoRemoteExecute"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_NO_REMOTE_SCRIPT      ,_T("NoRemoteScript"), MD_SSL_ACCESS_PERM},// NO_REMOTE only
    {MD_ACCESS_MASK                  ,_T("MaskAll"),    MD_SSL_ACCESS_PERM},
//  Valid values for MD_DIRECTORY_BROWSING
    {MD_DIRBROW_SHOW_DATE            ,_T("Date"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_SHOW_TIME            ,_T("Time"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_SHOW_SIZE            ,_T("Size"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_SHOW_EXTENSION       ,_T("Extension"), MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_LONG_DATE            ,_T("LongDate"),   MD_DIRECTORY_BROWSING},
    {MD_DIRBROW_ENABLED              ,_T("Enabled"),   MD_DIRECTORY_BROWSING},// Allow directory browsing
    {MD_DIRBROW_LOADDEFAULT          ,_T("LoadDefault"),MD_DIRECTORY_BROWSING},// Load default doc if exists
    {MD_DIRBROW_MASK                 ,_T("MaskAll"),        MD_DIRECTORY_BROWSING},
//  Valid values for MD_LOGON_METHOD
    {MD_LOGON_INTERACTIVE    ,_T("Interactive"),    MD_LOGON_METHOD, tValueTable::TYPE_EXCLUSIVE},
    {MD_LOGON_BATCH          ,_T("Batch"),      MD_LOGON_METHOD, tValueTable::TYPE_EXCLUSIVE},
    {MD_LOGON_NETWORK        ,_T("Network"),        MD_LOGON_METHOD, tValueTable::TYPE_EXCLUSIVE},
//  Valid values for MD_FILTER_STATE
    {MD_FILTER_STATE_LOADED          ,_T("Loaded"), MD_FILTER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_FILTER_STATE_UNLOADED        ,_T("Unloaded"),   MD_FILTER_STATE,    tValueTable::TYPE_EXCLUSIVE },
//  Valid values for MD_FILTER_FLAGS
    {/*SF_NOTIFY_SECURE_PORT*/0x00000001         ,_T("SecurePort"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_NONSECURE_PORT*/0x00000002      ,_T("NonSecurePort"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_READ_RAW_DATA*/0x000008000      ,_T("ReadRawData"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_PREPROC_HEADERS*/0x00004000     ,_T("PreprocHeaders"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_AUTHENTICATION*/0x00002000      ,_T("Authentication"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_URL_MAP*/0x00001000             ,_T("UrlMap"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_ACCESS_DENIED*/0x00000800       ,_T("AccessDenied"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_SEND_RESPONSE*/0x00000040       ,_T("SendResponse"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_SEND_RAW_DATA*/0x00000400       ,_T("SendRawData"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_LOG*/0x00000200                 ,_T("NotifyLog"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_END_OF_REQUEST*/0x00000080      ,_T("EndOfRequest"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_END_OF_NET_SESSION*/0x00000100  ,_T("EndOfNetSession"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_AUTHENTICATIONEX*/  0x20000000  ,_T("AuthenticationX"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_REQUEST_SECURITY_CONTEXT_CLOSE*/0x10000000,_T("RequestSecurityContextClose"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_RENEGOTIATE_CERT*/0x08000000,   _T("RenegotiateCert"), MD_FILTER_FLAGS},

    {/*SF_NOTIFY_ORDER_HIGH*/0x00080000   ,_T("OrderHigh"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_ORDER_MEDIUM*/0x00040000   ,_T("OrderMedium"), MD_FILTER_FLAGS},
    {/*SF_NOTIFY_ORDER_LOW*/0x00020000   ,_T("OrderLow"), MD_FILTER_FLAGS},

//  Valid values for MD_SERVER_STATE
    {MD_SERVER_STATE_STARTING        ,_T("Starting"),   MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_STARTED         ,_T("Started"),    MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_STOPPING        ,_T("Stopping"),   MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_STOPPED         ,_T("Stopped"),    MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_PAUSING         ,_T("Pausing"),    MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_PAUSED          ,_T("Paused"),     MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_STATE_CONTINUING      ,_T("Continuing"), MD_SERVER_STATE,    tValueTable::TYPE_EXCLUSIVE},
//  Valid values for MD_SERVER_COMMAND
    {MD_SERVER_COMMAND_START         ,_T("Start"),      MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_COMMAND_STOP          ,_T("Stop"),       MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_COMMAND_PAUSE         ,_T("Pause"),      MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_COMMAND_CONTINUE      ,_T("Continue"),   MD_SERVER_COMMAND,  tValueTable::TYPE_EXCLUSIVE},
//  Valid values for MD_SERVER_SIZE
    {MD_SERVER_SIZE_SMALL            ,_T("Small"),  MD_SERVER_SIZE, tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_SIZE_MEDIUM           ,_T("Medium"), MD_SERVER_SIZE, tValueTable::TYPE_EXCLUSIVE},
    {MD_SERVER_SIZE_LARGE            ,_T("Large"),  MD_SERVER_SIZE, tValueTable::TYPE_EXCLUSIVE},
// valid values for MD_CERT_CHECK_MODE
    {MD_CERT_NO_REVOC_CHECK	     ,_T("NoRevocCheck"), MD_CERT_CHECK_MODE},
    //{APPCMD_NONE, _T("None"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_VERIFY, _T("Verify"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_GETSTATUS, _T("GetStatus"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CREATE, _T("Create"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CREATEINPROC, _T("CreateInProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CREATEOUTPROC, _T("CreateOutProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CHANGETOINPROC, _T("ChangeToInProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_CHANGETOOUTPROC, _T("ChangeToOutProc"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_DELETE, _T("Delete"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},
    //{APPCMD_UNLOAD, _T("Unload"),MD_APP_COMMAND, tValueTable::TYPE_EXCLUSIVE},

    //{APPSTATUS_Error, _T("Error"),            MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Created, _T("Created"),        MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Deleted, _T("Deleted"),        MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_UnLoaded, _T("Unloaded"),      MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Killed, _T("Killed"),  MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Running, _T("Running"),        MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_Stopped, _T("Stopped"),        MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_NoApplication, _T("NoApplication"),    MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},
    //{APPSTATUS_AppSubNode, _T("AppSubNode"),  MD_APP_STATUS, tValueTable::TYPE_EXCLUSIVE},


// NEED LOGGING Updates
#if 0
    {MD_LOGTYPE_NONE     ,_T("LOGTYPE_NONE")},
    {MD_LOGTYPE_FILE     ,_T("LOGTYPE_FILE")},
    {MD_LOGTYPE_ODBC     ,_T("LOGTYPE_ODBC")},
    {MD_LOGFILE_PERIOD_MAXSIZE   ,_T("LOGFILE_PERIOD_MAXSIZE")},
    {MD_LOGFILE_PERIOD_DAILY     ,_T("LOGFILE_PERIOD_DAILY")},
    {MD_LOGFILE_PERIOD_WEEKLY    ,_T("LOGFILE_PERIOD_WEEKLY")},
    {MD_LOGFILE_PERIOD_MONTHLY   ,_T("LOGFILE_PERIOD_MONTHLY")},
#endif
//the end
    {0,0}
};

DWORD  MapValueNameToCode(const CString & strName,DWORD dwRelatedPropertyCode)
{
    return tValueTable::MapNameToCode(strName, dwRelatedPropertyCode);
}


DWORD  tValueTable::MapNameToCode(const CString& strName, DWORD dwRelatedPropertyCode, tValueTable * ValueTable)
{
    for(int i=0; ValueTable[i].lpszName!=0;i++)
    {
        if((strName.CompareNoCase(ValueTable[i].lpszName)==0) && ValueTable[i].dwRelatedPropertyCode==dwRelatedPropertyCode)
            return ValueTable[i].dwCode;
    }
    return NAME_NOT_FOUND;
}

CString  tValueTable::MapValueContentToString(DWORD dwValueContent, DWORD dwRelatedPropertyCode, tValueTable * ValueTable)
{
    CString strResult=_T("");
    for(int i=0; ValueTable[i].lpszName!=0;i++)
    {
        if(ValueTable[i].dwRelatedPropertyCode==dwRelatedPropertyCode)
        {
            if(ValueTable[i].dwFlags==tValueTable::TYPE_EXCLUSIVE)
            {
                if (ValueTable[i].dwCode == dwValueContent)
                    return ValueTable[i].lpszName;
            }
            else if ((ValueTable[i].dwCode & dwValueContent) == ValueTable[i].dwCode)
            {
                strResult = strResult + ValueTable[i].lpszName + _T(" ");
            }

        }
    }
    strResult.TrimRight();
    return strResult;
}


//prints info about what is stored in tables so that user can see the predefined names and values

void PrintTablesInfo(void)
{
    //Print supported property names
    _tprintf(_T("***The following list of property names (IIS parameters) is supported:\n"));
    _tprintf(_T("------------------------------------------------------------------------------\n"));
    _tprintf(_T("%-25s: \t%-10s %s\n"),_T("Property Name"), _T("Data type"), _T("Attributes and User Type"));
    _tprintf(_T("\t\t--Predefined Values\n"));
    _tprintf(_T("------------------------------------------------------------------------------\n"));
    for(int i=0; gPropertyNameTable[i].lpszName!=NULL; i++)
    {
       _tprintf(_T("%-25s: \t%-10s "),gPropertyNameTable[i].lpszName,
            LPCTSTR(_T("(")+tDataTypeNameTable::MapCodeToName(gPropertyNameTable[i].dwDefDataType)+_T(")")));
        if( (METADATA_INHERIT & gPropertyNameTable[i].dwDefAttributes) == METADATA_INHERIT)
        {   _tprintf(_T("INHERIT\t"));
        }
        if( (IIS_MD_UT_SERVER & gPropertyNameTable[i].dwDefUserType) == IIS_MD_UT_SERVER)
        {   _tprintf(_T("UT_SERVER\t"));
        }

        if( (IIS_MD_UT_FILE & gPropertyNameTable[i].dwDefUserType) == IIS_MD_UT_FILE)
        {   _tprintf(_T("UT_FILE "));
        }

        _tprintf(_T("\n"));

        //print list of applicable values

        for(int j=0; gValueTable[j].lpszName!=NULL;j++)
        {
            if( gValueTable[j].dwRelatedPropertyCode==gPropertyNameTable[i].dwCode)
            {
                _tprintf(_T("\t\t %-15s (=0x%x)\n"),gValueTable[j].lpszName,gValueTable[j].dwCode);

            }
        }
    }
    _tprintf(_T("\n***The following list of user types (for IIS parameters) is supported:\n"));
    for(i=0; gUserTypeNameTable[i].lpszName!=NULL; i++)
    {
        _tprintf(_T("%s "),gUserTypeNameTable[i].lpszName);
    }

    _tprintf(_T("\n\n***The following list of data types (for IIS parameters) is supported:\n"));
    for(i=0; gDataTypeNameTable[i].lpszName!=NULL; i++)
    {
        _tprintf(_T("%s  "),gDataTypeNameTable[i].lpszName);
    }
    _tprintf(_T("\n\n***The following list of attributes (for IIS parameters) is supported:\n"));
    for( i=0; gAttribNameTable[i].lpszName!=NULL; i++)
    {
        _tprintf(_T("%s  "),gAttribNameTable[i].lpszName);
    }
    _tprintf(_T("\n"));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\extend\extcom.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    extcom.cxx

Abstract:

    IIS Services IISADMIN Extension
    Main COM interface.
    Class CadmExt
    CLSID = CLSID_W3EXTEND
    IID = IID_IADMEXT

Author:

    Michael W. Thomas            16-Sep-97

--*/

#include <cominc.hxx>

#ifndef _NO_TRACING_
DECLARE_DEBUG_PRINTS_OBJECT();
#include <initguid.h>
DEFINE_GUID(IisExtComGuid, 
0x784d8925, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#endif

CAdmExt::CAdmExt():
    m_dwRefCount(0),
    m_pcCom(NULL),
    m_dwSinkCookie(0),
    m_pConnPoint(NULL)
{
}

CAdmExt::~CAdmExt()
{
#ifndef _NO_TRACING_
    DELETE_DEBUG_PRINT_OBJECT();
#endif
}

HRESULT
CAdmExt::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IADMEXT) {
        *ppObject = (IADMEXT *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CAdmExt::AddRef()
{
    DWORD dwRefCount;
    InterlockedIncrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CAdmExt::Release()
{
    DWORD dwRefCount;
    InterlockedDecrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // This is now a member of class factory.
    // It is not dynamically allocated, so don't delete it.
    //
/*
    if (dwRefCount == 0) {
        delete this;
        return 0;
    }
*/
    return dwRefCount;
}


HRESULT STDMETHODCALLTYPE
CAdmExt::Initialize(void)
{
    HRESULT hresReturn;
#ifdef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( "SVCEXT" );
#else
    CREATE_DEBUG_PRINT_OBJECT("SVCEXT", IisExtComGuid);
#endif

    hresReturn = CoCreateInstance(CLSID_MDCOM,
                                  NULL,
                                  CLSCTX_SERVER,
                                  IID_IMDCOM,
                                  (void**) &m_pcCom);
    if (SUCCEEDED(hresReturn)) {

        //
        // First, set the state of all servers to Stopped.
        //

        SetServerState(L"/LM/W3SVC");
        SetServerState(L"/LM/MSFTPSVC");

        //
        // Set up a sink for special processing.
        //

        IConnectionPointContainer* pConnPointContainer = NULL;
        BOOL bSinkConnected = FALSE;
        CSvcExtImpIMDCOMSINK *pEventSink = new CSvcExtImpIMDCOMSINK(m_pcCom);

        if (pEventSink != NULL) {

            // First query the object for its Connection Point Container. This
            // essentially asks the object in the server if it is connectable.
            hresReturn = m_pcCom->QueryInterface(
                   IID_IConnectionPointContainer,
                   (PVOID *)&pConnPointContainer);
            if SUCCEEDED(hresReturn)
            {
              // Find the requested Connection Point. This AddRef's the
              // returned pointer.
              hresReturn = pConnPointContainer->FindConnectionPoint(IID_IMDCOMSINK_W, &m_pConnPoint);
              if (SUCCEEDED(hresReturn)) {
                  hresReturn = m_pConnPoint->Advise((IUnknown *)pEventSink, &m_dwSinkCookie);
              }
                
              pConnPointContainer->Release();
            }

            pEventSink->Release();
        }
        else {
            hresReturn = E_OUTOFMEMORY;
        }
    }

    UpdateUsers();

    return hresReturn;
}


HRESULT STDMETHODCALLTYPE
CAdmExt::EnumDcomCLSIDs(
    /* [size_is][out] */ CLSID *pclsidDcom,
    /* [in] */ DWORD dwEnumIndex)
{
    return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
}

HRESULT STDMETHODCALLTYPE
CAdmExt::Terminate(void)
{
    if (m_pcCom != NULL) {
        if (m_pConnPoint != NULL) {
            if (m_dwSinkCookie != 0) {
                m_pConnPoint->Unadvise(m_dwSinkCookie);
            }
            m_pConnPoint->Release();
        }
        m_pcCom->Release();
    }

    return S_OK;
}

VOID
CAdmExt::SetServerState(
    LPWSTR pszPath)
{
    HRESULT hresReturn, hresTempReturn;
    TCHAR pszNameBuf[METADATA_MAX_NAME_LEN];
    int i;
    METADATA_RECORD mdrData;
    DWORD dwData;
    DWORD dwRequiredDataLen;
    METADATA_HANDLE mdhCurrent;

    hresReturn = m_pcCom->ComMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE,
                                            pszPath,
                                            METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                                            OPEN_TIMEOUT_VALUE,
                                            &mdhCurrent);

    if (SUCCEEDED(hresReturn)) {

        for (i=0;hresReturn == ERROR_SUCCESS;i++) {

            //
            // enumerate children
            //

            hresReturn = m_pcCom->ComMDEnumMetaObjects(mdhCurrent,
                                                     TEXT(""),
                                                     pszNameBuf,
                                                     i);

            if (SUCCEEDED(hresReturn)) {

                MD_SET_DATA_RECORD_EXT(&mdrData,
                                       MD_SERVER_STATE,
                                       METADATA_NO_ATTRIBUTES,
                                       0,
                                       DWORD_METADATA,
                                       sizeof(DWORD),
                                       (PBYTE)&dwData)

                //
                // See if Server State exists at this node,
                // and pick up the current attributes, etc.
                //

                hresTempReturn = m_pcCom->ComMDGetMetaData(mdhCurrent,
                                                        pszNameBuf,
                                                        &mdrData,
                                                        &dwRequiredDataLen);

                //
                // PREFIX
                // ComMDGetMetaData should not return success without setting the data
                // value pointed to by dwData. I'm not sure if PREFIX is incapable of
                // recognizing the extra level of indirection or if there is some path
                // that I missed in reviewing ComMDGetMetaData. I'm going to shut down
                // this warning, but I'll open an issue with the PREFIX guys.
                //

                /* INTRINSA suppress = uninitialized */
                if ((SUCCEEDED(hresTempReturn)) && (dwData != MD_SERVER_STATE_STOPPED)) {

                    //
                    // Set the new data
                    //

                    dwData = MD_SERVER_STATE_STOPPED;
                    hresTempReturn = m_pcCom->ComMDSetMetaData(mdhCurrent,
                                                             pszNameBuf,
                                                             &mdrData);
                }
            }
        }

        hresReturn = m_pcCom->ComMDCloseMetaObject(mdhCurrent);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\extend\cofact.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cofact.cxx

Abstract:

    IIS Services IISADMIN Extension
    Class Factory and Registration.
    CLSID = CLSID_W3EXTEND

Author:

    Michael W. Thomas            16-Sep-97

--*/

//
// Do not include cominc.hxx, as it sets Unicode, which breaks registration on Win95
//

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <ole2.h>
#include <windows.h>
#include <olectl.h>
#include <stdio.h>
#include <imd.h>
#include <iadmext.h>
#include <coimp.hxx>

CAdmExtSrvFactory::CAdmExtSrvFactory()
    :m_admextObject()
{
    m_dwRefCount=0;
    g_dwRefCount = 0;
    //
    // Addref object, so refcount doesn't go to 0 if all clients release.
    //
    m_admextObject.AddRef();
}

CAdmExtSrvFactory::~CAdmExtSrvFactory()
{
    m_admextObject.Release();
}
HRESULT
CAdmExtSrvFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void ** ppObject)
{
    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }
    if (FAILED(m_admextObject.QueryInterface(riid, ppObject))) {
        return E_NOINTERFACE;
    }
    return NO_ERROR;
}

HRESULT
CAdmExtSrvFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        InterlockedIncrement((long *)&g_dwRefCount);
    }
    else {
        InterlockedDecrement((long *)&g_dwRefCount);
    }
    return NO_ERROR;
}

HRESULT
CAdmExtSrvFactory::QueryInterface(REFIID riid, void **ppObject)
{
    if (riid==IID_IUnknown || riid == IID_IClassFactory) {
            *ppObject = (IClassFactory *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CAdmExtSrvFactory::AddRef()
{
    DWORD dwRefCount;
    InterlockedIncrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CAdmExtSrvFactory::Release()
{
    DWORD dwRefCount;
    InterlockedDecrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // There must only be one copy of this. So keep the first one around regardless.
    //
    //    if (dwRefCount == 0) {
    //        delete this;
    //    }
    return dwRefCount;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppObject)
{
    if (rclsid != CLSID_W3EXTEND) {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    if (FAILED(g_aesFactory.QueryInterface(riid, ppObject))) {
        *ppObject = NULL;
        return E_INVALIDARG;
    }
    return NO_ERROR;
}

HRESULT _stdcall DllCanUnloadNow() {
        if (g_dwRefCount) {
                return S_FALSE;
                }
        else {
                return S_OK;
                }
}

STDAPI DllRegisterServer(void)
{
    HKEY hKeyCLSID, hKeyInproc32;
    DWORD dwDisposition;
    HMODULE hModule;
    DWORD dwReturn = ERROR_SUCCESS;

    dwReturn = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                              TEXT("CLSID\\{FCC764A0-2A38-11d1-B9C6-00A0C922E750}"),
                              NULL,
                              TEXT(""),
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKeyCLSID,
                              &dwDisposition);
    if (dwReturn == ERROR_SUCCESS) {
        dwReturn = RegSetValueEx(hKeyCLSID,
                                 TEXT(""),
                                 NULL,
                                 REG_SZ,
                                 (BYTE*) TEXT("IIS Servers Extension"),
                                 sizeof(TEXT("IIS Servers Extension")));
        if (dwReturn == ERROR_SUCCESS) {
            dwReturn = RegCreateKeyEx(hKeyCLSID,
                "InprocServer32",
                NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                &hKeyInproc32, &dwDisposition);

            if (dwReturn == ERROR_SUCCESS) {
                hModule=GetModuleHandle(TEXT("SVCEXT.DLL"));
                if (!hModule) {
                    dwReturn = GetLastError();
                }
                else {
                    TCHAR szName[MAX_PATH+1];
                    if (GetModuleFileName(hModule,
                                          szName,
                                          sizeof(szName)) == NULL) {
                        dwReturn = GetLastError();
                    }
                    else {
                        dwReturn = RegSetValueEx(hKeyInproc32,
                                                 TEXT(""),
                                                 NULL,
                                                 REG_SZ,
                                                 (BYTE*) szName,
                                                 sizeof(TCHAR)*(lstrlen(szName)+1));
                        if (dwReturn == ERROR_SUCCESS) {
                            dwReturn = RegSetValueEx(hKeyInproc32,
                                                     TEXT("ThreadingModel"),
                                                     NULL,
                                                     REG_SZ,
                                                     (BYTE*) TEXT("Both"),
                                                     sizeof(TEXT("Both")));
                        }
                    }
                }
                RegCloseKey(hKeyInproc32);
            }
        }
        RegCloseKey(hKeyCLSID);
    }

    if (dwReturn == ERROR_SUCCESS) {

        dwReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                  IISADMIN_EXTENSIONS_REG_KEYA
                                  "\\{FCC764A0-2A38-11d1-B9C6-00A0C922E750}",
                                  NULL,
                                  "",
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKeyCLSID,
                                  &dwDisposition);

        if (dwReturn == ERROR_SUCCESS) {
            RegCloseKey(hKeyCLSID);
        }

    }

    return HRESULT_FROM_WIN32(dwReturn);
}

STDAPI DllUnregisterServer(void)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwTemp;

    dwTemp = RegDeleteKey(HKEY_CLASSES_ROOT,
                          TEXT("CLSID\\{FCC764A0-2A38-11d1-B9C6-00A0C922E750}\\InprocServer32"));
    if (dwTemp != ERROR_SUCCESS) {
        dwReturn = dwTemp;
    }
    dwTemp = RegDeleteKey(HKEY_CLASSES_ROOT,
                          TEXT("CLSID\\{FCC764A0-2A38-11d1-B9C6-00A0C922E750}"));
    if (dwTemp != ERROR_SUCCESS) {
        dwReturn = dwTemp;
    }
    dwTemp = RegDeleteKey(HKEY_LOCAL_MACHINE,
                          IISADMIN_EXTENSIONS_REG_KEY
                              TEXT("\\{FCC764A0-2A38-11d1-B9C6-00A0C922E750}"));
    if (dwTemp != ERROR_SUCCESS) {
        dwReturn = dwTemp;
    }
    return HRESULT_FROM_WIN32(dwReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\extend\globals.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    globals.cxx

Abstract:

    IIS Services IISADMIN Extension
    Global Variables

Author:

    Michael W. Thomas            16-Sep-97

--*/

#define INITGUID

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <ole2.h>
#include <windows.h>
#include <olectl.h>
#include <stdio.h>
#include <iadmext.h>
#include <coimp.hxx>


ULONG g_dwRefCount;
CAdmExtSrvFactory g_aesFactory;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\extend\logevent.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    logevent.cxx

Abstract:

    Simple function creating isntance of Event_LOG object
    I need a separate file for that because API for constructor takes
    only ANSI string and can't be called from unicode CPP file

Author:

    Kestutis Patiejunas           05-12-99

--*/
#include <eventlog.hxx>



extern EVENT_LOG *g_eventLogForAccountRecreation; 

BOOL CreateEventLogObject()
{
	g_eventLogForAccountRecreation = new EVENT_LOG("IISADMIN");
	return 	(g_eventLogForAccountRecreation != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\extend\resource.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    checker.cxx

Abstract:

    IIS Services IISADMIN Extension
    Unicode Metadata Sink.

Author:

    Michael W. Thomas            11-19-98

--*/

#ifndef _resource_h
#define _resource_h

#define IDS_USER_COMMENT                1
#define IDS_USER_FULLNAME               2
#define IDS_WAMUSER_COMMENT             3
#define IDS_WAMUSER_FULLNAME            4
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\extend\sink.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sink.cxx

Abstract:

    IIS Services IISADMIN Extension
    Unicode Metadata Sink.

Author:

    Michael W. Thomas            16-Sep-97

--*/
#include <cominc.hxx>

//extern HANDLE          hevtDone;

#define REG_FP_LOAD_VALUE         "NewFPWebCmdLine"
#define REG_FP_UNLOAD_VALUE       "DelFPWebCmdLine"

#ifdef _NO_TRACING_
DECLARE_DEBUG_PRINTS_OBJECT();
#endif

CSvcExtImpIMDCOMSINK::CSvcExtImpIMDCOMSINK(IMDCOM * pcCom):
    m_dwRefCount(1),
    m_pcCom(pcCom)
{
}

CSvcExtImpIMDCOMSINK::~CSvcExtImpIMDCOMSINK()
{
}

HRESULT
CSvcExtImpIMDCOMSINK::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IMDCOMSINK_W) {
        *ppObject = (IMDCOMSINKW *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CSvcExtImpIMDCOMSINK::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CSvcExtImpIMDCOMSINK::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}

#define SCHEMA_PATH_PREFIX IIS_MD_ADSI_SCHEMA_PATH_W L"/"

HRESULT STDMETHODCALLTYPE
CSvcExtImpIMDCOMSINK::ComMDSinkNotify(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ])
{
    DWORD i, j;
    for (i = 0; i < dwMDNumElements; i++) {
        if (((pcoChangeList[i].dwMDChangeType | MD_CHANGE_TYPE_SET_DATA) != 0) &&

            //
            // If this is a schema change, then don't do anything
            //

            (_wcsnicmp(pcoChangeList[i].pszMDPath,
                       SCHEMA_PATH_PREFIX,
                       ((sizeof(SCHEMA_PATH_PREFIX) / sizeof(WCHAR)) - 1)) != 0)) {

            for (j = 0; j < pcoChangeList[i].dwMDNumDataIDs; j++) {
                switch (pcoChangeList[i].pdwMDDataIDs[j]) {
                case MD_FRONTPAGE_WEB:
                    {
                        RegisterFrontPage( pcoChangeList[i].pszMDPath );
                        break;
                    }
                case MD_SERVER_COMMAND:
                    {
                        ProcessServerCommand(pcoChangeList[i].pszMDPath);
                        break;
                    }
                default:
                    ;

                    //
                    // No specific action for this command
                    //
                }
            }
        }
    }
    return S_OK;
}



#define REG_KEY_W3SVC_VROOTS    TEXT("SYSTEM\\CurrentControlSet\\Services\\W3SVC\\Parameters\\Virtual Roots")
#define REG_KEY_MSFTPSVC_VROOTS TEXT("SYSTEM\\CurrentControlSet\\Services\\MSFTPSVC\\Parameters\\Virtual Roots")


HRESULT STDMETHODCALLTYPE
CSvcExtImpIMDCOMSINK::ComMDEventNotify(
    /* [in] */ DWORD dwMDEvent)
{
    DWORD err;

    if (dwMDEvent == MD_EVENT_MID_RESTORE) {
        //
        // Blow away registry VRoots so they won't be brought back to life
        //
        err = RegDeleteKey(HKEY_LOCAL_MACHINE, REG_KEY_W3SVC_VROOTS);
        if ( err != ERROR_SUCCESS ) {
            DBGINFOW((DBG_CONTEXT,
                      L"[ComMDEventNotify] (%x) Couldn't remove W3SVC VRoot key\n",
                      err  ));
        }

        err = RegDeleteKey(HKEY_LOCAL_MACHINE, REG_KEY_MSFTPSVC_VROOTS);
        if ( err != ERROR_SUCCESS ) {
            DBGINFOW((DBG_CONTEXT,
                      L"[ComMDEventNotify] (%x) Couldn't remove MSFTPSVC VRoot key\n",
                      err  ));
        }

    }

    //
    // Sync up the user accounts with those from the metabase
    //

    UpdateUsers( TRUE );

    return S_OK;
}

//
// This must be in a non-Unicode file so that registry reads on Win95 work.
//


VOID
CSvcExtImpIMDCOMSINK::RegisterFrontPage(
    LPWSTR   pszPath
    )
{
    HKEY     hkey = NULL;
    CHAR     buff[255];
    CHAR     cmd[512];
    CHAR     achPath[512];
    LPSTR    pszOp;
    DWORD    cbBuff = sizeof( buff );
    DWORD    dwType;
    DWORD dwValue;
    DWORD dwRequiredDataLen;
    HRESULT hresReturn;
    METADATA_RECORD mdrData;

    MD_SET_DATA_RECORD_EXT(&mdrData,
                           MD_FRONTPAGE_WEB,
                           METADATA_NO_ATTRIBUTES,
                           ALL_METADATA,
                           DWORD_METADATA,
                           sizeof(DWORD),
                           (PBYTE)&dwValue)

    hresReturn = m_pcCom->ComMDGetMetaData(METADATA_MASTER_ROOT_HANDLE,
                                           pszPath,
                                           &mdrData,
                                           &dwRequiredDataLen);

    if (FAILED(hresReturn)) {
        if (hresReturn != MD_ERROR_DATA_NOT_FOUND) {
            DBGINFOW((DBG_CONTEXT,
                      L"[RegisterFrontPage] GetData Failed, return code = %X\n",
                      hresReturn));
        }
    }
    else {

        DBGINFOW(( DBG_CONTEXT,
                    L"[RegisterFrontPage] Value - %d, Path - %S\n",
                    dwValue,
                    pszPath ));

        //
        // PREFIX
        // ComMDGetMetaData should not return success without setting the data
        // value pointed to by dwValue. I'm not sure if PREFIX is incapable of
        // recognizing the extra level of indirection or if there is some path
        // that I missed in reviewing ComMDGetMetaData. I'm going to shut down
        // this warning, but I'll open an issue with the PREFIX guys.
        //

        /* INTRINSA suppress = uninitialized */
        pszOp = dwValue ? REG_FP_LOAD_VALUE : REG_FP_UNLOAD_VALUE;


        if ( !RegOpenKeyExA( HKEY_LOCAL_MACHINE,
                            REG_FP_PATH,
                            0,
                            KEY_READ,
                            &hkey )   &&
             !RegQueryValueExA( hkey,
                               pszOp,
                               NULL,
                               &dwType,
                               (BYTE *) &buff,
                               &cbBuff ))
        {

            if ( WideCharToMultiByte( CP_ACP,
                                      0,
                                      pszPath,
                                      -1,
                                      achPath,
                                      sizeof(achPath),
                                      NULL,
                                      NULL ) == 0 )
            {
                DBGINFOW((DBG_CONTEXT,
                          L"Failed to convert path to Ansi, error = %d\n",
                          GetLastError() ));
            }

            else {

                //
                // FrontPage cannot handle trailing slash, so remove it.
                // Need to restore as this is not a local copy of path.
                //

                DWORD dwPathLen = strlen(achPath);

                DBG_ASSERT(achPath[dwPathLen - 1] == '/');

                achPath[dwPathLen - 1] = '\0';

                if ( (strlen( buff ) + (dwPathLen - 1)) < sizeof( cmd ) )
                {
                    STARTUPINFOA StartupInfo;
                    PROCESS_INFORMATION ProcessInformation;
                    BOOL CreateProcessStatus;
                    DWORD ErrorCode;

                    sprintf( cmd, buff, achPath );

                    RtlZeroMemory(&StartupInfo,sizeof(StartupInfo));
                    StartupInfo.cb = sizeof(StartupInfo);
                    StartupInfo.dwFlags = 0;
                    StartupInfo.wShowWindow = 0;
                    CreateProcessStatus = CreateProcessA(
                                            NULL,
                                            cmd,
                                            NULL,
                                            NULL,
                                            FALSE,
                                            0,
                                            NULL,
                                            NULL,
                                            &StartupInfo,
                                            &ProcessInformation );

                    if ( CreateProcessStatus )
                    {
                        DBG_REQUIRE( CloseHandle(ProcessInformation.hProcess) );
                        DBG_REQUIRE( CloseHandle(ProcessInformation.hThread) );
                    }
                    else
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                    "[RegisterFrontPage] CreateProcess returned %d for %s\n",
                                    GetLastError(),
                                    cmd ));
                    }

                }
            }

        } else {

            DBGINFOW((DBG_CONTEXT,
                      L"[RegisterFrontPage] Failed to open reg or read value\n"));
        }

        if ( hkey )
        {
            RegCloseKey( hkey );
        }
    }
}

VOID
CSvcExtImpIMDCOMSINK::ProcessServerCommand(
    LPWSTR   pszPath
    )
{
    HKEY     hkey = NULL;
    WCHAR    pszServiceName[METADATA_MAX_NAME_LEN];
    DWORD    dwType;
    DWORD dwValue;
    DWORD dwRequiredDataLen;
    HRESULT hresReturn;
    METADATA_RECORD mdrData;

    MD_SET_DATA_RECORD_EXT(&mdrData,
                           MD_SERVER_COMMAND,
                           METADATA_NO_ATTRIBUTES,
                           ALL_METADATA,
                           DWORD_METADATA,
                           sizeof(DWORD),
                           (PBYTE)&dwValue)

    hresReturn = m_pcCom->ComMDGetMetaData(METADATA_MASTER_ROOT_HANDLE,
                                           pszPath,
                                           &mdrData,
                                           &dwRequiredDataLen);

    if (FAILED(hresReturn)) {
        DBGINFOW((DBG_CONTEXT,
                  L"[ProcessServerCommand] GetData Failed, return code = %X\n",
                  hresReturn));
    }
    else {

        //
        // PREFIX
        // ComMDGetMetaData should not return success without setting the data
        // value pointed to by dwValue. I'm not sure if PREFIX is incapable of
        // recognizing the extra level of indirection or if there is some path
        // that I missed in reviewing ComMDGetMetaData. I'm going to shut down
        // this warning, but I'll open an issue with the PREFIX guys.
        //

        /* INTRINSA suppress = uninitialized */
        if (dwValue == MD_SERVER_COMMAND_START) {
            if (GetServiceNameFromPath(pszPath,
                                       pszServiceName)) {
                StartIISService(pszServiceName);

            }
        }
    }

}

#define SERVICE_NAME_PREFIX L"/LM/"

BOOL
GetServiceNameFromPath(
    LPWSTR       pszPath,
    LPWSTR       pszServiceName
    )
/*++

Routine Description:

    Start an IIS service

Arguments:
    pszPath - path spcifying which IIS service to start
    pszServiceName - updated with service name

Return Value:
    TRUE - Success
    FALSE - Failure

--*/
{
    LPWSTR          pszPathIndex;
    UINT            cS;

    DBG_ASSERT(pszPath != NULL);
    DBG_ASSERT(pszServiceName != NULL);

    pszPathIndex = pszPath;
    if ((_wcsnicmp( pszPathIndex, \
                    SERVICE_NAME_PREFIX,
                    ((sizeof(SERVICE_NAME_PREFIX) / sizeof(WCHAR)) - 1)) == 0) &&
        (pszPath[(sizeof(SERVICE_NAME_PREFIX) / sizeof(WCHAR)) - 1] != (WCHAR)'\0')) {

        pszPathIndex += ((sizeof(SERVICE_NAME_PREFIX) / sizeof(WCHAR)) -1);

        //
        // copy to temp buffer until path delim
        //

        for ( cS = 0 ; cS < METADATA_MAX_NAME_LEN-1 &&
                       (*pszPathIndex != (WCHAR)'/'); )
        {
            pszServiceName[cS++] = *pszPathIndex++;
        }
        pszServiceName[cS] = (WCHAR)'\0';

        return TRUE;
    }

    return FALSE;
}

VOID
StartIISService(
    LPWSTR       pszServiceName
    )
/*++

Routine Description:

    Start an IIS service

Arguments:
    pszServiceName - specify which IIS service to start

Return Value:
    TRUE - Success
    FALSE - Failure

--*/
{
    SC_HANDLE       scManagerHandle;
    SC_HANDLE       serviceHandle;
    DWORD           errorCode;
    DWORD           iPoll;
    SERVICE_STATUS  ss;

    DBG_ASSERT(pszServiceName != NULL);

    if ( IISGetPlatformType() == PtWindows95 )

    {
        //
        // Start service Win95-style
        //


        if ( !IsInetinfoRunning() )
        {
            if ( _wcsicmp( pszServiceName, L"W3SVC" ) == 0 )
            {
                // We only can start W3SVC on Win95

                if ( !W95StartW3SVC() )
                {
                    DBGINFOW((DBG_CONTEXT,
                              L"[StartIISService] W95StartW3SVC Failed\n"));
                }
            }
        }
    }

    else

    {
        //
        // Start service WinNT-style
        //

        //
        // Open the service control manager
        //

        scManagerHandle = OpenSCManager( NULL,        // local machine
                                         NULL,        // ServicesActive database
                                         SC_MANAGER_ALL_ACCESS ); // all access

        if ( scManagerHandle != NULL ) {

            //
            // Open the service
            //

            serviceHandle = OpenService( scManagerHandle,
                                         pszServiceName,
                                         SERVICE_START );

            if ( serviceHandle != NULL ) {

                //
                // Make sure the service is running
                //

                if (!StartService( serviceHandle,
                                   0,
                                   NULL) &&
                    (GetLastError() != ERROR_SERVICE_ALREADY_RUNNING)) {
                    DBGINFOW(( DBG_CONTEXT,
                                L"[StartIISService] StartService(%s) Failed, Error = %X\n",
                                pszServiceName,
                                GetLastError()));
                }

                CloseServiceHandle( serviceHandle );
            }

            //
            // Close open handle
            //

            CloseServiceHandle( scManagerHandle);

        }

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\extend\iis51\checker.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    checker.cxx

Abstract:

    IIS Services IISADMIN Extension
    Unicode Metadata Sink.

Author:

    Michael W. Thomas            11-19-98

--*/
#include <cominc.hxx>
#include <lmaccess.h>
#include <lmserver.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <ntlsa.h>
#include <time.h>

#include <ntsam.h>
#include <netlib.h>
#include <resource.h>

#define SECURITY_WIN32
#define ISSP_LEVEL  32
#define ISSP_MODE   1
#include <sspi.h>
#include <sspi.h>
#include <eventlog.hxx>
#include "extend.h"

#include <comadmin.h>

typedef TCHAR USERNAME_STRING_TYPE[MAX_PATH];
typedef TCHAR PASSWORD_STRING_TYPE[LM20_PWLEN+1];

typedef enum {
    GUFM_SUCCESS,
    GUFM_NO_PATH,
    GUFM_NO_PASSWORD,
    GUFM_NO_USER_ID
} GUFM_RETURN;

BOOL  ValidatePassword(IN LPCTSTR UserName,IN LPCTSTR Domain,IN LPCTSTR Password);
void  InitLsaString(PLSA_UNICODE_STRING LsaString,LPWSTR String);
DWORD GetPrincipalSID (LPCTSTR Principal,PSID *Sid,BOOL *pbWellKnownSID);
DWORD OpenPolicy(LPTSTR ServerName,DWORD DesiredAccess,PLSA_HANDLE PolicyHandle);
DWORD AddRightToUserAccount(LPCTSTR szAccountName, LPTSTR PrivilegeName);
DWORD DoesUserHaveThisRight(LPCTSTR szAccountName, LPTSTR PrivilegeName,BOOL *fHaveThatRight);
HRESULT UpdateComApplications(IMDCOM * pcCom,LPCTSTR szWamUserName,LPCTSTR szWamUserPass);
int   IsDomainController(void);
BOOL  WaitForDCAvailability(void);


// these two lines for logging event about account recreation
EVENT_LOG *g_eventLogForAccountRecreation = NULL; 
BOOL CreateEventLogObject();



VOID  UpdateUserRights (LPCTSTR  account,LPTSTR pstrRights[],DWORD dwNofRights)
{
    DWORD status;
    BOOL  fPresence;

    
    for (DWORD i=0;i<dwNofRights;i++)
    {
        
        
        status = DoesUserHaveThisRight(account,pstrRights[i],&fPresence);
        if (!NT_SUCCESS(status))
        {
            DBGPRINTF(( DBG_CONTEXT,"[UpdateAnonymousUser] DoesUserHaveThisRight returned err=0x%0X for account %s right %s\n",status,account,pstrRights[i]));
        }
        else
        {
            if (!fPresence)
            {
                status = AddRightToUserAccount(account,pstrRights[i]);
                if (!NT_SUCCESS(status))
                {
                    DBGPRINTF(( DBG_CONTEXT,"[UpdateAnonymousUser] AddRightToUserAccount returned err=0x%0X for account %s right %s\n",status,account,pstrRights[i]));
                }
            }
        }
    }
}

DWORD AddRightToUserAccount(LPCTSTR szAccountName, LPTSTR PrivilegeName)
{
    BOOL fEnabled = FALSE;
    NTSTATUS status;
	LSA_UNICODE_STRING UserRightString;
    LSA_HANDLE PolicyHandle = NULL;

    // Create a LSA_UNICODE_STRING for the privilege name.
    InitLsaString(&UserRightString, PrivilegeName);

    // get the sid of szAccountName
    PSID pSID = NULL;
    BOOL bWellKnownSID = FALSE;

    status = GetPrincipalSID ((LPTSTR)szAccountName, &pSID, &bWellKnownSID);

    if (status != ERROR_SUCCESS) 
    {
        DBGPRINTF(( DBG_CONTEXT,"[AddRightToUserAccount] GetPrincipalSID returned err=0x%0X\n",status));
        return (status);
    }


    status = OpenPolicy(NULL, POLICY_ALL_ACCESS,&PolicyHandle);
    if ( status == NERR_Success )
    {
		UINT i;
        LSA_UNICODE_STRING *rgUserRights = NULL;
		ULONG cRights;
	
		status = LsaAddAccountRights (
				 PolicyHandle,
				 pSID,
				 &UserRightString,
				 1);
    }

    if (PolicyHandle)
    {
        LsaClose(PolicyHandle);
    }
    if (pSID) 
    {
        if (bWellKnownSID)
        {
            FreeSid (pSID);
        }
        else
        {
            free (pSID);
        }
    }
    return status;
}



DWORD DoesUserHaveThisRight(LPCTSTR szAccountName, LPTSTR PrivilegeName,BOOL *fHaveThatRight)
{
    BOOL fEnabled = FALSE;
    NTSTATUS status;
	LSA_UNICODE_STRING UserRightString;
    LSA_HANDLE PolicyHandle = NULL;


    *fHaveThatRight = FALSE;

    // Create a LSA_UNICODE_STRING for the privilege name.
    InitLsaString(&UserRightString, PrivilegeName);

    // get the sid of szAccountName
    PSID pSID = NULL;
    BOOL bWellKnownSID = FALSE;

    status = GetPrincipalSID ((LPTSTR)szAccountName, &pSID, &bWellKnownSID);

    if (status != ERROR_SUCCESS) 
    {
        return status;
    }


    status = OpenPolicy(NULL, POLICY_ALL_ACCESS,&PolicyHandle);
    if ( status == NERR_Success )
    {
		UINT i;
        LSA_UNICODE_STRING *rgUserRights = NULL;
		ULONG cRights;
	
		status = LsaEnumerateAccountRights(
				 PolicyHandle,
				 pSID,
				 &rgUserRights,
				 &cRights);

		if (status==STATUS_OBJECT_NAME_NOT_FOUND)
        {
			// no rights/privileges for this account
            status = ERROR_SUCCESS;
			fEnabled = FALSE;
		}
		else if (!NT_SUCCESS(status)) 
        {
            //iisDebugOut((LOG_TYPE_ERROR, _T("DoesUserHaveBasicRights:GetPrincipalSID:Failed to enumerate rights: status 0x%08lx\n"), status));
			goto DoesUserHaveBasicRights_Exit;
		}

		for(i=0; i < cRights; i++) 
        {
            if ( RtlEqualUnicodeString(&rgUserRights[i],&UserRightString,FALSE) ) 
            {
                fEnabled = TRUE;
                break;
            }
		}
		
        if (rgUserRights) 
        {
            LsaFreeMemory(rgUserRights);
        }
    }

DoesUserHaveBasicRights_Exit:

    if (PolicyHandle)
    {
        LsaClose(PolicyHandle);
    }
    if (pSID) 
    {
        if (bWellKnownSID)
        {
            FreeSid (pSID);
        }
        else
        {
            free (pSID);
        }
    }

    *fHaveThatRight = fEnabled;
    return status;
}



DWORD
GetCurrentUserSID (
    PSID *Sid
    )
{
    DWORD dwReturn = ERROR_SUCCESS;
    TOKEN_USER  *tokenUser = NULL;
    HANDLE      tokenHandle = NULL;
    DWORD       tokenSize;
    DWORD       sidLength;

    if (OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &tokenHandle))
    {
        GetTokenInformation (tokenHandle, TokenUser, tokenUser, 0, &tokenSize);

        tokenUser = (TOKEN_USER *) malloc (tokenSize);
        if (!tokenUser)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return GetLastError();
        }

        if (GetTokenInformation (tokenHandle, TokenUser, tokenUser, tokenSize, &tokenSize))
        {
            sidLength = GetLengthSid (tokenUser->User.Sid);
            *Sid = (PSID) malloc (sidLength);
            if (*Sid)
            {
                memcpy (*Sid, tokenUser->User.Sid, sidLength);
            }
            CloseHandle (tokenHandle);
        } else
            dwReturn = GetLastError();

        if (tokenUser)
            free(tokenUser);

    } else
        dwReturn = GetLastError();

    return dwReturn;
}

DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    )
{
    PACL    dacl;
    DWORD   sidLength;
    PSID    sid = NULL;
    PSID    groupSID;
    PSID    ownerSID;
    DWORD   returnValue;

    *SD = NULL;

    returnValue = GetCurrentUserSID (&sid);
    if (returnValue != ERROR_SUCCESS) {
        if (sid)
            free(sid);
        return returnValue;
    }

    sidLength = GetLengthSid (sid);

    *SD = (SECURITY_DESCRIPTOR *) malloc (
        (sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength) +
        (2 * sidLength) +
        sizeof (SECURITY_DESCRIPTOR));
    if (!*SD)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return GetLastError();
    }

    groupSID = (SID *) (*SD + 1);
    ownerSID = (SID *) (((BYTE *) groupSID) + sidLength);
    dacl = (ACL *) (((BYTE *) ownerSID) + sidLength);

    if (!InitializeSecurityDescriptor (*SD, SECURITY_DESCRIPTOR_REVISION))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!InitializeAcl (dacl,
                        sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength,
                        ACL_REVISION2))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!AddAccessAllowedAce (dacl,
                              ACL_REVISION2,
                              COM_RIGHTS_EXECUTE,
                              sid))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!SetSecurityDescriptorDacl (*SD, TRUE, dacl, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    memcpy (groupSID, sid, sidLength);
    if (!SetSecurityDescriptorGroup (*SD, groupSID, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    memcpy (ownerSID, sid, sidLength);
    if (!SetSecurityDescriptorOwner (*SD, ownerSID, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (sid)
        free(sid);
    return ERROR_SUCCESS;
}

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD
    )
{
    DWORD               returnValue;
    HKEY                registryKey;
    DWORD               valueType;
    DWORD               valueSize = 0;

    *NewSD = FALSE;

    //
    // Get the security descriptor from the named value. If it doesn't
    // exist, create a fresh one.
    //

    returnValue = RegOpenKeyEx (RootKey, KeyName, 0, KEY_ALL_ACCESS, &registryKey);

    if (returnValue != ERROR_SUCCESS)
    {
        if (returnValue == ERROR_FILE_NOT_FOUND)
        {
            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) {
                if (*SD)
                    free(*SD);
                return returnValue;
            }

            *NewSD = TRUE;
            return ERROR_SUCCESS;
        } else
            return returnValue;
    }

    returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, NULL, &valueSize);

    if (returnValue && returnValue != ERROR_INSUFFICIENT_BUFFER)
    {
        *SD = NULL;
        returnValue = CreateNewSD (SD);
        if (returnValue != ERROR_SUCCESS) {
            if (*SD)
                free(*SD);
            return returnValue;
        }

        *NewSD = TRUE;
    } else
    {
        *SD = (SECURITY_DESCRIPTOR *) malloc (valueSize);
        if (!*SD)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return GetLastError();
        }

        returnValue = RegQueryValueEx (registryKey,
                                       ValueName,
                                       NULL,
                                       &valueType,
                                       (LPBYTE) *SD,
                                       &valueSize);
        if (returnValue)
        {
            if (*SD)
                free (*SD);

            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) {
                if (*SD)
                    free(*SD);
                return returnValue;
            }

            *NewSD = TRUE;
        }
    }

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
GetPrincipalSID (
    LPCTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    )
{

    DWORD returnValue=ERROR_SUCCESS;
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority;
    BYTE Count;
    DWORD dwRID[8];
    TCHAR pszPrincipal[MAX_PATH];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));

    DBG_ASSERT(wcslen(Principal) < MAX_PATH);
    wcscpy(pszPrincipal, Principal);
    _wcslwr(pszPrincipal);
    if ( wcsstr(pszPrincipal, TEXT("administrators")) != NULL ) {
        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;
    } else if ( wcsstr(pszPrincipal, TEXT("system")) != NULL) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;
    } else if ( wcsstr(pszPrincipal, TEXT("interactive")) != NULL) {
        // INTERACTIVE
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;
    } else if ( wcsstr(pszPrincipal, TEXT("everyone")) != NULL) {
        // Everyone
        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;
    } else {
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID) {
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority,
                                    (BYTE)Count,
                                            dwRID[0],
                                            dwRID[1],
                                            dwRID[2],
                                            dwRID[3],
                                            dwRID[4],
                                            dwRID[5],
                                            dwRID[6],
                                            dwRID[7],
                                    Sid) ) {
            returnValue = GetLastError();
        }
    } else {
        // get regular account sid
        DWORD        sidSize;
        TCHAR        refDomain [256];
        DWORD        refDomainSize;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountName (NULL,
                           pszPrincipal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();

        if (returnValue == ERROR_INSUFFICIENT_BUFFER) {
            *Sid = (PSID) malloc (sidSize);
            if (!*Sid)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return GetLastError();
            }
            refDomainSize = 255;

            if (!LookupAccountName (NULL,
                                    pszPrincipal,
                                    *Sid,
                                    &sidSize,
                                    refDomain,
                                    &refDomainSize,
                                    &snu))
            {
                returnValue = GetLastError();
            } else {
                returnValue = ERROR_SUCCESS;
            }
        }
    }

    return returnValue;
}

DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    LPVOID                ace;
    ACE_HEADER            *aceHeader;
    ULONG                 i;

    GetAclInformation (OldACL,
                       (LPVOID) &aclSizeInfo,
                       (DWORD) sizeof (aclSizeInfo),
                       AclSizeInformation);

    //
    // Copy all of the ACEs to the new ACL
    //

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        //
        // Get the ACE and header info
        //

        if (!GetAce (OldACL, i, &ace))
            return GetLastError();

        aceHeader = (ACE_HEADER *) ace;

        //
        // Add the ACE to the new list
        //

        if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
            return GetLastError();
    }

    return ERROR_SUCCESS;
}


DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID = NULL;
    PACL                  oldACL, newACL;
    BOOL                  bWellKnownSID = FALSE;

    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (oldACL,
                       (LPVOID) &aclSizeInfo,
                       (DWORD) sizeof (ACL_SIZE_INFORMATION),
                       AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if (!AddAccessAllowedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    *Acl = newACL;
	newACL = NULL;

cleanup:

	// BugFix: 57654 Whistler
	//         Prefix bug leaking memory in error condition.
	//         By setting the newACL to NULL above if we have
	//         relinquished the memory to *Acl, we avoid releasing
	//         memory we have passed back to the caller.
	//         EBK 5/5/2000		
	if (newACL)
	{
		delete [] newACL;
		newACL = NULL;
	}

    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION    aclSizeInfo;
    ULONG                   i;
    LPVOID                  ace;
    ACCESS_ALLOWED_ACE      *accessAllowedAce;
    ACCESS_DENIED_ACE       *accessDeniedAce;
    SYSTEM_AUDIT_ACE        *systemAuditAce;
    PSID                    principalSID = NULL;
    DWORD                   returnValue = ERROR_SUCCESS;
    ACE_HEADER              *aceHeader;
    BOOL                    bWellKnownSID = FALSE;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (Acl,
                       (LPVOID) &aclSizeInfo,
                       (DWORD) sizeof (ACL_SIZE_INFORMATION),
                       AclSizeInformation);

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce (Acl, i, &ace))
        {
            returnValue = GetLastError();
            break;
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        } else

        if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessDeniedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        } else

        if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &systemAuditAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        }
    }

    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    )
{
    PSECURITY_DESCRIPTOR  sd = NULL;
    DWORD                 descriptorSize;
    DWORD                 daclSize;
    DWORD                 saclSize;
    DWORD                 ownerSIDSize;
    DWORD                 groupSIDSize;
    PACL                  dacl = NULL;
    PACL                  sacl = NULL;
    PSID                  ownerSID = NULL;
    PSID                  groupSID = NULL;
    BOOL                  present;
    BOOL                  systemDefault;

    //
    // Get SACL
    //

    if (!GetSecurityDescriptorSacl (OldSD, &present, &sacl, &systemDefault))
        return GetLastError();

    if (sacl && present)
    {
        saclSize = sacl->AclSize;
    } else saclSize = 0;

    //
    // Get DACL
    //

    if (!GetSecurityDescriptorDacl (OldSD, &present, &dacl, &systemDefault))
        return GetLastError();

    if (dacl && present)
    {
        daclSize = dacl->AclSize;
    } else daclSize = 0;

    //
    // Get Owner
    //

    if (!GetSecurityDescriptorOwner (OldSD, &ownerSID, &systemDefault))
        return GetLastError();

    ownerSIDSize = GetLengthSid (ownerSID);

    //
    // Get Group
    //

    if (!GetSecurityDescriptorGroup (OldSD, &groupSID, &systemDefault))
        return GetLastError();

    groupSIDSize = GetLengthSid (groupSID);

    //
    // Do the conversion
    //

    descriptorSize = 0;

    MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                    &saclSize, ownerSID, &ownerSIDSize, groupSID,
                    &groupSIDSize);

    sd = (PSECURITY_DESCRIPTOR) new BYTE [SECURITY_DESCRIPTOR_MIN_LENGTH];
    if (!sd)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return GetLastError();
    }
    if (!InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION))
        return GetLastError();

    if (!MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                         &saclSize, ownerSID, &ownerSIDSize, groupSID,
                         &groupSIDSize))
        return GetLastError();

    *NewSD = sd;
    return ERROR_SUCCESS;
}

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    )
{
    DWORD   returnValue;
    DWORD   disposition;
    HKEY    registryKey;

    //
    // Create new key or open existing key
    //

    returnValue = RegCreateKeyEx (RootKey,
                                  KeyName,
                                  0,
                                  TEXT(""),
                                  0,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &registryKey,
                                  &disposition);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    //
    // Write the security descriptor
    //

    returnValue = RegSetValueEx (registryKey,
                                 ValueName,
                                 0,
                                 REG_BINARY,
                                 (LPBYTE) SD,
                                 GetSecurityDescriptorLength (SD));
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}


DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl = NULL;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;

    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // If the security descriptor is new, add the required Principals to it
    //

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("INTERACTIVE"));
    }

    //
    // Remove the Principal that the caller wants removed
    //

    returnValue = RemovePrincipalFromACL (dacl, Principal);
    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute);
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!sdSelfRelative)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        goto Cleanup;
    }

    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute)
        free (sdAbsolute);

    return returnValue;
}

DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID = NULL;
    PACL                  oldACL, newACL;
    BOOL                  bWellKnownSID = FALSE;
    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (oldACL,
                       (LPVOID) &aclSizeInfo,
                       (DWORD) sizeof (ACL_SIZE_INFORMATION),
                       AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_DENIED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    if (!AddAccessDeniedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    *Acl = newACL;
	newACL = NULL;

cleanup:

	// BugFix: 57654 Whistler
	//         Prefix bug leaking memory in error condition.
	//         By setting the newACL to NULL above if we have
	//         relinquished the memory to *Acl, we avoid releasing
	//         memory we have passed back to the caller.
	//         EBK 5/5/2000		
	if (newACL)
	{
		delete[] newACL;
		newACL = NULL;
	}

    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;


    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, TEXT("INTERACTIVE"));
    }

    //
    // Add the Principal that the caller wants added
    //

    if (Permit)
        returnValue = AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, Principal);
    else
        returnValue = AddAccessDeniedACEToACL (&dacl, GENERIC_ALL, Principal);

    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute);
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!sdSelfRelative)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        returnValue = GetLastError();
        goto Cleanup;
    }


    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute)
        free (sdAbsolute);

    return returnValue;
}


DWORD
ChangeDCOMAccessACL (
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{

    DWORD   err;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE,
                                               TEXT("Software\\Microsoft\\OLE"),
                                               TEXT("DefaultAccessPermission"),
                                               Principal);
        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE,
                                          TEXT("Software\\Microsoft\\OLE"),
                                          TEXT("DefaultAccessPermission"),
                                          Principal,
                                          Permit);
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE,
                                               TEXT("Software\\Microsoft\\OLE"),
                                               TEXT("DefaultAccessPermission"),
                                               Principal);
    }
    return err;
}

DWORD
ChangeDCOMLaunchACL (
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{

    TCHAR   keyName [256] = TEXT("Software\\Microsoft\\OLE");
    DWORD   err;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE,
                                               keyName,
                                               TEXT("DefaultLaunchPermission"),
                                               Principal);
        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE,
                                          keyName,
                                          TEXT("DefaultLaunchPermission"),
                                          Principal,
                                          Permit);
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE,
                                               keyName,
                                               TEXT("DefaultLaunchPermission"),
                                               Principal);
    }
    return err;
}



GUFM_RETURN GetUserFromMetabase(IMDCOM *pcCom,
                                LPWSTR pszPath,
                                DWORD dwUserMetaId,
                                DWORD dwPasswordMetaId,
                                USERNAME_STRING_TYPE ustUserBuf,
                                PASSWORD_STRING_TYPE pstPasswordBuf)
{

    HRESULT hresTemp;
    GUFM_RETURN  gufmReturn = GUFM_SUCCESS;
    METADATA_RECORD mdrData;
    DWORD dwRequiredDataLen;

    METADATA_HANDLE mhOpenHandle;


    hresTemp = pcCom->ComMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE,
                                            pszPath,
                                            METADATA_PERMISSION_READ,
                                            OPEN_TIMEOUT_VALUE,
                                            &mhOpenHandle);
    if (FAILED(hresTemp)) {
        gufmReturn = GUFM_NO_PATH;
    }
    else {
        MD_SET_DATA_RECORD_EXT(&mdrData,
                               dwUserMetaId,
                               METADATA_NO_ATTRIBUTES,
                               ALL_METADATA,
                               STRING_METADATA,
                               MAX_PATH * sizeof(TCHAR),
                               (PBYTE)ustUserBuf)

        hresTemp = pcCom->ComMDGetMetaData(mhOpenHandle,
                                           NULL,
                                           &mdrData,
                                           &dwRequiredDataLen);

        if (FAILED(hresTemp) || (ustUserBuf[0] == (TCHAR)'\0')) {
            gufmReturn = GUFM_NO_USER_ID;
        }
        else {

            MD_SET_DATA_RECORD_EXT(&mdrData,
                                   dwPasswordMetaId,
                                   METADATA_NO_ATTRIBUTES,
                                   ALL_METADATA,
                                   STRING_METADATA,
                                   MAX_PATH * sizeof(TCHAR),
                                   (PBYTE)pstPasswordBuf)

            hresTemp = pcCom->ComMDGetMetaData(mhOpenHandle,
                                               NULL,
                                               &mdrData,
                                               &dwRequiredDataLen);
            if (FAILED(hresTemp)) {
                gufmReturn = GUFM_NO_PASSWORD;
            }
        }
        pcCom->ComMDCloseMetaObject(mhOpenHandle);
    }

    return gufmReturn;
}

BOOL WritePasswordToMetabase(IMDCOM *pcCom,
                             LPWSTR pszPath,
                             DWORD dwPasswordMetaId,
                             PASSWORD_STRING_TYPE pstPasswordBuf)
{

    HRESULT hresReturn;
    BOOL fReturn = FALSE;
    METADATA_RECORD mdrData;

    METADATA_HANDLE mhOpenHandle;


    hresReturn = pcCom->ComMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE,
                                            pszPath,
                                            METADATA_PERMISSION_WRITE,
                                            OPEN_TIMEOUT_VALUE,
                                            &mhOpenHandle);
    if (SUCCEEDED(hresReturn)) {
        MD_SET_DATA_RECORD_EXT(&mdrData,
                               dwPasswordMetaId,
                               METADATA_INHERIT | METADATA_SECURE,
                               IIS_MD_UT_FILE,
                               STRING_METADATA,
                               sizeof(pstPasswordBuf),
                               (PBYTE)pstPasswordBuf)

        hresReturn = pcCom->ComMDSetMetaData(mhOpenHandle,
                                             NULL,
                                             &mdrData);

        pcCom->ComMDCloseMetaObject(mhOpenHandle);
    }

    return SUCCEEDED(hresReturn);
}

BOOL DoesUserExist( LPWSTR strUsername, BOOL *fDisabled )
{
    BYTE *pBuffer;
    INT err = NERR_Success;
    BOOL fReturn = FALSE;

    *fDisabled = FALSE;

    err = NetUserGetInfo( NULL, strUsername, 3, &pBuffer );

    if ( err == NERR_Success )
    {
        *fDisabled = !!(((PUSER_INFO_3)pBuffer)->usri3_flags  & UF_ACCOUNTDISABLE);
        NetApiBufferFree( pBuffer );
        fReturn = TRUE;
    }

    return( fReturn );
}


NET_API_STATUS
NetpNtStatusToApiStatus (
    IN NTSTATUS NtStatus
    )

/*++

Routine Description:

    This function takes an NT status code and maps it to the appropriate
    LAN Man error code.

Arguments:

    NtStatus - Supplies the NT status.

Return Value:

    Returns the appropriate LAN Man error code for the NT status.

--*/
{
    NET_API_STATUS error;

    //
    // A small optimization for the most common case.
    //
    if ( NtStatus == STATUS_SUCCESS ) {
        return NERR_Success;
    }


    switch ( NtStatus ) {

        case STATUS_BUFFER_TOO_SMALL :
            return NERR_BufTooSmall;

        case STATUS_FILES_OPEN :
            return NERR_OpenFiles;

        case STATUS_CONNECTION_IN_USE :
            return NERR_DevInUse;

        case STATUS_INVALID_LOGON_HOURS :
            return NERR_InvalidLogonHours;

        case STATUS_INVALID_WORKSTATION :
            return NERR_InvalidWorkstation;

        case STATUS_PASSWORD_EXPIRED :
            return NERR_PasswordExpired;

        case STATUS_ACCOUNT_EXPIRED :
            return NERR_AccountExpired;

        case STATUS_REDIRECTOR_NOT_STARTED :
            return NERR_NetNotStarted;

        case STATUS_GROUP_EXISTS:
                return NERR_GroupExists;

        case STATUS_INTERNAL_DB_CORRUPTION:
                return NERR_InvalidDatabase;

        case STATUS_INVALID_ACCOUNT_NAME:
                return NERR_BadUsername;

        case STATUS_INVALID_DOMAIN_ROLE:
        case STATUS_INVALID_SERVER_STATE:
        case STATUS_BACKUP_CONTROLLER:
                return NERR_NotPrimary;

        case STATUS_INVALID_DOMAIN_STATE:
                return NERR_ACFNotLoaded;

        case STATUS_MEMBER_IN_GROUP:
                return NERR_UserInGroup;

        case STATUS_MEMBER_NOT_IN_GROUP:
                return NERR_UserNotInGroup;

        case STATUS_NONE_MAPPED:
        case STATUS_NO_SUCH_GROUP:
                return NERR_GroupNotFound;

        case STATUS_SPECIAL_GROUP:
        case STATUS_MEMBERS_PRIMARY_GROUP:
                return NERR_SpeGroupOp;

        case STATUS_USER_EXISTS:
                return NERR_UserExists;

        case STATUS_NO_SUCH_USER:
                return NERR_UserNotFound;

        case STATUS_PRIVILEGE_NOT_HELD:
                return ERROR_ACCESS_DENIED;

        case STATUS_LOGON_SERVER_CONFLICT:
                return NERR_LogonServerConflict;

        case STATUS_TIME_DIFFERENCE_AT_DC:
                return NERR_TimeDiffAtDC;

        case STATUS_SYNCHRONIZATION_REQUIRED:
                return NERR_SyncRequired;

        case STATUS_WRONG_PASSWORD_CORE:
                return NERR_BadPasswordCore;

        case STATUS_DOMAIN_CONTROLLER_NOT_FOUND:
                return NERR_DCNotFound;

        case STATUS_PASSWORD_RESTRICTION:
                return NERR_PasswordTooShort;

        case STATUS_ALREADY_DISCONNECTED:
                return NERR_Success;

        default:

            //
            // Use the system routine to do the mapping to ERROR_ codes.
            //

#ifndef WIN32_CHICAGO 
            error = RtlNtStatusToDosError( NtStatus );

            if ( error != (NET_API_STATUS)NtStatus ) {
                return error;
            }
#endif // WIN32_CHICAGO

            //
            // Could not map the NT status to anything appropriate.
            //

            return NERR_InternalError;
    }
} // NetpNtStatusToApiStatus


NET_API_STATUS
UaspGetDomainId(
    IN LPCWSTR ServerName OPTIONAL,
    OUT PSAM_HANDLE SamServerHandle OPTIONAL,
    OUT PPOLICY_ACCOUNT_DOMAIN_INFO * AccountDomainInfo
    )
/*++
Routine Description:
    Return a domain ID of the account domain of a server.
Arguments:
    ServerName - A pointer to a string containing the name of the
        Domain Controller (DC) to query.  A NULL pointer
        or string specifies the local machine.
    SamServerHandle - Returns the SAM connection handle if the caller wants it.
    DomainId - Receives a pointer to the domain ID.
        Caller must deallocate buffer using NetpMemoryFree.
Return Value:
    Error code for the operation.
--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    SAM_HANDLE LocalSamHandle = NULL;

    ACCESS_MASK LSADesiredAccess;
    LSA_HANDLE  LSAPolicyHandle = NULL;
    OBJECT_ATTRIBUTES LSAObjectAttributes;

    UNICODE_STRING ServerNameString;


    //
    // Connect to the SAM server
    //
    RtlInitUnicodeString( &ServerNameString, ServerName );

    Status = SamConnect(
                &ServerNameString,
                &LocalSamHandle,
                SAM_SERVER_LOOKUP_DOMAIN,
                NULL);

    if ( !NT_SUCCESS(Status))
    {
        LocalSamHandle = NULL;
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }


    //
    // Open LSA to read account domain info.
    //

    if ( AccountDomainInfo != NULL) {
        //
        // set desired access mask.
        //
        LSADesiredAccess = POLICY_VIEW_LOCAL_INFORMATION;

        InitializeObjectAttributes( &LSAObjectAttributes,
                                      NULL,             // Name
                                      0,                // Attributes
                                      NULL,             // Root
                                      NULL );           // Security Descriptor

        Status = LsaOpenPolicy( &ServerNameString,
                                &LSAObjectAttributes,
                                LSADesiredAccess,
                                &LSAPolicyHandle );

        if( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }


        //
        // now read account domain info from LSA.
        //

        Status = LsaQueryInformationPolicy(
                        LSAPolicyHandle,
                        PolicyAccountDomainInformation,
                        (PVOID *) AccountDomainInfo );

        if( !NT_SUCCESS(Status) ) {
            NetStatus = NetpNtStatusToApiStatus( Status );
            goto Cleanup;
        }
    }

    //
    // Return the SAM connection handle to the caller if he wants it.
    // Otherwise, disconnect from SAM.
    //

    if ( ARGUMENT_PRESENT( SamServerHandle ) ) {
        *SamServerHandle = LocalSamHandle;
        LocalSamHandle = NULL;
    }

    NetStatus = NERR_Success;

    //
    // Cleanup locally used resources
    //
Cleanup:
    if ( LocalSamHandle != NULL ) {
        (VOID) SamCloseHandle( LocalSamHandle );
    }

    if( LSAPolicyHandle != NULL ) {
        LsaClose( LSAPolicyHandle );
    }

    return NetStatus;
} // UaspGetDomainId


NET_API_STATUS
SampCreateFullSid(
    IN PSID DomainSid,
    IN ULONG Rid,
    OUT PSID *AccountSid
    )
/*++
Routine Description:
    This function creates a domain account sid given a domain sid and
    the relative id of the account within the domain.
    The returned Sid may be freed with LocalFree.
--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS    IgnoreStatus;
    UCHAR       AccountSubAuthorityCount;
    ULONG       AccountSidLength;
    PULONG      RidLocation;

    //
    // Calculate the size of the new sid
    //
    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(DomainSid) + (UCHAR)1;
    AccountSidLength = RtlLengthRequiredSid(AccountSubAuthorityCount);

    //
    // Allocate space for the account sid
    //
    *AccountSid = LocalAlloc(LMEM_ZEROINIT,AccountSidLength);
    if (*AccountSid == NULL)
    {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        //
        // Copy the domain sid into the first part of the account sid
        //
        IgnoreStatus = RtlCopySid(AccountSidLength, *AccountSid, DomainSid);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        //
        // Increment the account sid sub-authority count
        //
        *RtlSubAuthorityCountSid(*AccountSid) = AccountSubAuthorityCount;

        //
        // Add the rid as the final sub-authority
        //
        RidLocation = RtlSubAuthoritySid(*AccountSid, AccountSubAuthorityCount-1);
        *RidLocation = Rid;

        NetStatus = NERR_Success;
    }

    return(NetStatus);
}



int GetGuestUserNameForDomain_FastWay(LPTSTR szDomainToLookUp,LPTSTR lpGuestUsrName)
{
    int iReturn = FALSE;
    NET_API_STATUS NetStatus;

    // for UaspGetDomainId()
    SAM_HANDLE SamServerHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO pAccountDomainInfo = NULL;

    PSID pAccountSid = NULL;
    PSID pDomainSid = NULL;

    // for LookupAccountSid()
    SID_NAME_USE sidNameUse = SidTypeUser;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    TCHAR szUserName[UNLEN+1];
    DWORD cbName = UNLEN+1;
    // use UNLEN because DNLEN is too small
    TCHAR szReferencedDomainName[UNLEN+1];
    DWORD cbReferencedDomainName = sizeof(szReferencedDomainName);

    // make sure not to return back gobble-d-gook
    wcscpy(lpGuestUsrName, TEXT(""));

    //
    // Get the Sid for the specified Domain
    //
    // szDomainToLookUp=NULL for local machine
    NetStatus = UaspGetDomainId( szDomainToLookUp,&SamServerHandle,&pAccountDomainInfo );
    if ( NetStatus != NERR_Success )
    {
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }
    pDomainSid = pAccountDomainInfo->DomainSid;
    //
    // Use the Domain Sid and the well known Guest RID to create the Real Guest Sid
    //
    // Well-known users ...
    // DOMAIN_USER_RID_ADMIN          (0x000001F4L)
    // DOMAIN_USER_RID_GUEST          (0x000001F5L)
    NetStatus = NERR_InternalError;
    NetStatus = SampCreateFullSid(pDomainSid, DOMAIN_USER_RID_GUEST, &pAccountSid);
    if ( NetStatus != NERR_Success )
    {
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }

    //
    // Check if the SID is valid
    //
    if (0 == IsValidSid(pAccountSid))
    {
        DWORD dwErr = GetLastError();
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }

    //
    // Retrieve the UserName for the specified SID
    //
    wcscpy(szUserName, TEXT(""));
    wcscpy(szReferencedDomainName, TEXT(""));
    // szDomainToLookUp=NULL for local machine
    if (!LookupAccountSid(szDomainToLookUp,
                          pAccountSid,
                          szUserName,
                          &cbName,
                          szReferencedDomainName,
                          &cbReferencedDomainName,
                          &sidNameUse))
    {
        DWORD dwErr = GetLastError();
        goto GetGuestUserNameForDomain_FastWay_Exit;
    }


    // Return the guest user name that we got.
    wcscpy(lpGuestUsrName, szUserName);

    // Wow, after all that, we must have succeeded
    iReturn = TRUE;

GetGuestUserNameForDomain_FastWay_Exit:
    // Free the Domain info if we got some
    if (pAccountDomainInfo) {NetpMemoryFree(pAccountDomainInfo);}
    // Free the sid if we had allocated one
    if (pAccountSid) {LocalFree(pAccountSid);}
    return iReturn;
}

int GetGuestUserName_SlowWay(LPWSTR lpGuestUsrName)
{

    LPWSTR ServerName = NULL; // default to local machine
    DWORD Level = 1; // to retrieve info of all local and global normal user accounts
    DWORD Index = 0;
    DWORD EntriesRequested = 5;
    DWORD PreferredMaxLength = 1024;
    DWORD ReturnedEntryCount = 0;
    PVOID SortedBuffer = NULL;
    NET_DISPLAY_USER *p = NULL;
    DWORD i=0;
    int err = 0;
    BOOL fStatus = TRUE;

    while (fStatus)
    {
        err = NetQueryDisplayInformation(ServerName,
                                         Level,
                                         Index,
                                         EntriesRequested,
                                         PreferredMaxLength,
                                         &ReturnedEntryCount,
                                         &SortedBuffer);
        if (err == NERR_Success)
            fStatus = FALSE;
        if (err == NERR_Success || err == ERROR_MORE_DATA)
        {
            p = (NET_DISPLAY_USER *)SortedBuffer;
            i = 0;
            while (i < ReturnedEntryCount && (p[i].usri1_user_id != DOMAIN_USER_RID_GUEST))
                i++;
            if (i == ReturnedEntryCount)
            {
                if (err == ERROR_MORE_DATA)
                { // need to get more entries
                    Index = p[i-1].usri1_next_index;
                }
            }
            else
            {
                wcscpy(lpGuestUsrName, p[i].usri1_name);
                fStatus = FALSE;
            }
        }
        NetApiBufferFree(SortedBuffer);
    }

    return 0;
}

void GetGuestUserName(LPTSTR lpOutGuestUsrName)
{
    // try to retrieve the guest username the fast way
    // meaning = lookup the domain sid, and the well known guest rid, to get the guest sid.
    // then look it up.  The reason for this function is that on large domains with mega users
    // the account can be quickly looked up.
    TCHAR szGuestUsrName[UNLEN+1];
    LPTSTR pszComputerName = NULL;
    if (!GetGuestUserNameForDomain_FastWay(pszComputerName,szGuestUsrName))
    {

        // if the fast way failed for some reason, then let's do it
        // the slow way, since this way always used to work, only on large domains (1 mil users)
        // it could take 24hrs (since this function actually enumerates thru the domain)
        GetGuestUserName_SlowWay(szGuestUsrName);
    }

    // Return back the username
    wcscpy(lpOutGuestUsrName,szGuestUsrName);
    return;
}

int GetGuestGrpName(LPTSTR lpGuestGrpName)
{
    LPCTSTR ServerName = NULL; // local machine
    // use UNLEN because DNLEN is too small
    DWORD cbName = UNLEN+1;
    TCHAR ReferencedDomainName[UNLEN+1];
    DWORD cbReferencedDomainName = sizeof(ReferencedDomainName);
    SID_NAME_USE sidNameUse = SidTypeUser;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID GuestsSid = NULL;

    AllocateAndInitializeSid(&NtAuthority,
                             2,
                             SECURITY_BUILTIN_DOMAIN_RID,
                             DOMAIN_ALIAS_RID_GUESTS,
                             0,
                             0,
                             0,
                             0,
                             0,
                             0,
                             &GuestsSid);

    LookupAccountSid(ServerName,
                     GuestsSid,
                     lpGuestGrpName,
                     &cbName,
                     ReferencedDomainName,
                     &cbReferencedDomainName,
                     &sidNameUse);

    if (GuestsSid)
        FreeSid(GuestsSid);

    return 0;
}

INT RegisterAccountToLocalGroup(LPCTSTR szAccountName,
                                LPCTSTR szLocalGroupName,
                                BOOL fAction)
{
    int err;

    // get the sid of szAccountName
    PSID pSID = NULL;
    BOOL bWellKnownSID = FALSE;
    err = GetPrincipalSID ((LPTSTR)szAccountName, &pSID, &bWellKnownSID);
    if (err != ERROR_SUCCESS)
    {
        return (err);
    }

    // Get the localized LocalGroupName
    TCHAR szLocalizedLocalGroupName[GNLEN + 1];
    if (_wcsicmp(szLocalGroupName, TEXT("Guests")) == 0)
    {
        GetGuestGrpName(szLocalizedLocalGroupName);
    }
    else
    {
        wcscpy(szLocalizedLocalGroupName, szLocalGroupName);
    }

    // transfer szLocalGroupName to WCHAR
    WCHAR wszLocalGroupName[_MAX_PATH];
    wcscpy(wszLocalGroupName, szLocalizedLocalGroupName);

    LOCALGROUP_MEMBERS_INFO_0 buf;

    buf.lgrmi0_sid = pSID;

    if (fAction)
    {
        err = NetLocalGroupAddMembers(NULL, wszLocalGroupName, 0, (LPBYTE)&buf, 1);
    }
    else
    {
        err = NetLocalGroupDelMembers(NULL, wszLocalGroupName, 0, (LPBYTE)&buf, 1);
    }

    if (pSID)
    {
        if (bWellKnownSID)
            FreeSid (pSID);
        else
            free (pSID);
    }

    return (err);
}

void InitLsaString(PLSA_UNICODE_STRING LsaString,LPWSTR String)
{
    DWORD StringLength;

    if (String == NULL)
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = wcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
}

DWORD OpenPolicy(LPTSTR ServerName,DWORD DesiredAccess,PLSA_HANDLE PolicyHandle)
{
    DWORD Error;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server = NULL;
    SECURITY_QUALITY_OF_SERVICE QualityOfService;

    QualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    QualityOfService.ImpersonationLevel = SecurityImpersonation;
    QualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    QualityOfService.EffectiveOnly = FALSE;

    //
    // The two fields that must be set are length and the quality of service.
    //
    ObjectAttributes.Length = sizeof(LSA_OBJECT_ATTRIBUTES);
    ObjectAttributes.RootDirectory = NULL;
    ObjectAttributes.ObjectName = NULL;
    ObjectAttributes.Attributes = 0;
    ObjectAttributes.SecurityDescriptor = NULL;
    ObjectAttributes.SecurityQualityOfService = &QualityOfService;

    if (ServerName != NULL)
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        InitLsaString(&ServerString,ServerName);
        Server = &ServerString;
    }
    //
    // Attempt to open the policy for all access
    //
    Error = LsaOpenPolicy(Server,&ObjectAttributes,DesiredAccess,PolicyHandle);
    return(Error);

}


INT RegisterAccountUserRights(LPCTSTR szAccountName, BOOL fAction, BOOL fSpecicaliWamAccount)
{
    int err;

    // get the sid of szAccountName
    PSID pSID = NULL;
    BOOL bWellKnownSID = FALSE;
    err = GetPrincipalSID ((LPTSTR)szAccountName, &pSID, &bWellKnownSID);
    if (err != ERROR_SUCCESS)
    {
        return (err);
    }

    LSA_UNICODE_STRING UserRightString;
    LSA_HANDLE PolicyHandle = NULL;

    err = OpenPolicy(NULL, POLICY_ALL_ACCESS,&PolicyHandle);
    if ( err == NERR_Success )
    {
        if (fAction) 
        {
// defined in ntsecapi.h and ntlsa.h
//#define SE_INTERACTIVE_LOGON_NAME       TEXT("SeInteractiveLogonRight")
//#define SE_NETWORK_LOGON_NAME           TEXT("SeNetworkLogonRight")
//#define SE_BATCH_LOGON_NAME             TEXT("SeBatchLogonRight")
//#define SE_SERVICE_LOGON_NAME           TEXT("SeServiceLogonRight")
// Defined in winnt.h
//#define SE_CREATE_TOKEN_NAME              TEXT("SeCreateTokenPrivilege")
//#define SE_ASSIGNPRIMARYTOKEN_NAME        TEXT("SeAssignPrimaryTokenPrivilege")
//#define SE_LOCK_MEMORY_NAME               TEXT("SeLockMemoryPrivilege")
//#define SE_INCREASE_QUOTA_NAME            TEXT("SeIncreaseQuotaPrivilege")
//#define SE_UNSOLICITED_INPUT_NAME         TEXT("SeUnsolicitedInputPrivilege")
//#define SE_MACHINE_ACCOUNT_NAME           TEXT("SeMachineAccountPrivilege")
//#define SE_TCB_NAME                       TEXT("SeTcbPrivilege")
//#define SE_SECURITY_NAME                  TEXT("SeSecurityPrivilege")
//#define SE_TAKE_OWNERSHIP_NAME            TEXT("SeTakeOwnershipPrivilege")
//#define SE_LOAD_DRIVER_NAME               TEXT("SeLoadDriverPrivilege")
//#define SE_SYSTEM_PROFILE_NAME            TEXT("SeSystemProfilePrivilege")
//#define SE_SYSTEMTIME_NAME                TEXT("SeSystemtimePrivilege")
//#define SE_PROF_SINGLE_PROCESS_NAME       TEXT("SeProfileSingleProcessPrivilege")
//#define SE_INC_BASE_PRIORITY_NAME         TEXT("SeIncreaseBasePriorityPrivilege")
//#define SE_CREATE_PAGEFILE_NAME           TEXT("SeCreatePagefilePrivilege")
//#define SE_CREATE_PERMANENT_NAME          TEXT("SeCreatePermanentPrivilege")
//#define SE_BACKUP_NAME                    TEXT("SeBackupPrivilege")
//#define SE_RESTORE_NAME                   TEXT("SeRestorePrivilege")
//#define SE_SHUTDOWN_NAME                  TEXT("SeShutdownPrivilege")
//#define SE_DEBUG_NAME                     TEXT("SeDebugPrivilege")
//#define SE_AUDIT_NAME                     TEXT("SeAuditPrivilege")
//#define SE_SYSTEM_ENVIRONMENT_NAME        TEXT("SeSystemEnvironmentPrivilege")
//#define SE_CHANGE_NOTIFY_NAME             TEXT("SeChangeNotifyPrivilege")
//#define SE_REMOTE_SHUTDOWN_NAME           TEXT("SeRemoteShutdownPrivilege")
//#define SE_UNDOCK_NAME                    TEXT("SeUndockPrivilege")
//#define SE_SYNC_AGENT_NAME                TEXT("SeSyncAgentPrivilege")
//#define SE_ENABLE_DELEGATION_NAME         TEXT("SeEnableDelegationPrivilege")
            if (fSpecicaliWamAccount)
            {
                // no interactive logon for iwam!
                InitLsaString(&UserRightString, SE_NETWORK_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                InitLsaString(&UserRightString, SE_BATCH_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
            }
            else
            {
                InitLsaString(&UserRightString, SE_INTERACTIVE_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                InitLsaString(&UserRightString, SE_NETWORK_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
                InitLsaString(&UserRightString, SE_BATCH_LOGON_NAME);
                err = LsaAddAccountRights(PolicyHandle, pSID, &UserRightString, 1);
            }
        }
        else 
        {
            InitLsaString(&UserRightString, SE_INTERACTIVE_LOGON_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_NETWORK_LOGON_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
            InitLsaString(&UserRightString, SE_BATCH_LOGON_NAME);
            err = LsaRemoveAccountRights(PolicyHandle, pSID, FALSE, &UserRightString,1);
        }

        LsaClose(PolicyHandle);
    }

    if (pSID)
    {
        if (bWellKnownSID)
            FreeSid (pSID);
        else
            free (pSID);
    }

    return (err);
}


int ChangeUserPassword(IN LPTSTR szUserName, IN LPTSTR szNewPassword)
{
    int iReturn = TRUE;
    USER_INFO_1003  pi1003; 
    NET_API_STATUS  nas; 

    TCHAR szRawComputerName[CNLEN + 10];
    DWORD dwLen = CNLEN + 10;
    TCHAR szComputerName[CNLEN + 10];
    TCHAR szCopyOfUserName[UNLEN+10];
    TCHAR szTempFullUserName[(CNLEN + 10) + (UNLEN+1)];
    LPTSTR pch = NULL;

    wcscpy(szCopyOfUserName, szUserName);

    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeUserPassword().Start.name=%s,pass=%s"),szCopyOfUserName,szNewPassword));

    if ( !GetComputerName( szRawComputerName, &dwLen ))
        {goto ChangeUserPassword_Exit;}

    // Make a copy to be sure not to move the pointer around.
    wcscpy(szTempFullUserName, szCopyOfUserName);
    // Check if there is a "\" in there.
    pch = wcschr(szTempFullUserName, '\\');
    if (pch) 
        {
            // szCopyOfUserName should now go from something like this:
            // mycomputer\myuser
            // to this myuser
            wcscpy(szCopyOfUserName,pch+1);
            // trim off the '\' character to leave just the domain\computername so we can check against it.
            *pch = '\0';
            // compare the szTempFullUserName with the local computername.
            if (0 == _wcsicmp(szRawComputerName, szTempFullUserName))
            {
                // the computername\username has a hardcoded computername in it.
                // lets try to get only the username
                // look szCopyOfusername is already set
            }
            else
            {
                // the local computer machine name
                // and the specified username are different, so get out
                // and don't even try to change this user\password since
                // it's probably a domain\username

                // return true -- saying that we did in fact change the passoword.
                // we really didn't but we can't
                iReturn = TRUE;
                goto ChangeUserPassword_Exit;
            }
        }

    // Make sure the computername has a \\ in front of it
    if ( szRawComputerName[0] != '\\' )
        {wcscpy(szComputerName,L"\\\\");}
    wcscat(szComputerName,szRawComputerName);
    // 
    // administrative over-ride of existing password 
    // 
    // by this time szCopyOfUserName
    // should not look like mycomputername\username but it should look like username.
    pi1003.usri1003_password = szNewPassword;
     nas = NetUserSetInfo(
            szComputerName,   // computer name 
            szCopyOfUserName, // username 
            1003,             // info level 
            (LPBYTE)&pi1003,  // new info 
            NULL 
            ); 

    if(nas != NERR_Success) 
    {
        iReturn = FALSE;
        goto ChangeUserPassword_Exit;
    }

ChangeUserPassword_Exit:
    //iisDebugOut((LOG_TYPE_TRACE_WIN32_API, _T("ChangeUserPassword().End.Ret=%d"),iReturn));
    return iReturn; 
} 


//
// Create InternetGuest Account
//
BOOL CreateUser( LPCTSTR szUsername,
                LPCTSTR szPassword,
                LPCTSTR szComment,
                LPCTSTR szFullName,
                BOOL fSpecicaliWamAccount
                )
{

    INT err = NERR_Success;

    BYTE *pBuffer;
    WCHAR defGuest[UNLEN+1];
    TCHAR defGuestGroup[GNLEN+1];
    WCHAR wchGuestGroup[GNLEN+1];
    WCHAR wchUsername[UNLEN+1];
    WCHAR wchPassword[LM20_PWLEN+1];

    GetGuestUserName(defGuest);

    GetGuestGrpName(defGuestGroup);

    memset((PVOID)wchUsername, 0, sizeof(wchUsername));
    memset((PVOID)wchPassword, 0, sizeof(wchPassword));
    wcsncpy(wchGuestGroup, defGuestGroup, GNLEN);
    wcsncpy(wchUsername, szUsername, UNLEN);
    wcsncpy(wchPassword, szPassword, LM20_PWLEN);

    err = NetUserGetInfo( NULL, defGuest, 3, &pBuffer );

    if ( err == NERR_Success )
    {
        do
        {
            WCHAR wchComment[MAXCOMMENTSZ+1];
            WCHAR wchFullName[UNLEN+1];

            memset((PVOID)wchComment, 0, sizeof(wchComment));
            memset((PVOID)wchFullName, 0, sizeof(wchFullName));
            wcsncpy(wchComment, szComment, MAXCOMMENTSZ);
            wcsncpy(wchFullName, szFullName, UNLEN);

            USER_INFO_3 *lpui3 = (USER_INFO_3 *)pBuffer;

            lpui3->usri3_name = wchUsername;
            lpui3->usri3_password = wchPassword;
            lpui3->usri3_flags &= ~ UF_ACCOUNTDISABLE;
            lpui3->usri3_flags |= UF_DONT_EXPIRE_PASSWD;
            lpui3->usri3_acct_expires = TIMEQ_FOREVER;

            lpui3->usri3_comment = wchComment;
            lpui3->usri3_usr_comment = wchComment;
            lpui3->usri3_full_name = wchFullName;
            lpui3->usri3_primary_group_id = DOMAIN_GROUP_RID_USERS;

            DWORD parm_err;

            err = NetUserAdd( NULL, 3, pBuffer, &parm_err );

            if ( err != NERR_Success )
            {
              if ( err == NERR_UserExists )
              {
                  // see if we can just change the password.
                  if (TRUE == ChangeUserPassword((LPTSTR) szUsername, (LPTSTR) szPassword))
                     {err = NERR_Success;}
              }
              else
              {
                break;
              }
            }


        } while (FALSE);

        NetApiBufferFree( pBuffer );
    }
    if ( err == NERR_Success )
    {
        // add it to the guests group
        RegisterAccountToLocalGroup(szUsername, TEXT("Guests"), TRUE);

        // add certain user rights to this account
        RegisterAccountUserRights(szUsername, TRUE, fSpecicaliWamAccount);
    }

    return err == NERR_Success;
}

INT DeleteGuestUser( LPCTSTR szUsername )
{

    INT err = NERR_Success;
    BYTE *pBuffer;
    BOOL fDisabled;

    WCHAR wchUsername[UNLEN+1];

    wcsncpy(wchUsername, szUsername, UNLEN);

    if (FALSE == DoesUserExist(wchUsername,&fDisabled))
    {
        return err;
    }

    // remove it from the guests group
    RegisterAccountToLocalGroup(szUsername, TEXT("Guests"), FALSE);

    // remove certain user rights of this account
    RegisterAccountUserRights(szUsername, FALSE, TRUE);

    err = ::NetUserDel( TEXT(""), wchUsername );

    return err;
}

#define MAX_REALISTIC_RESOURCE_LEN  MAX_PATH
BOOL CreateUserAccount(LPTSTR pszAnonyName,
                       LPTSTR pszAnonyPass,
                       DWORD  dwUserCommentResourceId,
                       DWORD  dwUserFullNameResourceId,
                       BOOL   fSpecicaliWamAccount
                       )
{

    BOOL fReturn = FALSE;
    WCHAR pszComment[MAX_REALISTIC_RESOURCE_LEN];
    WCHAR pszFullName[MAX_REALISTIC_RESOURCE_LEN];

    //
    // First Load the Resources
    //

    HMODULE hBinary;

    hBinary = GetModuleHandle(TEXT("svcext"));

    if (hBinary != NULL) {
        fReturn = LoadString(hBinary,
                             dwUserCommentResourceId,
                             pszComment,
                             MAX_REALISTIC_RESOURCE_LEN);
        if (fReturn) {
            fReturn = LoadString(hBinary,
                                 dwUserFullNameResourceId,
                                 pszFullName,
                                 MAX_REALISTIC_RESOURCE_LEN);
        }

    }

    if (fReturn) {
        fReturn = CreateUser(pszAnonyName,
                             pszAnonyPass,
                             pszComment,
                             pszFullName,
                             fSpecicaliWamAccount
                             );
    }

    if (fReturn) {
        ChangeDCOMLaunchACL(pszAnonyName,
                            TRUE,
                            TRUE);
        /* removed when fixing bug 355249
        ChangeDCOMAccessACL(pszAnonyName,
                            TRUE,
                            TRUE);
        */        
    }

    return fReturn;
}

typedef void (*P_SslGenerateRandomBits)( PUCHAR pRandomData, LONG size );
P_SslGenerateRandomBits ProcSslGenerateRandomBits = NULL;

int GetRandomNum(void)
{
    int RandomNum;
    UCHAR cRandomByte;

    if ( ProcSslGenerateRandomBits != NULL )
    {
        (*ProcSslGenerateRandomBits)( &cRandomByte, 1 );
        RandomNum = cRandomByte;
    } else
    {
        RandomNum = rand();
    }

    return(RandomNum);
}

void ShuffleCharArray(int iSizeOfTheArray, TCHAR * lptsTheArray)
{
    int i;
    int iTotal;
    int RandomNum;

    iTotal = iSizeOfTheArray / sizeof(TCHAR);
    for (i=0; i<iTotal;i++ )
    {
        // shuffle the array
        RandomNum=GetRandomNum();
        TCHAR c = lptsTheArray[i];
        lptsTheArray[i]=lptsTheArray[RandomNum%iTotal];
        lptsTheArray[RandomNum%iTotal]=c;
    }
    return;
}

//
// Create a random password
//
void CreatePassword( TCHAR *pszPassword )
{
    //
    // Use Maximum available password length, as
    // setting any other length might run afoul
    // of the minimum password length setting
    //
    int nLength = LM20_PWLEN;
    int iTotal = 0;
    int RandomNum = 0;
    int i;
    TCHAR six2pr[64] =
    {
        TEXT('A'), TEXT('B'), TEXT('C'), TEXT('D'), TEXT('E'), TEXT('F'), TEXT('G'), TEXT('H'),
        TEXT('I'), TEXT('J'), TEXT('K'), TEXT('L'), TEXT('M'),
        TEXT('N'), TEXT('O'), TEXT('P'), TEXT('Q'), TEXT('R'), TEXT('S'), TEXT('T'), TEXT('U'),
        TEXT('V'), TEXT('W'), TEXT('X'), TEXT('Y'), TEXT('Z'),
        TEXT('a'), TEXT('b'), TEXT('c'), TEXT('d'), TEXT('e'), TEXT('f'), TEXT('g'), TEXT('h'),
        TEXT('i'), TEXT('j'), TEXT('k'), TEXT('l'), TEXT('m'),
        TEXT('n'), TEXT('o'), TEXT('p'), TEXT('q'), TEXT('r'), TEXT('s'), TEXT('t'), TEXT('u'),
        TEXT('v'), TEXT('w'), TEXT('x'), TEXT('y'), TEXT('z'),
        TEXT('0'), TEXT('1'), TEXT('2'), TEXT('3'), TEXT('4'), TEXT('5'), TEXT('6'), TEXT('7'),
        TEXT('8'), TEXT('9'), TEXT('*'), TEXT('_')
    };

    // create a random password
    ProcSslGenerateRandomBits = NULL;

    HINSTANCE hSslDll = LoadLibraryEx(TEXT("schannel.dll"), NULL, 0 );
    if ( hSslDll )
        {
        ProcSslGenerateRandomBits = (P_SslGenerateRandomBits)GetProcAddress( hSslDll,
                                                                             "SslGenerateRandomBits");
        }

    // See the random number generation for rand() call in GetRandomNum()
    time_t timer;
    time( &timer );
    srand( (unsigned int) timer );

    // shuffle around the global six2pr[] array
    ShuffleCharArray(sizeof(six2pr), (TCHAR*) &six2pr);
    // assign each character of the password array
    iTotal = sizeof(six2pr) / sizeof(TCHAR);
    for ( i=0;i<nLength;i++ )
    {
        RandomNum=GetRandomNum();
        pszPassword[i]=six2pr[RandomNum%iTotal];
    }

    //
    // in order to meet a possible
    // policy set upon passwords..
    //
    // replace the last 4 chars with these:
    //
    // 1) something from !@#$%^&*()-+=
    // 2) something from 1234567890
    // 3) an uppercase letter
    // 4) a lowercase letter
    //
    TCHAR something1[12] = {TEXT('!'), TEXT('@'), TEXT('#'), TEXT('$'), TEXT('^'), TEXT('&'),
                            TEXT('*'), TEXT('('), TEXT(')'), TEXT('-'), TEXT('+'), TEXT('=')};
    ShuffleCharArray(sizeof(something1), (TCHAR*) &something1);
    TCHAR something2[10] = {TEXT('0'), TEXT('1'), TEXT('2'), TEXT('3'), TEXT('4'), TEXT('5'),
                            TEXT('6'), TEXT('7'), TEXT('8'), TEXT('9')};
    ShuffleCharArray(sizeof(something2),(TCHAR*) &something2);
    TCHAR something3[26] = {TEXT('A'), TEXT('B'), TEXT('C'), TEXT('D'), TEXT('E'), TEXT('F'),
                            TEXT('G'), TEXT('H'), TEXT('I'), TEXT('J'), TEXT('K'), TEXT('L'),
                            TEXT('M'), TEXT('N'), TEXT('O'), TEXT('P'), TEXT('Q'), TEXT('R'),
                            TEXT('S'), TEXT('T'), TEXT('U'), TEXT('V'), TEXT('W'), TEXT('X'),
                            TEXT('Y'), TEXT('Z')};
    ShuffleCharArray(sizeof(something3),(TCHAR*) &something3);
    TCHAR something4[26] = {TEXT('a'), TEXT('b'), TEXT('c'), TEXT('d'), TEXT('e'), TEXT('f'),
                            TEXT('g'), TEXT('h'), TEXT('i'), TEXT('j'), TEXT('k'), TEXT('l'),
                            TEXT('m'), TEXT('n'), TEXT('o'), TEXT('p'), TEXT('q'), TEXT('r'),
                            TEXT('s'), TEXT('t'), TEXT('u'), TEXT('v'), TEXT('w'), TEXT('x'),
                            TEXT('y'), TEXT('z')};
    ShuffleCharArray(sizeof(something4),(TCHAR*)&something4);

    RandomNum=GetRandomNum();
    iTotal = sizeof(something1) / sizeof(TCHAR);
    pszPassword[nLength-4]=something1[RandomNum%iTotal];

    RandomNum=GetRandomNum();
    iTotal = sizeof(something2) / sizeof(TCHAR);
    pszPassword[nLength-3]=something2[RandomNum%iTotal];

    RandomNum=GetRandomNum();
    iTotal = sizeof(something3) / sizeof(TCHAR);
    pszPassword[nLength-2]=something3[RandomNum%iTotal];

    RandomNum=GetRandomNum();
    iTotal = sizeof(something4) / sizeof(TCHAR);
    pszPassword[nLength-1]=something4[RandomNum%iTotal];

    pszPassword[nLength]=TEXT('\0');

    if (hSslDll)
        {FreeLibrary( hSslDll );}
}



BOOL ValidatePassword(IN LPCTSTR UserName,IN LPCTSTR Domain,IN LPCTSTR Password)
/*++
Routine Description:
    Uses SSPI to validate the specified password
Arguments:
    UserName - Supplies the user name
    Domain - Supplies the user's domain
    Password - Supplies the password
Return Value:
    TRUE if the password is valid.
    FALSE otherwise.
--*/
{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS AcceptStatus;
    SECURITY_STATUS InitStatus;
    CredHandle ClientCredHandle;
    CredHandle ServerCredHandle;
    BOOL ClientCredAllocated = FALSE;
    BOOL ServerCredAllocated = FALSE;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    PSecPkgInfo PackageInfo = NULL;
    ULONG ClientFlags;
    ULONG ServerFlags;
    TCHAR TargetName[100];
    SEC_WINNT_AUTH_IDENTITY_W AuthIdentity;
    BOOL Validated = FALSE;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    AuthIdentity.User = (LPWSTR)UserName;
    AuthIdentity.UserLength = lstrlenW(UserName);
    AuthIdentity.Domain = (LPWSTR)Domain;
    AuthIdentity.DomainLength = lstrlenW(Domain);
    AuthIdentity.Password = (LPWSTR)Password;
    AuthIdentity.PasswordLength = lstrlenW(Password);
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( TEXT("NTLM"), &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }

    //
    // Acquire a credential handle for the server side
    //
    SecStatus = AcquireCredentialsHandle(
                    NULL,
                    TEXT("NTLM"),
                    SECPKG_CRED_INBOUND,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &ServerCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }
    ServerCredAllocated = TRUE;

    //
    // Acquire a credential handle for the client side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    TEXT("NTLM"),
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &ClientCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }
    ClientCredAllocated = TRUE;

    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        goto error_exit;
    }

    ClientFlags = ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT;

    InitStatus = InitializeSecurityContext(
                    &ClientCredHandle,
                    NULL,               // No Client context yet
                    NULL,
                    ClientFlags,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( !NT_SUCCESS(InitStatus) ) {
        goto error_exit;
    }

    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        goto error_exit;
    }
    ServerFlags = ASC_REQ_EXTENDED_ERROR;

    AcceptStatus = AcceptSecurityContext(
                    &ServerCredHandle,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ServerFlags,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( !NT_SUCCESS(AcceptStatus) ) {
        goto error_exit;
    }

    if (InitStatus != STATUS_SUCCESS)
    {

        //
        // Get the AuthenticateMessage (ClientSide)
        //

        ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
        AuthenticateDesc.ulVersion = 0;
        AuthenticateDesc.cBuffers = 1;
        AuthenticateDesc.pBuffers = &AuthenticateBuffer;

        AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
        AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
        AuthenticateBuffer.pvBuffer = LocalAlloc( 0, AuthenticateBuffer.cbBuffer );
        if ( AuthenticateBuffer.pvBuffer == NULL ) {
            goto error_exit;
        }

        SecStatus = InitializeSecurityContext(
                        NULL,
                        &ClientContextHandle,
                        TargetName,
                        0,
                        0,                      // Reserved 1
                        SECURITY_NATIVE_DREP,
                        &ChallengeDesc,
                        0,                  // Reserved 2
                        &ClientContextHandle,
                        &AuthenticateDesc,
                        &ContextAttributes,
                        &Lifetime );

        if ( !NT_SUCCESS(SecStatus) ) {
            goto error_exit;
        }

        if (AcceptStatus != STATUS_SUCCESS) {

            //
            // Finally authenticate the user (ServerSide)
            //

            AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

            SecStatus = AcceptSecurityContext(
                            NULL,
                            &ServerContextHandle,
                            &AuthenticateDesc,
                            ServerFlags,
                            SECURITY_NATIVE_DREP,
                            &ServerContextHandle,
                            NULL,
                            &ContextAttributes,
                            &Lifetime );

            if ( !NT_SUCCESS(SecStatus) ) {
                goto error_exit;
            }
            Validated = TRUE;

        }

    }

error_exit:
    if (ServerCredAllocated) {
        FreeCredentialsHandle( &ServerCredHandle );
    }
    if (ClientCredAllocated) {
        FreeCredentialsHandle( &ClientCredHandle );
    }

    //
    // Final Cleanup
    //

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
    return(Validated);
}



DWORD
ChangeAppIDAccessACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256];
    DWORD   err;

    wcscpy(keyName, TEXT("APPID\\"));
    wcscat(keyName, AppID);

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                               keyName,
                                               TEXT("AccessPermission"),
                                               Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT,
                                          keyName,
                                          TEXT("AccessPermission"),
                                          Principal,
                                          Permit);
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                               keyName,
                                               TEXT("AccessPermission"),
                                               Principal);
    }

    return err;
}

DWORD
ChangeAppIDLaunchACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{

    TCHAR   keyName [256];
    DWORD   err;

    wcscpy(keyName, TEXT("APPID\\"));
    wcscat(keyName, AppID);

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                               keyName,
                                               TEXT("LaunchPermission"),
                                               Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT,
                                          keyName,
                                          TEXT("LaunchPermission"),
                                          Principal,
                                          Permit);
    }
    else
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT,
                                               keyName,
                                               TEXT("LaunchPermission"),
                                               Principal);
    }

    return err;
}

//
//  Function will open the metabase and check the iusr_ and iwam_ usernames.
//  it will check if the names are still valid and if the passwords are still valid.
//
VOID UpdateAnonymousUser(IMDCOM *pcCom,
                         LPTSTR pszPath,
                         DWORD dwUserMetaId,
                         DWORD dwPasswordMetaId,
                         DWORD dwUserCommentResourceId,
                         DWORD dwUserFullNameResourceId,
                         LPTSTR pszDefaultUserNamePrefix,
                         USERNAME_STRING_TYPE ustSyncName,
                         PASSWORD_STRING_TYPE pstSyncPass,
                         BOOL fPerformPasswordValidate)
{
    int iReturn = FALSE;
    USERNAME_STRING_TYPE ustAnonyName = L"\0";
    PASSWORD_STRING_TYPE pstAnonyPass = L"\0";
    GUFM_RETURN gufmTemp;
    BOOL fRet;
    BOOL fExistence;
    BOOL fDisabled;
    BOOL fUpdateComApplications = FALSE;

    LPTSTR  pstrRightsFor_IUSR[] = 
        {
        L"SeInteractiveLogonRight",
    	L"SeNetworkLogonRight",
        L"SeBatchLogonRight"
    };

    LPTSTR  pstrRightsFor_IWAM[] = 
        {
    	L"SeNetworkLogonRight",
        L"SeBatchLogonRight"
    };


/*
    TCHAR szEntry[_MAX_PATH];
    TCHAR szPassword[LM20_PWLEN+1];


    CreatePassword(szPassword);
*/

    //
    // Get the WAM username and password
    //

    gufmTemp = GetUserFromMetabase(pcCom,
                                   pszPath,
                                   dwUserMetaId,
                                   dwPasswordMetaId,
                                   ustAnonyName,
                                   pstAnonyPass);

    //
    // If the metabase path doesn't exist, then
    // service doesn't exist, punt
    // If ID doesn't exist in the metabase, then punt, assume they
    // don't want an anonymous User. We may want to revisit this.
    //
    //

    if ((gufmTemp != GUFM_NO_PATH) && (gufmTemp != GUFM_NO_USER_ID)) {

        BOOL fCreateAccount = FALSE;

        //
        // See if this is our default account. Otherwise do nothing.
        //

        if (_wcsnicmp(pszDefaultUserNamePrefix,
                      ustAnonyName,
                      wcslen(pszDefaultUserNamePrefix)) == 0) {

            // Check if this user actually exists...
            fExistence = DoesUserExist(ustAnonyName,&fDisabled);

            if (fExistence) 
            {
                if (fDisabled)
                {
                    fCreateAccount = FALSE;
                    if (!g_eventLogForAccountRecreation)
                    {
                        CreateEventLogObject ();
                    }
                    
                    if (g_eventLogForAccountRecreation)
                    {
                        CHAR  szAnsiUserName[MAX_PATH];
                        const CHAR  *pszUserNames[1];
                        
                        
                        if (! WideCharToMultiByte(CP_ACP,
                            0,
                            ustAnonyName,
                            -1,
                            szAnsiUserName,
                            MAX_PATH-1,
                            NULL,
                            NULL))
                        {
                            memset (szAnsiUserName,0,sizeof(szAnsiUserName));
                        }
                        
                        pszUserNames[0] = szAnsiUserName;
                        
                        g_eventLogForAccountRecreation->LogEvent(
                            INET_SVC_ACCOUNT_DISABLED,
                            1,
                            pszUserNames,
                            0 );
                    }
                    
                }
                else
                {
                        if (gufmTemp != GUFM_NO_PASSWORD) {
                        DBG_ASSERT(gufmTemp == GUFM_SUCCESS);

                        if (fPerformPasswordValidate)
                        {
                            BOOL fCheckPassword = TRUE;

                            //
                            // Make sure this is the same password as other
                            // instances of this account. If not, set it.
                            //

                            if ((pstSyncPass[0] != (TCHAR)'\0') &&
                                (_wcsicmp(ustSyncName, ustAnonyName) == 0)) {

                                if (wcscmp(pstSyncPass,
                                             pstAnonyPass) != 0) {

                                    //
                                    // Passwords are different.
                                    //

                                    if (WritePasswordToMetabase(pcCom,
                                                                pszPath,
                                                                dwPasswordMetaId,
                                                                pstSyncPass)) {
                                        wcscpy(pstAnonyPass,
                                               pstSyncPass);
                                    }
                                    else {
                                        fCheckPassword = FALSE;
                                    }
                                }
                            }

                            if (fCheckPassword) {
                                if (ValidatePassword(ustAnonyName,
                                                     TEXT(""),
                                                     pstAnonyPass)) 
                                {
                                    // thats a good case account is ok, do nothing there
                                }
                                else 
                                {
                                    // we comment out  DeleteGuestUser because we try to change pswd on that user
                                    // DeleteGuestUser(ustAnonyName);
                                    fCreateAccount = TRUE;
                                }
                            }
                        }

                        //
                        // Set the sync password here
                        //

                        wcscpy(pstSyncPass,
                               pstAnonyPass);

                        wcscpy(ustSyncName,
                               ustAnonyName);

                    }
                }
            }
            else {
                fCreateAccount = TRUE;
            }

            if (fCreateAccount) {

                //
                // The user does not exist, so let's create it.
                // Make sure there's a password first.
                //

                if (gufmTemp == GUFM_NO_PASSWORD) {
#if 0
                    //
                    // If it's not there then subauth should be set
                    // and the password should not be in the metabase.
                    // Also, if we add it in, then it could cause
                    // a synchronization problem in the IUSR password
                    // between W3 and FTP.
                    //

                    CreatePassword(pstAnonyPass);

                    fCreateAccount = WritePasswordToMetabase(pcCom,
                                                             pszPath,
                                                             dwPasswordMetaId,
                                                             pstAnonyPass);
#endif
                }

                if (fCreateAccount) {
                    if (MD_WAM_USER_NAME == dwUserMetaId)
                    {
                        fRet = CreateUserAccount(ustAnonyName,pstAnonyPass,dwUserCommentResourceId,dwUserFullNameResourceId,TRUE);
                        if( fRet )
                        {
                            fUpdateComApplications = TRUE;
                        }
                        // if this is a domain controller.
                        // we have to wait for the domain controller
                        // replication to be finished, otherwise The CreateUserAccount
                        // call will fail
                        //
                        // if we failed to create the user
                        // it could be because this is a DC and we need
                        // to wait for the sysvol to be ready.
                        if (!fRet)
                        {
                            if (TRUE == WaitForDCAvailability())
                            {
                                // try again...
                                fRet = CreateUserAccount(ustAnonyName,pstAnonyPass,dwUserCommentResourceId,dwUserFullNameResourceId,TRUE);
                                if( fRet )
                                {
                                    fUpdateComApplications = TRUE;
                                }
                            }
                        }
                    }
                    else
                    {
                        fRet = CreateUserAccount(ustAnonyName,pstAnonyPass,dwUserCommentResourceId,dwUserFullNameResourceId,FALSE);
                        if (!fRet)
                        {
                            if (TRUE == WaitForDCAvailability())
                            {
                                // try again...
                                fRet = CreateUserAccount(ustAnonyName,pstAnonyPass,dwUserCommentResourceId,dwUserFullNameResourceId,FALSE);
                            }
                        }
                    }


                    if (!g_eventLogForAccountRecreation)
                    {
                        CreateEventLogObject ();
                    }

                    if (g_eventLogForAccountRecreation)
                    {
                        CHAR  szAnsiUserName[MAX_PATH];
                        const CHAR  *pszUserNames[1];

                        if (! WideCharToMultiByte(CP_ACP,
                                                      0,
                                                      ustAnonyName,
                                                      -1,
                                                      szAnsiUserName,
                                                      MAX_PATH-1,
                                                      NULL,
                                                      NULL))
                        {
                            memset (szAnsiUserName,0,sizeof(szAnsiUserName));
                        }

                        pszUserNames[0] = szAnsiUserName;

                        // if succeded to recreate an account then log an event
                        if (fRet)
                        {
                            g_eventLogForAccountRecreation->LogEvent(
                                                INET_SVC_ACCOUNT_RECREATED,
                                                1,
                                                pszUserNames,
                                                0 );
                        }
                        else
                        {
                            // if the creation of the account failed, then log that too.
                            g_eventLogForAccountRecreation->LogEvent(
                                                INET_SVC_ACCOUNT_CREATE_FAILED,
                                                1,
                                                pszUserNames,
                                                0 );
                        }
                    }

                    if (dwUserMetaId == MD_WAM_USER_NAME) {
                        ChangeAppIDLaunchACL(TEXT("{9209B1A6-964A-11D0-9372-00A0C9034910}"),
                                             ustAnonyName,
                                             TRUE,
                                             TRUE);
                        ChangeAppIDAccessACL(TEXT("{9209B1A6-964A-11D0-9372-00A0C9034910}"),
                                             ustAnonyName,
                                             TRUE,
                                             TRUE);
                    }
                } // fCreateAccount == TRUE
            } // fCreateAccount == TRUE

            //
            // check if user has enough rights   otherwise add some (bug 361833)
            //

            if (wcscmp(pszDefaultUserNamePrefix,TEXT("IUSR_")) == 0) 
            {
                UpdateUserRights (ustAnonyName,pstrRightsFor_IUSR,sizeof(pstrRightsFor_IUSR)/sizeof(LPTSTR));
            }
            else
            if (wcscmp(pszDefaultUserNamePrefix,TEXT("IWAM_")) == 0) 
            {
                UpdateUserRights (ustAnonyName,pstrRightsFor_IWAM,sizeof(pstrRightsFor_IWAM)/sizeof(LPTSTR));
            }


            // Update the com applications with the new wam user information
            if( fUpdateComApplications )
            {
                HRESULT hr =
                    UpdateComApplications( pcCom, ustAnonyName, pstAnonyPass );

                if( hr != S_OK )
                {
                    if( !g_eventLogForAccountRecreation )
                    {
                        CreateEventLogObject();
                    }

                    if ( g_eventLogForAccountRecreation )
                    {
                        g_eventLogForAccountRecreation->LogEvent(
                            INET_SVC_ACCOUNT_COMUPDATE_FAILED,
                            0,
                            NULL,
                            hr
                            );
                    }
                }
            }
        }
        else
        {
            // This is not one of our accouts.
            // in other words -- it doesn't start with
            // iusr_ or iwam_
            //
            // however there is a problem here.
            //
            // on machines that are made to be replica domain controllers or
            // backup domain controllers, when dcpromo is run to create those types
            // of machines, all the local accounts are wiped out.
            //
            // this is fine if the usernames are iusr_ or iwam_, since they are just
            // re-created in the above code (or the user is warned that they were unable
            // to be crated).  however in the case where these are
            // user created accounts, the user has no way of knowing that 
            // they're iusr/iwam accounts have been hosed.
            //
            // the code here is just to warn the user of that fact.
            if (TRUE == IsDomainController())
            {
                // check if they are valid.
                // Check if this user actually exists...
                fExistence = DoesUserExist(ustAnonyName,&fDisabled);
                if (!fExistence) 
                {
                    if (!fDisabled)
                    {
                        // the user doesn't exist
                        // log SOMETHING at least
                        if (!g_eventLogForAccountRecreation)
                        {
                            CreateEventLogObject ();
                        }

                        if (g_eventLogForAccountRecreation)
                        {
                            CHAR  szAnsiUserName[MAX_PATH];
                            const CHAR  *pszUserNames[1];
                                
                            if (! WideCharToMultiByte(CP_ACP,
                                0,
                                ustAnonyName,
                                -1,
                                szAnsiUserName,
                                MAX_PATH-1,
                                NULL,
                                NULL))
                            {
                                memset (szAnsiUserName,0,sizeof(szAnsiUserName));
                            }
            
                            pszUserNames[0] = szAnsiUserName;

                            g_eventLogForAccountRecreation->LogEvent(
                                                INET_SVC_ACCOUNT_NOT_EXIST,
                                                1,
                                                pszUserNames,
                                                0 );

                        }
                    }
                }
            }
        }
    }
}




VOID UpdateUsers(
    BOOL fRestore /* = FALSE */
    )
{
    HRESULT hresTemp;
    IMDCOM *pcCom;
    BOOL    fPerformUpadate = TRUE;
    BOOL    fPerformPasswordValidate = FALSE;
    HKEY    hkRegistryKey = NULL;
    DWORD   dwRegReturn,dwBuffer, dwSize, dwType;

    //
    // First get the metabase interface
    //
    
    
    dwRegReturn = RegOpenKey(HKEY_LOCAL_MACHINE,
                    L"SOFTWARE\\Microsoft\\InetStp",
                     &hkRegistryKey);
    if (dwRegReturn == ERROR_SUCCESS) 
    {
        dwSize = sizeof(dwBuffer);

        dwRegReturn = RegQueryValueEx(hkRegistryKey,
                        L"DisableUserAccountRestore",
                        NULL,
                        &dwType,
                        (BYTE *)&dwBuffer,
                        &dwSize);
        if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_DWORD)) 
        {
            fPerformUpadate = FALSE;
        }

        if (fPerformUpadate)
        {
            // we are doing the check to see if the user exists...
            // see if we need to verify that the password is ssynced as well...
            dwRegReturn = RegQueryValueEx(hkRegistryKey,
                            L"EnableUserAccountRestorePassSync",
                            NULL,
                            &dwType,
                            (BYTE *)&dwBuffer,
                            &dwSize);
            if ((dwRegReturn == ERROR_SUCCESS) && dwType == (REG_DWORD)) 
            {
                fPerformPasswordValidate = TRUE;
            }
        }

        RegCloseKey( hkRegistryKey );
    }


    if (fPerformUpadate)
    {
        hresTemp = CoCreateInstance(CLSID_MDCOM,
                                    NULL,
                                    CLSCTX_SERVER,
                                    IID_IMDCOM,
                                    (void**) &pcCom);

        if (SUCCEEDED(hresTemp)) {

            PASSWORD_STRING_TYPE pstAnonyPass;
            USERNAME_STRING_TYPE ustAnonyName;

            pstAnonyPass[0] = (TCHAR)'\0';
            ustAnonyName[0] = (TCHAR)'\0';

            UpdateAnonymousUser(pcCom,
                                TEXT("LM/W3SVC"),
                                MD_WAM_USER_NAME,
                                MD_WAM_PWD,
                                IDS_WAMUSER_COMMENT,
                                IDS_WAMUSER_FULLNAME,
                                TEXT("IWAM_"),
                                ustAnonyName,
                                pstAnonyPass,
                                fPerformPasswordValidate);

            pstAnonyPass[0] = (TCHAR)'\0';
            ustAnonyName[0] = (TCHAR)'\0';
            UpdateAnonymousUser(pcCom,
                                TEXT("LM/W3SVC"),
                                MD_ANONYMOUS_USER_NAME,
                                MD_ANONYMOUS_PWD,
                                IDS_USER_COMMENT,
                                IDS_USER_FULLNAME,
                                TEXT("IUSR_"),
                                ustAnonyName,
                                pstAnonyPass,
                                fPerformPasswordValidate);

            //
            // At this point pstAnonyPass should contain the web server password.
            //

            UpdateAnonymousUser(pcCom,
                                TEXT("LM/MSFTPSVC"),
                                MD_ANONYMOUS_USER_NAME,
                                MD_ANONYMOUS_PWD,
                                IDS_USER_COMMENT,
                                IDS_USER_FULLNAME,
                                TEXT("IUSR_"),
                                ustAnonyName,
                                pstAnonyPass,
                                fPerformPasswordValidate);

            pcCom->Release();
        }
    }

    if (g_eventLogForAccountRecreation)
    {
        delete g_eventLogForAccountRecreation;
        g_eventLogForAccountRecreation = NULL;
    }
}

HRESULT 
UpdateComApplications( 
    IMDCOM *    pcCom,
    LPCTSTR     szWamUserName, 
    LPCTSTR     szWamUserPass 
    )
/*++
Routine Description:

    If the IWAM account has been modified, it is necessary to update the
    the out of process com+ applications with the correct account
    information. This routine will collect all the com+ applications and
    reset the activation information.

Arguments:

    pcCom               - metabase object
    szWamUserName       - the new user name
    szWamUserPass       - the new user password

Note:

    This routine is a royal pain in the butt. I take back
    all the good things I may have said about com automation.

Return Value:
    
    HRESULT             - Return value from failed API call
                        - E_OUTOFMEMORY
                        - S_OK - everything worked
                        - S_FALSE - encountered a non-fatal error, unable
                          to reset at least one application.
--*/                       
{
    HRESULT     hr = NOERROR;
    BOOL        fNoErrors = TRUE;

    METADATA_HANDLE     hMetabase = NULL;
    WCHAR *             pwszDataPaths = NULL;
    DWORD               cchDataPaths = 0;
    BOOL                fTryAgain;
    DWORD               cMaxApplications;
    WCHAR *             pwszCurrentPath;

    SAFEARRAY *     psaApplications = NULL;
    SAFEARRAYBOUND  rgsaBound[1];
    DWORD           cApplications;
    VARIANT         varAppKey;
    LONG            rgIndices[1];

    METADATA_RECORD     mdrAppIsolated;
    METADATA_RECORD     mdrAppPackageId;
    DWORD               dwAppIsolated;
    WCHAR               wszAppPackageId[ 40 ];
    DWORD               dwMDGetDataLen = 0;

    ICOMAdminCatalog *      pComCatalog = NULL;
    ICatalogCollection *    pComAppCollection = NULL;
    ICatalogObject *        pComApp = NULL;
    BSTR                    bstrAppCollectionName = NULL;
    LONG                    nAppsInCollection;
    LONG                    iCurrentApp;
    LONG                    nChanges;

    VARIANT     varOldAppIdentity;
    VARIANT     varNewAppIdentity;
    VARIANT     varNewAppPassword;

    // This is built unicode right now. Since all the com apis I need
    // are unicode only I'm using wide characters here. I should get
    // plenty of compiler errors if _UNICODE isn't defined, but just
    // in case....
    DBG_ASSERT( sizeof(TCHAR) == sizeof(WCHAR) );

    DBGPRINTF(( DBG_CONTEXT,
                "Updating activation identity for out of process apps.\n"
                ));

    // Init variants
    VariantInit( &varAppKey );
    VariantInit( &varOldAppIdentity );
    VariantInit( &varNewAppIdentity );
    VariantInit( &varNewAppPassword );

    //
    // Get the applications to be reset by querying the metabase paths
    //

    hr = pcCom->ComMDOpenMetaObject( METADATA_MASTER_ROOT_HANDLE,
                                     L"LM/W3SVC",
                                     METADATA_PERMISSION_READ,
                                     OPEN_TIMEOUT_VALUE,
                                     &hMetabase
                                     );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT, 
                   "Failed to open metabase (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    // Get the data paths string

    fTryAgain = TRUE;
    do
    {
        hr = pcCom->ComMDGetMetaDataPaths( hMetabase,
                                           NULL,
                                           MD_APP_PACKAGE_ID,
                                           STRING_METADATA,
                                           cchDataPaths,
                                           pwszDataPaths,
                                           &cchDataPaths 
                                           );

        if( HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr )
        {
            delete[] pwszDataPaths;
            pwszDataPaths = NULL;

            pwszDataPaths = new WCHAR[cchDataPaths];
            if( !pwszDataPaths )
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }
        }
        else
        {
            fTryAgain = FALSE;
        }
    }
    while( fTryAgain );

    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT, 
                   "Failed to find metadata (%08x) Data(%d)\n",
                   hr,
                   MD_APP_PACKAGE_ID
                   ));
        goto cleanup;
    }
    else if (pwszDataPaths == NULL)
    {
        //
        // If we found no isolated apps, make the path list an empty multisz
        //
        cchDataPaths = 1;
        pwszDataPaths = new WCHAR[cchDataPaths];
        if( !pwszDataPaths )
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
        pwszDataPaths[0] = L'\0';
    }

    // Determine the maximum number of applications

    cMaxApplications = 1; // The pooled application

    for( pwszCurrentPath = pwszDataPaths; 
         *pwszCurrentPath != L'\0';
         pwszCurrentPath += wcslen(pwszCurrentPath) + 1
         )
    {
        cMaxApplications++;
    }

    //
    // Build a key array and load the com applications.
    //

    // Create an array to hold the keys

    rgsaBound[0].cElements = cMaxApplications;
    rgsaBound[0].lLbound = 0;

    psaApplications = SafeArrayCreate( VT_VARIANT, 1, rgsaBound );
    if( psaApplications == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    // Set the out of process pool application key
    varAppKey.vt = VT_BSTR;
    varAppKey.bstrVal = SysAllocString( W3_OOP_POOL_PACKAGE_ID );
    if( !varAppKey.bstrVal )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    rgIndices[0] = 0;
    hr = SafeArrayPutElement( psaApplications, rgIndices, &varAppKey );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT, 
                   "Failed setting an element in a safe array (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    // For each of the application paths determine if an out of process
    // application is defined there and set the appropriate key into
    // our array    

    MD_SET_DATA_RECORD_EXT( &mdrAppIsolated,
                            MD_APP_ISOLATED,
                            METADATA_NO_ATTRIBUTES,
                            ALL_METADATA,
                            DWORD_METADATA,
                            sizeof(DWORD),
                            (PBYTE)&dwAppIsolated
                            );

    MD_SET_DATA_RECORD_EXT( &mdrAppPackageId,
                            MD_APP_PACKAGE_ID,
                            METADATA_NO_ATTRIBUTES,
                            ALL_METADATA,
                            STRING_METADATA,
                            sizeof(wszAppPackageId),
                            (PBYTE)wszAppPackageId
                            );

    wszAppPackageId[0] = L'\0';

    // Go through each data path and set it into our array if
    // it is an isolated application

    cApplications = 1;  // Actual # of applications - 1 for pool

    for( pwszCurrentPath = pwszDataPaths; 
         *pwszCurrentPath != L'\0';
         pwszCurrentPath += wcslen(pwszCurrentPath) + 1
         )
    {
        hr = pcCom->ComMDGetMetaData( hMetabase,
                                      pwszCurrentPath,
                                      &mdrAppIsolated,
                                      &dwMDGetDataLen
                                      );
        if( FAILED(hr) )
        {
            DBGERROR(( DBG_CONTEXT, 
                       "Failed to get data from the metabase (%08x)"
                       " Path(%S) Data(%d)\n",
                       hr,
                       pwszCurrentPath,
                       mdrAppIsolated.dwMDIdentifier
                       ));

            fNoErrors = FALSE;
            continue;
        }

        // Is the application out of process
        if( dwAppIsolated == 1 )
        {
            // Get the application id

            hr = pcCom->ComMDGetMetaData( hMetabase,
                                          pwszCurrentPath,
                                          &mdrAppPackageId,
                                          &dwMDGetDataLen
                                          );
            if( FAILED(hr) )
            {
                DBGERROR(( DBG_CONTEXT, 
                           "Failed to get data from the metabase (%08x)"
                           " Path(%S) Data(%d)\n",
                           hr,
                           pwszCurrentPath,
                           mdrAppPackageId.dwMDIdentifier
                           ));

                fNoErrors = FALSE;
                continue;
            }

            // Add the application id to the array

            VariantClear( &varAppKey );
            varAppKey.vt = VT_BSTR;
            varAppKey.bstrVal = SysAllocString( wszAppPackageId );
            if( !varAppKey.bstrVal )
            {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }

            rgIndices[0]++;
            hr = SafeArrayPutElement( psaApplications, 
                                      rgIndices, 
                                      &varAppKey 
                                      );
            if( FAILED(hr) )
            {
                DBGERROR(( DBG_CONTEXT, 
                           "Failed to set safe array element (%08x)\n",
                           hr
                           ));
                VariantClear( &varAppKey );
                rgIndices[0]--;
                fNoErrors = FALSE;
                continue;
            }
            cApplications++;
        }
    }

    // Done with the metabase
    pcCom->ComMDCloseMetaObject(hMetabase);
    hMetabase = NULL;

    // Shrink the size of the safe-array if necessary
    if( cApplications < cMaxApplications )
    {
        rgsaBound[0].cElements = cApplications;

        hr = SafeArrayRedim( psaApplications, rgsaBound );
        if( FAILED(hr) )
        {
            DBGERROR(( DBG_CONTEXT, 
                       "Failed to redim safe array (%08x)\n",
                       hr
                       ));
            goto cleanup;
        }
    }

    //
    // For each application reset the activation identity
    //

    // Use our key array to get the application collection

    hr = CoCreateInstance( CLSID_COMAdminCatalog,
                           NULL,
                           CLSCTX_SERVER,
                           IID_ICOMAdminCatalog,
                           (void**)&pComCatalog
                           );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT, 
                   "Failed to create COM catalog (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    hr = pComCatalog->GetCollection( L"Applications", 
                                     (IDispatch **)&pComAppCollection
                                     );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT, 
                   "Failed to get Applications collection (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    hr = pComAppCollection->PopulateByKey( psaApplications );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT, 
                   "Failed to populate Applications collection (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    // Iterate over the application collection and update all the
    // applications that use IWAM.

    hr = pComAppCollection->get_Count( &nAppsInCollection );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT, 
                   "Failed to get Applications count (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }

    // Init our new app identity and password.

    varNewAppIdentity.vt = VT_BSTR;
    varNewAppIdentity.bstrVal = SysAllocString( szWamUserName );
    if( !varNewAppIdentity.bstrVal )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    varNewAppPassword.vt = VT_BSTR;
    varNewAppPassword.bstrVal = SysAllocString( szWamUserPass );
    if( !varNewAppPassword.bstrVal )
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    for( iCurrentApp = 0; iCurrentApp < nAppsInCollection; ++iCurrentApp )
    {
        if( pComApp )
        {
            pComApp->Release();
            pComApp = NULL;
        }
        if( varOldAppIdentity.vt != VT_EMPTY )
        {
            VariantClear( &varOldAppIdentity );
        }

        hr = pComAppCollection->get_Item( iCurrentApp, 
                                          (IDispatch **)&pComApp );
        if( FAILED(hr) )
        {
            DBGERROR(( DBG_CONTEXT, 
                       "Failed to get item from Applications collection (%08x)\n",
                       hr
                       ));
            fNoErrors = FALSE;
            continue;
        }

        // If the user has set this to something other than the IWAM_
        // user, then we will respect that and not reset the identiy.

        hr = pComApp->get_Value( L"Identity", &varOldAppIdentity );
        if( FAILED(hr) )
        {
            DBGERROR(( DBG_CONTEXT, 
                       "Failed to get Identify from Application (%08x)\n",
                       hr
                       ));
            fNoErrors = FALSE;
            continue;
        }

        DBG_ASSERT( varOldAppIdentity.vt == VT_BSTR );
        if( varOldAppIdentity.vt == VT_BSTR )
        {
            if( memcmp( L"IWAM_", varOldAppIdentity.bstrVal, 10 ) == 0 )
            {
                hr = pComApp->put_Value( L"Identity", varNewAppIdentity );
                if( FAILED(hr) )
                {
                    DBGERROR(( DBG_CONTEXT, 
                               "Failed to set new Identify (%08x)\n",
                               hr
                               ));
                    fNoErrors = FALSE;
                    continue;
                }

                hr = pComApp->put_Value( L"Password", varNewAppPassword );
                if( FAILED(hr) )
                {
                    DBGERROR(( DBG_CONTEXT, 
                               "Failed to set new Password (%08x)\n",
                               hr
                               ));
                    fNoErrors = FALSE;
                    continue;
                }
            }
            else
            {
                DBGINFO(( DBG_CONTEXT,
                          "Unrecognized application identity (%S)\n",
                          varOldAppIdentity.bstrVal
                          ));
            }
        }
    }

    hr = pComAppCollection->SaveChanges( &nChanges );
    if( FAILED(hr) )
    {
        DBGERROR(( DBG_CONTEXT,
                   "Failed to save changes (%08x)\n",
                   hr
                   ));
        goto cleanup;
    }
    
cleanup:

    if( hMetabase != NULL )
    {
        pcCom->ComMDCloseMetaObject(hMetabase);
    }

    if( psaApplications != NULL )
    {
        SafeArrayDestroy( psaApplications );
    }

    if( pComCatalog != NULL )
    {
        pComCatalog->Release();
    }

    if( pComAppCollection != NULL )
    {
        pComAppCollection->Release();
    }

    if( pComApp != NULL )
    {
        pComApp->Release();
    }

    if( varAppKey.vt != VT_EMPTY )
    {
        VariantClear( &varAppKey );
    }

    if( varOldAppIdentity.vt != VT_EMPTY )
    {
        VariantClear( &varOldAppIdentity );
    }

    if( varNewAppIdentity.vt != VT_EMPTY )
    {
        VariantClear( &varNewAppIdentity );
    }

    if( varNewAppPassword.vt != VT_EMPTY )
    {
        VariantClear( &varNewAppPassword );
    }

    delete [] pwszDataPaths;

    // return
    if( FAILED(hr) )
    {
        return hr;
    }
    else if( fNoErrors == FALSE )
    {
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}

int
IsDomainController(void)
{
    int iReturn = FALSE;

    OSVERSIONINFOEX VerInfo;
    ZeroMemory(&VerInfo, sizeof VerInfo);
    VerInfo.dwOSVersionInfoSize = sizeof VerInfo;
    if (GetVersionEx(reinterpret_cast<OSVERSIONINFO *>(&VerInfo)))
    {
        if (VER_NT_DOMAIN_CONTROLLER == VerInfo.wProductType)
        {
            iReturn = TRUE;
        }
    }

    return iReturn;
}

BOOL
WaitForDCAvailability(void)
{
    BOOL    bRetVal = FALSE;
    HANDLE  hEvent;
    DWORD   dwResult;
    DWORD   dwCount = 0, dwMax;
    DWORD   dwMaxWait = 20000; // 20 second max wait
    HKEY    hKeyNetLogonParams;

    if (FALSE == IsDomainController())
    {
        // not a domain controller
        // so we don't have to worry about replication delays...
        return TRUE;
    }

    dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,TEXT("SYSTEM\\CurrentControlSet\\Services\\netlogon\\parameters"),0,KEY_READ,&hKeyNetLogonParams );
    if ( dwResult == ERROR_SUCCESS ) 
    {
        //
        // value exists
        //
        DWORD   dwSysVolReady = 0,
                dwSize = sizeof( DWORD ),
                dwType = REG_DWORD;

        dwResult = RegQueryValueEx( hKeyNetLogonParams,TEXT("SysVolReady"),0,&dwType,(LPBYTE) &dwSysVolReady,&dwSize );
        if ( dwResult == ERROR_SUCCESS ) 
        {
            //
            // SysVolReady?
            //
            if ( dwSysVolReady == 0 ) 
            {
                HANDLE hEvent;
                //
                // wait for SysVol to become ready
                //
                hEvent = CreateEvent( 0, TRUE, FALSE, TEXT("IISSysVolReadyEvent") );
                if ( hEvent ) 
                {

                    dwResult = RegNotifyChangeKeyValue( hKeyNetLogonParams, FALSE, REG_NOTIFY_CHANGE_LAST_SET, hEvent, TRUE );

                    if ( dwResult == ERROR_SUCCESS )
                    {
                        const DWORD dwMaxCount = 3;
                        do {
                            //
                            // wait for SysVolReady to change
                            // hEvent is signaled for any changes in hKeyNetLogonParams
                            // not just the SysVolReady value.
                            //
                            WaitForSingleObject (hEvent, dwMaxWait / dwMaxCount );
                            dwResult = RegQueryValueEx( hKeyNetLogonParams,TEXT("SysVolReady"),0,&dwType,(LPBYTE) &dwSysVolReady,&dwSize );
                        } while ( dwSysVolReady == 0 && ++dwCount < dwMaxCount );

                        if ( dwSysVolReady ) 
                        {
                            bRetVal = TRUE;
                        }
                    }
                    CloseHandle( hEvent );
                }
            }
            else
            {
                // sysvol is ready
                bRetVal = TRUE;
            }

        }
        else  
        {
            //
            // value is non-existent, SysVol is assumed to be ready
            //
            if ( dwResult == ERROR_FILE_NOT_FOUND ) 
            {
                bRetVal = TRUE;
            }
        }

        RegCloseKey( hKeyNetLogonParams );
    }
    else
    {
        // error opening regkey, maybe it's not even there
        bRetVal = TRUE;
    }

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\festrcnv\detjpncs.c ===
// File Name:   detjpncs.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//
// Modified by v-chikos 

#include "win32.h"
#include "fechrcnv.h"


// The DetectJapaneseCode function find out what kind of code set is there in 
// a character string. 
//
//
// UCHAR *string        Points to the character string to be checked.
//         
// int   count          Specifies the size in bytes of the string pointed
//                      to by the string parameter.
//
// Return Value
// The function return the followings values.
//
//                      Value           Meaning
//                      CODE_ONLY_SBCS  There are no Japanese character in the 
//                                      string. 
//                      CODE_JPN_JIS    JIS Code Set. There are JIS Code Set 
//                                      character in the string.
//                      CODE_JPN_EUC    EUC Code Set. There are EUC Code Set 
//                                      character in the string.
//                      CODE_JPN_SJIS   Shift JIS Code Set. There are Shift JIS
//                                      Code Set character in the string.
//
//

// Note: CODE_UNKNOWN == CODE_ONLY_SBCS
//       added by v-chikos for IIS 2.0J

#define GetNextChar(r)                   \
{                                        \
            if ( --count )               \
                c = *++string;           \
            else                         \
                return (r);              \
}


int DetectJPNCode ( UCHAR *string, int count )
{
    int    i;
    int    c;

    for ( ; count > 0; count--, string++ ) {
        c = *string;

        if ( c == ESC ) { // check for jis (iso-2022-jp)
            if ( count < 3 )
                return CODE_UNKNOWN;
            c = *++string; count--;
            if ( c == KANJI_IN_1ST_CHAR              && 
                 ( *(string+1) == KANJI_IN_2ND_CHAR1 ||    // ESC $ B
                   *(string+1) == KANJI_IN_2ND_CHAR2 ))    // ESC $ @
                return CODE_JPN_JIS;
            else if ( c == KANJI_OUT_1ST_CHAR         && 
                 ( *(string+1) == KANJI_OUT_2ND_CHAR1 ||    // ESC ( B
                   *(string+1) == KANJI_OUT_2ND_CHAR2 ))    // ESC ( J
                return CODE_JPN_JIS;
            else
                return CODE_UNKNOWN;

        } else if ( (0x81 <= c && c <= 0x8d) || (0x8f <= c && c <= 0x9f) ) { // 1
            // found sjis 1st
            return CODE_JPN_SJIS;

        } else if ( 0x8e == c ) { //  2
            // found sjis 1st || euc Kana 1st (SS2)
            GetNextChar( CODE_UNKNOWN )
            if ( (0x40 <= c && c <= 0x7e) || (0x80 <= c && c <= 0xa0) || (0xe0 <= c && c <= 0xfc) ) // 2-1
                // found sjis 2nd 
                return CODE_JPN_SJIS;
            else if ( 0xa1 <= c && c <= 0xdf ) // 2-2
                // found sjis 2nd || euc Kana 2nd (sjis || euc)
                continue;
            else
                // illegal character code sequence
                return CODE_UNKNOWN;

        } else if ( 0xf0 <= c && c <= 0xfe ) { // 4
            // found euc 1st
            return CODE_JPN_EUC;

        } else if ( 0xe0 <= c && c <= 0xef ) { // 5
            // found sjis 1st || euc 1st
            GetNextChar( CODE_UNKNOWN )
            if ( (0x40 <= c && c <= 0x7e) || (0x80 <= c && c <= 0xa0) ) // 5-1
                // found sjis 2nd
                return CODE_JPN_SJIS;
            else if ( 0xfd <= c && c <= 0xfe ) // 5-2
                // found euc 2nd
                return CODE_JPN_EUC;
            else if ( 0xa1 <= c && c <= 0xfc ) // 5-3
                // found sjis 2nd || euc 2nd (sjis || euc)
                continue;
            else
                // illegal character code sequence
                return CODE_UNKNOWN;

        } else if ( 0xa1 <= c && c <= 0xdf ) { // 3
            // found sjis Kana || euc 1st
            GetNextChar( CODE_JPN_SJIS )
            if ( c <= 0x9f ) // 3-4
                // not euc 2nd byte 
                return CODE_JPN_SJIS;
            else if ( 0xa1 <= c && c <= 0xdf ) // 3-2
                // found sjis kana || euc 2nd (sjis || euc)
                continue;
            else if ( 0xe0 <= c && c <= 0xef ) { // 3-3
                // found sjis 1st || euc 2nd
sjis1stOReuc2nd:
                GetNextChar( CODE_JPN_EUC )
                if ( 0xfd <= c && c <= 0xfe ) // 3-3-5
                    // found euc 1st
                    return CODE_JPN_EUC;
                else if ( (0x80 <= c && c <= 0x8d) || (0x8f <= c && c <= 0xa0) ) // 3-3-2
                    // found sjis 2nd
                    return CODE_JPN_SJIS;
                else if ( 0x40 <= c && c <= 0x7e ) // 3-3-1
                    // found sjis 2nd || sbcs (sjis || euc)
                    continue;
                else if ( 0x8e == c ) { // 3-3-3
                    // found sjis 2nd || euc kana 1st
                    GetNextChar( CODE_JPN_SJIS )
                    if ( 0xa1 <= c && c <= 0xdf )
                        // found sjis Kana || euc Kana 2nd (sjis || euc)
                        continue;
                    else
                        // not found euc kana 2nd
                        return CODE_JPN_SJIS;
                } else if ( 0xa1 <= c && c <= 0xfc ) { // 3-3-4
                    // found sjis 2nd || euc 1st
                    GetNextChar( CODE_JPN_SJIS )
                    if ( 0xa1 <= c && c <= 0xdf ) // 3-3-4-1
                        // found sjis kana || euc 2nd (sjis || euc)
                        continue;
                    if ( 0xe0 <= c && c <= 0xef ) // 3-3-4-2
                        // found sjis 1st || euc 2nd
                        goto sjis1stOReuc2nd;
                    if ( 0xf0 <= c && c <= 0xfe ) // 3-3-4-3
                        // found euc 2nd
                        return CODE_JPN_EUC;
                    else
                        // not found euc 2nd
                        return CODE_JPN_SJIS;
                } else
                    // not found sjis 2nd
                    return CODE_JPN_EUC;
            } else if ( 0xf0 <= c && c <= 0xfe ) // 3-1
                return CODE_JPN_EUC;
            else
                return CODE_UNKNOWN;
        }
    }

    return CODE_ONLY_SBCS;

//  |<-----sjis1st---->|  |<-sjisKana->|<-sjis1st->|
//           ss2          |<------euc1st-------------------->|
//  |81   8d|8e|8f   9f|a0|a1        df|e0       ef|f0     fe|
//  |<--1-->|2 |<--1-->|  |<-----3---->|<----5---->|<---4--->|

// case 1 sjis
// case 4 euc

// case 2
//  |<---sjis2nd--->|  |<------sjis2nd---------------------->|
//                                |<-eucKana2nd->|
//  |40           7e|7f|80      a0|a1          df|e0       fc|
//  |<-------1----->|  |<----1--->|<------2----->|<----1---->|

// case 5
//  |<----sjis2nd----->|  |<---------sjis2nd---------------->|
//                                    |<--------euc2nd------>|
//  |40              7e|7f|80       a0|a1            fc|fd fe|
//  |<--------1------->|  |<----1---->|<-------3------>|<-2->|

// case 3
//  |<-----sjis1st---->|  |<-sjisKana->|<-sjis1st->|
//                        |<------euc2nd-------------------->|
//  |81              9f|a0|a1        df|e0       ef|f0     fe|
// <--------4--------->|  |<-----2---->|<----3---->|<--1---->|

// case 3-3
//  |<--sjis2nd-->|  |<------------sjis2nd------------------>|
//                            ss2       |<------euc1st------>|
//  |40         7e|7f|80   8d|8e|8f   a0|a1          fc|fd fe|
//  |<-----1----->|  |<--2-->|3 |<--2-->|<------4----->|<-5->|

// case 3-3-4
//  |<-sjisKana->|<-sjis1st->|
//  |<------euc2nd-------------------->|
//  |a1        df|e0       ef|f0     fe|
//  |<-----1---->|<----2---->|<--3---->|


#if 0 // old code
    for ( i = 0 ; i < count ; i++, string++ ) {
        if ( *string == ESC ) {
            if ( *(string+1) == KANJI_IN_1ST_CHAR    && 
                 ( *(string+2) == KANJI_IN_2ND_CHAR1 ||    // ESC $ B
                   *(string+2) == KANJI_IN_2ND_CHAR2 )) {  // ESC $ @
                    return CODE_JPN_JIS;
            }
            if ( *(string+1) == KANJI_OUT_1ST_CHAR    && 
                 ( *(string+2) == KANJI_OUT_2ND_CHAR1 ||    // ESC ( B
                   *(string+2) == KANJI_OUT_2ND_CHAR2 )) {  // ESC ( J
                    return CODE_JPN_JIS;
            }
        } else if ( *(string) >= 0x0081) {
            if ( *(string) < 0x00a0 ) {
                return CODE_JPN_SJIS;
            }
            else if ( *(string) < 0x00e0 || *(string) > 0x00ef) {
                return CODE_JPN_EUC;
            }
            if ( *(string+1) < 0x00a1) {
                return CODE_JPN_SJIS;
            }
            else if ( *(string+1) > 0x00fc) {
                return CODE_JPN_EUC;
            }
        }
    }
    return CODE_ONLY_SBCS;
#endif // 0
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\festrcnv\euc2sjis.c ===
//
// File Name:   euc2sjis.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "win32.h"
#include "fechrcnv.h"

#ifdef DBCS_DIVIDE
extern DBCS_STATUS dStatus0;
extern DBCS_STATUS dStatus;
#endif

//@
// 
// Syntax:

int EUCChar_to_ShiftJISChar ( UCHAR *pEUC, UCHAR *pShiftJIS )

// The EUCChar_to_ShiftJISChar function convert one character string 
// as EUC code to a Shift JIS code string. 
//
// UCHAR *pEUC          Points to the character string to be converted.
//
// UCHAR *pShiftJIS     Points to a buffer that receives the convert string
//                      from EUC Code to Shift JIS.
//
// Return Value
// The return value is the 
// number of Shift JIS characters written to the buffer pointed to by pSJIS.
//

{
	if ( *pEUC >= 0x0a1 && *pEUC <= 0x0de ) {
		if ( (*pEUC)%2 == 1 ) {	// odd
			*pShiftJIS = ((*pEUC)-0x0a1)/2+0x081;
			goto ODD_SECOND_BYTE;
		}
		else {	// even
			*pShiftJIS = ((*pEUC)-0x0a2)/2+0x081;
			goto EVEN_SECOND_BYTE;
		}
	}
	if ( *pEUC >= 0x0df && *pEUC <= 0x0fe ) {
		if ( (*pEUC)%2 == 1 ) {	// odd
			*pShiftJIS = ((*pEUC)-0x0df)/2+0x0e0;
			goto ODD_SECOND_BYTE;
		}
		else {	// even
			*pShiftJIS = ((*pEUC)-0x0e0)/2+0x0e0;
			goto EVEN_SECOND_BYTE;
		}
	}

	// Is the charcter Hankaku KATAKANA ?
	if ( *pEUC == 0x08e ) {
		*pShiftJIS = *(pEUC+1);
		return( 1 );
	}
	// Is the charcter ASCII charcter ?
	*pShiftJIS = *pEUC;
	return ( 1 );

ODD_SECOND_BYTE:
	if ( *(pEUC+1) >= 0x0a1 && *(pEUC+1) <= 0x0df ) {
		*(pShiftJIS+1) = *(pEUC+1) - 0x061;
	}
	else {
		*(pShiftJIS+1) = *(pEUC+1) - 0x060;
	}
	return ( 2 );
EVEN_SECOND_BYTE:
	*(pShiftJIS+1) = *(pEUC+1)-2;
	return ( 2 );
}

int EUC_to_ShiftJIS ( UCHAR *pEUC, int EUC_len, UCHAR *pSJIS, int SJIS_len )


// The EUC_to_ShiftJIS function convert a character string as EUC code 
// to a Shift JIS code string. 
//
// UCHAR *pEUC          Points to the character string to be converted.
//
// int   EUC_len        Specifies the size in bytes of the string pointed
//                      to by the pEUC parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pSJIS         Points to a buffer that receives the convert string
//                      from EUC Code to Shift JIS.
//         
// int   SJIS_len       Specifies the size, in Shift JIS characters of the 
//                      buffer pointed to by the pSJIS parameter.
//                      If the value is zero,
//                      the function returns the number of Shift JIS characters 
//                      required for the buffer, and makes no use of the pSJIS 
//                      buffer.
//
// Return Value
// If the function succeeds, and SJIS_len is nonzero, the return value is the 
// number of Shift JIS characters written to the buffer pointed to by pSJIS.
//
// If the function succeeds, and SJIS_len is zero, the return value is the
// required size, in Shift JIS characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pSJIS buffer
// is small for setting converted strings.
//

{
    int     re;                // Convert Lenght
    int     i;                 // Loop Counter
    
    if ( EUC_len == -1 ) {
        // If length is not set, last character of the strings is NULL.
        EUC_len = strlen ( pEUC ) + 1;
    }
    i = 0;
    re = 0;
    if ( SJIS_len == 0 ) {
        // Only retrun the required size
#ifdef DBCS_DIVIDE
        if ( dStatus0.nCodeSet == CODE_JPN_EUC ){
            pEUC++;
            i++;

            // Is the charcter Hankaku KATAKANA ?
            if ( dStatus0.cSavedByte == 0x08e )
                re++;
            else // The character is Kanji.
                re+=2;

            dStatus0.nCodeSet = CODE_UNKNOWN;
            dStatus0.cSavedByte = '\0';
        }
#endif
        while ( i < EUC_len ) {
#ifdef DBCS_DIVIDE
            if( ( i == EUC_len - 1 ) &&
                ( *pEUC >= 0x0a1 && *pEUC <= 0x0fe || *pEUC == 0x08e ) ) {
                dStatus0.nCodeSet = CODE_JPN_EUC;
                dStatus0.cSavedByte = *pEUC;
                break;
            }
#endif
            // Is the character Kanji?
            if ( *pEUC >= 0x0a1 && *pEUC <= 0x0fe ) {
                pEUC+=2;
                i+=2;
                re+=2;
                continue;
            }
            // Is the charcter Hankaku KATAKANA ?
            if ( *pEUC == 0x08e ) {
                pEUC+=2;
                i+=2;
                re++;
                continue;
            }
            // Is the charcter ASCII charcter ?
            pEUC++;
            i++;
            re++;
        }
        return ( re );
    }

#ifdef DBCS_DIVIDE
    if ( dStatus.nCodeSet == CODE_JPN_EUC ){
        UCHAR cEUC = dStatus.cSavedByte;

        if ( cEUC >= 0x0a1 && cEUC <= 0x0de ) {
            if ( cEUC % 2 == 1 ) {	// odd
                *pSJIS = (cEUC - 0x0a1) / 2 + 0x081;
                goto ODD_SECOND_BYTE2;
            }
            else {	// even
                *pSJIS = (cEUC - 0x0a2) / 2 + 0x081;
                goto EVEN_SECOND_BYTE2;
            }
        }
        if ( cEUC >= 0x0df && cEUC <= 0x0fe ) {
            if ( cEUC % 2 == 1 ) {	// odd
                *pSJIS = (cEUC - 0x0df) / 2 + 0x0e0;
                goto ODD_SECOND_BYTE2;
            }
            else {	// even
                *pSJIS = (cEUC - 0x0e0) / 2 + 0x0e0;
                goto EVEN_SECOND_BYTE2;
            }
        }
        // Is the charcter Hankaku KATAKANA ?
        if ( cEUC == 0x08e ) {
            *pSJIS++ = *pEUC++;
            i++;
            re++;
            goto END;
        }
ODD_SECOND_BYTE2:
        if ( *pEUC >= 0x0a1 && *pEUC <= 0x0df ) {
            *(pSJIS+1) = *pEUC - 0x061;
        }
        else {
            *(pSJIS+1) = *pEUC - 0x060;
        }
        pEUC++;
        i++;
        re+=2;
        pSJIS+=2;
        goto END;
EVEN_SECOND_BYTE2:
        *(pSJIS+1) = *pEUC - 2;
        pEUC++;
        i++;
        re+=2;
        pSJIS+=2;
END:
        dStatus.nCodeSet = CODE_UNKNOWN;
        dStatus.cSavedByte = '\0';
    }
#endif

    while ( i < EUC_len ) {
#ifdef DBCS_DIVIDE
        if( ( i == EUC_len - 1 ) &&
            ( *pEUC >= 0x0a1 && *pEUC <= 0x0fe || *pEUC == 0x08e ) ) {
            dStatus.nCodeSet = CODE_JPN_EUC;
            dStatus.cSavedByte = *pEUC;
            break;
        }
#endif
        if ( re >= SJIS_len ) {    // Buffer Over?
            return ( -1 );
        }
        if ( *pEUC >= 0x0a1 && *pEUC <= 0x0de ) {
            if ( (*pEUC)%2 == 1 ) {	// odd
                *pSJIS = ((*pEUC)-0x0a1)/2+0x081;
                goto ODD_SECOND_BYTE;
            }
            else {	// even
                *pSJIS = ((*pEUC)-0x0a2)/2+0x081;
                goto EVEN_SECOND_BYTE;
            }
        }
        if ( *pEUC >= 0x0df && *pEUC <= 0x0fe ) {
            if ( (*pEUC)%2 == 1 ) {	// odd
                *pSJIS = ((*pEUC)-0x0df)/2+0x0e0;
                goto ODD_SECOND_BYTE;
            }
            else {	// even
                *pSJIS = ((*pEUC)-0x0e0)/2+0x0e0;
                goto EVEN_SECOND_BYTE;
            }
        }
        // Is the charcter Hankaku KATAKANA ?
        if ( *pEUC == 0x08e ) {
            pEUC++;
            *pSJIS++ = *pEUC++;
            i+=2;
            re++;
            continue;
        }
        // Is the charcter ASCII charcter ?
        *pSJIS++ = *pEUC++;
        i++;
        re++;
        continue;
ODD_SECOND_BYTE:
        if ( re + 1 >= SJIS_len ) {    // Buffer Over?
            return ( -1 );
        }
        if ( *(pEUC+1) >= 0x0a1 && *(pEUC+1) <= 0x0df ) {
            *(pSJIS+1) = *(pEUC+1) - 0x061;
        }
        else {
            *(pSJIS+1) = *(pEUC+1) - 0x060;
        }
        pEUC+=2;
        i+=2;
        re+=2;
        pSJIS+=2;
        continue;
EVEN_SECOND_BYTE:
        if ( re + 1 >= SJIS_len ) {    // Buffer Over?
            return ( -1 );
        }
        *(pSJIS+1) = *(pEUC+1)-2;
        pEUC+=2;
        i+=2;
        re+=2;
        pSJIS+=2;
        continue;

    }
    return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\extend\iis51\sink.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sink.cxx

Abstract:

    IIS Services IISADMIN Extension
    Unicode Metadata Sink.

Author:

    Michael W. Thomas            16-Sep-97

--*/
#include <cominc.hxx>

//extern HANDLE          hevtDone;

#define REG_FP_LOAD_VALUE         "NewFPWebCmdLine"
#define REG_FP_UNLOAD_VALUE       "DelFPWebCmdLine"

#ifdef _NO_TRACING_
DECLARE_DEBUG_PRINTS_OBJECT();
#endif

CSvcExtImpIMDCOMSINK::CSvcExtImpIMDCOMSINK(IMDCOM * pcCom):
    m_dwRefCount(1),
    m_pcCom(pcCom)
{
}

CSvcExtImpIMDCOMSINK::~CSvcExtImpIMDCOMSINK()
{
}

HRESULT
CSvcExtImpIMDCOMSINK::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IMDCOMSINK_W) {
        *ppObject = (IMDCOMSINKW *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CSvcExtImpIMDCOMSINK::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CSvcExtImpIMDCOMSINK::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}

#define SCHEMA_PATH_PREFIX IIS_MD_ADSI_SCHEMA_PATH_W L"/"

HRESULT STDMETHODCALLTYPE
CSvcExtImpIMDCOMSINK::ComMDSinkNotify(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ])
{
    DWORD i, j;
    for (i = 0; i < dwMDNumElements; i++) {
        if (((pcoChangeList[i].dwMDChangeType | MD_CHANGE_TYPE_SET_DATA) != 0) &&

            //
            // If this is a schema change, then don't do anything
            //

            (_wcsnicmp(pcoChangeList[i].pszMDPath,
                       SCHEMA_PATH_PREFIX,
                       ((sizeof(SCHEMA_PATH_PREFIX) / sizeof(WCHAR)) - 1)) != 0)) {

            for (j = 0; j < pcoChangeList[i].dwMDNumDataIDs; j++) {
                switch (pcoChangeList[i].pdwMDDataIDs[j]) {
                case MD_FRONTPAGE_WEB:
                    {
                        RegisterFrontPage( pcoChangeList[i].pszMDPath );
                        break;
                    }
                case MD_SERVER_COMMAND:
                    {
                        ProcessServerCommand(pcoChangeList[i].pszMDPath);
                        break;
                    }
                default:
                    ;

                    //
                    // No specific action for this command
                    //
                }
            }
        }
    }
    return S_OK;
}



#define REG_KEY_W3SVC_VROOTS    TEXT("SYSTEM\\CurrentControlSet\\Services\\W3SVC\\Parameters\\Virtual Roots")
#define REG_KEY_MSFTPSVC_VROOTS TEXT("SYSTEM\\CurrentControlSet\\Services\\MSFTPSVC\\Parameters\\Virtual Roots")


HRESULT STDMETHODCALLTYPE
CSvcExtImpIMDCOMSINK::ComMDEventNotify(
    /* [in] */ DWORD dwMDEvent)
{
    DWORD err;

    if (dwMDEvent == MD_EVENT_MID_RESTORE) {
        //
        // Blow away registry VRoots so they won't be brought back to life
        //
        err = RegDeleteKey(HKEY_LOCAL_MACHINE, REG_KEY_W3SVC_VROOTS);
        if ( err != ERROR_SUCCESS ) {
            DBGINFOW((DBG_CONTEXT,
                      L"[ComMDEventNotify] (%x) Couldn't remove W3SVC VRoot key\n",
                      err  ));
        }

        err = RegDeleteKey(HKEY_LOCAL_MACHINE, REG_KEY_MSFTPSVC_VROOTS);
        if ( err != ERROR_SUCCESS ) {
            DBGINFOW((DBG_CONTEXT,
                      L"[ComMDEventNotify] (%x) Couldn't remove MSFTPSVC VRoot key\n",
                      err  ));
        }

        //
        // Sync up the user accounts with those from the metabase
        //

        UpdateUsers();

    }

    return S_OK;
}

//
// This must be in a non-Unicode file so that registry reads on Win95 work.
//


VOID
CSvcExtImpIMDCOMSINK::RegisterFrontPage(
    LPWSTR   pszPath
    )
{
    HKEY     hkey = NULL;
    CHAR     buff[255];
    CHAR     cmd[512];
    CHAR     achPath[512];
    LPSTR    pszOp;
    DWORD    cbBuff = sizeof( buff );
    DWORD    dwType;
    DWORD dwValue;
    DWORD dwRequiredDataLen;
    HRESULT hresReturn;
    METADATA_RECORD mdrData;

    MD_SET_DATA_RECORD_EXT(&mdrData,
                           MD_FRONTPAGE_WEB,
                           METADATA_NO_ATTRIBUTES,
                           ALL_METADATA,
                           DWORD_METADATA,
                           sizeof(DWORD),
                           (PBYTE)&dwValue)

    hresReturn = m_pcCom->ComMDGetMetaData(METADATA_MASTER_ROOT_HANDLE,
                                           pszPath,
                                           &mdrData,
                                           &dwRequiredDataLen);

    if (FAILED(hresReturn)) {
        if (hresReturn != MD_ERROR_DATA_NOT_FOUND) {
            DBGINFOW((DBG_CONTEXT,
                      L"[RegisterFrontPage] GetData Failed, return code = %X\n",
                      hresReturn));
        }
    }
    else {

        DBGINFOW(( DBG_CONTEXT,
                    L"[RegisterFrontPage] Value - %d, Path - %S\n",
                    dwValue,
                    pszPath ));

        //
        // PREFIX
        // ComMDGetMetaData should not return success without setting the data
        // value pointed to by dwValue. I'm not sure if PREFIX is incapable of
        // recognizing the extra level of indirection or if there is some path
        // that I missed in reviewing ComMDGetMetaData. I'm going to shut down
        // this warning, but I'll open an issue with the PREFIX guys.
        //

        /* INTRINSA suppress = uninitialized */
        pszOp = dwValue ? REG_FP_LOAD_VALUE : REG_FP_UNLOAD_VALUE;


        if ( !RegOpenKeyExA( HKEY_LOCAL_MACHINE,
                            REG_FP_PATH,
                            0,
                            KEY_READ,
                            &hkey )   &&
             !RegQueryValueExA( hkey,
                               pszOp,
                               NULL,
                               &dwType,
                               (BYTE *) &buff,
                               &cbBuff ))
        {

            if ( WideCharToMultiByte( CP_ACP,
                                      0,
                                      pszPath,
                                      -1,
                                      achPath,
                                      sizeof(achPath),
                                      NULL,
                                      NULL ) == 0 )
            {
                DBGINFOW((DBG_CONTEXT,
                          L"Failed to convert path to Ansi, error = %d\n",
                          GetLastError() ));
            }

            else {

                //
                // FrontPage cannot handle trailing slash, so remove it.
                // Need to restore as this is not a local copy of path.
                //

                DWORD dwPathLen = strlen(achPath);

                DBG_ASSERT(achPath[dwPathLen - 1] == '/');

                achPath[dwPathLen - 1] = '\0';

                if ( (strlen( buff ) + (dwPathLen - 1)) < sizeof( cmd ) )
                {
                    STARTUPINFOA StartupInfo;
                    PROCESS_INFORMATION ProcessInformation;
                    BOOL CreateProcessStatus;
                    DWORD ErrorCode;

                    sprintf( cmd, buff, achPath );

                    RtlZeroMemory(&StartupInfo,sizeof(StartupInfo));
                    StartupInfo.cb = sizeof(StartupInfo);
                    StartupInfo.dwFlags = 0;
                    StartupInfo.wShowWindow = 0;
                    CreateProcessStatus = CreateProcessA(
                                            NULL,
                                            cmd,
                                            NULL,
                                            NULL,
                                            FALSE,
                                            0,
                                            NULL,
                                            NULL,
                                            &StartupInfo,
                                            &ProcessInformation );

                    if ( CreateProcessStatus )
                    {
                        DBG_REQUIRE( CloseHandle(ProcessInformation.hProcess) );
                        DBG_REQUIRE( CloseHandle(ProcessInformation.hThread) );
                    }
                    else
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                    "[RegisterFrontPage] CreateProcess returned %d for %s\n",
                                    GetLastError(),
                                    cmd ));
                    }

                }
            }

        } else {

            DBGINFOW((DBG_CONTEXT,
                      L"[RegisterFrontPage] Failed to open reg or read value\n"));
        }

        if ( hkey )
        {
            RegCloseKey( hkey );
        }
    }
}

VOID
CSvcExtImpIMDCOMSINK::ProcessServerCommand(
    LPWSTR   pszPath
    )
{
    HKEY     hkey = NULL;
    WCHAR    pszServiceName[METADATA_MAX_NAME_LEN];
    DWORD    dwType;
    DWORD dwValue;
    DWORD dwRequiredDataLen;
    HRESULT hresReturn;
    METADATA_RECORD mdrData;

    MD_SET_DATA_RECORD_EXT(&mdrData,
                           MD_SERVER_COMMAND,
                           METADATA_NO_ATTRIBUTES,
                           ALL_METADATA,
                           DWORD_METADATA,
                           sizeof(DWORD),
                           (PBYTE)&dwValue)

    hresReturn = m_pcCom->ComMDGetMetaData(METADATA_MASTER_ROOT_HANDLE,
                                           pszPath,
                                           &mdrData,
                                           &dwRequiredDataLen);

    if (FAILED(hresReturn)) {
        DBGINFOW((DBG_CONTEXT,
                  L"[ProcessServerCommand] GetData Failed, return code = %X\n",
                  hresReturn));
    }
    else {

        //
        // PREFIX
        // ComMDGetMetaData should not return success without setting the data
        // value pointed to by dwValue. I'm not sure if PREFIX is incapable of
        // recognizing the extra level of indirection or if there is some path
        // that I missed in reviewing ComMDGetMetaData. I'm going to shut down
        // this warning, but I'll open an issue with the PREFIX guys.
        //

        /* INTRINSA suppress = uninitialized */
        if (dwValue == MD_SERVER_COMMAND_START) {
            if (GetServiceNameFromPath(pszPath,
                                       pszServiceName)) {
                StartIISService(pszServiceName);

            }
        }
    }

}

#define SERVICE_NAME_PREFIX L"/LM/"

BOOL
GetServiceNameFromPath(
    LPWSTR       pszPath,
    LPWSTR       pszServiceName
    )
/*++

Routine Description:

    Start an IIS service

Arguments:
    pszPath - path spcifying which IIS service to start
    pszServiceName - updated with service name

Return Value:
    TRUE - Success
    FALSE - Failure

--*/
{
    LPWSTR          pszPathIndex;
    UINT            cS;

    DBG_ASSERT(pszPath != NULL);
    DBG_ASSERT(pszServiceName != NULL);

    pszPathIndex = pszPath;
    if ((_wcsnicmp( pszPathIndex, \
                    SERVICE_NAME_PREFIX,
                    ((sizeof(SERVICE_NAME_PREFIX) / sizeof(WCHAR)) - 1)) == 0) &&
        (pszPath[(sizeof(SERVICE_NAME_PREFIX) / sizeof(WCHAR)) - 1] != (WCHAR)'\0')) {

        pszPathIndex += ((sizeof(SERVICE_NAME_PREFIX) / sizeof(WCHAR)) -1);

        //
        // copy to temp buffer until path delim
        //

        for ( cS = 0 ; cS < METADATA_MAX_NAME_LEN-1 &&
                       (*pszPathIndex != (WCHAR)'/'); )
        {
            pszServiceName[cS++] = *pszPathIndex++;
        }
        pszServiceName[cS] = (WCHAR)'\0';

        return TRUE;
    }

    return FALSE;
}

VOID
StartIISService(
    LPWSTR       pszServiceName
    )
/*++

Routine Description:

    Start an IIS service

Arguments:
    pszServiceName - specify which IIS service to start

Return Value:
    TRUE - Success
    FALSE - Failure

--*/
{
    SC_HANDLE       scManagerHandle;
    SC_HANDLE       serviceHandle;
    DWORD           errorCode;
    DWORD           iPoll;
    SERVICE_STATUS  ss;

    DBG_ASSERT(pszServiceName != NULL);

    if ( IISGetPlatformType() == PtWindows95 )

    {
        //
        // Start service Win95-style
        //


        if ( !IsInetinfoRunning() )
        {
            if ( _wcsicmp( pszServiceName, L"W3SVC" ) == 0 )
            {
                // We only can start W3SVC on Win95

                if ( !W95StartW3SVC() )
                {
                    DBGINFOW((DBG_CONTEXT,
                              L"[StartIISService] W95StartW3SVC Failed\n"));
                }
            }
        }
    }

    else

    {
        //
        // Start service WinNT-style
        //

        //
        // Open the service control manager
        //

        scManagerHandle = OpenSCManager( NULL,        // local machine
                                         NULL,        // ServicesActive database
                                         SC_MANAGER_ALL_ACCESS ); // all access

        if ( scManagerHandle != NULL ) {

            //
            // Open the service
            //

            serviceHandle = OpenService( scManagerHandle,
                                         pszServiceName,
                                         SERVICE_START );

            if ( serviceHandle != NULL ) {

                //
                // Make sure the service is running
                //

                if (!StartService( serviceHandle,
                                   0,
                                   NULL) &&
                    (GetLastError() != ERROR_SERVICE_ALREADY_RUNNING)) {
                    DBGINFOW(( DBG_CONTEXT,
                                L"[StartIISService] StartService(%s) Failed, Error = %X\n",
                                pszServiceName,
                                GetLastError()));
                }

                CloseServiceHandle( serviceHandle );
            }

            //
            // Close open handle
            //

            CloseServiceHandle( scManagerHandle);

        }

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\festrcnv\win32.h ===
/* win32.h */
/* Jeff Hostetler, Spyglass, Inc., 1994. */
/* Copyright (C) 1994, Spyglass, Inc.  All rights reserved. */

#ifndef _WIN32_H_
#define _WIN32_H_

//#define WIN32_LEAN_AND_MEAN   /* for windows.h */
#include <windows.h>

#include <stdio.h>
#include <string.h>

#endif /* _WIN32_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\festrcnv\fechrcnv.h ===
// Copyright (c) 1995  Microsoft Corpration
//
// File Name : fechrcnv.h
// Owner     : Tetsuhide Akaishi
// Revision  : 1.00 07/20/'95 Tetsuhide Akaishi
//


#include "festrcnv.h"

// Shift JIS Kanji Code Check
#define SJISISKANJI(c) ( ( (UCHAR)(c) >= 0x81 && (UCHAR)(c) <= 0x9f ) || \
                         ( (UCHAR)(c) >= 0xe0 && (UCHAR)(c) <= 0xfc ) )

// Shift JIS Kana Code Check
#define SJISISKANA(c) ( (UCHAR)(c) >= 0xa1 && (UCHAR)(c) <= 0xdf )

#define ESC     0x1b
#define SO      0x0e
#define SI      0x0f

// Define for JIS Code Kanji and Kana IN/OUT characters
#define KANJI_IN_1ST_CHAR       '$'
#define KANJI_IN_2ND_CHAR1      'B'
#define KANJI_IN_2ND_CHAR2      '@'
#define KANJI_IN_STR            "$B"
#define KANJI_IN_LEN             3
#define KANJI_OUT_1ST_CHAR      '('
#define KANJI_OUT_2ND_CHAR1     'J'
#define KANJI_OUT_2ND_CHAR2     'B'
#define KANJI_OUT_LEN            3
#define KANJI_OUT_STR           "(J"

#ifdef DBCS_DIVIDE
typedef struct _dbcs_status
{
    int nCodeSet;
    UCHAR cSavedByte;
    BOOL fESC;
} DBCS_STATUS;
#endif

//--------------------------------
// Internal Functions for Japanese
//--------------------------------

// Detect Japanese Code
int DetectJPNCode ( UCHAR *string, int len );

// Convert from Shift JIS to JIS
int ShiftJIS_to_JIS (
    UCHAR *pShiftJIS,
    int ShiftJIS_len,
    UCHAR *pJIS,
    int JIS_len
    );

// Convert from Shift JIS to EUC
int ShiftJIS_to_EUC (
    UCHAR *pShiftJIS,
    int ShiftJIS_len,
    UCHAR *pJIS,
    int JIS_len
    );

// Convert from JIS  to EUC
int JIS_to_EUC (
    UCHAR *pJIS,
    int JIS_len,
    UCHAR *pEUC,
    int EUC_len
    );

// Convert from JIS to Shift JIS
int JIS_to_ShiftJIS (
    UCHAR *pShiftJIS,
    int ShiftJIS_len,
    UCHAR *pJIS,
    int JIS_len
    );

// Convert from EUC to JIS
int EUC_to_JIS (
    UCHAR *pJIS,
    int JIS_len,
    UCHAR *pEUC,
    int EUC_len
    );

// Convert from EUC to Shift JIS
int EUC_to_ShiftJIS (
    UCHAR *pEUC,
    int EUC_len,
    UCHAR *pShiftJIS,
    int ShiftJIS_len
    );

#ifdef IEXPLORE
void FCC_Init( void );
int FCC_GetCurrentEncodingMode( void );
#endif  // IEXPLORE


#ifdef INETSERVER
UCHAR
SJISCheckLastChar( UCHAR *pShiftJIS, int len );
#endif // INETSERVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\festrcnv\sjis2jis.c ===
// Copyright (c) Microsoft Corpration
//
// File Name:   sjis2jis.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "win32.h"
#include "fechrcnv.h"

void ShiftJISChar_to_JISChar ( UCHAR *pShiftJIS, UCHAR *pJIS )

// The ShiftJISChar_to_JISChar function convert one character string 
// as Shift JIS code to a JIS code string. 
//
// UCHAR *pShiftJIS     Points to the character string to be converted.
//
// UCHAR *pJIS          Points to a buffer that receives the convert string
//                      from Shift JIS Code to JIS.
//
// Return Value
// None 

{
	USHORT	hi_code, low_code;

	hi_code = (*pShiftJIS);
	low_code = *(pShiftJIS+1);
	hi_code -= (hi_code > 0x9f ? 0xb1 : 0x71);
	hi_code = hi_code * 2 + 1;
	if ( low_code > 0x9e ) {
		low_code -= 0x7e;
		hi_code ++;
	}
	else {
		if ( low_code > 0x7e ) {
			low_code --;
		}
		low_code -= 0x1f;
	}
	*(pJIS) = (UCHAR)hi_code;
	*(pJIS+1) = (UCHAR)low_code;
	return;
}


int ShiftJIS_to_JIS ( UCHAR *pShiftJIS, int ShiftJIS_len,
                                                UCHAR *pJIS, int JIS_len )

// The ShiftJIS_to_JIS function convert a character string as Shift JIS code 
// to a JIS code string. 
//
// UCHAR *pShiftJIS     Points to the character string to be converted.
//
// int   ShiftJIS_len   Specifies the size in bytes of the string pointed
//                      to by the pShiftJIS parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pJIS          Points to a buffer that receives the convert string
//                      from Shift JIS Code to JIS.
//         
// int   JIS_len        Specifies the size, in JIS characters of the buffer
//                      pointed to by the pJIS parameter. If the value is zero,
//                      the function returns the number of JIS characters 
//                      required for the buffer, and makes no use of the pJIS 
//                      buffer.
//
// Return Value
// If the function succeeds, and JIS_len is nonzero, the return value is the 
// number of JIS characters written to the buffer pointed to by pJIS.
//
// If the function succeeds, and JIS_len is zero, the return value is the
// required size, in JIS characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pJIS buffer
// is small for setting converted strings.
//

{
    BOOL    kanji_in = FALSE;      // Kanji Mode
    BOOL    kana_in = FALSE;       // Kana  Mode
    int     re;                    // Convert Lenght
    int     i;                     // Loop Counter

    if ( ShiftJIS_len == -1 ) {
        // If length is not set, last character of the strings is NULL.
        ShiftJIS_len = strlen ( pShiftJIS ) + 1;
    }
    i = 0;
    re = 0;
    if ( JIS_len == 0 ) {
        // Only retrun the required size
        while ( i < ShiftJIS_len ) {
            if ( SJISISKANJI(*pShiftJIS) ) {  // Is this charcter 2 bytes Kanji?
                if ( kana_in ) {            // Kana Mode?
                    re ++;
                    kana_in = FALSE;         // Reset Kana Mode;
                }
                if ( kanji_in == FALSE ) {  // Kanji Mode?
                    re += KANJI_IN_LEN;
                    kanji_in = TRUE;        // Set Kanji Mode
                }

                i+=2;
                re += 2;
                pShiftJIS+=2;
            }
            else if ( SJISISKANA(*pShiftJIS) ) {
                if ( kanji_in ) {
                    re += KANJI_OUT_LEN;
                    kanji_in = FALSE;
                }
                if ( kana_in == FALSE ) {
                     re ++;
                     kana_in = TRUE;
                }
                i++;
                re++;
                pShiftJIS++;
            }
            else {
                if ( kana_in ) {
                    re ++;
                    kana_in = FALSE;
                }
                if ( kanji_in ) {
                    re += KANJI_OUT_LEN;
                    kanji_in = FALSE;
                }
                i++;
                re++;
                pShiftJIS++;
            }
        }
        if ( kana_in ) {
            re ++;
            kana_in = FALSE;
        }
        if ( kanji_in ) {
            re += KANJI_OUT_LEN;
            kanji_in = FALSE;
        }
        return ( re );
    }
    while ( i < ShiftJIS_len ) {
        if ( SJISISKANJI(*pShiftJIS) ) {  // Is this charcter 2 bytes Kanji?
            if ( kana_in ) {            // Kana Mode?
                if ( re >= JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                (*pJIS++) = SI;     // Set Kana Out Charcter
                re ++;
                kana_in = FALSE;         // Reset Kana Mode;
            }
            if ( kanji_in == FALSE ) {  // Kanji Mode?
                if ( re + KANJI_IN_LEN > JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                (*pJIS++) = ESC;    // Set Kanji In Charcter
                (*pJIS++) = KANJI_IN_1ST_CHAR;
                (*pJIS++) = KANJI_IN_2ND_CHAR1;
                re += KANJI_IN_LEN;
                kanji_in = TRUE;        // Set Kanji Mode
            }

            if ( re + 2 > JIS_len ) {   // Buffer Over?
                return ( -1 );
            }
            ShiftJISChar_to_JISChar ( pShiftJIS, pJIS );
            i+=2;
            re += 2;
            pShiftJIS+=2;
            pJIS += 2;
        }
        else if ( SJISISKANA(*pShiftJIS) ) {
            if ( kanji_in ) {
                if ( re + KANJI_OUT_LEN > JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                // Set Kanji Out Charcter
                (*pJIS++) = ESC;
                (*pJIS++) = KANJI_OUT_1ST_CHAR;
                (*pJIS++) = KANJI_OUT_2ND_CHAR1;
                re += KANJI_OUT_LEN;
                kanji_in = FALSE;
            }
            if ( kana_in == FALSE ) {
                if ( re >= JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                (*pJIS++) = SO;	// Set Kana In Charcter
                re ++;
                kana_in = TRUE;
            }
            if ( re >= JIS_len ) {   // Buffer Over?
                return ( -1 );
            }
            (*pJIS++) = (*pShiftJIS++) & 0x7f;
            i++;
            re++;
        }
        else {
            if ( kana_in ) {
                if ( re >= JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                (*pJIS++) = SI;	// Set Kana Out Charcter
                re ++;
                kana_in = FALSE;
            }
            if ( kanji_in ) {
                if ( re + KANJI_OUT_LEN > JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                // Set Kanji Out Charcter
                (*pJIS++) = ESC;
                (*pJIS++) = KANJI_OUT_1ST_CHAR;
                (*pJIS++) = KANJI_OUT_2ND_CHAR1;
                re += KANJI_OUT_LEN;
                kanji_in = FALSE;
            }
            if ( re >= JIS_len ) {   // Buffer Over?
                return ( -1 );
            }
            (*pJIS++) = (*pShiftJIS++);
            i++;
            re++;
        }
    }
    if ( kana_in ) {
        if ( re >= JIS_len ) {   // Buffer Over?
            return ( -1 );
        }
        (*pJIS++) = SI;	// Set Kana Out Charcter
        re ++;
        kana_in = FALSE;
    }
    if ( kanji_in ) {
        if ( re + KANJI_OUT_LEN  > JIS_len ) {   // Buffer Over?
            return ( -1 );
        }
        // Set Kanji Out Charcter
        (*pJIS++) = ESC;
        (*pJIS++) = KANJI_OUT_1ST_CHAR;
        (*pJIS++) = KANJI_OUT_2ND_CHAR1;
        re += KANJI_OUT_LEN;
        kanji_in = FALSE;
    }
    return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\festrcnv\status.c ===
// File Name:   status.c
// Owner:       Masahiro Teragawa
// Revision:    1.00  08/23/'95  Masahiro Teragawa
//

#include "win32.h"
#include "fechrcnv.h"

#ifdef DBCS_DIVIDE
DBCS_STATUS dStatus0 = { CODE_UNKNOWN, '\0', FALSE };
BOOL blkanji0 = FALSE;  // Kanji In Mode

DBCS_STATUS dStatus  = { CODE_UNKNOWN, '\0', FALSE };
BOOL blkanji = FALSE;  // Kanji In Mode
BOOL blkana  = FALSE;  // Kana Mode
#endif  // DBCS_DIVIDE

int nCurrentCodeSet = CODE_UNKNOWN;

/*********************************************************************/
/* Function:   FCC_Init                                              */
/*********************************************************************/
void FCC_Init( void )
{
#ifdef DBCS_DIVIDE
    dStatus0.nCodeSet = CODE_UNKNOWN;
    dStatus0.cSavedByte = '\0';
    dStatus0.fESC = FALSE;

    blkanji0 = FALSE;

    dStatus.nCodeSet = CODE_UNKNOWN;
    dStatus.cSavedByte = '\0';
    dStatus.fESC = FALSE;

    blkanji = FALSE;
    blkana  = FALSE;
#endif  // DBCS_DIVIDE

    nCurrentCodeSet = CODE_UNKNOWN;

    return;
}

/*********************************************************************/
/* Function:   FCC_GetCurrentEncodingMode                            */
/*********************************************************************/
int FCC_GetCurrentEncodingMode( void )
{
    return nCurrentCodeSet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\festrcnv\jis2sjis.c ===
//
// File Name:   jis2sjis.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "win32.h"
#include "fechrcnv.h"

#ifdef DBCS_DIVIDE
extern DBCS_STATUS dStatus0;
extern BOOL        blkanji0;  // Kanji In Mode

extern DBCS_STATUS dStatus;
extern BOOL        blkanji;   // Kanji In Mode
extern BOOL        blkana;    // Kana Mode
#endif

VOID JISChar_to_ShiftJISChar ( UCHAR *pJIS, UCHAR *pSJIS )

// The JISChar_to_ShiftJISChar function convert one character string 
// as JIS code to a Shift JIS code string. 
//
// UCHAR *pJIS          Points to the character string to be converted.
//
// UCHAR *pSJIS         Points to a buffer that receives the convert string
//                      from JIS Code to Shift JIS.
//
// Return Value
// None. 
//

{
    *pSJIS = ((*pJIS - 0x21) >> 1) +0x81;
    if ( *pSJIS > 0x9f ) {
        (*pSJIS) += 0x40;
    }
    *(pSJIS+1) = (*(pJIS+1)) + (*pJIS) & 1 ? 0x1f : 0x7d;
    if ( *(pSJIS+1) >= 0x7f ) {
        (*(pSJIS+1)) ++;
    }
}

int JIS_to_ShiftJIS ( UCHAR *pJIS, int JIS_len, UCHAR *pSJIS, int SJIS_len )


// The JIS_to_ShiftJIS function convert a character string as JIS code 
// to a Shift JIS code string. 
//
// UCHAR *pJIS          Points to the character string to be converted.
//
// int   JIS_len        Specifies the size in bytes of the string pointed
//                      to by the pJIS parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pSJIS         Points to a buffer that receives the convert string
//                      from EUC Code to Shift JIS.
//         
// int   SJIS_len       Specifies the size, in Shift JIS characters of the 
//                      buffer pointed to by the pSJIS parameter.
//                      If the value is zero,
//                      the function returns the number of Shift JIS characters 
//                      required for the buffer, and makes no use of the pSJIS 
//                      buffer.
//
// Return Value
// If the function succeeds, and SJIS_len is nonzero, the return value is the 
// number of Shift JIS characters written to the buffer pointed to by pSJIS.
//
// If the function succeeds, and SJIS_len is zero, the return value is the
// required size, in Shift JIS characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pSJIS buffer
// is small for setting converted strings.
//

{
    int     re;                // Convert Lenght
    int     i;                 // Loop Counter
#ifndef DBCS_DIVIDE
    BOOL    blkanji = FALSE;   // Kanji In Mode
    BOOL    blkana = FALSE;    // Kana Mode
#endif
    
    if ( JIS_len == -1 ) {
        // If length is not set, last character of the strings is NULL.
        JIS_len = strlen ( pJIS ) + 1;
    }
    i = 0;
    re = 0;
    if ( SJIS_len == 0 ) {
        // Only retrun the required size
#ifdef DBCS_DIVIDE
        if ( dStatus0.nCodeSet == CODE_JPN_JIS ) {
            UCHAR cJIS = dStatus0.cSavedByte;
            if ( dStatus0.fESC ){
                if ( cJIS ){
                    if ( cJIS == KANJI_IN_1ST_CHAR &&
                         ( *pJIS == KANJI_IN_2ND_CHAR1 ||
                           *pJIS == KANJI_IN_2ND_CHAR2 )){
                        blkanji0 = TRUE;
                        pJIS++;
                        i++;
                    } else if ( cJIS == KANJI_OUT_1ST_CHAR &&
                                ( *pJIS == KANJI_OUT_2ND_CHAR1 ||
                                  *pJIS == KANJI_OUT_2ND_CHAR2 )){
                        blkanji0 = FALSE;
                        pJIS++;
                        i++;
                    } else
                        re += 2;
                } else {
                    if ( *pJIS == KANJI_IN_1ST_CHAR &&
                         ( *(pJIS+1) == KANJI_IN_2ND_CHAR1 ||
                           *(pJIS+1) == KANJI_IN_2ND_CHAR2 )){
                        blkanji0 = TRUE;
                        pJIS += 2;
                        i += 2;
                    } else if ( *pJIS == KANJI_OUT_1ST_CHAR &&
                           ( *(pJIS+1) == KANJI_OUT_2ND_CHAR1 ||
                             *(pJIS+1) == KANJI_OUT_2ND_CHAR2 )){
                        blkanji0 = FALSE;
                        pJIS += 2;
                        i += 2;
                    } else
                        re++;
                }
            } else if ( cJIS ){    // Divide DBCS in KANJI mode
                pJIS++;
                i++;
                re += 2;
            }
            dStatus0.nCodeSet = CODE_UNKNOWN;
            dStatus0.cSavedByte = '\0';
            dStatus0.fESC = FALSE;
        }
#endif
        while ( i < JIS_len ) {
            if ( *pJIS == SO ) {   // Kana  Mode In?
                blkana = TRUE;
                pJIS++;
                i++;
                continue;
            }
            if ( *pJIS == SI ) {   // Kana Mode Out ?
                blkana = FALSE;
                pJIS++;
                i++;
                continue;
            }
            if ( blkana == TRUE ) {
                pJIS++;
                i++;
                re++;
                continue;
            }
            if ( *pJIS == ESC ) {
#ifdef DBCS_DIVIDE
                if ( i == JIS_len - 1 || i == JIS_len - 2 ){
                    dStatus0.nCodeSet = CODE_JPN_JIS;
                    dStatus0.fESC = TRUE;
                    if( i == JIS_len - 2 )
                        dStatus0.cSavedByte = *(pJIS+1);
                    break;
                }
#endif
                if ( *(pJIS+1) == KANJI_IN_1ST_CHAR    && 
                     ( *(pJIS+2) == KANJI_IN_2ND_CHAR1 ||
                       *(pJIS+2) == KANJI_IN_2ND_CHAR2 )) {
#ifdef DBCS_DIVIDE
                    blkanji0 = TRUE;
#else
                    blkanji = TRUE;
#endif
                    pJIS+=3;
                    i+=3;
                    continue;
                }
                if ( *(pJIS+1) == KANJI_OUT_1ST_CHAR    &&
                     ( *(pJIS+2) == KANJI_OUT_2ND_CHAR1 ||
                       *(pJIS+2) == KANJI_OUT_2ND_CHAR2 )) {
#ifdef DBCS_DIVIDE
                    blkanji0 = FALSE;
#else
                    blkanji = FALSE;
#endif
                    pJIS+=3;
                    i+=3;
                    continue;
                }
                pJIS++;
                i++;
                re++;
                continue;
            }
            else {
#ifdef DBCS_DIVIDE
                if ( blkanji0 == FALSE ) {
#else
                if ( blkanji == FALSE ) {
#endif
                    pJIS++;
                    i++;
                    re++;
                    continue;
                }
                else {
#ifdef DBCS_DIVIDE
                    if ( i == JIS_len - 1 ){
                        dStatus0.nCodeSet = CODE_JPN_JIS;
                        dStatus0.cSavedByte = *pJIS;
                        break;
                    }
#endif
                    if ( *pJIS == '*' ) {
                        pJIS+=2;
                        i+=2;
                        re ++;
                        continue;
                    }
                    else {
                        pJIS+=2;
                        i+=2;
                        re +=2;
                        continue;
                    }
                }
            }
        }
        return ( re );
    }

#ifdef DBCS_DIVIDE
    if ( dStatus.nCodeSet == CODE_JPN_JIS ) {
        UCHAR cJIS = dStatus.cSavedByte;
        if ( dStatus.fESC ){
            if ( cJIS){
                if ( cJIS == KANJI_IN_1ST_CHAR &&
                     ( *pJIS == KANJI_IN_2ND_CHAR1 ||
                       *pJIS == KANJI_IN_2ND_CHAR2 )){
                    blkanji = TRUE;
                    pJIS++;
                    i++;
                } else if ( cJIS == KANJI_OUT_1ST_CHAR &&
                            ( *pJIS == KANJI_OUT_2ND_CHAR1 ||
                              *pJIS == KANJI_OUT_2ND_CHAR2 )){
                    blkanji = FALSE;
                    pJIS++;
                    i++;
                } else {
                    *pSJIS = ESC;
                    *(pSJIS+1) = cJIS;
                    re += 2;
                    pSJIS += 2;
                }
            } else {
                if ( *pJIS == KANJI_IN_1ST_CHAR &&
                     ( *(pJIS+1) == KANJI_IN_2ND_CHAR1 ||
                       *(pJIS+1) == KANJI_IN_2ND_CHAR2 )){
                    blkanji = TRUE;
                    pJIS += 2;
                    i += 2;
                } else if ( *pJIS == KANJI_OUT_1ST_CHAR &&
                       ( *(pJIS+1) == KANJI_OUT_2ND_CHAR1 ||
                         *(pJIS+1) == KANJI_OUT_2ND_CHAR2 )){
                    blkanji = FALSE;
                    pJIS += 2;
                    i += 2;
                } else {
                    *pSJIS = ESC;
                    re++;
                    pSJIS++;
                }
            }
        } else if ( cJIS ){    // Divide DBCS in KANJI mode
            // Start One Character Convert from JIS to Shift JIS
            *pSJIS = (cJIS - 0x21 >> 1) +0x81;
            if ( *pSJIS > 0x9f ) {
                (*pSJIS) += 0x40;
            }
            *(pSJIS+1) = *pJIS + ( cJIS & 1 ? 0x1f : 0x7d );
            if ( *(pSJIS+1) >= 0x7f ) {
                (*(pSJIS+1)) ++;
            }
            pJIS++;
            i++;
            re += 2;
            pSJIS += 2;
        }
        dStatus.nCodeSet = CODE_UNKNOWN;
        dStatus.cSavedByte = '\0';
        dStatus.fESC = FALSE;
    }
#endif

    while ( i < JIS_len ) {
        if ( *pJIS == SO ) {   // Kana  Mode In?
            blkana = TRUE;
            pJIS++;
            i++;
            continue;
        }
        if ( *pJIS == SI ) {   // Kana Mode Out ?
            blkana = FALSE;
            pJIS++;
            i++;
            continue;
        }
        if ( blkana == TRUE ) {
            if ( re >= SJIS_len ) { // Buffer Over flow?
                return ( -1 );
            }
            *pSJIS = (*pJIS) | 0x80;
            pJIS++;
            i++;
            re++;
            pSJIS++;
            continue;
        }
        if ( *pJIS == ESC ) {
#ifdef DBCS_DIVIDE
            if ( i == JIS_len - 1 || i == JIS_len - 2 ){
                dStatus.nCodeSet = CODE_JPN_JIS;
                dStatus.fESC = TRUE;
                if( i == JIS_len - 2 )
                    dStatus.cSavedByte = *(pJIS+1);
                break;
            }
#endif
            if ( *(pJIS+1) == KANJI_IN_1ST_CHAR    && 
                 ( *(pJIS+2) == KANJI_IN_2ND_CHAR1 ||
                   *(pJIS+2) == KANJI_IN_2ND_CHAR2 )) {
                blkanji = TRUE;
                pJIS+=3;
                i+=3;
                continue;
            }
            if ( *(pJIS+1) == KANJI_OUT_1ST_CHAR    &&
                 ( *(pJIS+2) == KANJI_OUT_2ND_CHAR1 ||
                   *(pJIS+2) == KANJI_OUT_2ND_CHAR2 )) {
                blkanji = FALSE;
                pJIS+=3;
                i+=3;
                continue;
            }
            if ( re >= SJIS_len ) { // Buffer Over flow?
                return ( -1 );
            }
            *pSJIS = *pJIS;
            pJIS++;
            i++;
            re++;
            pSJIS++;
            continue;
        }
        else {
            if ( blkanji == FALSE ) {
                if ( re >= SJIS_len ) { // Buffer Over flow?
                    return ( -1 );
                }
                *pSJIS = *pJIS;
                pJIS++;
                i++;
                re++;
                pSJIS++;
                continue;
            }
            else {
#ifdef DBCS_DIVIDE
                if ( i == JIS_len - 1 ){
                    dStatus.nCodeSet = CODE_JPN_JIS;
                    dStatus.cSavedByte = *pJIS;
                    break;
                }
#endif
                if ( *pJIS == '*' ) {
                    if ( re >= SJIS_len ) { // Buffer Over flow?
                        return ( -1 );
                    }
                    *pSJIS = *(pJIS+1) | 0x80;
                    pJIS+=2;
                    i+=2;
                    re ++;
                    pSJIS++;
                    continue;
                }
                else {
                    // Kanji Code
                    if ( re + 1 >= SJIS_len ) { // Buffer Over flow?
                        return ( -1 );
                    }
                    // Start One Character Convert from JIS to Shift JIS
                    *pSJIS = ((*pJIS - 0x21) >> 1) +0x81;
                    if ( *pSJIS > 0x9f ) {
                        (*pSJIS) += 0x40;
                    }
                    *(pSJIS+1) = (*(pJIS+1)) + ( (*pJIS) & 1 ? 0x1f : 0x7d );
                    if ( *(pSJIS+1) >= 0x7f ) {
                        (*(pSJIS+1)) ++;
                    }
                    pJIS+=2;
                    i+=2;
                    re +=2;
                    pSJIS+=2;
                    continue;
                }
            }
        }
    }
    return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\festrcnv\unix2pc.c ===
// File Name:   unix2pc.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "win32.h"
#include "fechrcnv.h"

#ifdef DBCS_DIVIDE
extern DBCS_STATUS dStatus0;
extern DBCS_STATUS dStatus;
#endif
#ifdef IEXPLORE
extern int nCurrentCodeSet;
#endif

int JPNUNIX_to_PC ( int CodeSet,
                           UCHAR *pUNIXChar, int UNIXChar_len,
                           UCHAR *pPCChar, int PCChar_len )

// The JPNUNIX_to_PC function convert a character string as Japanese UNIX code 
// set string to a PC code set string. 
//
//                      
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//                      
//                      Value           Meaning
//                      CODE_UNKNOWN    Unknown. If this value is CODE_UNKNOWN,
//                                      Code Type is checked automatically. 
//                                      
//                      CODE_JPN_JIS    JIS Code Set. The function convert 
//                                      pUNIXChar string as JIS code set string
//                                      to a PC code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert 
//                                      pUNIXChar string as EUC code set string
//                                      to a PC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set. 
//
// UCHAR *pUNIXChar     Points to the character string to be converted.
//
// int   UNIXChar_len   Specifies the size in bytes of the string pointed
//                      to by the pUNIXChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pPCChar       Points to a buffer that receives the convert string
//                      from UNIX Code to PC Code.
//         
// int   PCChar_len     Specifies the size, in PC characters of the buffer
//                      pointed to by the pPCChar parameter. If the value is zero,
//                      the function returns the number of PC characters 
//                      required for the buffer, and makes no use of the pPCChar
//                      buffer.
//
// Return Value
// If the function succeeds, and PCChar_len is nonzero, the return value is the 
// number of PC characters written to the buffer pointed to by pPCChar.
//
// If the function succeeds, and PCChar_len is zero, the return value is the
// required size, in PC characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pPCChar buffer
// is small for setting converted strings.
//
{
    int   re;
#ifdef DBCS_DIVIDE
    int   i = 0, nDelta = 0;

    if ( PCChar_len == 0 && dStatus0.nCodeSet != CODE_UNKNOWN)
        CodeSet = dStatus0.nCodeSet;
    else if ( PCChar_len != 0 && dStatus.nCodeSet != CODE_UNKNOWN )
        CodeSet = dStatus.nCodeSet;
    else
#endif
#ifdef IEXPLORE
    if ( nCurrentCodeSet == CODE_UNKNOWN ) {
#endif
    if ( CodeSet == CODE_UNKNOWN ) {
        if ( ( CodeSet = DetectJPNCode ( pUNIXChar, UNIXChar_len ) )
                                       == CODE_ONLY_SBCS ) {
            CodeSet = CODE_JPN_JIS;
        }
    }
#ifdef IEXPLORE
        nCurrentCodeSet = CodeSet;
    } else
        CodeSet = nCurrentCodeSet;
#endif
    switch ( CodeSet ) {
        case CODE_JPN_JIS:    // Japanese JIS Code
            // Convert from JIS to Shift JIS
            re = JIS_to_ShiftJIS ( pUNIXChar, UNIXChar_len,
                                           pPCChar, PCChar_len );
            break;
        case CODE_JPN_EUC:    // Japanese EUC Code
            // Convert from EUC to Shift JIS
            re = EUC_to_ShiftJIS ( pUNIXChar, UNIXChar_len,
                                           pPCChar, PCChar_len );
            break;
        default:
        case CODE_JPN_SJIS:    // Japanese Shift JIS Code
            // Start Only Copy Process
            if ( UNIXChar_len == -1 ) {
                UNIXChar_len = strlen ( pUNIXChar ) + 1;
            }

            if ( PCChar_len != 0 ) {
#ifdef DBCS_DIVIDE
                UCHAR *pPCCharEnd = pPCChar + PCChar_len - 1;
                if ( dStatus.nCodeSet == CODE_JPN_SJIS && dStatus.cSavedByte){
                    *pPCChar++ = dStatus.cSavedByte;
                    *pPCChar = *pUNIXChar;
                    ++UNIXChar_len;
                    ++nDelta;
                    ++i;
                    dStatus.nCodeSet = CODE_UNKNOWN;
                    dStatus.cSavedByte = '\0';
                }

                while(i < UNIXChar_len - nDelta){
                    if(IsDBCSLeadByte(*(pUNIXChar + i))){
                        if(i == UNIXChar_len - nDelta - 1){
                            dStatus.nCodeSet = CODE_JPN_SJIS;
                            dStatus.cSavedByte = *(pUNIXChar + i);
                            --UNIXChar_len;
                            break;
                        } else if((i == UNIXChar_len - nDelta - 2) &&
                                  (*(pUNIXChar + i + 1) == '\0')){
                            dStatus.nCodeSet = CODE_JPN_SJIS;
                            dStatus.cSavedByte = *(pUNIXChar + i);
                            *(pPCChar + i + 1) = '\0';
                            --UNIXChar_len;
                            break;
                        }
                        if(pPCChar + i > pPCCharEnd)  // check destination buf
                            break;
                        *(pPCChar + i++) = *(pUNIXChar + i);
                        *(pPCChar + i++) = *(pUNIXChar + i);
                    } else
                        *(pPCChar + i++) = *(pUNIXChar + i);
                }
#else
                if ( UNIXChar_len > PCChar_len ) {  // Is the buffer small?
                    return ( -1 );
                }
                memmove ( pPCChar, pUNIXChar, UNIXChar_len );
#endif
            }
#ifdef DBCS_DIVIDE
            else {   // Only retrun the required size
                if ( dStatus0.nCodeSet == CODE_JPN_SJIS ){ // 1st byte was saved
                    ++UNIXChar_len;
                    ++nDelta;
                    ++i;
                    dStatus0.nCodeSet = CODE_UNKNOWN;
                    dStatus0.cSavedByte = '\0';
                }

                while(i < UNIXChar_len - nDelta){
                    if(IsDBCSLeadByte(*(pUNIXChar + i))){
                        if(i == UNIXChar_len - nDelta - 1){
                            dStatus0.nCodeSet = CODE_JPN_SJIS;
                            dStatus0.cSavedByte = *(pUNIXChar + i);
                            --UNIXChar_len;
                            break;
                        } else if((i == UNIXChar_len - nDelta - 2) &&
                                  (*(pUNIXChar + i + 1) == '\0')){
                            dStatus0.nCodeSet = CODE_JPN_SJIS;
                            dStatus0.cSavedByte = *(pUNIXChar + i);
                            --UNIXChar_len;
                            break;
                        }
                        i+=2;
                    } else
                        i++;
                }
            }
#endif
            re = UNIXChar_len;
            break;
    }
    return ( re );
}




int WINAPI UNIX_to_PC ( int CodePage, int CodeSet,
                        UCHAR *pUNIXChar, int UNIXChar_len,
                        UCHAR *pPCChar, int PCChar_len )

// The UNIX_to_PC function convert a character string as UNIX code 
// set string to a PC code set string. 
//
// int   CodePage       Country Code Page.
//                      If this value is -1, the function use OS CodePage from 
//                      Operating System automatically.
//                      
//                      Value           Meaning
//                      -1              Auto Detect Mode.
//                      932             Japan.
//                      ???             Taiwan.
//                      ???             Korea.
//                      ???             PRC(Chaina)?
//                      
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//                      
//                      Value           Meaning
//                      CODE_UNKNOWN    Unknown. If this value is CODE_UNKNOWN,
//                                      Code Type is checked automatically. 
//                                      
//                      CODE_JPN_JIS    JIS Code Set. The function convert 
//                                      pUNIXChar string as JIS code set string
//                                      to a PC code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert 
//                                      pUNIXChar string as EUC code set string
//                                      to a PC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set. 
//
// UCHAR *pUNIXChar     Points to the character string to be converted.
//
// int   UNIXChar_len   Specifies the size in bytes of the string pointed
//                      to by the pUNIXChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pPCChar       Points to a buffer that receives the convert string
//                      from UNIX Code to PC Code.
//         
// int   PCChar_len     Specifies the size, in PC characters of the buffer
//                      pointed to by the pPCChar parameter. If the value is zero,
//                      the function returns the number of PC characters 
//                      required for the buffer, and makes no use of the pPCChar
//                      buffer.
//
// Return Value
// If the function succeeds, and PCChar_len is nonzero, the return value is the 
// number of PC characters written to the buffer pointed to by pPCChar.
//
// If the function succeeds, and PCChar_len is zero, the return value is the
// required size, in PC characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pPCChar buffer
// is small for setting converted strings.
//
//@
{
        int     re;

        if ( CodePage == -1 ) {
            CodePage = (int)GetOEMCP();
        }
        switch ( CodePage ) {
        case 932:    // Japanese Code Page
            re = JPNUNIX_to_PC ( CodeSet, pUNIXChar, UNIXChar_len,
                                           pPCChar, PCChar_len );
            break;
//      case ???:    // Taiwan Code Page
//          re = TAIWANUNIX_to_PC (,,,,,,);
//          break;
//      case ???:    // Korea Code Page
//          re = KOREAUNIX_to_PC (,,,,,,);
//          break;
//      case ???:    // PRC Code Page
//          re = PRCUNIX_to_PC (,,,,,,);
//          break;
        default:
            // Start Only Copy Process
            if ( UNIXChar_len == -1 ) {
                UNIXChar_len = strlen ( pUNIXChar ) + 1;
            }
            if ( PCChar_len != 0 ) {
                if ( UNIXChar_len > PCChar_len ) {  // Is the buffer small?
                    return ( -1 );
                }
                memmove ( pPCChar, pUNIXChar, UNIXChar_len );
            }
            re = UNIXChar_len;
            break;
        }
        return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\festrcnv\sjis2euc.c ===
// Copyright (c) Microsoft Corpration
//
// File Name:   sjis2euc.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "win32.h"
#include "fechrcnv.h"

//Shift JIS(SJC) to EUC Conversion algorithm
//Two byte KANJI
//  - 1st byte of Shift JIS charcter 
//	  (XX = Hex value of 1st byte of Shift JIS Charcter)
//    Range 0x81 - 0x9f
//    (2nd byte of Shift JIS is less than or equals to 0x9e)
//                                            (EUC odd)0xa1-0xdd
//              EUC 1st byte = (XX-0x81)*2 + 0xa1
//    (2nd byte of Shift JIS is greater than or equals to 0x9f)
//                                            (EUC even)0xa2-0xde
//              EUC 1st byte = (XX-0x81)*2 + 0xa2
//
//    Range 0xe0 - 0xef
//    (2nd byte of Shift JIS is less than or equals to 0x9e)
//                                            (EUC odd)0xdf-0xfd
//              EUC 1st byte = (XX-0xe0)*2 + 0xdf
//    (2nd byte of Shift JIS is greater than or equals to 0x9f)
//                                            (EUC even)0xa2-0xde
//              EUC 1st byte = (XX-0xe0)*2 + 0xe0
//
//  - 2nd byte of Shift JIS charcter 
//	  (YY = Hex value of 2nd byte of Shift JIS Charcter)
//    Range 0x40 - 0x7e                       (EUC)0xa1 - 0xdf
//              EUC 2nd byte = (YY+0x61)
//    Range 0x80 - 0x9e                       (EUC)0xe0 - 0xfe
//              EUC 2nd byte = (YY+0x60)
//    Range 0x9f - 0xfc                       (EUC)0xa1 - 0xfe
//              EUC 2nd byte = (YY+0x02)
//
//  Range 0x0a1 - 0x0df(Hankaku KATAKANA)
//    1st byte of EUC charcter = 0x08e
//    2nd byte if EUC charcter = C6220 Hankaku KATAKANA code
//    (same byte value as Shift JIS Hankaku KATAKANA) (0x0a1 - 0x0df)

//@
// 
// Syntax:

int ShiftJISChar_to_EUCChar ( UCHAR *pShiftJIS, UCHAR *pEUC )


// The ShiftJISChar_to_EUCChar function convert one Shift JIS character 
// to a JIS code string. 
//
// UCHAR *pShiftJIS     Points to the character string to be converted.
//
// UCHAR *pEUC          Points to a buffer that receives the convert string
//                      from Shift JIS Code to EUC Code.
//
// Return Value
//      The number of bytes to copy.
//

{
	if ( *pShiftJIS >= 0x081 && *pShiftJIS <= 0x09f ) {
		if ( *(pShiftJIS+1) <= 0x09e ) {
			*pEUC = ((*pShiftJIS)-0x081)*2+0x0a1;
		}
		else {
			*pEUC = ((*pShiftJIS)-0x081)*2+0x0a2;
		}
		goto SECOND_BYTE;
	}
	if ( *pShiftJIS >= 0x0e0 && *pShiftJIS <= 0x0ef ) {
		if ( *(pShiftJIS+1) <= 0x09e ) {
			*pEUC = ((*pShiftJIS)-0x0e0)*2+0x0df;
		}
		else {
			*pEUC = ((*pShiftJIS)-0x0e0)*2+0x0e0;
		}
		goto SECOND_BYTE;
	}

	// Is the charcter Hankaku KATAKANA ?
	if ( *pShiftJIS >= 0x0a1 && *pShiftJIS <= 0x0df ) {
		*pEUC = 0x08e;
		*(pEUC+1) = *pShiftJIS;
		return( 2 );
	}
	// Is the charcter IBM Extended Charcter?
	if ( *pShiftJIS >= 0x0fa && *pShiftJIS <= 0x0fc ) {
		// There are no IBM Extended Charcte in EUC charset.
		*pEUC = ' ';
		*(pEUC+1) = ' ';
		return( 2 );
	}
		// Is the charcter ASCII charcter ?
	*pEUC = *pShiftJIS;
	return ( 1 );

SECOND_BYTE:
	if ( *(pShiftJIS+1) >= 0x040 && *(pShiftJIS+1) <= 0x07e ) {
		*(pEUC+1) = *(pShiftJIS + 1) + 0x061;
	}
	else {
		if ( *(pShiftJIS+1) >= 0x080 && *(pShiftJIS+1) <= 0x09e ) {
			*(pEUC+1) = *(pShiftJIS + 1) + 0x060;
		}
		else {
			*(pEUC+1) = *(pShiftJIS + 1) + 0x002;
		}
	}
	return ( 2 );
}


int ShiftJIS_to_EUC ( UCHAR *pShiftJIS, int ShiftJIS_len,
                                                UCHAR *pEUC, int EUC_len )

// The ShiftJIS_to_JIS function convert a character string as Shift JIS code 
// to a EUC code string. 
//
// UCHAR *pShiftJIS     Points to the character string to be converted.
//
// int   ShiftJIS_len   Specifies the size in bytes of the string pointed
//                      to by the pShiftJIS parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pEUC          Points to a buffer that receives the convert string
//                      from Shift JIS Code to EUC Code.
//         
// int   EUC_len        Specifies the size, in EUC characters of the buffer
//                      pointed to by the pEUC parameter. If the value is zero,
//                      the function returns the number of EUC characters 
//                      required for the buffer, and makes no use of the pEUC 
//                      buffer.
//
// Return Value
// If the function succeeds, and EUC_len is nonzero, the return value is the 
// number of EUC characters written to the buffer pointed to by pEUC.
//
// If the function succeeds, and EUC_len is zero, the return value is the
// required size, in EUC characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pEUC buffer
// is small for setting converted strings.
//

{

    int     re;                // Convert Lenght
    int     i;                 // Loop Counter
    
    if ( ShiftJIS_len == -1 ) {
        // If length is not set, last character of the strings is NULL.
        ShiftJIS_len = strlen ( pShiftJIS ) + 1;
    }
    i = 0;
    re = 0;
    if ( EUC_len == 0 ) {
        // Only retrun the required size
        while ( i < ShiftJIS_len ) {
            if ( SJISISKANJI(*pShiftJIS) ) {
                pShiftJIS+=2;
                i+=2;
                re+=2;
                continue;
            }
            if ( SJISISKANA(*pShiftJIS) ) {
                pShiftJIS++;
                i++;
                re+=2;
                continue;
            }
            pShiftJIS++;
            i++;
            re++;
        }
        return ( re );
    }
    while ( i < ShiftJIS_len ) {
        if ( *pShiftJIS >= 0x081 && *pShiftJIS <= 0x09f ) {
            if ( re + 1 >= EUC_len ) {    // Buffer Over?
                return ( -1 );
            }
            if ( *(pShiftJIS+1) <= 0x09e ) {
                *pEUC = ((*pShiftJIS)-0x081)*2+0x0a1;
            }
            else {
                *pEUC = ((*pShiftJIS)-0x081)*2+0x0a2;
            }
            pShiftJIS++;          // Next Char
            pEUC++;
            if ( (*pShiftJIS) >= 0x040 && (*pShiftJIS) <= 0x07e ) {
                (*pEUC) = (*pShiftJIS) + 0x061;
            }
            else {
                if ( (*pShiftJIS) >= 0x080 && (*pShiftJIS) <= 0x09e ) {
                    (*pEUC) = (*pShiftJIS) + 0x060;
                }
                else {
                    (*pEUC) = (*pShiftJIS) + 0x002;
                }
            }
            re+=2;
            i+=2;
            pShiftJIS++;
            pEUC++;
            continue;
        }
        if ( *pShiftJIS >= 0x0e0 && *pShiftJIS <= 0x0ef ) {
            if ( re + 1 >= EUC_len ) {    // Buffer Over?
                return ( -1 );
            }
            if ( *(pShiftJIS+1) <= 0x09e ) {
                *pEUC = ((*pShiftJIS)-0x0e0)*2+0x0df;
            }
            else {
                *pEUC = ((*pShiftJIS)-0x0e0)*2+0x0e0;
            }
            pShiftJIS++;          // Next Char
            pEUC++;
            if ( (*pShiftJIS) >= 0x040 && (*pShiftJIS) <= 0x07e ) {
                (*pEUC) = (*pShiftJIS) + 0x061;
            }
            else {
                if ( (*pShiftJIS) >= 0x080 && (*pShiftJIS) <= 0x09e ) {
                    (*pEUC) = (*pShiftJIS) + 0x060;
                }
                else {
                    (*pEUC) = (*pShiftJIS) + 0x002;
                }
            }
            re+=2;
            i+=2;
            pShiftJIS++;
            pEUC++;
            continue;
        }
        // Is the charcter Hankaku KATAKANA ?
        if ( *pShiftJIS >= 0x0a1 && *pShiftJIS <= 0x0df ) {
            if ( re + 1 >= EUC_len ) {    // Buffer Over?
                return ( -1 );
            }
            *pEUC = 0x08e;
            pEUC++;
            (*pEUC) = *pShiftJIS;
            re+=2;
            i++;
            pShiftJIS++;
            pEUC++;
            continue;
        }

        // Is the charcter IBM Extended Charcter?
        if ( *pShiftJIS >= 0x0fa && *pShiftJIS <= 0x0fc ) {
            if ( re + 1 >= EUC_len ) {    // Buffer Over?
                return ( -1 );
            }
            // There are no IBM Extended Charcte in EUC charset.
            *pEUC = ' ';
            pEUC++;
            (*pEUC) = ' ';
            re+=2;
            i+=2;
            pShiftJIS+=2;
            pEUC++;
            continue;
	}

        // Is the charcter ASCII charcter ?
        if ( re  >= EUC_len ) {    // Buffer Over?
            return ( -1 );
        }
        *pEUC = *pShiftJIS;
        re++;
        i++;
        pShiftJIS++;
        pEUC++;
        continue;
    }
    return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\festrcnv\pc2unix.c ===
// File Name:   pc2unix.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "win32.h"
#include "fechrcnv.h"



int PC_to_JPNUNIX ( int CodeSet,
                           UCHAR *pPCChar, int PCChar_len,
                           UCHAR *pUNIXChar, int UNIXChar_len )
// The PC_to_JPNUNIX function convert a character string as PC code
// set string to a Japanese UNIX code set string.
//
//
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//
//                      Value           Meaning
//                      CODE_JPN_JIS    JIS Code Set. The function convert
//                                      pPCChar string
//                                      to a JIS code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert
//                                      pPCChar string
//                                      to a EUC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set.
//
// UCHAR *pPCChar       Points to the character string to be converted.
//
// int   PCChar_len     Specifies the size in bytes of the string pointed
//                      to by the pPCChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
//
// UCHAR *pUNIXChar     Points to a buffer that receives the convert string
//                      from PC Code to UNIX Code.
//
// int   UNIXChar_len   Specifies the size, in UNIX characters of the buffer
//                      pointed to by the pUNIXChar parameter. If the value is
//                      zero, the function returns the number of UNIX characters
//                      required for the buffer, and makes no use of the
//                      pUNIXChar buffer.
//
// Return Value
// If the function succeeds, and UNIXChar_len is nonzero, the return value is
// the number of UNIX characters written to the buffer pointed to by pUNIXChar.
//
// If the function succeeds, and UNIXChar_len is zero, the return value is the
// required size, in UNIX characters, for a buffer that can receive the
// converted string.
//
// If the function fails, the return value is -1. The error mean pUNIXChar
// buffer is small for setting converted strings.
//
//@
{
    int    re;

        switch ( CodeSet ) {
        default:
        case CODE_JPN_JIS:    // Japanese JIS Code
            // Convert from Shift JIS to JIS
            re = ShiftJIS_to_JIS ( pPCChar, PCChar_len,
                                           pUNIXChar, UNIXChar_len );
            break;
        case CODE_JPN_EUC:    // Japanese EUC Code
            // Convert from Shift JIS to EUC
            re = ShiftJIS_to_EUC ( pPCChar, PCChar_len,
                                           pUNIXChar, UNIXChar_len );
            break;
        case CODE_JPN_SJIS:    // Japanese Shift JIS Code
            // Convert from Shift JIS to Shift JIS
            if ( PCChar_len == -1 ) {
                PCChar_len = strlen ( pPCChar ) + 1;
            }
            if ( UNIXChar_len != 0 ) {
                if ( PCChar_len > UNIXChar_len ) {  // Is the buffer small?
                    return ( -1 );
                }
                // Copy from pPCChar to pUNIXChar
                memmove ( pUNIXChar, pPCChar, PCChar_len );
            }
            re = PCChar_len;
            break;
        }
        return ( re );
}


int WINAPI PC_to_UNIX ( int CodePage, int CodeSet,
                        UCHAR *pPCChar, int PCChar_len,
                        UCHAR *pUNIXChar, int UNIXChar_len )

// The PC_to_UNIX function convert a character string as PC code
// set string to a UNIX code set string.
//
// int   CodePage       Country Code Page.
//                      If this value is -1, the function use OS CodePage from
//                      Operating System automatically.
//
//                      Value           Meaning
//                      -1              Auto Detect Mode.
//                      932             Japan.
//                      ???             Taiwan.
//                      ???             Korea.
//                      ???             PRC(Chaina)?
//
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//
//                      Value           Meaning
//                      CODE_JPN_JIS    JIS Code Set. The function convert
//                                      pPCChar string
//                                      to a JIS code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert
//                                      pPCChar string
//                                      to a EUC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set.
//
// UCHAR *pPCChar       Points to the character string to be converted.
//
// int   PCChar_len     Specifies the size in bytes of the string pointed
//                      to by the pPCChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
//
// UCHAR *pUNIXChar     Points to a buffer that receives the convert string
//                      from PC Code to UNIX Code.
//
// int   UNIXChar_len   Specifies the size, in UNIX characters of the buffer
//                      pointed to by the pUNIXChar parameter. If the value is
//                      zero, the function returns the number of UNIX characters
//                      required for the buffer, and makes no use of the
//                      pUNIXChar buffer.
//
// Return Value
// If the function succeeds, and UNIXChar_len is nonzero, the return value is
// the number of UNIX characters written to the buffer pointed to by pUNIXChar.
//
// If the function succeeds, and UNIXChar_len is zero, the return value is the
// required size, in UNIX characters, for a buffer that can receive the
// converted string.
//
// If the function fails, the return value is -1. The error mean pUNIXChar
// buffer is small for setting converted strings.
//
//@
{
        int     re;

        if ( CodePage == -1 ) {
            CodePage = (int)GetOEMCP();
        }
        switch ( CodePage ) {
        case 932:    // Japanese Code Page
            re = PC_to_JPNUNIX ( CodeSet, pPCChar, PCChar_len,
                                           pUNIXChar, UNIXChar_len );
            break;
//      case ???:    // Taiwan Code Page
//          re = PC_to_TAIWANUNIX (,,,,,,);
//          break;
//      case ???:    // Korea Code Page
//          re = PC_to_KOREAUNIX (,,,,,,);
//          break;
//      case ???:    // PRC Code Page
//          re = PC_to_PRCUNIX (,,,,,,);
//          break;
        default:
            // Start Only Copy Process
            if ( PCChar_len == -1 ) {
                PCChar_len = strlen ( pPCChar ) + 1;
            }
            if ( UNIXChar_len != 0 ) {
                if ( PCChar_len > UNIXChar_len ) {  // Is the buffer small?
                    return ( -1 );
                }
                memmove ( pUNIXChar, pPCChar, PCChar_len );
            }
            re = PCChar_len;
            break;
        }
        return ( re );
}


#if 1//#ifdef INETSERVER
UCHAR
SJISCheckLastChar( UCHAR *pShiftJIS, int len )
/*
    It check the last character of strings whether it is Shift-JIS 1st byte
    or not.

    UCHAR   *pShiftJIS   Shift-JIS strings to check
    int     len          byte size of ShiftJIS strings

    Return value
    0       last character is not a Shift-JIS 1st byte
    last character(Shift-JIS 1st byte)
*/
{
    int ch;

    while ( len-- )
    {
        ch = *pShiftJIS++;
        if ( SJISISKANJI(ch) )
            if ( 0 == len )
                return (UCHAR)ch;
            else
            {
                --len;
                ++pShiftJIS;
            }
    }

    return 0;
}
#endif // INETSERVER



BOOL WINAPI DLLEntry( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    BOOL  fReturn = TRUE;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:

    case DLL_PROCESS_DETACH:

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break ;
    }

    return ( fReturn);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\client\info_cli_stub.c ===
#include "info_cli.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\idl\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Madan Appiah (madana) 10-Oct-1995

Revision History:


--*/


#include <windef.h>
#include <lmcons.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define LPSTR [string] char*
#define BOOL DWORD
#endif

#include <inetcom.h>
#include <iisinfo.h>    // includes inetinfo.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\client\infobind.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    infobind.c

Abstract:

    Routines which use RPC to bind and unbind the client to the common
    internet Admin APIs.

Author:

    Madan Appiah (madana) 10-Oct-1995

Environment:

    User Mode -Win32

Revision History:

    Madan Appiah (madana) 10-Oct-1995 Created.
    Murali R. Krishnan (MuraliK)   15-Nov-1995   Remove Netp routines
    Murali R. Krishnan (MuraliK)   21-Nov-1995   Support TCP/IP binding

--*/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>

#include <info_cli.h>
#include <inetinfo.h>
#include "apiutil.h"



handle_t
INET_INFO_IMPERSONATE_HANDLE_bind(
    INET_INFO_IMPERSONATE_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the inet info admin client stubs when
    it is necessary create an RPC binding to the server end with
    impersonation level of security

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle;
    RPC_STATUS RpcStatus;

    RpcStatus = RpcBindHandleForServer(&BindHandle,
                                       ServerName,
                                       INET_INFO_INTERFACE_NAME,
                                       PROT_SEQ_NP_OPTIONS_W
                                       );


    return BindHandle;
} // INET_INFO_IMPERSONATE_HANDLE_bind()



handle_t
INET_INFO_IDENTIFY_HANDLE_bind(
    INET_INFO_IDENTIFY_HANDLE ServerName
    )

/*++

Routine Description:

    This routine is called from the inet admin client stubs when
    it is necessary create an RPC binding to the server end with
    identification level of impersonation.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    handle_t BindHandle;
    RPC_STATUS RpcStatus;

    RpcStatus = RpcBindHandleForServer(&BindHandle,
                                       ServerName,
                                       INET_INFO_INTERFACE_NAME,
                                       PROT_SEQ_NP_OPTIONS_W
                                       );

    return BindHandle;
} // INET_INFO_IDENTITY_HANDLE_bind()



void
INET_INFO_IMPERSONATE_HANDLE_unbind(
    INET_INFO_IMPERSONATE_HANDLE ServerName,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services.
    This routine is called from the inet admin client stubs when it is
    necessary to unbind from the server end.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);

    (VOID ) RpcBindHandleFree(&BindHandle);

    return;
} // INET_INFO_IMPERSONATE_HANDLE_unbind()



void
INET_INFO_IDENTIFY_HANDLE_unbind(
    INET_INFO_IDENTIFY_HANDLE ServerName,
    handle_t BindHandle
    )

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by all services.
    This routine is called from the inet admin client stubs when it is
    necessary to unbind from a server.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(ServerName);


    (VOID ) RpcBindHandleFree(&BindHandle);

    return;
} // INET_INFO_IDENTITY_HANDLE_unbind()


/****************************** End Of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\client\infotest.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :
        infotest.cxx

   Abstract:
        main program to test the working of RPC APIs for Internet Services

   Author:

           Murali R. Krishnan    ( MuraliK )     23-Jan-1996

   Project:

           Internet Services Common RPC Client.

   Functions Exported:

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include <lm.h>
# include <stdio.h>
# include <stdlib.h>
# include "inetinfo.h"
# include "apiutil.h"

//
//  size of half dword in bits
//
# define HALF_DWORD_SIZE    ( sizeof(DWORD) * 8 / 2)

//
//  To Avoid overflows I multiply using two parts
//
# define LargeIntegerToDouble( li)      \
        ( ( 1 << HALF_DWORD_SIZE) * \
           (( double) (li).HighPart) * ( 1 << HALF_DWORD_SIZE) + \
          ((li).LowPart) \
        )


static LPWSTR g_lpszServerAddress = NULL;

//
// Prototypes of Functions
//

BOOL GenUsageMessage( int argc, char * argv[]);

BOOL TestGetStatistics( int argc, char * argv[]);

BOOL TestInetGetAdminInfo( int argc, char * argv[]);

BOOL TestInetSetAdminInfo( int argc, char * argv[]);




//
//  The following DefineAllCommands() defines a template for all commands.
//  Format: CmdCodeName     CommandName         Function Pointer   Comments
//
//  To add addditional test commands, add just another line to the
//      given list
//  Dont touch any macros below, they are all automatically generated.
//  Always the first entry should be usage function.
//

#define  DefineAllCommands()    \
 Cmd( CmdUsage,             "usage",                GenUsageMessage,    \
        " Commands Available" )                                         \
 Cmd( CmdGetStatistics,     "getstatistics",        TestGetStatistics,  \
        " Get Common Statistics" )                                      \
 Cmd( CmdInetGetAdminInfo,  "igetadmininfo",        TestInetGetAdminInfo, \
        " Get common Internet Administrative Information" )    \
 Cmd( CmdInetSetAdminInfo,  "isetadmininfo",        TestInetSetAdminInfo, \
        " Set common Internet Administrative Information" )    \
 Cmd( CmdGet1Statistics,     "stats",                TestGetStatistics,  \
        " Get Common Statistics" )                                      \
 Cmd( CmdDebugFlags,        "debug",                NULL,               \
        " isetadmininfo: Set Debugging flags for the server" )          \
 Cmd( CmdPortNumber,        "port",                 NULL,               \
        " isetadmininfo: Set the port number for server")               \
 Cmd( CmdMaxConnections,    "maxconn",              NULL,               \
        " isetadmininfo: Set the max connections allowed in server")    \
 Cmd( CmdConnectionTimeout, "timeout",              NULL,               \
        " isetadmininfo: Set the Connection Timeout interval( in seconds)") \
 Cmd( CmdLogAnonymous,      "loganon",              NULL,               \
        " isetadmininfo: Set the LogAnonymous Flag")                    \
 Cmd( CmdLogNonAnonymous,   "lognonanon",           NULL,               \
        " isetadmininfo: Set the LogNonAnonymous Flag")                 \
 Cmd( CmdAnonUserName,      "anonuser",             NULL,               \
        " isetadmininfo: Set the Anonymous User Name ")                 \
 Cmd( CmdAdminName,         "adminname",            NULL,               \
        " isetadmininfo: Set the Administrator name ")                  \
 Cmd( CmdAdminEmail,        "adminemail",           NULL,               \
        " isetadmininfo: Set the Administrator Email ")                 \
 Cmd( CmdServerComment,     "servercomment",        NULL,               \
        " isetadmininfo: Set the Server Comments for server ")          \


// Define command codes

# define Cmd( CmdCode, CmdName, CmdFunc, CmdComments)       CmdCode,

typedef enum  _CmdCodes {
    DefineAllCommands()
    maxCmdCode
} CmdCodes;

#undef Cmd

// Define the functions and array of mappings

// General command function type
typedef BOOL ( * CMDFUNC)( int argc, char * argv[]);

typedef  struct _CmdStruct {
    CmdCodes    cmdCode;
    char *      pszCmdName;
    CMDFUNC     cmdFunc;
    char *      pszCmdComments;
} CmdStruct;


// Define Prototypes of command functions
# define Cmd( CmdCode, CmdName, CmdFunc, CmdComments)    \
    BOOL CmdFunc(int argc, char * argv[]);

// Cause an expansion to generate prototypes
// DefineAllCommands()
// Automatic generation causes a problem when we have NULL in Function ptrs :(
// Let the user explicitly define the prototypes

#undef Cmd

//
// Define the global array of commands
//

# define Cmd( CmdCode, CmdName, CmdFunc, CmdComments)        \
    { CmdCode, CmdName, CmdFunc, CmdComments},

static CmdStruct   g_cmds[] = {

    DefineAllCommands()
    { maxCmdCode, NULL, NULL}       // sentinel command
};

#undef Cmd



/************************************************************
 *    Functions
 ************************************************************/

BOOL
GenUsageMessage( int argc, char * argv[])
{
    CmdStruct * pCmd;

    printf( " Usage:\n %s <server-name/address> <cmd name> <cmd arguments>\n",
            argv[0]);
    for( pCmd = g_cmds; pCmd != NULL && pCmd->cmdCode != maxCmdCode; pCmd++) {
        printf( "\t%s\t%s\n", pCmd->pszCmdName, pCmd->pszCmdComments);
    }

    return ( TRUE);
} // GenUsageMessage()



static
CmdStruct * DecodeCommand( char * pszCmd)
{
    CmdStruct * pCmd;
    if ( pszCmd != NULL) {

        for( pCmd = g_cmds;
             pCmd != NULL && pCmd->cmdCode != maxCmdCode; pCmd++) {

            if ( lstrcmpiA( pszCmd, pCmd->pszCmdName) == 0) {
                 return ( pCmd);
            }
        } // for
    }

    return ( &g_cmds[0]);      // No match found, return usage message
} // DecodeCommand()



static
LPWSTR
ConvertToUnicode( char * psz)
/*++
    Converts a given string into unicode string (after allocating buffer space)
    Returns NULL on failure. Use GetLastError() for details.
--*/
{
    LPWSTR  pszUnicode;
    int     cch;

    cch = strlen( psz) + 1;
    pszUnicode = ( LPWSTR ) malloc( cch * sizeof( WCHAR));

    if ( pszUnicode != NULL) {

       // Success. Copy the string now
       int iRet;

       iRet = MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED,
                                   psz,    cch,
                                   pszUnicode,  cch);

       if ( iRet == 0 || iRet != cch) {

            free( pszUnicode);      // failure so free the block
            pszUnicode = NULL;
       }
    } else {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
    }

    return ( pszUnicode);
} // ConvertToUnicode()


static
VOID
PrintStatisticsInfo( IN LPINET_INFO_STATISTICS_0  pStat)
{
    double gCacheHit = 0;

    if ( pStat == NULL) {

        return ;
    }

    printf( " Printing Statistics Information: \n");
    printf( "%20s = %ld\n", "Cache Bytes Total",
           pStat->CacheCtrs.CacheBytesTotal);
    printf( "%20s = %ld\n", "Cache Bytes In Use",
           pStat->CacheCtrs.CacheBytesInUse);
    printf( "%20s = %ld\n", "Open File Handles ",
           pStat->CacheCtrs.CurrentOpenFileHandles);
    printf( "%20s = %ld\n", "Current Dir Lists",
           pStat->CacheCtrs.CurrentDirLists);
    printf( "%20s = %ld\n", "Current Objects ",
           pStat->CacheCtrs.CurrentObjects);
    printf( "%20s = %ld\n", "Cache Flushes",
           pStat->CacheCtrs.FlushesFromDirChanges);
    printf( "%20s = %ld\n", "Cache Hits",
           pStat->CacheCtrs.CacheHits);
    printf( "%20s = %ld\n", "Cache Misses",
           pStat->CacheCtrs.CacheMisses);
    gCacheHit = (((float) pStat->CacheCtrs.CacheHits * 100) /
                 (pStat->CacheCtrs.CacheHits + pStat->CacheCtrs.CacheMisses));
    printf( "%20s = %6.4g\n", " Cache Hit Ratio",
           gCacheHit);

    printf( "%20s = %ld\n", "Atq Allowed Requests",
           pStat->AtqCtrs.TotalAllowedRequests);
    printf( "%20s = %ld\n", "Atq Blocked Requests",
           pStat->AtqCtrs.TotalBlockedRequests);
    printf( "%20s = %ld\n", "Atq Current Blocked Requests",
           pStat->AtqCtrs.CurrentBlockedRequests);
    printf( "%20s = %ld Bytes/sec\n", "Atq Measured Bandwidth",
           pStat->AtqCtrs.MeasuredBandwidth);



#ifndef NO_AUX_PERF

    printf( " Auxiliary Counters # = %u\n",
           pStat->nAuxCounters);

    for ( DWORD i = 0; i < pStat->nAuxCounters; i++) {

        printf( "Aux Counter[%u] = %u\n", i, pStat->rgCounters[i]);

    } //for

#endif // NO_AUX_PERF

    return;

} // PrintStatisticsInfo()



static
VOID
PrintStatsForTime( IN INET_INFO_STATISTICS_0 *    pStatStart,
                  IN INET_INFO_STATISTICS_0 *    pStatEnd,
                  IN DWORD sInterval)
/*++
  Print the statistics information over a time interval sInterval seconds.
  Arguments:
    pStatStart  pointer to statistics information for starting sample
    pStatEnd    pointer to statistics information for ending sample
    sInterval   Time interval in seconds for the sample

  Returns:
     None

--*/
{
    DWORD dwDiff;

    if ( pStatStart == NULL || pStatEnd == NULL || sInterval == 0 ) {

        return ;
    }

    printf( "Statistics  for Interval = %u seconds\n", sInterval);
    printf( "%20s\t %10s\t%10s\t%10s\t%6s\n\n",
           "Item   ", "Start Sample", "End Sample", "Difference", "Rate/s");

    dwDiff = (pStatEnd->CacheCtrs.CacheBytesTotal -
              pStatStart->CacheCtrs.CacheBytesTotal);
    printf( "%20s\t %10.3g\t %10ld\t %10ld\t%6ld\n",
           "Cache Bytes Total",
           (pStatStart->CacheCtrs.CacheBytesTotal),
           (pStatEnd->CacheCtrs.CacheBytesTotal),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.CacheBytesInUse -
              pStatStart->CacheCtrs.CacheBytesInUse);
    printf( "%20s\t %10.3g\t %10ld\t %10ld\t%6ld\n",
           "Cache Bytes In Use",
           (pStatStart->CacheCtrs.CacheBytesInUse),
           (pStatEnd->CacheCtrs.CacheBytesInUse),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.CurrentOpenFileHandles -
              pStatStart->CacheCtrs.CurrentOpenFileHandles);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "File Handle Cached ",
           (pStatStart->CacheCtrs.CurrentOpenFileHandles),
           (pStatEnd->CacheCtrs.CurrentOpenFileHandles),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.CurrentDirLists -
              pStatStart->CacheCtrs.CurrentDirLists);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Current Dir Lists ",
           (pStatStart->CacheCtrs.CurrentDirLists),
           (pStatEnd->CacheCtrs.CurrentDirLists),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.CurrentObjects -
              pStatStart->CacheCtrs.CurrentObjects);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Current Objects Cached",
           (pStatStart->CacheCtrs.CurrentObjects),
           (pStatEnd->CacheCtrs.CurrentObjects),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.FlushesFromDirChanges -
              pStatStart->CacheCtrs.FlushesFromDirChanges);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Cache Flushes",
           (pStatStart->CacheCtrs.FlushesFromDirChanges),
           (pStatEnd->CacheCtrs.FlushesFromDirChanges),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.CacheHits -
              pStatStart->CacheCtrs.CacheHits);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Cache Hits",
           (pStatStart->CacheCtrs.CacheHits),
           (pStatEnd->CacheCtrs.CacheHits),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->CacheCtrs.CacheMisses -
              pStatStart->CacheCtrs.CacheMisses);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Cache Misses",
           (pStatStart->CacheCtrs.CacheMisses),
           (pStatEnd->CacheCtrs.CacheMisses),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->AtqCtrs.TotalAllowedRequests -
              pStatStart->AtqCtrs.TotalAllowedRequests);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total Atq Allowed Requests",
           (pStatStart->AtqCtrs.TotalAllowedRequests),
           (pStatEnd->AtqCtrs.TotalAllowedRequests),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->AtqCtrs.TotalBlockedRequests -
              pStatStart->AtqCtrs.TotalBlockedRequests);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total Atq Blocked Requests",
           (pStatStart->AtqCtrs.TotalBlockedRequests),
           (pStatEnd->AtqCtrs.TotalBlockedRequests),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->AtqCtrs.TotalRejectedRequests -
              pStatStart->AtqCtrs.TotalRejectedRequests);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Total Atq Rejected Requests",
           (pStatStart->AtqCtrs.TotalRejectedRequests),
           (pStatEnd->AtqCtrs.TotalRejectedRequests),
           dwDiff,
           dwDiff/sInterval
           );

    dwDiff = (pStatEnd->AtqCtrs.CurrentBlockedRequests -
              pStatStart->AtqCtrs.CurrentBlockedRequests);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Current Atq Blocked Requests",
           (pStatStart->AtqCtrs.CurrentBlockedRequests),
           (pStatEnd->AtqCtrs.CurrentBlockedRequests),
           dwDiff,
           dwDiff/sInterval
           );


    dwDiff = (pStatEnd->AtqCtrs.MeasuredBandwidth -
              pStatStart->AtqCtrs.MeasuredBandwidth);
    printf( "%20s\t %10ld\t %10ld\t %10ld\t%6ld\n",
           "Measured Bandwidth",
           (pStatStart->AtqCtrs.MeasuredBandwidth),
           (pStatEnd->AtqCtrs.MeasuredBandwidth),
           dwDiff,
           dwDiff/sInterval
           );

    return;

} // PrintStatisticsInfo()



BOOL
TestGetStatistics( int argc, char * argv[] )
/*++
   Gets common Statistics from server and prints it.
   If the optional time information is given, then this function
   obtains the statistics, sleeps for specified time interval and then
    again obtains new statistics and prints the difference, neatly formatted.

   Arguments:
      argc = count of arguments
      argv  array of strings for command
            argv[0] = stats or getstatistics
            argv[1] = time interval if specified in seconds
--*/
{
    DWORD   err;
    DWORD   timeToSleep = 0;
    INET_INFO_STATISTICS_0 *  pStat1 = NULL;

    if ( argc > 1 && argv[1] != NULL) {

        timeToSleep = atoi( argv[1]);
    }

    err = InetInfoQueryStatistics(g_lpszServerAddress,
                                  0,
                                  0,
                                  (LPBYTE *) &pStat1);

    if ( err == NO_ERROR) {

        if ( timeToSleep <= 0) {

            PrintStatisticsInfo( pStat1);
        } else {

            INET_INFO_STATISTICS_0  *  pStat2 = NULL;

            printf( "Statistics For Time Interval %u seconds\n\n",
                   timeToSleep);

            Sleep( timeToSleep * 1000);   // sleep for the interval
            err = InetInfoQueryStatistics(g_lpszServerAddress,
                                       0,
                                       0,
                                       (LPBYTE *) &pStat2);

            if ( err == NO_ERROR) {

                PrintStatsForTime( pStat1, pStat2, timeToSleep);
            }

            if ( pStat2 != NULL) {

                MIDL_user_free( pStat2);
            }
        }
    }

    if ( pStat1 != NULL) {

        MIDL_user_free( pStat1);
    }

    SetLastError( err);
    return ( err == NO_ERROR);
} // TestGetStatistics()






static VOID
PrintInetAdminInformation( IN LPINETA_CONFIG_INFO  pConfigInfo)
{
    if ( pConfigInfo == NULL)
        return;

    printf( "\n Printing InetA Config Information in %08x\n", pConfigInfo);
    printf( "%20s= %d\n", "LogAnonymous",   pConfigInfo->fLogAnonymous);
    printf( "%20s= %d\n", "LogNonAnonymous",pConfigInfo->fLogNonAnonymous);
    printf( "%20s= %08x\n", "Authentication Flags",
           pConfigInfo->dwAuthentication);

    printf( "%20s= %d\n", "Port",           pConfigInfo->sPort);
    printf( "%20s= %d\n", "Connection Timeout",
           pConfigInfo->CommonConfigInfo.dwConnectionTimeout);
    printf( "%20s= %d\n",  "Max Connections",
           pConfigInfo->CommonConfigInfo.dwMaxConnections);

    printf( "%20s= %S\n", "AnonUserName",
           pConfigInfo->lpszAnonUserName);
    printf( "%20s= %S\n", "AnonPassword",
           pConfigInfo->szAnonPassword);

    printf( "%20s= %S\n", "Admin Name",
           pConfigInfo->CommonConfigInfo.lpszAdminName);
    printf( "%20s= %S\n", "Admin Email",
           pConfigInfo->CommonConfigInfo.lpszAdminEmail);
    printf( "%20s= %S\n", "Server Comments",
           pConfigInfo->CommonConfigInfo.lpszServerComment);

    //
    // IP lists and Grant lists, Virtual Roots are not included now. Later.
    //

    return;
} // PrintInetAdminInformation()




static DWORD
GetServiceIdFromString( IN LPCSTR pszService)
{
    if ( pszService != NULL) {

        if ( !_stricmp(pszService, "HTTP")) {

            return ( INET_HTTP);
        } else if (!_stricmp( pszService, "GOPHER")) {

            return (INET_GOPHER);
        } else if ( !_stricmp( pszService, "FTP")) {

            return (INET_FTP);
        } else if ( !_stricmp( pszService, "DNS")) {

            return (INET_DNS);
        }
    }

    return ( INET_HTTP);
} // GetServiceIdFromString()



static BOOL
TestInetGetAdminInfo( int argc, char * argv[] )
/*++
   Gets the configuration information using InetInfoGetAdminInformation()
   argv[0] = igetadmininfo
   argv[1] = service name  ( gopher, http, ftp, catapult)

--*/
{
    DWORD err;
    LPINETA_CONFIG_INFO  pConfig = NULL;
    DWORD dwServiceId;

    printf( " InetInfoGetAdminInformation() called at: Time = %d\n",
            GetTickCount());

    dwServiceId = (argc > 1) ? GetServiceIdFromString( argv[1]) : INET_HTTP;

    err = InetInfoGetAdminInformation( NULL,  // g_lpszServerAddress,
                                    dwServiceId,
                                   &pConfig);

    printf( "Finished at Time = %d\n", GetTickCount());
    printf( "InetInfoGetAdminInformation returned Error Code = %d\n", err);

    if ( err == NO_ERROR) {
        PrintInetAdminInformation( pConfig);
        MIDL_user_free( ( LPVOID) pConfig);
    }


    SetLastError( err);
    return ( err == NO_ERROR);
} // TestInetGetAdminInfo()




DWORD
SetInetAdminField(
    IN LPINETA_CONFIG_INFO  pConfigIn,
    IN char * pszSubCmd,
    IN char * pszValue)
{
    DWORD err = NO_ERROR;
    CmdStruct * pCmd = DecodeCommand( pszSubCmd); // get command struct

    if ( pCmd == NULL) {
        // ignore invalid commands
        printf( " Invalid SubCommand for set admin info %s. Ignoring...\n",
                pszSubCmd);
        return ( ERROR_INVALID_PARAMETER);
    }

    switch ( pCmd->cmdCode) {

        case CmdPortNumber:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_PORT_NUMBER);
            pConfigIn->sPort = atoi( pszValue);
            break;

        case CmdConnectionTimeout:
            SetField( pConfigIn->FieldControl, FC_INET_COM_CONNECTION_TIMEOUT);
            pConfigIn->CommonConfigInfo.dwConnectionTimeout = atoi( pszValue);
            break;

        case CmdMaxConnections:
            SetField( pConfigIn->FieldControl, FC_INET_COM_MAX_CONNECTIONS);
            pConfigIn->CommonConfigInfo.dwMaxConnections = atoi( pszValue);
            break;

          case CmdLogAnonymous:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_LOG_ANONYMOUS);
            pConfigIn->fLogAnonymous = atoi( pszValue);
            break;

          case CmdLogNonAnonymous:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_LOG_NONANONYMOUS);
            pConfigIn->fLogNonAnonymous = atoi( pszValue);
            break;

          case CmdAnonUserName:
            SetField( pConfigIn->FieldControl, FC_INET_INFO_ANON_USER_NAME);
            pConfigIn->lpszAnonUserName = ConvertToUnicode( pszValue);
            if ( pConfigIn->lpszAnonUserName == NULL) {
                err = GetLastError();
            }
            break;

          case CmdAdminName:
            SetField( pConfigIn->FieldControl, FC_INET_COM_ADMIN_NAME);
            pConfigIn->CommonConfigInfo.lpszAdminName =
              ConvertToUnicode( pszValue);
            if ( pConfigIn->CommonConfigInfo.lpszAdminName == NULL) {
                err = GetLastError();
            }
            break;

          case CmdAdminEmail:
            SetField( pConfigIn->FieldControl, FC_INET_COM_ADMIN_EMAIL);
            pConfigIn->CommonConfigInfo.lpszAdminEmail =
              ConvertToUnicode( pszValue);
            if ( pConfigIn->CommonConfigInfo.lpszAdminEmail == NULL) {
                err = GetLastError();
            }
            break;

          case CmdServerComment:
            SetField( pConfigIn->FieldControl, FC_INET_COM_SERVER_COMMENT);
            pConfigIn->CommonConfigInfo.lpszServerComment =
              ConvertToUnicode( pszValue);
            if ( pConfigIn->CommonConfigInfo.lpszServerComment == NULL) {
                err = GetLastError();
            }
            break;


        default:
            printf( " Invalid Sub command %s for SetConfigInfo(). Ignoring.\n",
                    pszSubCmd);
            err = ERROR_INVALID_PARAMETER;
            break;

    }  // switch


    return ( err);
} // SetAdminField()


static VOID
FreeBuffer( IN PVOID * ppBuffer)
{
    if ( *ppBuffer != NULL) {
        free( * ppBuffer);
        *ppBuffer = NULL;       // reset the old value
    }
    return;
} // FreeBuffer()

VOID
FreeStringsInInetConfigInfo( IN OUT LPINETA_CONFIG_INFO pConfigInfo)
{
    FreeBuffer( (PVOID *) & pConfigInfo->lpszAnonUserName);

} // FreeStringsInInetConfigInfo()



BOOL
TestInetSetAdminInfo( int argc, char * argv[])
/*++
    Arguments:
        argc = count of arguments
        argv  array of strings for command
            argv[0] = isetadmininfo
            argv[1] = sub function within set info for testing
            argv[2] = value for sub function
 for all information to be set, give <sub command name> <value>
--*/
{
    DWORD err = ERROR_CALL_NOT_IMPLEMENTED;
    LPINETA_CONFIG_INFO  * ppConfigOut = NULL;
    INETA_CONFIG_INFO  configIn;   // config values that are set

    if ( argc < 1 || ( (argc & 0x1) != 0x1 ) ) {  // argc should be > 1 and odd

        printf( "Invalid Number of arguments for %s\n", argv[0]);
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    // form the admin info block to set the information
    //
    memset( ( LPVOID) &configIn, 0, sizeof( configIn)); // init to Zeros

    // extract each field and value to set in configIn

    for( ; --argc > 1; argc -= 2) {

        if ( SetInetAdminField( &configIn, argv[argc - 1], argv[argc])
             != NO_ERROR)  {

            break;
        }

    } // for() to extract and set all fields

    if ( err != NO_ERROR) {
        // Now make RPC call to set the fields
        err = InetInfoSetAdminInformation( g_lpszServerAddress,
                                          INET_HTTP,
                                          &configIn);
    }

    // Need to free all the buffers allocated for the strings
    FreeStringsInInetConfigInfo( &configIn);

    SetLastError( err );
    return ( err == NO_ERROR );
} // TestSetInetAdminInfo()



int __cdecl
main( int argc, char * argv[])
{
    DWORD err = NO_ERROR;
    char ** ppszArgv;       // arguments for command functions
    int     cArgs;           // arg count for command functions
    char * pszCmdName;
    CmdStruct  * pCmd;
    CMDFUNC pCmdFunc = NULL;

    if ( argc < 3 || argv[1] == NULL ) {

      // Insufficient arguments
       GenUsageMessage( argc, argv);
       return ( 1);
    }

    pszCmdName = argv[2];
    if (( pCmd = DecodeCommand( pszCmdName)) == NULL || pCmd->cmdFunc == NULL) {
        printf( "Internal Error: Invalid Command %s\n", pszCmdName);
        GenUsageMessage( argc, argv);
        return ( 1);
    }

    g_lpszServerAddress = ConvertToUnicode( argv[1]);   // get server address

    cArgs = argc - 2;
    ppszArgv = argv + 2;     // position at the start of the command name

    if ( !(*pCmd->cmdFunc)( cArgs, ppszArgv)) {     // call the test function

        // Test function failed.
        printf( "Command %s failed. Error = %d\n", pszCmdName, GetLastError());
        return ( 1);
    }

    printf( " Command %s succeeded\n", pszCmdName);
    return ( 0);        // success

} // main()





/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\idl\makefile.inc ===
#
#   makefile.idl
#       Created: ???
#
#   Revision
#       MuraliK     2-March-1995 [ Eliminated absolute directory dependencies]
#
#   Specify the following in the file for use
#
#   IDL_FILE_NAME   ( without the .idl suffix)
#   IDL_FLAGS       if any thing specific required
#

!INCLUDE $(NTMAKEENV)\makefile.plt

IDL_FILE_BASENAME   = info

IDL_FILE_NAME   = info
IDL_FLAGS       = -ms_ext -c_ext -oldnames $(MIDL_OPTIMIZATION_NT5)
IMPORTS         = imports

CLIENT_H    = $(O)\$(IDL_FILE_NAME)_cli.h
SERVER_H    = $(O)\$(IDL_FILE_NAME)_srv.h

CLIENT_ACF  = $(IDL_FILE_NAME)cli.acf
SERVER_ACF  = $(IDL_FILE_NAME)srv.acf

!IFNDEF  DISABLE_NET_UNICODE

UNICODE         = 1
NET_C_DEFINES   = -DUNICODE
!ENDIF


SDKINC          = $(SDK_INC_PATH)
SDKCRTINC       = $(CRT_INC_PATH)

INCS            = -I. -I$(SDKINC)  -I$(SDKCRTINC) -I$(IISBASEDIR)\inc

CLIENT_STUB     = $(O)\$(IDL_FILE_NAME)_cli.c
SERVER_STUB     = $(O)\$(IDL_FILE_NAME)_srv.c

CLIENT_TARGETS  = $(CLIENT_STUB) \
                  $(CLIENT_H)
SERVER_TARGETS  = $(SERVER_STUB) \
                  $(SERVER_H)

TARGETS         = $(CLIENT_TARGETS)  $(SERVER_TARGETS)
EXTRN_DEPENDS   = $(IISBASEDIR)\inc\inetinfo.h

CLIENT_FLAGS    =  -server none -acf $(CLIENT_ACF) -header $(CLIENT_H)
SERVER_FLAGS    =  -client none -acf $(SERVER_ACF) -header $(SERVER_H)

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) $(NET_C_DEFINES)

#
#  Define output and dependencies
#


all:    $(TARGETS) $(EXTRN_DEPENDS)
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF


#
#  MIDL Compile stuff
#
$(CLIENT_TARGETS):  .\$(IDL_FILE_BASENAME).idl  $(EXTRN_DEPENDS) .\$(IMPORTS).idl \
                    .\$(IMPORTS).h .\$(CLIENT_ACF)
    midl $(IDL_FLAGS) $(CPP) $(CLIENT_FLAGS) .\$(IDL_FILE_BASENAME).idl  -cstub $(CLIENT_STUB) $(INCS)

$(SERVER_TARGETS):  .\$(IDL_FILE_BASENAME).idl  $(EXTRN_DEPENDS) .\$(IMPORTS).idl \
                    .\$(IMPORTS).h .\$(SERVER_ACF)
    midl $(IDL_FLAGS) $(CPP) $(SERVER_FLAGS) .\$(IDL_FILE_BASENAME).idl -sstub $(SERVER_STUB) $(INCS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\client\infostub.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    infostub.c

Abstract:

    Client stubs of the Internet Info Server Admin APIs.

Author:

    Madan Appiah (madana) 10-Oct-1993

Environment:

    User Mode - Win32

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "info_cli.h"

#include <ntsam.h>
#include <ntlsa.h>

#include <ftpd.h>
#include <w3svc.h>
#include <rpcutil.h>
#include <winsock2.h>

//
//  Quick macro to initialize a unicode string
//

WCHAR  g_wchUnicodeNull[] = L"";

#define _InitUnicodeString( pUnicode, pwch )                       \
   {                                                               \
        (pUnicode)->Buffer    = pwch;                              \
        (pUnicode)->Length    = wcslen( pwch ) * sizeof(WCHAR);    \
        (pUnicode)->MaximumLength = (pUnicode)->Length + sizeof(WCHAR); \
   }

# define InitUnicodeString( pUnicode, pwch)  \
   if (pwch == NULL) { _InitUnicodeString( pUnicode, g_wchUnicodeNull); } \
   else              { _InitUnicodeString( pUnicode, pwch);             } \


//
//  Returns a unicode empty string if the string is NULL
//

#define EMPTY_IF_NULL(str)      (str ? str : L"")

struct SRV_SECRET_NAMES
{
    DWORD   dwID;
    LPWSTR  SecretName;
    LPWSTR  RootSecretName;
}
aSrvSecrets[] =
{
    INET_FTP,     FTPD_ANONYMOUS_SECRET_W,     FTPD_ROOT_SECRET_W,
    INET_HTTP,    W3_ANONYMOUS_SECRET_W,       W3_ROOT_SECRET_W,
    INET_GOPHER,  GOPHERD_ANONYMOUS_SECRET_W , GOPHERD_ROOT_SECRET_W,
    //INET_CHAT,    CHAT_ANONYMOUS_SECRET_W,     CHAT_ROOT_SECRET_W,
    //INET_NNTP,    NNTP_ANONYMOUS_SECRET_W,     NNTP_ROOT_SECRET_W,
    //INET_SMTP,    SMTP_ANONYMOUS_SECRET_W,     SMTP_ROOT_SECRET_W,
    //INET_POP3,    POP3_ANONYMOUS_SECRET_W,     POP3_ROOT_SECRET_W,
    //INET_LDAP,    LDAP_ANONYMOUS_SECRET_W,     LDAP_ROOT_SECRET_W,
    //INET_IMAP,    IMAP_ANONYMOUS_SECRET_W,     IMAP_ROOT_SECRET_W,
    0,            NULL,                        NULL
};

DWORD
GetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    OUT LPWSTR *     ppSecret
    );

DWORD
SetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    IN  LPWSTR       pSecret,
    IN  DWORD        cbSecret
    );


NET_API_STATUS
NET_API_FUNCTION
InetInfoGetVersion(
    IN  LPWSTR   Server OPTIONAL,
    IN  DWORD    dwReserved,
    OUT DWORD *  pdwVersion
    )
{
    NET_API_STATUS status;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = R_InetInfoGetVersion(
                     Server,
                     dwReserved,
                     pdwVersion
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);

} // InetInfoGetVersion()




NET_API_STATUS
NET_API_FUNCTION
InetInfoGetServerCapabilities(
    IN  LPWSTR   Server OPTIONAL,
    IN  DWORD    dwReserved,
    OUT LPINET_INFO_CAPABILITIES * ppCap
    )
{
    NET_API_STATUS status;

    *ppCap = NULL;
    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = R_InetInfoGetServerCapabilities(
                     Server,
                     dwReserved,
                     (LPINET_INFO_CAPABILITIES_STRUCT *)ppCap
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);

} // InetInfoServerCapabilities()




NET_API_STATUS
NET_API_FUNCTION
InetInfoQueryStatistics(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    Level,
    IN  DWORD    dwServerMask,
    OUT LPBYTE * Buffer
    )
{
    NET_API_STATUS status;

    *Buffer = NULL;
    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = R_InetInfoQueryStatistics(
                     pszServer,
                     Level,
                     dwServerMask,
                     (LPINET_INFO_STATISTICS_INFO) Buffer
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);
} // InetInfoQueryStatistics()




NET_API_STATUS
NET_API_FUNCTION
InetInfoClearStatistics(
    IN  LPWSTR pszServer OPTIONAL,
    IN  DWORD  dwServerMask
    )
{
    NET_API_STATUS status;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = R_InetInfoClearStatistics(
                     pszServer,
                     dwServerMask
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);
} // InetInfoClearStatistics()




NET_API_STATUS
NET_API_FUNCTION
InetInfoFlushMemoryCache(
    IN  LPWSTR pszServer OPTIONAL,
    IN  DWORD  dwServerMask
    )
{
    NET_API_STATUS status;

    RpcTryExcept {

        //
        // Try RPC (local or remote) version of API.
        //
        status = R_InetInfoFlushMemoryCache(
                     pszServer,
                     dwServerMask
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return (status);
} // InetInfoFlushMemoryCache()


NET_API_STATUS
NET_API_FUNCTION
InetInfoGetGlobalAdminInformation(
    IN  LPWSTR                       Server OPTIONAL,
    IN  DWORD                        dwReserved,
    OUT LPINET_INFO_GLOBAL_CONFIG_INFO * ppConfig
    )
{
    NET_API_STATUS status;

    RpcTryExcept {

        status = R_InetInfoGetGlobalAdminInformation(
                     Server,
                     dwReserved,
                     ppConfig
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
} // InetInfoGetGlobalAdminInformation()



NET_API_STATUS
NET_API_FUNCTION
InetInfoGetSites(
    IN  LPWSTR                pszServer OPTIONAL,
    IN  DWORD                 dwServerMask,
    OUT LPINET_INFO_SITE_LIST * ppSites
    )
{
    NET_API_STATUS status;

    RpcTryExcept {

        status = R_InetInfoGetSites(
                     pszServer,
                     dwServerMask,
                     ppSites
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
} // InetInfoGetSites()


NET_API_STATUS
NET_API_FUNCTION
InetInfoSetGlobalAdminInformation(
    IN  LPWSTR                     Server OPTIONAL,
    IN  DWORD                      dwReserved,
    IN  INET_INFO_GLOBAL_CONFIG_INFO * pConfig
    )
{
    NET_API_STATUS status;

    RpcTryExcept {

        status = R_InetInfoSetGlobalAdminInformation(
                     Server,
                     dwReserved,
                     pConfig
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
} // InetInfoSetGlobalAdminInformation()



NET_API_STATUS
NET_API_FUNCTION
InetInfoGetAdminInformation(
    IN  LPWSTR                Server OPTIONAL,
    IN  DWORD                 dwServerMask,
    OUT LPINET_INFO_CONFIG_INFO * ppConfig
    )
{
    NET_API_STATUS             status;
    BOOL                       fGetPassword = TRUE;
    LPWSTR                     pSecret;
    DWORD                      i = 0;
    DWORD                      j;
    LPWSTR                     pszCurrent;
    INET_INFO_VIRTUAL_ROOT_ENTRY * pVirtRoot;

    RpcTryExcept {

        status = R_InetInfoGetAdminInformation(
                     Server,
                     dwServerMask,
                     ppConfig
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( status )
        return status;

#ifndef CHICAGO

    //
    //  Get the anonymous account password
    //

    while ( aSrvSecrets[i].dwID &&
            !(aSrvSecrets[i].dwID & dwServerMask ) )
    {
        i++;
    }

    // Note: Only the service corresponding to first mask is chosen.

    if ( !aSrvSecrets[i].dwID )
        return ERROR_INVALID_PARAMETER;

    status = GetSecret( Server,
                        aSrvSecrets[i].SecretName,
                        &pSecret );

    if ( status )
        return status;

    memcpy( (*ppConfig)->szAnonPassword,
            pSecret,
            sizeof(WCHAR) * min( wcslen( pSecret ), PWLEN ));

    (*ppConfig)->szAnonPassword[PWLEN] = L'\0';

    LocalFree( pSecret );

    //
    //  Zero terminate all of the passwords in case there is no associated
    //  secret
    //

    for ( j = 0; j < (*ppConfig)->VirtualRoots->cEntries; j++ )
    {
        *(*ppConfig)->VirtualRoots->aVirtRootEntry[j].AccountPassword = L'\0';
    }

    status = GetSecret( Server,
                        aSrvSecrets[i].RootSecretName,
                        &pSecret );

    if ( status )
        return status;

    pszCurrent = pSecret;

    while ( *pszCurrent )
    {
        LPWSTR pszRoot;
        LPWSTR pszPassword;
        LPWSTR pszAddress;
        LPWSTR pszNextLine = pszCurrent + wcslen(pszCurrent) + 1;


        //
        //  The list is in the form:
        //
        //     <Root>,<Addresss>=<Password>\0
        //     <Root>,<Addresss>=<Password>\0
        //     \0
        //

        pszRoot = pszCurrent;

        pszPassword = wcschr( pszCurrent, L'=' );

        if ( !pszPassword )
        {
            //
            //  Bad list format, skip this one
            //

            goto NextLine;
        }

        *pszPassword = L'\0';
        pszPassword++;

        pszAddress = wcschr( pszRoot, L',');

        if ( !pszAddress )
        {
            goto NextLine;

        }

        *pszAddress = L'\0';
        pszAddress++;

        //
        //  Now look for this root and address in the virtual root list
        //  so we can set the password
        //

        for ( i = 0; i < (*ppConfig)->VirtualRoots->cEntries; i++ )
        {
            pVirtRoot = &(*ppConfig)->VirtualRoots->aVirtRootEntry[i];

            if ( !_wcsicmp( pszRoot, pVirtRoot->pszRoot ) &&
                 (!pszAddress || !_wcsicmp( pszAddress, pVirtRoot->pszAddress)))
            {
                //
                //  If the password length is invalid, we just ignore it.
                //  This shouldn't happen because we check before setting the
                //  password
                //

                if ( wcslen( pszPassword ) <= PWLEN )
                {
                    wcscpy( pVirtRoot->AccountPassword,
                            pszPassword );
                    break;
                }
            }
        }

NextLine:

        pszCurrent = pszNextLine;
    }

    LocalFree( pSecret );
#else // CHICAGO
    //
    //  Zero terminate all of the passwords in case there is no associated
    //  secret
    //

    for ( j = 0; j < (*ppConfig)->VirtualRoots->cEntries; j++ )
    {
        *(*ppConfig)->VirtualRoots->aVirtRootEntry[j].AccountPassword = L'\0';
    }
#endif // CHICAGO
    return status;
} // InetInfoGetAdminInformation()



NET_API_STATUS
NET_API_FUNCTION
InetInfoSetAdminInformation(
    IN  LPWSTR              Server OPTIONAL,
    IN  DWORD               dwServerMask,
    IN  INET_INFO_CONFIG_INFO * pConfig
    )
{
    NET_API_STATUS status;
    WCHAR          szAnonPassword[PWLEN+1];
    LPWSTR         pszRootPasswords = NULL;
    LPWSTR         pszPassword;
    DWORD          i, j;

#ifndef CHICAGO

    //
    //  Enumerate the LSA secret names for the specified servers.  We set the
    //  secrets first so the anonymous user name password can be refreshed
    //  in the server side InetInfoSetAdminInformation
    //

    i = 0;
    while ( aSrvSecrets[i].dwID )
    {
        if ( !(aSrvSecrets[i].dwID & dwServerMask ))
        {
            i++;
            continue;
        }

        if ( IsFieldSet( pConfig->FieldControl, FC_INET_INFO_ANON_PASSWORD ))
        {
            status = SetSecret( Server,
                                aSrvSecrets[i].SecretName,
                                pConfig->szAnonPassword,
                                (wcslen( pConfig->szAnonPassword ) + 1)
                                    * sizeof(WCHAR));

            if ( status )
                return status;
        }

        if ( IsFieldSet( pConfig->FieldControl, FC_INET_INFO_VIRTUAL_ROOTS ))
        {
            DWORD                      cbNeeded = sizeof(WCHAR);
            INET_INFO_VIRTUAL_ROOT_ENTRY * pVirtRoot;
            LPWSTR                     psz;
            LPWSTR                     pszSecret;

            //
            //  Build a string that looks like:
            //
            //     <Root>,<Addresss>=<Password>\0
            //     <Root>,<Addresss>=<Password>\0
            //     \0
            //

            //
            //  Do a first pass to figure the buffer size we need to build
            //

            for ( j = 0; j < pConfig->VirtualRoots->cEntries; j++ )
            {
                pVirtRoot = &pConfig->VirtualRoots->aVirtRootEntry[j];

                cbNeeded += (wcslen( pVirtRoot->pszRoot ) +
                             wcslen( EMPTY_IF_NULL(pVirtRoot->pszAddress)) +
                             wcslen( pVirtRoot->AccountPassword ) +
                             (PWLEN + 3)) * sizeof(WCHAR);
            }

            //
            //  We always allocate at least enough room for a '\0'
            //

            pszSecret = LocalAlloc( LPTR, cbNeeded + sizeof(WCHAR) );

            if ( !pszSecret )
                return ERROR_NOT_ENOUGH_MEMORY;

            psz = pszSecret;

            //
            //  Now build the string
            //

            for ( j = 0; j < pConfig->VirtualRoots->cEntries; j++ )
            {
                pVirtRoot = &pConfig->VirtualRoots->aVirtRootEntry[j];

                psz += wsprintfW( psz,
                                  L"%ls,%ls=%ls",
                                  pVirtRoot->pszRoot,
                                  EMPTY_IF_NULL(pVirtRoot->pszAddress),
                                  pVirtRoot->AccountPassword );
                psz++;
            }

            //
            //  Add the list terminating NULL
            //

            *psz = L'\0';

            status = SetSecret( Server,
                                aSrvSecrets[i].RootSecretName,
                                pszSecret,
                                cbNeeded );

            LocalFree( pszSecret );

            if ( status )
                return status;
        }

        i++;
    }
#endif // CHICAGO

    //
    //  Set the passwords to NULL so it doesn't go out on the
    //  wire.  We set them as a secrets above
    //

    if ( IsFieldSet( pConfig->FieldControl, FC_INET_INFO_VIRTUAL_ROOTS ))
    {
        pszRootPasswords = LocalAlloc( LPTR,
                                       pConfig->VirtualRoots->cEntries *
                                       (PWLEN + 1) * sizeof(WCHAR) );

        if ( !pszRootPasswords )
            return ERROR_NOT_ENOUGH_MEMORY;

        for ( i = 0; i < pConfig->VirtualRoots->cEntries; i++ )
        {
            pszPassword = pConfig->VirtualRoots->aVirtRootEntry[i].AccountPassword;

            if ( wcslen( pszPassword ) > PWLEN )
            {
                LocalFree( pszRootPasswords );
                return ERROR_INVALID_PARAMETER;
            }

            wcscpy( pszRootPasswords + i * (PWLEN + 1),
                    pszPassword );

            memset( pszPassword,
                    0,
                    sizeof( pConfig->VirtualRoots->aVirtRootEntry[i].AccountPassword ));
        }
    }

    if ( IsFieldSet( pConfig->FieldControl, FC_INET_INFO_ANON_PASSWORD ))
    {
        memcpy( szAnonPassword,
                pConfig->szAnonPassword,
                sizeof(pConfig->szAnonPassword) );

        memset( pConfig->szAnonPassword,
                0,
                sizeof(pConfig->szAnonPassword) );
    }

    RpcTryExcept {

        status = R_InetInfoSetAdminInformation(
                     Server,
                     dwServerMask,
                     pConfig
                     );
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    //
    //  Restore the structure we just mucked with
    //

    if ( IsFieldSet( pConfig->FieldControl, FC_INET_INFO_ANON_PASSWORD ))
    {
        memcpy( pConfig->szAnonPassword,
                szAnonPassword,
                sizeof(pConfig->szAnonPassword) );

        memset( szAnonPassword, 0, sizeof( szAnonPassword ));
    }

    if ( IsFieldSet( pConfig->FieldControl, FC_INET_INFO_VIRTUAL_ROOTS ))
    {
        for ( i = 0; i < pConfig->VirtualRoots->cEntries; i++ )
        {
            pszPassword = pConfig->VirtualRoots->aVirtRootEntry[i].AccountPassword;

            wcscpy( pszPassword,
                    pszRootPasswords + i * (PWLEN + 1) );
        }

        memset( pszRootPasswords,
                0,
                pConfig->VirtualRoots->cEntries * (PWLEN + 1) * sizeof(WCHAR));

        LocalFree( pszRootPasswords );

        pszRootPasswords = NULL;
    }

    return status;
} // InetInfoSetAdminInformation()


NET_API_STATUS
NET_API_FUNCTION
IISEnumerateUsers(
    IN  LPWSTR                Server OPTIONAL,
    IN  DWORD                 dwLevel,
    IN  DWORD                 dwServiceId,
    IN  DWORD                 dwInstance,
    OUT PDWORD                nRead,
    OUT LPBYTE                *pBuffer
    )
{
    NET_API_STATUS status;
    GENERIC_INFO_CONTAINER genInfo;
    GENERIC_ENUM_STRUCT genStruct;

    genInfo.Buffer = NULL;
    genInfo.EntriesRead = 0;

    genStruct.Container = &genInfo;
    genStruct.Level = dwLevel;

    RpcTryExcept {

        status = R_IISEnumerateUsers(
                     Server,
                     dwServiceId,
                     dwInstance,
                     (LPIIS_USER_ENUM_STRUCT)&genStruct
                     );

        if ( genInfo.Buffer != NULL ) {
            *pBuffer = (LPBYTE)genInfo.Buffer;
            *nRead = genInfo.EntriesRead;

        } else {
            *pBuffer = NULL;
            *nRead = 0;
        }
    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;

} // IISEnumerateUsers




NET_API_STATUS
NET_API_FUNCTION
IISDisconnectUser(
    IN LPWSTR                   Server OPTIONAL,
    IN DWORD                    dwServiceId,
    IN DWORD                    dwInstance,
    IN DWORD                    dwIdUser
    )
{
    NET_API_STATUS status;

    RpcTryExcept {

        status = R_IISDisconnectUser(
                     Server,
                     dwServiceId,
                     dwInstance,
                     dwIdUser
                     );

    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;

} // IISDisconnectUser



NET_API_STATUS
NET_API_FUNCTION
InitW3CounterStructure(
    IN LPWSTR  Server OPTIONAL,
    OUT LPDWORD lpcbTotalRequired
	)
{
    NET_API_STATUS             status;

    RpcTryExcept {

        status = R_InitW3CounterStructure(Server, lpcbTotalRequired);

    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
} //InitW3CounterStructure


NET_API_STATUS
NET_API_FUNCTION
CollectW3PerfData(
    IN LPWSTR        Server OPTIONAL,
	IN LPWSTR        lpValueName,
    OUT LPBYTE       lppData,
    IN OUT LPDWORD   lpcbTotalBytes,
    OUT LPDWORD      lpNumObjectTypes 
	)
{
    NET_API_STATUS             status;

    RpcTryExcept {

        status = R_CollectW3PerfData(
					 Server,
                     lpValueName,
                     lppData,
                     lpcbTotalBytes,
                     lpNumObjectTypes
                     );

    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
} //CollectW3PerfData


NET_API_STATUS
NET_API_FUNCTION
W3QueryStatistics2(
    IN  LPWSTR                Server OPTIONAL,
    IN  DWORD                 dwLevel,
    IN  DWORD                 dwInstance,
    IN  DWORD                 dwReserved,
    OUT LPBYTE                * pBuffer
    )
{
    NET_API_STATUS             status;

    *pBuffer = NULL;
    RpcTryExcept {

        status = R_W3QueryStatistics2(
                     Server,
                     dwLevel,
                     dwInstance,
                     dwReserved,
                     (LPW3_STATISTICS_STRUCT)pBuffer
                     );

    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
} // W3QueryStatistics2


NET_API_STATUS
NET_API_FUNCTION
W3ClearStatistics2(
    IN  LPWSTR                Server OPTIONAL,
    IN  DWORD                 dwInstance
    )
{
    NET_API_STATUS             status;

    RpcTryExcept {

        status = R_W3ClearStatistics2(
                     Server,
                     dwInstance
                     );

    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;

} // W3ClearStatistics2


NET_API_STATUS
NET_API_FUNCTION
FtpQueryStatistics2(
    IN  LPWSTR                Server OPTIONAL,
    IN  DWORD                 dwLevel,
    IN  DWORD                 dwInstance,
    IN  DWORD                 dwReserved,
    OUT LPBYTE                * pBuffer
    )
{
    NET_API_STATUS             status;

    *pBuffer = NULL;
    RpcTryExcept {

        status = R_FtpQueryStatistics2(
                     Server,
                     dwLevel,
                     dwInstance,
                     dwReserved,
                     (LPFTP_STATISTICS_STRUCT)pBuffer
                     );

    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;
} // FtpQueryStatistics2


NET_API_STATUS
NET_API_FUNCTION
FtpClearStatistics2(
    IN  LPWSTR                Server OPTIONAL,
    IN  DWORD                 dwInstance
    )
{
    NET_API_STATUS             status;

    RpcTryExcept {

        status = R_FtpClearStatistics2(
                     Server,
                     dwInstance
                     );

    }
    RpcExcept (1) {
        status = RpcExceptionCode();
    }
    RpcEndExcept

    return status;

} // FtpClearStatistics2


#ifndef CHICAGO

DWORD
GetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    OUT LPWSTR *     ppSecret
    )
/*++

   Description

     Gets the specified LSA secret

   Arguments:

     Server - Server name (or NULL) secret lives on
     SecretName - Name of the LSA secret
     ppSecret - Receives an allocated block of memory containing the secret.
        Must be freed with LocalFree.

   Note:

--*/
{
    LSA_HANDLE        hPolicy;
    UNICODE_STRING *  punicodePassword;
    UNICODE_STRING    unicodeServer;
    NTSTATUS          ntStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    unicodeSecret;


    InitUnicodeString( &unicodeServer,
                       Server );

    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( &unicodeServer,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
        return LsaNtStatusToWinError( ntStatus );

    InitUnicodeString( &unicodeSecret,
                       SecretName );


    //
    //  Query the secret value
    //

    ntStatus = LsaRetrievePrivateData( hPolicy,
                                       &unicodeSecret,
                                       &punicodePassword );

    LsaClose( hPolicy );

    if ( !NT_SUCCESS( ntStatus ))
        return LsaNtStatusToWinError( ntStatus );

    *ppSecret = LocalAlloc( LPTR, punicodePassword->Length + sizeof(WCHAR) );

    if ( !*ppSecret )
    {
        RtlZeroMemory( punicodePassword->Buffer,
                       punicodePassword->MaximumLength );

        LsaFreeMemory( (PVOID) punicodePassword );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //  Copy it into the buffer, Length is count of bytes
    //

    memcpy( *ppSecret,
            punicodePassword->Buffer,
            punicodePassword->Length );

    (*ppSecret)[punicodePassword->Length/sizeof(WCHAR)] = L'\0';

    RtlZeroMemory( punicodePassword->Buffer,
                   punicodePassword->MaximumLength );

    LsaFreeMemory( (PVOID) punicodePassword );

    return NO_ERROR;
} // GetSecret()


DWORD
SetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    IN  LPWSTR       pSecret,
    IN  DWORD        cbSecret
    )
/*++

   Description

     Sets the specified LSA secret

   Arguments:

     Server - Server name (or NULL) secret lives on
     SecretName - Name of the LSA secret
     pSecret - Pointer to secret memory
     cbSecret - Size of pSecret memory block

   Note:

--*/
{
    LSA_HANDLE        hPolicy;
    UNICODE_STRING    unicodePassword;
    UNICODE_STRING    unicodeServer;
    NTSTATUS          ntStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING    unicodeSecret;


    InitUnicodeString( &unicodeServer,
                       Server );

    //
    //  Initialize the unicode string by hand so we can handle '\0' in the
    //  string
    //

    unicodePassword.Buffer        = pSecret;
    unicodePassword.Length        = (USHORT) cbSecret;
    unicodePassword.MaximumLength = (USHORT) cbSecret;

    //
    //  Open a policy to the remote LSA
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ntStatus = LsaOpenPolicy( &unicodeServer,
                              &ObjectAttributes,
                              POLICY_ALL_ACCESS,
                              &hPolicy );

    if ( !NT_SUCCESS( ntStatus ) )
        return LsaNtStatusToWinError( ntStatus );

    //
    //  Create or open the LSA secret
    //

    InitUnicodeString( &unicodeSecret,
                       SecretName );

    ntStatus = LsaStorePrivateData( hPolicy,
                                    &unicodeSecret,
                                    &unicodePassword );

    LsaClose( hPolicy );

    if ( !NT_SUCCESS( ntStatus ))
    {
        return LsaNtStatusToWinError( ntStatus );
    }

    return NO_ERROR;
} // SetSecret()


#else // CHICAGO



DWORD
GetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    OUT LPWSTR *     ppSecret
    )
{
    return(NO_ERROR);
}

DWORD
SetSecret(
    IN  LPWSTR       Server,
    IN  LPWSTR       SecretName,
    IN  LPWSTR       pSecret,
    IN  DWORD        cbSecret
    )
{
    return(NO_ERROR);
}
#endif // CHICAGO


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\perfmon\infoctrs.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    infoctrs.h

    Offset definitions for the INFO Server's counter objects & counters.

    These offsets *must* start at 0 and be multiples of 2.  In the
    INFOOpenPerformanceData procecedure, they will be added to the
    INFO Server's "First Counter" and "First Help" values in order to
    determine the absolute location of the counter & object names
    and corresponding help text in the registry.

    This file is used by the INFOCTRS.DLL DLL code as well as the
    INFOCTRS.INI definition file.  INFOCTRS.INI is parsed by the
    LODCTR utility to load the object & counter names into the
    registry.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.
        MuraliK     02-Jun-1995 Added Counters for Atq I/O requests
        SophiaC     16-Oct-1995 Info/Access Product Split

*/


#ifndef _INFOCTRS_H_
#define _INFOCTRS_H_


//
//  The INFO Server counter object.
//

#define INFO_COUNTER_OBJECT                     0


//
//  The individual counters.
//

#define INFO_ATQ_TOTAL_ALLOWED_REQUESTS_COUNTER         2
#define INFO_ATQ_TOTAL_BLOCKED_REQUESTS_COUNTER         4
#define INFO_ATQ_TOTAL_REJECTED_REQUESTS_COUNTER        6
#define INFO_ATQ_CURRENT_BLOCKED_REQUESTS_COUNTER       8
#define INFO_ATQ_MEASURED_BANDWIDTH_COUNTER             10

#define INFO_CACHE_FILES_CACHED_COUNTER                 12
#define INFO_CACHE_TOTAL_FILES_CACHED_COUNTER           14
#define INFO_CACHE_FILES_HIT_COUNTER                    16
#define INFO_CACHE_FILES_MISS_COUNTER                   18
#define INFO_CACHE_FILE_RATIO_COUNTER                   20
#define INFO_CACHE_FILE_RATIO_COUNTER_DENOM             22
#define INFO_CACHE_FILE_FLUSHES_COUNTER                 24
#define INFO_CACHE_CURRENT_FILE_CACHE_SIZE_COUNTER      26
#define INFO_CACHE_MAXIMUM_FILE_CACHE_SIZE_COUNTER      28
#define INFO_CACHE_ACTIVE_FLUSHED_FILES_COUNTER         30
#define INFO_CACHE_TOTAL_FLUSHED_FILES_COUNTER          32

#define INFO_CACHE_URI_CACHED_COUNTER                   34
#define INFO_CACHE_TOTAL_URI_CACHED_COUNTER             36
#define INFO_CACHE_URI_HIT_COUNTER                      38
#define INFO_CACHE_URI_MISS_COUNTER                     40
#define INFO_CACHE_URI_RATIO_COUNTER                    42
#define INFO_CACHE_URI_RATIO_COUNTER_DENOM              44
#define INFO_CACHE_URI_FLUSHES_COUNTER                  46
#define INFO_CACHE_TOTAL_FLUSHED_URI_COUNTER            48

#define INFO_CACHE_BLOB_CACHED_COUNTER                  50
#define INFO_CACHE_TOTAL_BLOB_CACHED_COUNTER            52
#define INFO_CACHE_BLOB_HIT_COUNTER                     54
#define INFO_CACHE_BLOB_MISS_COUNTER                    56
#define INFO_CACHE_BLOB_RATIO_COUNTER                   58
#define INFO_CACHE_BLOB_RATIO_COUNTER_DENOM             60
#define INFO_CACHE_BLOB_FLUSHES_COUNTER                 62
#define INFO_CACHE_TOTAL_FLUSHED_BLOB_COUNTER           64

#endif  // _INFOCTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\perfmon\infodata.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    infodata.h

    Extensible object definitions for the Internet Info Services Common
    counter objects & counters.


    FILE HISTORY:
        MuraliK     02-Jun-1995 Added Counters for Atq I/O requests
        SophiaC     16-Oct-1995 Info/Access Product Split

*/


#ifndef _INFODATA_H_
#define _INFODATA_H_

#define INFO_PERFORMANCE_KEY    INET_INFO_KEY "\\Performance"

//
//  This structure is used to ensure the first counter is properly
//  aligned.  Unfortunately, since PERF_COUNTER_BLOCK consists
//  of just a single DWORD, any LARGE_INTEGERs that immediately
//  follow will not be aligned properly.
//
//  This structure requires "natural" packing & alignment (probably
//  quad-word, especially on Alpha).  Ergo, keep it out of the
//  #pragma pack(4) scope below.
//

typedef struct _INFO_COUNTER_BLOCK
{
    PERF_COUNTER_BLOCK  PerfCounterBlock;
    LARGE_INTEGER       DummyEntryForAlignmentPurposesOnly;

} INFO_COUNTER_BLOCK;


//
//  The routines that load these structures assume that all fields
//  are DWORD packed & aligned.
//

#pragma pack(4)


//
//  Offsets within a PERF_COUNTER_BLOCK.
//

#define INFO_ATQ_TOTAL_ALLOWED_REQUESTS_OFFSET  (sizeof(INFO_COUNTER_BLOCK))

#define INFO_ATQ_TOTAL_BLOCKED_REQUESTS_OFFSET  \
                                  (INFO_ATQ_TOTAL_ALLOWED_REQUESTS_OFFSET + \
                                                    sizeof(DWORD))
#define INFO_ATQ_TOTAL_REJECTED_REQUESTS_OFFSET  \
                                  (INFO_ATQ_TOTAL_BLOCKED_REQUESTS_OFFSET + \
                                                    sizeof(DWORD))
#define INFO_ATQ_CURRENT_BLOCKED_REQUESTS_OFFSET  \
                 (INFO_ATQ_TOTAL_REJECTED_REQUESTS_OFFSET + sizeof(DWORD))

#define INFO_ATQ_MEASURED_BANDWIDTH_OFFSET  \
                 (INFO_ATQ_CURRENT_BLOCKED_REQUESTS_OFFSET + sizeof(DWORD))


#define INFO_CACHE_FILES_CACHED_OFFSET \
                 (INFO_ATQ_MEASURED_BANDWIDTH_OFFSET + sizeof(DWORD))

#define INFO_CACHE_TOTAL_FILES_CACHED_OFFSET \
                 (INFO_CACHE_FILES_CACHED_OFFSET + sizeof(DWORD))

#define INFO_CACHE_FILES_HIT_OFFSET \
                 (INFO_CACHE_TOTAL_FILES_CACHED_OFFSET + sizeof(DWORD))

#define INFO_CACHE_FILES_MISS_OFFSET \
                 (INFO_CACHE_FILES_HIT_OFFSET + sizeof(DWORD))

#define INFO_CACHE_FILE_RATIO_OFFSET \
                 (INFO_CACHE_FILES_MISS_OFFSET + sizeof(DWORD))

#define INFO_CACHE_FILE_RATIO_DENOM_OFFSET \
                 (INFO_CACHE_FILE_RATIO_OFFSET + sizeof(DWORD))

#define INFO_CACHE_FILE_FLUSHES_OFFSET \
                 (INFO_CACHE_FILE_RATIO_DENOM_OFFSET + sizeof(DWORD))

#define INFO_CACHE_CURRENT_FILE_CACHE_SIZE_OFFSET \
                 (INFO_CACHE_FILE_FLUSHES_OFFSET + sizeof(DWORD))

#define INFO_CACHE_MAXIMUM_FILE_CACHE_SIZE_OFFSET \
                 (INFO_CACHE_CURRENT_FILE_CACHE_SIZE_OFFSET + sizeof(DWORD))

#define INFO_CACHE_ACTIVE_FLUSHED_FILES_OFFSET \
                 (INFO_CACHE_MAXIMUM_FILE_CACHE_SIZE_OFFSET + sizeof(DWORD))

#define INFO_CACHE_TOTAL_FLUSHED_FILES_OFFSET \
                 (INFO_CACHE_ACTIVE_FLUSHED_FILES_OFFSET + sizeof(DWORD))



#define INFO_CACHE_URI_CACHED_OFFSET \
                 (INFO_CACHE_TOTAL_FLUSHED_FILES_OFFSET + sizeof(DWORD))

#define INFO_CACHE_TOTAL_URI_CACHED_OFFSET \
                 (INFO_CACHE_URI_CACHED_OFFSET + sizeof(DWORD))

#define INFO_CACHE_URI_HIT_OFFSET \
                 (INFO_CACHE_TOTAL_URI_CACHED_OFFSET + sizeof(DWORD))

#define INFO_CACHE_URI_MISS_OFFSET \
                 (INFO_CACHE_URI_HIT_OFFSET + sizeof(DWORD))

#define INFO_CACHE_URI_RATIO_OFFSET \
                 (INFO_CACHE_URI_MISS_OFFSET + sizeof(DWORD))

#define INFO_CACHE_URI_RATIO_DENOM_OFFSET \
                 (INFO_CACHE_URI_RATIO_OFFSET + sizeof(DWORD))

#define INFO_CACHE_URI_FLUSHES_OFFSET \
                 (INFO_CACHE_URI_RATIO_DENOM_OFFSET + sizeof(DWORD))

#define INFO_CACHE_TOTAL_FLUSHED_URI_OFFSET \
                 (INFO_CACHE_URI_FLUSHES_OFFSET + sizeof(DWORD))


#define INFO_CACHE_BLOB_CACHED_OFFSET \
                 (INFO_CACHE_TOTAL_FLUSHED_URI_OFFSET + sizeof(DWORD))

#define INFO_CACHE_TOTAL_BLOB_CACHED_OFFSET \
                 (INFO_CACHE_BLOB_CACHED_OFFSET + sizeof(DWORD))

#define INFO_CACHE_BLOB_HIT_OFFSET \
                 (INFO_CACHE_TOTAL_BLOB_CACHED_OFFSET + sizeof(DWORD))

#define INFO_CACHE_BLOB_MISS_OFFSET \
                 (INFO_CACHE_BLOB_HIT_OFFSET + sizeof(DWORD))

#define INFO_CACHE_BLOB_RATIO_OFFSET \
                 (INFO_CACHE_BLOB_MISS_OFFSET + sizeof(DWORD))

#define INFO_CACHE_BLOB_RATIO_DENOM_OFFSET \
                 (INFO_CACHE_BLOB_RATIO_OFFSET + sizeof(DWORD))

#define INFO_CACHE_BLOB_FLUSHES_OFFSET \
                 (INFO_CACHE_BLOB_RATIO_DENOM_OFFSET + sizeof(DWORD))

#define INFO_CACHE_TOTAL_FLUSHED_BLOB_OFFSET \
                 (INFO_CACHE_BLOB_FLUSHES_OFFSET + sizeof(DWORD))


#define SIZE_OF_INFO_PERFORMANCE_DATA \
                 (INFO_CACHE_TOTAL_FLUSHED_BLOB_OFFSET + sizeof(DWORD))

//
//  The counter structure returned.
//

typedef struct _INFO_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            INFOObjectType;
    PERF_COUNTER_DEFINITION     INFOTotalAllowedRequests;
    PERF_COUNTER_DEFINITION     INFOTotalBlockedRequests;
    PERF_COUNTER_DEFINITION     INFOTotalRejectedRequests;
    PERF_COUNTER_DEFINITION     INFOCurrentRejectedRequests;
    PERF_COUNTER_DEFINITION     INFOMeasuredBandwidth;

    PERF_COUNTER_DEFINITION     INFOFilesCached;
    PERF_COUNTER_DEFINITION     INFOTotalFilesCached;
    PERF_COUNTER_DEFINITION     INFOFileHits;
    PERF_COUNTER_DEFINITION     INFOFileMisses;
    PERF_COUNTER_DEFINITION     INFOFileHitsRatio;
    PERF_COUNTER_DEFINITION     INFOFileHitsRatioDenom;
    PERF_COUNTER_DEFINITION     INFOFileFlushes;
    PERF_COUNTER_DEFINITION     INFOFileCurrentCacheSize;
    PERF_COUNTER_DEFINITION     INFOFileMaximumCacheSize;
    PERF_COUNTER_DEFINITION     INFOFileFlushedEntries;
    PERF_COUNTER_DEFINITION     INFOFileTotalFlushed;

    PERF_COUNTER_DEFINITION     INFOURICached;
    PERF_COUNTER_DEFINITION     INFOTotalURICached;
    PERF_COUNTER_DEFINITION     INFOURIHits;
    PERF_COUNTER_DEFINITION     INFOURIMisses;
    PERF_COUNTER_DEFINITION     INFOURIHitsRatio;
    PERF_COUNTER_DEFINITION     INFOURIHitsRatioDenom;
    PERF_COUNTER_DEFINITION     INFOURIFlushes;
    PERF_COUNTER_DEFINITION     INFOURITotalFlushed;

    PERF_COUNTER_DEFINITION     INFOBlobCached;
    PERF_COUNTER_DEFINITION     INFOTotalBlobCached;
    PERF_COUNTER_DEFINITION     INFOBlobHits;
    PERF_COUNTER_DEFINITION     INFOBlobMisses;
    PERF_COUNTER_DEFINITION     INFOBlobHitsRatio;
    PERF_COUNTER_DEFINITION     INFOBlobHitsRatioDenom;
    PERF_COUNTER_DEFINITION     INFOBlobFlushes;
    PERF_COUNTER_DEFINITION     INFOBlobTotalFlushed;

} INFO_DATA_DEFINITION;


extern  INFO_DATA_DEFINITION    INFODataDefinition;


#define NUMBER_OF_INFO_COUNTERS ((sizeof(INFO_DATA_DEFINITION) -        \
                                  sizeof(PERF_OBJECT_TYPE)) /           \
                                  sizeof(PERF_COUNTER_DEFINITION))


//
//  Restore default packing & alignment.
//

#pragma pack()


#endif  // _INFODATA_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\server\info_srv_stub.c ===
#include "info_srv.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\perfmon\makefile.inc ===
MY_BINPLACE = -binplace -P $(BINPLACE_PLACEFILE)

copyini:
    $(MY_BINPLACE) infoctrs.ini
    $(MY_BINPLACE) infoctrs.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\perfmon\infodata.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    infodata.c

    Constant data structures for the Info Server's counter objects &
    counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.
        MuraliK     02-Jun-1995 Added Counters for Atq I/O requests
        SophiaC     16-Oct-1995 Info/Access Product Split

*/


#include <windows.h>
#include <winperf.h>
#include <infoctrs.h>
#include <infodata.h>


//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

INFO_DATA_DEFINITION INFODataDefinition =
{
    {   // INFOObjectType
        sizeof(INFO_DATA_DEFINITION) + SIZE_OF_INFO_PERFORMANCE_DATA,
        sizeof(INFO_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        INFO_COUNTER_OBJECT,
        0,
        INFO_COUNTER_OBJECT,
        0,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_INFO_COUNTERS,
        2,                              // Default = Bytes Total/sec
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // TotalAllowedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_ATQ_TOTAL_ALLOWED_REQUESTS_COUNTER,
        0,
        INFO_ATQ_TOTAL_ALLOWED_REQUESTS_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_ATQ_TOTAL_ALLOWED_REQUESTS_OFFSET
    },

    {   // TotalBlockedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_ATQ_TOTAL_BLOCKED_REQUESTS_COUNTER,
        0,
        INFO_ATQ_TOTAL_BLOCKED_REQUESTS_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_ATQ_TOTAL_BLOCKED_REQUESTS_OFFSET
    },

    {   // TotalRejectedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_ATQ_TOTAL_REJECTED_REQUESTS_COUNTER,
        0,
        INFO_ATQ_TOTAL_REJECTED_REQUESTS_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_ATQ_TOTAL_REJECTED_REQUESTS_OFFSET
    },

    {   // CurrentBlockedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_ATQ_CURRENT_BLOCKED_REQUESTS_COUNTER,
        0,
        INFO_ATQ_CURRENT_BLOCKED_REQUESTS_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_ATQ_CURRENT_BLOCKED_REQUESTS_OFFSET
    },

    {   // AtqMeasuredBandwidth
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_ATQ_MEASURED_BANDWIDTH_COUNTER,
        0,
        INFO_ATQ_MEASURED_BANDWIDTH_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_ATQ_MEASURED_BANDWIDTH_OFFSET
    },
    
    {   // FilesCached
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_FILES_CACHED_COUNTER,
        0,
        INFO_CACHE_FILES_CACHED_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_FILES_CACHED_OFFSET
    },

    {   // TotalFilesCached
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_TOTAL_FILES_CACHED_COUNTER,
        0,
        INFO_CACHE_TOTAL_FILES_CACHED_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_TOTAL_FILES_CACHED_OFFSET
    },

    {   // FileCacheHits
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_FILES_HIT_COUNTER,
        0,
        INFO_CACHE_FILES_HIT_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_FILES_HIT_OFFSET
    },

    {   // FileCacheMisses
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_FILES_MISS_COUNTER,
        0,
        INFO_CACHE_FILES_MISS_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_FILES_MISS_OFFSET
    },

    {   // Calculated ratio of hits to misses - Numerator (cache hits)
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_FILE_RATIO_COUNTER,
        0,
        INFO_CACHE_FILE_RATIO_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        INFO_CACHE_FILE_RATIO_OFFSET
    },

    {   // Calculated ratio of hits to misses - Denominator, not displayed!
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_FILE_RATIO_COUNTER_DENOM,
        0,
        INFO_CACHE_FILE_RATIO_COUNTER_DENOM,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(DWORD),
        INFO_CACHE_FILE_RATIO_DENOM_OFFSET
    },


    {   // File Cache Flushes
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_FILE_FLUSHES_COUNTER,
        0,
        INFO_CACHE_FILE_FLUSHES_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_FILE_FLUSHES_OFFSET
    },

    {   // Current file cache size
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_CURRENT_FILE_CACHE_SIZE_COUNTER,
        0,
        INFO_CACHE_CURRENT_FILE_CACHE_SIZE_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_CURRENT_FILE_CACHE_SIZE_OFFSET
    },

    {   // Maximum file cache size
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_MAXIMUM_FILE_CACHE_SIZE_COUNTER,
        0,
        INFO_CACHE_MAXIMUM_FILE_CACHE_SIZE_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_MAXIMUM_FILE_CACHE_SIZE_OFFSET
    },

    {   // ActiveFlushedFiles
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_ACTIVE_FLUSHED_FILES_COUNTER,
        0,
        INFO_CACHE_ACTIVE_FLUSHED_FILES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_ACTIVE_FLUSHED_FILES_OFFSET
    },

    {   // Total flushed files
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_TOTAL_FLUSHED_FILES_COUNTER,
        0,
        INFO_CACHE_TOTAL_FLUSHED_FILES_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_TOTAL_FLUSHED_FILES_OFFSET
    },



    {   // URICached
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_URI_CACHED_COUNTER,
        0,
        INFO_CACHE_URI_CACHED_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_URI_CACHED_OFFSET
    },

    {   // TotalURICached
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_TOTAL_URI_CACHED_COUNTER,
        0,
        INFO_CACHE_TOTAL_URI_CACHED_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_TOTAL_URI_CACHED_OFFSET
    },

    {   // URICacheHits
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_URI_HIT_COUNTER,
        0,
        INFO_CACHE_URI_HIT_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_URI_HIT_OFFSET
    },

    {   // URICacheMisses
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_URI_MISS_COUNTER,
        0,
        INFO_CACHE_URI_MISS_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_URI_MISS_OFFSET
    },

    {   // Calculated ratio of hits to misses - Numerator (cache hits)
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_URI_RATIO_COUNTER,
        0,
        INFO_CACHE_URI_RATIO_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        INFO_CACHE_URI_RATIO_OFFSET
    },

    {   // Calculated ratio of hits to misses - Denominator, not displayed!
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_URI_RATIO_COUNTER_DENOM,
        0,
        INFO_CACHE_URI_RATIO_COUNTER_DENOM,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(DWORD),
        INFO_CACHE_URI_RATIO_DENOM_OFFSET
    },


    {   // URI Cache Flushes
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_URI_FLUSHES_COUNTER,
        0,
        INFO_CACHE_URI_FLUSHES_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_URI_FLUSHES_OFFSET
    },


    {   // Total flushed URIs
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_TOTAL_FLUSHED_URI_COUNTER,
        0,
        INFO_CACHE_TOTAL_FLUSHED_URI_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_TOTAL_FLUSHED_URI_OFFSET
    },


    

    {   // BlobCached
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_BLOB_CACHED_COUNTER,
        0,
        INFO_CACHE_BLOB_CACHED_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_BLOB_CACHED_OFFSET
    },

    {   // TotalBlobCached
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_TOTAL_BLOB_CACHED_COUNTER,
        0,
        INFO_CACHE_TOTAL_BLOB_CACHED_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_TOTAL_BLOB_CACHED_OFFSET
    },

    {   // BlobCacheHits
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_BLOB_HIT_COUNTER,
        0,
        INFO_CACHE_BLOB_HIT_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_BLOB_HIT_OFFSET
    },

    {   // BlobCacheMisses
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_BLOB_MISS_COUNTER,
        0,
        INFO_CACHE_BLOB_MISS_COUNTER,
        0,
        -3,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_BLOB_MISS_OFFSET
    },

    {   // Calculated ratio of hits to misses - Numerator (cache hits)
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_BLOB_RATIO_COUNTER,
        0,
        INFO_CACHE_BLOB_RATIO_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        INFO_CACHE_BLOB_RATIO_OFFSET
    },

    {   // Calculated ratio of hits to misses - Denominator, not displayed!
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_BLOB_RATIO_COUNTER_DENOM,
        0,
        INFO_CACHE_BLOB_RATIO_COUNTER_DENOM,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(DWORD),
        INFO_CACHE_BLOB_RATIO_DENOM_OFFSET
    },


    {   // Blob Cache Flushes
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_BLOB_FLUSHES_COUNTER,
        0,
        INFO_CACHE_BLOB_FLUSHES_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_BLOB_FLUSHES_OFFSET
    },


    {   // Total flushed Blobs
        sizeof(PERF_COUNTER_DEFINITION),
        INFO_CACHE_TOTAL_FLUSHED_BLOB_COUNTER,
        0,
        INFO_CACHE_TOTAL_FLUSHED_BLOB_COUNTER,
        0,
        -1,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        INFO_CACHE_TOTAL_FLUSHED_BLOB_OFFSET
    }


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\perfmon\infoperf.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    infoperf.c

    This file implements the Extensible Performance Objects for
    the common INFO counters


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created, based on RussBl's sample code.
        MuraliK     02-Jun-1995 Added Counters for Atq I/O requests
        SophiaC     16-Oct-1995 Info/Access Product Split
        MuraliK     16-Nov-1995 Removed undoc apis

*/

#include <windows.h>
#include <winperf.h>
#include <lm.h>
#include <inetinfo.h>

#include <string.h>
#include <stdlib.h>

#include <infoctrs.h>
#include <infodata.h>
#include <perfutil.h>
#include <iis64.h>
#include "infomsg.h"

# include "apiutil.h"

//
//  Private constants.
//
#define APP_NAME                        (TEXT("IISInfoCtrs"))
//
//  Private globals.
//

DWORD   cOpens    = 0;                  // Active "opens" reference count.
BOOL    fInitOK   = FALSE;              // TRUE if DLL initialized OK.
HANDLE  hEventLog = NULL;               // event log handle

#if DBG
DWORD   INFODebug = 0;                  // Debug behaviour flags.
#endif  // DBG

//
//  Public prototypes.
//

PM_OPEN_PROC    OpenINFOPerformanceData;
PM_COLLECT_PROC CollectINFOPerformanceData;
PM_CLOSE_PROC   CloseINFOPerformanceData;


//
//  Public functions.
//

/*******************************************************************

    NAME:       OpenINFOPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate
                performance counters with the registry.

    ENTRY:      lpDeviceNames - Poitner to object ID of each device
                    to be opened.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD OpenINFOPerformanceData( LPWSTR lpDeviceNames )
{
    DWORD err  = NO_ERROR;
    HKEY  hkey = NULL;
    DWORD size;
    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;
    PERF_COUNTER_DEFINITION * pctr;
    DWORD                     i;

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). The registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem.
    //

    if( !fInitOK )
    {

        //
        //  This is the *first* open.
        //
        // open the event log interface
        if (hEventLog == NULL) {
            hEventLog = RegisterEventSource (
                (LPSTR)NULL,    // on the local machine
                APP_NAME);      // register the name to allow message lookup
        }

        //
        //  Open the HTTP Server service's Performance key.
        //

        err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            INFO_PERFORMANCE_KEY,
                            0,
                            KEY_READ,
                            &hkey );

        if( err == NO_ERROR )
        {
            //
            //  Read the first counter DWORD.
            //

            size = sizeof(DWORD);

            err = RegQueryValueEx( hkey,
                                   "First Counter",
                                   NULL,
                                   &type,
                                   (LPBYTE)&dwFirstCounter,
                                   &size );
            if( err == NO_ERROR )
            {
                //
                //  Read the first help DWORD.
                //

                size = sizeof(DWORD);

                err = RegQueryValueEx( hkey,
                                    "First Help",
                                    NULL,
                                    &type,
                                    (LPBYTE)&dwFirstHelp,
                                    &size );

                if ( err == NO_ERROR )
                {
                    //
                    //  Update the object & counter name & help indicies.
                    //

                    INFODataDefinition.INFOObjectType.ObjectNameTitleIndex
                        += dwFirstCounter;
                    INFODataDefinition.INFOObjectType.ObjectHelpTitleIndex
                        += dwFirstHelp;

                    pctr = &INFODataDefinition.INFOTotalAllowedRequests;

                    for( i = 0 ; i < NUMBER_OF_INFO_COUNTERS ; i++ )
                    {
                        pctr->CounterNameTitleIndex += dwFirstCounter;
                        pctr->CounterHelpTitleIndex += dwFirstHelp;
                        pctr++;
                    }

                    //
                    //  Remember that we initialized OK.
                    //

                    fInitOK = TRUE;
                    //
                    //  Bump open counter.
                    //

                    cOpens++;

                    // return success
                    err = ERROR_SUCCESS;
                } else {
                    // log event
                    ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                        0, IIS_INFO_UNABLE_READ_FIRST_HELP,
                        (PSID)NULL, 0,
                        sizeof (err), NULL,
                        (PVOID)(&err));
                }
            } else {
                // log event
                ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                    0, IIS_INFO_UNABLE_READ_FIRST_COUNTER,
                    (PSID)NULL, 0,
                    sizeof (err), NULL,
                    (PVOID)(&err));
            }
            //
            //  Close the registry if we managed to actually open it.
            //

            if( hkey != NULL )
            {
                RegCloseKey( hkey );
                hkey = NULL;
            }
        } else {
            // log event
            ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                0, IIS_INFO_UNABLE_OPEN_PERF_KEY,
                (PSID)NULL, 0,
                sizeof (err), NULL,
                (PVOID)(&err));
        }
    }

    return err;

}   // OpenINFOPerformanceData

/*******************************************************************

    NAME:       CollectINFOPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate

    ENTRY:      lpValueName - The name of the value to retrieve.

                lppData - On entry contains a pointer to the buffer to
                    receive the completed PerfDataBlock & subordinate
                    structures.  On exit, points to the first bytes
                    *after* the data structures added by this routine.

                lpcbTotalBytes - On entry contains a pointer to the
                    size (in BYTEs) of the buffer referenced by lppData.
                    On exit, contains the number of BYTEs added by this
                    routine.

                lpNumObjectTypes - Receives the number of objects added
                    by this routine.

    RETURNS:    DWORD - Win32 status code.  MUST be either NO_ERROR
                    or ERROR_MORE_DATA.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CollectINFOPerformanceData( LPWSTR    lpValueName,
                                 LPVOID  * lppData,
                                 LPDWORD   lpcbTotalBytes,
                                 LPDWORD   lpNumObjectTypes )
{
    DWORD                  dwQueryType;
    ULONG                  cbRequired;
    DWORD                * pdwCounter;
    INFO_COUNTER_BLOCK   * pCounterBlock;
    INFO_DATA_DEFINITION * pINFODataDefinition;
    INET_INFO_STATISTICS_0   * pINFOStats;
    NET_API_STATUS         neterr;

    //
    //  No need to even try if we failed to open...
    //

    if( !fInitOK )
    {
        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        //
        //  According to the Performance Counter design, this
        //  is a successful exit.  Go figure.
        //

        return NO_ERROR;
    }

    //
    //  Determine the query type.
    //

    dwQueryType = GetQueryType( lpValueName );

    if (( dwQueryType == QUERY_FOREIGN ) || ( dwQueryType == QUERY_COSTLY ))
    {
        //
        //  We don't do foreign or Costly queries.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return NO_ERROR;
    }

    if( dwQueryType == QUERY_ITEMS )
    {
        //
        //  The registry is asking for a specific object.  Let's
        //  see if we're one of the chosen.
        //

        if( !IsNumberInUnicodeList(
                        INFODataDefinition.INFOObjectType.ObjectNameTitleIndex,
                        lpValueName ) )
        {
            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

            return NO_ERROR;
        }
    }

    //
    //  See if there's enough space.
    //

    pINFODataDefinition = (INFO_DATA_DEFINITION *)*lppData;

    cbRequired = sizeof(INFO_DATA_DEFINITION) + SIZE_OF_INFO_PERFORMANCE_DATA;

    if( *lpcbTotalBytes < cbRequired )
    {
        //
        //  Nope.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return ERROR_MORE_DATA;
    }

    //
    //  Try to retrieve the data.
    //

    neterr = InetInfoQueryStatistics( NULL,
                                      0,
                                      0,
                                      (LPBYTE *)&pINFOStats );

    if( neterr == NERR_Success ) {
        //
        // Copy the (constant, initialized) Object Type and counter definitions
        //  to the caller's data buffer
        //

        memmove( pINFODataDefinition,
                &INFODataDefinition,
                sizeof(INFO_DATA_DEFINITION) );

        //
        //  Format the INFO Server data.
        //

        pCounterBlock = (INFO_COUNTER_BLOCK *)( pINFODataDefinition + 1 );

        pCounterBlock->PerfCounterBlock.ByteLength = SIZE_OF_INFO_PERFORMANCE_DATA;

        //
        //  Now move the DWORDs into the buffer.
        //

        pdwCounter = (DWORD *)(pCounterBlock + 1);

        //
        //  ATQ Global counters
        //
        *pdwCounter++ = pINFOStats->AtqCtrs.TotalAllowedRequests;
        *pdwCounter++ = pINFOStats->AtqCtrs.TotalBlockedRequests;
        *pdwCounter++ = pINFOStats->AtqCtrs.TotalRejectedRequests;
        *pdwCounter++ = pINFOStats->AtqCtrs.CurrentBlockedRequests;
        *pdwCounter++ = pINFOStats->AtqCtrs.MeasuredBandwidth;

        //
        // File Handle Cache counters
        //
        *pdwCounter++ = pINFOStats->CacheCtrs.FilesCached;
        *pdwCounter++ = pINFOStats->CacheCtrs.TotalFilesCached;
        *pdwCounter++ = pINFOStats->CacheCtrs.FileHits;
        *pdwCounter++ = pINFOStats->CacheCtrs.FileMisses;
        *pdwCounter++ = pINFOStats->CacheCtrs.FileHits;
        *pdwCounter++ = ( pINFOStats->CacheCtrs.FileHits +
                        pINFOStats->CacheCtrs.FileMisses);
        *pdwCounter++ = pINFOStats->CacheCtrs.FileFlushes;

        // 64BIT BUGBUG: need to change the caller to expect int64 and then
        // put in the whole 64 bit value here
        // *((DWORDLONG *)pdwCounter) =
        *pdwCounter++ =
            (DWORD)pINFOStats->CacheCtrs.CurrentFileCacheSize;

        // pdwCounter += sizeof(DWORDLONG) / sizeof(*pdwCounter);

        // *((DWORDLONG *)pdwCounter) =
        *pdwCounter++ =
            (DWORD)pINFOStats->CacheCtrs.MaximumFileCacheSize;

        // pdwCounter += sizeof(DWORDLONG) / sizeof(*pdwCounter);

        *pdwCounter++ = pINFOStats->CacheCtrs.FlushedEntries;
        *pdwCounter++ = pINFOStats->CacheCtrs.TotalFlushed;

        //
        // URI Cache counters
        //
        *pdwCounter++ = pINFOStats->CacheCtrs.URICached;
        *pdwCounter++ = pINFOStats->CacheCtrs.TotalURICached;
        *pdwCounter++ = pINFOStats->CacheCtrs.URIHits;
        *pdwCounter++ = pINFOStats->CacheCtrs.URIMisses;
        *pdwCounter++ = pINFOStats->CacheCtrs.URIHits;
        *pdwCounter++ = ( pINFOStats->CacheCtrs.URIHits +
                        pINFOStats->CacheCtrs.URIMisses);
        *pdwCounter++ = pINFOStats->CacheCtrs.URIFlushes;
        *pdwCounter++ = pINFOStats->CacheCtrs.TotalURIFlushed;

        //
        // Blob Cache Counters
        //
        *pdwCounter++ = pINFOStats->CacheCtrs.BlobCached;
        *pdwCounter++ = pINFOStats->CacheCtrs.TotalBlobCached;
        *pdwCounter++ = pINFOStats->CacheCtrs.BlobHits;
        *pdwCounter++ = pINFOStats->CacheCtrs.BlobMisses;
        *pdwCounter++ = pINFOStats->CacheCtrs.BlobHits;
        *pdwCounter++ = ( pINFOStats->CacheCtrs.BlobHits +
                        pINFOStats->CacheCtrs.BlobMisses);
        *pdwCounter++ = pINFOStats->CacheCtrs.BlobFlushes;
        *pdwCounter++ = pINFOStats->CacheCtrs.TotalBlobFlushed;

        //
        //  Update arguments for return.
        //

        *lppData          = (PVOID)pdwCounter;
        *lpNumObjectTypes = 1;
        *lpcbTotalBytes   = DIFF((BYTE *)pdwCounter - (BYTE *)pINFODataDefinition);

        //
        //  Free the API buffer.
        //

        MIDL_user_free( (LPBYTE)pINFOStats );

        //
        //  Success!  Honest!!
        //
    } else {
        //
        //  Error retrieving statistics.
        //

        // if the server is down, we don't log an error.
		if ( !( neterr == RPC_S_SERVER_UNAVAILABLE ||
                neterr == RPC_S_UNKNOWN_IF         ||
                neterr == ERROR_SERVICE_NOT_ACTIVE ||
                neterr == RPC_S_CALL_FAILED_DNE ))
        {

            // log event
            ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                0, IIS_INFO_UNABLE_QUERY_IIS_INFO_DATA,
                (PSID)NULL, 0,
                sizeof (neterr), NULL,
                (PVOID)(&neterr));
        }

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;
    }

    return NO_ERROR;

}   // CollectINFOPerformanceData

/*******************************************************************

    NAME:       CloseINFOPerformanceData

    SYNOPSIS:   Terminates the performance counters.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CloseINFOPerformanceData( VOID )
{
    //
    //  No real cleanup to do here.
    //

    if (--cOpens == 0) {
        if (hEventLog != NULL) DeregisterEventSource (hEventLog);
    }

    return NO_ERROR;

}   // CloseINFOPerformanceData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\server\main.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    main.cxx

        Library initialization for infocomm.dll  --
           Internet Information Services Common dll.

    FILE HISTORY:
        Johnl       06-Oct-1994 Created.
        MuraliK     15-Nov-1994
               Modified to include new service list initializations

        MuraliK     21-Feb-1995
               Added init and cleanup of debugging variables
        MuraliK     16-May-1995
               Added code to read debug flags.
        MuraliK     6-June-1995
               Initialized Atq Bandwidth Level, reading values from registry

        MuraliK    16-Oct-1995   Tailored it for infocom.dll
*/

#include <tcpdllp.hxx>
#include <atq.h>
#include <info_srv.h>
#include <inetsvcs.h>
#include <lonsi.hxx>
#include <mb.hxx>
#include <irtlmisc.h>

PISRPC  g_pIsrpc = NULL;
HINSTANCE g_hDll = NULL;
LONG    g_cInitializers = 0;
CRITICAL_SECTION g_csDllInitLock;

DECLARE_PLATFORM_TYPE();

enum {
    INIT_NONE,
    INIT_DEBUG_PRINT,
    INIT_ENTRY_POINTS,
    INIT_SVC_LOC,
    INIT_IISRTL,
    INIT_ATQ,
    INIT_SECURITY,
    INIT_SVC_INFO,
    INIT_METABASE,
    INIT_TSUNAMI,
    INIT_SCAVENGER,
    INIT_SVC_RPC,
    INIT_RDNS,
    INIT_MIME_MAP,
    INIT_CONFIG_FROM_REG,
    INIT_LOGGING,
    INIT_ENDPOINT_UTILITIES
} g_InitCommonDllState = INIT_NONE;

#ifndef _NO_TRACING_
#include <initguid.h>
#ifndef _EXEXPRESS
DEFINE_GUID(IisInfoServerGuid,
0x784d8911, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DEFINE_GUID(IisKInfoServerGuid,
0x784d891E, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#endif
DECLARE_DEBUG_PRINTS_OBJECT()
#endif
//
// externs
//

DWORD
InitGlobalConfigFromReg(
    VOID
    );

#ifdef _NO_TRACING_
DWORD
GetDebugFlagsFromReg(
        IN LPCTSTR pszRegEntry
        );
#endif


extern "C"
BOOL WINAPI DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    BOOL  fReturn = TRUE;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:  {

        DWORD  dwDebug;

#ifdef _NO_TRACING_

#ifndef _EXEXPRESS
        CREATE_DEBUG_PRINT_OBJECT( "infocomm.dll");
#else
        CREATE_DEBUG_PRINT_OBJECT( "knfocomm.dll");
#endif

        dwDebug = GetDebugFlagsFromReg(INET_INFO_PARAMETERS_KEY);

        SET_DEBUG_FLAGS( dwDebug);

#else
#ifndef _EXEXPRESS
        CREATE_DEBUG_PRINT_OBJECT( "infocomm.dll", IisInfoServerGuid);
#else
        CREATE_DEBUG_PRINT_OBJECT( "knfocomm.dll", IisKInfoServerGuid);
#endif
#endif

        g_hDll = hDll;

        //
        // Initialize the platform type
        //

        (VOID)IISGetPlatformType( );

        DBG_REQUIRE( DisableThreadLibraryCalls( hDll ) );

        INITIALIZE_CRITICAL_SECTION( &g_csDllInitLock );
        break;
    }

    case DLL_PROCESS_DETACH:

        DELETE_DEBUG_PRINT_OBJECT();
        DeleteCriticalSection( &g_csDllInitLock );
    break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break ;
    }

    return ( fReturn);

}  // main()


BOOL
CallInitFunctions(
    VOID
    )
/*++
    Description:

        Call all the init functions.

    Return value:

        TRUE of all init's succeed.
--*/
{
    DWORD err = NO_ERROR;

    g_InitCommonDllState = INIT_NONE;

#ifdef _NO_TRACING_
    if (!VALID_DEBUG_PRINT_OBJECT()) goto error;
#endif
    g_InitCommonDllState = INIT_DEBUG_PRINT;

    if (!GetDynamicEntryPoints()) goto error;
    g_InitCommonDllState = INIT_ENTRY_POINTS;

    if (!pfnInitSvcLoc()) goto error;
    g_InitCommonDllState = INIT_SVC_LOC;

    if (!InitializeIISRTL()) goto error;
    g_InitCommonDllState = INIT_IISRTL;

#ifndef _EXEXPRESS
    if (!AtqInitialize(ATQ_INIT_SPUD_FLAG)) goto error;
#else
    if (!AtqInitialize(0)) goto error;
#endif
    g_InitCommonDllState = INIT_ATQ;

    err = InitializeSecurity(g_hDll);
    if (err != NO_ERROR) goto error;
    g_InitCommonDllState = INIT_SECURITY;

    if (!IIS_SERVICE::InitializeServiceInfo()) goto error;
    g_InitCommonDllState = INIT_SVC_INFO;

    if (!IIS_SERVICE::InitializeMetabaseComObject()) goto error;
    g_InitCommonDllState = INIT_METABASE;

    if (!Tsunami_Initialize()) goto error;
    g_InitCommonDllState = INIT_TSUNAMI;

    if (!InitializeCacheScavenger()) goto error;
    g_InitCommonDllState = INIT_SCAVENGER;

    if (!IIS_SERVICE::InitializeServiceRpc(
                                 INET_INFO_SERVICE_NAME,
                                 inetinfo_ServerIfHandle
                                 )
       ) goto error;
    g_InitCommonDllState = INIT_SVC_RPC;

    if (!InitRDns()) goto error;
    g_InitCommonDllState = INIT_RDNS;

    if (!InitializeMimeMap(INET_INFO_PARAMETERS_KEY)) goto error;
    g_InitCommonDllState = INIT_MIME_MAP;

    err = InitGlobalConfigFromReg();
    if (err != NO_ERROR) goto error;
    g_InitCommonDllState = INIT_CONFIG_FROM_REG;

    err = LOGGING::Initialize();
    if (err != NO_ERROR) goto error;
    g_InitCommonDllState = INIT_LOGGING;

    if (!InitializeEndpointUtilities()) goto error;
    g_InitCommonDllState = INIT_ENDPOINT_UTILITIES;

    return TRUE;
error:

    if (err != NO_ERROR) {
        SetLastError(err);
    }

    return FALSE;
}

VOID
CallUninitFunctions(
    VOID
    )
/*++
    Description:

        Call all the uninit functions.

    Return value:

        None.
--*/
{
    switch (g_InitCommonDllState) {
    case INIT_ENDPOINT_UTILITIES:
        TerminateEndpointUtilities();
        
    case INIT_LOGGING:
        LOGGING::Terminate();

    case INIT_CONFIG_FROM_REG:
    case INIT_MIME_MAP:
        CleanupMimeMap();

    case INIT_RDNS:
        TerminateRDns();

    case INIT_SVC_RPC:
        IIS_SERVICE::CleanupServiceRpc();

    case INIT_SCAVENGER:
        TerminateCacheScavenger();

    case INIT_TSUNAMI:
        Tsunami_Terminate();

    case INIT_METABASE:
        IIS_SERVICE::CleanupMetabaseComObject();

    case INIT_SVC_INFO:
        IIS_SERVICE::CleanupServiceInfo();

    case INIT_SECURITY:
        TerminateSecurity();

    case INIT_ATQ:
        if ( !AtqTerminate()) {
            DBGPRINTF(( DBG_CONTEXT,
                        " ATQ Terminate Failed with Error %d\n", GetLastError()
                        ));
            DBGPRINTF(( DBG_CONTEXT, " ATQ Terminate Failed\n"));
        }

    case INIT_SVC_LOC:
        pfnTerminateSvcLoc();

    case INIT_IISRTL:
        TerminateIISRTL();

    case INIT_ENTRY_POINTS:
        FreeDynamicLibraries();

    case INIT_DEBUG_PRINT:
    case INIT_NONE:
        /* no complaints Mr. Compiler */ break;
    }

}



BOOL
InitCommonDlls(
    VOID
    )
/*++
    Description:

        DLL Init and uninit functions that don't have to worry about the
        peb lock being taken during PROCESS_ATTACH/DETACH.

--*/
{
    BOOL fReturn = TRUE;
    RECT rect;

    DBGPRINTF(( DBG_CONTEXT,
                "[InitCommonDlls] Entered - Initialization count %d\n",
                g_cInitializers ));

    EnterCriticalSection( &g_csDllInitLock );

    //
    //  Are we already initialized?
    //

    if ( g_cInitializers ) {

        g_cInitializers++;
        LeaveCriticalSection( &g_csDllInitLock );

        return TRUE;
    }

    INITIALIZE_PLATFORM_TYPE();

    if ( !CallInitFunctions() )
    {
        DWORD err;

        IIS_PRINTF((buff,"Initializing infocomm.dll module failed\n"));

        err = GetLastError();
        CallUninitFunctions();
        SetLastError(err);
        fReturn = FALSE;

    } else if ( !TsIsWindows95() ) {

        //
        // Call a windows API that will cause windows server side thread to
        // be created for tcpsvcs.exe. This prevents a severe winsrv memory
        // leak when spawning processes and
        // gives a perf boost so the windows
        // console isn't brought up and torn down each time.   :(
        //

        (VOID) AdjustWindowRectEx( &rect,
                                   0,
                                   FALSE,
                                   0 );

        // fReturn already init to TRUE
    }

    //
    //  Only inc the init count if we initialized successfully
    //

    if ( fReturn ) {

        g_cInitializers++;
    }

    LeaveCriticalSection( &g_csDllInitLock );

    return fReturn;
}

BOOL
TerminateCommonDlls(
    VOID
    )
{
    MB     mb( (IMDCOM*) IIS_SERVICE::QueryMDObject() );

    DBG_ASSERT( g_cInitializers > 0 );

    DBGPRINTF(( DBG_CONTEXT,
                "[TerminateCommonDlls] Init Count = %d\n",
                g_cInitializers ));

    EnterCriticalSection( &g_csDllInitLock );

    if ( --g_cInitializers )
    {
        LeaveCriticalSection( &g_csDllInitLock );
        return TRUE;
    }

    //
    // When we clean up, make sure the metabase has been saved,
    // so no recent modifications get lost.
    //

    DBGPRINTF(( DBG_CONTEXT,
                "[TerminateCommonDlls] Saving Metabase\n" ));

    mb.Save();


    DBGPRINTF(( DBG_CONTEXT,
                "[TerminateCommonDlls] Terminating dlls\n" ));


    CallUninitFunctions();

    LeaveCriticalSection( &g_csDllInitLock );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\server\rpccom.cxx ===
/*++
   Copyright    (c)    1996        Microsoft Corporation

   Module Name:
        rpccom.cxx

   Abstract:

        This module contains the server side service RPC admin APIs for K2


   Author:

        Johnson Apacible    (johnsona)      06-03-96


--*/

//
//  Include Headers
//

#include <tcpdllp.hxx>
#include <tsunami.hxx>

extern "C" {
#include <info_srv.h>
};

#include <atq.h>
#include "inetreg.h"
#include <iisver.h>

// forward definition

NET_API_STATUS
NET_API_FUNCTION
InitW3PerfCounters(
	OUT LPDWORD lpcbTotalRequired
	);

NET_API_STATUS
NET_API_FUNCTION
CollectW3PerfCounters( LPWSTR    lpValueName,
                       LPBYTE  * lppData,
                       LPDWORD   lpcbTotalBytes,
                       LPDWORD   lpNumObjectTypes 
					 );


NET_API_STATUS
NET_API_FUNCTION
GetStatistics(
    IN DWORD    dwLevel,
    IN DWORD    dwServiceId,
    IN DWORD    dwInstance,
    OUT PCHAR * pBuffer
    )
/*++

   Description

     Common get statistics routine

   Arguments:

      dwLevel - level of the statistics to get
      dwServiceId - ID of the service to get stats from
      dwInstance - instance whose stats we are to get
      InfoStruct - Will contain the returned buffer

   Note:

--*/
{
    DWORD err = NO_ERROR;
    PCHAR buffer;
    PIIS_SERVICE  pInetSvc;

    IF_DEBUG( DLL_RPC) {

       DBGPRINTF( ( DBG_CONTEXT,
                   " Entering GetStatistics (L%d)\n", dwLevel));
    }

    //
    // Do we have permissions?
    //

    if ( (err = TsApiAccessCheck( TCP_QUERY_STATISTICS )) != NO_ERROR) {
        IF_DEBUG( DLL_RPC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " TsApiAccessCheck() Failed. Error = %u\n", err));
        }
        return(err);
    }

    pInetSvc = IIS_SERVICE::FindFromServiceInfoList( dwServiceId );
    if ( pInetSvc == NULL ) {
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // Get the params
    //

    if (!pInetSvc->GetInstanceStatistics(
                                        dwInstance,
                                        dwLevel,
                                        pBuffer
                                        ) ) {

        err =  GetLastError();
        IF_DEBUG( DLL_RPC) {
            DBGPRINTF( ( DBG_CONTEXT,
                        "GetInstanceStats failed. Error = %u\n",
                        err));
        }
    }

    //
    // This was referenced in Find
    //

    pInetSvc->Dereference( );

    return err;

} // GetStatistics



NET_API_STATUS
NET_API_FUNCTION
ClearStatistics(
    IN DWORD    dwServiceId,
    IN DWORD    dwInstance
    )
/*++

   Description

     Common get statistics routine

   Arguments:

      pszServer - unused
      dwServerMask - Bitfield of servers to set the information for
      pConfig - Admin information to set

   Note:

--*/
{
    DWORD err = NO_ERROR;
    PCHAR buffer;
    PIIS_SERVICE  pInetSvc;

    IF_DEBUG( DLL_RPC) {

       DBGPRINTF( ( DBG_CONTEXT,
                   " Entering ClearStatistics (Instance %d)\n", dwInstance));
    }

    //
    // Do we have permissions?
    //

    if ( (err = TsApiAccessCheck( TCP_CLEAR_STATISTICS )) != NO_ERROR) {
        IF_DEBUG( DLL_RPC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " TsApiAccessCheck() Failed. Error = %u\n", err));
        }
        return(err);
    }

    pInetSvc = IIS_SERVICE::FindFromServiceInfoList( dwServiceId );
    if ( pInetSvc == NULL ) {
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // Get the params
    //

    if (!pInetSvc->ClearInstanceStatistics(dwInstance) ) {

        err =  GetLastError();
        IF_DEBUG( DLL_RPC) {
            DBGPRINTF( ( DBG_CONTEXT,
                        "GetInstanceStats failed. Error = %u\n",
                        err));
        }
    }

    //
    // This was referenced in Find
    //

    pInetSvc->Dereference( );

    return err;

} // ClearStatistics


NET_API_STATUS
NET_API_FUNCTION
R_InitW3CounterStructure(
    IN LPWSTR   pszServer OPTIONAL,
	OUT LPDWORD lpcbTotalRequired
    )
/*++

   Description

     Initialize W3 object and counter indexes

   Arguments:

	 pszServer - unused
	 lpcbTotalRequired - size of memory needed to retrieve w3 performance data

   Note:

--*/
{
    DWORD err;

	err = InitW3PerfCounters(lpcbTotalRequired);

	return err;
} // R_InitW3CounterStructure


NET_API_STATUS
NET_API_FUNCTION
R_CollectW3PerfData(
    IN LPWSTR        pszServer OPTIONAL,
	IN LPWSTR        lpValueName,
    OUT LPBYTE       lppData,
    IN OUT LPDWORD   lpcbTotalBytes,
    OUT LPDWORD   lpNumObjectTypes 
	)
/*++

   Description

     Collect W3 perfomance data

   Arguments:

	 pszServer - unused
	 lpValueName - counter object name to be retrieved
	 lppData - will hold the returned W3 performance data
	 lpcbTotalBytes - total bytes of W3 performance data returned
	 lpNumobjectTypes - number of object types returned

   Note:

--*/
{
    DWORD err;

	err = CollectW3PerfCounters( lpValueName,
								 &lppData,
						         lpcbTotalBytes,
						         lpNumObjectTypes
	                            );

	return err;
}


NET_API_STATUS
NET_API_FUNCTION
R_W3QueryStatistics2(
    IN LPWSTR                       pszServer OPTIONAL,
    IN DWORD                        dwLevel,
    IN DWORD                        dwInstance,
    IN DWORD                        dwReserved,
    IN LPW3_STATISTICS_STRUCT       InfoStruct
    )
/*++

   Description

     Gets the W3 specific statistics

   Arguments:

      pszServer - unused
      dwLevel - level of the statistics to get
      dwInstance - instance whose stats we are to get
      dwReserved - MBZ
      InfoStruct - Will contain the returned buffer

   Note:

--*/
{
    DWORD err;
    PCHAR buffer;

    err = GetStatistics(
                    dwLevel,
                    INET_HTTP_SVC_ID,
                    dwInstance,
                    &buffer
                    );

    if ( err == NO_ERROR ) {
        InfoStruct->StatInfo1 = (LPW3_STATISTICS_1)buffer;
    }

    return ( err);

} // W3GetStatistics



NET_API_STATUS
NET_API_FUNCTION
R_W3ClearStatistics2(
    IN LPWSTR                       pszServer OPTIONAL,
    IN DWORD                        dwInstance
    )
/*++

   Description

     Clears the W3 specific statistics

   Arguments:

      pszServer - unused
      dwInstance - instance whose stats we should clear

   Note:

--*/
{
    DWORD err;

    err = ClearStatistics(
                INET_HTTP_SVC_ID,
                dwInstance
                );

    return err;

} // W3ClearStatistics



NET_API_STATUS
NET_API_FUNCTION
R_FtpQueryStatistics2(
    IN LPWSTR                       pszServer OPTIONAL,
    IN DWORD                        dwLevel,
    IN DWORD                        dwInstance,
    IN DWORD                        dwReserved,
    IN LPFTP_STATISTICS_STRUCT       InfoStruct
    )
/*++

   Description

     Gets the Ftp specific statistics

   Arguments:

      pszServer - unused
      dwLevel - level of the statistics to get
      dwInstance - instance whose stats we are to get
      dwReserved - MBZ
      InfoStruct - Will contain the returned buffer

   Note:

--*/
{
    DWORD err;
    PCHAR buffer;

    err = GetStatistics(
                    dwLevel,
                    INET_FTP_SVC_ID,
                    dwInstance,
                    &buffer
                    );

    if ( err == NO_ERROR ) {
        InfoStruct->StatInfo0 = (LPFTP_STATISTICS_0)buffer;
    }

    return ( err);

} // FtpGetStatistics



NET_API_STATUS
NET_API_FUNCTION
R_FtpClearStatistics2(
    IN LPWSTR                       pszServer OPTIONAL,
    IN DWORD                        dwInstance
    )
/*++

   Description

     Clears the Ftp specific statistics

   Arguments:

      pszServer - unused
      dwInstance - instance whose stats we should clear

   Note:

--*/
{
    DWORD err;

    err = ClearStatistics(
                INET_FTP_SVC_ID,
                dwInstance
                );

    return err;

} // FtpClearStatistics


NET_API_STATUS
NET_API_FUNCTION
R_IISEnumerateUsers(
    IN LPWSTR                   pszServer OPTIONAL,
    IN DWORD                    dwServiceId,
    IN DWORD                    dwInstance,
    OUT LPIIS_USER_ENUM_STRUCT  InfoStruct
    )
/*++

   Description

     Enumerates the users for a given instance.

   Arguments:

      pszServer - unused
      dwServiceId - service ID
      dwInstance - instance ID
      InfoStruct - structure to get the information with.

   Note:

--*/
{
    DWORD err = NO_ERROR;
    PCHAR buffer = NULL;
    DWORD nRead = 0;
    DWORD dwLevel = InfoStruct->Level;
    PIIS_SERVICE  pInetSvc;

    IF_DEBUG( DLL_RPC) {

       DBGPRINTF( ( DBG_CONTEXT,
                   " Entering R_IISEnumerateUsers (L%d) for Service %x\n",
                    dwLevel, dwServiceId));
    }

    //
    // We only support 1
    //

    if ( dwLevel != 1 ) {
        return(ERROR_INVALID_LEVEL);
    }

    if ( ( err = TsApiAccessCheck( TCP_ENUMERATE_USERS)) != NO_ERROR) {

       IF_DEBUG( DLL_RPC) {
            DBGPRINTF( ( DBG_CONTEXT,
                        " TsApiAccessCheck() Failed. Error = %u\n", err));
       }
       return(err);
    }

    pInetSvc = IIS_SERVICE::FindFromServiceInfoList( dwServiceId );
    if ( pInetSvc == NULL ) {
        buffer = NULL;
        nRead = 0;
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // Get the params
    //

    if ( !pInetSvc->EnumerateInstanceUsers(
                                dwInstance,
                                &nRead,
                                &buffer) ) {

        DBG_ASSERT(buffer == NULL);
        DBG_ASSERT(nRead == 0);
        err = GetLastError();

    } else {

        InfoStruct->ConfigInfo.Level1->Buffer =
                        (LPIIS_USER_INFO_1)buffer;
        InfoStruct->ConfigInfo.Level1->EntriesRead = nRead;
    }

    //
    // This was referenced in Find
    //

    pInetSvc->Dereference( );

    return err;

} // R_IISEnumerateUsers



NET_API_STATUS
NET_API_FUNCTION
R_IISDisconnectUser(
    IN LPWSTR                   pszServer OPTIONAL,
    IN DWORD                    dwServiceId,
    IN DWORD                    dwInstance,
    IN DWORD                    dwIdUser
    )
/*++

   Description

     Enumerates the users for a given instance.

   Arguments:

      pszServer - unused
      dwServiceId - service ID
      dwInstance - instance ID
      InfoStruct - structure to get the information with.

   Note:

--*/
{
    DWORD err = NO_ERROR;
    PIIS_SERVICE  pInetSvc;

    IF_DEBUG( DLL_RPC) {

       DBGPRINTF( ( DBG_CONTEXT,
                   " Entering R_IISDisconnectUsers for Service %x\n",
                    dwServiceId));
    }

    if ( ( err = TsApiAccessCheck( TCP_DISCONNECT_USER )) != NO_ERROR) {

       IF_DEBUG( DLL_RPC) {
            DBGPRINTF( ( DBG_CONTEXT,
                        " TsApiAccessCheck() Failed. Error = %u\n", err));
       }
       return(err);
    }

    pInetSvc = IIS_SERVICE::FindFromServiceInfoList( dwServiceId );
    if ( pInetSvc == NULL ) {
        return ERROR_SERVICE_NOT_ACTIVE;
    }

    //
    // Get the params
    //

    if ( !pInetSvc->DisconnectInstanceUser(
                                dwInstance,
                                dwIdUser) ) {

        err = GetLastError();

    }

    //
    // This was referenced in Find
    //

    pInetSvc->Dereference( );

    return ( err);

} // R_IISDisconnectUsers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\server\w3data.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993-1996           **/
/**********************************************************************/

/*
    w3ata.c

    Constant data structures for the W3 Server's counter objects &
    counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.
        Bob Watson/MuraliK     03-Oct-1996 - Added rate counters for W3.

*/


#include <windows.h>
#include <winperf.h>
#include "w3ctrs.h"
#include "w3data.h"

static W3_COUNTER_BLOCK     w3c;

//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

W3_DATA_DEFINITION W3DataDefinition =
{
    {   // W3ObjectType
        sizeof(W3_DATA_DEFINITION) + sizeof (W3_COUNTER_BLOCK),
        sizeof(W3_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        W3_COUNTER_OBJECT,
        0,
        W3_COUNTER_OBJECT,
        0,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_W3_COUNTERS,
        2,                              // Default = Bytes Total/sec
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // W3BytesSent/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BYTES_SENT_COUNTER,
        0,
        W3_BYTES_SENT_COUNTER,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(w3c.BytesSent),
        0 // assigned in open procedure
    },

    {   // W3BytesReceived/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BYTES_RECEIVED_COUNTER,
        0,
        W3_BYTES_RECEIVED_COUNTER,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(w3c.BytesReceived),
        0 // assigned in open procedure
    },

    {   // W3BytesTotal/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BYTES_TOTAL_COUNTER,
        0,
        W3_BYTES_TOTAL_COUNTER,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(w3c.BytesTotal),
        0 // assigned in open procedure
    },

    {   // W3FilesSent
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_SENT_COUNTER,
        0,
        W3_FILES_SENT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.FilesSent),
        0 // assigned in open procedure
    },

    {   // W3FilesSentSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_SENT_SEC,
        0,
        W3_FILES_SENT_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.FilesSentSec),
        0 // assigned in open procedure
    },

    {   // W3FilesReceived
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_RECEIVED_COUNTER,
        0,
        W3_FILES_RECEIVED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.FilesReceived),
        0 // assigned in open procedure
    },

    {   // W3FilesReceivedSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_RECEIVED_SEC,
        0,
        W3_FILES_RECEIVED_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.FilesReceivedSec),
        0 // assigned in open procedure
    },

    {   // W3FilesTotal
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_TOTAL_COUNTER,
        0,
        W3_FILES_TOTAL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.FilesTotal),
        0 // assigned in open procedure
    },

    {   // W3FilesSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_SEC,
        0,
        W3_FILES_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.FilesSec),
        0 // assigned in open procedure
    },

    {   // W3CurrentAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_ANONYMOUS_COUNTER,
        0,
        W3_CURRENT_ANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentAnonymous),
        0 // assigned in open procedure
    },

    {   // W3CurrentNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_NONANONYMOUS_COUNTER,
        0,
        W3_CURRENT_NONANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentNonAnonymous),
        0 // assigned in open procedure
    },

    {   // W3TotalAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_ANONYMOUS_COUNTER,
        0,
        W3_TOTAL_ANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalAnonymous),
        0 // assigned in open procedure
    },

    {   // W3TotalAnonymous/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_ANONYMOUS_USERS_SEC,
        0,
        W3_ANONYMOUS_USERS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.AnonymousUsersSec),
        0 // assigned in open procedure
    },

    {   // W3NonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_NONANONYMOUS_COUNTER,
        0,
        W3_TOTAL_NONANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalNonAnonymous),
        0 // assigned in open procedure
    },

    {   // W3NonAnonymous/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_NON_ANONYMOUS_USERS_SEC,
        0,
        W3_NON_ANONYMOUS_USERS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.NonAnonymousUsersSec),
        0 // assigned in open procedure
    },

    {   // W3MaxAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_ANONYMOUS_COUNTER,
        0,
        W3_MAX_ANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxAnonymous),
        0 // assigned in open procedure
    },

    {   // W3MaxNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_NONANONYMOUS_COUNTER,
        0,
        W3_MAX_NONANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxNonAnonymous),
        0 // assigned in open procedure
    },

    {   // W3CurrentConnections
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_CONNECTIONS_COUNTER,
        0,
        W3_CURRENT_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentConnections),
        0 // assigned in open procedure
    },

    {   // W3MaxConnections
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_CONNECTIONS_COUNTER,
        0,
        W3_MAX_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxConnections),
        0 // assigned in open procedure
    },

    {   // W3ConnectionAttempts
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CONNECTION_ATTEMPTS_COUNTER,
        0,
        W3_CONNECTION_ATTEMPTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.ConnectionAttempts),
        0 // assigned in open procedure
    },
    {   // W3ConnectionsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CONNECTION_ATTEMPTS_SEC,
        0,
        W3_CONNECTION_ATTEMPTS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.ConnectionAttemptsSec),
        0 // assigned in open procedure
    },

    {   // W3LogonAttempts
        sizeof(PERF_COUNTER_DEFINITION),
        W3_LOGON_ATTEMPTS_COUNTER,
        0,
        W3_LOGON_ATTEMPTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.LogonAttempts),
        0 // assigned in open procedure
    },

    {   // W3LogonAttemptsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_LOGON_ATTEMPTS_SEC,
        0,
        W3_LOGON_ATTEMPTS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.LogonAttemptsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalOptions
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_OPTIONS_COUNTER,
        0,
        W3_TOTAL_OPTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalOptions),
        0 // assigned in open procedure
    },

    {   // W3TotalOptionsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_OPTIONS_SEC,
        0,
        W3_TOTAL_OPTIONS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalOptionsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalGets
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_GETS_COUNTER,
        0,
        W3_TOTAL_GETS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalGets),
        0 // assigned in open procedure
    },

    {   // W3TotalGetsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_GETS_SEC,
        0,
        W3_TOTAL_GETS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalGetsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalPosts
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_POSTS_COUNTER,
        0,
        W3_TOTAL_POSTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalPosts),
        0 // assigned in open procedure
    },

    {   // W3TotalPostsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_POSTS_SEC,
        0,
        W3_TOTAL_POSTS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalPostsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalHeads
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_HEADS_COUNTER,
        0,
        W3_TOTAL_HEADS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalHeads),
        0 // assigned in open procedure
    },

    {   // W3TotalHeadsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_HEADS_SEC,
        0,
        W3_TOTAL_HEADS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalHeadsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalPuts
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PUTS_COUNTER,
        0,
        W3_TOTAL_PUTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalPuts),
        0 // assigned in open procedure
    },

    {   // W3TotalPutsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PUTS_SEC,
        0,
        W3_TOTAL_PUTS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalPutsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalDeletes
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_DELETES_COUNTER,
        0,
        W3_TOTAL_DELETES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalDeletes),
        0 // assigned in open procedure
    },

    {   // W3TotalDeletesSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_DELETES_SEC,
        0,
        W3_TOTAL_DELETES_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalDeletesSec),
        0 // assigned in open procedure
    },

    {   // W3TotalTraces
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_TRACES_COUNTER,
        0,
        W3_TOTAL_TRACES_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalTraces),
        0 // assigned in open procedure
    },

    {   // W3TotalTracesSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_TRACES_SEC,
        0,
        W3_TOTAL_TRACES_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalTracesSec),
        0 // assigned in open procedure
    },

    {   // W3TotalMove
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_MOVE_COUNTER,
        0,
        W3_TOTAL_MOVE_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalMove),
        0 // assigned in open procedure
    },

    {   // W3TotalMoveSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_MOVE_SEC,
        0,
        W3_TOTAL_MOVE_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalMoveSec),
        0 // assigned in open procedure
    },

    {   // W3TotalCopy
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_COPY_COUNTER,
        0,
        W3_TOTAL_COPY_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalCopy),
        0 // assigned in open procedure
    },

    {   // W3TotalCopySec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_COPY_SEC,
        0,
        W3_TOTAL_COPY_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalCopySec),
        0 // assigned in open procedure
    },

    {   // W3TotalMkcol
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_MKCOL_COUNTER,
        0,
        W3_TOTAL_MKCOL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalMkcol),
        0 // assigned in open procedure
    },

    {   // W3TotalMkcolSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_MKCOL_SEC,
        0,
        W3_TOTAL_MKCOL_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalMkcolSec),
        0 // assigned in open procedure
    },

    {   // W3TotalPropfind
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PROPFIND_COUNTER,
        0,
        W3_TOTAL_PROPFIND_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalPropfind),
        0 // assigned in open procedure
    },

    {   // W3TotalPropfindSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PROPFIND_SEC,
        0,
        W3_TOTAL_PROPFIND_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalPropfindSec),
        0 // assigned in open procedure
    },

    {   // W3TotalProppatch
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PROPPATCH_COUNTER,
        0,
        W3_TOTAL_PROPPATCH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalProppatch),
        0 // assigned in open procedure
    },

    {   // W3TotalProppatchSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PROPPATCH_SEC,
        0,
        W3_TOTAL_PROPPATCH_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalProppatchSec),
        0 // assigned in open procedure
    },

    {   // W3TotalSearch
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_SEARCH_COUNTER,
        0,
        W3_TOTAL_SEARCH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalSearch),
        0 // assigned in open procedure
    },

    {   // W3TotalSearchSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_SEARCH_SEC,
        0,
        W3_TOTAL_SEARCH_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalSearchSec),
        0 // assigned in open procedure
    },

    {   // W3TotalLock
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_LOCK_COUNTER,
        0,
        W3_TOTAL_LOCK_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalLock),
        0 // assigned in open procedure
    },

    {   // W3TotalLockSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_LOCK_SEC,
        0,
        W3_TOTAL_LOCK_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalLockSec),
        0 // assigned in open procedure
    },

    {   // W3TotalUnlock
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_UNLOCK_COUNTER,
        0,
        W3_TOTAL_UNLOCK_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalUnlock),
        0 // assigned in open procedure
    },

    {   // W3TotalUnlockSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_UNLOCK_SEC,
        0,
        W3_TOTAL_UNLOCK_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalUnlockSec),
        0 // assigned in open procedure
    },

    {   // W3TotalOthers
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_OTHERS_COUNTER,
        0,
        W3_TOTAL_OTHERS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalOthers),
        0 // assigned in open procedure
    },

    {   // W3TotalOthersSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_OTHERS_SEC,
        0,
        W3_TOTAL_OTHERS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalOthersSec),
        0 // assigned in open procedure
    },

    {   // W3TotalRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_REQUESTS_COUNTER,
        0,
        W3_TOTAL_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalRequests),
        0 // assigned in open procedure
    },

    {   // W3TotalRequestsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_REQUESTS_SEC,
        0,
        W3_TOTAL_REQUESTS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalRequestsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalCGIRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_CGI_REQUESTS_COUNTER,
        0,
        W3_TOTAL_CGI_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalCGIRequests),
        0 // assigned in open procedure
    },

    {   // W3TotalCGIRequestsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CGI_REQUESTS_SEC,
        0,
        W3_CGI_REQUESTS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.CGIRequestsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalBGIRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_BGI_REQUESTS_COUNTER,
        0,
        W3_TOTAL_BGI_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalBGIRequests),
        0 // assigned in open procedure
    },

    {   // W3TotalBGIRequestsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BGI_REQUESTS_SEC,
        0,
        W3_BGI_REQUESTS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.BGIRequestsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalNotFoundErrors
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_NOT_FOUND_ERRORS_COUNTER,
        0,
        W3_TOTAL_NOT_FOUND_ERRORS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalNotFoundErrors),
        0 // assigned in open procedure
    },

    {   // W3TotalNotFoundErrorsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_NOT_FOUND_ERRORS_SEC,
        0,
        W3_TOTAL_NOT_FOUND_ERRORS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalNotFoundErrorsSec),
        0 // assigned in open procedure
    },

    {   // W3TotalLockedErrors
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_LOCKED_ERRORS_COUNTER,
        0,
        W3_TOTAL_LOCKED_ERRORS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalLockedErrors),
        0 // assigned in open procedure
    },

    {   // W3TotalLockedErrorsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_LOCKED_ERRORS_SEC,
        0,
        W3_TOTAL_LOCKED_ERRORS_SEC,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalLockedErrorsSec),
        0 // assigned in open procedure
    },

    {   // W3CurrentCGI
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_CGI_COUNTER,
        0,
        W3_CURRENT_CGI_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentCGIRequests),
        0 // assigned in open procedure
    },

    {   // W3CurrentBGI
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_BGI_COUNTER,
        0,
        W3_CURRENT_BGI_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentBGIRequests),
        0 // assigned in open procedure
    },

    {   // W3MaxCGI
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_CGI_COUNTER,
        0,
        W3_MAX_CGI_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxCGIRequests),
        0 // assigned in open procedure
    },

    {   // W3MaxBGI
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_BGI_COUNTER,
        0,
        W3_MAX_BGI_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxBGIRequests),
        0 // assigned in open procedure
    },

#if defined(CAL_ENABLED)
    {   // W3CurrentCalAuth
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_CAL_AUTH_COUNTER,
        0,
        W3_CURRENT_CAL_AUTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentCalAuth),
        0 // assigned in open procedure
    },

    {   // W3MaxCalAuth
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_CAL_AUTH_COUNTER,
        0,
        W3_MAX_CAL_AUTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxCalAuth),
        0 // assigned in open procedure
    },

    {   // W3TotalFailedCalAuth
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_FAILED_CAL_AUTH_COUNTER,
        0,
        W3_TOTAL_FAILED_CAL_AUTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalFailedCalAuth),
        0 // assigned in open procedure
    },

    {   // W3CurrentCalSsl
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_CAL_SSL_COUNTER,
        0,
        W3_CURRENT_CAL_SSL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentCalSsl),
        0 // assigned in open procedure
    },

    {   // W3MaxCalSsl
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_CAL_SSL_COUNTER,
        0,
        W3_MAX_CAL_SSL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxCalSsl),
        0 // assigned in open procedure
    },

    {   // W3TotalFailedCalSsl
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_FAILED_CAL_SSL_COUNTER,
        0,
        W3_TOTAL_FAILED_CAL_SSL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalFailedCalSsl),
        0 // assigned in open procedure
    },
#endif

    {   // W3BlockedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BLOCKED_REQUESTS_COUNTER,
        0,
        W3_BLOCKED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.BlockedRequests),
        0 // assigned in open procedure
    },
    
    {   // W3AllowedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_ALLOWED_REQUESTS_COUNTER,
        0,
        W3_ALLOWED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.AllowedRequests),
        0 // assigned in open procedure
    },
    
    {   // W3RejectedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_REJECTED_REQUESTS_COUNTER,
        0,
        W3_REJECTED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.RejectedRequests),
        0 // assigned in open procedure
    },
    
    {   // W3CurrentBlockedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_BLOCKED_REQUESTS_COUNTER,
        0,
        W3_CURRENT_BLOCKED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentBlockedRequests),
        0 // assigned in open procedure
    },
    
    {   // W3MeasuredBandwidth
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MEASURED_BANDWIDTH_COUNTER,
        0,
        W3_MEASURED_BANDWIDTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MeasuredBandwidth),
        0 // assigned in open procedure
    },

    {   // W3ServiceUptime
        sizeof(PERF_COUNTER_DEFINITION),
        W3_SERVICE_UPTIME_COUNTER,
        0,
        W3_SERVICE_UPTIME_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.ServiceUptime),
        0 // assigned in open procedure
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\server\rpcperfw3.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    rpcperfw3.c

    This file implements the Extensible Performance Objects for
    the W3 Server service.


    FILE HISTORY:
		MingLu      20-NOV-1999 Created, support optimized w3 performance counters
*/

#include <tcpdllp.hxx>

#include <windows.h>
#include <winperf.h>
#include <lm.h>

#include <string.h>
#include <stdlib.h>

#include <iis64.h>
#include <w3svc.h>

#include "w3perfmsg.h"

extern "C" {
#include "perfutil.h"
#include "w3data.h"
} // extern "C"

#define APP_NAME                     (TEXT("W3Ctrs"))
#define MAX_SIZEOF_INSTANCE_NAME     METADATA_MAX_NAME_LEN
#define TOTAL_INSTANCE_NAME          L"_Total"

//
//  Private globals.
//

BOOL    fInitOK   = FALSE;    // TRUE if W3 counter structure initialized OK.

// forward declaration

NET_API_STATUS
NET_API_FUNCTION
GetStatistics(
    IN DWORD    dwLevel,
    IN DWORD    dwServiceId,
    IN DWORD    dwInstance,
    OUT PCHAR * pBuffer
    );

//
//  Private prototypes.
//
VOID
CopyStatisticsData(
    IN W3_STATISTICS_1          * pW3Stats,
    OUT W3_COUNTER_BLOCK        * pCounterBlock
    );

VOID
Update_TotalStatisticsData(
    IN W3_COUNTER_BLOCK         * pCounterBlock,
    OUT W3_COUNTER_BLOCK        * pTotal
    );

NET_API_STATUS
NET_API_FUNCTION
InitW3PerfCounters(
	OUT LPDWORD lpcbTotalRequired
	)
/*++

   Description

     Initialize W3 object and counter indexes

   Arguments:

	 lpcbTotalRequired - size of memory needed to retrieve w3 performance data

   Note:

--*/
{
	HANDLE  hEventLog = NULL;   // event log handle
    DWORD err  = NO_ERROR;
    HKEY  hkey = NULL;
    DWORD size;
    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;
    W3_COUNTER_BLOCK   w3c;
    DWORD i;
	DWORD dwNameLength;         // Length of each W3 instance name
	DWORD dwInstanceCount;      // Count of W3 instances
	LPINET_INFO_SITE_LIST  pSites = NULL;// W3 instance info list
	DWORD cbTotalRequired = 0;           // Total memory space needed

	if(!fInitOK)
	{

		// Only initialize W3 counter structure on the first call  

        // open event log interface

        hEventLog = RegisterEventSource (
                     (LPTSTR)NULL, // Use Local Machine
                     APP_NAME // event log app name to find in registry
					);

        if (hEventLog == NULL)
        {
			return GetLastError();
        }        

        //
        //  Open the HTTP Server service's Performance key.
        //

		err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
		                    W3_PERFORMANCE_KEY,
                            0,
                            KEY_READ,
                            &hkey );

        if( err == NO_ERROR)
        {
        //
        //  Read the first counter DWORD.
        //
        
		    size = sizeof(DWORD);

			err = RegQueryValueEx( hkey,
				                   "First Counter",
					               NULL,
						           &type,
							       (LPBYTE)&dwFirstCounter,
								   &size );
			if( err == NO_ERROR )
			{
				//
				//  Read the first help DWORD.
				//

				size = sizeof(DWORD);

				err = RegQueryValueEx( hkey,
					                   "First Help",
									   NULL,
                                       &type,
                                       (LPBYTE)&dwFirstHelp,
                                       &size );

				if ( err == NO_ERROR )
				{
					//
                    //  Update the object & counter name & help indicies.
					//

					W3DataDefinition.W3ObjectType.ObjectNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3ObjectType.ObjectHelpTitleIndex
						+= dwFirstHelp;

					W3DataDefinition.W3BytesSent.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3BytesSent.CounterHelpTitleIndex
			            += dwFirstHelp;
				    W3DataDefinition.W3BytesSent.CounterOffset =
					    (DWORD)((LPBYTE)&w3c.BytesSent - (LPBYTE)&w3c);

					W3DataDefinition.W3BytesReceived.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3BytesReceived.CounterHelpTitleIndex
						+= dwFirstHelp;
				    W3DataDefinition.W3BytesReceived.CounterOffset =
					   (DWORD)((LPBYTE)&w3c.BytesReceived - (LPBYTE)&w3c);

					W3DataDefinition.W3BytesTotal.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3BytesTotal.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3BytesTotal.CounterOffset =
						(DWORD)((LPBYTE)&w3c.BytesTotal - (LPBYTE)&w3c);

					W3DataDefinition.W3FilesSent.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3FilesSent.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3FilesSent.CounterOffset =
						(DWORD)((LPBYTE)&w3c.FilesSent - (LPBYTE)&w3c);

					W3DataDefinition.W3FilesSentSec.CounterNameTitleIndex
						+= dwFirstCounter;
			        W3DataDefinition.W3FilesSentSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3FilesSentSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.FilesSentSec - (LPBYTE)&w3c);

					W3DataDefinition.W3FilesReceived.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3FilesReceived.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3FilesReceived.CounterOffset =
						(DWORD)((LPBYTE)&w3c.FilesReceived - (LPBYTE)&w3c);

					W3DataDefinition.W3FilesReceivedSec.CounterNameTitleIndex
						+= dwFirstCounter;
				    W3DataDefinition.W3FilesReceivedSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3FilesReceivedSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.FilesReceivedSec - (LPBYTE)&w3c);

					W3DataDefinition.W3FilesTotal.CounterNameTitleIndex
						+= dwFirstCounter;
				    W3DataDefinition.W3FilesTotal.CounterHelpTitleIndex
					    += dwFirstHelp;
					W3DataDefinition.W3FilesTotal.CounterOffset =
						(DWORD)((LPBYTE)&w3c.FilesTotal - (LPBYTE)&w3c);

					W3DataDefinition.W3FilesSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3FilesSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3FilesSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.FilesSec - (LPBYTE)&w3c);

					W3DataDefinition.W3CurrentAnonymous.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3CurrentAnonymous.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3CurrentAnonymous.CounterOffset =
						(DWORD)((LPBYTE)&w3c.CurrentAnonymous - (LPBYTE)&w3c);

					W3DataDefinition.W3CurrentNonAnonymous.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3CurrentNonAnonymous.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3CurrentNonAnonymous.CounterOffset =
						(DWORD)((LPBYTE)&w3c.CurrentNonAnonymous - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalAnonymous.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalAnonymous.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalAnonymous.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalAnonymous - (LPBYTE)&w3c);

					W3DataDefinition.W3AnonymousUsersSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3AnonymousUsersSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3AnonymousUsersSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.AnonymousUsersSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalNonAnonymous.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalNonAnonymous.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalNonAnonymous.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalNonAnonymous - (LPBYTE)&w3c);

					W3DataDefinition.W3NonAnonymousUsersSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3NonAnonymousUsersSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3NonAnonymousUsersSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.NonAnonymousUsersSec - (LPBYTE)&w3c);

					W3DataDefinition.W3MaxAnonymous.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3MaxAnonymous.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3MaxAnonymous.CounterOffset =
						(DWORD)((LPBYTE)&w3c.MaxAnonymous - (LPBYTE)&w3c);

					W3DataDefinition.W3MaxNonAnonymous.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3MaxNonAnonymous.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3MaxNonAnonymous.CounterOffset =
						(DWORD)((LPBYTE)&w3c.MaxNonAnonymous - (LPBYTE)&w3c);

					W3DataDefinition.W3CurrentConnections.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3CurrentConnections.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3CurrentConnections.CounterOffset =
						(DWORD)((LPBYTE)&w3c.CurrentConnections - (LPBYTE)&w3c);

					W3DataDefinition.W3MaxConnections.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3MaxConnections.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3MaxConnections.CounterOffset =
						(DWORD)((LPBYTE)&w3c.MaxConnections - (LPBYTE)&w3c);

					W3DataDefinition.W3ConnectionAttempts.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3ConnectionAttempts.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3ConnectionAttempts.CounterOffset =
						(DWORD)((LPBYTE)&w3c.ConnectionAttempts - (LPBYTE)&w3c);

					W3DataDefinition.W3ConnectionAttemptsSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3ConnectionAttemptsSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3ConnectionAttemptsSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.ConnectionAttemptsSec - (LPBYTE)&w3c);

					W3DataDefinition.W3LogonAttempts.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3LogonAttempts.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3LogonAttempts.CounterOffset =
						(DWORD)((LPBYTE)&w3c.LogonAttempts - (LPBYTE)&w3c);

					W3DataDefinition.W3LogonAttemptsSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3LogonAttemptsSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3LogonAttemptsSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.LogonAttemptsSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalOptions.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalOptions.CounterHelpTitleIndex
                    += dwFirstHelp;
					W3DataDefinition.W3TotalOptions.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalOptions - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalOptionsSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalOptionsSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalOptionsSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalOptionsSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalGets.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalGets.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalGets.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalGets - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalGetsSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalGetsSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalGetsSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalGetsSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalPosts.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalPosts.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalPosts.CounterOffset =
					    (DWORD)((LPBYTE)&w3c.TotalPosts - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalPostsSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalPostsSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalPostsSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalPostsSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalHeads.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalHeads.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalHeads.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalHeads - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalHeadsSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalHeadsSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalHeadsSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalHeadsSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalPuts.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalPuts.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalPuts.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalPuts - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalPutsSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalPutsSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalPutsSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalPutsSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalDeletes.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalDeletes.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalDeletes.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalDeletes - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalDeletesSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalDeletesSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalDeletesSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalDeletesSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalTraces.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalTraces.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalTraces.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalTraces - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalTracesSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalTracesSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalTracesSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalTraces - (LPBYTE)&w3c);
                    
					W3DataDefinition.W3TotalMove.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalMove.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalMove.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalMove - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalMoveSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalMoveSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalMoveSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalMoveSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalCopy.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalCopy.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalCopy.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalCopy - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalCopySec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalCopySec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalCopySec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalCopySec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalMkcol.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalMkcol.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalMkcol.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalMkcol - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalMkcolSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalMkcolSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalMkcolSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalMkcolSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalPropfind.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalPropfind.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalPropfind.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalPropfind - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalPropfindSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalPropfindSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalPropfindSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalPropfindSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalProppatch.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalProppatch.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalProppatch.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalProppatch - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalProppatchSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalProppatchSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalProppatchSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalProppatchSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalSearch.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalSearch.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalSearch.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalSearch - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalSearchSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalSearchSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalSearchSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalSearchSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalLock.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalLock.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalLock.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalLock - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalLockSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalLockSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalLockSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalLockSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalUnlock.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalUnlock.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalUnlock.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalUnlock - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalUnlockSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalUnlockSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalUnlockSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalUnlockSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalOthers.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalOthers.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalOthers.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalOthers - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalOthersSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalOthersSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalOthersSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalOthersSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalRequests.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalRequests.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalRequests.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalRequests - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalRequestsSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalRequestsSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalRequestsSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalRequestsSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalCGIRequests.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalCGIRequests.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalCGIRequests.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalCGIRequests - (LPBYTE)&w3c);

					W3DataDefinition.W3CGIRequestsSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3CGIRequestsSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3CGIRequestsSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.CGIRequestsSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalBGIRequests.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalBGIRequests.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalBGIRequests.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalBGIRequests - (LPBYTE)&w3c);

					W3DataDefinition.W3BGIRequestsSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3BGIRequestsSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3BGIRequestsSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.BGIRequestsSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalNotFoundErrors.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalNotFoundErrors.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalNotFoundErrors.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalNotFoundErrors - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalNotFoundErrorsSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalNotFoundErrorsSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalNotFoundErrorsSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalNotFoundErrorsSec - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalLockedErrors.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalLockedErrors.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalLockedErrors.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalLockedErrors - (LPBYTE)&w3c);

					W3DataDefinition.W3TotalLockedErrorsSec.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3TotalLockedErrorsSec.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3TotalLockedErrorsSec.CounterOffset =
						(DWORD)((LPBYTE)&w3c.TotalLockedErrorsSec - (LPBYTE)&w3c);

					W3DataDefinition.W3CurrentCGIRequests.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3CurrentCGIRequests.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3CurrentCGIRequests.CounterOffset =
						(DWORD)((LPBYTE)&w3c.CurrentCGIRequests - (LPBYTE)&w3c);

					W3DataDefinition.W3CurrentBGIRequests.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3CurrentBGIRequests.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3CurrentBGIRequests.CounterOffset =
						(DWORD)((LPBYTE)&w3c.CurrentBGIRequests - (LPBYTE)&w3c);

					W3DataDefinition.W3MaxCGIRequests.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3MaxCGIRequests.CounterHelpTitleIndex
                    += dwFirstHelp;
					W3DataDefinition.W3MaxCGIRequests.CounterOffset =
						(DWORD)((LPBYTE)&w3c.MaxCGIRequests - (LPBYTE)&w3c);

					W3DataDefinition.W3MaxBGIRequests.CounterNameTitleIndex
						+= dwFirstCounter;
					W3DataDefinition.W3MaxBGIRequests.CounterHelpTitleIndex
						+= dwFirstHelp;
					W3DataDefinition.W3MaxBGIRequests.CounterOffset =
						(DWORD)((LPBYTE)&w3c.MaxBGIRequests - (LPBYTE)&w3c);

#if defined(CAL_ENABLED)
                    W3DataDefinition.W3CurrentCalAuth.CounterNameTitleIndex
                        += dwFirstCounter;
                    W3DataDefinition.W3CurrentCalAuth.CounterHelpTitleIndex
                        += dwFirstHelp;
                    W3DataDefinition.W3CurrentCalAuth.CounterOffset =
                        (DWORD)((LPBYTE)&w3c.CurrentCalAuth - (LPBYTE)&w3c);

                    W3DataDefinition.W3MaxCalAuth.CounterNameTitleIndex
                        += dwFirstCounter;
                    W3DataDefinition.W3MaxCalAuth.CounterHelpTitleIndex
                        += dwFirstHelp;
                    W3DataDefinition.W3MaxCalAuth.CounterOffset =
                        (DWORD)((LPBYTE)&w3c.MaxCalAuth - (LPBYTE)&w3c);

                    W3DataDefinition.W3TotalFailedCalAuth.CounterNameTitleIndex
                        += dwFirstCounter;
                    W3DataDefinition.W3TotalFailedCalAuth.CounterHelpTitleIndex
                        += dwFirstHelp;
                    W3DataDefinition.W3TotalFailedCalAuth.CounterOffset =
                        (DWORD)((LPBYTE)&w3c.TotalFailedCalAuth - (LPBYTE)&w3c);

                    W3DataDefinition.W3CurrentCalSsl.CounterNameTitleIndex
                        += dwFirstCounter;
                    W3DataDefinition.W3CurrentCalSsl.CounterHelpTitleIndex
                        += dwFirstHelp;
                    W3DataDefinition.W3CurrentCalSsl.CounterOffset =
                        (DWORD)((LPBYTE)&w3c.CurrentCalSsl - (LPBYTE)&w3c);

                    W3DataDefinition.W3MaxCalSsl.CounterNameTitleIndex
                        += dwFirstCounter;
                    W3DataDefinition.W3MaxCalSsl.CounterHelpTitleIndex
                        += dwFirstHelp;
                    W3DataDefinition.W3MaxCalSsl.CounterOffset =
                        (DWORD)((LPBYTE)&w3c.MaxCalSsl - (LPBYTE)&w3c);

                    W3DataDefinition.W3TotalFailedCalSsl.CounterNameTitleIndex
                        += dwFirstCounter;
                    W3DataDefinition.W3TotalFailedCalSsl.CounterHelpTitleIndex
                        += dwFirstHelp;
                    W3DataDefinition.W3TotalFailedCalSsl.CounterOffset =
                        (DWORD)((LPBYTE)&w3c.TotalFailedCalSsl - (LPBYTE)&w3c);
#endif

                    W3DataDefinition.W3BlockedRequests.CounterNameTitleIndex
                        += dwFirstCounter;
                    W3DataDefinition.W3BlockedRequests.CounterHelpTitleIndex
                        += dwFirstHelp;
                    W3DataDefinition.W3BlockedRequests.CounterOffset =
                        (DWORD)((LPBYTE)&w3c.BlockedRequests - (LPBYTE)&w3c);

                    W3DataDefinition.W3AllowedRequests.CounterNameTitleIndex
                        += dwFirstCounter;
                    W3DataDefinition.W3AllowedRequests.CounterHelpTitleIndex
                        += dwFirstHelp;
                    W3DataDefinition.W3AllowedRequests.CounterOffset =
                        (DWORD)((LPBYTE)&w3c.AllowedRequests - (LPBYTE)&w3c);

                    W3DataDefinition.W3RejectedRequests.CounterNameTitleIndex
                        += dwFirstCounter;
                    W3DataDefinition.W3RejectedRequests.CounterHelpTitleIndex
                        += dwFirstHelp;
                    W3DataDefinition.W3RejectedRequests.CounterOffset =
                        (DWORD)((LPBYTE)&w3c.RejectedRequests - (LPBYTE)&w3c);

                    W3DataDefinition.W3CurrentBlockedRequests.CounterNameTitleIndex
                        += dwFirstCounter;
                    W3DataDefinition.W3CurrentBlockedRequests.CounterHelpTitleIndex
                        += dwFirstHelp;
                    W3DataDefinition.W3CurrentBlockedRequests.CounterOffset =
                        (DWORD)((LPBYTE)&w3c.CurrentBlockedRequests - (LPBYTE)&w3c);

                    W3DataDefinition.W3MeasuredBandwidth.CounterNameTitleIndex
                        += dwFirstCounter;
                    W3DataDefinition.W3MeasuredBandwidth.CounterHelpTitleIndex
                        += dwFirstHelp;
                    W3DataDefinition.W3MeasuredBandwidth.CounterOffset =
                        (DWORD)((LPBYTE)&w3c.MeasuredBandwidth - (LPBYTE)&w3c);

                    W3DataDefinition.W3ServiceUptime.CounterNameTitleIndex
                        += dwFirstCounter;
                    W3DataDefinition.W3ServiceUptime.CounterHelpTitleIndex
                        += dwFirstHelp;
                    W3DataDefinition.W3ServiceUptime.CounterOffset =
                        (DWORD)((LPBYTE)&w3c.ServiceUptime - (LPBYTE)&w3c);

					fInitOK = TRUE;

                }
				
				else 
				{
                    ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                                 0, W3_UNABLE_READ_FIRST_HELP,
                                 (PSID)NULL, 0,
                                 sizeof(err), NULL,
                                 (PVOID)(&err));
                }
            } 
			
			else 
			{
                ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                             0, W3_UNABLE_READ_FIRST_COUNTER,
                             (PSID)NULL, 0,
                             sizeof(err), NULL,
                             (PVOID)(&err));
            } 

            //
            //  Close the registry if we managed to actually open it.
            //

            if( hkey != NULL )
            {
                RegCloseKey( hkey );
                hkey = NULL;
            }
		}
		else 
		{
            ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                         0, W3_UNABLE_OPEN_W3SVC_PERF_KEY,
                         (PSID)NULL, 0,
                         sizeof(err), NULL,
                         (PVOID)(&err));
        }

		DeregisterEventSource (hEventLog);
	}

	//
	// Enumerate and get total number of instance count
	//

	IIS_SERVICE::GetServiceSiteInfo (
							        INET_HTTP_SVC_ID,
									&pSites
									);

	if( pSites == NULL)
	{
		*lpcbTotalRequired = 0;
		return err;		
	}

	//
	// Add 1 to dwInstanceCount for _Total instance
	//
	
	dwInstanceCount = pSites->cEntries + 1;

	//
	// Get the size of memory required for retrieving W3 perf data
	//

	// Reserve space for W3 perf data except instance names

	cbTotalRequired = sizeof(W3_DATA_DEFINITION) + 
					  MAX_SIZEOF_INSTANCE_NAME +  
					  dwInstanceCount *
		                  (sizeof(PERF_INSTANCE_DEFINITION) +
						   sizeof(W3_COUNTER_BLOCK));

	// Reserve more space for all instance names
		
	for(i=0; i != pSites->cEntries; i++)
	{
		cbTotalRequired += QWORD_MULTIPLE(
			(lstrlenW(pSites->aSiteEntry[i].pszComment) + 1) 
			* sizeof(WCHAR)
			);
		midl_user_free(pSites->aSiteEntry[i].pszComment);
	}
        
    midl_user_free(pSites);
		
	*lpcbTotalRequired = cbTotalRequired;

	return err;
}

NET_API_STATUS
NET_API_FUNCTION
CollectW3PerfCounters( LPWSTR    lpValueName,
                       LPBYTE  * lppData,
                       LPDWORD   lpcbTotalBytes,
                       LPDWORD   lpNumObjectTypes 
					 )
/*++

   Description

     Collect W3 perfomance data

   Arguments:

	 lpValueName - counter object name to be retrieved
	 lppData - will hold the returned W3 performance data
	 lpcbTotalBytes - total bytes of W3 performance data returned
	 lpNumobjectTypes - number of object types returned

   Note:

--*/
{
    PERF_INSTANCE_DEFINITION * pPerfInstanceDefinition;
    DWORD                   dwInstanceCount = 0;
    DWORD                   i = 0;
    DWORD                   dwQueryType;
    W3_COUNTER_BLOCK        * pCounterBlock;
    W3_COUNTER_BLOCK        * pTotal;
    W3_DATA_DEFINITION      * pW3DataDefinition;
    W3_STATISTICS_1         * pW3Stats;
	PCHAR                   buffer;
	LPINET_INFO_SITE_LIST   pSites = NULL;     // W3 instance info list
    DWORD                   cbTotalRequired = 0;
    DWORD                   dwErr;
    
    //
    //  Determine the query type.
    //

    dwQueryType = GetQueryType( lpValueName );

    if (( dwQueryType == QUERY_FOREIGN ) || (dwQueryType == QUERY_COSTLY))
    {
		// We don't do foreign queries
		
		*lpcbTotalBytes = 0;
		*lpNumObjectTypes = 0;

        return ERROR_SUCCESS;
    }

    if( dwQueryType == QUERY_ITEMS )
    {
        //
        //  The registry is asking for a specific object.  Let's
        //  see if we're one of the chosen.
        //

        if( !IsNumberInUnicodeList(
                        W3DataDefinition.W3ObjectType.ObjectNameTitleIndex,
                        lpValueName ) )
        {
            //
            // this can be due to IIS restart
            // so we need to try to init counters
            //

            InitW3PerfCounters(&cbTotalRequired);

            //
            // try again
            //
            if( !IsNumberInUnicodeList(
                            W3DataDefinition.W3ObjectType.ObjectNameTitleIndex,
                            lpValueName ) )
            {
            
			    *lpcbTotalBytes = 0;
			    *lpNumObjectTypes = 0;

                return ERROR_SUCCESS;
            }
        }
    }

	//
	// Enumerate and get total number of instance count
	//

	IIS_SERVICE::GetServiceSiteInfo (
							        INET_HTTP_SVC_ID,
									&pSites
									);

	if( pSites == NULL )
    {
		*lpcbTotalBytes = 0;
		*lpNumObjectTypes = 0;

        return ERROR_SUCCESS;
    }

    // Calculate the necessary size
    dwErr = InitW3PerfCounters(&cbTotalRequired);

    if ( dwErr != ERROR_SUCCESS )
    {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;

        return dwErr;
    }

    // Check the buffer size
    if ( *lpcbTotalBytes < cbTotalRequired )
    {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;

        return ERROR_INSUFFICIENT_BUFFER;
    }

	//
	// Add 1 to dwInstanceCount for _Total instance
	//
	
	dwInstanceCount = pSites->cEntries + 1;

    pW3DataDefinition = (W3_DATA_DEFINITION *)(*lppData);

    //
    //  Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    memmove( pW3DataDefinition,
             &W3DataDefinition,
             sizeof(W3_DATA_DEFINITION) );

    //
    //  Create data for return for each instance
    //

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  &pW3DataDefinition[1];

    //
    // Set first block of Buffer for _Total
    //

    MonBuildInstanceDefinition(
        pPerfInstanceDefinition,
        (PVOID *)&pCounterBlock,
        0,
        0,
        (DWORD)-1, // use name
        TOTAL_INSTANCE_NAME );   // pass in instance name

    pTotal = pCounterBlock;
    memset( pTotal, 0, sizeof(W3_COUNTER_BLOCK ));
    pTotal->PerfCounterBlock.ByteLength = sizeof (W3_COUNTER_BLOCK);
    pPerfInstanceDefinition =
        (PERF_INSTANCE_DEFINITION *)((LPBYTE)pCounterBlock +
         sizeof(W3_COUNTER_BLOCK));

#if defined(CAL_ENABLED)
    //
    // query for Global statistics info
    //

	GetStatistics( 0,
                   INET_HTTP_SVC_ID,
                   0,
                   &buffer
                 );

    pW3Stats = (LPW3_STATISTICS_1)buffer;

    CopyStatisticsData( pW3Stats,
                        pTotal );

	MIDL_user_free( pW3Stats );

#endif

    //
    // query for Global statistics info
    //
	GetStatistics( 0,
                   INET_HTTP_SVC_ID,
                   0,
                   &buffer
                 );

    pW3Stats = (LPW3_STATISTICS_1)buffer;

    pTotal->ServiceUptime = pW3Stats->ServiceUptime;

    MIDL_user_free( pW3Stats );

    //
    //  Try to retrieve the data for each instance.
    //

    for ( i=0; i != pSites->cEntries; i++)
    {
        MonBuildInstanceDefinition(
            pPerfInstanceDefinition,
            (PVOID *)&pCounterBlock,
            0,
            0,
            (DWORD)-1, // use name
            pSites->aSiteEntry[i].pszComment // pass in instance name
            );

		midl_user_free(pSites->aSiteEntry[i].pszComment);
        
        //
        // query for statistics info
        //

		GetStatistics( 0,
		               INET_HTTP_SVC_ID,
			           pSites->aSiteEntry[i].dwInstance,
				       &buffer
					 );

		pW3Stats = (LPW3_STATISTICS_1)buffer;

        //
        //  Format the W3 Server data.
        //

        CopyStatisticsData( pW3Stats,
                            pCounterBlock );

        //
        //  Free the API buffer.
        //

        MIDL_user_free( pW3Stats );

        //
        //  update _Total instance counters
        //

        Update_TotalStatisticsData( pCounterBlock,
                                    pTotal );

        pPerfInstanceDefinition =
            (PERF_INSTANCE_DEFINITION *)((LPBYTE)pCounterBlock +
             sizeof(W3_COUNTER_BLOCK));
    }

    midl_user_free(pSites);

    if (dwInstanceCount == 1) {

        //
        //  zero fill one instance sized block of data if there's no data
        //  instances
        //

        memset (pPerfInstanceDefinition, 0,
            (sizeof(PERF_INSTANCE_DEFINITION) +
            MAX_SIZEOF_INSTANCE_NAME +
            sizeof(W3_COUNTER_BLOCK)));

        // adjust pointer to point to end of zeroed block
        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                    ((BYTE *)pPerfInstanceDefinition + 
                                     (sizeof(PERF_INSTANCE_DEFINITION) +
                                      MAX_SIZEOF_INSTANCE_NAME +
                                      sizeof(W3_COUNTER_BLOCK) ));
    }

    //
    //  Update arguments for return.
    //

    *lpNumObjectTypes = 1;

    pW3DataDefinition->W3ObjectType.NumInstances = dwInstanceCount;

    pW3DataDefinition->W3ObjectType.TotalByteLength =
        *lpcbTotalBytes   = QWORD_MULTIPLE(DIFF((PBYTE)pPerfInstanceDefinition -
                                                (PBYTE)pW3DataDefinition));
    
    return ERROR_SUCCESS;

}   // CollectW3PerformanceData

VOID
CopyStatisticsData(
    IN W3_STATISTICS_1          * pW3Stats,
    OUT W3_COUNTER_BLOCK        * pCounterBlock
    )
{
    //
    //  Format the W3 Server data.
    //

    pCounterBlock->PerfCounterBlock.ByteLength = sizeof (W3_COUNTER_BLOCK);

    pCounterBlock->BytesSent        = pW3Stats->TotalBytesSent.QuadPart;
    pCounterBlock->BytesReceived    = pW3Stats->TotalBytesReceived.QuadPart;
    pCounterBlock->BytesTotal       = pW3Stats->TotalBytesSent.QuadPart +
                                      pW3Stats->TotalBytesReceived.QuadPart;

    pCounterBlock->FilesSent        =
        pCounterBlock->FilesSentSec = pW3Stats->TotalFilesSent;
    pCounterBlock->FilesReceived    =
        pCounterBlock->FilesReceivedSec = pW3Stats->TotalFilesReceived;
    pCounterBlock->FilesTotal       =
        pCounterBlock->FilesSec     = pW3Stats->TotalFilesSent +
                                   pW3Stats->TotalFilesReceived;

    pCounterBlock->CurrentAnonymous = pW3Stats->CurrentAnonymousUsers;
    pCounterBlock->CurrentNonAnonymous = pW3Stats->CurrentNonAnonymousUsers;

    pCounterBlock->TotalAnonymous   =
        pCounterBlock->AnonymousUsersSec= pW3Stats->TotalAnonymousUsers;
    pCounterBlock->TotalNonAnonymous =
        pCounterBlock->NonAnonymousUsersSec = pW3Stats->TotalNonAnonymousUsers;

    pCounterBlock->MaxAnonymous     = pW3Stats->MaxAnonymousUsers;
    pCounterBlock->MaxNonAnonymous  = pW3Stats->MaxNonAnonymousUsers;

    pCounterBlock->CurrentConnections = pW3Stats->CurrentConnections;
    pCounterBlock->MaxConnections   = pW3Stats->MaxConnections;
    pCounterBlock->ConnectionAttempts =
        pCounterBlock->ConnectionAttemptsSec = pW3Stats->ConnectionAttempts;

    pCounterBlock->LogonAttempts    =
        pCounterBlock->LogonAttemptsSec = pW3Stats->LogonAttempts;

    pCounterBlock->TotalOptions     =
        pCounterBlock->TotalOptionsSec = pW3Stats->TotalOptions;
    pCounterBlock->TotalGets        =
        pCounterBlock->TotalGetsSec = pW3Stats->TotalGets;
    pCounterBlock->TotalPosts       =
        pCounterBlock->TotalPostsSec = pW3Stats->TotalPosts;
    pCounterBlock->TotalHeads       =
        pCounterBlock->TotalHeadsSec = pW3Stats->TotalHeads;
    pCounterBlock->TotalPuts        =
        pCounterBlock->TotalPutsSec = pW3Stats->TotalPuts;
    pCounterBlock->TotalDeletes     =
        pCounterBlock->TotalDeletesSec = pW3Stats->TotalDeletes;
    pCounterBlock->TotalTraces      =
        pCounterBlock->TotalTracesSec = pW3Stats->TotalTraces;
    pCounterBlock->TotalMove        =
        pCounterBlock->TotalMoveSec = pW3Stats->TotalMove;
    pCounterBlock->TotalCopy        =
        pCounterBlock->TotalCopySec = pW3Stats->TotalCopy;
    pCounterBlock->TotalMkcol       =
        pCounterBlock->TotalMkcolSec = pW3Stats->TotalMkcol;
    pCounterBlock->TotalPropfind    =
        pCounterBlock->TotalPropfindSec = pW3Stats->TotalPropfind;
    pCounterBlock->TotalProppatch    =
        pCounterBlock->TotalProppatchSec = pW3Stats->TotalProppatch;
    pCounterBlock->TotalSearch       =
        pCounterBlock->TotalSearchSec = pW3Stats->TotalSearch;
    pCounterBlock->TotalLock         =
        pCounterBlock->TotalLockSec = pW3Stats->TotalLock;
    pCounterBlock->TotalUnlock       =
        pCounterBlock->TotalUnlockSec = pW3Stats->TotalUnlock;
    pCounterBlock->TotalOthers      =
        pCounterBlock->TotalOthersSec = pW3Stats->TotalOthers;
    pCounterBlock->TotalRequests    =
        pCounterBlock->TotalRequestsSec = pW3Stats->TotalOptions +
                                       pW3Stats->TotalGets +
                                       pW3Stats->TotalPosts +
                                       pW3Stats->TotalHeads +
                                       pW3Stats->TotalPuts +
                                       pW3Stats->TotalDeletes +
                                       pW3Stats->TotalTraces +
                                       pW3Stats->TotalMove +
                                       pW3Stats->TotalCopy +
                                       pW3Stats->TotalMkcol +
                                       pW3Stats->TotalPropfind +
                                       pW3Stats->TotalProppatch +
                                       pW3Stats->TotalSearch +
                                       pW3Stats->TotalLock +
                                       pW3Stats->TotalUnlock +
                                       pW3Stats->TotalOthers;

    pCounterBlock->TotalCGIRequests =
        pCounterBlock->CGIRequestsSec = pW3Stats->TotalCGIRequests;
    pCounterBlock->TotalBGIRequests =
        pCounterBlock->BGIRequestsSec = pW3Stats->TotalBGIRequests;

    pCounterBlock->TotalNotFoundErrors =
        pCounterBlock->TotalNotFoundErrorsSec = pW3Stats->TotalNotFoundErrors;

    pCounterBlock->TotalLockedErrors =
        pCounterBlock->TotalLockedErrorsSec = pW3Stats->TotalLockedErrors;

    pCounterBlock->CurrentCGIRequests = pW3Stats->CurrentCGIRequests;
    pCounterBlock->CurrentBGIRequests = pW3Stats->CurrentBGIRequests;
    pCounterBlock->MaxCGIRequests   = pW3Stats->MaxCGIRequests;
    pCounterBlock->MaxBGIRequests   = pW3Stats->MaxBGIRequests;

#if defined(CAL_ENABLED)
    pCounterBlock->CurrentCalAuth   = pW3Stats->CurrentCalAuth;
    pCounterBlock->MaxCalAuth       = pW3Stats->MaxCalAuth;
    pCounterBlock->TotalFailedCalAuth = pW3Stats->TotalFailedCalAuth;
    pCounterBlock->CurrentCalSsl    = pW3Stats->CurrentCalSsl;
    pCounterBlock->MaxCalSsl        = pW3Stats->MaxCalSsl;
    pCounterBlock->TotalFailedCalSsl  = pW3Stats->TotalFailedCalSsl;
#endif

    pCounterBlock->BlockedRequests  = pW3Stats->TotalBlockedRequests;
    pCounterBlock->AllowedRequests  = pW3Stats->TotalAllowedRequests;
    pCounterBlock->RejectedRequests = pW3Stats->TotalRejectedRequests;
    pCounterBlock->MeasuredBandwidth= pW3Stats->MeasuredBw;
    pCounterBlock->CurrentBlockedRequests = pW3Stats->CurrentBlockedRequests;
    pCounterBlock->ServiceUptime = pW3Stats->ServiceUptime;
}   // CopyStatisticsData


VOID
Update_TotalStatisticsData(
    IN W3_COUNTER_BLOCK         * pCounterBlock,
    OUT W3_COUNTER_BLOCK        * pTotal
    )
{
    //
    //  update _total instance counters
    //

    pTotal->BytesSent += pCounterBlock->BytesSent;
    pTotal->BytesReceived += pCounterBlock->BytesReceived;
    pTotal->BytesTotal += pCounterBlock->BytesTotal;

    pTotal->FilesSent += pCounterBlock->FilesSent;
    pTotal->FilesSentSec = pTotal->FilesSent;
    pTotal->FilesReceived += pCounterBlock->FilesReceived;
    pTotal->FilesReceivedSec = pTotal->FilesReceived;
    pTotal->FilesTotal += pCounterBlock->FilesTotal;
    pTotal->FilesSec = pTotal->FilesTotal;
    pTotal->CurrentAnonymous += pCounterBlock->CurrentAnonymous;
    pTotal->CurrentNonAnonymous += pCounterBlock->CurrentNonAnonymous;
    pTotal->TotalAnonymous += pCounterBlock->TotalAnonymous;
    pTotal->AnonymousUsersSec += pCounterBlock->AnonymousUsersSec;
    pTotal->TotalNonAnonymous += pCounterBlock->TotalNonAnonymous;
    pTotal->NonAnonymousUsersSec += pCounterBlock->NonAnonymousUsersSec;

    pTotal->MaxAnonymous += pCounterBlock->MaxAnonymous;
    pTotal->MaxNonAnonymous += pCounterBlock->MaxNonAnonymous;

    pTotal->CurrentConnections = pCounterBlock->CurrentConnections;
    pTotal->MaxConnections = pCounterBlock->MaxConnections;
    pTotal->ConnectionAttempts = pCounterBlock->ConnectionAttempts;
    pTotal->ConnectionAttemptsSec = pCounterBlock->ConnectionAttemptsSec;

    pTotal->LogonAttempts += pCounterBlock->LogonAttempts;
    pTotal->LogonAttemptsSec += pCounterBlock->LogonAttemptsSec;

    pTotal->TotalOptions += pCounterBlock->TotalOptions;
    pTotal->TotalOptionsSec += pCounterBlock->TotalOptionsSec;
    pTotal->TotalGets += pCounterBlock->TotalGets;
    pTotal->TotalGetsSec += pCounterBlock->TotalGetsSec;
    pTotal->TotalPosts += pCounterBlock->TotalPosts;
    pTotal->TotalPostsSec += pCounterBlock->TotalPostsSec;
    pTotal->TotalHeads += pCounterBlock->TotalHeads;
    pTotal->TotalHeadsSec += pCounterBlock->TotalHeadsSec;

    pTotal->TotalPuts += pCounterBlock->TotalPuts;
    pTotal->TotalPutsSec += pCounterBlock->TotalPutsSec;
    pTotal->TotalDeletes += pCounterBlock->TotalDeletes;
    pTotal->TotalDeletesSec += pCounterBlock->TotalDeletesSec;
    pTotal->TotalTraces += pCounterBlock->TotalTraces;
    pTotal->TotalTracesSec += pCounterBlock->TotalTracesSec;
    pTotal->TotalMove += pCounterBlock->TotalMove;
    pTotal->TotalMoveSec += pCounterBlock->TotalMoveSec;
    pTotal->TotalCopy += pCounterBlock->TotalCopy;
    pTotal->TotalCopySec += pCounterBlock->TotalCopySec;
    pTotal->TotalMkcol += pCounterBlock->TotalMkcol;
    pTotal->TotalMkcolSec += pCounterBlock->TotalMkcolSec;
    pTotal->TotalPropfind += pCounterBlock->TotalPropfind;
    pTotal->TotalPropfindSec += pCounterBlock->TotalPropfindSec;
    pTotal->TotalProppatch += pCounterBlock->TotalProppatch;
    pTotal->TotalProppatchSec += pCounterBlock->TotalProppatchSec;
    pTotal->TotalSearch += pCounterBlock->TotalSearch;
    pTotal->TotalSearchSec += pCounterBlock->TotalSearchSec;
    pTotal->TotalLock += pCounterBlock->TotalLock;
    pTotal->TotalLockSec += pCounterBlock->TotalLockSec;
    pTotal->TotalUnlock += pCounterBlock->TotalUnlock;
    pTotal->TotalUnlockSec += pCounterBlock->TotalUnlockSec;
    pTotal->TotalOthers += pCounterBlock->TotalOthers;
    pTotal->TotalOthersSec += pCounterBlock->TotalOthersSec;
    pTotal->TotalRequests += pCounterBlock->TotalRequests;
    pTotal->TotalRequestsSec += pCounterBlock->TotalRequestsSec;

    pTotal->TotalCGIRequests += pCounterBlock->TotalCGIRequests;
    pTotal->CGIRequestsSec += pCounterBlock->CGIRequestsSec;
    pTotal->TotalBGIRequests += pCounterBlock->TotalBGIRequests;
    pTotal->BGIRequestsSec += pCounterBlock->BGIRequestsSec;

    pTotal->TotalNotFoundErrors += pCounterBlock->TotalNotFoundErrors;
    pTotal->TotalNotFoundErrorsSec += pCounterBlock->TotalNotFoundErrorsSec;
    pTotal->TotalLockedErrors += pCounterBlock->TotalLockedErrors;
    pTotal->TotalLockedErrorsSec += pCounterBlock->TotalLockedErrorsSec;

    pTotal->CurrentCGIRequests += pCounterBlock->CurrentCGIRequests;
    pTotal->CurrentBGIRequests += pCounterBlock->CurrentBGIRequests;
    pTotal->MaxCGIRequests += pCounterBlock->MaxCGIRequests;
    pTotal->MaxBGIRequests += pCounterBlock->MaxBGIRequests;

#if defined(CAL_ENABLED)
    pTotal->CurrentCalAuth   += pCounterBlock->CurrentCalAuth;
    pTotal->MaxCalAuth       += pCounterBlock->MaxCalAuth;
    pTotal->TotalFailedCalAuth += pCounterBlock->TotalFailedCalAuth;
    pTotal->CurrentCalSsl    += pCounterBlock->CurrentCalSsl;
    pTotal->MaxCalSsl        += pCounterBlock->MaxCalSsl;
    pTotal->TotalFailedCalSsl  += pCounterBlock->TotalFailedCalSsl;
#endif

    pTotal->BlockedRequests += pCounterBlock->BlockedRequests;
    pTotal->RejectedRequests += pCounterBlock->RejectedRequests;
    pTotal->AllowedRequests += pCounterBlock->AllowedRequests;
    pTotal->MeasuredBandwidth += pCounterBlock->MeasuredBandwidth;
    pTotal->CurrentBlockedRequests += pCounterBlock->CurrentBlockedRequests;

}   // Update_TotalStatisticsData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\server\rpcex.cxx ===
/*++
   Copyright    (c)    1994        Microsoft Corporation

   Module Name:
        rpcex.cxx

   Abstract:

        This module contains the server side RPC admin APIs for v3


   Author:

        Johnson Apacible    (johnsona)      06-03-96


--*/

//
//  Include Headers
//

#include <tcpdllp.hxx>
#include <tsunami.hxx>

extern "C" {
#include <info_srv.h>
};

#include <atq.h>
#include "inetreg.h"
#include <iisver.h>


NET_API_STATUS
NET_API_FUNCTION
R_IISSetAdminInformation(
    IN LPWSTR                   pszServer OPTIONAL,
    IN DWORD                    dwLevel,
    IN DWORD                    dwServiceId,
    IN DWORD                    dwInstance,
    IN LPINSTANCE_INFO_STRUCT     InfoStruct
    )
/*++

   Description

     Sets the common service admin information for the servers specified
     in dwServerMask.

   Arguments:

      pszServer - unused
      dwServerMask - Bitfield of servers to set the information for
      pConfig - Admin information to set

   Note:

--*/
{
    DWORD err = NO_ERROR;
    PCHAR buffer;

    IF_DEBUG( DLL_RPC) {

       DBGPRINTF( ( DBG_CONTEXT,
                   " Entering R_IISSetAdminInformation (L%d) for Service %x\n",
                    dwLevel, dwServiceId));
    }


    //
    // We only support 1
    //

    if ( dwLevel != 1 ) {
        return(ERROR_INVALID_LEVEL);
    }

    //
    // Do we have permissions?
    //

    if ( (err = TsApiAccessCheck( TCP_SET_ADMIN_INFORMATION )) != NO_ERROR) {
       IF_DEBUG( DLL_RPC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " TsApiAccessCheck() Failed. Error = %u\n", err));
       }
        return(err);
    }

    //
    //  Loop through the services and set the information for each one
    //

    if ( !IIS_SERVICE::SetServiceAdminInfo(
                            dwLevel,
                            dwServiceId,
                            dwInstance,
                            TRUE,           // common config
                            (PCHAR)InfoStruct->ConfigInfo1
                            )) {

        err =  GetLastError();
        IF_DEBUG( DLL_RPC) {
            DBGPRINTF( ( DBG_CONTEXT,
                        "SetServiceAdminInfo failed. Error = %u\n",
                        err));
        }
    }

    return ( err);

} // IISSetAdminInformation


NET_API_STATUS
NET_API_FUNCTION
R_IISGetAdminInformation(
    IN LPWSTR                   pszServer OPTIONAL,
    IN DWORD                    dwLevel,
    IN DWORD                    dwServiceId,
    IN DWORD                    Instance,
    IN LPINSTANCE_INFO_STRUCT   InfoStruct
    )
/*++

   Description

     Gets the common service admin information for the specified
     server in dwServerMask.

   Arguments:

      pszServer - unused
      dwServerMask - Bitfield of server to get the information for
      pConfig - Receives current operating values of the server

   Note:

--*/
{
    DWORD err = NO_ERROR;
    PCHAR buffer = NULL;
    DWORD nRead = 0;

    IF_DEBUG( DLL_RPC) {

       DBGPRINTF( ( DBG_CONTEXT,
                   " Entering R_IISGetAdminInformation (L%d) for Service %x\n",
                    dwLevel, dwServiceId));
    }

    //
    // We only support 1
    //

    if ( (dwLevel != 1) && (dwLevel != 2) ) {
        return(ERROR_INVALID_LEVEL);
    }

    if ( ( err = TsApiAccessCheck( TCP_QUERY_ADMIN_INFORMATION)) != NO_ERROR) {
       IF_DEBUG( DLL_RPC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " TsApiAccessCheck() Failed. Error = %u\n", err));
       }
       return(err);
    }

    if ( !IIS_SERVICE::GetServiceAdminInfo(
                                   dwLevel,
                                   dwServiceId,
                                   Instance,
                                   TRUE,        // common config
                                   &nRead,
                                   &buffer
                                   )) {

        DBG_ASSERT(buffer == NULL);
        DBG_ASSERT(nRead == 0);

        err = GetLastError();
        DBG_ASSERT(err != NO_ERROR);
        IF_DEBUG( DLL_RPC) {
            DBGPRINTF( ( DBG_CONTEXT,
                        "GetServiceAdminInfo failed. Error = %u\n",
                        err));
        }
    } else {

        DBG_ASSERT(nRead == 1);
        if ( dwLevel == 1 ) {
            InfoStruct->ConfigInfo1 = (LPIIS_INSTANCE_INFO_1)buffer;
        } else {
            InfoStruct->ConfigInfo2 = (LPIIS_INSTANCE_INFO_2)buffer;
        }
    }

    return ( err);

} // R_IISGetAdminInformation




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\authent.cxx ===
#include "..\common\authent.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\test\infotest.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :
        infotest.cxx

   Abstract:
        main program to test the working of RPC APIs for Internet Services

   Author:

           Murali R. Krishnan    ( MuraliK )     23-Jan-1996

   Project:

           Internet Services Common RPC Client.

   Functions Exported:

   Revision History:

--*/

/************************************************************
 *     Include Headers
 ************************************************************/

# include <windows.h>
# include <lm.h>
# include <stdio.h>
# include <stdlib.h>
# include "iisinfo.h"
# include "apiutil.h"

WCHAR Server[255];
DWORD Level = 1;

//
//  From tsunami.hxx
//


void
get( DWORD instance)
{
    DWORD err;

    LPINET_INFO_CONFIG_INFO buffer = NULL;

    err = InetInfoGetAdminInformation( Server,
                                       INET_HTTP_SVC_ID,
                                       &buffer );
    printf("err %d buffer %x\n",err,buffer);
    if ( err == NO_ERROR ) {

        DWORD i;

        printf( "dwConnectionTime =     %8d\n", buffer->dwConnectionTimeout );
        printf( "dwAuthentication =   0x%08x\n", buffer->dwAuthentication );
        printf( "Port             =     %8d\n", (DWORD) buffer->sPort);

        printf("vroot 0x%08x\n",buffer->VirtualRoots);
        printf("vr entries is %d\n",buffer->VirtualRoots->cEntries);

        for (i=0 ; i < buffer->VirtualRoots->cEntries ;i++ ) {
            printf("\nroot %S\n",
                buffer->VirtualRoots->aVirtRootEntry[i].pszRoot);
            printf("directory %S\n",
                buffer->VirtualRoots->aVirtRootEntry[i].pszDirectory);
            printf("account %S\n",
                buffer->VirtualRoots->aVirtRootEntry[i].pszAccountName);
            printf("mask %x\n",
                buffer->VirtualRoots->aVirtRootEntry[i].dwMask);
            printf("error %x\n",
                buffer->VirtualRoots->aVirtRootEntry[i].dwError);

        }

        midl_user_free( buffer );
    }
}

void
getftp( DWORD instance)
{
    DWORD err;
    DWORD numEntries;
    LPIIS_USER_INFO_1 info;
    LPIIS_USER_INFO_1 scan;
    IN_ADDR addr;

    err = IISEnumerateUsers(
              Server,
              1,
              INET_FTP_SVC_ID,
              instance,
              &numEntries,
              (LPBYTE *)&info
              );

    printf( "err %lu, buffer %x\n", err, info );

    if( err == NO_ERROR ) {

        printf( "%lu connected users\n", numEntries );

        for( scan = info ; numEntries > 0 ; numEntries--, scan++ ) {

            addr.s_addr = (u_long)scan->inetHost;

            printf(
                "idUser     = %lu\n"
                "pszUser    = %S\n"
                "fAnonymous = %lu\n"
                "inetHost   = %s\n"
                "tConnect   = %lu\n"
                "\n",
                scan->idUser,
                scan->pszUser,
                scan->fAnonymous,
                inet_ntoa( addr ),
                scan->tConnect
                );

        }

        midl_user_free( info );
        
    }

}

void
getweb( DWORD instance)
{
    printf( "Not supported\n" );
#if 0
    DWORD err;

    if (instance == 0 ) {
        instance = INET_INSTANCE_ROOT;
    }

    if ( Level == 1 )
    {
        W3_CONFIG_INFO_1 * buffer = NULL;
        err = W3GetAdminInformation2(
                                Server,
                                Level,
                                instance,
                                (LPBYTE*)&buffer
                                );


        printf("err %d buffer 0x%08x\n",err,buffer);

        if ( err == NO_ERROR ) {

            printf( "csecCGIScriptTimeout    =   %8d\n", buffer->csecCGIScriptTimeout );
            printf( "csecPoolODBCConnections =   %8d\n", buffer->csecPoolODBCConnections );
            printf( "fCacheISAPIApps         =   %s\n", buffer->fCacheISAPIApps ? "TRUE" : "FALSE" );
            printf( "fUseKeepAlives          =   %s\n", buffer->fUseKeepAlives ? "TRUE" : "FALSE" );
        }
    }
#endif
}

void
set( DWORD instance )
{
    DWORD err;

    LPINET_INFO_CONFIG_INFO buffer = NULL;

    err = InetInfoGetAdminInformation( Server,
                                       INET_HTTP_SVC_ID,
                                       &buffer );

    printf("err %d buffer %x\n",err,buffer);
    if ( err == NO_ERROR ) {
        printf("Port is %d\n",buffer->sPort);
        printf("vroot %x\n",buffer->VirtualRoots);
        printf("vr entries is %d\n",buffer->VirtualRoots->cEntries);
    } else {
        return;
    }

    err = InetInfoSetAdminInformation( Server,
                                       INET_HTTP_SVC_ID,
                                       buffer );

    printf("err %d \n",err);
    if ( err == NO_ERROR ) {
        get(instance);
    }
    midl_user_free( buffer );
}

void
setvr( DWORD instance )
{
#if 1
    printf( "Not supported\n" );
#else
    DWORD err;
    IIS_INSTANCE_INFO_1 newt;

    ZeroMemory(&newt,sizeof(IIS_INSTANCE_INFO_1));

    LPIIS_INSTANCE_INFO_1 buffer = NULL;
    err = IISGetAdminInformation(
                            Server,
                            Level,
                            INET_HTTP_SVC_ID,
                            instance,
                            (LPBYTE*)&buffer
                            );


    printf("err %d buffer %x\n",err,buffer);
    if ( err == NO_ERROR ) {
        printf("Port is %d\n",buffer->sPort);
        printf("vroot %x\n",buffer->VirtualRoots);
        printf("vr entries is %d\n",buffer->VirtualRoots->cEntries);
    } else {
        return;
    }

    newt.FieldControl = FC_INET_INFO_VIRTUAL_ROOTS;
    newt.VirtualRoots = buffer->VirtualRoots;
    buffer->VirtualRoots->aVirtRootEntry[1].pszDirectory = L"d:\\nt40";

    err = IISSetAdminInformation(
                            Server,
                            Level,
                            INET_HTTP_SVC_ID,
                            instance,
                            (LPBYTE)&newt
                            );

    printf("err %d \n",err);
    if ( err == NO_ERROR ) {
        get(instance);
    }
    midl_user_free( buffer );
#endif
}


void
enumer()
{
#if 1
    printf( "Not Supported\n" );
#else
    DWORD err;
    DWORD nRead = 0;
    DWORD i;
    LPIIS_INSTANCE_INFO_2 buffer = NULL;
    LPIIS_INSTANCE_INFO_2 p;

    //
    // set the port
    //

    err = IISEnumerateInstances(
                            Server,
                            Level,
                            INET_HTTP_SVC_ID,
                            &nRead,
                            (LPBYTE*)&buffer
                            );


    printf("err %d read %d buffer %x \n",err,nRead, buffer);
    if ( err == NO_ERROR ) {

        for (i=0,p=buffer; i < nRead;i++,p++ ) {
            printf("instance %d  state %d comment %S\n",
            p->dwInstance, p->dwServerState, p->lpszServerComment);
        }
    }
#endif
}

void
add( PDWORD instance )
{
#if 1
    printf( "not supported\n" );
#else
    DWORD err;
    DWORD nRead = 0;
    LPIIS_INSTANCE_INFO_1 buffer = NULL;
    LPW3_CONFIG_INFO_1 w3Buffer = NULL;

    err = IISGetAdminInformation(
                            Server,
                            Level,
                            INET_HTTP_SVC_ID,
                            INET_INSTANCE_ROOT,
                            (LPBYTE*)&buffer
                            );


    printf("IISGetAdminInfo err %d buffer %x\n",err,buffer);
    if ( err != NO_ERROR ) {
        return;
    }

    printf("password %ws\n",buffer->szAnonPassword);
    printf("instance %x\n",buffer->dwInstance);
    printf("port %x\n",buffer->sPort);
    printf("vroot %x\n",buffer->VirtualRoots);

    if ( buffer->VirtualRoots != NULL ) {
        printf("vr entries is %d\n",buffer->VirtualRoots->cEntries);
    }

    err = W3GetAdminInformation2(
                            Server,
                            Level,
                            INET_INSTANCE_ROOT,
                            (LPBYTE*)&w3Buffer
                            );


    printf("W3GetAdminInfo err %d w3Buffer %x\n",err,w3Buffer);
    if ( err != NO_ERROR ) {
        midl_user_free( buffer );
        return;
    }

    //
    // set the port
    //

    buffer->sPort = 8081;

    err = IISAddInstance(
                        Server,
                        INET_HTTP_SVC_ID,
                        1,
                        (LPBYTE)buffer,
                        1,
                        (LPBYTE)w3Buffer,
                        instance
                        );

    printf("IISAddInstance err %d InstanceId %d\n",err,*instance);
#endif
} // Add instance


void
del( DWORD instance )
{
#if 1
    printf( "not supported\n" );
#else
    DWORD err;

    err = IISDeleteInstance(
                    Server,
                    INET_HTTP_SVC_ID,
                    instance
                    );

    printf("err %d\n",err);
#endif
}

void
ctrl( DWORD instance, DWORD Code )
{
#if 1
    printf(" not supported\n" );
#else
    DWORD err;

    err = IISControlInstance(
                    Server,
                    INET_HTTP_SVC_ID,
                    instance,
                    Code
                    );

    printf("err %d\n",err);
#endif
}

void
flush( DWORD Service )
{
    DWORD err;

    err = InetInfoFlushMemoryCache( NULL, 4 );  // '4' is the webserver
    printf("Flush Memory Cache returned %d\n", err );
}

int __cdecl
main( int argc, char * argv[])
{
    CHAR op;
    DWORD instance;
    DWORD iArg = 1;

    if ( argc < 2 ) {
        printf( "infotest.exe [Server] [add | get | enum | web | ... ] \n" );
        printf( "cacheflush to flush the object cache\n" );
        printf( "only add and get are currently supported\n" );
        return 1;
    }


    if ( *argv[iArg] == '\\' ){
        wsprintfW( Server, L"%S", argv[iArg++] );
    }

    if ( argc > 2 ){
        op = argv[iArg++][0];
        printf("operation %c\n",op);
    }else{
        op = 'e';
    }

    if ( argc > 4 ){
        Level = atoi(argv[iArg+1]);
        printf("Level %d\n", Level);
    } else {
        Level = 1;
    }

    switch (op) {
    case 'a':
        add( &instance );
        break;

    case 'b':
        instance = atoi(argv[iArg]);
        set( instance );
        break;

    case 'v':
        instance = atoi(argv[iArg]);
        setvr( instance );
        break;

    case 'd':
        if ( argc > 2 ) {
            instance = atoi(argv[iArg]);
            printf("instance %d\n",instance);
            del(instance);
        }
        break;

    case 'e':
        enumer();
        break;

    case 'c':
        flush( 0 );
        break;
        

#if 0
    case 's':
        if ( argc > 2 ) {
            instance = atoi(argv[iArg]);
            printf("starting instance %d\n",instance);
            ctrl(instance,IIS_CONTROL_CODE_START);
        }
        break;

    case 'p':
        if ( argc > 2 ) {
            instance = atoi(argv[iArg]);
            printf("instance %d\n",instance);
            ctrl(instance,IIS_CONTROL_CODE_PAUSE);
        }
        break;

    case 'c':
        if ( argc > 2 ) {
            instance = atoi(argv[iArg]);
            printf("instance %d\n",instance);
            ctrl(instance,IIS_CONTROL_CODE_CONTINUE);
        }
        break;

    case 'x':
        if ( argc > 2 ) {
            instance = atoi(argv[iArg]);
            printf("instance %d\n",instance);
            ctrl(instance,IIS_CONTROL_CODE_STOP);
        }
        break;
#endif

    case 'g':
        get(0);
        break;

    case 'w':
        if ( argc > 2 ) {
            instance = atoi(argv[iArg]);
            printf("instance %d\n",instance);
            getweb(instance);
        }
        break;

    case 'f':
        if ( argc > 2 ) {
            instance = atoi(argv[iArg]);
            printf("instance %d\n",instance);
            getftp(instance);
        }
        break;

    default:
        printf( "unknown command\n" );
        break;
    }
    return(0);
} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\capiutil.cxx ===
#include "..\common\capiutil.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\info\server\rpcsupp.cxx ===
/*++
   Copyright    (c)    1994        Microsoft Corporation

   Module Name:
        rpcsupp.cxx

   Abstract:

        This module contains the server side RPC admin APIs


   Author:

        John Ludeman    (johnl)     02-Dec-1994

   Project:

        Internet Servers Common Server DLL

--*/

//
//  Include Headers
//

#include <tcpdllp.hxx>
#include <tsunami.hxx>

extern "C" {
#include <info_srv.h>
};

#include <atq.h>
#include "inetreg.h"
#include <iistypes.hxx>
#include <iiscnfg.h>
#include <imd.h>
#include <inetreg.h>
#include <mb.hxx>

//
// number of capabilities DWORD
//

#define NUM_CAPABILITIES_FLAGS      1



NET_API_STATUS
NET_API_FUNCTION
R_InetInfoGetVersion(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    dwReserved,
    OUT DWORD *  pdwVersion
    )
/*++

   Description

     Returns the version of the TCP server package.  Primarily intended to
     detect downlevel servers for future versions of the admin tool.

   Arguments:

      pszServer - unused
      dwReserved - unused (may eventually indicate an individual server)
      pdwVersion - Receives the major version in the hi-word and the minor
          version in the low word

   Note:

--*/
{
    *pdwVersion = MAKELONG( IIS_VERSION_MAJOR, IIS_VERSION_MINOR );

    return NO_ERROR;
} // R_InetInfoGetVersion



NET_API_STATUS
NET_API_FUNCTION
R_InetInfoGetServerCapabilities(
    IN  LPWSTR   pszServer OPTIONAL,
    IN  DWORD    dwReserved,
    OUT LPINET_INFO_CAPABILITIES_STRUCT *ppCap
    )
/*++

   Description

     Returns the information about the server and its capabilities.

   Arguments:

      pszServer - unused
      dwReserved - unused (may eventually indicate an individual server)
      ppCap - Receives the INET_INFO_CAPABILITIES structure


--*/
{
    DWORD err = NO_ERROR;
    LPINET_INFO_CAPABILITIES_STRUCT pCap;

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF( ( DBG_CONTEXT,
                   " Entering R_InetInfoGetServerCapabilities()\n" ));
    }

    if ( ( err = TsApiAccessCheck( TCP_QUERY_ADMIN_INFORMATION)) != NO_ERROR) {

        IF_DEBUG( DLL_RPC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " TsApiAccessCheck() Failed. Error = %u\n", err));
        }

    } else {

        OSVERSIONINFO verInfo;
        DWORD   bufSize =
                    sizeof(INET_INFO_CAPABILITIES_STRUCT) +
                    NUM_CAPABILITIES_FLAGS * sizeof(INET_INFO_CAP_FLAGS);

        pCap = (LPINET_INFO_CAPABILITIES_STRUCT) MIDL_user_allocate( bufSize );
        *ppCap = pCap;

        if ( pCap == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        ZeroMemory(pCap, bufSize);
        pCap->CapFlags = (LPINET_INFO_CAP_FLAGS)
            ((PCHAR)pCap + sizeof(INET_INFO_CAPABILITIES));

        //
        // Fill in the version and product type
        //

        pCap->CapVersion = 1;
        switch (IISGetPlatformType()) {
        case PtNtServer:
            pCap->ProductType = INET_INFO_PRODUCT_NTSERVER;
            break;
        case PtNtWorkstation:
            pCap->ProductType = INET_INFO_PRODUCT_NTWKSTA;
            break;
        case PtWindows95:
            pCap->ProductType = INET_INFO_PRODUCT_WINDOWS95;
            break;
        default:
            pCap->ProductType = INET_INFO_PRODUCT_UNKNOWN;
        }

        //
        // Fill in GetVersionEx information
        //

        verInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if ( GetVersionEx( &verInfo ) ) {
            pCap->BuildNumber = verInfo.dwBuildNumber;
        } else {
            pCap->BuildNumber = 0;
        }

        pCap->MajorVersion = IIS_VERSION_MAJOR;
        pCap->MinorVersion = IIS_VERSION_MINOR;

        //
        // Fill in the capabilities
        //

        pCap->NumCapFlags = NUM_CAPABILITIES_FLAGS;

        pCap->CapFlags[0].Mask = IIS_CAP1_ALL;

        if ( pCap->ProductType == INET_INFO_PRODUCT_NTSERVER ) {

            //
            //  For downlevel purposes, we take out the multi-instance and virtual
            //  sever support since the downlevel version of the RPC api
            //  doesn't support those concepts.
            //

            pCap->CapFlags[0].Flag = (IIS_CAP1_NTS &
                                    ~(IIS_CAP1_MULTIPLE_INSTANCE | IIS_CAP1_VIRTUAL_SERVER));

        } else {

            pCap->CapFlags[0].Flag = IIS_CAP1_NTW;
        }
    }

    return ( err );

} // R_InetInfoGetServerCapabilities

NET_API_STATUS
NET_API_FUNCTION
R_InetInfoSetGlobalAdminInformation(
    IN  LPWSTR                     pszServer OPTIONAL,
    IN  DWORD                      dwReserved,
    IN  INETA_GLOBAL_CONFIG_INFO * pConfig
    )
/*++

   Description

     Sets the global service admin information

   Arguments:

      pszServer - unused
      dwReserved
      pConfig - Admin information to set

   Note:

--*/
{
    DWORD err;
    HKEY  hkey = NULL;
    HKEY  CacheKey = NULL;
    HKEY  FilterKey = NULL;
    DWORD dwDummy;

    if ( ( err = TsApiAccessCheck( TCP_SET_ADMIN_INFORMATION)) != NO_ERROR) {

       IF_DEBUG( DLL_RPC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " TsApiAccessCheck() Failed. Error = %u\n", err));
       }

       return err;
    }

    err = ERROR_NOT_SUPPORTED;

    return err;
} // R_InetInfoSetGlobalAdminInformation



NET_API_STATUS
NET_API_FUNCTION
R_InetInfoGetGlobalAdminInformation(
    IN  LPWSTR                       pszServer OPTIONAL,
    IN  DWORD                        dwReserved,
    OUT LPINETA_GLOBAL_CONFIG_INFO * ppConfig
    )
/*++

   Description

     Gets the global service admin information

   Arguments:

      pszServer - unused
      dwReserved
      ppConfig - Receives current operating values of the server

   Note:

--*/
{
    DWORD err = NO_ERROR;
    INETA_GLOBAL_CONFIG_INFO * pConfig;

    IF_DEBUG( DLL_RPC) {

        DBGPRINTF( ( DBG_CONTEXT,
                   " Entering R_InetInfoGetGlobalAdminInformation()\n" ));
    }

    if ( ( err = TsApiAccessCheck( TCP_QUERY_ADMIN_INFORMATION)) != NO_ERROR) {

        IF_DEBUG( DLL_RPC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " TsApiAccessCheck() Failed. Error = %u\n", err));
        }

    } else {

        *ppConfig = (INETA_GLOBAL_CONFIG_INFO *) MIDL_user_allocate(
                                        sizeof( INET_INFO_GLOBAL_CONFIG_INFO ));

        if ( !*ppConfig ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        pConfig = *ppConfig;

        memset( pConfig, 0, sizeof( *pConfig ));

        pConfig->FieldControl = FC_GINET_INFO_ALL;

        pConfig->cbMemoryCacheSize = 0;
        pConfig->BandwidthLevel    = (DWORD)AtqGetInfo( AtqBandwidthThrottle);

        if( err != NO_ERROR ) {

            //
            // clean up the allocated memory
            //

            MIDL_user_free( pConfig );

        } else {

            *ppConfig = pConfig;

        }
    }

    IF_DEBUG( DLL_RPC) {

         DBGPRINTF(( DBG_CONTEXT,
                   "R_InetInfoGetGlobalAdminInformation() returns Error = %u \n",
                    err ));
    }

    return ( err );

} // R_InetInfoGetGlobalAdminInformation()




NET_API_STATUS
NET_API_FUNCTION
R_InetInfoSetAdminInformation(
    IN  LPWSTR              pszServer OPTIONAL,
    IN  DWORD               dwServerMask,
    IN  INETA_CONFIG_INFO * pConfig
    )
/*++

   Description

     Sets the common service admin information for the servers specified
     in dwServerMask.

   Arguments:

      pszServer - unused
      dwServerMask - Bitfield of servers to set the information for
      pConfig - Admin information to set

   Note:

--*/
{
    DWORD err;

    LPINET_INFO_VIRTUAL_ROOT_LIST rootList = NULL;

    IF_DEBUG( DLL_RPC) {
        DBGPRINTF( ( DBG_CONTEXT,
              " Entering R_InetInfoSetAdminInformation. Mask %x\n",
              dwServerMask));
    }

    //
    // Do we have permissions?
    //

    if ( (err = TsApiAccessCheck( TCP_SET_ADMIN_INFORMATION )) != NO_ERROR) {
       IF_DEBUG( DLL_RPC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " TsApiAccessCheck() Failed. Error = %u\n", err));
       }
        return(err);
    }

    //
    //  Loop through the services and set the information for each one
    //

    if ( !IIS_SERVICE::SetServiceAdminInfo(
                            1,
                            dwServerMask,
                            1,              // Instance - may be overidden with downlevel instance
                            TRUE,           // common config
                            pConfig
                            )) {

        err =  GetLastError();
        IF_DEBUG( DLL_RPC) {
            DBGPRINTF( ( DBG_CONTEXT,
                        "SetServiceAdminInfo failed. Error = %u\n",
                        err));
        }
    }

    IF_DEBUG( DLL_RPC) {
        DBGPRINTF( ( DBG_CONTEXT,
                   " Leaving R_InetInfoSetAdminInformation.  Err = %d\n",
                   err ));
    }

    return(err);

} // R_InetInfoSetAdminInformation


NET_API_STATUS
NET_API_FUNCTION
R_InetInfoGetAdminInformation(
    IN  LPWSTR                pszServer OPTIONAL,
    IN  DWORD                 dwServerMask,
    OUT LPINETA_CONFIG_INFO * ppConfig
    )
/*++

   Description

     Gets the common service admin information for the specified
     server in dwServerMask.

   Arguments:

      pszServer - unused
      dwServerMask - Bitfield of server to get the information for
      pConfig - Receives current operating values of the server

   Note:

--*/
{
    DWORD err = NO_ERROR;
    DWORD nEntries = 0;
    PCHAR buffer = NULL;
    DWORD nRead = 0;

    IF_DEBUG( DLL_RPC) {
        DBGPRINTF( ( DBG_CONTEXT,
                   " Entering R_InetInfoGetAdminInformation.\n"));
    }

    *ppConfig = NULL;

    //
    // Call the new API
    //

    IF_DEBUG( DLL_RPC) {
        DBGPRINTF( ( DBG_CONTEXT,
              " Entering R_InetInfoGetAdminInformation. Mask %x\n",
              dwServerMask));
    }

    if ( !IIS_SERVICE::GetServiceAdminInfo(
                                   1,
                                   dwServerMask,
                                   1,           // Instance - my get overidden by downlevel instance
                                   TRUE,        // common config
                                   &nRead,
                                   ppConfig
                                   )) {

        DBG_ASSERT(buffer == NULL);
        DBG_ASSERT(nRead == 0);

        err = GetLastError();
        DBG_ASSERT(err != NO_ERROR);
        IF_DEBUG( DLL_RPC) {
            DBGPRINTF( ( DBG_CONTEXT,
                        "GetServiceAdminInfo failed. Error = %u\n",
                        err));
        }
    } else {

        DBG_ASSERT(nRead == 1);
    }

    IF_DEBUG( DLL_RPC) {
        DBGPRINTF( ( DBG_CONTEXT,
                   " Leaving R_InetInfoGetAdminInformation.  Err = %d\n",
                   err ));
    }

    return(err);

} // R_InetInfoGetAdminInformation()



NET_API_STATUS
NET_API_FUNCTION
R_InetInfoGetSites(
    IN  LPWSTR                pszServer OPTIONAL,
    IN  DWORD                 dwServerMask,
    OUT LPINET_INFO_SITE_LIST * ppSites
    )
/*++

   Description

     Gets the list of instances for the specified
     server in dwServerMask.

   Arguments:

      pszServer - unused
      dwServerMask - Bitfield of server to get the information for
      ppSites - Receives current site list

   Note:

--*/
{
    BOOL    fRet = FALSE;
    DWORD   err = NO_ERROR;

    IF_DEBUG( DLL_RPC) {
        DBGPRINTF( ( DBG_CONTEXT,
                   " Entering R_InetInfoGetSites.\n"));
    }

    *ppSites = NULL;

    //
    // Call the new API
    //

    IF_DEBUG( DLL_RPC) {
        DBGPRINTF( ( DBG_CONTEXT,
              " Entering R_InetInfoGetSites. Mask %x\n",
              dwServerMask));
    }

    
    fRet = IIS_SERVICE::GetServiceSiteInfo (
                                dwServerMask,
                                ppSites
                                );
                                
    if (!fRet) {

        err = GetLastError();

        DBG_ASSERT(err != NO_ERROR);
        IF_DEBUG( DLL_RPC) {
            DBGPRINTF( ( DBG_CONTEXT,
                        "GetServiceSiteInfo failed. Error = %u\n",
                        err));
        }
    } 


    IF_DEBUG( DLL_RPC) {
        DBGPRINTF( ( DBG_CONTEXT,
                   " Leaving R_InetInfoGetSiteInformation.  Err = %d\n",
                   err ));
    }

    return(err);

} // R_InetInfoGetSiteInformation()


NET_API_STATUS
NET_API_FUNCTION
R_InetInfoQueryStatistics(
    IN  LPWSTR             pszServer OPTIONAL,
    IN  DWORD              Level,
    IN  DWORD              dwServerMask,
    LPINET_INFO_STATISTICS_INFO StatsInfo
    )
{
    DWORD err;

    err = TsApiAccessCheck( TCP_QUERY_STATISTICS );

    if ( err ) {
        return err;
    }

    switch ( Level ) {

    case 0:
        {
            INET_INFO_STATISTICS_0 * pstats0;
            ATQ_STATISTICS atqStats;

            pstats0 = (INET_INFO_STATISTICS_0 *) MIDL_user_allocate(
                                    sizeof( INET_INFO_STATISTICS_0 ));

            if ( !pstats0 ) {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

#ifndef NO_AUX_PERF
            // init count of counters that are valid
            pstats0->nAuxCounters = 0;

            //
            // IF THERE ARE VALID UNNAMED COUNTERS THAT WE WISH TO TRACK
            // WE SHOULD DO SO HERE........
            // For Future Additions, this comment is added.
            // MuraliK  20-Sept-1995
            //

#endif // NO_AUX_PERF

            if ( !TsCacheQueryStatistics( Level,
                                          dwServerMask,
                                          &pstats0->CacheCtrs ) ||
                !AtqGetStatistics( &atqStats))
            {
                MIDL_user_free( pstats0 );
                err = GetLastError();
            } else {

                // copy Atq Statistics to stats
                INETA_ATQ_STATISTICS * pAtqStats = &pstats0->AtqCtrs;
                pAtqStats->TotalBlockedRequests  = atqStats.cBlockedRequests;
                pAtqStats->TotalAllowedRequests  = atqStats.cAllowedRequests;
                pAtqStats->TotalRejectedRequests = atqStats.cRejectedRequests;
                pAtqStats->CurrentBlockedRequests=
                  atqStats.cCurrentBlockedRequests;
                pAtqStats->MeasuredBandwidth = atqStats.MeasuredBandwidth;

                StatsInfo->InetStats0 = pstats0;
            }
        }
        break;

    default:
        err = ERROR_INVALID_LEVEL;
        break;
    }

    return err;
}




NET_API_STATUS
NET_API_FUNCTION
R_InetInfoClearStatistics(
    IN  LPWSTR pszServer OPTIONAL,
    IN  DWORD  dwServerMask
    )
{
    DWORD err;

    err = TsApiAccessCheck( TCP_SET_ADMIN_INFORMATION );

    if ( err == NO_ERROR) {
        if (!TsCacheClearStatistics( dwServerMask ) ||
            !AtqClearStatistics())  {

            err =  GetLastError();
        }
    }

    return err;
} // R_InetInfoClearStatistics




NET_API_STATUS
NET_API_FUNCTION
R_InetInfoFlushMemoryCache(
    IN  LPWSTR pszServer OPTIONAL,
    IN  DWORD  dwServerMask
    )
{
    DWORD err;

    err = TsApiAccessCheck( TCP_SET_ADMIN_INFORMATION );

    if ( err ) {
        return err;
    }

    if ( !TsCacheFlush( dwServerMask )) {
        return GetLastError();
    }

    return NO_ERROR;
}



BOOL
ReadRegString(
    HKEY     hkey,
    CHAR * * ppchstr,
    LPCSTR   pchValue,
    LPCSTR   pchDefault
    )
/*++

   Description

     Gets the specified string from the registry.  If *ppchstr is not NULL,
     then the value is freed.  If the registry call fails, *ppchstr is
     restored to its previous value.

   Arguments:

      hkey - Handle to open key
      ppchstr - Receives pointer of allocated memory of the new value of the
        string
      pchValue - Which registry value to retrieve
      pchDefault - Default string if value isn't found

--*/
{
    CHAR * pch = *ppchstr;

    *ppchstr = ReadRegistryString( hkey,
                                   pchValue,
                                   pchDefault,
                                   TRUE );

    if ( !*ppchstr ) {
        *ppchstr = pch;
        return FALSE;
    }

    if ( pch ) {
        TCP_FREE( pch );
    }

    return TRUE;

} // ReadRegString



BOOL
ConvertStringToRpc(
    WCHAR * * ppwch,
    LPCSTR  pch
    )
/*++

   Description

     Allocates, copies and converts pch to *ppwch

   Arguments:

     ppwch - Receives allocated destination string
     pch - ANSI string to copy from

--*/
{
    int cch;
    int iRet;

    if ( !pch ) {
        *ppwch = NULL;
        return TRUE;
    }

    cch = strlen( pch );

    if ( !(*ppwch = (WCHAR *) MIDL_user_allocate( (cch + 1) * sizeof(WCHAR))) )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    iRet = MultiByteToWideChar( CP_ACP,
                                MB_PRECOMPOSED,
                                pch,
                                cch + 1,
                                *ppwch,
                                cch + 1 );

    if ( !iRet ) {
        MIDL_user_free( *ppwch );
        return FALSE;
    }

    return TRUE;
} // ConvertStringToRpc



VOID
FreeRpcString(
    WCHAR * pwch
    )
{
    if ( pwch ) {
        MIDL_user_free( pwch );
    }

} // FreeRpcString




DWORD
InitGlobalConfigFromReg(
                VOID
                )
/*++

  Loads the global configuration parameters from registry.
  Should be called after Atq Module is initialized.

  Returns:
    Win32 error code. NO_ERROR on success

--*/

{
    DWORD  dwError;
    HKEY   hkey = NULL;
    DWORD  dwVal;
    MB     mb( (IMDCOM*) IIS_SERVICE::QueryMDObject()  );

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            INET_INFO_PARAMETERS_KEY,
                            0,
                            KEY_ALL_ACCESS,
                            &hkey);

    if ( dwError == NO_ERROR) {

        DWORD       dwChangeNumber;

        // See if we need to migrate the bandwidth to the
        // metabase.

        if (!mb.GetSystemChangeNumber(&dwChangeNumber) ||
            dwChangeNumber == 0)
        {
            if (!mb.Open( "/lm",
                METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
            {
                return GetLastError();
            }

            dwVal = ReadRegistryDword( hkey,
                                   INETA_BANDWIDTH_LEVEL,
                                   INETA_DEF_BANDWIDTH_LEVEL);

            mb.SetDword("", MD_MAX_BANDWIDTH, IIS_MD_UT_SERVER, dwVal);
            mb.Close();
        }

    }

    if (mb.Open("/lm", METADATA_PERMISSION_READ))
    {
        if ( mb.GetDword("", MD_MAX_BANDWIDTH_BLOCKED, IIS_MD_UT_SERVER, &dwVal ))
        {
            AtqSetInfo( AtqBandwidthThrottleMaxBlocked, (ULONG_PTR)dwVal );
        }

        if (!mb.GetDword("", MD_MAX_BANDWIDTH, IIS_MD_UT_SERVER, &dwVal))
        {
            DBGPRINTF( ( DBG_CONTEXT, "Could not read MD_MAX_BANDWIDTH\n" ) );
            dwVal = INETA_DEF_BANDWIDTH_LEVEL;
        }
    }
    else
    {
        DBGPRINTF( ( DBG_CONTEXT, "Couldn't open; error=%d\n", GetLastError() ) );
        dwVal = INETA_DEF_BANDWIDTH_LEVEL;
    }
    
    DBGPRINTF( ( DBG_CONTEXT,
               " Setting Global throttle value to %d\n", dwVal ));

    AtqSetInfo( AtqBandwidthThrottle, (ULONG_PTR)dwVal);

    if ( hkey ) {
        RegCloseKey( hkey );
    }

    return NO_ERROR;

} // InitGlobalConfigFromReg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\certnotf.cxx ===
#include "..\common\certnotf.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\dbgutil.h ===
#include "..\common\dbgutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\dynodbc.c ===
#include "..\common\dynodbc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\fcache.cxx ===
#include "..\common\fcache.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\igateway.cxx ===
#include "..\common\igateway.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\iisassoc.cxx ===
#include "..\common\iisassoc.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\iisadmin.cxx ===
#include "..\common\iisadmin.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\globals.cxx ===
#include "..\common\globals.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\iisbind.cxx ===
#include "..\common\iisbind.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\iisendp.cxx ===
#include "..\common\iisendp.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\iiscert.cxx ===
#include "..\common\iiscert.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\iisctl.cxx ===
#include "..\common\iisctl.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\iissvc.cxx ===
#include "..\common\iissvc.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\inetreg.h ===
#include "..\common\inetreg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\instance.cxx ===
#include "..\common\instance.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\isrpc.cxx ===
#include "..\common\isrpc.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\mbsink.cxx ===
#include "..\common\mbsink.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\logon32.cxx ===
#include "..\common\logon32.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\mimemap.cxx ===
#include "..\common\mimemap.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\mimeutil.cxx ===
#include "..\common\mimeutil.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\md5c.c ===
#include "..\common\md5c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\nsistubs.cxx ===
#include "..\common\nsistubs.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\odbcconn.cxx ===
#include "..\common\odbcconn.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\parse.cxx ===
#include "..\common\parse.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\refb.cxx ===
#include "..\common\refb.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\rnr.cxx ===
#include "..\common\rnr.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\security.cxx ===
#include "..\common\security.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kisfecnv\fechrcnv.h ===
// Copyright (c) 1995  Microsoft Corpration
//
// File Name : fechrcnv.h
// Owner     : Tetsuhide Akaishi
// Revision  : 1.00 07/20/'95 Tetsuhide Akaishi
//


#include "festrcnv.h"

// Shift JIS Kanji Code Check
#define SJISISKANJI(c) ( ( (UCHAR)(c) >= 0x81 && (UCHAR)(c) <= 0x9f ) || \
                         ( (UCHAR)(c) >= 0xe0 && (UCHAR)(c) <= 0xfc ) )

// Shift JIS Kana Code Check
#define SJISISKANA(c) ( (UCHAR)(c) >= 0xa1 && (UCHAR)(c) <= 0xdf )

#define ESC     0x1b
#define SO      0x0e
#define SI      0x0f

// Define for JIS Code Kanji and Kana IN/OUT characters
#define KANJI_IN_1ST_CHAR       '$'
#define KANJI_IN_2ND_CHAR1      'B'
#define KANJI_IN_2ND_CHAR2      '@'
#define KANJI_IN_STR            "$B"
#define KANJI_IN_LEN             3
#define KANJI_OUT_1ST_CHAR      '('
#define KANJI_OUT_2ND_CHAR1     'J'
#define KANJI_OUT_2ND_CHAR2     'B'
#define KANJI_OUT_LEN            3
#define KANJI_OUT_STR           "(J"

#ifdef DBCS_DIVIDE
typedef struct _dbcs_status
{
    int nCodeSet;
    UCHAR cSavedByte;
    BOOL fESC;
} DBCS_STATUS;
#endif

//--------------------------------
// Internal Functions for Japanese
//--------------------------------

// Detect Japanese Code
int DetectJPNCode ( UCHAR *string, int len );

// Convert from Shift JIS to JIS
int ShiftJIS_to_JIS (
    UCHAR *pShiftJIS,
    int ShiftJIS_len,
    UCHAR *pJIS,
    int JIS_len
    );

// Convert from Shift JIS to EUC
int ShiftJIS_to_EUC (
    UCHAR *pShiftJIS,
    int ShiftJIS_len,
    UCHAR *pJIS,
    int JIS_len
    );

// Convert from JIS  to EUC
int JIS_to_EUC (
    UCHAR *pJIS,
    int JIS_len,
    UCHAR *pEUC,
    int EUC_len
    );

// Convert from JIS to Shift JIS
int JIS_to_ShiftJIS (
    UCHAR *pShiftJIS,
    int ShiftJIS_len,
    UCHAR *pJIS,
    int JIS_len
    );

// Convert from EUC to JIS
int EUC_to_JIS (
    UCHAR *pJIS,
    int JIS_len,
    UCHAR *pEUC,
    int EUC_len
    );

// Convert from EUC to Shift JIS
int EUC_to_ShiftJIS (
    UCHAR *pEUC,
    int EUC_len,
    UCHAR *pShiftJIS,
    int ShiftJIS_len
    );

#ifdef IEXPLORE
void FCC_Init( void );
int FCC_GetCurrentEncodingMode( void );
#endif  // IEXPLORE


#ifdef INETSERVER
UCHAR
SJISCheckLastChar( UCHAR *pShiftJIS, int len );
#endif // INETSERVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\tokenacl.cxx ===
#include "..\common\tokenacl.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\tcputil.cxx ===
#include "..\common\tcputil.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\tsvccfg.cxx ===
#include "..\common\tsvccfg.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\sslinfo.cxx ===
#include "..\common\sslinfo.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kcommon\vroots.cxx ===
#include "..\common\vroots.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kisfecnv\status.c ===
// File Name:   status.c
// Owner:       Masahiro Teragawa
// Revision:    1.00  08/23/'95  Masahiro Teragawa
//

#include "win32.h"
#include "fechrcnv.h"

#ifdef DBCS_DIVIDE
DBCS_STATUS dStatus0 = { CODE_UNKNOWN, '\0', FALSE };
BOOL blkanji0 = FALSE;  // Kanji In Mode

DBCS_STATUS dStatus  = { CODE_UNKNOWN, '\0', FALSE };
BOOL blkanji = FALSE;  // Kanji In Mode
BOOL blkana  = FALSE;  // Kana Mode
#endif  // DBCS_DIVIDE

int nCurrentCodeSet = CODE_UNKNOWN;

/*********************************************************************/
/* Function:   FCC_Init                                              */
/*********************************************************************/
void FCC_Init( void )
{
#ifdef DBCS_DIVIDE
    dStatus0.nCodeSet = CODE_UNKNOWN;
    dStatus0.cSavedByte = '\0';
    dStatus0.fESC = FALSE;

    blkanji0 = FALSE;

    dStatus.nCodeSet = CODE_UNKNOWN;
    dStatus.cSavedByte = '\0';
    dStatus.fESC = FALSE;

    blkanji = FALSE;
    blkana  = FALSE;
#endif  // DBCS_DIVIDE

    nCurrentCodeSet = CODE_UNKNOWN;

    return;
}

/*********************************************************************/
/* Function:   FCC_GetCurrentEncodingMode                            */
/*********************************************************************/
int FCC_GetCurrentEncodingMode( void )
{
    return nCurrentCodeSet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kisfecnv\detjpncs.c ===
// File Name:   detjpncs.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//
// Modified by v-chikos 

#include "win32.h"
#include "fechrcnv.h"


// The DetectJapaneseCode function find out what kind of code set is there in 
// a character string. 
//
//
// UCHAR *string        Points to the character string to be checked.
//         
// int   count          Specifies the size in bytes of the string pointed
//                      to by the string parameter.
//
// Return Value
// The function return the followings values.
//
//                      Value           Meaning
//                      CODE_ONLY_SBCS  There are no Japanese character in the 
//                                      string. 
//                      CODE_JPN_JIS    JIS Code Set. There are JIS Code Set 
//                                      character in the string.
//                      CODE_JPN_EUC    EUC Code Set. There are EUC Code Set 
//                                      character in the string.
//                      CODE_JPN_SJIS   Shift JIS Code Set. There are Shift JIS
//                                      Code Set character in the string.
//
//

// Note: CODE_UNKNOWN == CODE_ONLY_SBCS
//       added by v-chikos for IIS 2.0J

#define GetNextChar(r)                   \
{                                        \
            if ( --count )               \
                c = *++string;           \
            else                         \
                return (r);              \
}


int DetectJPNCode ( UCHAR *string, int count )
{
    int    i;
    int    c;

    for ( ; count > 0; count--, string++ ) {
        c = *string;

        if ( c == ESC ) { // check for jis (iso-2022-jp)
            if ( count < 3 )
                return CODE_UNKNOWN;
            c = *++string; count--;
            if ( c == KANJI_IN_1ST_CHAR              && 
                 ( *(string+1) == KANJI_IN_2ND_CHAR1 ||    // ESC $ B
                   *(string+1) == KANJI_IN_2ND_CHAR2 ))    // ESC $ @
                return CODE_JPN_JIS;
            else if ( c == KANJI_OUT_1ST_CHAR         && 
                 ( *(string+1) == KANJI_OUT_2ND_CHAR1 ||    // ESC ( B
                   *(string+1) == KANJI_OUT_2ND_CHAR2 ))    // ESC ( J
                return CODE_JPN_JIS;
            else
                return CODE_UNKNOWN;

        } else if ( (0x81 <= c && c <= 0x8d) || (0x8f <= c && c <= 0x9f) ) { // 1
            // found sjis 1st
            return CODE_JPN_SJIS;

        } else if ( 0x8e == c ) { //  2
            // found sjis 1st || euc Kana 1st (SS2)
            GetNextChar( CODE_UNKNOWN )
            if ( (0x40 <= c && c <= 0x7e) || (0x80 <= c && c <= 0xa0) || (0xe0 <= c && c <= 0xfc) ) // 2-1
                // found sjis 2nd 
                return CODE_JPN_SJIS;
            else if ( 0xa1 <= c && c <= 0xdf ) // 2-2
                // found sjis 2nd || euc Kana 2nd (sjis || euc)
                continue;
            else
                // illegal character code sequence
                return CODE_UNKNOWN;

        } else if ( 0xf0 <= c && c <= 0xfe ) { // 4
            // found euc 1st
            return CODE_JPN_EUC;

        } else if ( 0xe0 <= c && c <= 0xef ) { // 5
            // found sjis 1st || euc 1st
            GetNextChar( CODE_UNKNOWN )
            if ( (0x40 <= c && c <= 0x7e) || (0x80 <= c && c <= 0xa0) ) // 5-1
                // found sjis 2nd
                return CODE_JPN_SJIS;
            else if ( 0xfd <= c && c <= 0xfe ) // 5-2
                // found euc 2nd
                return CODE_JPN_EUC;
            else if ( 0xa1 <= c && c <= 0xfc ) // 5-3
                // found sjis 2nd || euc 2nd (sjis || euc)
                continue;
            else
                // illegal character code sequence
                return CODE_UNKNOWN;

        } else if ( 0xa1 <= c && c <= 0xdf ) { // 3
            // found sjis Kana || euc 1st
            GetNextChar( CODE_JPN_SJIS )
            if ( c <= 0x9f ) // 3-4
                // not euc 2nd byte 
                return CODE_JPN_SJIS;
            else if ( 0xa1 <= c && c <= 0xdf ) // 3-2
                // found sjis kana || euc 2nd (sjis || euc)
                continue;
            else if ( 0xe0 <= c && c <= 0xef ) { // 3-3
                // found sjis 1st || euc 2nd
sjis1stOReuc2nd:
                GetNextChar( CODE_JPN_EUC )
                if ( 0xfd <= c && c <= 0xfe ) // 3-3-5
                    // found euc 1st
                    return CODE_JPN_EUC;
                else if ( (0x80 <= c && c <= 0x8d) || (0x8f <= c && c <= 0xa0) ) // 3-3-2
                    // found sjis 2nd
                    return CODE_JPN_SJIS;
                else if ( 0x40 <= c && c <= 0x7e ) // 3-3-1
                    // found sjis 2nd || sbcs (sjis || euc)
                    continue;
                else if ( 0x8e == c ) { // 3-3-3
                    // found sjis 2nd || euc kana 1st
                    GetNextChar( CODE_JPN_SJIS )
                    if ( 0xa1 <= c && c <= 0xdf )
                        // found sjis Kana || euc Kana 2nd (sjis || euc)
                        continue;
                    else
                        // not found euc kana 2nd
                        return CODE_JPN_SJIS;
                } else if ( 0xa1 <= c && c <= 0xfc ) { // 3-3-4
                    // found sjis 2nd || euc 1st
                    GetNextChar( CODE_JPN_SJIS )
                    if ( 0xa1 <= c && c <= 0xdf ) // 3-3-4-1
                        // found sjis kana || euc 2nd (sjis || euc)
                        continue;
                    if ( 0xe0 <= c && c <= 0xef ) // 3-3-4-2
                        // found sjis 1st || euc 2nd
                        goto sjis1stOReuc2nd;
                    if ( 0xf0 <= c && c <= 0xfe ) // 3-3-4-3
                        // found euc 2nd
                        return CODE_JPN_EUC;
                    else
                        // not found euc 2nd
                        return CODE_JPN_SJIS;
                } else
                    // not found sjis 2nd
                    return CODE_JPN_EUC;
            } else if ( 0xf0 <= c && c <= 0xfe ) // 3-1
                return CODE_JPN_EUC;
            else
                return CODE_UNKNOWN;
        }
    }

    return CODE_ONLY_SBCS;

//  |<-----sjis1st---->|  |<-sjisKana->|<-sjis1st->|
//           ss2          |<------euc1st-------------------->|
//  |81   8d|8e|8f   9f|a0|a1        df|e0       ef|f0     fe|
//  |<--1-->|2 |<--1-->|  |<-----3---->|<----5---->|<---4--->|

// case 1 sjis
// case 4 euc

// case 2
//  |<---sjis2nd--->|  |<------sjis2nd---------------------->|
//                                |<-eucKana2nd->|
//  |40           7e|7f|80      a0|a1          df|e0       fc|
//  |<-------1----->|  |<----1--->|<------2----->|<----1---->|

// case 5
//  |<----sjis2nd----->|  |<---------sjis2nd---------------->|
//                                    |<--------euc2nd------>|
//  |40              7e|7f|80       a0|a1            fc|fd fe|
//  |<--------1------->|  |<----1---->|<-------3------>|<-2->|

// case 3
//  |<-----sjis1st---->|  |<-sjisKana->|<-sjis1st->|
//                        |<------euc2nd-------------------->|
//  |81              9f|a0|a1        df|e0       ef|f0     fe|
// <--------4--------->|  |<-----2---->|<----3---->|<--1---->|

// case 3-3
//  |<--sjis2nd-->|  |<------------sjis2nd------------------>|
//                            ss2       |<------euc1st------>|
//  |40         7e|7f|80   8d|8e|8f   a0|a1          fc|fd fe|
//  |<-----1----->|  |<--2-->|3 |<--2-->|<------4----->|<-5->|

// case 3-3-4
//  |<-sjisKana->|<-sjis1st->|
//  |<------euc2nd-------------------->|
//  |a1        df|e0       ef|f0     fe|
//  |<-----1---->|<----2---->|<--3---->|


#if 0 // old code
    for ( i = 0 ; i < count ; i++, string++ ) {
        if ( *string == ESC ) {
            if ( *(string+1) == KANJI_IN_1ST_CHAR    && 
                 ( *(string+2) == KANJI_IN_2ND_CHAR1 ||    // ESC $ B
                   *(string+2) == KANJI_IN_2ND_CHAR2 )) {  // ESC $ @
                    return CODE_JPN_JIS;
            }
            if ( *(string+1) == KANJI_OUT_1ST_CHAR    && 
                 ( *(string+2) == KANJI_OUT_2ND_CHAR1 ||    // ESC ( B
                   *(string+2) == KANJI_OUT_2ND_CHAR2 )) {  // ESC ( J
                    return CODE_JPN_JIS;
            }
        } else if ( *(string) >= 0x0081) {
            if ( *(string) < 0x00a0 ) {
                return CODE_JPN_SJIS;
            }
            else if ( *(string) < 0x00e0 || *(string) > 0x00ef) {
                return CODE_JPN_EUC;
            }
            if ( *(string+1) < 0x00a1) {
                return CODE_JPN_SJIS;
            }
            else if ( *(string+1) > 0x00fc) {
                return CODE_JPN_EUC;
            }
        }
    }
    return CODE_ONLY_SBCS;
#endif // 0
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kisfecnv\win32.h ===
/* win32.h */
/* Jeff Hostetler, Spyglass, Inc., 1994. */
/* Copyright (C) 1994, Spyglass, Inc.  All rights reserved. */

#ifndef _WIN32_H_
#define _WIN32_H_

//#define WIN32_LEAN_AND_MEAN   /* for windows.h */
#include <windows.h>

#include <stdio.h>
#include <string.h>

#endif /* _WIN32_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kisfecnv\euc2sjis.c ===
//
// File Name:   euc2sjis.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "win32.h"
#include "fechrcnv.h"

#ifdef DBCS_DIVIDE
extern DBCS_STATUS dStatus0;
extern DBCS_STATUS dStatus;
#endif

//@
// 
// Syntax:

int EUCChar_to_ShiftJISChar ( UCHAR *pEUC, UCHAR *pShiftJIS )

// The EUCChar_to_ShiftJISChar function convert one character string 
// as EUC code to a Shift JIS code string. 
//
// UCHAR *pEUC          Points to the character string to be converted.
//
// UCHAR *pShiftJIS     Points to a buffer that receives the convert string
//                      from EUC Code to Shift JIS.
//
// Return Value
// The return value is the 
// number of Shift JIS characters written to the buffer pointed to by pSJIS.
//

{
	if ( *pEUC >= 0x0a1 && *pEUC <= 0x0de ) {
		if ( (*pEUC)%2 == 1 ) {	// odd
			*pShiftJIS = ((*pEUC)-0x0a1)/2+0x081;
			goto ODD_SECOND_BYTE;
		}
		else {	// even
			*pShiftJIS = ((*pEUC)-0x0a2)/2+0x081;
			goto EVEN_SECOND_BYTE;
		}
	}
	if ( *pEUC >= 0x0df && *pEUC <= 0x0fe ) {
		if ( (*pEUC)%2 == 1 ) {	// odd
			*pShiftJIS = ((*pEUC)-0x0df)/2+0x0e0;
			goto ODD_SECOND_BYTE;
		}
		else {	// even
			*pShiftJIS = ((*pEUC)-0x0e0)/2+0x0e0;
			goto EVEN_SECOND_BYTE;
		}
	}

	// Is the charcter Hankaku KATAKANA ?
	if ( *pEUC == 0x08e ) {
		*pShiftJIS = *(pEUC+1);
		return( 1 );
	}
	// Is the charcter ASCII charcter ?
	*pShiftJIS = *pEUC;
	return ( 1 );

ODD_SECOND_BYTE:
	if ( *(pEUC+1) >= 0x0a1 && *(pEUC+1) <= 0x0df ) {
		*(pShiftJIS+1) = *(pEUC+1) - 0x061;
	}
	else {
		*(pShiftJIS+1) = *(pEUC+1) - 0x060;
	}
	return ( 2 );
EVEN_SECOND_BYTE:
	*(pShiftJIS+1) = *(pEUC+1)-2;
	return ( 2 );
}

int EUC_to_ShiftJIS ( UCHAR *pEUC, int EUC_len, UCHAR *pSJIS, int SJIS_len )


// The EUC_to_ShiftJIS function convert a character string as EUC code 
// to a Shift JIS code string. 
//
// UCHAR *pEUC          Points to the character string to be converted.
//
// int   EUC_len        Specifies the size in bytes of the string pointed
//                      to by the pEUC parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pSJIS         Points to a buffer that receives the convert string
//                      from EUC Code to Shift JIS.
//         
// int   SJIS_len       Specifies the size, in Shift JIS characters of the 
//                      buffer pointed to by the pSJIS parameter.
//                      If the value is zero,
//                      the function returns the number of Shift JIS characters 
//                      required for the buffer, and makes no use of the pSJIS 
//                      buffer.
//
// Return Value
// If the function succeeds, and SJIS_len is nonzero, the return value is the 
// number of Shift JIS characters written to the buffer pointed to by pSJIS.
//
// If the function succeeds, and SJIS_len is zero, the return value is the
// required size, in Shift JIS characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pSJIS buffer
// is small for setting converted strings.
//

{
    int     re;                // Convert Lenght
    int     i;                 // Loop Counter
    
    if ( EUC_len == -1 ) {
        // If length is not set, last character of the strings is NULL.
        EUC_len = strlen ( pEUC ) + 1;
    }
    i = 0;
    re = 0;
    if ( SJIS_len == 0 ) {
        // Only retrun the required size
#ifdef DBCS_DIVIDE
        if ( dStatus0.nCodeSet == CODE_JPN_EUC ){
            pEUC++;
            i++;

            // Is the charcter Hankaku KATAKANA ?
            if ( dStatus0.cSavedByte == 0x08e )
                re++;
            else // The character is Kanji.
                re+=2;

            dStatus0.nCodeSet = CODE_UNKNOWN;
            dStatus0.cSavedByte = '\0';
        }
#endif
        while ( i < EUC_len ) {
#ifdef DBCS_DIVIDE
            if( ( i == EUC_len - 1 ) &&
                ( *pEUC >= 0x0a1 && *pEUC <= 0x0fe || *pEUC == 0x08e ) ) {
                dStatus0.nCodeSet = CODE_JPN_EUC;
                dStatus0.cSavedByte = *pEUC;
                break;
            }
#endif
            // Is the character Kanji?
            if ( *pEUC >= 0x0a1 && *pEUC <= 0x0fe ) {
                pEUC+=2;
                i+=2;
                re+=2;
                continue;
            }
            // Is the charcter Hankaku KATAKANA ?
            if ( *pEUC == 0x08e ) {
                pEUC+=2;
                i+=2;
                re++;
                continue;
            }
            // Is the charcter ASCII charcter ?
            pEUC++;
            i++;
            re++;
        }
        return ( re );
    }

#ifdef DBCS_DIVIDE
    if ( dStatus.nCodeSet == CODE_JPN_EUC ){
        UCHAR cEUC = dStatus.cSavedByte;

        if ( cEUC >= 0x0a1 && cEUC <= 0x0de ) {
            if ( cEUC % 2 == 1 ) {	// odd
                *pSJIS = (cEUC - 0x0a1) / 2 + 0x081;
                goto ODD_SECOND_BYTE2;
            }
            else {	// even
                *pSJIS = (cEUC - 0x0a2) / 2 + 0x081;
                goto EVEN_SECOND_BYTE2;
            }
        }
        if ( cEUC >= 0x0df && cEUC <= 0x0fe ) {
            if ( cEUC % 2 == 1 ) {	// odd
                *pSJIS = (cEUC - 0x0df) / 2 + 0x0e0;
                goto ODD_SECOND_BYTE2;
            }
            else {	// even
                *pSJIS = (cEUC - 0x0e0) / 2 + 0x0e0;
                goto EVEN_SECOND_BYTE2;
            }
        }
        // Is the charcter Hankaku KATAKANA ?
        if ( cEUC == 0x08e ) {
            *pSJIS++ = *pEUC++;
            i++;
            re++;
            goto END;
        }
ODD_SECOND_BYTE2:
        if ( *pEUC >= 0x0a1 && *pEUC <= 0x0df ) {
            *(pSJIS+1) = *pEUC - 0x061;
        }
        else {
            *(pSJIS+1) = *pEUC - 0x060;
        }
        pEUC++;
        i++;
        re+=2;
        pSJIS+=2;
        goto END;
EVEN_SECOND_BYTE2:
        *(pSJIS+1) = *pEUC - 2;
        pEUC++;
        i++;
        re+=2;
        pSJIS+=2;
END:
        dStatus.nCodeSet = CODE_UNKNOWN;
        dStatus.cSavedByte = '\0';
    }
#endif

    while ( i < EUC_len ) {
#ifdef DBCS_DIVIDE
        if( ( i == EUC_len - 1 ) &&
            ( *pEUC >= 0x0a1 && *pEUC <= 0x0fe || *pEUC == 0x08e ) ) {
            dStatus.nCodeSet = CODE_JPN_EUC;
            dStatus.cSavedByte = *pEUC;
            break;
        }
#endif
        if ( re >= SJIS_len ) {    // Buffer Over?
            return ( -1 );
        }
        if ( *pEUC >= 0x0a1 && *pEUC <= 0x0de ) {
            if ( (*pEUC)%2 == 1 ) {	// odd
                *pSJIS = ((*pEUC)-0x0a1)/2+0x081;
                goto ODD_SECOND_BYTE;
            }
            else {	// even
                *pSJIS = ((*pEUC)-0x0a2)/2+0x081;
                goto EVEN_SECOND_BYTE;
            }
        }
        if ( *pEUC >= 0x0df && *pEUC <= 0x0fe ) {
            if ( (*pEUC)%2 == 1 ) {	// odd
                *pSJIS = ((*pEUC)-0x0df)/2+0x0e0;
                goto ODD_SECOND_BYTE;
            }
            else {	// even
                *pSJIS = ((*pEUC)-0x0e0)/2+0x0e0;
                goto EVEN_SECOND_BYTE;
            }
        }
        // Is the charcter Hankaku KATAKANA ?
        if ( *pEUC == 0x08e ) {
            pEUC++;
            *pSJIS++ = *pEUC++;
            i+=2;
            re++;
            continue;
        }
        // Is the charcter ASCII charcter ?
        *pSJIS++ = *pEUC++;
        i++;
        re++;
        continue;
ODD_SECOND_BYTE:
        if ( re + 1 >= SJIS_len ) {    // Buffer Over?
            return ( -1 );
        }
        if ( *(pEUC+1) >= 0x0a1 && *(pEUC+1) <= 0x0df ) {
            *(pSJIS+1) = *(pEUC+1) - 0x061;
        }
        else {
            *(pSJIS+1) = *(pEUC+1) - 0x060;
        }
        pEUC+=2;
        i+=2;
        re+=2;
        pSJIS+=2;
        continue;
EVEN_SECOND_BYTE:
        if ( re + 1 >= SJIS_len ) {    // Buffer Over?
            return ( -1 );
        }
        *(pSJIS+1) = *(pEUC+1)-2;
        pEUC+=2;
        i+=2;
        re+=2;
        pSJIS+=2;
        continue;

    }
    return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kisfecnv\pc2unix.c ===
// File Name:   pc2unix.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "win32.h"
#include "fechrcnv.h"



int PC_to_JPNUNIX ( int CodeSet,
                           UCHAR *pPCChar, int PCChar_len,
                           UCHAR *pUNIXChar, int UNIXChar_len )
// The PC_to_JPNUNIX function convert a character string as PC code
// set string to a Japanese UNIX code set string.
//
//
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//
//                      Value           Meaning
//                      CODE_JPN_JIS    JIS Code Set. The function convert
//                                      pPCChar string
//                                      to a JIS code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert
//                                      pPCChar string
//                                      to a EUC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set.
//
// UCHAR *pPCChar       Points to the character string to be converted.
//
// int   PCChar_len     Specifies the size in bytes of the string pointed
//                      to by the pPCChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
//
// UCHAR *pUNIXChar     Points to a buffer that receives the convert string
//                      from PC Code to UNIX Code.
//
// int   UNIXChar_len   Specifies the size, in UNIX characters of the buffer
//                      pointed to by the pUNIXChar parameter. If the value is
//                      zero, the function returns the number of UNIX characters
//                      required for the buffer, and makes no use of the
//                      pUNIXChar buffer.
//
// Return Value
// If the function succeeds, and UNIXChar_len is nonzero, the return value is
// the number of UNIX characters written to the buffer pointed to by pUNIXChar.
//
// If the function succeeds, and UNIXChar_len is zero, the return value is the
// required size, in UNIX characters, for a buffer that can receive the
// converted string.
//
// If the function fails, the return value is -1. The error mean pUNIXChar
// buffer is small for setting converted strings.
//
//@
{
    int    re;

        switch ( CodeSet ) {
        default:
        case CODE_JPN_JIS:    // Japanese JIS Code
            // Convert from Shift JIS to JIS
            re = ShiftJIS_to_JIS ( pPCChar, PCChar_len,
                                           pUNIXChar, UNIXChar_len );
            break;
        case CODE_JPN_EUC:    // Japanese EUC Code
            // Convert from Shift JIS to EUC
            re = ShiftJIS_to_EUC ( pPCChar, PCChar_len,
                                           pUNIXChar, UNIXChar_len );
            break;
        case CODE_JPN_SJIS:    // Japanese Shift JIS Code
            // Convert from Shift JIS to Shift JIS
            if ( PCChar_len == -1 ) {
                PCChar_len = strlen ( pPCChar ) + 1;
            }
            if ( UNIXChar_len != 0 ) {
                if ( PCChar_len > UNIXChar_len ) {  // Is the buffer small?
                    return ( -1 );
                }
                // Copy from pPCChar to pUNIXChar
                memmove ( pUNIXChar, pPCChar, PCChar_len );
            }
            re = PCChar_len;
            break;
        }
        return ( re );
}


int WINAPI PC_to_UNIX ( int CodePage, int CodeSet,
                        UCHAR *pPCChar, int PCChar_len,
                        UCHAR *pUNIXChar, int UNIXChar_len )

// The PC_to_UNIX function convert a character string as PC code
// set string to a UNIX code set string.
//
// int   CodePage       Country Code Page.
//                      If this value is -1, the function use OS CodePage from
//                      Operating System automatically.
//
//                      Value           Meaning
//                      -1              Auto Detect Mode.
//                      932             Japan.
//                      ???             Taiwan.
//                      ???             Korea.
//                      ???             PRC(Chaina)?
//
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//
//                      Value           Meaning
//                      CODE_JPN_JIS    JIS Code Set. The function convert
//                                      pPCChar string
//                                      to a JIS code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert
//                                      pPCChar string
//                                      to a EUC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set.
//
// UCHAR *pPCChar       Points to the character string to be converted.
//
// int   PCChar_len     Specifies the size in bytes of the string pointed
//                      to by the pPCChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
//
// UCHAR *pUNIXChar     Points to a buffer that receives the convert string
//                      from PC Code to UNIX Code.
//
// int   UNIXChar_len   Specifies the size, in UNIX characters of the buffer
//                      pointed to by the pUNIXChar parameter. If the value is
//                      zero, the function returns the number of UNIX characters
//                      required for the buffer, and makes no use of the
//                      pUNIXChar buffer.
//
// Return Value
// If the function succeeds, and UNIXChar_len is nonzero, the return value is
// the number of UNIX characters written to the buffer pointed to by pUNIXChar.
//
// If the function succeeds, and UNIXChar_len is zero, the return value is the
// required size, in UNIX characters, for a buffer that can receive the
// converted string.
//
// If the function fails, the return value is -1. The error mean pUNIXChar
// buffer is small for setting converted strings.
//
//@
{
        int     re;

        if ( CodePage == -1 ) {
            CodePage = (int)GetOEMCP();
        }
        switch ( CodePage ) {
        case 932:    // Japanese Code Page
            re = PC_to_JPNUNIX ( CodeSet, pPCChar, PCChar_len,
                                           pUNIXChar, UNIXChar_len );
            break;
//      case ???:    // Taiwan Code Page
//          re = PC_to_TAIWANUNIX (,,,,,,);
//          break;
//      case ???:    // Korea Code Page
//          re = PC_to_KOREAUNIX (,,,,,,);
//          break;
//      case ???:    // PRC Code Page
//          re = PC_to_PRCUNIX (,,,,,,);
//          break;
        default:
            // Start Only Copy Process
            if ( PCChar_len == -1 ) {
                PCChar_len = strlen ( pPCChar ) + 1;
            }
            if ( UNIXChar_len != 0 ) {
                if ( PCChar_len > UNIXChar_len ) {  // Is the buffer small?
                    return ( -1 );
                }
                memmove ( pUNIXChar, pPCChar, PCChar_len );
            }
            re = PCChar_len;
            break;
        }
        return ( re );
}


#if 1//#ifdef INETSERVER
UCHAR
SJISCheckLastChar( UCHAR *pShiftJIS, int len )
/*
    It check the last character of strings whether it is Shift-JIS 1st byte
    or not.

    UCHAR   *pShiftJIS   Shift-JIS strings to check
    int     len          byte size of ShiftJIS strings

    Return value
    0       last character is not a Shift-JIS 1st byte
    last character(Shift-JIS 1st byte)
*/
{
    int ch;

    while ( len-- )
    {
        ch = *pShiftJIS++;
        if ( SJISISKANJI(ch) )
            if ( 0 == len )
                return (UCHAR)ch;
            else
            {
                --len;
                ++pShiftJIS;
            }
    }

    return 0;
}
#endif // INETSERVER



BOOL WINAPI DLLEntry( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    BOOL  fReturn = TRUE;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:

    case DLL_PROCESS_DETACH:

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break ;
    }

    return ( fReturn);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kisfecnv\sjis2jis.c ===
// Copyright (c) Microsoft Corpration
//
// File Name:   sjis2jis.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "win32.h"
#include "fechrcnv.h"

void ShiftJISChar_to_JISChar ( UCHAR *pShiftJIS, UCHAR *pJIS )

// The ShiftJISChar_to_JISChar function convert one character string 
// as Shift JIS code to a JIS code string. 
//
// UCHAR *pShiftJIS     Points to the character string to be converted.
//
// UCHAR *pJIS          Points to a buffer that receives the convert string
//                      from Shift JIS Code to JIS.
//
// Return Value
// None 

{
	USHORT	hi_code, low_code;

	hi_code = (*pShiftJIS);
	low_code = *(pShiftJIS+1);
	hi_code -= (hi_code > 0x9f ? 0xb1 : 0x71);
	hi_code = hi_code * 2 + 1;
	if ( low_code > 0x9e ) {
		low_code -= 0x7e;
		hi_code ++;
	}
	else {
		if ( low_code > 0x7e ) {
			low_code --;
		}
		low_code -= 0x1f;
	}
	*(pJIS) = (UCHAR)hi_code;
	*(pJIS+1) = (UCHAR)low_code;
	return;
}


int ShiftJIS_to_JIS ( UCHAR *pShiftJIS, int ShiftJIS_len,
                                                UCHAR *pJIS, int JIS_len )

// The ShiftJIS_to_JIS function convert a character string as Shift JIS code 
// to a JIS code string. 
//
// UCHAR *pShiftJIS     Points to the character string to be converted.
//
// int   ShiftJIS_len   Specifies the size in bytes of the string pointed
//                      to by the pShiftJIS parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pJIS          Points to a buffer that receives the convert string
//                      from Shift JIS Code to JIS.
//         
// int   JIS_len        Specifies the size, in JIS characters of the buffer
//                      pointed to by the pJIS parameter. If the value is zero,
//                      the function returns the number of JIS characters 
//                      required for the buffer, and makes no use of the pJIS 
//                      buffer.
//
// Return Value
// If the function succeeds, and JIS_len is nonzero, the return value is the 
// number of JIS characters written to the buffer pointed to by pJIS.
//
// If the function succeeds, and JIS_len is zero, the return value is the
// required size, in JIS characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pJIS buffer
// is small for setting converted strings.
//

{
    BOOL    kanji_in = FALSE;      // Kanji Mode
    BOOL    kana_in = FALSE;       // Kana  Mode
    int     re;                    // Convert Lenght
    int     i;                     // Loop Counter

    if ( ShiftJIS_len == -1 ) {
        // If length is not set, last character of the strings is NULL.
        ShiftJIS_len = strlen ( pShiftJIS ) + 1;
    }
    i = 0;
    re = 0;
    if ( JIS_len == 0 ) {
        // Only retrun the required size
        while ( i < ShiftJIS_len ) {
            if ( SJISISKANJI(*pShiftJIS) ) {  // Is this charcter 2 bytes Kanji?
                if ( kana_in ) {            // Kana Mode?
                    re ++;
                    kana_in = FALSE;         // Reset Kana Mode;
                }
                if ( kanji_in == FALSE ) {  // Kanji Mode?
                    re += KANJI_IN_LEN;
                    kanji_in = TRUE;        // Set Kanji Mode
                }

                i+=2;
                re += 2;
                pShiftJIS+=2;
            }
            else if ( SJISISKANA(*pShiftJIS) ) {
                if ( kanji_in ) {
                    re += KANJI_OUT_LEN;
                    kanji_in = FALSE;
                }
                if ( kana_in == FALSE ) {
                     re ++;
                     kana_in = TRUE;
                }
                i++;
                re++;
                pShiftJIS++;
            }
            else {
                if ( kana_in ) {
                    re ++;
                    kana_in = FALSE;
                }
                if ( kanji_in ) {
                    re += KANJI_OUT_LEN;
                    kanji_in = FALSE;
                }
                i++;
                re++;
                pShiftJIS++;
            }
        }
        if ( kana_in ) {
            re ++;
            kana_in = FALSE;
        }
        if ( kanji_in ) {
            re += KANJI_OUT_LEN;
            kanji_in = FALSE;
        }
        return ( re );
    }
    while ( i < ShiftJIS_len ) {
        if ( SJISISKANJI(*pShiftJIS) ) {  // Is this charcter 2 bytes Kanji?
            if ( kana_in ) {            // Kana Mode?
                if ( re >= JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                (*pJIS++) = SI;     // Set Kana Out Charcter
                re ++;
                kana_in = FALSE;         // Reset Kana Mode;
            }
            if ( kanji_in == FALSE ) {  // Kanji Mode?
                if ( re + KANJI_IN_LEN > JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                (*pJIS++) = ESC;    // Set Kanji In Charcter
                (*pJIS++) = KANJI_IN_1ST_CHAR;
                (*pJIS++) = KANJI_IN_2ND_CHAR1;
                re += KANJI_IN_LEN;
                kanji_in = TRUE;        // Set Kanji Mode
            }

            if ( re + 2 > JIS_len ) {   // Buffer Over?
                return ( -1 );
            }
            ShiftJISChar_to_JISChar ( pShiftJIS, pJIS );
            i+=2;
            re += 2;
            pShiftJIS+=2;
            pJIS += 2;
        }
        else if ( SJISISKANA(*pShiftJIS) ) {
            if ( kanji_in ) {
                if ( re + KANJI_OUT_LEN > JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                // Set Kanji Out Charcter
                (*pJIS++) = ESC;
                (*pJIS++) = KANJI_OUT_1ST_CHAR;
                (*pJIS++) = KANJI_OUT_2ND_CHAR1;
                re += KANJI_OUT_LEN;
                kanji_in = FALSE;
            }
            if ( kana_in == FALSE ) {
                if ( re >= JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                (*pJIS++) = SO;	// Set Kana In Charcter
                re ++;
                kana_in = TRUE;
            }
            if ( re >= JIS_len ) {   // Buffer Over?
                return ( -1 );
            }
            (*pJIS++) = (*pShiftJIS++) & 0x7f;
            i++;
            re++;
        }
        else {
            if ( kana_in ) {
                if ( re >= JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                (*pJIS++) = SI;	// Set Kana Out Charcter
                re ++;
                kana_in = FALSE;
            }
            if ( kanji_in ) {
                if ( re + KANJI_OUT_LEN > JIS_len ) {   // Buffer Over?
                    return ( -1 );
                }
                // Set Kanji Out Charcter
                (*pJIS++) = ESC;
                (*pJIS++) = KANJI_OUT_1ST_CHAR;
                (*pJIS++) = KANJI_OUT_2ND_CHAR1;
                re += KANJI_OUT_LEN;
                kanji_in = FALSE;
            }
            if ( re >= JIS_len ) {   // Buffer Over?
                return ( -1 );
            }
            (*pJIS++) = (*pShiftJIS++);
            i++;
            re++;
        }
    }
    if ( kana_in ) {
        if ( re >= JIS_len ) {   // Buffer Over?
            return ( -1 );
        }
        (*pJIS++) = SI;	// Set Kana Out Charcter
        re ++;
        kana_in = FALSE;
    }
    if ( kanji_in ) {
        if ( re + KANJI_OUT_LEN  > JIS_len ) {   // Buffer Over?
            return ( -1 );
        }
        // Set Kanji Out Charcter
        (*pJIS++) = ESC;
        (*pJIS++) = KANJI_OUT_1ST_CHAR;
        (*pJIS++) = KANJI_OUT_2ND_CHAR1;
        re += KANJI_OUT_LEN;
        kanji_in = FALSE;
    }
    return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\knfo\client\info_cli_stub.c ===
#include "info_cli.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\knfo\idl\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Madan Appiah (madana) 10-Oct-1995

Revision History:


--*/


#include <windef.h>
#include <lmcons.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define LPSTR [string] char*
#define BOOL DWORD
#endif

#include <inetcom.h>
#include <iisinfo.h>    // includes inetinfo.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kisfecnv\jis2sjis.c ===
//
// File Name:   jis2sjis.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "win32.h"
#include "fechrcnv.h"

#ifdef DBCS_DIVIDE
extern DBCS_STATUS dStatus0;
extern BOOL        blkanji0;  // Kanji In Mode

extern DBCS_STATUS dStatus;
extern BOOL        blkanji;   // Kanji In Mode
extern BOOL        blkana;    // Kana Mode
#endif

VOID JISChar_to_ShiftJISChar ( UCHAR *pJIS, UCHAR *pSJIS )

// The JISChar_to_ShiftJISChar function convert one character string 
// as JIS code to a Shift JIS code string. 
//
// UCHAR *pJIS          Points to the character string to be converted.
//
// UCHAR *pSJIS         Points to a buffer that receives the convert string
//                      from JIS Code to Shift JIS.
//
// Return Value
// None. 
//

{
    *pSJIS = ((*pJIS - 0x21) >> 1) +0x81;
    if ( *pSJIS > 0x9f ) {
        (*pSJIS) += 0x40;
    }
    *(pSJIS+1) = (*(pJIS+1)) + (*pJIS) & 1 ? 0x1f : 0x7d;
    if ( *(pSJIS+1) >= 0x7f ) {
        (*(pSJIS+1)) ++;
    }
}

int JIS_to_ShiftJIS ( UCHAR *pJIS, int JIS_len, UCHAR *pSJIS, int SJIS_len )


// The JIS_to_ShiftJIS function convert a character string as JIS code 
// to a Shift JIS code string. 
//
// UCHAR *pJIS          Points to the character string to be converted.
//
// int   JIS_len        Specifies the size in bytes of the string pointed
//                      to by the pJIS parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pSJIS         Points to a buffer that receives the convert string
//                      from EUC Code to Shift JIS.
//         
// int   SJIS_len       Specifies the size, in Shift JIS characters of the 
//                      buffer pointed to by the pSJIS parameter.
//                      If the value is zero,
//                      the function returns the number of Shift JIS characters 
//                      required for the buffer, and makes no use of the pSJIS 
//                      buffer.
//
// Return Value
// If the function succeeds, and SJIS_len is nonzero, the return value is the 
// number of Shift JIS characters written to the buffer pointed to by pSJIS.
//
// If the function succeeds, and SJIS_len is zero, the return value is the
// required size, in Shift JIS characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pSJIS buffer
// is small for setting converted strings.
//

{
    int     re;                // Convert Lenght
    int     i;                 // Loop Counter
#ifndef DBCS_DIVIDE
    BOOL    blkanji = FALSE;   // Kanji In Mode
    BOOL    blkana = FALSE;    // Kana Mode
#endif
    
    if ( JIS_len == -1 ) {
        // If length is not set, last character of the strings is NULL.
        JIS_len = strlen ( pJIS ) + 1;
    }
    i = 0;
    re = 0;
    if ( SJIS_len == 0 ) {
        // Only retrun the required size
#ifdef DBCS_DIVIDE
        if ( dStatus0.nCodeSet == CODE_JPN_JIS ) {
            UCHAR cJIS = dStatus0.cSavedByte;
            if ( dStatus0.fESC ){
                if ( cJIS ){
                    if ( cJIS == KANJI_IN_1ST_CHAR &&
                         ( *pJIS == KANJI_IN_2ND_CHAR1 ||
                           *pJIS == KANJI_IN_2ND_CHAR2 )){
                        blkanji0 = TRUE;
                        pJIS++;
                        i++;
                    } else if ( cJIS == KANJI_OUT_1ST_CHAR &&
                                ( *pJIS == KANJI_OUT_2ND_CHAR1 ||
                                  *pJIS == KANJI_OUT_2ND_CHAR2 )){
                        blkanji0 = FALSE;
                        pJIS++;
                        i++;
                    } else
                        re += 2;
                } else {
                    if ( *pJIS == KANJI_IN_1ST_CHAR &&
                         ( *(pJIS+1) == KANJI_IN_2ND_CHAR1 ||
                           *(pJIS+1) == KANJI_IN_2ND_CHAR2 )){
                        blkanji0 = TRUE;
                        pJIS += 2;
                        i += 2;
                    } else if ( *pJIS == KANJI_OUT_1ST_CHAR &&
                           ( *(pJIS+1) == KANJI_OUT_2ND_CHAR1 ||
                             *(pJIS+1) == KANJI_OUT_2ND_CHAR2 )){
                        blkanji0 = FALSE;
                        pJIS += 2;
                        i += 2;
                    } else
                        re++;
                }
            } else if ( cJIS ){    // Divide DBCS in KANJI mode
                pJIS++;
                i++;
                re += 2;
            }
            dStatus0.nCodeSet = CODE_UNKNOWN;
            dStatus0.cSavedByte = '\0';
            dStatus0.fESC = FALSE;
        }
#endif
        while ( i < JIS_len ) {
            if ( *pJIS == SO ) {   // Kana  Mode In?
                blkana = TRUE;
                pJIS++;
                i++;
                continue;
            }
            if ( *pJIS == SI ) {   // Kana Mode Out ?
                blkana = FALSE;
                pJIS++;
                i++;
                continue;
            }
            if ( blkana == TRUE ) {
                pJIS++;
                i++;
                re++;
                continue;
            }
            if ( *pJIS == ESC ) {
#ifdef DBCS_DIVIDE
                if ( i == JIS_len - 1 || i == JIS_len - 2 ){
                    dStatus0.nCodeSet = CODE_JPN_JIS;
                    dStatus0.fESC = TRUE;
                    if( i == JIS_len - 2 )
                        dStatus0.cSavedByte = *(pJIS+1);
                    break;
                }
#endif
                if ( *(pJIS+1) == KANJI_IN_1ST_CHAR    && 
                     ( *(pJIS+2) == KANJI_IN_2ND_CHAR1 ||
                       *(pJIS+2) == KANJI_IN_2ND_CHAR2 )) {
#ifdef DBCS_DIVIDE
                    blkanji0 = TRUE;
#else
                    blkanji = TRUE;
#endif
                    pJIS+=3;
                    i+=3;
                    continue;
                }
                if ( *(pJIS+1) == KANJI_OUT_1ST_CHAR    &&
                     ( *(pJIS+2) == KANJI_OUT_2ND_CHAR1 ||
                       *(pJIS+2) == KANJI_OUT_2ND_CHAR2 )) {
#ifdef DBCS_DIVIDE
                    blkanji0 = FALSE;
#else
                    blkanji = FALSE;
#endif
                    pJIS+=3;
                    i+=3;
                    continue;
                }
                pJIS++;
                i++;
                re++;
                continue;
            }
            else {
#ifdef DBCS_DIVIDE
                if ( blkanji0 == FALSE ) {
#else
                if ( blkanji == FALSE ) {
#endif
                    pJIS++;
                    i++;
                    re++;
                    continue;
                }
                else {
#ifdef DBCS_DIVIDE
                    if ( i == JIS_len - 1 ){
                        dStatus0.nCodeSet = CODE_JPN_JIS;
                        dStatus0.cSavedByte = *pJIS;
                        break;
                    }
#endif
                    if ( *pJIS == '*' ) {
                        pJIS+=2;
                        i+=2;
                        re ++;
                        continue;
                    }
                    else {
                        pJIS+=2;
                        i+=2;
                        re +=2;
                        continue;
                    }
                }
            }
        }
        return ( re );
    }

#ifdef DBCS_DIVIDE
    if ( dStatus.nCodeSet == CODE_JPN_JIS ) {
        UCHAR cJIS = dStatus.cSavedByte;
        if ( dStatus.fESC ){
            if ( cJIS){
                if ( cJIS == KANJI_IN_1ST_CHAR &&
                     ( *pJIS == KANJI_IN_2ND_CHAR1 ||
                       *pJIS == KANJI_IN_2ND_CHAR2 )){
                    blkanji = TRUE;
                    pJIS++;
                    i++;
                } else if ( cJIS == KANJI_OUT_1ST_CHAR &&
                            ( *pJIS == KANJI_OUT_2ND_CHAR1 ||
                              *pJIS == KANJI_OUT_2ND_CHAR2 )){
                    blkanji = FALSE;
                    pJIS++;
                    i++;
                } else {
                    *pSJIS = ESC;
                    *(pSJIS+1) = cJIS;
                    re += 2;
                    pSJIS += 2;
                }
            } else {
                if ( *pJIS == KANJI_IN_1ST_CHAR &&
                     ( *(pJIS+1) == KANJI_IN_2ND_CHAR1 ||
                       *(pJIS+1) == KANJI_IN_2ND_CHAR2 )){
                    blkanji = TRUE;
                    pJIS += 2;
                    i += 2;
                } else if ( *pJIS == KANJI_OUT_1ST_CHAR &&
                       ( *(pJIS+1) == KANJI_OUT_2ND_CHAR1 ||
                         *(pJIS+1) == KANJI_OUT_2ND_CHAR2 )){
                    blkanji = FALSE;
                    pJIS += 2;
                    i += 2;
                } else {
                    *pSJIS = ESC;
                    re++;
                    pSJIS++;
                }
            }
        } else if ( cJIS ){    // Divide DBCS in KANJI mode
            // Start One Character Convert from JIS to Shift JIS
            *pSJIS = (cJIS - 0x21 >> 1) +0x81;
            if ( *pSJIS > 0x9f ) {
                (*pSJIS) += 0x40;
            }
            *(pSJIS+1) = *pJIS + ( cJIS & 1 ? 0x1f : 0x7d );
            if ( *(pSJIS+1) >= 0x7f ) {
                (*(pSJIS+1)) ++;
            }
            pJIS++;
            i++;
            re += 2;
            pSJIS += 2;
        }
        dStatus.nCodeSet = CODE_UNKNOWN;
        dStatus.cSavedByte = '\0';
        dStatus.fESC = FALSE;
    }
#endif

    while ( i < JIS_len ) {
        if ( *pJIS == SO ) {   // Kana  Mode In?
            blkana = TRUE;
            pJIS++;
            i++;
            continue;
        }
        if ( *pJIS == SI ) {   // Kana Mode Out ?
            blkana = FALSE;
            pJIS++;
            i++;
            continue;
        }
        if ( blkana == TRUE ) {
            if ( re >= SJIS_len ) { // Buffer Over flow?
                return ( -1 );
            }
            *pSJIS = (*pJIS) | 0x80;
            pJIS++;
            i++;
            re++;
            pSJIS++;
            continue;
        }
        if ( *pJIS == ESC ) {
#ifdef DBCS_DIVIDE
            if ( i == JIS_len - 1 || i == JIS_len - 2 ){
                dStatus.nCodeSet = CODE_JPN_JIS;
                dStatus.fESC = TRUE;
                if( i == JIS_len - 2 )
                    dStatus.cSavedByte = *(pJIS+1);
                break;
            }
#endif
            if ( *(pJIS+1) == KANJI_IN_1ST_CHAR    && 
                 ( *(pJIS+2) == KANJI_IN_2ND_CHAR1 ||
                   *(pJIS+2) == KANJI_IN_2ND_CHAR2 )) {
                blkanji = TRUE;
                pJIS+=3;
                i+=3;
                continue;
            }
            if ( *(pJIS+1) == KANJI_OUT_1ST_CHAR    &&
                 ( *(pJIS+2) == KANJI_OUT_2ND_CHAR1 ||
                   *(pJIS+2) == KANJI_OUT_2ND_CHAR2 )) {
                blkanji = FALSE;
                pJIS+=3;
                i+=3;
                continue;
            }
            if ( re >= SJIS_len ) { // Buffer Over flow?
                return ( -1 );
            }
            *pSJIS = *pJIS;
            pJIS++;
            i++;
            re++;
            pSJIS++;
            continue;
        }
        else {
            if ( blkanji == FALSE ) {
                if ( re >= SJIS_len ) { // Buffer Over flow?
                    return ( -1 );
                }
                *pSJIS = *pJIS;
                pJIS++;
                i++;
                re++;
                pSJIS++;
                continue;
            }
            else {
#ifdef DBCS_DIVIDE
                if ( i == JIS_len - 1 ){
                    dStatus.nCodeSet = CODE_JPN_JIS;
                    dStatus.cSavedByte = *pJIS;
                    break;
                }
#endif
                if ( *pJIS == '*' ) {
                    if ( re >= SJIS_len ) { // Buffer Over flow?
                        return ( -1 );
                    }
                    *pSJIS = *(pJIS+1) | 0x80;
                    pJIS+=2;
                    i+=2;
                    re ++;
                    pSJIS++;
                    continue;
                }
                else {
                    // Kanji Code
                    if ( re + 1 >= SJIS_len ) { // Buffer Over flow?
                        return ( -1 );
                    }
                    // Start One Character Convert from JIS to Shift JIS
                    *pSJIS = ((*pJIS - 0x21) >> 1) +0x81;
                    if ( *pSJIS > 0x9f ) {
                        (*pSJIS) += 0x40;
                    }
                    *(pSJIS+1) = (*(pJIS+1)) + ( (*pJIS) & 1 ? 0x1f : 0x7d );
                    if ( *(pSJIS+1) >= 0x7f ) {
                        (*(pSJIS+1)) ++;
                    }
                    pJIS+=2;
                    i+=2;
                    re +=2;
                    pSJIS+=2;
                    continue;
                }
            }
        }
    }
    return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kisfecnv\sjis2euc.c ===
// Copyright (c) Microsoft Corpration
//
// File Name:   sjis2euc.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "win32.h"
#include "fechrcnv.h"

//Shift JIS(SJC) to EUC Conversion algorithm
//Two byte KANJI
//  - 1st byte of Shift JIS charcter 
//	  (XX = Hex value of 1st byte of Shift JIS Charcter)
//    Range 0x81 - 0x9f
//    (2nd byte of Shift JIS is less than or equals to 0x9e)
//                                            (EUC odd)0xa1-0xdd
//              EUC 1st byte = (XX-0x81)*2 + 0xa1
//    (2nd byte of Shift JIS is greater than or equals to 0x9f)
//                                            (EUC even)0xa2-0xde
//              EUC 1st byte = (XX-0x81)*2 + 0xa2
//
//    Range 0xe0 - 0xef
//    (2nd byte of Shift JIS is less than or equals to 0x9e)
//                                            (EUC odd)0xdf-0xfd
//              EUC 1st byte = (XX-0xe0)*2 + 0xdf
//    (2nd byte of Shift JIS is greater than or equals to 0x9f)
//                                            (EUC even)0xa2-0xde
//              EUC 1st byte = (XX-0xe0)*2 + 0xe0
//
//  - 2nd byte of Shift JIS charcter 
//	  (YY = Hex value of 2nd byte of Shift JIS Charcter)
//    Range 0x40 - 0x7e                       (EUC)0xa1 - 0xdf
//              EUC 2nd byte = (YY+0x61)
//    Range 0x80 - 0x9e                       (EUC)0xe0 - 0xfe
//              EUC 2nd byte = (YY+0x60)
//    Range 0x9f - 0xfc                       (EUC)0xa1 - 0xfe
//              EUC 2nd byte = (YY+0x02)
//
//  Range 0x0a1 - 0x0df(Hankaku KATAKANA)
//    1st byte of EUC charcter = 0x08e
//    2nd byte if EUC charcter = C6220 Hankaku KATAKANA code
//    (same byte value as Shift JIS Hankaku KATAKANA) (0x0a1 - 0x0df)

//@
// 
// Syntax:

int ShiftJISChar_to_EUCChar ( UCHAR *pShiftJIS, UCHAR *pEUC )


// The ShiftJISChar_to_EUCChar function convert one Shift JIS character 
// to a JIS code string. 
//
// UCHAR *pShiftJIS     Points to the character string to be converted.
//
// UCHAR *pEUC          Points to a buffer that receives the convert string
//                      from Shift JIS Code to EUC Code.
//
// Return Value
//      The number of bytes to copy.
//

{
	if ( *pShiftJIS >= 0x081 && *pShiftJIS <= 0x09f ) {
		if ( *(pShiftJIS+1) <= 0x09e ) {
			*pEUC = ((*pShiftJIS)-0x081)*2+0x0a1;
		}
		else {
			*pEUC = ((*pShiftJIS)-0x081)*2+0x0a2;
		}
		goto SECOND_BYTE;
	}
	if ( *pShiftJIS >= 0x0e0 && *pShiftJIS <= 0x0ef ) {
		if ( *(pShiftJIS+1) <= 0x09e ) {
			*pEUC = ((*pShiftJIS)-0x0e0)*2+0x0df;
		}
		else {
			*pEUC = ((*pShiftJIS)-0x0e0)*2+0x0e0;
		}
		goto SECOND_BYTE;
	}

	// Is the charcter Hankaku KATAKANA ?
	if ( *pShiftJIS >= 0x0a1 && *pShiftJIS <= 0x0df ) {
		*pEUC = 0x08e;
		*(pEUC+1) = *pShiftJIS;
		return( 2 );
	}
	// Is the charcter IBM Extended Charcter?
	if ( *pShiftJIS >= 0x0fa && *pShiftJIS <= 0x0fc ) {
		// There are no IBM Extended Charcte in EUC charset.
		*pEUC = ' ';
		*(pEUC+1) = ' ';
		return( 2 );
	}
		// Is the charcter ASCII charcter ?
	*pEUC = *pShiftJIS;
	return ( 1 );

SECOND_BYTE:
	if ( *(pShiftJIS+1) >= 0x040 && *(pShiftJIS+1) <= 0x07e ) {
		*(pEUC+1) = *(pShiftJIS + 1) + 0x061;
	}
	else {
		if ( *(pShiftJIS+1) >= 0x080 && *(pShiftJIS+1) <= 0x09e ) {
			*(pEUC+1) = *(pShiftJIS + 1) + 0x060;
		}
		else {
			*(pEUC+1) = *(pShiftJIS + 1) + 0x002;
		}
	}
	return ( 2 );
}


int ShiftJIS_to_EUC ( UCHAR *pShiftJIS, int ShiftJIS_len,
                                                UCHAR *pEUC, int EUC_len )

// The ShiftJIS_to_JIS function convert a character string as Shift JIS code 
// to a EUC code string. 
//
// UCHAR *pShiftJIS     Points to the character string to be converted.
//
// int   ShiftJIS_len   Specifies the size in bytes of the string pointed
//                      to by the pShiftJIS parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pEUC          Points to a buffer that receives the convert string
//                      from Shift JIS Code to EUC Code.
//         
// int   EUC_len        Specifies the size, in EUC characters of the buffer
//                      pointed to by the pEUC parameter. If the value is zero,
//                      the function returns the number of EUC characters 
//                      required for the buffer, and makes no use of the pEUC 
//                      buffer.
//
// Return Value
// If the function succeeds, and EUC_len is nonzero, the return value is the 
// number of EUC characters written to the buffer pointed to by pEUC.
//
// If the function succeeds, and EUC_len is zero, the return value is the
// required size, in EUC characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pEUC buffer
// is small for setting converted strings.
//

{

    int     re;                // Convert Lenght
    int     i;                 // Loop Counter
    
    if ( ShiftJIS_len == -1 ) {
        // If length is not set, last character of the strings is NULL.
        ShiftJIS_len = strlen ( pShiftJIS ) + 1;
    }
    i = 0;
    re = 0;
    if ( EUC_len == 0 ) {
        // Only retrun the required size
        while ( i < ShiftJIS_len ) {
            if ( SJISISKANJI(*pShiftJIS) ) {
                pShiftJIS+=2;
                i+=2;
                re+=2;
                continue;
            }
            if ( SJISISKANA(*pShiftJIS) ) {
                pShiftJIS++;
                i++;
                re+=2;
                continue;
            }
            pShiftJIS++;
            i++;
            re++;
        }
        return ( re );
    }
    while ( i < ShiftJIS_len ) {
        if ( *pShiftJIS >= 0x081 && *pShiftJIS <= 0x09f ) {
            if ( re + 1 >= EUC_len ) {    // Buffer Over?
                return ( -1 );
            }
            if ( *(pShiftJIS+1) <= 0x09e ) {
                *pEUC = ((*pShiftJIS)-0x081)*2+0x0a1;
            }
            else {
                *pEUC = ((*pShiftJIS)-0x081)*2+0x0a2;
            }
            pShiftJIS++;          // Next Char
            pEUC++;
            if ( (*pShiftJIS) >= 0x040 && (*pShiftJIS) <= 0x07e ) {
                (*pEUC) = (*pShiftJIS) + 0x061;
            }
            else {
                if ( (*pShiftJIS) >= 0x080 && (*pShiftJIS) <= 0x09e ) {
                    (*pEUC) = (*pShiftJIS) + 0x060;
                }
                else {
                    (*pEUC) = (*pShiftJIS) + 0x002;
                }
            }
            re+=2;
            i+=2;
            pShiftJIS++;
            pEUC++;
            continue;
        }
        if ( *pShiftJIS >= 0x0e0 && *pShiftJIS <= 0x0ef ) {
            if ( re + 1 >= EUC_len ) {    // Buffer Over?
                return ( -1 );
            }
            if ( *(pShiftJIS+1) <= 0x09e ) {
                *pEUC = ((*pShiftJIS)-0x0e0)*2+0x0df;
            }
            else {
                *pEUC = ((*pShiftJIS)-0x0e0)*2+0x0e0;
            }
            pShiftJIS++;          // Next Char
            pEUC++;
            if ( (*pShiftJIS) >= 0x040 && (*pShiftJIS) <= 0x07e ) {
                (*pEUC) = (*pShiftJIS) + 0x061;
            }
            else {
                if ( (*pShiftJIS) >= 0x080 && (*pShiftJIS) <= 0x09e ) {
                    (*pEUC) = (*pShiftJIS) + 0x060;
                }
                else {
                    (*pEUC) = (*pShiftJIS) + 0x002;
                }
            }
            re+=2;
            i+=2;
            pShiftJIS++;
            pEUC++;
            continue;
        }
        // Is the charcter Hankaku KATAKANA ?
        if ( *pShiftJIS >= 0x0a1 && *pShiftJIS <= 0x0df ) {
            if ( re + 1 >= EUC_len ) {    // Buffer Over?
                return ( -1 );
            }
            *pEUC = 0x08e;
            pEUC++;
            (*pEUC) = *pShiftJIS;
            re+=2;
            i++;
            pShiftJIS++;
            pEUC++;
            continue;
        }

        // Is the charcter IBM Extended Charcter?
        if ( *pShiftJIS >= 0x0fa && *pShiftJIS <= 0x0fc ) {
            if ( re + 1 >= EUC_len ) {    // Buffer Over?
                return ( -1 );
            }
            // There are no IBM Extended Charcte in EUC charset.
            *pEUC = ' ';
            pEUC++;
            (*pEUC) = ' ';
            re+=2;
            i+=2;
            pShiftJIS+=2;
            pEUC++;
            continue;
	}

        // Is the charcter ASCII charcter ?
        if ( re  >= EUC_len ) {    // Buffer Over?
            return ( -1 );
        }
        *pEUC = *pShiftJIS;
        re++;
        i++;
        pShiftJIS++;
        pEUC++;
        continue;
    }
    return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\kisfecnv\unix2pc.c ===
// File Name:   unix2pc.c
// Owner:       Tetsuhide Akaishi
// Revision:    1.00  02/21/'93  Tetsuhide Akaishi
//

#include "win32.h"
#include "fechrcnv.h"

#ifdef DBCS_DIVIDE
extern DBCS_STATUS dStatus0;
extern DBCS_STATUS dStatus;
#endif
#ifdef IEXPLORE
extern int nCurrentCodeSet;
#endif

int JPNUNIX_to_PC ( int CodeSet,
                           UCHAR *pUNIXChar, int UNIXChar_len,
                           UCHAR *pPCChar, int PCChar_len )

// The JPNUNIX_to_PC function convert a character string as Japanese UNIX code 
// set string to a PC code set string. 
//
//                      
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//                      
//                      Value           Meaning
//                      CODE_UNKNOWN    Unknown. If this value is CODE_UNKNOWN,
//                                      Code Type is checked automatically. 
//                                      
//                      CODE_JPN_JIS    JIS Code Set. The function convert 
//                                      pUNIXChar string as JIS code set string
//                                      to a PC code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert 
//                                      pUNIXChar string as EUC code set string
//                                      to a PC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set. 
//
// UCHAR *pUNIXChar     Points to the character string to be converted.
//
// int   UNIXChar_len   Specifies the size in bytes of the string pointed
//                      to by the pUNIXChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pPCChar       Points to a buffer that receives the convert string
//                      from UNIX Code to PC Code.
//         
// int   PCChar_len     Specifies the size, in PC characters of the buffer
//                      pointed to by the pPCChar parameter. If the value is zero,
//                      the function returns the number of PC characters 
//                      required for the buffer, and makes no use of the pPCChar
//                      buffer.
//
// Return Value
// If the function succeeds, and PCChar_len is nonzero, the return value is the 
// number of PC characters written to the buffer pointed to by pPCChar.
//
// If the function succeeds, and PCChar_len is zero, the return value is the
// required size, in PC characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pPCChar buffer
// is small for setting converted strings.
//
{
    int   re;
#ifdef DBCS_DIVIDE
    int   i = 0, nDelta = 0;

    if ( PCChar_len == 0 && dStatus0.nCodeSet != CODE_UNKNOWN)
        CodeSet = dStatus0.nCodeSet;
    else if ( PCChar_len != 0 && dStatus.nCodeSet != CODE_UNKNOWN )
        CodeSet = dStatus.nCodeSet;
    else
#endif
#ifdef IEXPLORE
    if ( nCurrentCodeSet == CODE_UNKNOWN ) {
#endif
    if ( CodeSet == CODE_UNKNOWN ) {
        if ( ( CodeSet = DetectJPNCode ( pUNIXChar, UNIXChar_len ) )
                                       == CODE_ONLY_SBCS ) {
            CodeSet = CODE_JPN_JIS;
        }
    }
#ifdef IEXPLORE
        nCurrentCodeSet = CodeSet;
    } else
        CodeSet = nCurrentCodeSet;
#endif
    switch ( CodeSet ) {
        case CODE_JPN_JIS:    // Japanese JIS Code
            // Convert from JIS to Shift JIS
            re = JIS_to_ShiftJIS ( pUNIXChar, UNIXChar_len,
                                           pPCChar, PCChar_len );
            break;
        case CODE_JPN_EUC:    // Japanese EUC Code
            // Convert from EUC to Shift JIS
            re = EUC_to_ShiftJIS ( pUNIXChar, UNIXChar_len,
                                           pPCChar, PCChar_len );
            break;
        default:
        case CODE_JPN_SJIS:    // Japanese Shift JIS Code
            // Start Only Copy Process
            if ( UNIXChar_len == -1 ) {
                UNIXChar_len = strlen ( pUNIXChar ) + 1;
            }

            if ( PCChar_len != 0 ) {
#ifdef DBCS_DIVIDE
                UCHAR *pPCCharEnd = pPCChar + PCChar_len - 1;
                if ( dStatus.nCodeSet == CODE_JPN_SJIS && dStatus.cSavedByte){
                    *pPCChar++ = dStatus.cSavedByte;
                    *pPCChar = *pUNIXChar;
                    ++UNIXChar_len;
                    ++nDelta;
                    ++i;
                    dStatus.nCodeSet = CODE_UNKNOWN;
                    dStatus.cSavedByte = '\0';
                }

                while(i < UNIXChar_len - nDelta){
                    if(IsDBCSLeadByte(*(pUNIXChar + i))){
                        if(i == UNIXChar_len - nDelta - 1){
                            dStatus.nCodeSet = CODE_JPN_SJIS;
                            dStatus.cSavedByte = *(pUNIXChar + i);
                            --UNIXChar_len;
                            break;
                        } else if((i == UNIXChar_len - nDelta - 2) &&
                                  (*(pUNIXChar + i + 1) == '\0')){
                            dStatus.nCodeSet = CODE_JPN_SJIS;
                            dStatus.cSavedByte = *(pUNIXChar + i);
                            *(pPCChar + i + 1) = '\0';
                            --UNIXChar_len;
                            break;
                        }
                        if(pPCChar + i > pPCCharEnd)  // check destination buf
                            break;
                        *(pPCChar + i++) = *(pUNIXChar + i);
                        *(pPCChar + i++) = *(pUNIXChar + i);
                    } else
                        *(pPCChar + i++) = *(pUNIXChar + i);
                }
#else
                if ( UNIXChar_len > PCChar_len ) {  // Is the buffer small?
                    return ( -1 );
                }
                memmove ( pPCChar, pUNIXChar, UNIXChar_len );
#endif
            }
#ifdef DBCS_DIVIDE
            else {   // Only retrun the required size
                if ( dStatus0.nCodeSet == CODE_JPN_SJIS ){ // 1st byte was saved
                    ++UNIXChar_len;
                    ++nDelta;
                    ++i;
                    dStatus0.nCodeSet = CODE_UNKNOWN;
                    dStatus0.cSavedByte = '\0';
                }

                while(i < UNIXChar_len - nDelta){
                    if(IsDBCSLeadByte(*(pUNIXChar + i))){
                        if(i == UNIXChar_len - nDelta - 1){
                            dStatus0.nCodeSet = CODE_JPN_SJIS;
                            dStatus0.cSavedByte = *(pUNIXChar + i);
                            --UNIXChar_len;
                            break;
                        } else if((i == UNIXChar_len - nDelta - 2) &&
                                  (*(pUNIXChar + i + 1) == '\0')){
                            dStatus0.nCodeSet = CODE_JPN_SJIS;
                            dStatus0.cSavedByte = *(pUNIXChar + i);
                            --UNIXChar_len;
                            break;
                        }
                        i+=2;
                    } else
                        i++;
                }
            }
#endif
            re = UNIXChar_len;
            break;
    }
    return ( re );
}




int WINAPI UNIX_to_PC ( int CodePage, int CodeSet,
                        UCHAR *pUNIXChar, int UNIXChar_len,
                        UCHAR *pPCChar, int PCChar_len )

// The UNIX_to_PC function convert a character string as UNIX code 
// set string to a PC code set string. 
//
// int   CodePage       Country Code Page.
//                      If this value is -1, the function use OS CodePage from 
//                      Operating System automatically.
//                      
//                      Value           Meaning
//                      -1              Auto Detect Mode.
//                      932             Japan.
//                      ???             Taiwan.
//                      ???             Korea.
//                      ???             PRC(Chaina)?
//                      
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//                      
//                      Value           Meaning
//                      CODE_UNKNOWN    Unknown. If this value is CODE_UNKNOWN,
//                                      Code Type is checked automatically. 
//                                      
//                      CODE_JPN_JIS    JIS Code Set. The function convert 
//                                      pUNIXChar string as JIS code set string
//                                      to a PC code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert 
//                                      pUNIXChar string as EUC code set string
//                                      to a PC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set. 
//
// UCHAR *pUNIXChar     Points to the character string to be converted.
//
// int   UNIXChar_len   Specifies the size in bytes of the string pointed
//                      to by the pUNIXChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pPCChar       Points to a buffer that receives the convert string
//                      from UNIX Code to PC Code.
//         
// int   PCChar_len     Specifies the size, in PC characters of the buffer
//                      pointed to by the pPCChar parameter. If the value is zero,
//                      the function returns the number of PC characters 
//                      required for the buffer, and makes no use of the pPCChar
//                      buffer.
//
// Return Value
// If the function succeeds, and PCChar_len is nonzero, the return value is the 
// number of PC characters written to the buffer pointed to by pPCChar.
//
// If the function succeeds, and PCChar_len is zero, the return value is the
// required size, in PC characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pPCChar buffer
// is small for setting converted strings.
//
//@
{
        int     re;

        if ( CodePage == -1 ) {
            CodePage = (int)GetOEMCP();
        }
        switch ( CodePage ) {
        case 932:    // Japanese Code Page
            re = JPNUNIX_to_PC ( CodeSet, pUNIXChar, UNIXChar_len,
                                           pPCChar, PCChar_len );
            break;
//      case ???:    // Taiwan Code Page
//          re = TAIWANUNIX_to_PC (,,,,,,);
//          break;
//      case ???:    // Korea Code Page
//          re = KOREAUNIX_to_PC (,,,,,,);
//          break;
//      case ???:    // PRC Code Page
//          re = PRCUNIX_to_PC (,,,,,,);
//          break;
        default:
            // Start Only Copy Process
            if ( UNIXChar_len == -1 ) {
                UNIXChar_len = strlen ( pUNIXChar ) + 1;
            }
            if ( PCChar_len != 0 ) {
                if ( UNIXChar_len > PCChar_len ) {  // Is the buffer small?
                    return ( -1 );
                }
                memmove ( pPCChar, pUNIXChar, UNIXChar_len );
            }
            re = UNIXChar_len;
            break;
        }
        return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\knfo\server\info_srv_stub.c ===
#include "info_srv.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\knfo\client\infotest.cxx ===
#include "..\..\info\client\infotest.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\knfo\client\infostub.c ===
#include "..\..\info\client\infostub.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\knfo\client\infobind.c ===
#include "..\..\info\client\infobind.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\knfo\server\makefile.inc ===
obj\$(TARGET_DIRECTORY)\main.obj: ..\..\info\server\main.cxx

obj\$(TARGET_DIRECTORY)\rpccom.obj: ..\..\info\server\rpccom.cxx

obj\$(TARGET_DIRECTORY)\rpcex.obj: ..\..\info\server\rpcex.cxx

obj\$(TARGET_DIRECTORY)\rpcsupp.obj: ..\..\info\server\rpcsupp.cxx

obj\$(TARGET_DIRECTORY)\infocomm.res: ..\..\info\server\infocomm.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\knfo\server\rpccom.cxx ===
#include "..\..\info\server\rpccom.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\knfo\server\rpcex.cxx ===
#include "..\..\info\server\rpcex.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\knfo\server\rpcperfw3.cxx ===
#include "..\..\info\server\rpcperfw3.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\knfo\server\main.cxx ===
#include "..\..\info\server\main.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\knfo\server\rpcsupp.cxx ===
#include "..\..\info\server\rpcsupp.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\knfo\server\w3data.c ===
#include "..\..\info\server\w3data.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\knfo\idl\makefile.inc ===
#
#   makefile.idl
#       Created: ???
#
#   Revision
#       MuraliK     2-March-1995 [ Eliminated absolute directory dependencies]
#
#   Specify the following in the file for use
#
#   CLIENT_DIR
#   SERVER_DIR
#   IDL_FILE_NAME   ( without the .idl suffix)
#   IDL_FLAGS       if any thing specific required
#

!INCLUDE ..\..\..\..\place.inc
!INCLUDE $(NTMAKEENV)\makefile.plt

IDL_FILE_BASENAME   = knfo

IDL_FILE_NAME   = info
IDL_FLAGS       = -ms_ext -c_ext -oldnames $(MIDL_OPTIMIZATION_NT5)
IMPORTS         = imports

CLIENT_DIR  = client
SERVER_DIR  = server

CLIENT_H    = $(O)\$(IDL_FILE_NAME)_cli.h
SERVER_H    = $(O)\$(IDL_FILE_NAME)_srv.h

CLIENT_ACF  = $(IDL_FILE_BASENAME)cli.acf
SERVER_ACF  = $(IDL_FILE_BASENAME)srv.acf

!IFNDEF  DISABLE_NET_UNICODE

UNICODE         =1
NET_C_DEFINES   = -DUNICODE
!ENDIF


SDKINC          = $(SDK_INC_PATH)
SDKCRTINC       = $(CRT_INC_PATH)

INCS            = -I. -I$(SDKINC)  -I$(SDKCRTINC) -I$(IISBASEDIR)\inc

CLIENT_STUB     = $(O)\$(IDL_FILE_NAME)_cli.c
SERVER_STUB     = $(O)\$(IDL_FILE_NAME)_srv.c

CLIENT_TARGETS  = $(CLIENT_STUB) \
                  $(CLIENT_H)
SERVER_TARGETS  = $(SERVER_STUB) \
                  $(SERVER_H)

TARGETS         = $(CLIENT_TARGETS)  $(SERVER_TARGETS)
EXTRN_DEPENDS   = $(IISBASEDIR)\inc\inetinfo.h

CLIENT_FLAGS    =  -server none -acf $(CLIENT_ACF) -header $(CLIENT_H)
SERVER_FLAGS    =  -client none -acf $(SERVER_ACF) -header $(SERVER_H)

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) $(NET_C_DEFINES)

#
#  Define output and dependencies
#


all:    $(TARGETS) $(EXTRN_DEPENDS)
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF


#
#  MIDL Compile stuff
#
$(CLIENT_TARGETS):  .\$(IDL_FILE_BASENAME).idl  $(EXTRN_DEPENDS) .\$(IMPORTS).idl \
                    .\$(IMPORTS).h .\$(CLIENT_ACF)
    midl $(IDL_FLAGS) $(CPP) $(CLIENT_FLAGS) .\$(IDL_FILE_BASENAME).idl  -cstub $(CLIENT_STUB) $(INCS)

$(SERVER_TARGETS):  .\$(IDL_FILE_BASENAME).idl  $(EXTRN_DEPENDS) .\$(IMPORTS).idl \
                    .\$(IMPORTS).h .\$(SERVER_ACF)
    midl $(IDL_FLAGS) $(CPP) $(SERVER_FLAGS) .\$(IDL_FILE_BASENAME).idl -sstub $(SERVER_STUB) $(INCS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\ksatq\atqendp.cxx ===
#include "..\atq\atqendp.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\ksatq\atqcport.cxx ===
#include "..\atq\atqcport.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\ksatq\atqmain.cxx ===
#include "..\atq\atqmain.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\ksatq\abw.cxx ===
#include "..\atq\abw.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\ksatq\auxctrs.h ===
#include "..\atq\auxctrs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\ksatq\atqbmon.cxx ===
#include "..\atq\atqbmon.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\ksatq\atqsupp.cxx ===
#include "..\atq\atqsupp.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\ksatq\atqxmit.cxx ===
#include "..\atq\atqxmit.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\ksatq\captrc.cpp ===
#include "..\atq\captrc.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\ksatq\dbgutil.h ===
#include "..\atq\dbgutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\ksatq\dllmain.cxx ===
#include "..\atq\dllmain.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\ksatq\dirmon.cpp ===
#include "..\atq\dirmon.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\ksatq\timeout.cxx ===
#include "..\atq\timeout.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\ksatq\spud.cxx ===
#include "..\atq\spud.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\ksatq\xmitnt.cxx ===
#include "..\atq\xmitnt.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\clapistb\clapistb.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      clapistb.cxx

   Abstract:
        CLAPISTB

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

#include "stdafx.h"
#include <datetime.hxx>

#define CLAPISTB_CLSID      "{08FD99D1-CFB6-11CF-BC03-00AA006111E0}"
#define CLAPISTB_NAME       "IID_CLAPI_CLIENT_STUB"
#define CLAPICLNT_NAME      "_CLAPI_CLIENT"

STDAPI
DllRegisterServer(void)
/*++

Routine Description:
    MFC register server function

Arguments:

Return Value:

--*/
{

    LONG ret = E_UNEXPECTED;
    DWORD dwDisp;
    HKEY hRoot = NULL;
    HKEY hCLSID = NULL;
    HKEY hInterface = NULL;
    HKEY hKey;
    HMODULE hModule;

    CHAR szName[MAX_PATH+1];

    //
    // open CLASSES/CLSID
    //

    if ( RegOpenKeyExA(HKEY_CLASSES_ROOT,
                    "CLSID",
                    0,
                    KEY_ALL_ACCESS,
                    &hCLSID) != ERROR_SUCCESS ) {

        goto exit;
    }

    //
    // Create the Guid and set the control name
    //

    hRoot = CreateKey(hCLSID,CLAPISTB_CLSID,CLAPISTB_NAME);

    if ( hRoot == NULL ) {
        goto exit;
    }

    //
    // InProcServer32
    //

    hModule=GetModuleHandleA("clapistb.dll");
    if (hModule == NULL) {
        goto exit;
    }

    if (GetModuleFileNameA(hModule, szName, sizeof(szName)) == 0) {
        goto exit;
    }

    hKey = CreateKey(hRoot, "InProcServer32", szName);
    if ( hKey == NULL ) {
        goto exit;
    }

    if (RegSetValueExA(hKey,
                "ThreadingModel",
                NULL,
                REG_SZ,
                (LPBYTE)"Both",
                sizeof("Both")) != ERROR_SUCCESS) {

        RegCloseKey(hKey);
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // Open CLASSES/Interface
    //

    if ( RegOpenKeyExA(HKEY_CLASSES_ROOT,
                    "Interface",
                    0,
                    KEY_ALL_ACCESS,
                    &hInterface) != ERROR_SUCCESS ) {

        goto exit;
    }

    //
    // Create the Guid and set the control name
    //

    RegCloseKey(hRoot);
    hRoot = CreateKey(hInterface,CLAPISTB_CLSID,CLAPICLNT_NAME);

    if ( hRoot == NULL ) {
        goto exit;
    }

    //
    // NumMethods
    //

    hKey = CreateKey(hRoot, "NumMethods", "9");
    if ( hKey == NULL ) {
        goto exit;
    }
    RegCloseKey(hKey);

    //
    // ProxyStubClsId
    //

    hKey = CreateKey(hRoot, "ProxyStubClsId32", CLAPISTB_CLSID);
    if ( hKey == NULL ) {
        goto exit;
    }
    RegCloseKey(hKey);

    ret = S_OK;

exit:

    if ( hInterface != NULL ) {
        RegCloseKey(hInterface);
    }

    if ( hRoot != NULL ) {
        RegCloseKey(hRoot);
    }

    if ( hCLSID != NULL ) {
        RegCloseKey(hCLSID);
    }

    return ret;

} // DllRegisterServer



STDAPI
DllUnregisterServer(
    VOID
    )
{
    HKEY hKey;

    //
    // Get CLSID handle
    //

    if ( RegOpenKeyExA(HKEY_CLASSES_ROOT,
                    "CLSID",
                    0,
                    KEY_ALL_ACCESS,
                    &hKey) != ERROR_SUCCESS ) {

        return E_UNEXPECTED;
    }

    (VOID)ZapRegistryKey(hKey,CLAPISTB_CLSID);

    RegCloseKey(hKey);

    //
    // Get Interface
    //

    if ( RegOpenKeyExA(HKEY_CLASSES_ROOT,
                    "Interface",
                    0,
                    KEY_ALL_ACCESS,
                    &hKey) != ERROR_SUCCESS ) {

        return E_UNEXPECTED;
    }

    (VOID)ZapRegistryKey(hKey,CLAPISTB_CLSID);

    RegCloseKey(hKey);
    return S_OK;

} // DllUnregisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\comlog\cofact.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :
        cofact.cxx

   Abstract:
        class factory

   Author:

       Johnson Apacible (JohnsonA)      02-April-1997


--*/

#include "precomp.hxx"
#define INITGUID
#undef DEFINE_GUID      // Added for NT 5 migration

#include "comlog.hxx"

ULONG g_dwRefCount = 0;

CINETLOGSrvFactory::CINETLOGSrvFactory(
    VOID
    )
{
    m_dwRefCount=0;
}

CINETLOGSrvFactory::~CINETLOGSrvFactory(
    VOID
    )
{
}

HRESULT
CINETLOGSrvFactory::CreateInstance(
    IUnknown *pUnkOuter,
    REFIID   riid,
    void **  ppObject
    )
{
    HRESULT hresReturn = E_NOINTERFACE;

    if (pUnkOuter != NULL) 
    {
        return CLASS_E_NOAGGREGATION;
    }

    if (m_ClsId == CLSID_InetLogPublic)
    {
        CInetLogPublic *pInetLogPublic = new CInetLogPublic();

        if( pInetLogPublic == NULL ) 
        {
            hresReturn = E_OUTOFMEMORY;
        } 
        else 
        {
            hresReturn = pInetLogPublic->QueryInterface(riid, ppObject);

            if( FAILED(hresReturn) ) 
            {
                DBGPRINTF( (DBG_CONTEXT,
                    "[CINETLOGSrvFactory::CreateInstance] no I/F\n"));
                delete pInetLogPublic;
            }
        }
    }
    else if (m_ClsId == CLSID_InetLogInformation)
    {
        CInetLogInformation *pInetLogInfo = new CInetLogInformation();

        if( pInetLogInfo == NULL ) 
        {
            hresReturn = E_OUTOFMEMORY;
        } 
        else 
        {
            hresReturn = pInetLogInfo->QueryInterface(riid, ppObject);

            if( FAILED(hresReturn) ) 
            {
                DBGPRINTF( (DBG_CONTEXT,
                    "[CINETLOGSrvFactory::CreateInstance] no I/F\n"));
                delete pInetLogInfo;
            }
        }
    }
    
    return hresReturn;
}

HRESULT
CINETLOGSrvFactory::LockServer(
    IN BOOL fLock
    )
{
    if (fLock) {
        InterlockedIncrement((long *)&g_dwRefCount);
    } else {
        InterlockedDecrement((long *)&g_dwRefCount);
    }
    return NO_ERROR;
}

HRESULT
CINETLOGSrvFactory::QueryInterface(
    REFIID riid,
    void **ppObject
    )
{
    if (riid==IID_IUnknown || riid == IID_IClassFactory) {
        *ppObject = (IClassFactory *) this;
    }
    else {
        return E_NOINTERFACE;
    }

    AddRef();
    return NO_ERROR;
}

ULONG
CINETLOGSrvFactory::AddRef(
    )
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CINETLOGSrvFactory::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}




STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    void** ppObject)
{
    *ppObject = NULL;

    if ((rclsid != CLSID_InetLogInformation) &&
        (rclsid != CLSID_InetLogPublic)
       )
    {
        DBGPRINTF( (DBG_CONTEXT, "[CINETLOGSrvFactory::DllGetClassObject] bad class\n" ) );
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    CINETLOGSrvFactory *pFactory = new CINETLOGSrvFactory;

    if( pFactory == NULL )
    {
        return E_OUTOFMEMORY;
    }

    pFactory->m_ClsId = rclsid;
    
    if (FAILED(pFactory->QueryInterface(riid, ppObject))) 
    {
        delete pFactory;
        DBGPRINTF( (DBG_CONTEXT, "[CINETLOGSrvFactory::DllGetClassObject] no I/F\n" ) );
        return E_INVALIDARG;
    }
    return NO_ERROR;
}


HRESULT
_stdcall
DllCanUnloadNow(
    VOID
    )
{

   if (g_dwRefCount != 0) {
        return S_FALSE;
    } else {
        return S_OK;
    }
} // DllCanUnloadNow


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\comlog\comlogex.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      clapiex.cpp

   Abstract:
       CLAPI external API.

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

#include "precomp.hxx"
#include "comlog.hxx"

LONG    g_ComLogInitializeCount = -1;
DWORD   g_dwDebugFlags = DEBUG_ERROR;

PLIST_ENTRY g_listComLogContexts;

#include <initguid.h>
DEFINE_GUID(IisComLogGuid, 
0x784d890E, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
DECLARE_DEBUG_PRINTS_OBJECT();


HANDLE
ComLogInitializeLog(
    LPCSTR pszInstanceName,
    LPCSTR pszMetabasePath,
    LPVOID pvIMDCOM
    )
/*++

Routine Description:
    Initialize the Log

Arguments:
    pszInstanceName - name of instance
    lpszMetabasePath - path to metabase
    pvIMDCOM - ptr to IMDCOM

Return Value:
    handle for the context object

--*/
{
    //
    // create an handle and return it

    //
    // The constructor for COMLOG_CONTEXT will add the new context to the list of contexts.
    //
    
    COMLOG_CONTEXT *pContext = new COMLOG_CONTEXT(
                                    pszInstanceName,
                                    pszMetabasePath,
                                    pvIMDCOM );

    HANDLE hHandle = (HANDLE) pContext;

    if (hHandle != NULL) {

        //
        // set up the node and put it in a queue or execute it
        //

        pContext->InitializeLog(
                        pszInstanceName,
                        pszMetabasePath,
                        pvIMDCOM );

    }

    return( hHandle );
} // ComLogInitializeLog



DWORD
ComLogTerminateLog( HANDLE hHandle )
/*++

Routine Description:
    terminate the Log

Arguments:
    handle - handle for the context object

Return Value:
    error code

--*/
{
    DWORD err = NO_ERROR;

    COMLOG_CONTEXT *pContext = (COMLOG_CONTEXT*)hHandle;

    if ( pContext == NULL ) {
        err = ERROR_INVALID_HANDLE;

    } else {

        pContext->TerminateLog();
        delete pContext;
    }

    return err;
} // ComLogTerminateLog



DWORD
ComLogDllStartup(
    VOID
    )
{
    DWORD dwThreadId;
    DWORD err;

    if ( InterlockedIncrement( &g_ComLogInitializeCount ) != 0 ) {

        DBGPRINTF((DBG_CONTEXT,
            "ComLogDllStartup [Count is %d]\n",
            g_ComLogInitializeCount));

        return(NO_ERROR);
    }

#ifdef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT("iscomlog.dll");
#else
    CREATE_DEBUG_PRINT_OBJECT("iscomlog.dll", IisComLogGuid);
#endif

    //
    // Get platform type
    //

    INITIALIZE_PLATFORM_TYPE();
    DBG_ASSERT( IISIsValidPlatform());

    INITIALIZE_CRITICAL_SECTION(&COMLOG_CONTEXT::sm_listLock);
    InitializeListHead(&COMLOG_CONTEXT::sm_ContextListHead);

    return NO_ERROR;
} // ComLogStartup


DWORD
ComLogDllCleanUp(
    VOID
    )
/*++

Routine Description:
    Clean up the Log. It will wait until the queue is empty and then it will
    terminate the queue.

Arguments:

Return Value:
    error code

--*/
{
    PLIST_ENTRY listEntry;
    COMLOG_CONTEXT* context;

    if ( InterlockedDecrement( &g_ComLogInitializeCount ) >= 0 ) {

        DBGPRINTF((DBG_CONTEXT,
            "ComLogDllCleanUp [Count is %d]\n",
            g_ComLogInitializeCount));

        return(NO_ERROR);
    }

    //
    // If we have something on the list, then the caller did not
    // cleanup properly.  Do the partial cleanup.
    //

    EnterCriticalSection( &COMLOG_CONTEXT::sm_listLock );

    for ( listEntry = COMLOG_CONTEXT::sm_ContextListHead.Flink;
          listEntry != &COMLOG_CONTEXT::sm_ContextListHead;
          listEntry = listEntry->Flink    ) {

        context = (COMLOG_CONTEXT*)CONTAINING_RECORD(
                                        listEntry,
                                        COMLOG_CONTEXT,
                                        m_ContextListEntry
                                        );

        DBGPRINTF((DBG_CONTEXT,
            "Log context %x not terminated by server %s\n",
            context, context->m_strInstanceName.QueryStr()));

        context->TerminateLog( );
    }

    LeaveCriticalSection( &COMLOG_CONTEXT::sm_listLock );

    DeleteCriticalSection(&COMLOG_CONTEXT::sm_listLock);
    DELETE_DEBUG_PRINT_OBJECT( );
    return(NO_ERROR);
}

DWORD
ComLogNotifyChange(
    HANDLE hHandle
    )
/*++

Routine Description:
    Called to notify of any change in instance metabase config

Arguments:

Return Value:
    error code

--*/
{
    DWORD err = NO_ERROR;

    COMLOG_CONTEXT *pContext = (COMLOG_CONTEXT*)hHandle;

    if ( pContext == NULL )
    {
        err = ERROR_INVALID_HANDLE;
    }
    else
    {
        pContext->NotifyChange();
    }

    return err;
}


DWORD
ComLogLogInformation(
        IN HANDLE hHandle,
        IN INETLOG_INFORMATION *pInetLogInfo
        )
/*++

Routine Description:
    Log information to the logging module

Arguments:
    hHandle - handle for the context
    pInetLogInfo - logging object

Return Value:
    error code

--*/
{
    COMLOG_CONTEXT *pContext = (COMLOG_CONTEXT*)hHandle;

    if ( pContext != NULL ) {
        pContext->LogInformation( pInetLogInfo );
        return(NO_ERROR);
    }
    return ERROR_INVALID_HANDLE;
} // ComLogLogInformation


DWORD
ComLogGetConfig(
    HANDLE hHandle,
    INETLOG_CONFIGURATIONA *ppConfig
    )
/*++

Routine Description:
    get logging configuration information

Arguments:
    hHandle - handle for the context
    ppConfig - configuration information

Return Value:
    error code

--*/
{
    DWORD err = NO_ERROR;

    COMLOG_CONTEXT *pContext = (COMLOG_CONTEXT*)hHandle;

    if ( pContext == NULL ) {
        return(ERROR_INVALID_HANDLE);
    } else {
        pContext->GetConfig(ppConfig);
    }

    return err;
}

DWORD
ComLogQueryExtraLogFields(
        HANDLE  hHandle,
        PCHAR   pBuf,
        PDWORD  pcbBuf
        )
{
    COMLOG_CONTEXT *pContext = (COMLOG_CONTEXT*)hHandle;

    if ( pContext == NULL ) {
        return(ERROR_INVALID_HANDLE);
    } else {

        pContext->QueryExtraLogFields(pcbBuf, pBuf);
    }

    return(NO_ERROR);
} // ComLogQueryExtraLogFields


DWORD
ComLogSetConfig(
        IN HANDLE hHandle,
        IN INETLOG_CONFIGURATIONA *pConfig
        )
/*++

Routine Description:
    set logging information

Arguments:
    hHandle - handle for the context
    pConfig - configuration information

Return Value:
    error code

--*/
{
    DWORD err = NO_ERROR;

    COMLOG_CONTEXT *pContext = (COMLOG_CONTEXT*)hHandle;

    if ( pContext == NULL ) 
    {
        return(ERROR_INVALID_HANDLE);
    } 
    else 
    {
        pContext->SetConfig( pConfig );
    }

    return err;
} // ComLogSetConfig


DWORD
ComLogCustomInformation(
        IN  HANDLE              hHandle,
        IN  DWORD               cCount, 
        IN  PCUSTOM_LOG_DATA    pCustomLogData,
        IN  LPSTR               szHeaderSuffix
        )
/*++

Routine Description:
    Log information to the logging module

Arguments:
    hHandle - handle for the context
    pInetLogInfo - logging object

Return Value:
    error code

--*/
{
    COMLOG_CONTEXT *pContext = (COMLOG_CONTEXT*)hHandle;

    if ( pContext != NULL ) 
    {
        pContext->LogCustomInformation( cCount, pCustomLogData, szHeaderSuffix);
        return(NO_ERROR);
    }
    return ERROR_INVALID_HANDLE;
} // ComLogCustomInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\comlog\comlog.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      clapi.cpp

   Abstract:
    CLAPI - Common logging layer

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

#include "precomp.hxx"
#include "comlog.hxx"
#include <inetsvcs.h>

DECLARE_PLATFORM_TYPE();

// by exporting DllRegisterServer, you can use regsvr.exe
#define CLAPI_PROG_ID           "CLAPI.INETLOGINFORMATION"
#define CLAPI_CLSID_KEY_NAME    "CLSID"
#define CLAPI_INPROC_SERVER     "InProcServer32"
#define CLAPI_CLSID             "{A1F89741-F619-11CF-BC0F-00AA006111E0}"

/*
#define LOGPUBLIC_PROG_ID       "MSIISLOG.MSLOGPUBLIC"
#define LOGPUBLIC_CLSID         "{FB583AC4-C361-11d1-8BA4-080009DCC2FA}"
*/
extern "C" {

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    );
}

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    )
/*++

Routine Description:

    DLL entrypoint.

Arguments:

    hDLL          - Instance handle.

    Reason        - The reason the entrypoint was called.
                    DLL_PROCESS_ATTACH
                    DLL_PROCESS_DETACH
                    DLL_THREAD_ATTACH
                    DLL_THREAD_DETACH

    Reserved      - Reserved.

Return Value:

    BOOL          - TRUE if the action succeeds.

--*/
{
    BOOL bReturn = TRUE;

    switch ( dwReason ) {

    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hDll);
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return bReturn;
} // DllEntry


STDAPI
DllRegisterServer(void)
/*++

Routine Description:
    MFC register server function

Arguments:

Return Value:

--*/
{

    LONG ret = E_UNEXPECTED;
    DWORD dwDisp;
    HKEY hProgID = NULL;
    HKEY hCLSID = NULL;
    HKEY hClapi = NULL;
    HKEY hKey;
    HMODULE hModule;

    CHAR szName[MAX_PATH+1];

    //
    // CLAPI.INETLOGINFORMATION
    //

    hProgID = CreateKey(
                    HKEY_CLASSES_ROOT,
                    CLAPI_PROG_ID,
                    CLAPI_PROG_ID);

    if ( hProgID == NULL ) {
        IIS_PRINTF((buff,"Cannot set value for key %s\n", CLAPI_PROG_ID));
        goto exit;
    }

    hCLSID = CreateKey(hProgID,
                    CLAPI_CLSID_KEY_NAME,
                    CLAPI_CLSID);

    if ( hCLSID == NULL ) {
        IIS_PRINTF((buff,"Cannot set value %s for key %s\n",
            CLAPI_CLSID_KEY_NAME, CLAPI_CLSID));
        goto exit;
    }

    RegCloseKey(hCLSID);
    hCLSID = NULL;

    //
    // CLSID
    //

    if ( RegOpenKeyExA(HKEY_CLASSES_ROOT,
                    CLAPI_CLSID_KEY_NAME,
                    0,
                    KEY_ALL_ACCESS,
                    &hCLSID) != ERROR_SUCCESS ) {

        IIS_PRINTF((buff,"Cannot open CLSID key\n"));
        goto exit;
    }

    hClapi = CreateKey(hCLSID,CLAPI_CLSID,CLAPI_PROG_ID);
    if ( hClapi == NULL ) {
        goto exit;
    }

    //
    // InProcServer32
    //

    hModule=GetModuleHandleA("iscomlog.dll");
    if (hModule == NULL) {
        IIS_PRINTF((buff,"GetModuleHandle failed with %d\n",GetLastError()));
        goto exit;
    }

    if (GetModuleFileNameA(hModule, szName, sizeof(szName))==0) {

        IIS_PRINTF((buff,
            "GetModuleFileName failed with %d\n",GetLastError()));
        goto exit;
    }

    hKey = CreateKey(hClapi,CLAPI_INPROC_SERVER,szName);

    if ( hKey == NULL ) {
        goto exit;
    }

    if (RegSetValueExA(hKey,
                "ThreadingModel",
                0,
                REG_SZ,
                (LPBYTE)"Both",
                sizeof("Both")) != ERROR_SUCCESS) {

        RegCloseKey(hKey);
        hKey = NULL;
        goto exit;
    }
    
    RegCloseKey(hKey);

    /*

    //
    // Set ProgID key
    //

    hKey = CreateKey(hClapi,"ProgID",CLAPI_PROG_ID);
    if ( hKey == NULL ) {
        goto exit;
    }

    RegCloseKey(hKey);
    ret = S_OK;

    if ( hClapi != NULL ) {
        RegCloseKey(hClapi);
        hClapi = NULL;
    }

    if ( hProgID != NULL ) {
        RegCloseKey(hProgID);
        hProgID = NULL;
    }

    if ( hCLSID != NULL ) {
        RegCloseKey(hCLSID);
        hCLSID = NULL;
    }

    //
    // MSIISLOG.MSLOGPUBLIC
    //

    
    hProgID = CreateKey(
                    HKEY_CLASSES_ROOT,
                    LOGPUBLIC_PROG_ID,
                    LOGPUBLIC_PROG_ID);

    if ( hProgID == NULL ) {
        IIS_PRINTF((buff,"Cannot set value for key %s\n", LOGPUBLIC_PROG_ID));
        goto exit;
    }

    hCLSID = CreateKey(hProgID,
                    CLAPI_CLSID_KEY_NAME,
                    LOGPUBLIC_CLSID);
                    

    if ( hCLSID == NULL ) {
        IIS_PRINTF((buff,"Cannot set value %s for key %s\n",
            CLAPI_CLSID_KEY_NAME, LOGPUBLIC_CLSID));
        goto exit;
    }

    RegCloseKey(hCLSID);
    hCLSID = NULL;

    //
    // CLSID
    //

    if ( RegOpenKeyExA(HKEY_CLASSES_ROOT,
                    CLAPI_CLSID_KEY_NAME,
                    0,
                    KEY_ALL_ACCESS,
                    &hCLSID) != ERROR_SUCCESS ) {

        IIS_PRINTF((buff,"Cannot open CLSID key\n"));
        goto exit;
    }

    hClapi = CreateKey(hCLSID,LOGPUBLIC_CLSID,LOGPUBLIC_PROG_ID);
    if ( hClapi == NULL ) {
        goto exit;
    }

    //
    // InProcServer32
    //

    hModule=GetModuleHandleA("iscomlog.dll");
    if (hModule == NULL) {
        IIS_PRINTF((buff,"GetModuleHandle failed with %d\n",GetLastError()));
        goto exit;
    }

    if (GetModuleFileNameA(hModule, szName, sizeof(szName))==0) {

        IIS_PRINTF((buff,
            "GetModuleFileName failed with %d\n",GetLastError()));
        goto exit;
    }

    hKey = CreateKey(hClapi,CLAPI_INPROC_SERVER,szName);

    if ( hKey == NULL ) {
        goto exit;
    }

    if (RegSetValueExA(hKey,
                "ThreadingModel",
                0,
                REG_SZ,
                (LPBYTE)"Both",
                sizeof("Both")) != ERROR_SUCCESS) {

        RegCloseKey(hKey);
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // Set ProgID key
    //

    hKey = CreateKey(hClapi,"ProgID",LOGPUBLIC_PROG_ID);
    if ( hKey == NULL ) {
        goto exit;
    }

    
    
    RegCloseKey(hKey);
    */
    
    ret = S_OK;

exit:

    if ( hClapi != NULL ) {
        RegCloseKey(hClapi);
        hClapi = NULL;
    }

    if ( hProgID != NULL ) {
        RegCloseKey(hProgID);
        hProgID = NULL;
    }

    if ( hCLSID != NULL ) {
        RegCloseKey(hCLSID);
        hCLSID = NULL;
    }

    return ret;

} // DllRegisterServer


STDAPI
DllUnregisterServer(
    VOID
    )
{
    LONG err;
    CHAR tmpBuf[MAX_PATH+1];

    //
    // delete CLASSES/CLAPI.INETLOGINFORMATION/CLSID
    //

    strcpy(tmpBuf,CLAPI_PROG_ID);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,CLAPI_CLSID_KEY_NAME);

    err = RegDeleteKey(HKEY_CLASSES_ROOT, tmpBuf);

    //
    // delete CLASSES/CLAPI.INETLOGINFORMATION
    //

    err = RegDeleteKey(HKEY_CLASSES_ROOT, CLAPI_PROG_ID);

    //
    // delete CLASSES/CLSID/{}/InProcServer32
    //

    strcpy(tmpBuf,CLAPI_CLSID_KEY_NAME);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,CLAPI_CLSID);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,CLAPI_INPROC_SERVER);

    err = RegDeleteKey(HKEY_CLASSES_ROOT, tmpBuf);

    //
    // delete CLASSES/CLSID/{}/ProgID
    //

    strcpy(tmpBuf,CLAPI_CLSID_KEY_NAME);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,CLAPI_CLSID);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,"ProgID");

    err = RegDeleteKey(HKEY_CLASSES_ROOT, tmpBuf);

    //
    // delete CLASSES/CLSID/{}
    //

    strcpy(tmpBuf,CLAPI_CLSID_KEY_NAME);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,CLAPI_CLSID);

    err = RegDeleteKey(HKEY_CLASSES_ROOT, tmpBuf);

    /*
    //
    // delete CLASSES/MSIISLOG.MSLOGPUBLIC/CLSID
    //

    strcpy(tmpBuf,LOGPUBLIC_PROG_ID);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,CLAPI_CLSID_KEY_NAME);

    err = RegDeleteKey(HKEY_CLASSES_ROOT, tmpBuf);

    //
    // delete CLASSES/CLAPI.INETLOGINFORMATION
    //

    err = RegDeleteKey(HKEY_CLASSES_ROOT, LOGPUBLIC_PROG_ID);

    //
    // delete CLASSES/CLSID/{}/InProcServer32
    //

    strcpy(tmpBuf,CLAPI_CLSID_KEY_NAME);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,LOGPUBLIC_CLSID);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,CLAPI_INPROC_SERVER);

    err = RegDeleteKey(HKEY_CLASSES_ROOT, tmpBuf);

    //
    // delete CLASSES/CLSID/{}/ProgID
    //

    strcpy(tmpBuf,CLAPI_CLSID_KEY_NAME);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,LOGPUBLIC_CLSID);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,"ProgID");

    err = RegDeleteKey(HKEY_CLASSES_ROOT, tmpBuf);

    //
    // delete CLASSES/CLSID/{}
    //

    strcpy(tmpBuf,CLAPI_CLSID_KEY_NAME);
    strcat(tmpBuf,TEXT("\\"));
    strcat(tmpBuf,LOGPUBLIC_CLSID);

    err = RegDeleteKey(HKEY_CLASSES_ROOT, tmpBuf);
    */
    
    return S_OK;

} // DllUnregisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\comlog\logobj.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :
        logobj.cxx

   Abstract:
        Log COM Object

   Author:

       Johnson Apacible (JohnsonA)      02-April-1997


--*/

#include "precomp.hxx"
#include "comlog.hxx"

CInetLogInformation::CInetLogInformation(
    VOID
    ):
    m_refCount              ( 0),
    m_szClientAddress       ( NULL),
    m_szServerAddress       ( NULL),
    m_szUserName            ( NULL),
    m_szOperation           ( NULL),
    m_szTarget              ( NULL),
    m_szParameters          ( NULL),
    m_szHTTPHeaders         ( NULL),
    m_szVersion             ( NULL),
    m_cbSiteName            ( 0),
    m_cbComputerName        ( 0),
    m_cbServerAddress       ( 0),
    m_cbClientAddress       ( 0),
    m_cbUserName            ( 0),
    m_cbOperation           ( 0),
    m_cbTarget              ( 0),
    m_cbParameters          ( 0),
    m_cbHTTPHeaders         ( 0),
    m_cbVersion             ( 0),
    m_dwPort                ( 0),
    m_msProcessingTime      ( 0),
    m_dwWin32Status         ( 0),
    m_dwProtocolStatus      ( 0),
    m_bytesSent             ( 0),
    m_bytesRecv             ( 0)

{
    m_szSiteName[0] = '\0';
    m_szComputerName[0] = '\0';

} // CInetLogInformation::CInetLogInformation


CInetLogInformation::~CInetLogInformation(
    VOID
    )
{

} // CInetLogInformation::~CInetLogInformation



ULONG
CInetLogInformation::AddRef(
    VOID
    )
{
    InterlockedIncrement( &m_refCount );
    return(m_refCount);
} // CInetLogInformation::AddRef


ULONG
CInetLogInformation::Release(
    VOID
    )
{
    InterlockedDecrement( &m_refCount );
    return(m_refCount);
} // CInetLogInformation::Release


HRESULT
CInetLogInformation::QueryInterface(
    REFIID riid,
    VOID **ppObj
    )
{
    if ( riid == IID_IUnknown ||
         riid == IID_IINETLOG_INFORMATION ) {

        *ppObj = (CInetLogInformation *)this;
        AddRef();
        return(NO_ERROR);
    } else {

        return(E_NOINTERFACE);
    }
} // CInetLogInformation::QueryInterface


#define RETURN_STRING_INFO( _pBuf, _pcbBuf, _pInfo, _cbInfo ) { \
    if ( (_pBuf) != NULL ) {                                    \
                                                                \
        if ( *(_pcbBuf) >= (_cbInfo) ) {                        \
            CopyMemory( _pBuf, _pInfo, _cbInfo );               \
        } else {                                                \
            *(_pcbBuf) = (_cbInfo);                             \
            return(NULL);                                       \
        }                                                       \
    }                                                           \
    *(_pcbBuf) = (_cbInfo);                                     \
    return(_pInfo);                                             \
}


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetSiteName(
    IN PCHAR    pszSiteName,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszSiteName,
            pcbSize,
            m_szSiteName,
            m_cbSiteName);

} // GetSiteName


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetComputerName(
    IN PCHAR    pszComputerName,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszComputerName,
            pcbSize,
            m_szComputerName,
            m_cbComputerName);

} // GetComputerName



LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetClientHostName(
    IN PCHAR    pszClientHostName,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszClientHostName,
            pcbSize,
            m_szClientAddress,
            m_cbClientAddress);

} // GetClientHostName


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetClientUserName(
    IN PCHAR    pszClientUserName,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszClientUserName,
            pcbSize,
            m_szUserName,
            m_cbUserName);

} // GetClientUserName


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetServerAddress(
    IN PCHAR    pszServerAddress,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszServerAddress,
            pcbSize,
            m_szServerAddress,
            m_cbServerAddress);

} // GetServerIPAddress



LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetOperation(
    IN PCHAR    pszOperation,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszOperation,
            pcbSize,
            m_szOperation,
            m_cbOperation);
} // GetOperation


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetTarget(
    IN PCHAR    pszTarget,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszTarget,
            pcbSize,
            m_szTarget,
            m_cbTarget);

} // GetTarget


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetParameters(
    IN PCHAR    pszParameters,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszParameters,
            pcbSize,
            m_szParameters,
            m_cbParameters);

} // GetParameters


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetExtraHTTPHeaders(
    IN PCHAR    pszHTTPHeaders,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszHTTPHeaders,
            pcbSize,
            m_szHTTPHeaders,
            m_cbHTTPHeaders);
} // GetExtraHTTPHeaders


DWORD STDMETHODCALLTYPE
CInetLogInformation::GetTimeForProcessing(
    VOID
    )
{
    return(m_msProcessingTime);
} // GetTimeForProcessing


DWORD STDMETHODCALLTYPE
CInetLogInformation::GetPortNumber(
    VOID
    )
{
    return(m_dwPort);
} // GetPortNumber

DWORD STDMETHODCALLTYPE
CInetLogInformation::GetBytesSent(
    VOID
    )
{
    return(m_bytesSent);
} // GetBytesSent


DWORD STDMETHODCALLTYPE
CInetLogInformation::GetBytesRecvd(
    VOID
    )
{
    return(m_bytesRecv);
} // GetBytesRecvd


DWORD STDMETHODCALLTYPE
CInetLogInformation::GetWin32Status(
    VOID
    )
{
    return(m_dwWin32Status);
} // GetWin32Status

DWORD STDMETHODCALLTYPE
CInetLogInformation::GetProtocolStatus(
    VOID
    )
{
    return(m_dwProtocolStatus);
} // GetProtocolStatus


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetVersionString(
    IN PCHAR    pszVersionString,
    IN PDWORD   pcbSize
    )
{
    RETURN_STRING_INFO(
            pszVersionString,
            pcbSize,
            m_szVersion,
            m_cbVersion);

} //GetVersionString



CHAR szNULL[] = "";
CHAR szDotDot[] = "...";

VOID
CInetLogInformation::CanonicalizeLogRecord(
        IN INETLOG_INFORMATION * pInetLogRecord,
        IN LPCSTR   pszSiteName,
        IN LPCSTR   pszComputerName,
        IN BOOL     fDefault
        )
{
    m_szClientAddress = pInetLogRecord->pszClientHostName;
    if ( m_szClientAddress == NULL ) {
        m_szClientAddress = szNULL;
        m_cbClientAddress = 0;
    } else {
        m_cbClientAddress = pInetLogRecord->cbClientHostName;
    }

    m_szOperation = pInetLogRecord->pszOperation;
    if ( m_szOperation == NULL ) {
        m_szOperation = szNULL;
        m_cbOperation = 0;
    } else {
        m_cbOperation = pInetLogRecord->cbOperation;
        if ( m_cbOperation > MAX_LOG_OPERATION_FIELD_LEN ) {
            m_cbOperation = MAX_LOG_OPERATION_FIELD_LEN;
        }
    }

    m_szTarget = pInetLogRecord->pszTarget;
    if ( m_szTarget == NULL ) {
        m_szTarget = szNULL;
        m_cbTarget = 0;
    } else {
        m_cbTarget = pInetLogRecord->cbTarget;
        if ( m_cbTarget > MAX_LOG_TARGET_FIELD_LEN ) {
            m_cbTarget = MAX_LOG_TARGET_FIELD_LEN;
        }
    }

    m_dwProtocolStatus = pInetLogRecord->dwProtocolStatus;
    m_bytesSent = pInetLogRecord->dwBytesSent;
    m_bytesRecv = pInetLogRecord->dwBytesRecvd;

    if ( fDefault ) {
        return;
    }

    strcpy( m_szSiteName, pszSiteName );
    strcpy( m_szComputerName, pszComputerName );

    m_cbSiteName = strlen(m_szSiteName);
    m_cbComputerName = strlen(m_szComputerName);

    m_szUserName = pInetLogRecord->pszClientUserName;
    if ( m_szUserName == NULL ) {
        m_szUserName = szNULL;
        m_cbUserName = 0;
    } else {
        m_cbUserName = strlen(m_szUserName);
        if ( m_cbUserName > MAX_LOG_USER_FIELD_LEN ) {
            m_cbUserName = MAX_LOG_USER_FIELD_LEN;
        }
    }

    //
    // If server IP is empty, then set it the first time
    //

    m_szServerAddress = pInetLogRecord->pszServerAddress;
    if ( m_szServerAddress == NULL ) {
        m_szServerAddress = szNULL;
        m_cbServerAddress = 0;
    } else {
        m_cbServerAddress = strlen(m_szServerAddress);
    }

    if ( pInetLogRecord->pszParameters == NULL ) {
        m_szParameters = szNULL;
        m_cbParameters = 0;
    } else {
        m_szParameters = pInetLogRecord->pszParameters;
        m_cbParameters = strlen(m_szParameters);
        if ( m_cbParameters > MAX_LOG_PARAMETER_FIELD_LEN ) {
            m_szParameters = szDotDot;
            m_cbParameters = 3;
        }
    }

    if ( pInetLogRecord->pszHTTPHeader == NULL ) {
        m_szHTTPHeaders = szNULL;
        m_cbHTTPHeaders = 0;
    } else {
        m_szHTTPHeaders = pInetLogRecord->pszHTTPHeader;
        m_cbHTTPHeaders =  pInetLogRecord->cbHTTPHeaderSize;
    }

    if ( pInetLogRecord->pszVersion == NULL ) {
        m_szVersion = szNULL;
        m_cbVersion = 0;
    } else {
        m_szVersion = pInetLogRecord->pszVersion;
        m_cbVersion = strlen(m_szVersion);
    }

    m_msProcessingTime = pInetLogRecord->msTimeForProcessing;
    m_dwWin32Status = pInetLogRecord->dwWin32Status;
    m_dwPort        = pInetLogRecord->dwPort;
    return;

} // CanonicalizeLogRecord
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\comlog\logpublic.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :
        logpublic.cxx

   Abstract:
        Public Log COM Object

   Author:

       Saurab Nog (SaurabN)      25-March-1998


--*/

#include "precomp.hxx"
#include "comlog.hxx"

CInetLogPublic::CInetLogPublic(
    VOID
    ):
    m_pContext      ( NULL),
    m_refCount      ( 0)

{
    InitializeListHead(&m_ListEntry);
    
} // CInetLogPublic::CInetLogPublic


CInetLogPublic::~CInetLogPublic(
    VOID
    )
{

} // CInetLogPublic::~CInetLogPublic


ULONG
CInetLogPublic::AddRef(
    VOID
    )
{
    DWORD dwRefCount =  InterlockedIncrement( &m_refCount );
    return(dwRefCount);
} // CInetLogPublic::AddRef


ULONG
CInetLogPublic::Release(
    VOID
    )
{
    DWORD dwRefCount =  InterlockedDecrement( &m_refCount );
    
    if (dwRefCount == 0) 
    {
        EnterCriticalSection( &COMLOG_CONTEXT::sm_listLock );
        RemoveEntryList(&m_ListEntry);
        LeaveCriticalSection( &COMLOG_CONTEXT::sm_listLock );

        delete this;
    }
    
    return(dwRefCount);
    
} // CInetLogPublic::Release


HRESULT
CInetLogPublic::QueryInterface(
    REFIID riid,
    VOID **ppObj
    )
{
    if ( riid == IID_IUnknown ||
         riid == IID_IInetLogPublic) 
    {

        *ppObj = (CInetLogPublic *)this;
        AddRef();
        return(NO_ERROR);
    } 
    else 
    {
        return(E_NOINTERFACE);
    }
} // CInetLogPublic::QueryInterface


HRESULT  
CInetLogPublic::SetLogInstance(
    LPSTR szInstance
    )
{
    PLIST_ENTRY     listEntry;
    COMLOG_CONTEXT* pContext = NULL;
    HRESULT         hr = E_FAIL;

    //
    // Search through the context list for a matching context
    //
    
    EnterCriticalSection( &COMLOG_CONTEXT::sm_listLock );

    for ( listEntry = COMLOG_CONTEXT::sm_ContextListHead.Flink;
          listEntry != &COMLOG_CONTEXT::sm_ContextListHead;
          listEntry = listEntry->Flink    ) 
    {

        pContext = (COMLOG_CONTEXT*)CONTAINING_RECORD(
                                        listEntry,
                                        COMLOG_CONTEXT,
                                        m_ContextListEntry
                                        );

        if (0 != strcmp(pContext->m_strInstanceName.QueryStr(), szInstance))
        {
            pContext = NULL;
        }
        else
        {
            break;
        }
    }

    if ( NULL != pContext)
    {
        if (NULL != m_pContext)
        {
            RemoveEntryList(&m_ListEntry);
        }
        
        m_pContext = pContext;

        InsertTailList(
                &m_pContext->m_PublicListEntry,
                &m_ListEntry
                );
                
        hr = S_OK;
    }

    LeaveCriticalSection( &COMLOG_CONTEXT::sm_listLock );
    return hr;
}

HRESULT 
CInetLogPublic::LogInformation( 
    IInetLogInformation *pLogObj 
    )
{
    if (NULL == m_pContext)
    {
        return (E_HANDLE);
    }

    m_pContext->LogInformation(pLogObj);
    return S_OK;
}
        
HRESULT 
CInetLogPublic::LogCustomInformation( 
    IN  DWORD               cCount, 
    IN  PCUSTOM_LOG_DATA    pCustomLogData,
    IN  LPSTR               szHeaderSuffix
    )
{
    if (NULL == m_pContext)
    {
        return (E_HANDLE);
    }

    m_pContext->LogCustomInformation(cCount, pCustomLogData, szHeaderSuffix);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\comlog\context.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      Context.cxx

   Abstract:
      The file contains the implementation of the Context object. A context
      job is an object which stored in the logging request queue.

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

#include "precomp.hxx"
#include "comlog.hxx"
#include "iiscnfg.h"

//
// statics
//

CRITICAL_SECTION    COMLOG_CONTEXT::sm_listLock;
LIST_ENTRY          COMLOG_CONTEXT::sm_ContextListHead;


CHAR    g_pszResFromGetComputerName [MAX_PATH] ="";

VOID
COMLOG_CONTEXT::LoadPluginModules(
    VOID
    )
/*++
Routine Description:

    load all the plugin module from the metabase

Arguments:

    None.

Return Value:

    None

--*/
{

    DWORD   cb;
    MB      mb( (IMDCOM*) m_pvIMDCOM );
    PCHAR   p;
    CLSID   clsid;
    WCHAR   buf[MAX_PATH];
    BUFFER  szLoadOrder(1024);
    PCHAR   pEnd;
    DWORD   dwLogType;
    DWORD   nPlugins = 0;

    PPLUGIN_NODE    pluginNode;

    LPUNKNOWN       punk;
    ILogPluginEx    *pComponent;
    bool            fExtended;
    HRESULT         hr ;

    //
    // get the config information from the metabase
    //

    LockExclusive( );
    
    if ( !mb.Open(m_strMetabasePath.QueryStr()) ) 
    {
        DBGPRINTF((DBG_CONTEXT,"Unable to open MB path %s[err %x]\n",
                    m_strMetabasePath.QueryStr(), GetLastError()));
                    
        goto exit;
    }

    //
    // If logging disabled, bail out
    //

    if ( mb.GetDword( "", MD_LOG_TYPE, IIS_MD_UT_SERVER, &dwLogType)) 
    {

        if ( dwLogType == MD_LOG_TYPE_DISABLED ) 
        {
            DBGPRINTF((DBG_CONTEXT,"Logging disabled\n"));
            goto exit;
        }
    }

    //
    // Read the plugin order list
    //

retry:

    cb = szLoadOrder.QuerySize( );
    
    if ( !mb.GetString( "", MD_LOG_PLUGIN_ORDER, IIS_MD_UT_SERVER, (PCHAR)szLoadOrder.QueryPtr( ), &cb )) 
    {

        DWORD err = GetLastError();

        if ( err == ERROR_INSUFFICIENT_BUFFER ) 
        {

            DBGPRINTF((DBG_CONTEXT,"Buff Too Small[%d] need[%d]\n", szLoadOrder.QuerySize(), cb ));

            if ( cb > szLoadOrder.QuerySize( ) ) 
            {
                szLoadOrder.Resize( cb );
                goto retry;
            }
        }

        DBGPRINTF((DBG_CONTEXT,"Error getting pluginOrder[err %x]\n", err));

        mb.Close();
        goto exit;
    }

    mb.Close();

    //
    // Parse it
    //

    pEnd = (PCHAR)szLoadOrder.QueryPtr( );

    for ( p = pEnd;  pEnd != NULL;  p = pEnd + 1 ) 
    {
        if ( *p == '\0' ) 
        {
            break;
        }

        //
        // pEnd will point to the next entry
        //

        pEnd = strchr(p, ',');
        
        if ( pEnd != NULL ) 
        {
            *pEnd = '\0';
        }

        //
        // p points to the CLSID
        //

        DBGPRINTF((DBG_CONTEXT,"Got Logging clsid %s\n",p));
        
        if ( !TsIsNtServer() ) 
        {

            //
            // odbc not allowed
            //

            if ( _stricmp(p,ODBCLOG_CLSID) == 0 ) 
            {
                DBGPRINTF((DBG_CONTEXT,"ODBC logging not allowed for NTW\n"));
                continue;
            }

            //
            // only ncsa allowed on Win95
            //

            if ( TsIsWindows95() ) 
            {
                if ( _stricmp(p,NCSALOG_CLSID) != 0 ) 
                {
                    DBGPRINTF((DBG_CONTEXT,"Only NCSA logging allowed for WIN95\n"));
                    continue;
                }
            }
        }

        //
        // convert string to CLSID
        //

        mbstowcs( (WCHAR *)buf, p, MAX_PATH);

        hr = CLSIDFromString( buf, &clsid );
        
        if (FAILED(hr)) 
        {
            //
            // cannot convert string
            //
            
            DBGPRINTF((DBG_CONTEXT,"Cannot convert string to CLSID: %s\n",p));
            continue;
        }

        hr = CoCreateInstance( clsid, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&punk );

        if (FAILED(hr)) 
        {
            //
            // cannot convert string
            //
            
            DBGPRINTF((DBG_CONTEXT,"Cannot create instance: %s\n",p));
            continue;
        }

        hr = punk->QueryInterface(IID_ILogPluginEx, (void **)&pComponent);

        if (SUCCEEDED(hr)) 
        {
            fExtended = true;
        }
        else
        {
            fExtended = false;

            //
            // Try getting the older interface
            //
            
            hr = punk->QueryInterface(IID_ILogPlugin, (void **)&pComponent);
        }
        
        punk->Release();

        if (FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT,"Unable to get the Extended or the Standard Plugin Interface.\n"));
            continue;
        }

        //
        // Add the component
        //

        pluginNode = (PPLUGIN_NODE)LocalAlloc( 0, sizeof(PLUGIN_NODE) );
        
        if ( pluginNode == NULL ) 
        {
            pComponent->Release( );
            continue;
        }

        pluginNode->pComponent = pComponent;
        pluginNode->fSupportsExtendedInterface = fExtended;
        
        nPlugins++;
        InsertTailList(&m_pluginList, &pluginNode->ListEntry);

        //
        // Is this the default?
        //

        if ( _stricmp(p,EXTLOG_CLSID) == 0 ) 
        {
            m_fDefault = TRUE;
            DBGPRINTF((DBG_CONTEXT,"Logging Extended[%d]\n", m_fDefault));
        }
    }

    if ( nPlugins > 1 ) 
    {
        m_fDefault = FALSE;
    }

exit:
    Unlock( );
    return;

} // COMLOG_CONTEXT::LoadPlugInModules


VOID
COMLOG_CONTEXT::ReleasePluginModules(
    VOID
    )
{
    PLIST_ENTRY     listEntry;
    PPLUGIN_NODE  pluginModule;

    LockExclusive( );

    m_fDefault = FALSE;

    while ( !IsListEmpty(&m_pluginList) ) {

        listEntry = RemoveHeadList( &m_pluginList );
        pluginModule = (PPLUGIN_NODE)CONTAINING_RECORD(
                                                listEntry,
                                                PLUGIN_NODE,
                                                ListEntry
                                                );

        pluginModule->pComponent->Release( );
        LocalFree( pluginModule );
    }

    Unlock( );
    return;
} // COMLOG_CONTEXT::ReleasePlugInModules


COMLOG_CONTEXT::COMLOG_CONTEXT(
            LPCSTR pszInstanceName,
            LPCSTR pszMetabasePath,
            LPVOID pvIMDCOM
            )
:     m_fDefault            (FALSE),
      m_pvIMDCOM            (pvIMDCOM)

/*++

Routine Description:
    Constructor for clapi context object

Arguments:
    pszInstanceName - name of the instance

Return Value:

--*/
{
    DWORD cbComputerNameSize = sizeof(g_pszResFromGetComputerName);
    LPUNKNOWN punk = NULL;
    CHAR    tmpBuf[MAX_PATH];
    MB      mb( (IMDCOM*) m_pvIMDCOM );

    InitializeListHead( &m_pluginList );
    InitializeListHead( &m_PublicListEntry);
    
    m_strInstanceName.Copy(pszInstanceName);
    m_strMetabasePath.Copy(pszMetabasePath);


    if (g_pszResFromGetComputerName[0]==0)
    {
        if ( !GetComputerName( g_pszResFromGetComputerName, &cbComputerNameSize) ) 
        {
            strcpy(g_pszResFromGetComputerName,"<Server>");
        }
    }

    m_strComputerName.Copy(g_pszResFromGetComputerName);

    //
    // Add into the global list
    //

    EnterCriticalSection( &COMLOG_CONTEXT::sm_listLock );
    InsertTailList(
            &COMLOG_CONTEXT::sm_ContextListHead,
            &m_ContextListEntry
            );

    LeaveCriticalSection( &COMLOG_CONTEXT::sm_listLock );

    //
    // Load all the plugin modules
    //

    LoadPluginModules( );

    return;

} // COMLOG_CONTEXT::COMLOG



COMLOG_CONTEXT::~COMLOG_CONTEXT()
/*++

Routine Description:
    destructor

Arguments:

Return Value:

--*/
{
    PLIST_ENTRY     listEntry;
    PInetLogPublic  pPublic;

    EnterCriticalSection( &COMLOG_CONTEXT::sm_listLock );
    LockExclusive();
    
    RemoveEntryList(&m_ContextListEntry);
    
    ReleasePluginModules();
    
    for ( listEntry = m_PublicListEntry.Flink;
          listEntry != &m_PublicListEntry;
          listEntry = listEntry->Flink    ) 
    {

        pPublic = (PInetLogPublic)CONTAINING_RECORD(
                                        listEntry,
                                        CInetLogPublic,
                                        m_ListEntry
                                        );

       pPublic->m_pContext = NULL;
    }

    Unlock();
    LeaveCriticalSection( &COMLOG_CONTEXT::sm_listLock );

} // COMLOG_CONTEXT::~COMLOG()


VOID
COMLOG_CONTEXT::LogInformation(
            PINETLOG_INFORMATION pLogInfo
            )
{

    PLIST_ENTRY listEntry;
    PPLUGIN_NODE plugin;
    CInetLogInformation inetLog;

    LockShared();

    if ( m_pluginList.Flink != &m_pluginList )
    {
        // logging is enabled
        
        inetLog.CanonicalizeLogRecord(
                                pLogInfo,
                                m_strInstanceName.QueryStr(),
                                m_strComputerName.QueryStr(),
                                m_fDefault
                                );

        for ( listEntry = m_pluginList.Flink;
              listEntry != &m_pluginList;
              listEntry = listEntry->Flink    ) 
        {

            plugin = (PPLUGIN_NODE)CONTAINING_RECORD(
                                        listEntry,
                                        PLUGIN_NODE,
                                        ListEntry
                                        );

            plugin->pComponent->LogInformation( &inetLog );
        }
    }

    Unlock();

} // COMLOG_CONTEXT::LogInformation



VOID
COMLOG_CONTEXT::LogInformation(
            IInetLogInformation *pLogObj 
            )
{

    PLIST_ENTRY listEntry;
    PPLUGIN_NODE plugin;

    LockShared();

    if ( m_pluginList.Flink != &m_pluginList )
    {
        // logging is enabled
        
        for ( listEntry = m_pluginList.Flink;
              listEntry != &m_pluginList;
              listEntry = listEntry->Flink    ) 
        {

            plugin = (PPLUGIN_NODE)CONTAINING_RECORD(
                                        listEntry,
                                        PLUGIN_NODE,
                                        ListEntry
                                        );

            plugin->pComponent->LogInformation( pLogObj );
        }
    }

    Unlock();

} // COMLOG_CONTEXT::LogInformation


VOID
COMLOG_CONTEXT::LogCustomInformation(
            IN  DWORD               cCount, 
            IN  PCUSTOM_LOG_DATA    pCustomLogData,
            IN  LPSTR               szHeaderSuffix
            )
{

    //
    // This function is supported only if the extended interface was found on the plugin
    //
    
    PLIST_ENTRY listEntry;
    PPLUGIN_NODE plugin;

    LockShared();
    
    for ( listEntry = m_pluginList.Flink;
          listEntry != &m_pluginList;
          listEntry = listEntry->Flink    ) 
    {

        plugin = (PPLUGIN_NODE)CONTAINING_RECORD(
                                        listEntry,
                                        PLUGIN_NODE,
                                        ListEntry
                                        );

        if (plugin->fSupportsExtendedInterface)
        {
            plugin->pComponent->LogCustomInformation( cCount, pCustomLogData, szHeaderSuffix);
        }
    }

    Unlock();

} // COMLOG_CONTEXT::LogCustomInformation


VOID
COMLOG_CONTEXT::NotifyChange(
            VOID
            )
{
    TerminateLog();
    ReleasePluginModules( );

    LoadPluginModules( );
    InitializeLog(
        m_strInstanceName.QueryStr(),
        m_strMetabasePath.QueryStr(),
        (CHAR*)m_pvIMDCOM
        );

} // COMLOG_CONTEXT::NotifyChange



VOID
COMLOG_CONTEXT::GetConfig(
    IN INETLOG_CONFIGURATIONA *pConfigInfo
    )
{
    //
    // just return the first configuration information
    //

    PLIST_ENTRY listEntry;
    PPLUGIN_NODE plugin;

    LockShared( );
    for ( listEntry = m_pluginList.Flink;
          listEntry != &m_pluginList;
          listEntry = listEntry->Flink    ) {

        plugin = (PPLUGIN_NODE)CONTAINING_RECORD(
                                        listEntry,
                                        PLUGIN_NODE,
                                        ListEntry
                                        );

        plugin->pComponent->GetConfig(
                            sizeof(INETLOG_CONFIGURATIONA),
                            (BYTE *)pConfigInfo);

        Unlock( );
        return;
    }

    //
    // No Log
    //

    Unlock( );
    pConfigInfo->inetLogType = INET_LOG_DISABLED;
    return;
} // GetConfig


VOID
COMLOG_CONTEXT::SetConfig(
    IN INETLOG_CONFIGURATIONA *pConfigInfo
    )
{
    //
    // check the log type and call the proper setconfig function
    //

    MB      mb( (IMDCOM*) m_pvIMDCOM );

    //
    // NTW and win95 restrictions
    //

    if ( (pConfigInfo->inetLogType == INET_LOG_TO_SQL) &&
         !TsIsNtServer() ) {
        return;
    }

    if ( !mb.Open( m_strMetabasePath.QueryStr(),
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        return;
    }

    //
    // Release all
    //

    ReleasePluginModules( );

    switch (pConfigInfo->inetLogType) {

        case INET_LOG_TO_FILE:
            switch (pConfigInfo->u.logFile.ilFormat) {

            case INET_LOG_FORMAT_INTERNET_STD:

                mb.SetString("",
                             MD_LOG_PLUGIN_ORDER,
                             IIS_MD_UT_SERVER,
                             ASCLOG_CLSID );
                break;

            case INET_LOG_FORMAT_NCSA:
                mb.SetString("",
                             MD_LOG_PLUGIN_ORDER,
                             IIS_MD_UT_SERVER,
                             NCSALOG_CLSID );
                break;

            case INET_LOG_FORMAT_EXTENDED:
                mb.SetString("",
                             MD_LOG_PLUGIN_ORDER,
                             IIS_MD_UT_SERVER,
                             EXTLOG_CLSID );
                mb.SetDword( "",
                        MD_LOGEXT_FIELD_MASK,
                        IIS_MD_UT_SERVER,
                        pConfigInfo->u.logFile.dwFieldMask );
                break;

            default:
                DBGPRINTF((DBG_CONTEXT,"SetConfig: Invalid Format type %d\n",
                    pConfigInfo->inetLogType));
                goto no_log;
            }

            mb.SetDword( "",
                    MD_LOGFILE_PERIOD,
                    IIS_MD_UT_SERVER,
                    pConfigInfo->u.logFile.ilPeriod );

            if (pConfigInfo->u.logFile.ilPeriod == INET_LOG_PERIOD_NONE ) {
                mb.SetDword( "",
                    MD_LOGFILE_TRUNCATE_SIZE,
                    IIS_MD_UT_SERVER, pConfigInfo->
                    u.logFile.cbSizeForTruncation );
            }

            mb.SetString( "",
                MD_LOGFILE_DIRECTORY,
                IIS_MD_UT_SERVER,
                pConfigInfo->u.logFile.rgchLogFileDirectory );

            mb.SetDword( "",
                    MD_LOG_TYPE,
                    IIS_MD_UT_SERVER,
                    MD_LOG_TYPE_ENABLED );

            break;

        case INET_LOG_TO_SQL:

            mb.SetString("",
                         MD_LOG_PLUGIN_ORDER,
                         IIS_MD_UT_SERVER,
                         ODBCLOG_CLSID );

            mb.SetString( "",
                          MD_LOGSQL_DATA_SOURCES,
                          IIS_MD_UT_SERVER,
                          pConfigInfo->u.logSql.rgchDataSource );

            mb.SetString( "",
                          MD_LOGSQL_TABLE_NAME,
                          IIS_MD_UT_SERVER,
                          pConfigInfo->u.logSql.rgchTableName );

            mb.SetString( "",
                          MD_LOGSQL_USER_NAME,
                          IIS_MD_UT_SERVER,
                          pConfigInfo->u.logSql.rgchUserName );

            mb.SetString( "",
                          MD_LOGSQL_PASSWORD,
                          IIS_MD_UT_SERVER,
                          pConfigInfo->u.logSql.rgchPassword,
                          METADATA_INHERIT|METADATA_SECURE );

            mb.SetDword( "",
                    MD_LOG_TYPE,
                    IIS_MD_UT_SERVER,
                    MD_LOG_TYPE_ENABLED );

            break;

        case INET_LOG_DISABLED:
        default:
            goto no_log;
    }

exit:
    mb.Save();
    mb.Close();
    return;

no_log:

    mb.SetString( "",
            MD_LOG_PLUGIN_ORDER,
            IIS_MD_UT_SERVER,
            ""
            );

    mb.SetDword( "",
            MD_LOG_TYPE,
            IIS_MD_UT_SERVER,
            MD_LOG_TYPE_DISABLED );

    goto exit;

} // COMLOG_CONTEXT::SetConfig


VOID
COMLOG_CONTEXT::QueryExtraLogFields(
                PDWORD pcbSize,
                PCHAR  pszLogFields
                )
{

    PLIST_ENTRY listEntry;
    PPLUGIN_NODE plugin;

    LockShared( );
    for ( listEntry = m_pluginList.Flink;
          listEntry != &m_pluginList;
          listEntry = listEntry->Flink    ) {

        plugin = (PPLUGIN_NODE)CONTAINING_RECORD(
                                        listEntry,
                                        PLUGIN_NODE,
                                        ListEntry
                                        );

        plugin->pComponent->QueryExtraLoggingFields(
                                        pcbSize,
                                        pszLogFields
                                        );

        //
        // handle just the 1st component
        //

        Unlock( );
        return;
    }

    Unlock( );

    *pcbSize = 0;
    *pszLogFields = '\0';
    return;

} // COMLOG_CONTEXT::QueryExtraLogFields




VOID
COMLOG_CONTEXT::InitializeLog(
        LPCSTR pszInstanceName,
        LPCSTR pszMetabasePath,
        LPVOID pvIMDCOM
        )
{
    PLIST_ENTRY listEntry;
    PPLUGIN_NODE plugin;

    LockExclusive();

    for ( listEntry = m_pluginList.Flink;
          listEntry != &m_pluginList;
          listEntry = listEntry->Flink    ) {

        plugin = (PPLUGIN_NODE)CONTAINING_RECORD(
                                        listEntry,
                                        PLUGIN_NODE,
                                        ListEntry
                                        );

        plugin->pComponent->InitializeLog(
                                pszInstanceName,
                                pszMetabasePath,
                                (PCHAR)m_pvIMDCOM
                                );

        if ( m_fDefault ) {

            INETLOG_CONFIGURATIONA  config;
            m_fDefault = FALSE;
            if ( plugin->pComponent->GetConfig(
                                    sizeof(config),
                                    (PBYTE)&config ) ) {

                if ( (config.u.logFile.ilFormat ==
                                INET_LOG_FORMAT_EXTENDED)
                                &&
                     (config.u.logFile.dwFieldMask ==
                                DEFAULT_EXTLOG_FIELDS) ) {

                    m_fDefault = TRUE;
                }
            }
        }

    }

    Unlock();

} // COMLOG_CONTEXT::InitializeLog


VOID
COMLOG_CONTEXT::TerminateLog(
    VOID
    )
{
    PLIST_ENTRY listEntry;
    PPLUGIN_NODE plugin;

    LockExclusive( );
    for ( listEntry = m_pluginList.Flink;
          listEntry != &m_pluginList;
          listEntry = listEntry->Flink    ) {

        plugin = (PPLUGIN_NODE)CONTAINING_RECORD(
                                        listEntry,
                                        PLUGIN_NODE,
                                        ListEntry
                                        );

        plugin->pComponent->TerminateLog( );
    }

    Unlock( );

} // COMLOG_CONTEXT::TerminateLog
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\inetlog\cinetlog.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      cinetlog.c

   Abstract:
        CINETLOG

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN            // Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for OLE Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>                      // MFC database classes
#include <afxdao.h>                     // MFC DAO database classes
#endif //_UNICODE

//#include <compobj.h>

extern "C"
{
#include "inetcom.h"
}

#include <datetime.hxx>

#define CINETLOG_CLSID      "{cc557a71-f61a-11cf-bc0f-00aa006111e0}"
#define CINETLOG_NAME       "IID_IINETLOG_INFORMATION_PSFactory"
#define CINETLOG_CLNT_NAME  "IID_IINETLOG_INFORMATION"

STDAPI
DllRegisterServer(void)
/*++

Routine Description:
    MFC register server function

Arguments:

Return Value:

--*/
{

    LONG ret = E_UNEXPECTED;
    DWORD dwDisp;
    HKEY hRoot = NULL;
    HKEY hCLSID = NULL;
    HKEY hInterface = NULL;
    HKEY hKey;
    HMODULE hModule;

    CHAR szName[MAX_PATH+1];

    //
    // open CLASSES/CLSID
    //

    if ( RegOpenKeyExA(HKEY_CLASSES_ROOT,
                    "CLSID",
                    0,
                    KEY_ALL_ACCESS,
                    &hCLSID) != ERROR_SUCCESS ) {

        goto exit;
    }

    //
    // Create the Guid and set the control name
    //

    hRoot = CreateKey(hCLSID,CINETLOG_CLSID,CINETLOG_NAME);

    if ( hRoot == NULL ) {
        goto exit;
    }

    //
    // InProcServer32
    //

    hModule=GetModuleHandleA("cinetlog.dll");
    if (hModule == NULL) {
        goto exit;
    }

    if (GetModuleFileNameA(hModule, szName, sizeof(szName)) == 0) {
        goto exit;
    }

    hKey = CreateKey(hRoot, "InProcServer32", szName);
    if ( hKey == NULL ) {
        goto exit;
    }

    if (RegSetValueExA(hKey,
                "ThreadingModel",
                NULL,
                REG_SZ,
                (LPBYTE)"Both",
                sizeof("Both")) != ERROR_SUCCESS) {

        RegCloseKey(hKey);
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // Open CLASSES/Interface
    //

    if ( RegOpenKeyExA(HKEY_CLASSES_ROOT,
                    "Interface",
                    0,
                    KEY_ALL_ACCESS,
                    &hInterface) != ERROR_SUCCESS ) {

        goto exit;
    }

    //
    // Create the Guid and set the control name
    //

    RegCloseKey(hRoot);
    hRoot = CreateKey(hInterface,CINETLOG_CLSID,CINETLOG_CLNT_NAME);

    if ( hRoot == NULL ) {
        goto exit;
    }

    //
    // ProxyStubClsId
    //

    hKey = CreateKey(hRoot, "ProxyStubClsId32", CINETLOG_CLSID);
    if ( hKey == NULL ) {
        goto exit;
    }
    RegCloseKey(hKey);

    ret = S_OK;

exit:

    if ( hInterface != NULL ) {
        RegCloseKey(hInterface);
    }

    if ( hRoot != NULL ) {
        RegCloseKey(hRoot);
    }

    if ( hCLSID != NULL ) {
        RegCloseKey(hCLSID);
    }

    return ret;

} // DllRegisterServer



STDAPI
DllUnregisterServer(
    VOID
    )
{
    HKEY hKey;

    //
    // Get CLSID handle
    //

    if ( RegOpenKeyExA(HKEY_CLASSES_ROOT,
                    "CLSID",
                    0,
                    KEY_ALL_ACCESS,
                    &hKey) != ERROR_SUCCESS ) {

        return E_UNEXPECTED;
    }

    ZapRegistryKey(hKey,CINETLOG_CLSID);

    RegCloseKey(hKey);

    //
    // Get Interface
    //

    if ( RegOpenKeyExA(HKEY_CLASSES_ROOT,
                    "Interface",
                    0,
                    KEY_ALL_ACCESS,
                    &hKey) != ERROR_SUCCESS ) {

        return E_UNEXPECTED;
    }

    ZapRegistryKey(hKey,CINETLOG_CLSID);

    RegCloseKey(hKey);
    return S_OK;

} // DllUnregisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\const.h ===
#ifndef _CONST_H_
#define _CONST_H_

#include <lmcons.h>
#include "inetcom.h"

//
// Default values for Logging related registry parameters
//

#define   DEFAULT_LOG_FILE_DIRECTORY_NT             "%systemroot%\\system32\\LogFiles"
#define   DEFAULT_LOG_FILE_DIRECTORY_W95            "%windir%\\system\\LogFiles"
#define   DEFAULT_LOG_FILE_TRUNCATE_SIZE            NO_FILE_TRUNCATION
#define   DEFAULT_LOG_FILE_PERIOD                   INET_LOG_PERIOD_DAILY
#define   DEFAULT_LOG_SQL_DATASOURCE                "InternetDb"
#define   DEFAULT_LOG_SQL_TABLE                     "InternetLog"
#define   DEFAULT_LOG_SQL_USER_NAME                 "InternetAdmin"
#define   DEFAULT_LOG_SQL_PASSWORD                  ""

#define DEFAULT_LOG_FILE_NAME                      "inetsvcs"
#define DEFAULT_EXTENDED_LOG_FILE_NAME             "extended"
#define DEFAULT_NCSA_LOG_FILE_NAME                 "ncsa"
#define DEFAULT_LOG_FILE_EXTENSION                 "log"

#define DEFAULT_DELIMITER_CHAR_IN_LOG_RECORD        ','

#endif  // _CONST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\cofact.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :
        cofact.cxx

   Abstract:
        class factory

   Author:

       Johnson Apacible (JohnsonA)      02-April-1997


--*/

#include "precomp.hxx"


CComModule _Module;

STDAPI
DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    void** ppObject)
{
    HRESULT hr;

    hr = _Module.GetClassObject(rclsid, riid, ppObject);

    return hr;
}


STDAPI
DllCanUnloadNow(
    VOID
    )
{

	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
} // DllCanUnloadNow
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\dynodbc.cxx ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    dynodbc.c

Abstract:

    This module provides functions for dynamically loading the ODBC
       functions.

Author:

    Murali R. Krishnan  (MuraliK)  3-Nov-1995

Revision History:

--*/


#include "precomp.hxx"

extern "C"
{
# include "dynodbc.h"
}

//
//  ODBC DLL Entry Points, fill by calling LoadODBC
//

pfnSQLAllocConnect        pSQLAllocConnect   ;
pfnSQLAllocEnv            pSQLAllocEnv       ;
pfnSQLAllocStmt           pSQLAllocStmt      ;
pfnSQLBindCol             pSQLBindCol        ;
pfnSQLCancel              pSQLCancel         ;
pfnSQLColAttributes       pSQLColAttributes  ;
pfnSQLConnect             pSQLConnect        ;
pfnSQLDescribeCol         pSQLDescribeCol    ;
pfnSQLDisconnect          pSQLDisconnect     ;
pfnSQLError               pSQLError          ;
pfnSQLExecDirect          pSQLExecDirect     ;
pfnSQLExecute             pSQLExecute        ;
pfnSQLFetch               pSQLFetch          ;
pfnSQLFreeConnect         pSQLFreeConnect    ;
pfnSQLFreeEnv             pSQLFreeEnv        ;
pfnSQLFreeStmt            pSQLFreeStmt       ;
pfnSQLGetCursorName       pSQLGetCursorName  ;
pfnSQLNumResultCols       pSQLNumResultCols  ;
pfnSQLPrepare             pSQLPrepare        ;
pfnSQLRowCount            pSQLRowCount       ;
pfnSQLSetCursorName       pSQLSetCursorName  ;
pfnSQLTransact            pSQLTransact       ;

pfnSQLSetConnectOption    pSQLSetConnectOption;
pfnSQLDrivers             pSQLDrivers         ;
pfnSQLDataSources         pSQLDataSources     ;
pfnSQLBindParameter       pSQLBindParameter   ;
pfnSQLGetInfo             pSQLGetInfo        ;
pfnSQLMoreResults         pSQLMoreResults    ;



# define ODBC_MODULE_NAME             "odbc32.dll"

#define LOAD_ENTRY( hMod, Name )  \
   (p##Name = (pfn##Name) GetProcAddress( (hMod), #Name ))


static BOOL  s_fODBCLoaded = FALSE;

HMODULE g_hODBC = NULL;


BOOL
DynLoadODBC(
    VOID
    )
{
    HMODULE hMod;

    if ( s_fODBCLoaded ) {
        return TRUE;
    }

    if ( (hMod = (HMODULE) LoadLibrary( ODBC_MODULE_NAME ))) {

        if (LOAD_ENTRY( hMod, SQLAllocConnect   )  &&
            LOAD_ENTRY( hMod, SQLAllocEnv       )  &&
            LOAD_ENTRY( hMod, SQLAllocStmt      )  &&
            LOAD_ENTRY( hMod, SQLBindCol        )  &&
            LOAD_ENTRY( hMod, SQLCancel         )  &&
            LOAD_ENTRY( hMod, SQLColAttributes  )  &&
            LOAD_ENTRY( hMod, SQLConnect        )  &&
            LOAD_ENTRY( hMod, SQLDescribeCol    )  &&
            LOAD_ENTRY( hMod, SQLDisconnect     )  &&
            LOAD_ENTRY( hMod, SQLError          )  &&
            LOAD_ENTRY( hMod, SQLExecDirect     )  &&
            LOAD_ENTRY( hMod, SQLExecute        )  &&
            LOAD_ENTRY( hMod, SQLFetch          )  &&
            LOAD_ENTRY( hMod, SQLFreeConnect    )  &&
            LOAD_ENTRY( hMod, SQLFreeEnv        )  &&
            LOAD_ENTRY( hMod, SQLFreeStmt       )  &&
            LOAD_ENTRY( hMod, SQLNumResultCols  )  &&
            LOAD_ENTRY( hMod, SQLPrepare        )  &&
            LOAD_ENTRY( hMod, SQLRowCount       )  &&
            LOAD_ENTRY( hMod, SQLTransact       )  &&
            LOAD_ENTRY( hMod, SQLSetConnectOption )  &&
            LOAD_ENTRY( hMod, SQLDrivers        )  &&
            LOAD_ENTRY( hMod, SQLDataSources    )  &&
            LOAD_ENTRY( hMod, SQLGetInfo        )  &&
            LOAD_ENTRY( hMod, SQLBindParameter  )  &&
            LOAD_ENTRY( hMod, SQLMoreResults    ) ) {

            s_fODBCLoaded = TRUE;
            g_hODBC = hMod;

        } else {
            FreeLibrary(hMod);
        }
    }

    return (s_fODBCLoaded);

} // DynLoadODBC()


VOID
DynUnloadODBC(
    VOID
    )
{
    if ( !s_fODBCLoaded ) {
        return;
    }

    FreeLibrary( g_hODBC );
    s_fODBCLoaded = FALSE;
    g_hODBC = NULL;

    return;

} // DynUnloadODBC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\global.h ===
#ifndef _GLOBAL_H_
#define _GLOBAL_H_

#include <inetsvcs.h>

DWORD
WeekOfMonth(
    IN LPSYSTEMTIME pstNow
    );

BOOL IsBeginningOfNewPeriod(
    IN DWORD          dwPeriod,
    IN LPSYSTEMTIME   pstCurrentFile,
    IN LPSYSTEMTIME   pstNow
    );

VOID
ConvertSpacesToPlus(
    IN LPSTR    pszString
    );

extern LPEVENT_LOG    g_eventLog;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\extlogc.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :
      ExtLogC.cpp

   Abstract:
      W3C Extended LogFile Format Implementation

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

#include "precomp.hxx"
#include <stdio.h>
#include "ilogobj.hxx"
#include "script.h"
#include "LogScript.hxx"
#include "filectl.hxx"
#include "lkrhash.h"
#include "iisver.h"
#include "iis64.h"

#include "extlogc.hxx"

const CHAR  szExtNoPeriodPattern[]  = "extend*.log";
const CHAR  G_PSZ_DELIMITER[2]      = { ' ', '\0'};

CHAR        szDotDot[]              = "...";
CHAR        szDash  []              = "-";
CHAR        szHTTPOk[]              = "200\r\n";

CCustomPropHashTable   *g_pGlobalLoggingProperties=NULL;


/* ************************************************************************************ */
/* Helper functions                                                                     */
/* ************************************************************************************ */

inline VOID
BuildHeader(
    IN OUT  STR *   strHeader,
    IN      DWORD   dwMask,
    IN      DWORD   dwField,
    IN      LPCSTR  szFieldHeader
)
{
    if (dwMask & dwField)
    {
        strHeader->Append(szFieldHeader);
        strHeader->Append(' ');
    }
}

/* ************************************************************************************ */

inline BOOL
CopyFieldToBuffer(
    IN PCHAR        Field,
    IN DWORD        FieldSize,
    IN PCHAR *      ppchOutBuffer,
    IN OUT PDWORD   SpaceNeeded,
    IN DWORD        SpaceProvided
    )
{
    if ( 0 == FieldSize ) 
    {
        Field = "-";
        FieldSize = 1;
    }

    //
    // Remove the NULL terminator
    //

    (*SpaceNeeded) += FieldSize + 1;          // +1 for trailing space

    if ( (*SpaceNeeded) <= SpaceProvided ) 
    {
        CopyMemory( (*ppchOutBuffer), Field, FieldSize );
        (*ppchOutBuffer) += FieldSize;
        (**ppchOutBuffer) = ' ';
        (*ppchOutBuffer)++;
        
        return(TRUE);
    }
    
    return FALSE;

} // CopyFieldToBuffer

/* ************************************************************************************ */

inline BOOL WriteHTTPHeader(
    IN OUT PCHAR *  ppchHeader,
    IN     PCHAR *  ppchOutBuffer,
    IN OUT PDWORD   SpaceNeeded,
    IN     DWORD    SpaceProvided
    )
{
    DWORD cbTmp = 0;                                                                              
                                                                                                    
    if ( (NULL != ppchHeader ) && ( NULL != *ppchHeader))                                                                    
    {   

        CHAR * pTmp = *ppchHeader;
        
        cbTmp       = strlen(pTmp);                                                               
        *ppchHeader = pTmp + cbTmp + 1;                                                           
                                                                                                    
        if ((cbTmp > MAX_LOG_TARGET_FIELD_LEN ) || 
            (((*SpaceNeeded)+cbTmp) > MAX_LOG_RECORD_LEN)
           ) 
        {                                                                                   
            pTmp  = szDotDot;                                                               
            cbTmp = 3;                                                                      
        }                                                                                   
        else
        {                                                                                   
            ConvertSpacesToPlus(pTmp);                                                      
        }                                                                                   

        return CopyFieldToBuffer( pTmp, cbTmp, ppchOutBuffer, SpaceNeeded, SpaceProvided);       
    }                                                                                       

    return FALSE;
}

/* ************************************************************************************ */
/* CCustomPropHashTable Class                                                           */
/* ************************************************************************************ */


VOID
CCustomPropHashTable::ClearTableAndStorage()
{
    
    //
    // Clear the Hash Table & free any previous LOG_PROPERTY_INFO entries
    //
    
    Clear();
    
    if (NULL != m_pLogPropArray)
    {
        delete [] m_pLogPropArray;
        m_pLogPropArray = NULL;
    }
    m_cLogPropItems = 0;
    
}



BOOL CCustomPropHashTable::InitializeFromMB (MB &mb,const char *path)
{
    BOOL retVal = TRUE;
    if (!m_fInitialized)
    {
        if (mb.Open(path))
        {
            retVal = m_fInitialized = FillHashTable(mb);
            mb.Close();
        }
        else
        {
            retVal = FALSE;
        }
    }
    return retVal;
}


BOOL
CCustomPropHashTable::PopulateHash(MB& mb, LPCSTR szPath, DWORD& cItems, bool fCountOnly)
{
    BOOL retVal = TRUE;

    //
    // Retrieve all required fields for all Custom Properties and store in the hash table.
    //

    int    index    = 0;
    
    CHAR   szChildName[256];
    CHAR   szW3CHeader[256] = "";
    
    STR    strNewPath;

    while( mb.EnumObjects(szPath, szChildName, index) )
    {
        DWORD   size;
        DWORD   dwPropertyID, dwPropertyMask, dwPropertyDataType;
        LPCSTR  szNewPath;
        

        //
        // Create the new path.
        //

        if ((NULL != szPath) && ( '\0' != *szPath))
        {
            if ( !(strNewPath.Copy(szPath) &&
                   strNewPath.Append("/") &&
                   strNewPath.Append(szChildName)) )
            {
                retVal = FALSE;
                break;
            }
        }
        else
        {
            if ( !strNewPath.Copy(szChildName) )
            {
                retVal = FALSE;
                break;
            }
        }
        
        szNewPath = strNewPath.QueryStr();
        
        //
        // Copy configuration information into internal structures 
        //

        szW3CHeader[0] = 0;
        size = 256;

        if ( mb.GetString( szNewPath, MD_LOGCUSTOM_PROPERTY_HEADER, IIS_MD_UT_SERVER, 
                                szW3CHeader, &size)     &&
             mb.GetDword( szNewPath, MD_LOGCUSTOM_PROPERTY_ID, IIS_MD_UT_SERVER, 
                                &dwPropertyID)          &&
             mb.GetDword( szNewPath, MD_LOGCUSTOM_PROPERTY_MASK, IIS_MD_UT_SERVER, 
                                &dwPropertyMask)        &&
             mb.GetDword( szNewPath, MD_LOGCUSTOM_PROPERTY_DATATYPE, IIS_MD_UT_SERVER, 
                                &dwPropertyDataType)

            )
        {
            if (! fCountOnly)
            {
                PLOG_PROPERTY_INFO pRec = &m_pLogPropArray[cItems];

                if ( ! (pRec->strKeyPath.Copy(szNewPath) &&
                        pRec->strW3CHeader.Copy(szW3CHeader)) )
                {
                    retVal = FALSE;
                    break;
                }
            
                pRec->dwPropertyID         = dwPropertyID;
                pRec->dwPropertyMask       = dwPropertyMask;
                pRec->dwPropertyDataType   = dwPropertyDataType;

                if (LK_SUCCESS != InsertRecord(pRec))
                {
                    DBGPRINTF((DBG_CONTEXT, "PopulateHash: Unable to insert Property %s\n", pRec->strKeyPath.QueryStr()));
                    retVal = FALSE;
                    break;
                }
            }

            cItems++;
        }

        //
        // Enumerate children
        //

        if (!PopulateHash(mb, szNewPath, cItems, fCountOnly))
        {
            retVal = FALSE;
            break;
        }
        index++;
    }
    return retVal;
}

/* ************************************************************************************ */

BOOL
CCustomPropHashTable::FillHashTable(MB& mb)
{
    BOOL retVal = FALSE;
    DWORD cItems = 0;

    //
    // Find out the number of items in the Custom Logging Tree
    //

    if (PopulateHash(mb, NULL, cItems, true))
    {

        ClearTableAndStorage ();
    
        if (cItems)
        {
            m_pLogPropArray = new LOG_PROPERTY_INFO[cItems];

            if ( NULL != m_pLogPropArray)
            {
                m_cLogPropItems = cItems;
                cItems = 0;
                if ( !(retVal = PopulateHash(mb, NULL, cItems, false)))
                {
                    ClearTableAndStorage ();
                }
                DBG_ASSERT(m_cLogPropItems == cItems);
            }
        }
    }
    return retVal;
}

/* ************************************************************************************ */

VOID
CCustomPropHashTable::SetPopulationState(MB& mb)
{
    CIterator   iter;
    DWORD       dwValue;
    
    LK_RETCODE  lkrc = InitializeIterator(&iter);

    while (LK_SUCCESS == lkrc)
    {
        Record* pRec = iter.Record();
        
        if ( mb.GetDword("", pRec->dwPropertyID, IIS_MD_UT_SERVER, &dwValue) &&
            (dwValue & pRec->dwPropertyMask))
        {
            pRec->fEnabled = TRUE;
        }
        else
        {
            pRec->fEnabled = FALSE;
        }
        
        lkrc = IncrementIterator(&iter);
    }

    CloseIterator(&iter);
}


BOOL
CCustomPropHashTable::InitFrom(CCustomPropHashTable& src)
{
    CIterator   iter;
    DWORD       dwValue, i;
    BOOL        retVal = FALSE;

    ClearTableAndStorage ();

    if (src.m_cLogPropItems)
    {
        m_pLogPropArray = new LOG_PROPERTY_INFO[src.m_cLogPropItems];

        if ( NULL != m_pLogPropArray)
        {
            m_cLogPropItems = src.m_cLogPropItems;
            retVal = TRUE;
            for (i=0; i<m_cLogPropItems;i++)
            {
                PLOG_PROPERTY_INFO pRec = &m_pLogPropArray[i];
                PLOG_PROPERTY_INFO pRecOriginal = &src.m_pLogPropArray[i];

                if ( pRec->strKeyPath.Copy(pRecOriginal->strKeyPath) &&
                     pRec->strW3CHeader.Copy(pRecOriginal->strW3CHeader) )
                {
                    pRec->dwPropertyID         = pRecOriginal->dwPropertyID;
                    pRec->dwPropertyMask       = pRecOriginal->dwPropertyMask;
                    pRec->dwPropertyDataType   = pRecOriginal->dwPropertyDataType;

                    if (LK_SUCCESS != InsertRecord(pRec))
                    {
                        DBGPRINTF((DBG_CONTEXT, "InitFrom: Unable to insert Property %s\n", pRec->strKeyPath.QueryStr()));
                        retVal = FALSE;
                        break;
                    }
                }
                else
                {
                    retVal = FALSE;
                    break;
                }
            }
        }
    }

    return retVal;
}


/* ************************************************************************************ */
/* CEXTLOG Class                                                                        */
/* ************************************************************************************ */

CEXTLOG::CEXTLOG() :
    m_lMask                     (DEFAULT_EXTLOG_FIELDS),
    m_fHashTablePopulated       ( FALSE),
    m_fWriteHeadersInitialized  ( FALSE),
    m_cPrevCustLogItems         ( 0),
    m_pLogFields                ( NULL ),
    m_fUseLocalTimeForRollover  ( 0),
    m_pLocalTimeCache           ( NULL)
{
    if ( !g_pGlobalLoggingProperties)
    {
        g_pGlobalLoggingProperties =  new CCustomPropHashTable;
    }
    else
    {
        g_pGlobalLoggingProperties->AddRef();
    }
}

/* ************************************************************************************ */

CEXTLOG::~CEXTLOG()
{
    m_HashTable.ClearTableAndStorage ();

    if ( NULL != m_pLocalTimeCache)
    {
        delete m_pLocalTimeCache;
        m_pLocalTimeCache = NULL;
    }
    
    if (NULL != m_pLogFields)
    {
        delete [] m_pLogFields;
        m_pLogFields = NULL;
    }
    if ( g_pGlobalLoggingProperties)
    {
        if ( g_pGlobalLoggingProperties->Release () == 0)
        {
            delete g_pGlobalLoggingProperties;
            g_pGlobalLoggingProperties = NULL;
        }
    }
}


/* ************************************************************************************ */

STDMETHODIMP
CEXTLOG::InitializeLog(
                LPCSTR szInstanceName,
                LPCSTR pszMetabasePath,
                CHAR*  pvIMDCOM
                )
{
    HRESULT retVal = RETURNCODETOHRESULT ( MD_ERROR_DATA_NOT_FOUND );

    MB  mb( (IMDCOM*) pvIMDCOM );


    if ( g_pGlobalLoggingProperties )
    {
        if  (  (m_fHashTablePopulated = 
            g_pGlobalLoggingProperties->InitializeFromMB (mb,"/LM/Logging/Custom Logging")))
        {
            if (m_HashTable.InitFrom (*g_pGlobalLoggingProperties))
            {
                if ( mb.Open(pszMetabasePath))
                {
                    m_HashTable.SetPopulationState(mb);
                    if ( mb.Close())
                    {
                        retVal = CLogFileCtrl::InitializeLog(szInstanceName, pszMetabasePath, pvIMDCOM);
                    }
                }
                else
                {
                    retVal = HRESULTTOWIN32( GetLastError());
                }
            }
            else
            {
                retVal = RETURNCODETOHRESULT ( ERROR_OUTOFMEMORY );
            }
        }

    }
    else
    {
        DBG_ASSERT (FALSE);
        retVal = RETURNCODETOHRESULT ( ERROR_OUTOFMEMORY );
    }

    return retVal;
}

/* ************************************************************************************ */

STDMETHODIMP
CEXTLOG::TerminateLog(
    VOID
    )
{
    return CLogFileCtrl::TerminateLog();
}

/* ************************************************************************************ */

DWORD
CEXTLOG::GetRegParameters(
                    LPCSTR pszRegKey,
                    LPVOID pvIMDCOM
                    )
{
    // let the parent object get the default parameter first

    CLogFileCtrl::GetRegParameters( pszRegKey, pvIMDCOM );

    MB      mb( (IMDCOM*) pvIMDCOM );

    if ( !mb.Open("") ) {
        DBGPRINTF((DBG_CONTEXT, "Error %x on mb open\n",GetLastError()));
        goto exit;
    }

    if ( !mb.GetDword(
                pszRegKey,
                MD_LOGEXT_FIELD_MASK,
                IIS_MD_UT_SERVER,
                &m_lMask ) )
    {
        DBGPRINTF((DBG_CONTEXT, "Error %x on FieldMask GetDword\n",GetLastError()));
    }

    //
    // Get time to be used for logfile rollover
    //
    
    if ( !mb.GetDword( pszRegKey,
                        MD_LOGFILE_LOCALTIME_ROLLOVER,
                        IIS_MD_UT_SERVER,
                        &m_fUseLocalTimeForRollover
                      ) )
    {
        m_fUseLocalTimeForRollover = 0;
    }

    if (m_fUseLocalTimeForRollover && ( NULL == m_pLocalTimeCache))
    {
        m_pLocalTimeCache = new ASCLOG_DATETIME_CACHE;
    }

exit:
    return(NO_ERROR);
}

/* ************************************************************************************ */

VOID
CEXTLOG::GetFormatHeader(
    IN OUT STR * strHeader
    )
{
    strHeader->Reset();

    BuildHeader(strHeader, m_lMask, EXTLOG_DATE,             EXTLOG_DATE_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_TIME,             EXTLOG_TIME_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_CLIENT_IP,        EXTLOG_CLIENT_IP_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_USERNAME,         EXTLOG_USERNAME_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_SITE_NAME,        EXTLOG_SITE_NAME_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_COMPUTER_NAME,    EXTLOG_COMPUTER_NAME_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_SERVER_IP,        EXTLOG_SERVER_IP_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_SERVER_PORT,      EXTLOG_SERVER_PORT_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_METHOD,           EXTLOG_METHOD_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_URI_STEM,         EXTLOG_URI_STEM_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_URI_QUERY,        EXTLOG_URI_QUERY_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_HTTP_STATUS,      EXTLOG_HTTP_STATUS_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_WIN32_STATUS,     EXTLOG_WIN32_STATUS_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_BYTES_SENT,       EXTLOG_BYTES_SENT_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_BYTES_RECV,       EXTLOG_BYTES_RECV_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_TIME_TAKEN,       EXTLOG_TIME_TAKEN_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_PROTOCOL_VERSION, EXTLOG_PROTOCOL_VERSION_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_HOST,             EXTLOG_HOST_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_USER_AGENT,       EXTLOG_USER_AGENT_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_COOKIE,           EXTLOG_COOKIE_ID);
    BuildHeader(strHeader, m_lMask, EXTLOG_REFERER,          EXTLOG_REFERER_ID);

    if ( ! strHeader->IsEmpty())
    {
        //
        // Remove the trailing space
        //

        strHeader->SetLen(strHeader->QuerySize()-1);
    }
    
    return;

} // CEXTLOG::GetFormatHeader

/* ************************************************************************************ */

BOOL
CEXTLOG::WriteLogDirectives(
    IN DWORD Sludge
    )
/*++

Routine Description:
    Function to write the Extended logging directives

Arguments:

    Sludge - number of additional bytes that needs to be written
        together with the directives

Return Value:

    TRUE, ok
    FALSE, not enough space to write.

--*/
{
    BOOL  fRetVal = TRUE;
    
    if ( m_pLogFile != NULL) 
    {

        CHAR        buf[1024];
        CHAR        szDateTime[32];
        
        STACK_STR   (header,256);
        DWORD       len;

        GetFormatHeader(&header );

        (VOID)m_DateTimeCache.GetFormattedCurrentDateTime(szDateTime);

        len = wsprintf( buf,
                        "#Software: Microsoft %s %d.%d\r\n"
                        "#Version: %s\r\n"
                        "#Date: %s %s\r\n"
                        "#Fields: %s\r\n",
                        VER_IISPRODUCTNAME_STR, VER_IISMAJORVERSION, VER_IISMINORVERSION,
                        EXTLOG_VERSION, szDateTime, szDateTime+strlen(szDateTime)+1, header.QueryStr());

        DBG_ASSERT(len == strlen(buf));

        if ( !IsFileOverFlowForCB(len + Sludge))  
        {
            m_pLogFile->Write(buf, len) ? IncrementBytesWritten(len) : (fRetVal = FALSE);
        } 
        else 
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            DBGPRINTF((DBG_CONTEXT, "WriteLogDirectives: Unable to write directives\n"));
            fRetVal = FALSE;
        }
    }

    return(fRetVal);

} // CLogFileCtrl::WriteLogDirectives

/* ************************************************************************************ */

BOOL
CEXTLOG::FormatLogBuffer(
         IN IInetLogInformation *pLogObj,
         IN LPSTR                pBuf,
         IN DWORD                *pcbSize,
         OUT SYSTEMTIME          *pSystemTime
)
{
    PCHAR pTmp;
    DWORD cbTmp;
    DWORD nRequired;
    DWORD status;
    PCHAR pBuffer = pBuf;
    CHAR  rgchDateTime[32];

    //
    // We need system time
    //

    m_DateTimeCache.SetSystemTime( pSystemTime );
   
    //
    // if default go through fast path
    //

    if ( m_lMask != DEFAULT_EXTLOG_FIELDS ) 
    {
        BOOL fRet = NormalFormatBuffer(
                            pLogObj,
                            pBuf,
                            pcbSize,
                            pSystemTime
                            );

        if (fRet && m_fUseLocalTimeForRollover )
        {
            m_pLocalTimeCache ? m_pLocalTimeCache->SetLocalTime(pSystemTime):
                                GetLocalTime(pSystemTime);
        }

        return fRet;
    }

    //
    // Default format is:
    // Time ClientIP Operation Target HTTPStatus
    //
    // Time         8   HH:MM:SS
    // delimiters   4
    // EOL          2
    //

    nRequired = 8 + 4 + 2;

    (VOID) m_DateTimeCache.GetFormattedDateTime(pSystemTime,rgchDateTime);
    pTmp = rgchDateTime + 11;

    CopyMemory(pBuffer, pTmp, 8);
    pBuffer += 8;
    *(pBuffer++) = ' ';

    //
    // IP Address
    //

    pTmp = pLogObj->GetClientHostName( NULL, &cbTmp );
    if ( cbTmp == 0 ) 
    {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp;
    if ( nRequired <= *pcbSize ) 
    {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        *(pBuffer++) = ' ';
    }

    //
    // Operation
    //

    pTmp = pLogObj->GetOperation( NULL, &cbTmp );
    if ( cbTmp == 0 ) 
    {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp;
    if ( nRequired <= *pcbSize ) 
    {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        *(pBuffer++) = ' ';
    }

    //
    // Target
    //

    pTmp = pLogObj->GetTarget( NULL, &cbTmp );

    if ( cbTmp == 0 ) 
    {
        cbTmp = 1;
        pTmp = "-";
    }
    else if ( (cbTmp > MAX_LOG_TARGET_FIELD_LEN ) ||
              ((nRequired + cbTmp) > MAX_LOG_RECORD_LEN))
    {
        cbTmp = 3;
        pTmp  = szDotDot;
    }
         
    nRequired += cbTmp;
    if ( nRequired <= *pcbSize ) 
    {
        for (DWORD i=0; i<cbTmp;i++ ) 
        {
            if ( isspace((UCHAR)(*pBuffer = pTmp[i])) ) 
            {
                *pBuffer = '+';
            }
            pBuffer++;
        }
        *(pBuffer++) = ' ';
    }

    status = pLogObj->GetProtocolStatus( );

    if ( (status == 200) && (nRequired + 5 <= *pcbSize) ) 
    {

        CopyMemory( pBuffer, szHTTPOk, 5);
        pBuffer += 5;
        nRequired += 3;
    } 
    else 
    {

        CHAR    tmpBuf[32];

        cbTmp = FastDwToA( tmpBuf, status );

        nRequired += cbTmp;
        if ( nRequired <= *pcbSize ) 
        {
            CopyMemory(pBuffer, tmpBuf, cbTmp);
            pBuffer += cbTmp;
        }

        *(pBuffer++) = '\r';
        *pBuffer = '\n';
    }

    if ( nRequired > *pcbSize ) 
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        *pcbSize = nRequired;
        return(FALSE);
    }

    *pcbSize = nRequired;

    //
    // To allow filenames & rollover based on either local or GMT time
    //

    if ( m_fUseLocalTimeForRollover )
    {
        m_pLocalTimeCache ? m_pLocalTimeCache->SetLocalTime(pSystemTime):
                            GetLocalTime(pSystemTime);
    }

    return TRUE;

} // CEXTLOG::FormatLogBuffer


/* ************************************************************************************ */

BOOL
CEXTLOG::NormalFormatBuffer(
        IN IInetLogInformation  *pLogObj,
        IN LPSTR                pBuf,
        IN DWORD                *pcbSize,
        IN SYSTEMTIME           *pSystemTime
        )
{

    BOOL    fSucceeded = FALSE;
    DWORD   spaceNeeded = 0;

    CHAR    tmpBuf[32];
    PCHAR   pTmp;
    DWORD   cbTmp;

    //
    // Format is:
    // Date Time ClientIP UserName Service Server ServerIP
    //      Method Target parameters httpstatus win32 bytes timetaken
    //      user-agent cookies
    //

    PCHAR outBuffer = pBuf;
    *outBuffer = 0;

    if ( m_lMask & (EXTLOG_DATE | EXTLOG_TIME) ) 
    {

        DWORD cchDateTime;
        DWORD cchDate;
        DWORD cchTime;
        CHAR  rgchDateTime[ 32];

        cchDateTime = m_DateTimeCache.GetFormattedDateTime(
                                            pSystemTime,
                                            rgchDateTime);

        cchDate = strlen(rgchDateTime);
        cchTime = cchDateTime - cchDate - 1;

        if (m_lMask & EXTLOG_DATE) 
        {
            // Date is in YYYY-MM-DD format (GMT)

            fSucceeded = CopyFieldToBuffer( rgchDateTime, cchDate, &outBuffer, 
                                            &spaceNeeded, *pcbSize);
        }

        if (m_lMask & EXTLOG_TIME) 
        {
            // Time in HH:MM:SS format (GMT)

            fSucceeded = CopyFieldToBuffer( rgchDateTime+cchDate+1, cchTime, &outBuffer, 
                                            &spaceNeeded, *pcbSize);
        }
    }

    //
    // Fill up the buffer
    //

    if (m_lMask & EXTLOG_CLIENT_IP ) 
    {
        pTmp = pLogObj->GetClientHostName( NULL, &cbTmp );
        fSucceeded = CopyFieldToBuffer( pTmp, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_USERNAME ) 
    {
        pTmp = pLogObj->GetClientUserName( NULL, &cbTmp );
        fSucceeded = CopyFieldToBuffer( pTmp, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_SITE_NAME) 
    {
        pTmp = pLogObj->GetSiteName( NULL, &cbTmp );
        fSucceeded = CopyFieldToBuffer( pTmp, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_COMPUTER_NAME) 
    {
        pTmp = pLogObj->GetComputerName( NULL, &cbTmp );
        fSucceeded = CopyFieldToBuffer( pTmp, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_SERVER_IP ) 
    {
        pTmp = pLogObj->GetServerAddress( NULL, &cbTmp );
        fSucceeded = CopyFieldToBuffer( pTmp, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_SERVER_PORT ) 
    {
        cbTmp = FastDwToA( tmpBuf, pLogObj->GetPortNumber() );
        fSucceeded = CopyFieldToBuffer( tmpBuf, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }
    
    if (m_lMask & EXTLOG_METHOD ) 
    {
        pTmp = pLogObj->GetOperation( NULL, &cbTmp );
        fSucceeded = CopyFieldToBuffer( pTmp, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }
    
    if (m_lMask & EXTLOG_URI_STEM ) 
    {
        pTmp = pLogObj->GetTarget( NULL, &cbTmp );

        if ((cbTmp > MAX_LOG_TARGET_FIELD_LEN ) || ((spaceNeeded + cbTmp) > MAX_LOG_RECORD_LEN))
        {
            cbTmp = 3;
            pTmp  = szDotDot;
        }
        else
        {
            ConvertSpacesToPlus(pTmp);
        }
        
        fSucceeded = CopyFieldToBuffer( pTmp, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_URI_QUERY ) 
    {
        pTmp = pLogObj->GetParameters( NULL, &cbTmp );

        if ((cbTmp > MAX_LOG_TARGET_FIELD_LEN ) || ((spaceNeeded + cbTmp) > MAX_LOG_RECORD_LEN))
        {
            cbTmp = 3;
            pTmp  = szDotDot;
        }
        else
        {
            ConvertSpacesToPlus(pTmp);
        }
        
        fSucceeded = CopyFieldToBuffer( pTmp, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_HTTP_STATUS ) 
    {
        cbTmp = FastDwToA( tmpBuf, pLogObj->GetProtocolStatus() );
        fSucceeded = CopyFieldToBuffer( tmpBuf, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_WIN32_STATUS ) 
    {
        cbTmp = FastDwToA( tmpBuf, pLogObj->GetWin32Status() );
        fSucceeded = CopyFieldToBuffer( tmpBuf, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_BYTES_SENT ) 
    {
        cbTmp = FastDwToA( tmpBuf, pLogObj->GetBytesSent() );
        fSucceeded = CopyFieldToBuffer( tmpBuf, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_BYTES_RECV ) 
    {
        cbTmp = FastDwToA( tmpBuf, pLogObj->GetBytesRecvd() );
        fSucceeded = CopyFieldToBuffer( tmpBuf, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_TIME_TAKEN ) 
    {
        cbTmp = FastDwToA( tmpBuf, pLogObj->GetTimeForProcessing() );
        fSucceeded = CopyFieldToBuffer( tmpBuf, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    if (m_lMask & EXTLOG_PROTOCOL_VERSION ) 
    {
        pTmp = pLogObj->GetVersionString( NULL, &cbTmp );
        fSucceeded = CopyFieldToBuffer( pTmp, cbTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }

    //
    // See if we need to get the extra header
    //

    if ( (m_lMask & (EXTLOG_HOST       |
                     EXTLOG_USER_AGENT |
                     EXTLOG_COOKIE     |
                     EXTLOG_REFERER )) != NULL ) 
    {

        pTmp = pLogObj->GetExtraHTTPHeaders( NULL, &cbTmp );
                   
        if ( m_lMask & EXTLOG_HOST )           
             fSucceeded = WriteHTTPHeader(&pTmp, &outBuffer, &spaceNeeded, *pcbSize);

        if ( m_lMask & EXTLOG_USER_AGENT )           
             fSucceeded = WriteHTTPHeader(&pTmp, &outBuffer, &spaceNeeded, *pcbSize);
                
        if ( m_lMask & EXTLOG_COOKIE )           
             fSucceeded = WriteHTTPHeader(&pTmp, &outBuffer, &spaceNeeded, *pcbSize);

        if ( m_lMask & EXTLOG_REFERER )           
             fSucceeded = WriteHTTPHeader(&pTmp, &outBuffer, &spaceNeeded, *pcbSize);
    }
    
    //
    // remove the trailing space
    //

    if ('\0' != *pBuf)
    {
        outBuffer--;
        spaceNeeded--;
    }

    //
    // add line terminator
    //

    spaceNeeded += 2;
    if ( spaceNeeded <= *pcbSize)
    {
        outBuffer[0] = '\r';
        outBuffer[1] = '\n';
        fSucceeded   = TRUE;
    }
    else
    {
        fSucceeded   = FALSE;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
    }

    *pcbSize = spaceNeeded;
    return fSucceeded;

} // CEXTLOG::FormatLogBuffer

/* ************************************************************************************ */
/* Custom Logging Functions                                                             */
/* ************************************************************************************ */

BOOL
CEXTLOG::WriteCustomLogDirectives(
        IN DWORD Sludge
        )
{
    BOOL   fRetVal = TRUE;

    if ( m_pLogFile != NULL) 
    {
        CHAR        szDateTime[32];
        DWORD       dwLen;

        STACK_STR( strHeader, 512 );
        
        m_DateTimeCache.GetFormattedCurrentDateTime(szDateTime);
        
        BuildCustomLogHeader(m_cPrevCustLogItems, m_pPrevCustLogItems, szDateTime, 
                             m_strHeaderSuffix.QueryStr(), strHeader);

        dwLen = strHeader.QueryCB();

        if ( !IsFileOverFlowForCB(dwLen + Sludge) )
        {
            m_pLogFile->Write(strHeader.QueryStr(), dwLen) ? 
                                IncrementBytesWritten(dwLen) : (fRetVal = FALSE);
        } 
        else 
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            DBGPRINTF((DBG_CONTEXT, "WriteCustomLogDirectives: Unable to write directives\n"));
            fRetVal = FALSE;
        }
    }
    
    return fRetVal;
}

/* ************************************************************************************ */

DWORD 
CEXTLOG::ConvertDataToString(
    IN  DWORD dwPropertyType, 
    IN  PVOID pData, 
    IN  PCHAR pBuffer, 
    IN  DWORD dwBufferSize
    )
/*++

Routine Description:
    Function to convert Custom Logging data to string

Arguments:

    dwPropertyType - type information regarding the data to convert.
    pData          - pointer to data.
    pBuffer        - pointer to buffer to store the result.
    dwBufferSize   - byte count of space remaining in the buffer. If 0 or -ve
                     => buffer is full

Return Value:

    Number of bytes in the string representation of the data +1 (for space at end).
    The output buffer (pBuffer) is not NULL terminated.

--*/
{
    CHAR    szBuf[64];
    PCHAR   pChString;
    DWORD   dwLength;

    USES_CONVERSION;                        // To enable W2A

    DBG_ASSERT(NULL != pBuffer);

    if ( NULL != pData)
    {
        pChString = szBuf;
    
        switch (dwPropertyType)
        {
        
            case MD_LOGCUSTOM_DATATYPE_INT:
            {
                int i = *((int *)pData);
                _itoa(i, pChString, 10);
                dwLength = strlen(pChString);
                break;
            }

            case MD_LOGCUSTOM_DATATYPE_UINT:
            {
                unsigned int  ui = *((unsigned int *)pData);
                unsigned long ul = ui;
                _ultoa(ul, pChString, 10);
                dwLength = strlen(pChString);
                break;
            }

            case MD_LOGCUSTOM_DATATYPE_LONG:
            {
                long l = *((long *)pData);
                _ltoa(l, pChString, 10);
                dwLength = strlen(pChString);
                break;
            }

            case MD_LOGCUSTOM_DATATYPE_ULONG:
            {
                unsigned long ul = *((unsigned long *)pData);
                _ultoa(ul, pChString, 10);
                dwLength = strlen(pChString);
                break;
            }

            case MD_LOGCUSTOM_DATATYPE_FLOAT:
            {
                float f = *((float *)pData);
                dwLength = sprintf(pChString,"%f",f);
                break;
            }
        
            case MD_LOGCUSTOM_DATATYPE_DOUBLE:
            {
                double d = *((double *)pData);
                dwLength = sprintf(pChString,"%f",d);
                break;
            }
        
            case MD_LOGCUSTOM_DATATYPE_LPSTR:
            {
                pChString = (LPSTR)pData;
                dwLength = strlen(pChString);

                if (dwLength > MAX_LOG_TARGET_FIELD_LEN )
                {
                    pChString = szDotDot;
                    dwLength  = 3;
                }
            
                break;
            }
            
            case MD_LOGCUSTOM_DATATYPE_LPWSTR:
            {
                dwLength = wcslen( (LPWSTR)pData);

                if (dwLength <= MAX_LOG_TARGET_FIELD_LEN)
                {
                    pChString = W2A((LPWSTR)pData);
                }
                else
                {
                    pChString = szDotDot;
                    dwLength  = 3;
                }
            
                break;
            }
            
            default:
                dwLength = 0;
                break;
        }
    }
    else
    {
        pChString = szDash;
        dwLength = 1;
    }

    //
    // Copy over the charaters to the output buffer and append a ' '
    //
    
    if (dwLength < dwBufferSize)
    {
        CopyMemory(pBuffer, pChString, dwLength);
        pBuffer[dwLength] = ' ';
    }
    else if (dwBufferSize > 3)
    {
        //
        // Not enough memory to copy the field. Use ... instead
        //
        
        dwLength = 3;
        CopyMemory(pBuffer, szDotDot, 3);
        pBuffer[dwLength] = ' ';
    }
    else
    {
        //
        // Can't even copy ... Just punt on the remaining part of the log line
        //
        
        dwLength = -1;
    }
    
    return dwLength+1;
}
/* ************************************************************************************ */

DWORD 
CEXTLOG::FormatCustomLogBuffer( 
        DWORD               cItems, 
        PPLOG_PROPERTY_INFO pPropInfo,
        PPVOID              pPropData,
        LPCSTR              szDateTime, 
        LPSTR               szLogLine,
        DWORD               cchLogLine
        )
{
    DWORD       cchUsed;
    PCHAR       pCh   = szLogLine;
    
    cchLogLine -= 1;                                   // Reserve space for trailing \r\n

    //
    // Add date & time if enabled
    //

    if ( m_lMask & (EXTLOG_DATE | EXTLOG_TIME) ) 
    {

        DWORD cch = strlen(szDateTime);

        if (m_lMask & EXTLOG_DATE) 
        {
            memcpy(pCh, szDateTime, cch);
            *(pCh+cch) = ' ';
            pCh += cch+1;
        }
        
        if (m_lMask & EXTLOG_TIME) 
        {
            szDateTime += cch+1;
            cch = strlen(szDateTime);
            memcpy(pCh, szDateTime, cch);
            *(pCh+cch) = ' ';
            pCh += cch+1;
        }
    }

    cchLogLine -= DIFF(pCh - szLogLine);
    
    for (DWORD i=0; i< cItems; i++)
    {
        // Convert data to string

        cchUsed   = ConvertDataToString(pPropInfo[i]->dwPropertyDataType, 
                                        pPropData[i], 
                                        pCh, cchLogLine);
        pCh         += cchUsed;
        
        cchLogLine  -= cchUsed;
    }
    
    *(pCh-1)  = '\r';
    *(pCh)    = '\n';
    
    return DIFF(pCh+1-szLogLine);
}

/* ************************************************************************************ */

void 
CEXTLOG::BuildCustomLogHeader( 
        DWORD               cItems, 
        PPLOG_PROPERTY_INFO pPropInfo, 
        LPCSTR              szDateTime,
        LPCSTR              szHeaderSuffix,
        STR&                strHeader
        )
{
    DWORD   cchHeader;
    LPSTR   szHeader =  strHeader.QueryStr();
    
    cchHeader = wsprintf( szHeader,
                        "#Software: Microsoft %s %d.%d\r\n"
                        "#Version: %s\r\n"
                        "#Date: %s %s\r\n",
                        VER_IISPRODUCTNAME_STR, VER_IISMAJORVERSION, VER_IISMINORVERSION,
                        EXTLOG_VERSION,
                        szDateTime,
                        szDateTime+strlen(szDateTime)+1
                        );

    if ( (NULL != szHeaderSuffix) && ('\0' != *szHeaderSuffix))
    {
        DWORD   cchSuffix;

        // Make sure that the header begins with a #

        if ( *szHeaderSuffix != '#')
        {
            szHeader[cchHeader++] = '#';
        }

        cchSuffix = strlen(szHeaderSuffix);
        memcpy(szHeader+cchHeader, szHeaderSuffix, cchSuffix);
        cchHeader += cchSuffix;

        szHeader[cchHeader++] = '\r';
        szHeader[cchHeader++] = '\n';
    }

    memcpy(szHeader+cchHeader, "#Fields:", sizeof("#Fields:"));
    cchHeader += sizeof("#Fields:");
    strHeader.SetLen(cchHeader-1);

    //
    // Fill in W3C Headers for all fields.
    //
    if ( m_lMask & EXTLOG_DATE ) 
    {
        strHeader.Append(" date");
    }
    if (m_lMask & EXTLOG_TIME) 
    {
        strHeader.Append(" time");
    }

    for (DWORD i=0; i< cItems; i++)
    {
        // Add header to header string

        strHeader.Append(' ');
        strHeader.Append(pPropInfo[i]->strW3CHeader);
    }

    strHeader.Append("\r\n");
}

/* ************************************************************************************ */

STDMETHODIMP 
CEXTLOG::LogCustomInformation(
    IN  DWORD               cItems, 
    IN  PCUSTOM_LOG_DATA    pCustomLogData,
    IN  LPSTR               szHeaderSuffix
    )
/*++

Routine Description:
    Function to write Custom Logging information for Extended logging

Arguments:

    cItems          - number of fields to log 
                     (elements in the array pointed to by pCustomLogData)
                     
    pCustomLogData  - pointer to array of CUSTOM_LOG_DATA

Return Value:

    HRESULT indicating whether function Succeeded or Failed.

--*/
{

    SYSTEMTIME      sysTime;
    DWORD           i, j, cchLogLine;
    BOOL            fResetHeaders;
    CHAR            szDateTime[32];
    CHAR            szLogLine[MAX_LOG_RECORD_LEN+1];

    DBG_ASSERT( 0 != cItems);
    DBG_ASSERT( NULL != pCustomLogData);
    DBG_ASSERT( MAX_CUSTLOG_FIELDS >= cItems);

    PLOG_PROPERTY_INFO  pPropInfo[MAX_CUSTLOG_FIELDS];
    PVOID               pPropData[MAX_CUSTLOG_FIELDS];

    //
    // Lock Shared. Ensures that shared variables are not modified unknowst to this thread.
    //
    
    LockCustLogShared();
    
    fResetHeaders = FALSE;

    //
    // Build list of enabled keys. Simultaneously check if headr needs resetting.
    //
    
    for (i=0, j=0 ; i< cItems; i++)
    {

        if ( (LK_SUCCESS == m_HashTable.FindKey(pCustomLogData[i].szPropertyPath, pPropInfo+j)) &&
             (pPropInfo[j]->fEnabled)
           )
        {
            fResetHeaders  |=  ( pPropInfo[j] != m_pPrevCustLogItems[j] );
            pPropData[j]    =  pCustomLogData[i].pData;    
            j++;
        }
    }

    cItems = j;

    //
    // Header needs resetting if # items is different or Header Suffix has changed.
    //
    
    fResetHeaders |= (m_cPrevCustLogItems != cItems);

    if (szHeaderSuffix != NULL) 
    {
        fResetHeaders |=  ( 0 != strcmp(m_strHeaderSuffix.QueryStr(), szHeaderSuffix));
    }
    
    m_DateTimeCache.SetSystemTime( &sysTime );
    m_DateTimeCache.GetFormattedDateTime(&sysTime, szDateTime);

    cchLogLine = FormatCustomLogBuffer( cItems, 
                                        pPropInfo, 
                                        pPropData, 
                                        szDateTime, 
                                        szLogLine, 
                                        MAX_LOG_RECORD_LEN+1);
    
    if (fResetHeaders)
    {
        //
        // Convert Lock to Exclusive before setting the class wide variable.
        //
        
        LockCustLogConvertExclusive();
        
        m_cPrevCustLogItems = cItems;

        for (i=0; i <cItems; i++)
        {
            m_pPrevCustLogItems[i] = pPropInfo[i];
        }

        m_strHeaderSuffix.Copy(szHeaderSuffix);
    }    

    //
    // Write out the log to file
    //
    
    if ( m_fUseLocalTimeForRollover )
    {
        m_pLocalTimeCache ? m_pLocalTimeCache->SetLocalTime(&sysTime):
                            GetLocalTime(&sysTime);
    }

    WriteLogInformation(sysTime, szLogLine, cchLogLine, TRUE, fResetHeaders); 

    UnlockCustLog();
    
    return S_OK;
}

/* ************************************************************************************ */
/* ILogScripting Functions                                                              */
/* ************************************************************************************ */

HRESULT
CEXTLOG::ReadFileLogRecord(
    IN  FILE                *fpLogFile, 
    IN  LPINET_LOGLINE       pInetLogLine,
    IN  PCHAR                pszLogLine,
    IN  DWORD                dwLogLineSize
    )
/*++

Routine Description:
    Function to read a log line from an open log file

Arguments:

    fpLogFile       -   FILE * to open file
    pInetLogLine    -   pointer to INET_LOGLINE structure where parsed info is stored
    pszLogLine      -   buffer to store the log line
    dwLogLineSize   -   size of pszLogLine

Return Value:

    HRESULT indicating whether function Succeeded or Failed.

--*/
{
    CHAR *  pCh;
    DWORD   pos, custompos;
    CHAR *  szDateString, * szTimeString;

getnewline:

    pCh = pszLogLine;
    
    fgets(pCh, dwLogLineSize, fpLogFile);

    if (feof(fpLogFile))
    {
        return E_FAIL;
    }

    pCh = SkipWhite(pCh);

    if (('\n' == *pCh) || ('\0' == *pCh))
    {
        // Empty line. Get Next line

        goto getnewline;
    }

    if ( '#' ==  *pCh )                             
    {

        pCh = strstr(pszLogLine, "#Date:");

        if (NULL != pCh)
        {
            //
            // Copy the date & time into member variables
            //

            pCh = strtok(pCh+6," \t\r\n");
            if (NULL == pCh)
            {
                return E_FAIL;
            }
            strcpy(m_szDate, pCh);
        
            pCh = strtok(NULL," \t\r\n");
            if (NULL == pCh)
            {
                return E_FAIL;
            }
            strcpy(m_szTime, pCh);

            goto getnewline;
        }

        //
        // Not the date line. Check if the fields are being reset
        //
        
        pCh = strstr(pszLogLine, "#Fields:");

        if (NULL != pCh)
        {
            // Headers are being defined or redefined

            dwDatePos           = 0;
            dwTimePos           = 0;
            dwClientIPPos       = 0;
            dwUserNamePos       = 0;
            dwSiteNamePos       = 0; 
            dwComputerNamePos   = 0;
            dwServerIPPos       = 0;
            dwMethodPos         = 0;
            dwURIStemPos        = 0;
            dwURIQueryPos       = 0;
            dwHTTPStatusPos     = 0;
            dwWin32StatusPos    = 0;
            dwBytesSentPos      = 0;
            dwBytesRecvPos      = 0;
            dwTimeTakenPos      = 0;
            dwServerPortPos     = 0;
            dwVersionPos        = 0;
            dwCookiePos         = 0;
            dwUserAgentPos      = 0;
            dwRefererPos        = 0;

            pInetLogLine->iCustomFieldsCount = 0;
        
            pCh = strtok(pCh+8," \t\r\n");

            for (pos = 1; pCh != NULL; pos++, pCh = strtok(NULL," \t\r\n")) 
            {
   
                if (0 == _stricmp(pCh, EXTLOG_DATE_ID))                {
                    dwDatePos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_TIME_ID))         {
                    dwTimePos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_CLIENT_IP_ID))     {
                    dwClientIPPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_USERNAME_ID))      {
                    dwUserNamePos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_SITE_NAME_ID))     {
                    dwSiteNamePos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_COMPUTER_NAME_ID)) {
                    dwComputerNamePos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_SERVER_IP_ID))     {
                    dwServerIPPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_METHOD_ID))        {
                    dwMethodPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_URI_STEM_ID))      {
                    dwURIStemPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_URI_QUERY_ID))     {
                    dwURIQueryPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_HTTP_STATUS_ID))   {
                    dwHTTPStatusPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_WIN32_STATUS_ID))  {
                    dwWin32StatusPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_BYTES_SENT_ID))    {
                    dwBytesSentPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_BYTES_RECV_ID))    {
                    dwBytesRecvPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_TIME_TAKEN_ID))    {
                    dwTimeTakenPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_SERVER_PORT_ID))   {
                    dwServerPortPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_PROTOCOL_VERSION_ID)){
                    dwVersionPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_COOKIE_ID))        {
                    dwCookiePos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_USER_AGENT_ID))        {
                    dwUserAgentPos = pos;
                } else if (0 == _stricmp(pCh, EXTLOG_REFERER_ID))        {
                    dwRefererPos = pos;
                } else if ( pInetLogLine->iCustomFieldsCount < MAX_CUSTOM_FIELDS) {

                    // Unidentified header. Add to custom header list
                    
                    strcpy(pInetLogLine->CustomFields[pInetLogLine->iCustomFieldsCount++].szHeader, pCh);
                }
            }
        }

        goto getnewline;
    }

    //
    // We have a log line. Parse it.
    //
    
    szDateString = m_szDate;
    szTimeString = m_szTime;

    pCh = strtok(pszLogLine," \t\r\n");

    for (pos = 1, custompos = 0; pCh != NULL; pos++, pCh= strtok(NULL, " \t\r\n")) 
    {
        if ( pos == dwDatePos )             {
            szDateString                    = pCh;
        } else if (pos == dwTimePos)        {
            szTimeString                    = pCh;
        } else if (pos == dwClientIPPos)    {
            pInetLogLine->pszClientHostName = pCh;
        } else if (pos == dwUserNamePos)    {
            pInetLogLine->pszClientUserName = pCh;
        } else if (pos == dwSiteNamePos)    {
            pInetLogLine->pszSiteName       = pCh;
        } else if (pos == dwComputerNamePos){
            pInetLogLine->pszComputerName   = pCh;
        } else if (pos == dwServerIPPos)    {
            pInetLogLine->pszServerAddress  = pCh;
        } else if (pos == dwMethodPos)      {
            pInetLogLine->pszOperation      = pCh;
        } else if (pos == dwURIStemPos)     {
            pInetLogLine->pszTarget         = pCh;
        } else if (pos == dwURIQueryPos)    {
            pInetLogLine->pszParameters     = pCh;
        } else if (pos == dwHTTPStatusPos)  {
            pInetLogLine->pszProtocolStatus = pCh;
        } else if (pos == dwWin32StatusPos) {
            pInetLogLine->pszWin32Status    = pCh;
        } else if (pos == dwBytesSentPos)   {
            pInetLogLine->pszBytesSent      = pCh;
        } else if (pos == dwBytesRecvPos)   {
            pInetLogLine->pszBytesRecvd     = pCh;
        } else if (pos == dwTimeTakenPos)   {
            pInetLogLine->pszTimeForProcessing= pCh;
        } else if (pos == dwServerPortPos)  {
            pInetLogLine->pszPort           = pCh;
        } else if (pos == dwVersionPos)     {
            pInetLogLine->pszVersion        = pCh;
        } else if (pos == dwCookiePos)      {
            pInetLogLine->pszCookie         = pCh;
        } else if (pos == dwUserAgentPos)   {
            pInetLogLine->pszUserAgent      = pCh;
        } else if (pos == dwRefererPos)     {
            pInetLogLine->pszReferer        = pCh;
        } else if ( custompos < (DWORD)pInetLogLine->iCustomFieldsCount) {
            pInetLogLine->CustomFields[custompos++].pchData = pCh;
        }
    }

    if ( ! ConvertW3CDateToVariantDate(szDateString, szTimeString, &(pInetLogLine->DateTime)) )
    {
        return E_FAIL;
    }

    return S_OK;

} // CEXTLOG::ReadFileLogRecord

/* ************************************************************************************ */

HRESULT
CEXTLOG::WriteFileLogRecord(
    IN  FILE            *fpLogFile, 
    IN  ILogScripting   *pILogScripting,
    IN  bool            fWriteHeader
    )
/*++

Routine Description:
    Function to write a log line to an open log file

Arguments:

    fpLogFile       -   FILE * to open file
    pILogScripting  -   ILogScripting interface for getting information to write
    fWriteHeader    -   Flag to indicate that log header must be written.

Return Value:

    HRESULT indicating whether function Succeeded or Failed.

--*/
{
    USES_CONVERSION;

    HRESULT hr = E_FAIL;
    CHAR    szLogLine[4096];  
    DWORD   dwIndex = 0;
    long    i = 0;

    VARIANT DateTime;
    VARIANT varCustomFieldsArray;

    SYSTEMTIME  sysTime; 
    CHAR        rgchDateTime[ 32];

    const int cFields = 18;
    
    //
    // Populate Headers
    //

    if (!m_fWriteHeadersInitialized)
    {
        LPSTR   szFieldNames[cFields] = { 
                                            EXTLOG_CLIENT_IP_ID, 
                                            EXTLOG_USERNAME_ID, 
                                            EXTLOG_SITE_NAME_ID,
                                            EXTLOG_COMPUTER_NAME_ID, 
                                            EXTLOG_SERVER_IP_ID, 
                                            EXTLOG_METHOD_ID, 
                                            EXTLOG_URI_STEM_ID, 
                                            EXTLOG_URI_QUERY_ID,
                                            EXTLOG_HTTP_STATUS_ID,
                                            EXTLOG_WIN32_STATUS_ID,
                                            EXTLOG_BYTES_SENT_ID, 
                                            EXTLOG_BYTES_RECV_ID, 
                                            EXTLOG_TIME_TAKEN_ID,
                                            EXTLOG_SERVER_PORT_ID,
                                            EXTLOG_PROTOCOL_VERSION_ID,
                                            EXTLOG_USER_AGENT_ID,
                                            EXTLOG_COOKIE_ID,
                                            EXTLOG_REFERER_ID
                                        };

        m_fWriteHeadersInitialized = TRUE;
        
        if ( NULL != (m_pLogFields =   new LOG_FIELDS[cFields]))
        {
            for (int i =0; i < cFields; i++)
            {
                strcpy(m_pLogFields[i].szW3CHeader, szFieldNames[i]);
                m_pLogFields[i].varData.lVal = NULL;
            }
        }
    }

    if (NULL == m_pLogFields)
    {
        return E_OUTOFMEMORY;            
    }

    if (SUCCEEDED( pILogScripting->get_ClientIP       ( & m_pLogFields[0].varData) )    &&
        SUCCEEDED( pILogScripting->get_UserName       ( & m_pLogFields[1].varData) )    &&   
        SUCCEEDED( pILogScripting->get_ServiceName    ( & m_pLogFields[2].varData) )    &&
        SUCCEEDED( pILogScripting->get_ServerName     ( & m_pLogFields[3].varData) )    &&
        SUCCEEDED( pILogScripting->get_ServerIP       ( & m_pLogFields[4].varData) )    &&
        SUCCEEDED( pILogScripting->get_Method         ( & m_pLogFields[5].varData) )    &&
        SUCCEEDED( pILogScripting->get_URIStem        ( & m_pLogFields[6].varData) )    &&
        SUCCEEDED( pILogScripting->get_URIQuery       ( & m_pLogFields[7].varData) )    &&
        SUCCEEDED( pILogScripting->get_ProtocolStatus ( & m_pLogFields[8].varData) )    &&
        SUCCEEDED( pILogScripting->get_Win32Status    ( & m_pLogFields[9].varData) )    &&
        SUCCEEDED( pILogScripting->get_BytesSent      ( & m_pLogFields[10].varData) )   &&
        SUCCEEDED( pILogScripting->get_BytesReceived  ( & m_pLogFields[11].varData) )   &&
        SUCCEEDED( pILogScripting->get_TimeTaken      ( & m_pLogFields[12].varData) )   &&
        SUCCEEDED( pILogScripting->get_ServerPort     ( & m_pLogFields[13].varData) )   &&
        SUCCEEDED( pILogScripting->get_ProtocolVersion( & m_pLogFields[14].varData) )   &&
        SUCCEEDED( pILogScripting->get_UserAgent      ( & m_pLogFields[15].varData) )   &&
        SUCCEEDED( pILogScripting->get_Cookie         ( & m_pLogFields[16].varData) )   &&
        SUCCEEDED( pILogScripting->get_Referer        ( & m_pLogFields[17].varData) )   &&

        SUCCEEDED( pILogScripting->get_CustomFields   ( & varCustomFieldsArray ) )      &&
        SUCCEEDED( pILogScripting->get_DateTime       ( & DateTime) )                   &&
        VariantTimeToSystemTime                       ( DateTime.date, &sysTime)
        )
    {
        SAFEARRAY * psaCustom;
        long        cItems = 0, lIndex[2];
        BSTR        szCustomHeader, szCustomData;
        BSTR HUGEP *pbstr;

        //
        // Build Header
        //

        strcpy(szLogLine, "date time");

        for ( i = 0; i < cFields; i++)
        {
            if ( VT_NULL != m_pLogFields[i].varData.vt)
            {
                strcat(szLogLine, " ");
                strcat(szLogLine, m_pLogFields[i].szW3CHeader);
            }
        }

        if ( (VT_BSTR|VT_ARRAY) == varCustomFieldsArray.vt)
        {
            psaCustom = varCustomFieldsArray.parray;
        
            if (NULL != psaCustom)
            {
                cItems = psaCustom->rgsabound[1].cElements;
            }

            if ( SUCCEEDED(SafeArrayAccessData(psaCustom, (void HUGEP* FAR*)&pbstr)) )
            {
                for ( i = 0; i < cItems; i++)
                {
                    strcat(szLogLine, " ");
                    strcat(szLogLine, W2A(pbstr[i]));
                }

                SafeArrayUnaccessData(psaCustom);
            }
        }

        m_DateTimeCache.GetFormattedDateTime( &sysTime, rgchDateTime);

        if ( fWriteHeader || strcmp( szLogLine, m_szWriteHeader.QueryStr()) )
        {
            // Need to write headers

            m_szWriteHeader.Copy(szLogLine);

            wsprintf(szLogLine,
                        "#Software: Microsoft Internet Information Services 5.0\n"
                        "#Version: %s\n"
                        "#Date: %s %s\n"
                        "#Fields: %s\n",
                        EXTLOG_VERSION,
                        rgchDateTime,
                        rgchDateTime+strlen(rgchDateTime)+1,
                        m_szWriteHeader.QueryStr()
                    );
        }
        else
        {
            szLogLine[0] = '\0';
        }

        //
        // Write the fields to the log line
        //

        strcat(szLogLine, rgchDateTime);
        strcat(szLogLine, " ");
        strcat(szLogLine, rgchDateTime+strlen(rgchDateTime)+1);

        for ( i = 0; i < cFields; i++)
        {
            switch  (m_pLogFields[i].varData.vt)
            {
                case VT_BSTR:
                    strcat(szLogLine, " ");
                    strcat( szLogLine, W2A(GetBstrFromVariant( &m_pLogFields[i].varData)) );
                    break;

                case VT_I4:
                    strcat(szLogLine, " ");
                    GetLongFromVariant( &m_pLogFields[i].varData, szLogLine+strlen(szLogLine));
                    break;

                case VT_EMPTY:
                    strcat (szLogLine, " -");
                    break;

                default:
                    break;
            }
        }

        if ( (0 < cItems) && SUCCEEDED(SafeArrayAccessData(psaCustom, (void HUGEP* FAR*)&pbstr)) )
        {
            for ( i = 0; i < cItems; i++)
            {
                strcat(szLogLine, " ");
                strcat(szLogLine, W2A(pbstr[cItems + i]));
            }

            SafeArrayUnaccessData(psaCustom);
        }

        fprintf(fpLogFile, "%s\n", szLogLine);

        hr = S_OK;
    }

    return hr;
}

/* ************************************************************************************ */

BOOL
CEXTLOG::ConvertW3CDateToVariantDate(
    IN  PCHAR szDateString, 
    IN  PCHAR szTimeString, 
    OUT DATE * pDateTime)
/*++

Routine Description:
    Convert a Date & Time string in the W3C Format to DATE type
    
Arguments:

    szDateString    -   String representing date in format Year-Month-Day
    szTimeString    -   String representing time in format HH:MM:SS
    pDateTime       -   Output DATE

Return Value:

    TRUE  - Succeeded
    FALSE - Failed

--*/

{

    WORD        iVal;
    PCHAR       pCh;

    SYSTEMTIME  sysTime;

    //
    // Process the Date. Format is 1998-01-27 ( Year-Month-Day )
    //

    memset (&sysTime,0,sizeof(sysTime));
    pCh = szDateString;
    
    sysTime.wYear = (*pCh-'0')*1000 + ( *(pCh+1)-'0' )*100 + 
                    ( *(pCh+2)-'0')*10 + ( *(pCh+3)-'0');

    pCh += 5;

    iVal = *pCh -'0';
    if ( *(pCh+1) != '/')
    {
        iVal = iVal*10 + *(pCh+1) - '0';
        pCh++;
    }
    sysTime.wMonth = iVal;
    
    pCh+=2;

    iVal = *pCh -'0';
    if ( *(pCh+1) != '/')
    {
        iVal = iVal*10 + *(pCh+1) - '0';
    }
    sysTime.wDay = iVal;

    //
    // Process the Time. Format is 10:47:44 ( HH:MM:SS )
    //

    pCh = szTimeString;

    iVal = *pCh -'0';
    if ( *(pCh+1) != ':')
    {
        iVal = iVal*10 + *(pCh+1) - '0';
        pCh++;
    }
    sysTime.wHour = iVal;
    
    pCh += 2;

    iVal = *pCh -'0';
    if ( *(pCh+1) != ':')
    {
        iVal = iVal*10 + *(pCh+1) - '0';
        pCh++;
    }
    sysTime.wMinute = iVal;

    pCh += 2;

    iVal = *pCh -'0';
    if ( *(pCh+1) != '\0')
    {
        iVal = iVal*10 + *(pCh+1) - '0';
    }
    sysTime.wSecond = iVal;
    
    return SystemTimeToVariantTime(&sysTime, pDateTime);
}

/* ************************************************************************************ */
/* Support Functions                                                                    */
/* ************************************************************************************ */

VOID
CEXTLOG::FormNewLogFileName(
                IN LPSYSTEMTIME pstNow
                )
/*++
  This function that forms the new log file name based on
   type of periodic logging done.

  Arguments:
    pstNow     pointer to SystemTime which contains the current time.
    fBackup    flag indicating if we want to make current file a backup.

  Returns:
    TRUE on success in forming the name or FALSE if there is any error.

--*/
{

    I_FormNewLogFileName(pstNow,DEFAULT_EXTENDED_LOG_FILE_NAME);

} // INET_FILE_LOG::FormNewLogFileName()

/* ************************************************************************************ */

LPCSTR
CEXTLOG::QueryNoPeriodPattern(
    VOID
    )
{
    return szExtNoPeriodPattern;
} // CEXTLOG::QueryNoPeriodPattern

/* ************************************************************************************ */

VOID
CEXTLOG::InternalGetConfig(
        PINETLOG_CONFIGURATIONA pLogConfig
        )
{
    CLogFileCtrl::InternalGetConfig( pLogConfig );
    pLogConfig->u.logFile.dwFieldMask = m_lMask;
}

/* ************************************************************************************ */

VOID
CEXTLOG::InternalGetExtraLoggingFields(
    PDWORD pcbSize,
    PCHAR  pszFieldsList
    )
{
    TCHAR *pszTmp = pszFieldsList;
    DWORD dwSize = 0;
    DWORD dwFieldSize;

    if (m_lMask & EXTLOG_HOST ) {
        lstrcpy( pszTmp, "Host:");
        dwFieldSize = strlen(pszTmp)+1;
        pszTmp += dwFieldSize;
        dwSize += dwFieldSize;
    }

    if (m_lMask & EXTLOG_USER_AGENT ) {
        lstrcpy( pszTmp, "User-Agent:");
        dwFieldSize = strlen(pszTmp)+1;
        pszTmp += dwFieldSize;
        dwSize += dwFieldSize;
    }

    if (m_lMask & EXTLOG_COOKIE ) {
        lstrcpy( pszTmp, "Cookie:");
        dwFieldSize = strlen(pszTmp)+1;
        pszTmp += dwFieldSize;
        dwSize += dwFieldSize;
    }

    if (m_lMask & EXTLOG_REFERER ) {
        lstrcpy( pszTmp, "Referer:");
        dwFieldSize = strlen(pszTmp)+1;
        pszTmp += dwFieldSize;
        dwSize += dwFieldSize;
    }
    pszTmp[0]='\0';
    dwSize++;
    *pcbSize = dwSize;
    return;

} // CEXTLOG::InternalGetExtraLoggingFields

/* ************************************************************************************ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\filectl.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      filectl.cxx

   Abstract:
      OLE control to handle file logging object

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

#include "precomp.hxx"
#include "initguid.h"
#include <ilogobj.hxx>
#include "filectl.hxx"
#include <issched.hxx>

#include <atlimpl.cpp>

#define LOG_FILE_SLOP       512

//
// tick minute.
//

#define TICK_MINUTE         (60 * 1000)

//************************************************************************************


VOID
LogWriteEvent(
    IN LPCSTR InstanceName,
    IN BOOL   fResume
    );

//
// globals
//

LPEVENT_LOG   g_eventLog = NULL;


CLogFileCtrl::CLogFileCtrl(
    VOID
    )
:
    m_fFirstLog             ( TRUE),
    m_pLogFile              ( NULL),
    m_fDiskFullShutdown     ( FALSE),
    m_fUsingCustomHeaders   ( FALSE),
    m_sequence              ( 1),
    m_TickResumeOpen        ( 0),
    m_strLogFileName        ( ),
    m_dwSchedulerCookie     ( 0),
    m_fInTerminate          ( FALSE)
/*++

Routine Description:
    Contructor for the log file control

Arguments:

Return Value:

--*/
{
    //
    // initialize all the internal variable
    //

    ZeroMemory( &m_stCurrentFile, sizeof( m_stCurrentFile));
    INITIALIZE_CRITICAL_SECTION( &m_csLock );
}


//************************************************************************************
// CLogFileCtrl::~CLogFileCtrl - Destructor

CLogFileCtrl::~CLogFileCtrl()
/*++

Routine Description:
    destructor for the log file control

Arguments:

Return Value:

--*/
{
    TerminateLog();

    DeleteCriticalSection( &m_csLock );
}

//************************************************************************************

STDMETHODIMP
CLogFileCtrl::InitializeLog(
                LPCSTR szInstanceName,
                LPCSTR pszMetabasePath,
                CHAR* pvIMDCOM )
/*++

Routine Description:
    Initialize log

Arguments:
    cbSize - size of the service name
    RegKey - service name
    dwInstanceOf - instance number

Return Value:

--*/
{
    //
    // get the default parameters
    //

    m_strInstanceName.Copy(szInstanceName);
    m_strMetabasePath.Copy(pszMetabasePath);
    m_pvIMDCOM = (LPVOID)pvIMDCOM;

    //
    // get the registry value
    //

    (VOID)GetRegParameters(
                    pszMetabasePath,
                    pvIMDCOM );

     return 0;
}

//************************************************************************************

STDMETHODIMP
CLogFileCtrl::TerminateLog(
    VOID
    )
/*++

Routine Description:
    clean up the log

Arguments:

Return Value:

--*/
{    
    Lock( );

    m_fInTerminate = TRUE;

    if ( m_pLogFile!=NULL) {
        m_pLogFile->CloseFile( );
        delete m_pLogFile;
        m_pLogFile = NULL;
    }

    if (m_dwSchedulerCookie)
    {
        RemoveWorkItem(m_dwSchedulerCookie);
    }

    m_dwSchedulerCookie = 0;

    m_fInTerminate = FALSE;
    
    Unlock( );

    return(TRUE);
}

//************************************************************************************

STDMETHODIMP
CLogFileCtrl::LogInformation(
            IInetLogInformation * ppvDataObj
            )
/*++

Routine Description:
    log information

Arguments:
    ppvDataObj - COM Logging object

Return Value:

--*/
{
    SYSTEMTIME stNow;

    CHAR    tmpBuf[512];
    DWORD   dwSize = sizeof(tmpBuf);
    PCHAR   pBuf = tmpBuf;
    DWORD   err;

retry:

    err = NO_ERROR;
    
    if ( FormatLogBuffer(ppvDataObj,
                        pBuf,
                        &dwSize,
                        &stNow         // time is returned
                        ) 
       ) 
    {
        WriteLogInformation(stNow, pBuf, dwSize, FALSE, FALSE);
    }
    else 
    {

        err = GetLastError();
        
        IIS_PRINTF((buff,"FormatLogBuffer failed with %d\n",GetLastError()));

        if ( (err == ERROR_INSUFFICIENT_BUFFER) &&
             ( pBuf == tmpBuf ) &&
             (dwSize <= MAX_LOG_RECORD_LEN) ) 
        {
             
            pBuf = (PCHAR)LocalAlloc( 0, dwSize );
            
            if ( pBuf != NULL ) 
            {
                goto retry;
            }
        }
    }

    if ( (pBuf != tmpBuf) && (pBuf != NULL) ) 
    {
        LocalFree( pBuf );
    }
    
    return(0);

} // LogInformation

//************************************************************************************

STDMETHODIMP
CLogFileCtrl::GetConfig( DWORD cbSize, BYTE * log)
/*++

Routine Description:
    get configuration information

Arguments:
    cbSize - size of the data structure
    log - log configuration data structure

Return Value:

--*/
{
    InternalGetConfig( (PINETLOG_CONFIGURATIONA)log );
    return(0L);
}

//************************************************************************************

STDMETHODIMP
CLogFileCtrl::QueryExtraLoggingFields(
    IN PDWORD   pcbSize,
    PCHAR       pszFieldsList
    )
/*++

Routine Description:
    get configuration information

Arguments:
    cbSize - size of the data structure
    log - log configuration data structure

Return Value:

--*/
{
    InternalGetExtraLoggingFields( pcbSize, pszFieldsList );
    return(0L);
}

//************************************************************************************

STDMETHODIMP
CLogFileCtrl::LogCustomInformation( 
    IN  DWORD               cCount, 
    IN  PCUSTOM_LOG_DATA    pCustomLogData,
    IN  LPSTR               szHeaderSuffix
    )
{
    return(0L);
}

//************************************************************************************

void
CLogFileCtrl::InternalGetExtraLoggingFields(
                            PDWORD pcbSize,
                            TCHAR *pszFieldsList
                            )
{
    pszFieldsList[0]=_T('\0');
    pszFieldsList[1]=_T('\0');
    *pcbSize = 2;
}

//************************************************************************************

VOID
CLogFileCtrl::InternalGetConfig(
    IN PINETLOG_CONFIGURATIONA pLogConfig
    )
/*++

Routine Description:
    internal; get configuration information function.

Arguments:
    log - log configuration data structure

Return Value:

--*/
{
    pLogConfig->inetLogType = INET_LOG_TO_FILE;
    strcpy(
        pLogConfig->u.logFile.rgchLogFileDirectory,
        QueryLogFileDirectory()
        );

    pLogConfig->u.logFile.cbSizeForTruncation = QuerySizeForTruncation();
    pLogConfig->u.logFile.ilPeriod = QueryPeriod();
    pLogConfig->u.logFile.ilFormat = QueryLogFormat();
}

//************************************************************************************

STDMETHODIMP
CLogFileCtrl::SetConfig(
                        DWORD cbSize,
                        BYTE * log
                        )
/*++

Routine Description:
    set the log configuration information

Arguments:
    cbSize - size of the configuration data structure
    log - log information

Return Value:

--*/
{
    //
    // write the configuration information to the registry
    //

    PINETLOG_CONFIGURATIONA pLogConfig = (PINETLOG_CONFIGURATIONA)log;
    SetSizeForTruncation( pLogConfig->u.logFile.cbSizeForTruncation );
    SetPeriod( pLogConfig->u.logFile.ilPeriod );
    SetLogFileDirectory( pLogConfig->u.logFile.rgchLogFileDirectory );
    return(0L);
} // CLogFileCtrl::SetConfig

//************************************************************************************

DWORD
CLogFileCtrl::GetRegParameters(
    IN LPCSTR pszRegKey,
    IN LPVOID pvIMDCOM
    )
/*++

Routine Description:
    get the registry value

Arguments:
    strRegKey - registry key

Return Value:

--*/
{

    DWORD err = NO_ERROR;
    MB    mb( (IMDCOM*) m_pvIMDCOM );
    DWORD dwSize;
    CHAR  szTmp[MAX_PATH+1];
    DWORD cbTmp = sizeof(szTmp);
    CHAR  buf[MAX_PATH+1];
    DWORD dwPeriod;

    if ( !mb.Open("") ) {
        err = GetLastError();
        return(err);
    }

    //
    // Get log file period
    //

    if ( mb.GetDword(
            pszRegKey,
            MD_LOGFILE_PERIOD,
            IIS_MD_UT_SERVER,
            &dwPeriod ) )
    {
        //
        // Make sure it is within bounds
        //

        if ( dwPeriod > INET_LOG_PERIOD_HOURLY ) 
        {
            IIS_PRINTF((buff,"Invalid log period %d, set to %d\n",
                dwPeriod, DEFAULT_LOG_FILE_PERIOD));

            dwPeriod = DEFAULT_LOG_FILE_PERIOD;
        }
        
    } 
    else 
    {
        dwPeriod = DEFAULT_LOG_FILE_PERIOD;
    }

    SetPeriod( dwPeriod );

    //
    //  Get truncate size
    //

    if ( dwPeriod == INET_LOG_PERIOD_NONE ) 
    {

        SetSizeForTruncation ( DEFAULT_LOG_FILE_TRUNCATE_SIZE );
        
        if ( mb.GetDword(   pszRegKey,
                            MD_LOGFILE_TRUNCATE_SIZE,
                            IIS_MD_UT_SERVER,
                            &dwSize ) ) 
        {

            if ( dwSize < MIN_FILE_TRUNCATION_SIZE ) 
            {
                dwSize = MIN_FILE_TRUNCATION_SIZE;
                IIS_PRINTF((buff,
                    "Setting truncation size to %d\n", dwSize));
            }

            SetSizeForTruncation( dwSize );
        }
    } 
    else 
    {
        SetSizeForTruncation( NO_FILE_TRUNCATION );
    }

    //
    // Get directory
    //

    if ( !mb.GetExpandString(
                    pszRegKey,
                    MD_LOGFILE_DIRECTORY,
                    IIS_MD_UT_SERVER,
                    szTmp,
                    &cbTmp ) )
    {
        lstrcpy(szTmp,
            TsIsWindows95() ?
                DEFAULT_LOG_FILE_DIRECTORY_W95 :
                DEFAULT_LOG_FILE_DIRECTORY_NT );
    }

    mb.Close();

    ExpandEnvironmentStrings( szTmp, buf, MAX_PATH+1 );
    SetLogFileDirectory( buf );
    
    return(err);

} // CLogFileCtrl::GetRegParameters

//************************************************************************************


BOOL
CLogFileCtrl::OpenLogFile(
    IN PSYSTEMTIME  pst
    )
/*++

Routine Description:
    internal routine to open file.

Arguments:

Return Value:

--*/
{
    BOOL fReturn = TRUE;
    BOOL bRet = FALSE;
    HANDLE hToken = NULL;
    DWORD dwError = NO_ERROR;
    CHAR  rgchPath[ MAX_PATH + 1 + 32];

    if ( m_pLogFile != NULL) {

        //
        // already a log file is open. return silently
        //

        IIS_PRINTF( ( buff,
                    " Log File %s is already open ( %08x)\n",
                    m_strLogFileName.QueryStr(), m_pLogFile));

    } else {

        //
        // If this the first time we opened, get the file name
        //

        if ( m_fFirstLog || (QueryPeriod() != INET_LOG_PERIOD_NONE) ) {
            m_fFirstLog = FALSE;
            FormNewLogFileName( pst );
        }

        //
        // Append log file name to path to form the path of file to be opened.
        //

        if ( (m_strLogFileName.QueryCCH() +
                m_strLogFileDirectory.QueryCCH() >= MAX_PATH) ||
             (m_strLogFileDirectory.QueryCCH() < 3) ) {

            fReturn = FALSE;

            if ( (g_eventLog != NULL) && !m_fDiskFullShutdown) {

                const CHAR*    tmpString[1];
                tmpString[0] = rgchPath;
                g_eventLog->LogEvent(
                    LOG_EVENT_CREATE_DIR_ERROR,
                    1,
                    tmpString,
                    ERROR_BAD_PATHNAME );
            }
            SetLastError( ERROR_BAD_PATHNAME );
            goto exit;
        }

        lstrcpy( rgchPath, QueryLogFileDirectory());
//      if ( rgchPath[strlen(rgchPath)-1] != '\\' ) {

        if ( *CharPrev(rgchPath, rgchPath + strlen(rgchPath)) != '\\' ) {
            lstrcat( rgchPath, "\\");
        }
        lstrcat( rgchPath, QueryInstanceName() );

        //
        // There is a small chance that this function could be called (indirectly)
        // from an INPROC ISAPI completion thread (HSE_REQ_DONE).  In this case
        // the thread token is the impersonated user and may not have permissions
        // to open the log file (especially if the user is the IUSR_ account).  
        // To be paranoid, let's revert to LOCAL_SYSTEM anyways before opening.
        //

        if ( OpenThreadToken( GetCurrentThread(), 
                              TOKEN_ALL_ACCESS, 
                              FALSE, 
                              &hToken ) )
        {
            DBG_ASSERT( hToken != NULL );
            RevertToSelf();
        }

        // Allow logging to mapped drives
        
        bRet = IISCreateDirectory( rgchPath, TRUE );
        dwError = GetLastError();

        if ( hToken != NULL )
        {
            SetThreadToken( NULL, hToken );
            SetLastError( dwError );
        } 
    
        if ( !bRet ) {

            if ( (g_eventLog != NULL) && !m_fDiskFullShutdown) {

                const CHAR*    tmpString[1];
                tmpString[0] = rgchPath;
                g_eventLog->LogEvent(
                    LOG_EVENT_CREATE_DIR_ERROR,
                    1,
                    tmpString,
                    GetLastError()
                    );
            }

            IIS_PRINTF((buff,"IISCreateDir[%s] error %d\n",
                rgchPath, GetLastError()));
            fReturn = FALSE;
            goto exit;
        }

        lstrcat( rgchPath, "\\");
        lstrcat( rgchPath, m_strLogFileName.QueryStr());

        m_pLogFile = new ILOG_FILE( );

        if (m_pLogFile != NULL) {

            if ( m_pLogFile->Open(
                        rgchPath,
                        QuerySizeForTruncation(),
                        !m_fDiskFullShutdown
                        ) ) {

                m_pLogFile->QueryFileSize(&m_cbTotalWritten);
            } else {

                delete m_pLogFile;
                m_pLogFile = NULL;
                fReturn = FALSE;
            }

        } else {

            IIS_PRINTF((buff,"Unable to allocate ILOG_FILE[err %d]\n",
                GetLastError()));

            fReturn = FALSE;
        }
    }

exit:

    return ( fReturn);

} // CLogFileCtrl::OpenLogFile

//************************************************************************************


BOOL
CLogFileCtrl::WriteLogDirectives(
    IN DWORD Sludge
    )
/*++

Routine Description:
    virtual function for the sub class to log directives to the file.

Arguments:

    Sludge - number of additional bytes that needs to be written
        together with the directives

Return Value:

    TRUE, ok
    FALSE, not enough space to write.

--*/
{
    //
    // if we will overflow, open another file
    //

    if ( IsFileOverFlowForCB( Sludge ) ) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        DBGPRINTF((DBG_CONTEXT,
            "Unable to write directive\n"));
        return(FALSE);
    }

    return TRUE;
} // CLogFileCtrl::WriteLogDirectives

//************************************************************************************

BOOL
CLogFileCtrl::WriteCustomLogDirectives(
    IN DWORD Sludge
    )
{
   
    return TRUE;
}

//************************************************************************************

VOID
CLogFileCtrl::I_FormNewLogFileName(
                    IN LPSYSTEMTIME pstNow,
                    IN LPCSTR       LogNamePrefix
                    )
{

    CHAR    tmpBuf[MAX_PATH+1];

    WORD wYear = ( pstNow->wYear % 100);  // retain just last 2 digits.

    switch ( QueryPeriod( ) ) {

    case INET_LOG_PERIOD_HOURLY:

        wsprintf( tmpBuf, "%.2s%02.2u%02u%02u%02u.%s",
                  LogNamePrefix,
                  wYear,
                  pstNow->wMonth,
                  pstNow->wDay,
                  pstNow->wHour,
                  DEFAULT_LOG_FILE_EXTENSION);
        break;

    case INET_LOG_PERIOD_DAILY:

        wsprintf( tmpBuf, "%.2s%02.2u%02u%02u.%s",
                  LogNamePrefix,
                  wYear,
                  pstNow->wMonth,
                  pstNow->wDay,
                  DEFAULT_LOG_FILE_EXTENSION);
        break;

    case INET_LOG_PERIOD_WEEKLY:

        wsprintf( tmpBuf, "%.2s%02.2u%02u%02u.%s",
                  LogNamePrefix,
                  wYear,
                  pstNow->wMonth,
                  WeekOfMonth(pstNow),
                  DEFAULT_LOG_FILE_EXTENSION);
        break;

    case INET_LOG_PERIOD_MONTHLY:
    
        wsprintf( tmpBuf, "%.2s%02u%02u.%s",
                  LogNamePrefix,
                  wYear,
                  pstNow->wMonth,
                  DEFAULT_LOG_FILE_EXTENSION);
        break;

    case INET_LOG_PERIOD_NONE:
    default:

        wsprintf(tmpBuf, "%.6s%u.%s",
              LogNamePrefix,
              m_sequence,
              DEFAULT_LOG_FILE_EXTENSION);

        m_sequence++;
        break;

    } // switch()

    m_strLogFileName.Copy(tmpBuf);

    return;
}

//************************************************************************************

VOID
CLogFileCtrl::SetLogFileDirectory(
        IN LPCSTR pszDir
        )
{

    STR tmpStr;
    HANDLE hFile;
    WIN32_FIND_DATA findData;
    DWORD   maxFileSize = 0;

    m_strLogFileDirectory.Copy(pszDir);

    //
    // if period is not none, then return
    //

    if ( QueryPeriod() != INET_LOG_PERIOD_NONE ) {
        return;
    }

    //
    // Get the starting sequence number
    //

    m_sequence = 1;

    //
    // Append instance name and the pattern.
    // should look like c:\winnt\system32\logfiles\w3svc1\inetsv*.log
    //

    tmpStr.Copy(pszDir);
//    if ( pszDir[tmpStr.QueryCCH()-1] != '\\' ) {
    if ( *CharPrev(pszDir, pszDir + tmpStr.QueryCCH()) != '\\' ) {
        tmpStr.Append("\\");
    }
    tmpStr.Append( QueryInstanceName() );
    tmpStr.Append( "\\" );
    tmpStr.Append( QueryNoPeriodPattern() );

    hFile = FindFirstFile( tmpStr.QueryStr(), &findData );
    if ( hFile == INVALID_HANDLE_VALUE ) {
        return;
    }

    do {

        PCHAR ptr;
        DWORD sequence = 1;

        ptr = strchr(findData.cFileName, '.');
        if (ptr != NULL ) {
            *ptr = '\0';
            ptr = findData.cFileName;

            while ( *ptr != '\0' ) {

                if ( isdigit((UCHAR)(*ptr)) ) {
                    sequence = atoi( ptr );
                    break;
                }
                ptr++;
            }

            if ( sequence > m_sequence ) {
                maxFileSize = findData.nFileSizeLow;
                m_sequence = sequence;
                DBGPRINTF((DBG_CONTEXT,
                    "Sequence start is %d[%d]\n", sequence, maxFileSize));
            }
        }

    } while ( FindNextFile( hFile, &findData ) );

    FindClose(hFile);

    if ( (maxFileSize+LOG_FILE_SLOP) > QuerySizeForTruncation() ) {
        m_sequence++;
    }

    return;

} // SetLogFileDirectory

//************************************************************************************

VOID
CLogFileCtrl::WriteLogInformation(
    IN SYSTEMTIME&     stNow, 
    IN PCHAR           pBuf, 
    IN DWORD           dwSize, 
    IN BOOL            fCustom,
    IN BOOL            fResetHeaders 
    )
/*++

Routine Description:
    write log line to file

Arguments:
    stNow           Present Time
    fResetHeaders   TRUE -> Reset headers, FALSE -> Don't reset headers
    pBuf            Pointer to Log Line
    dwSize          Number of characters in pBuf
    fCustom         TRUE -> Using custom logging, FALSE -> normal logging

Return Value:

--*/
{

    BOOL    fOpenNewFile;
    DWORD   err;
    DWORD   tickCount = 0;


    Lock ( );

    if ( m_pLogFile != NULL ) 
    {
        if ( QueryPeriod() == INET_LOG_PERIOD_DAILY ) 
        {
            fOpenNewFile = (m_stCurrentFile.wDay != stNow.wDay) ||
                           (m_stCurrentFile.wMonth != stNow.wMonth);
        } 
        else 
        {
            fOpenNewFile = IsBeginningOfNewPeriod( QueryPeriod(),
                                                   &m_stCurrentFile,
                                                   &stNow) ||
                           IsFileOverFlowForCB( dwSize);

             //
             // Reset headers if day is over. Used for weekly or unlimited files.
             //

             if ( !fOpenNewFile && !fResetHeaders)
             {
                fResetHeaders = (m_stCurrentFile.wDay != stNow.wDay) ||
                                (m_stCurrentFile.wMonth != stNow.wMonth);
             }
        }
    } 
    else 
    {
        fOpenNewFile = TRUE;
    }

    if (fOpenNewFile ) 
    {

        //
        // open a file only after every minute when we hit disk full
        //

        if ( m_TickResumeOpen != 0 ) 
        {
            tickCount = GetTickCount( );

            if ( (tickCount < m_TickResumeOpen) ||
                 ((tickCount + TICK_MINUTE) < tickCount ) )  // The Tick counter is about to wrap.
            {
                goto exit_tick;
            }
        }

retry_open:

        //
        // Close existing log
        //

        TerminateLog();

        //
        // Open new log file
        //

        if ( OpenLogFile( &stNow ) ) 
        {
            //
            // Schedule Callback for closing log file and set flag for writing directives.
            //

            ScheduleCallback(stNow);
            
            fResetHeaders = TRUE;
        }
        else
        {
            err = GetLastError();

            //
            // The file is already bigger than the truncate size
            // try another one.
            //

            if ( err == ERROR_INSUFFICIENT_BUFFER ) 
            {
                FormNewLogFileName( &stNow );
                err = NO_ERROR;
                goto retry_open;
            }

            goto exit;
        }
    }

    //
    // Reset Headers if needed
    //

    if ((fResetHeaders) || (fCustom != m_fUsingCustomHeaders))
    {
        BOOL fSucceeded;
        
        if (fCustom)
        {
            m_fUsingCustomHeaders = TRUE;
            fSucceeded = WriteCustomLogDirectives(dwSize);
        }
        else
        {
            m_fUsingCustomHeaders = FALSE;
            fSucceeded = WriteLogDirectives(dwSize);
        }
            
        if (!fSucceeded) 
        {
            err = GetLastError( );

            if ( err == ERROR_INSUFFICIENT_BUFFER ) 
            {
                FormNewLogFileName( &stNow );
                err = NO_ERROR;
                goto retry_open;
            }

            TerminateLog();
            goto exit;
        }

        //
        // record the time of opening of this new file
        //

        m_stCurrentFile = stNow;
    }

    //
    // write it to the buffer
    //

    if ( m_pLogFile->Write(pBuf, dwSize) ) 
    {
        IncrementBytesWritten(dwSize);

        //
        // If this had been shutdown, log event for reactivation
        //

        if ( m_fDiskFullShutdown ) 
        {
            m_fDiskFullShutdown = FALSE;
            m_TickResumeOpen = 0;

            LogWriteEvent( QueryInstanceName(), TRUE );
        }
    } 
    else 
    {
        err = GetLastError();
        TerminateLog( );
    }

exit:

    if ( err == ERROR_DISK_FULL ) 
    {
        if ( !m_fDiskFullShutdown ) 
        {
            m_fDiskFullShutdown = TRUE;
            LogWriteEvent( QueryInstanceName(), FALSE );
        }
        
        m_TickResumeOpen = GetTickCount();
        m_TickResumeOpen += TICK_MINUTE;
    }

exit_tick:

    Unlock( );

} // LogInformation


//************************************************************************************

DWORD
CLogFileCtrl::ScheduleCallback(SYSTEMTIME& stNow)
{
    DWORD dwTimeRemaining = 0;
    
    switch (m_dwPeriod)
    {
        case INET_LOG_PERIOD_HOURLY:
            dwTimeRemaining = 60*60 - 
                              (stNow.wMinute*60 + 
                               stNow.wSecond);
            break;
            
        case INET_LOG_PERIOD_DAILY:
            dwTimeRemaining = 24*60*60 - 
                              (stNow.wHour*60*60 + 
                               stNow.wMinute*60 + 
                               stNow.wSecond);
            break;
            
        case INET_LOG_PERIOD_WEEKLY:
            dwTimeRemaining = 7*24*60*60 -
                              (stNow.wDayOfWeek*24*60*60 + 
                               stNow.wHour*60*60 + 
                               stNow.wMinute*60 + 
                               stNow.wSecond);
            break;
            
        case INET_LOG_PERIOD_MONTHLY:
        
            DWORD   dwNumDays = 31;

            if ( (4 == stNow.wMonth) ||     // April
                 (6 == stNow.wMonth) ||     // June
                 (9 == stNow.wMonth) ||     // September
                 (11 == stNow.wMonth)       // November
               )
            {
                dwNumDays = 30;
            }

            if (2 == stNow.wMonth)          // February
            {
		if ((stNow.wYear % 4 == 0 && stNow.wYear % 100 != 0) || stNow.wYear % 400 == 0)
                {
                    //
                    // leap year.
                    //

                    dwNumDays = 29;
                }
                else
                {
                    dwNumDays = 28;
                }
            }
            
            dwTimeRemaining = dwNumDays*24*60*60 -
                              (stNow.wDay*24*60*60 + 
                               stNow.wHour*60*60 + 
                               stNow.wMinute*60 + 
                               stNow.wSecond);
            break;
    }

    //
    // Convert remaining time to millisecs
    //
    
    dwTimeRemaining = dwTimeRemaining*1000 - stNow.wMilliseconds;
    
    if (dwTimeRemaining)
    {
        m_dwSchedulerCookie =  ScheduleWorkItem(
                                    LoggingSchedulerCallback,
                                    this,
                                    dwTimeRemaining,
                                    FALSE);
    }                

    return(m_dwSchedulerCookie);
}

//************************************************************************************

CHAR * SkipWhite( CHAR * pch )
{
    while ( ISWHITEA( *pch ) )
    {
        pch++;
    }

    return pch;
}

//************************************************************************************

DWORD
FastDwToA(
    CHAR*   pBuf,
    DWORD   dwV
    )
/*++

Routine Description:
    Convert DWORD to ascii (decimal )
    returns length ( w/o trailing '\0' )

Arguments:
    pBuf - buffer where to store converted value
    dwV - value to convert

Return Value:
    length of ascii string

--*/
{
    DWORD   v;

    if ( dwV < 10 ) {
        pBuf[0] = (CHAR)('0'+dwV);
        pBuf[1] = '\0';
        return 1;
    } else if ( dwV < 100 ) {
        pBuf[0] = (CHAR)((dwV/10) + '0');
        pBuf[1] = (CHAR)((dwV%10) + '0');
        pBuf[2] = '\0';
        return 2;
    } else if ( dwV < 1000 ) {
        pBuf[0] = (CHAR)((v=dwV/100) + '0');
        dwV -= v * 100;
        pBuf[1] = (CHAR)((dwV/10) + '0');
        pBuf[2] = (CHAR)((dwV%10) + '0');
        pBuf[3] = '\0';
        return 3;
    } else if ( dwV < 10000 ) {

        pBuf[0] = (CHAR)((v=dwV/1000) + '0');
        dwV -= v * 1000;
        pBuf[1] = (CHAR)((v=dwV/100) + '0');
        dwV -= v * 100;
        pBuf[2] = (CHAR)((dwV/10) + '0');
        pBuf[3] = (CHAR)((dwV%10) + '0');
        pBuf[4] = '\0';
        return 4;
    }

    _ultoa(dwV, pBuf, 10);
    return strlen(pBuf);
    
} // FastDwToA

//************************************************************************************

VOID
LogWriteEvent(
    IN LPCSTR InstanceName,
    IN BOOL   fResume
    )
{
    if ( g_eventLog != NULL ) {

        const CHAR*    tmpString[1];
        tmpString[0] = InstanceName;

        g_eventLog->LogEvent(
                fResume ?
                    LOG_EVENT_RESUME_LOGGING :
                    LOG_EVENT_DISK_FULL_SHUTDOWN,
                1,
                tmpString,
                0);
    }
    return;
} // LogWriteEvent

//************************************************************************************

VOID WINAPI LoggingSchedulerCallback( PVOID pContext)
{
    CLogFileCtrl *pLog = (CLogFileCtrl *) pContext;

    //
    // There is a possibility of deadlock if another thread is inside TerminateLog
    // stuck in RemoveWorkItem, waiting for this callback thread to complete. To
    // prevent that we use the synchronization flag - m_fInTerminate.
    //
    
    pLog->m_dwSchedulerCookie = 0;

    if (!pLog->m_fInTerminate)
    {
        pLog->TerminateLog();
    }
}

//************************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\misc.cpp ===
#include "precomp.hxx"

VOID
ConvertSpacesToPlus(
    IN LPSTR    pszString
    )
{
    if ( pszString != NULL ) {
        while ( *pszString != '\0' ) {
            if (isspace((UCHAR)*pszString)) {
                *pszString = '+';
            }
            pszString++;
        }
    }

    return;
}

DWORD
WeekOfMonth(
    IN LPSYSTEMTIME pstNow
    )
/*++
  Finds the ordinal number of the week of current month.
  The numbering of weeks starts from 1 and run through 5 per month (max).
  The week number changes only on sundays.

  The calculation to be use is:
     1 + ( dayOfMonth - 1)/7  + (( dayOfMonth - 1) % 7 > dayOfWeek);
     (a)     (b)                       (c)                (d)

     (a) to set the week numbers to begin from week numbered "1"
     (b) used to calculate the rough number of the week on which a given
        day falls based on the date.
     (c) calculates what is the offset from the start of week for a given
        day based on the fact that a week had 7 days.
     (d) is the raw day of week given to us.
      (c) > (d) indicates that the week is rolling forward and hence
        the week count should be offset by 1 more.

--*/
{
    DWORD dwTmp;

    dwTmp = (pstNow->wDay - 1);
    dwTmp = ( 1 + dwTmp/7 + (((dwTmp % 7) > pstNow->wDayOfWeek) ? 1 : 0));

    return ( dwTmp);
} // WeekOfMonth()


BOOL
IsBeginningOfNewPeriod(
    IN DWORD          dwPeriod,
    IN LPSYSTEMTIME   pstCurrentFile,
    IN LPSYSTEMTIME   pstNow
    )
/*++
    This function checks to see if we are beginning a new period for
    a given periodic interval type ( specified using dwPeriod).

Arguments:
    dwPeriod    INETLOG_PERIOD  specifying the periodic interval.
    pstCurrentFile  pointer to SYSTEMTIME for the current file.
    pstNow      pointer to SYSTEMTIME for the present time.

Returns:
    TRUE if a new period is beginning ( ie pstNow > pstCurrentFile).
    FALSE otherwise.
--*/
{

    BOOL fNewPeriod = FALSE;

    switch ( dwPeriod) {

    case INET_LOG_PERIOD_HOURLY:
        fNewPeriod = (pstCurrentFile->wHour != pstNow->wHour);

        //
        // Fall Through
        //

    case INET_LOG_PERIOD_DAILY:
        fNewPeriod = fNewPeriod || (pstCurrentFile->wDay != pstNow->wDay);

        //
        // Fall Through
        //

    case INET_LOG_PERIOD_MONTHLY:

        fNewPeriod = fNewPeriod || (pstCurrentFile->wMonth != pstNow->wMonth);
        break;

    case INET_LOG_PERIOD_WEEKLY:
        fNewPeriod =
            (WeekOfMonth(pstCurrentFile) != WeekOfMonth(pstNow)) ||
            (pstCurrentFile->wMonth != pstNow->wMonth);
        break;

    case INET_LOG_PERIOD_NONE:
    default:
        break;
    } // switch()

    return(fNewPeriod);
}// IsBeginningOfNewPeriod
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\odblogc.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      odblogc.cpp

   Abstract:
      NCSA Logging Format implementation

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

#include "precomp.hxx"
#include "odbcconn.hxx"
#include <ilogobj.hxx>
#include "odblogc.hxx"
#include <iadmw.h>


/************************************************************
 *    Symbolic Constants and Data
 ************************************************************/

# define MAX_SQL_FIELD_NAMES_LEN       ( 400)
# define MAX_SQL_FIELD_VALUES_LEN      ( 200)
# define MAX_SQL_IDENTIFIER_QUOTE_CHAR ( 50)

# define PSZ_UNKNOWN_FIELD_W      _T("-")
# define PSZ_UNKNOWN_FIELD_A      _T("-")

# define PSZ_GET_ERROR_FAILED_A    _T("ODBC:GetLastError() Failed")
# define LEN_PSZ_GET_ERROR_FAILED_A  sizeof(PSZ_GET_ERROR_FAILED_A)

# define PSZ_GET_ERROR_FAILED_W    _T("ODBC:GetLastError() Failed")
# define LEN_PSZ_GET_ERROR_FAILED_W  sizeof(PSZ_GET_ERROR_FAILED_W)

//
//  The template of SQL command has 3 arguments.
//   1. table name
//   2. field names
//   3. field values
// 1,2 and 3 are obained  during the first wsprintf
//

static const CHAR  sg_rgchSqlInsertCmdTemplate[] =
    _T("insert into %s ( %s) values ( %s)");

# define PSZ_SQL_INSERT_CMD_TEMPLATE    (  sg_rgchSqlInsertCmdTemplate)
# define LEN_PSZ_SQL_INSERT_CMD_TEMPLATE  \
           ( lstrlen( PSZ_SQL_INSERT_CMD_TEMPLATE))

//
// Leave %ws so that we can print the service and server name when this
//   string is used to generate an SQL statement.
//
static const CHAR sg_rgchStdLogFieldValues[] =
   _T(" ?, ?, ?, '%s', '%s', ?, ?, ?, ?, ?, ?, ?, ?, ?");

# define PSZ_INTERNET_STD_LOG_FORMAT_FIELD_NAMES  ( sg_rgchStdLogFieldNames)
# define PSZ_INTERNET_STD_LOG_FORMAT_FIELD_VALUES ( sg_rgchStdLogFieldValues)


//
// AllFieldInfo()
//  Defines all the fields required for SQL logging of the information
//   to the database using ODBC interfaces.
//  C arrays are numbered from offset 0.
//  SQL columns are numbered from 1.
//  field index values start from 0 and we adjust it when we talk of SQL col.
//  FieldInfo( symbolic-name, field-name,
//             field-index/column-number,
//             field-C-type, field-Sql-type,
//             field-precision, field-max-size, field-cb-value)
//

# define StringField( symName, fldName, fldIndex, prec)  \
FieldInfo( symName, fldName, fldIndex, SQL_C_CHAR, SQL_CHAR, \
          (prec), (prec), SQL_NTS)

# define NumericField( symName, fldName, fldIndex)  \
FieldInfo( symName, fldName, fldIndex, SQL_C_LONG, SQL_INTEGER, \
           0, sizeof( DWORD), 0)

# define TimeStampField( symName, fldName, fldIndex) \
FieldInfo( symName, fldName, fldIndex, SQL_C_TIMESTAMP, SQL_TIMESTAMP, \
          0, sizeof( TIMESTAMP_STRUCT), 0)

//
// fields that have constant value. we are interested in names of such fields.
// they have negative field indexes.
// These fields need not be generated as parameter markers.
//  ( Since they are invariants during lifetime of an INET_SQL_LOG oject)
//  Hence the field values will go into the command generated.
// Left here as a documentation aid and field-generation purposes.
//
# define ConstantValueField( synName, fldName) \
FieldInfo( synName, fldName, -1,  SQL_C_CHAR, SQL_CHAR, 0, 0, SQL_NTS)

//
// Ideally the "username" field should have MAX_USER_NAME_LEN as max size.
//  However, Access 7.0 limits varchar() size to be 255 (8 bits) :-(
//  So, we limit the size to be the least of the two ...
//
// FieldNames used are reserved. They are same as the names distributed
//   in the template log file. Do not change them at free will.
//
//

# define AllFieldInfo() \
 StringField(        CLIENT_HOST,       _T("ClientHost"),     0,   255)    \
 StringField(        USER_NAME,         _T("username"),       1,   255)    \
 TimeStampField(     REQUEST_TIME,      _T("LogTime"),        2)          \
 ConstantValueField( SERVICE_NAME,      _T("service"))                    \
 ConstantValueField( SERVER_NAME,       _T("machine"))                    \
 StringField(        SERVER_IPADDR,     _T("serverip"),       3,   50)    \
 NumericField(       PROCESSING_TIME,   _T("processingtime"), 4)          \
 NumericField(       BYTES_RECVD,       _T("bytesrecvd"),     5)          \
 NumericField(       BYTES_SENT,        _T("bytessent"),      6)          \
 NumericField(       SERVICE_STATUS,    _T("servicestatus"),  7)          \
 NumericField(       WIN32_STATUS,      _T("win32status"),    8)          \
 StringField(        SERVICE_OPERATION, _T("operation"),      9,  255)    \
 StringField(        SERVICE_TARGET,    _T("target"),        10,  255)    \
 StringField(        SERVICE_PARAMS,    _T("parameters"),    11,  255)    \


/************************************************************
 *    Type Definitions
 ************************************************************/

//
// Define the FieldInfo macro to generate a list of enumerations for
//  the indexes to be used in the array of field parameters.
//


# define FieldInfo(symName, field, index, cType, sqlType, prec, maxSz, cbVal) \
        i ## symName = (index),

enum LOGGING_VALID_COLUMNS {


    // fields run from 0 through iMaxFields
    AllFieldInfo()

    iMaxFields
}; // enum LOGGING_VALID_COLUMNS


# undef FieldInfo


# define FieldInfo(symName, field, index, cType, sqlType, prec, maxSz, cbVal) \
        fi ## symName,

enum LOGGING_FIELD_INDEXES {

    fiMinFields = -1,

    // fields run from 0 through fiMaxFields
    AllFieldInfo()

    fiMaxFields
}; // enum LOGGING_FIELD_INDEXES


# undef FieldInfo


struct FIELD_INFO {

    int     iParam;
    CHAR  * pszName;
    SWORD   paramType;
    SWORD   cType;
    SWORD   sqlType;
    UDWORD  cbColPrecision;
    SWORD   ibScale;
    SDWORD  cbMaxSize;
    SDWORD  cbValue;
}; // struct FIELD_INFO


//
// Define the FieldInfo macro to generate a list of data to be generated
//   for entering the data values in an array for parameter information.
//  Note the terminating ',' used here.
//

# define FieldInfo(symName, field, index, cType, sqlType, prec, maxSz, cbVal) \
  { ((index) + 1), field, SQL_PARAM_INPUT, cType, sqlType,  \
    ( prec), 0, ( maxSz), ( cbVal) },

/*

   The array of Fields: sg_rgFields contain the field information
    for logging to SQL database for the log-record of
    the services. The values are defined using the macros FieldInfo()
    defined above.


   If there is any need to add/delete/modify the parameters bound,
    one should modify the above table "AllFieldInfo" macro.

*/

static FIELD_INFO  sg_rgFields[] = {

    AllFieldInfo()

      //
      // The above macro after expansion terminates with a comma.
      //  Add dummy entry to complete initialization of array.
      //

      { 0, _T("dummy"), SQL_PARAM_INPUT, 0, 0, 0, 0, 0, 0}
};


# undef FieldInfo

//
// tick minute.
//

#define TICK_MINUTE         (60 * 1000)


/************************************************************
 *    Functions
 ************************************************************/

BOOL
GenerateFieldNames(IN PODBC_CONNECTION poc,
                   OUT CHAR * pchFieldNames,
                   IN DWORD    cchFieldNames);

inline BOOL
IsEmptyStr( IN LPCSTR psz)
{  return ( psz == NULL || *psz == _T('\0')); }

BOOL
CODBCLOG::PrepareStatement( VOID)
/*++
  This command forms the template SQL command used for insertion
    of log records. Then it prepares the SQL command( for later execution)
    using ODBC_CONNECTION::PrepareStatement().

  It should always be called after locking the INET_SQL_LOG object.

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.

  Note:
     The template for insertion is:

     insert into <table name> ( field names ...) values (  ?, ?, ...)
                                                         ^^^^
                                             Field values go here

    Field names are generated on a per logging format basis.
--*/
{
    BOOL   fReturn = FALSE;
    CHAR  rgchFieldNames[ MAX_SQL_FIELD_NAMES_LEN];
    CHAR  rgchFieldValues[ MAX_SQL_FIELD_VALUES_LEN];


    //
    // Obtain field names and field values ( template) for various log formats.
    //  The order of field names should match the order of field values
    //  generated by FormatLogInformation() for the format specified.
    //

    rgchFieldNames[ 0] = rgchFieldValues[ 0] = _T('\0');

    DWORD cchFields;

    fReturn = GenerateFieldNames(m_poc,
                                 rgchFieldNames,
                                 MAX_SQL_FIELD_NAMES_LEN);

    if ( !fReturn) {

        //DBGPRINTF(( DBG_CONTEXT,
        //           " Unable to generate field names. Error = %d\n",
        //           GetLastError()));
        //break;
        return(fReturn);
    }

    cchFields = wsprintf( (CHAR *)rgchFieldValues,
                           PSZ_INTERNET_STD_LOG_FORMAT_FIELD_VALUES,
                           QueryServiceName(),
                           QueryServerName());

    fReturn = (fReturn && (cchFields < MAX_SQL_FIELD_VALUES_LEN));
    //DBG_ASSERT( cchFields <  MAX_SQL_FIELD_VALUES_LEN);

    fReturn = TRUE;

    if ( fReturn) {

        CHAR * pwszSqlCommand;
        DWORD   cchReqd;

        //
        //  The required number of chars include sql insert template command
        //   and field names and table name.
        //

        cchReqd = ( LEN_PSZ_SQL_INSERT_CMD_TEMPLATE +
                   strlen( m_rgchTableName) +
                   strlen( rgchFieldNames)  +
                   strlen( rgchFieldValues) + 20);

        pwszSqlCommand = ( CHAR *) LocalAlloc( LPTR, cchReqd * sizeof( CHAR));
        m_poStmt = m_poc->AllocStatement();

        if ( ( fReturn = ( pwszSqlCommand != NULL) && ( m_poStmt != NULL))) {

            DWORD cchUsed;

            cchUsed = wsprintf( pwszSqlCommand,
                                PSZ_SQL_INSERT_CMD_TEMPLATE,
                                m_rgchTableName,
                                rgchFieldNames,
                                rgchFieldValues);
            //DBG_ASSERT( cchUsed < cchReqd);

            //IF_DEBUG(INETLOG) {
            //    DBGPRINTF( ( DBG_CONTEXT,
            //                " Sqlcommand generated is: %ws.\n",
            //                pwszSqlCommand));
            //}

            fReturn = ((cchUsed < cchReqd) &&
                       m_poStmt->PrepareStatement( pwszSqlCommand)
                       );

            LocalFree( pwszSqlCommand);         // free allocated memory
        }

    } // valid field names and filed values.


    //IF_DEBUG( INETLOG) {
    //
    //    DBGPRINTF( ( DBG_CONTEXT,
    //                "%s::PrepareStatement() returns %d.",
    //                QueryClassIdString(), fReturn));
    //}

    return ( fReturn);
} // INET_SQL_LOG::PrepareStatement()


BOOL
CODBCLOG::PrepareParameters( VOID)
/*++
  This function creates an array of ODBC_PARAMETER objects used for binding
    parameters to an already prepared statement. These ODBC_PARAMETER objects
    are then used for insertion of data values into the table specified,
    through ODBC.

  This function should always be called after locking the object.

  Arguments:
     None

  Returns:
     TRUE on success and FALSE if there is any failure.
--*/
{
    BOOL fReturn = FALSE;
    PODBC_PARAMETER * prgParams = NULL;
    DWORD cParams = 0;
    DWORD nParamsSeen = 0;

    DWORD i;

    //DBG_ASSERT( m_poStmt != NULL && m_poStmt->IsValid()  &&
    //            m_ppParams == NULL && m_cOdbcParams == 0);

    //
    // create sufficient space for iMaxFields pointers to ODBC objects.
    //
    prgParams = new PODBC_PARAMETER[ iMaxFields];


    if ( prgParams != NULL) {

        fReturn = TRUE;      // Assume everything will go on fine.
        cParams = iMaxFields;


        //
        // Create all the ODBC parameters.
        //  Walk through all field indexes and pick up the valid columns
        //
        for( nParamsSeen = 0, i =0; i < fiMaxFields; i++) {

            if ( sg_rgFields[i].iParam > 0) {

                WORD colNum = (WORD ) sg_rgFields[i].iParam;

                prgParams[nParamsSeen] =
                  new ODBC_PARAMETER(colNum,
                                     sg_rgFields[i].paramType,
                                     sg_rgFields[i].cType,
                                     sg_rgFields[i].sqlType,
                                     sg_rgFields[i].cbColPrecision
                                     );

                if ( prgParams[ nParamsSeen] == NULL) {

                    fReturn = FALSE;
                    //DBGPRINTF( ( DBG_CONTEXT,
                    //            " Failed to create Parameter[%d] %s. \n",
                    //            i, sg_rgFields[i].pszName));
                    break;
                }

                nParamsSeen++;
                //DBG_ASSERT( nParamsSeen <= cParams);
            }
        } // for creation of all ODBC parameters


        if ( fReturn) {
            //
            // Set buffers for values to be received during insertions.
            // Bind parameters to the statement using ODBC_CONNECTION object.
            //

            //DBG_ASSERT( nParamsSeen == cParams);

            for( nParamsSeen = 0, i = 0; i < fiMaxFields; i++) {

                if ( sg_rgFields[i].iParam > 0) {

                    if (!prgParams[nParamsSeen]->
                        SetValueBuffer(sg_rgFields[i].cbMaxSize,
                                       sg_rgFields[i].cbValue) ||
                        !m_poStmt->BindParameter( prgParams[nParamsSeen])
                        ) {

                        fReturn = FALSE;
                        //DBGPRINTF( ( DBG_CONTEXT,
                        //            " Binding Parameter [%u] (%08x) failed.\n",
                        //            nParamsSeen, prgParams[nParamsSeen]));
                        //DBG_CODE( prgParams[ i]->Print());
                        break;
                    }

                    nParamsSeen++;
                }
            } // for
        } // if all ODBC params were created.

        if ( !fReturn) {

            //
            // Free up the space used, since we were unsuccessful.
            //

            for( i = 0; i < iMaxFields; i++) {

                if ( prgParams[ i] != NULL) {

                    delete ( prgParams[ i]);
                    prgParams[i] = NULL;
                }
            } // for

            delete [] prgParams;
            prgParams = NULL;
            cParams = 0;
        }

    } // if array for pointers to ODBC params created successfully

    //
    // Set the values. Either invalid or valid ,depending on failure/success
    //
    m_ppParams    = prgParams;
    m_cOdbcParams = cParams;

    return ( fReturn);
} // INET_SQL_LOG::PrepareParameters()


BOOL
GenerateFieldNames(IN PODBC_CONNECTION poc,
                   OUT CHAR * pchFieldNames,
                   IN DWORD    cchFieldNames)
/*++
  This function generates the field names string from the names of the fields
   and identifier quote character for particular ODBC datasource in use.
--*/
{
    BOOL  fReturn = FALSE;
    CHAR  rgchQuote[MAX_SQL_IDENTIFIER_QUOTE_CHAR];
    DWORD cchQuote;

    //DBG_ASSERT( poc != NULL && pchFieldNames != NULL);

    pchFieldNames[0] = _T('\0');  // initialize

    //
    // Inquire and obtain the SQL identifier quote char for ODBC data source.
    //
    fReturn = poc->GetInfo(SQL_IDENTIFIER_QUOTE_CHAR,
                             rgchQuote, MAX_SQL_IDENTIFIER_QUOTE_CHAR,
                             &cchQuote);

    if ( !fReturn) {

        //DBG_CODE( {
        //    STR strError;
        //
        //    poc->GetLastErrorText( &strError);
        //
        //    DBGPRINTF(( DBG_CONTEXT,
        //           " ODBC_CONNECTION(%08x)::GetInfo(QuoteChar) failed."
        //               " Error = %s\n",
        //               poc, strError.QueryStr()));
        //});

    } else {

        DWORD i;
        DWORD cchUsed = 0;
        DWORD cchLen;

        //
        // ODBC returns " "  (blank) if there is no special character
        //  for quoting identifiers. we need to identify and string the same.
        // This needs to be done, other wise ODBC will complain when
        //  we give unwanted blanks before ","
        //

        if ( !strcmp( rgchQuote, _T(" "))) {

            rgchQuote[0] = _T('\0');  // string the quoted blank.
            cchQuote     = 0;
        } else {

            cchQuote = strlen( rgchQuote);
        }

        // for each column, generate the quoted literal string and concatenate.
        for( i = 0; i < fiMaxFields; i++) {

            DWORD cchLen1 =
              (strlen(sg_rgFields[i].pszName) + 2 * cchQuote + 2);

            if ( cchUsed + cchLen1 < cchFieldNames) {

                // space available for copying the data.
                cchLen = wsprintf( pchFieldNames + cchUsed,
                                   _T(" %s%s%s,"),
                                   rgchQuote,
                                   sg_rgFields[i].pszName,
                                   rgchQuote
                                   );

                //DBG_ASSERT( cchLen == cchLen1);
            }

            cchUsed += cchLen1;
        } // for


        if ( cchUsed >= cchFieldNames) {

            // buffer exceeded. return error.
            SetLastError( ERROR_INSUFFICIENT_BUFFER);
            fReturn = FALSE;

        } else {

            //
            // Reset the last character from being a ","
            //
            cchLen = (cchUsed > 0) ? (cchUsed - 1) : 0;
            pchFieldNames[cchLen] = _T('\0');
            fReturn = TRUE;
        }
    }

    //IF_DEBUG( INETLOG) {
    //
    //    DBGPRINTF(( DBG_CONTEXT,
    //               " GenerateFieldNames() returns %d."
    //               " Fields = %S\n",
    //               fReturn, pchFieldNames));
    //}

    return (fReturn);
} // GenerateFieldNames()


CODBCLOG::CODBCLOG()
{

    INITIALIZE_CRITICAL_SECTION( &m_csLock);

    m_poc               = NULL;
    m_poStmt            = NULL;
    m_ppParams          = NULL;
    m_fEnableEventLog   = true;

    m_TickResumeOpen    = GetTickCount() + TICK_MINUTE;
}


/////////////////////////////////////////////////////////////////////////////
// CODBCLOG::~CODBCLOG - Destructor

CODBCLOG::~CODBCLOG()
{
    TerminateLog( );
    DeleteCriticalSection( &m_csLock);
}


STDMETHODIMP
CODBCLOG::InitializeLog(
            LPCSTR pszInstanceName,
            LPCSTR pszMetabasePath,
            CHAR* pMetabase )
{
    DWORD dwError = NO_ERROR;

    // load ODBC entry point
    LoadODBC();

    // get the default parameters

    DWORD   dwL = sizeof(m_rgchServerName);
    
    if ( !GetComputerName( m_rgchServerName, &dwL ) ) 
    {
        m_rgchServerName[0] = '\0';
    }

    strcpy( m_rgchServiceName, pszInstanceName);

    //
    // nntp (5x) logging sends the private IMDCOM interface while w3svc (6.0)
    // logging sends the public IMSAdminBase interface.  Find out which it is
    //
    BOOL fIsPublicInterface = (_strnicmp(pszInstanceName, "w3svc", 5) == 0);

    if (fIsPublicInterface)
    {
        dwError = GetRegParametersFromPublicInterface(pszMetabasePath,
                                                      pMetabase);
    }
    else
    {
        dwError = GetRegParameters(pszMetabasePath, pMetabase);
    }

    if (dwError == NO_ERROR )
    {

        // open database
        if ( m_poc == NULL )
        {
            Lock();

            m_poc = new ODBC_CONNECTION();

            if ( m_poc == NULL )
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
            } else
            {
                if ( !m_poc->Open( m_rgchDataSource, m_rgchUserName, m_rgchPassword ) ||
                     !PrepareStatement() ||
                     !PrepareParameters() )
                {
                    dwError = GetLastError();
                }

            }
            Unlock();
        }
    }

    return(dwError);
}

STDMETHODIMP
CODBCLOG::LogInformation(
        IInetLogInformation * ppvDataObj
        )
{
    DWORD       dwError   = ERROR_SUCCESS;
    BOOL        fReturn;
    SYSTEMTIME  stNow;

    STR         strClientHostName;
    STR         strClientUserName;
    STR         strServerIpAddress;
    STR         strOperation;
    STR         strTarget;
    STR         strParameters;

    PCHAR       pTmp;
    DWORD       cbSize;
    DWORD       dwBytesSent;
    DWORD       dwBytesRecvd;
    DWORD       dwProtocolStatus;
    DWORD       dwWin32Status;
    DWORD       dwTimeForProcessing;


    if (!( 
            m_poc != NULL && m_poc->IsValid() &&
            m_poStmt != NULL && m_poStmt->IsValid() &&
            m_ppParams != NULL 
       ))
    {
        //
        // Check if it is time to retry
        //
        
        DWORD tickCount = GetTickCount( );

        if ( (tickCount < m_TickResumeOpen) ||
             ((tickCount + TICK_MINUTE) < tickCount ) )  // The Tick counter is about to wrap.
        {
            return ERROR_INVALID_PARAMETER;
        }
    } 
   
    dwBytesSent = ppvDataObj->GetBytesSent( );
    dwBytesRecvd = ppvDataObj->GetBytesRecvd( );

    dwTimeForProcessing = ppvDataObj->GetTimeForProcessing( );
    dwWin32Status = ppvDataObj->GetWin32Status( );
    dwProtocolStatus = ppvDataObj->GetProtocolStatus( );

    pTmp = ppvDataObj->GetClientHostName( NULL, &cbSize);
    if ( cbSize == 0 ) {
        pTmp = "";
    }
    strClientHostName.Copy(pTmp);

    pTmp = ppvDataObj->GetClientUserName( NULL, &cbSize);
    if ( cbSize == 0 ) {
        pTmp = "";
    }
    strClientUserName.Copy(pTmp);

    pTmp = ppvDataObj->GetServerAddress( NULL, &cbSize);
    if ( cbSize == 0 ) {
        pTmp = "";
    }
    strServerIpAddress.Copy(pTmp);

    pTmp = ppvDataObj->GetOperation( NULL, &cbSize);
    if ( cbSize == 0 ) {
        pTmp = "";
    }
    strOperation.Copy(pTmp);

    pTmp = ppvDataObj->GetTarget( NULL, &cbSize);
    if ( cbSize == 0 ) {
        pTmp = "";
    }
    strTarget.Copy(pTmp);

    pTmp = ppvDataObj->GetParameters( NULL, &cbSize);
    if ( cbSize == 0 ) {
        pTmp = "";
    }
    strParameters.Copy(pTmp);

    LPCSTR     pszUserName  = strClientUserName.QueryStr();
    LPCSTR     pszOperation = strOperation.QueryStr();
    LPCSTR     pszTarget    = strTarget.QueryStr();
    LPCSTR     pszParameters= strParameters.QueryStr();
    LPCSTR     pszServerAddr= strServerIpAddress.QueryStr();
    
    SDWORD     cbParameters;
    SDWORD     cbTarget;
    
    cbParameters = strlen( pszParameters ? pszParameters : "" ) + 1;
    cbTarget     = strlen( pszTarget ? pszTarget : "" ) + 1;

    //
    //  Format the Date and Time for logging.
    //

    GetLocalTime( & stNow);

    if ( IsEmptyStr(pszUserName)) { pszUserName = QueryDefaultUserName();}
    if ( IsEmptyStr(pszOperation))  { pszOperation = PSZ_UNKNOWN_FIELD_A; }
    if ( IsEmptyStr(pszParameters)) { pszParameters= PSZ_UNKNOWN_FIELD_A; }
    if ( IsEmptyStr(pszTarget))     { pszTarget    = PSZ_UNKNOWN_FIELD_A; }
    if ( IsEmptyStr(pszServerAddr)) { pszServerAddr= PSZ_UNKNOWN_FIELD_A; }

    Lock();

    //
    // Reopen if necessary.
    //

    if (!(
            m_poc != NULL && m_poc->IsValid() &&
            m_poStmt != NULL && m_poStmt->IsValid() &&
            m_ppParams != NULL 
       ))
    {
        
        TerminateLog();
        
        m_TickResumeOpen =  GetTickCount( ) + TICK_MINUTE;

        m_poc = new ODBC_CONNECTION();

        if ( m_poc == NULL )
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        } 
        else
        {
            //
            // Try to open a new connection but don't log the failure in the eventlog
            //
                
            if ( !m_poc->Open( m_rgchDataSource, m_rgchUserName, m_rgchPassword, FALSE) ||
                 !PrepareStatement() ||
                 !PrepareParameters() )
            {
                dwError = GetLastError();

                if ( ERROR_SUCCESS == dwError)
                {
                    //
                    // Last Error wasn't set correctly
                    //

                    dwError = ERROR_GEN_FAILURE;
                }
            }
        }
        
        if ( ERROR_SUCCESS != dwError )
        {
            Unlock();
            return dwError;
        }
    }

    DBG_ASSERT(m_poc != NULL && m_poc->IsValid());
    DBG_ASSERT(m_poStmt != NULL && m_poStmt->IsValid());
    DBG_ASSERT(m_ppParams != NULL );

    //
    //  Truncate the parameters and target fields
    //

    if ( cbTarget > m_ppParams[ iSERVICE_TARGET]->QueryMaxCbValue() )
    {
        strTarget.SetLen(m_ppParams[ iSERVICE_TARGET]->QueryMaxCbValue()-1);
    }
    
    if ( cbParameters > m_ppParams[ iSERVICE_PARAMS]->QueryMaxCbValue() )
    {
        strParameters.SetLen(m_ppParams[ iSERVICE_PARAMS]->QueryMaxCbValue()-1);
    }

    //
    // Copy data values into parameter markers.
    // NYI: LARGE_INTEGERS are ignored. Only lowBytes used!
    //

    fReturn =
      (
        m_ppParams[ iCLIENT_HOST]->
          CopyValue( strClientHostName.QueryStr()) &&
        m_ppParams[ iUSER_NAME]->CopyValue( pszUserName) &&
        m_ppParams[ iREQUEST_TIME]->CopyValue( &stNow) &&
        m_ppParams[ iSERVER_IPADDR]->CopyValue( pszServerAddr) &&
        m_ppParams[ iPROCESSING_TIME]->
          CopyValue( dwTimeForProcessing) &&
        m_ppParams[ iBYTES_RECVD]->
          CopyValue( dwBytesRecvd) &&
        m_ppParams[ iBYTES_SENT]->
          CopyValue( dwBytesSent) &&
        m_ppParams[ iSERVICE_STATUS]->
          CopyValue( dwProtocolStatus) &&
        m_ppParams[ iWIN32_STATUS]->CopyValue( dwWin32Status) &&
        m_ppParams[ iSERVICE_OPERATION]->CopyValue( pszOperation)  &&
        m_ppParams[ iSERVICE_TARGET]->CopyValue( pszTarget)     &&
        m_ppParams[ iSERVICE_PARAMS]->CopyValue( pszParameters)
       );

    //
    // Execute insertion if parameters got copied properly.
    //

    if (fReturn)
    {
        fReturn = m_poStmt->ExecuteStatement(); 
    }

    Unlock();

    if ( !fReturn )
    {

        //
        // Execution of SQL statement failed.
        // Pass the error as genuine failure, indicating ODBC failed
        // Obtain and store the error string in the proper return field
        //

        TerminateLog();
        
        dwError = ERROR_GEN_FAILURE;

        if ( true == m_fEnableEventLog )
        {
            //
            // We have not written an event log before. Indicate error
            //

            if ( g_eventLog != NULL ) 
            {
                const CHAR*    tmpString[1];

                tmpString[0] = m_rgchDataSource;
                
                g_eventLog->LogEvent(
                     LOG_EVENT_ODBC_LOGGING_ERROR,
                     1,
                     tmpString,
                     GetLastError()
                     );
            }

            Lock();
            
            m_fEnableEventLog = false;
            m_TickResumeOpen  = GetTickCount() + TICK_MINUTE;

            Unlock();
        }
    }
    else
    {
        //
        // Success. Re-enable event logging
        //

        if (false == m_fEnableEventLog) 
        {

            if ( g_eventLog != NULL )
            {
                const CHAR*    tmpString[1];

                tmpString[0] = m_rgchDataSource;
                
                g_eventLog->LogEvent(
                    LOG_EVENT_ODBC_LOGGING_RESUMED,
                    1,
                    tmpString
                    );
            }
            
            m_fEnableEventLog = true;
        }        
    }

    return(dwError);
}

STDMETHODIMP
CODBCLOG::TerminateLog()
{
    DWORD dwError = NO_ERROR;

    Lock();
    if (m_poStmt != NULL )
    {
        delete m_poStmt;
        m_poStmt = NULL;
    }

    if (m_poc!= NULL)
    {
        if (!m_poc->Close())
        {
            dwError = GetLastError();
        }

        delete m_poc;
        m_poc=NULL;
    }

    if (m_ppParams!=NULL)
    {
        DWORD i;

        for (i=0;i<m_cOdbcParams;i++)
        {
            if (m_ppParams[i]!=NULL)
            {
                delete m_ppParams[i];
                m_ppParams[i]=NULL;
            }
        }

        delete []m_ppParams;
        m_ppParams = NULL;
        m_cOdbcParams=0;
    }

    Unlock();

    return(dwError);
}

STDMETHODIMP
CODBCLOG::SetConfig(
                        DWORD cbSize,
                        BYTE * log)
{
    return(0L);
}

STDMETHODIMP
CODBCLOG::GetConfig(
                        DWORD cbSize,
                        BYTE * log)
{
    PINETLOG_CONFIGURATIONA pLogConfig = (PINETLOG_CONFIGURATIONA)log;
    pLogConfig->inetLogType = INET_LOG_TO_SQL;
    strcpy( pLogConfig->u.logSql.rgchDataSource, m_rgchDataSource);
    strcpy( pLogConfig->u.logSql.rgchTableName, m_rgchTableName);
    strcpy( pLogConfig->u.logSql.rgchUserName, m_rgchUserName);
    strcpy( pLogConfig->u.logSql.rgchPassword, m_rgchPassword);
    return(0L);
}

DWORD
CODBCLOG::GetRegParameters(
                    LPCSTR pszRegKey,
                    LPVOID pvIMDCOM )
{
    DWORD err = NO_ERROR;

    MB      mb( (IMDCOM*) pvIMDCOM );
    DWORD   cb;

    if ( !mb.Open("") )
    {
        err = GetLastError();
        goto Exit;
    }

    cb = sizeof(m_rgchDataSource);
    if ( !mb.GetString( pszRegKey, MD_LOGSQL_DATA_SOURCES, IIS_MD_UT_SERVER, m_rgchDataSource, &cb ) )
    {
        strcpy(m_rgchDataSource,DEFAULT_LOG_SQL_DATASOURCE);
    }

    cb = sizeof(m_rgchTableName);
    if ( !mb.GetString( pszRegKey, MD_LOGSQL_TABLE_NAME, IIS_MD_UT_SERVER, m_rgchTableName, &cb ) )
    {
        strcpy(m_rgchTableName,DEFAULT_LOG_SQL_TABLE);
    }

    cb = sizeof(m_rgchUserName);
    if ( !mb.GetString( pszRegKey, MD_LOGSQL_USER_NAME, IIS_MD_UT_SERVER, m_rgchUserName, &cb ) )
    {
        strcpy(m_rgchUserName,DEFAULT_LOG_SQL_USER_NAME);
    }

    cb = sizeof(m_rgchPassword);
    if ( !mb.GetString( pszRegKey, MD_LOGSQL_PASSWORD, IIS_MD_UT_SERVER, m_rgchPassword, &cb, METADATA_INHERIT|METADATA_SECURE ) )
    {
        strcpy(m_rgchPassword,DEFAULT_LOG_SQL_PASSWORD);
    }

 Exit:
    return err;
}

inline
VOID
WCopyToA(
    const WCHAR * wszSrc,
    CHAR        * szDest
    )
{
   while( *szDest++ = ( CHAR )( *wszSrc++ ) )
   { ; }
}

inline
VOID
ACopyToW(
    const CHAR * szSrc,
    WCHAR      * wszDest
    )
{
   while( *wszDest++ = ( WCHAR )( *szSrc++ ) )
   { ; }
}

DWORD
CODBCLOG::GetRegParametersFromPublicInterface(LPCSTR pszRegKey,
                                              LPVOID pMetabase)
{
    //
    // What I really want is the version of MB in iisutil.dll.  But, since I
    // cannot link to that and iisrtl.dll, I will just work with the
    // IMSAdminBase object directly
    //
    IMSAdminBase *pAdminBase = (IMSAdminBase *)pMetabase;
    METADATA_HANDLE hMBPath = NULL;
    DWORD cbRequired;
    METADATA_RECORD mdr;
    WCHAR pwszBuffer[MAX_PATH];
    WCHAR pwszRegKey[MAX_PATH];
    HRESULT hr;

    ACopyToW(pszRegKey, pwszRegKey);

    // MB::MB
    pAdminBase->AddRef();
    // MB::Open
    hr = pAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
                             L"",
                             METADATA_PERMISSION_READ,
                             MB_TIMEOUT,
                             &hMBPath);
    if (FAILED(hr))
    {
        goto Exit;
    }

    // MB::GetString
    mdr.dwMDIdentifier = MD_LOGSQL_DATA_SOURCES;
    mdr.dwMDAttributes = METADATA_INHERIT;
    mdr.dwMDUserType   = IIS_MD_UT_SERVER;
    mdr.dwMDDataType   = STRING_METADATA;
    mdr.dwMDDataLen    = sizeof pwszBuffer;
    mdr.pbMDData       = (BYTE *)pwszBuffer;

    hr = pAdminBase->GetData(hMBPath, pwszRegKey, &mdr, &cbRequired);
    if (FAILED(hr) ||
        wcslen(pwszBuffer) >= sizeof m_rgchDataSource)
    {
        strcpy(m_rgchDataSource, DEFAULT_LOG_SQL_DATASOURCE);
    }
    else
    {
        WCopyToA(pwszBuffer, m_rgchDataSource);
    }

    // MB::GetString
    mdr.dwMDIdentifier = MD_LOGSQL_TABLE_NAME;
    mdr.dwMDAttributes = METADATA_INHERIT;
    mdr.dwMDUserType   = IIS_MD_UT_SERVER;
    mdr.dwMDDataType   = STRING_METADATA;
    mdr.dwMDDataLen    = sizeof pwszBuffer;
    mdr.pbMDData       = (BYTE *)pwszBuffer;

    hr = pAdminBase->GetData(hMBPath, pwszRegKey, &mdr, &cbRequired);
    if (FAILED(hr) ||
        wcslen(pwszBuffer) >= sizeof m_rgchTableName)
    {
        strcpy(m_rgchTableName, DEFAULT_LOG_SQL_TABLE);
    }
    else
    {
        WCopyToA(pwszBuffer, m_rgchTableName);
    }

    // MB::GetString
    mdr.dwMDIdentifier = MD_LOGSQL_USER_NAME;
    mdr.dwMDAttributes = METADATA_INHERIT;
    mdr.dwMDUserType   = IIS_MD_UT_SERVER;
    mdr.dwMDDataType   = STRING_METADATA;
    mdr.dwMDDataLen    = sizeof pwszBuffer;
    mdr.pbMDData       = (BYTE *)pwszBuffer;

    hr = pAdminBase->GetData(hMBPath, pwszRegKey, &mdr, &cbRequired);
    if (FAILED(hr) ||
        wcslen(pwszBuffer) >= sizeof m_rgchUserName)
    {
        strcpy(m_rgchUserName, DEFAULT_LOG_SQL_USER_NAME);
    }
    else
    {
        WCopyToA(pwszBuffer, m_rgchUserName);
    }

    // MB::GetString
    mdr.dwMDIdentifier = MD_LOGSQL_PASSWORD;
    mdr.dwMDAttributes = METADATA_INHERIT|METADATA_SECURE;
    mdr.dwMDUserType   = IIS_MD_UT_SERVER;
    mdr.dwMDDataType   = STRING_METADATA;
    mdr.dwMDDataLen    = sizeof pwszBuffer;
    mdr.pbMDData       = (BYTE *)pwszBuffer;

    hr = pAdminBase->GetData(hMBPath, pwszRegKey, &mdr, &cbRequired);
    if (FAILED(hr) ||
        wcslen(pwszBuffer) >= sizeof m_rgchPassword)
    {
        strcpy(m_rgchPassword, DEFAULT_LOG_SQL_PASSWORD);
    }
    else
    {
        WCopyToA(pwszBuffer, m_rgchPassword);
    }

    hr = S_OK;

 Exit:
    // MB::Close
    if (hMBPath)
    {
        pAdminBase->CloseKey(hMBPath);
        hMBPath = NULL;
    }
    // MB::~MB
    pAdminBase->Release();

    if (FAILED(hr))
    {
        return HRESULTTOWIN32(hr);
    }

    return NO_ERROR;
}

STDMETHODIMP
CODBCLOG::QueryExtraLoggingFields(
                    PDWORD  pcbSize,
                    TCHAR *pszFieldsList
                    )
/*++

Routine Description:
    get configuration information

Arguments:
    cbSize - size of the data structure
    log - log configuration data structure

Return Value:

--*/
{
    *pcbSize = 0;
    *pszFieldsList = '\0';
    return(0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\ilogfile.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       ilogfile.cxx

   Abstract:
       This module defines helper functions for File logging

   Author:

       Murali R. Krishnan    ( MuraliK )     21-FEb-1996

--*/

#include "precomp.hxx"

#define BLOCK_INC_SIZE          1

#if !defined(STATUS_DISK_FULL)
#define STATUS_DISK_FULL    0xC000007FL
#endif

ILOG_FILE::ILOG_FILE(
    VOID
    )
/*++
  This function constructs a new File object used for handling
    log files.

  The reference count is used to count the number of owners
    of this object. It starts off with 1.
    the ILOG_FILE::OpenFileForAppend() function
        inrements refcount when a new owner is given this object
    the ILOG_FILE::CloseFile() function
        derements refcount when an owner relinquishes the object

--*/
:
   m_hFile            ( INVALID_HANDLE_VALUE),
   m_pvBuffer         ( NULL),
   m_cbBufferUsed     ( 0),
   m_hMemFile         ( NULL),
   m_nGranules        ( 0),
   m_strFileName      ( )
{
    SYSTEM_INFO sysInfo;

    m_qwFilePos.QuadPart = 0;
    m_mapSize.QuadPart = 0;

    GetSystemInfo(&sysInfo);
    m_dwAllocationGranularity = sysInfo.dwAllocationGranularity;

    if ( m_dwAllocationGranularity == 0 ) {
        m_dwAllocationGranularity = 0x10000;
    }

} // ILOG_FILE::ILOG_FILE()




ILOG_FILE::~ILOG_FILE(VOID)
/*++
  This function cleans up state maintained within the object -
    freeing up the memory and closing file handle.
  It then destroys all state information maintained.

  The reference count should be zero, indicating this object is no more in use.

--*/
{
    CloseFile();

    return;
} // ILOG_FILE::~ILOG_FILE()



BOOL
ILOG_FILE::ExpandMapping(
    VOID
    )
{

    m_mapSize.QuadPart = m_mapSize.QuadPart + (ULONGLONG)(BLOCK_INC_SIZE * m_dwAllocationGranularity);
    
    /*
    //
    // This check is removed as now condition isn't true becuase we are not limited by 32 bit 
    // truncation size
    //
    if ( (newMapSize.QuadPart < m_mapSize.QuadPart) || (m_mapSize.QuadPart > m_qwTruncateSize.QuadPart) ) {
        IIS_PRINTF((buff,"Cannot expand mapping.  "
            "New size %d will exceed truncation size %d\n",
            newMapSize, m_qwTruncateSize));

        SetLastError( ERROR_DISK_FULL );
        return(FALSE);
    }
    */

    //
    // Destroy the old and create a new mapping
    //

    DestroyMapping( );

    return(CreateMapping( ));

} // ExpandMapping


BOOL
ILOG_FILE::CreateMapping(
    VOID
    )
{
    //
    // find the next file mapping window
    //
    ULARGE_INTEGER qwStart;
    ULARGE_INTEGER qwTmp;

    DWORD dwSize;


    //DWORD dwSize;

    qwStart.QuadPart = m_qwFilePos.QuadPart;
    qwStart.LowPart = qwStart.LowPart - (qwStart.LowPart % m_dwAllocationGranularity);


    m_hMemFile = CreateFileMapping(
                            m_hFile,
                            NULL,
                            PAGE_READWRITE,
                            m_mapSize.HighPart,
                            m_mapSize.LowPart,
                            NULL ) ;

    if ( m_hMemFile == NULL ) {

#if 0
        IIS_PRINTF((buff,"Error %d in CreateFileMapping[%s][size = %d]\n",
            GetLastError(), m_strFileName.QueryStr(),
            m_mapSize ));
#endif
        SetLastError( ERROR_DISK_FULL );
        return(FALSE);
    }

    qwTmp.QuadPart = m_mapSize.QuadPart - qwStart.QuadPart;
    dwSize = qwTmp.LowPart;
    

    qwTmp.QuadPart = m_qwFilePos.QuadPart - qwStart.QuadPart;
    m_cbBufferUsed = qwTmp.LowPart;


    m_pvBuffer = MapViewOfFile(
                        m_hMemFile,
                        FILE_MAP_ALL_ACCESS,
                        qwStart.HighPart,
                        qwStart.LowPart,
                        dwSize
                        );

    if ( m_pvBuffer == NULL ) {
        IIS_PRINTF((buff,"Error %d in MapViewOfFile[%s][%d:%d,%d]\n",
            GetLastError(), m_strFileName.QueryStr(),
            qwStart.HighPart,qwStart.LowPart, dwSize ));
        DestroyMapping();
        return(FALSE);
    }

    if ( TsIsWindows95() ) {
        ZeroMemory(
            (PCHAR)((PCHAR)m_pvBuffer + m_cbBufferUsed),
            dwSize - m_cbBufferUsed);
    }

    return(TRUE);
} // CreateMapping



BOOL
ILOG_FILE::Write(
    IN PCHAR pvData,
    IN DWORD cbData
    )
/*++
  This function writes the data present in the input buffer of specified
    length to the file.
  For performance reasons, the function actually buffers data in the
    internal buffers of ILOG_FILE object. Such buffered data is flushed
    to disk later on when buffer (chain) is full or when
    a flush call is made from a scheduled flush.

  Arguments:
     pvData       pointer to buffer containing data to be written
     cbData       count of characters of data to be written.

  Returns:
     TRUE on success and FALSE if there is any error.
--*/
{
    ULARGE_INTEGER oldFilePos;
    ULARGE_INTEGER newFilePos;

    BOOL  fReturn = TRUE;

    if ( m_hMemFile == NULL ) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return ( FALSE);
    }

    //
    // Bug 110351: Need try-except blocks around CopyMemory for dealing
    // with compressed files
    //

    oldFilePos.QuadPart = m_qwFilePos.QuadPart;
    newFilePos.QuadPart = m_qwFilePos.QuadPart + (ULONGLONG)cbData;

    //
    // copy part of the data to the end of the buffer
    //

    if (newFilePos.QuadPart > m_mapSize.QuadPart ) {

        ULARGE_INTEGER qwSpace;
        DWORD dwSpace;

        qwSpace.QuadPart = m_mapSize.QuadPart - m_qwFilePos.QuadPart;

        dwSpace = qwSpace.LowPart;

        __try
        {
            CopyMemory(
                    (LPBYTE)m_pvBuffer + m_cbBufferUsed,
                    (PVOID)pvData,
                    dwSpace
                    );

        }
        __except( ( _exception_code() == STATUS_IN_PAGE_ERROR ||
                    _exception_code() == STATUS_DISK_FULL ) ?
                  EXCEPTION_EXECUTE_HANDLER :
                  EXCEPTION_CONTINUE_SEARCH )
        {
            SetLastError( _exception_code() );
            goto error_exit;
        }
           
        cbData -= dwSpace;
        pvData += dwSpace;
        m_cbBufferUsed += dwSpace;
        m_qwFilePos.QuadPart = m_qwFilePos.QuadPart + qwSpace.QuadPart;


        if ( !ExpandMapping( ) ) 
        {
            DWORD err = GetLastError();
            SetLastError(err);
            goto error_exit;
        }
    }

    __try
    {
       CopyMemory(
            (LPBYTE)m_pvBuffer + m_cbBufferUsed,
            pvData,
            cbData
            );
    }
    __except(( _exception_code() == STATUS_IN_PAGE_ERROR ||
                    _exception_code() == STATUS_DISK_FULL ) ?
                  EXCEPTION_EXECUTE_HANDLER :
                  EXCEPTION_CONTINUE_SEARCH )
    {
        SetLastError( _exception_code() );
        goto error_exit;
    }

    m_cbBufferUsed += cbData;

    m_qwFilePos.QuadPart = m_qwFilePos.QuadPart + (ULONGLONG)cbData;

    return ( fReturn);

error_exit:

    m_qwFilePos.QuadPart = oldFilePos.QuadPart;
    CloseFile( );
    return(FALSE);


} // ILOG_FILE::Write()



BOOL
ILOG_FILE::Open(
        IN LPCSTR pszFileName,
        IN DWORD  dwTruncationSize,
        IN BOOL   fLogEvent
        )
/*++
  This function opens up a new file for appending data.
  This function automatically sets the file pointer to be
   at the end of file to just enable append to file.

  This function should be called after locking this object

  Arguments:
    pszFileName - name of the file to open
    dwTruncationSize
    fLogEvent   - Produce an event log if Open fails.

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    BOOL                fRet;
    HANDLE              hToken = NULL;

    if ( dwTruncationSize < MIN_FILE_TRUNCATION_SIZE ) {
        dwTruncationSize = MIN_FILE_TRUNCATION_SIZE;
    }

    m_qwTruncateSize.HighPart = 0;
    m_qwTruncateSize.LowPart = dwTruncationSize;

    m_nGranules = BLOCK_INC_SIZE;
    m_mapSize.QuadPart = UInt32x32To64(m_nGranules,m_dwAllocationGranularity);
    m_strFileName.Copy(pszFileName);

    //
    // There is a small chance that this function could be called (indirectly)
    // from an INPROC ISAPI completion thread (HSE_REQ_DONE).  In this case
    // the thread token is the impersonated user and may not have permissions
    // to open the log file (especially if the user is the IUSR_ account).  
    // To be paranoid, let's revert to LOCAL_SYSTEM anyways before opening.
    //
    
    if ( OpenThreadToken( GetCurrentThread(), 
                          TOKEN_ALL_ACCESS, 
                          FALSE, 
                          &hToken ) )
    {
        DBG_ASSERT( hToken != NULL );
        RevertToSelf();
    }
    
    fRet = OpenFile( pszFileName, fLogEvent);
    
    if ( hToken != NULL )
    {
        SetThreadToken( NULL, hToken );
    } 
    
    return fRet;

} // ILOG_FILE::Open


BOOL
ILOG_FILE::OpenFile(
        IN LPCSTR pszFileName,
        IN BOOL   fLogEvent
        )
{
    ULARGE_INTEGER qwTmp;
    DWORD err = NO_ERROR;


    m_qwFilePos.QuadPart = 0;
    m_pvBuffer = NULL;
    m_cbBufferUsed = 0;

    //
    // 1. Create a new file -- open a file if it already exists
    //

    m_hFile = CreateFile(pszFileName,
                          GENERIC_WRITE | GENERIC_READ,
                          FILE_SHARE_WRITE | FILE_SHARE_READ,
                          NULL,       // security attributes
                          OPEN_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                          NULL);      // template file handle

    if ( m_hFile == INVALID_HANDLE_VALUE ) {

       err = GetLastError();

       
       if ( (g_eventLog != NULL) && fLogEvent) {

           const CHAR*    tmpString[1];
           tmpString[0] = pszFileName;

           g_eventLog->LogEvent(
               LOG_EVENT_CREATE_FILE_ERROR,
               1,
               tmpString,
               err
               );
        }

        IIS_PRINTF((buff,"CreateFile[%s] error %d\n",
            pszFileName, err));
        
        SetLastError(err);
        return(FALSE);
    }

    //
    // 2. Set the file pointer at the end of the file (append mode)
    //

    if ( GetLastError() == ERROR_ALREADY_EXISTS ) {

        if ( !PositionToEOF( &m_qwFilePos ) ) {
            err = GetLastError();
            goto error_exit;
        }

        qwTmp.HighPart = 0;
        qwTmp.LowPart = BLOCK_INC_SIZE * m_dwAllocationGranularity;

        while ( m_qwFilePos.QuadPart >= m_mapSize.QuadPart ) {

            m_mapSize.QuadPart  = m_mapSize.QuadPart + qwTmp.QuadPart;
            m_nGranules += BLOCK_INC_SIZE;
        }

        /*
        // not anymore a problem for 64b file possition offsets  
        if ( m_mapSize.QuadPart >= m_qwTruncateSize.QuadPart ) {
            IIS_PRINTF((buff,"[OpenFile] Truncate size[%d] exceeded[%d]\n",
                m_qwTruncateSize, m_mapSize));
            err = ERROR_INSUFFICIENT_BUFFER;
            goto error_exit;
        }
        */
    }

    if ( !CreateMapping( ) ) {
        err = GetLastError();
        goto error_exit;
    }

    return ( TRUE );

error_exit:

    CloseFile( );
    SetLastError(err);
    return(FALSE);

} // ILOG_FILE::OpenFile()


BOOL
ILOG_FILE::PositionToEOF(
    ULARGE_INTEGER  *pFilePos
    )
/*++
  Determine where to begin append operation

  This function should be called after locking this object

  Arguments:
    pFilePos - updated with position where to begin append if success

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    ULARGE_INTEGER  qwFileSize;
    ULARGE_INTEGER  qwFilePos;
    BOOL    fReturn = FALSE;
    DWORD   dwRet;
    LONG    HiFilePos = 0;

    //
    // If file size multiple of BLOCK_INC_SIZE * m_dwAllocationGranularity
    // then it is likely that file has not been closed properly.
    // If this is the case we need to get the position of the last
    // zero char in the file and start logging there.
    //


    qwFileSize.QuadPart = 0;
    qwFileSize.LowPart = GetFileSize( m_hFile,&qwFileSize.HighPart);


    if (qwFileSize.LowPart != FILE_SIZE_LOW_MAX || GetLastError()==NO_ERROR)
    {
        if ( (qwFileSize.LowPart  == 0) ||
             (qwFileSize.LowPart  % m_dwAllocationGranularity) != 0 ) 
        {

            qwFilePos.QuadPart = 0;

            dwRet = SetFilePointer(m_hFile,
                                qwFilePos.LowPart,
                                (PLONG)(&qwFilePos.HighPart),
                                FILE_END);

            if (dwRet != FILE_SIZE_LOW_MAX || GetLastError()==NO_ERROR)
            {

                pFilePos->QuadPart = qwFileSize.QuadPart;
                return TRUE;
            }
            else
            {
                IIS_PRINTF((buff,"SetFilePointer[END] failed %d\n",
                    GetLastError()));
                return(FALSE);
            }

        } 
        else 
        {

            //
            // find last zero char in file
            //
            ULARGE_INTEGER    lLow;
            ULARGE_INTEGER    lHigh;
            ULARGE_INTEGER    lLast;
            ULARGE_INTEGER    lMiddle;
            CHAR    ch;
            DWORD   dwRead;

            lLow.QuadPart = 0;
            lHigh.QuadPart = qwFileSize.QuadPart - 1;
            lLast.QuadPart = qwFileSize.QuadPart;

            fReturn = TRUE;

            while ( lLow.QuadPart <= lHigh.QuadPart ) {

                lMiddle.QuadPart = lLow.QuadPart + (lHigh.QuadPart - lLow.QuadPart) / 2;

                dwRet = SetFilePointer( m_hFile,
                                        lMiddle.LowPart,
                                        (PLONG)(&lMiddle.HighPart),
                                        FILE_BEGIN);

                if  (dwRet==FILE_SIZE_LOW_MAX && GetLastError()!=NO_ERROR)
                {
                    fReturn = FALSE;
                    break;
                }

                if ( ReadFile( m_hFile, &ch, 1, &dwRead, NULL ) ) {
                    if ( ch == '\0' ) {
                        lHigh.QuadPart = lMiddle.QuadPart - 1;
                        lLast.QuadPart = lMiddle.QuadPart;
                    } else {
                        lLow.QuadPart = lMiddle.QuadPart + 1;
                    }
                } else {
                    fReturn = FALSE;
                    break;
                }
            }

            if ( fReturn ) {
                IIS_PRINTF((buff,"[ilogfile.cxx], set log pos:%ld\n",
                    lLast ));

                dwRet = SetFilePointer( m_hFile,
                                        lLast.LowPart,
                                        (PLONG)(&lLast.HighPart),
                                        FILE_BEGIN );

                if (dwRet!=FILE_SIZE_LOW_MAX || GetLastError()==NO_ERROR)
                {
                    pFilePos->QuadPart = lLast.QuadPart;
                } else 
                {
                    fReturn = FALSE;
                }
            }
        }
    } else {
        IIS_PRINTF((buff,"GetFilePosition failed with %d\n",
            GetLastError()));
    }

    return fReturn;
}



BOOL
ILOG_FILE::CloseFile(VOID)
/*++
  This function closes the open file. It flushes out file data
   before closing the file.

  This function should be called after locking this object

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    DWORD dwRet;

    DestroyMapping( );

    if ( m_hFile != INVALID_HANDLE_VALUE)  {

        //
        // set the pointer to the end of file
        //

        dwRet = SetFilePointer( m_hFile,
                                m_qwFilePos.LowPart,
                                (PLONG)(&m_qwFilePos.HighPart),
                                FILE_BEGIN);

        if ( dwRet==FILE_SIZE_LOW_MAX && GetLastError()!=NO_ERROR )
        {

            IIS_PRINTF((buff,"SetFilePointer[Pos = %d] failed with %d\n",
                m_qwFilePos, GetLastError()));

        }

        SetEndOfFile( m_hFile );
        CloseHandle( m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;  // store the invalid handle
    }

    return (TRUE);
} // ILOG_FILE::CloseFile()



VOID
ILOG_FILE::DestroyMapping(
    VOID
    )
/*++
  This function closes the open file. It flushes out file data
   before closing the file.

  This function should be called after locking this object

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    /* NKJ -- why do we need to flush?
    if ( m_hFile != INVALID_HANDLE_VALUE)  {
        FlushFileBuffers( m_hFile);
    }
    */

    if ( m_pvBuffer != NULL ) {
        /* FlushViewOfFile( m_pvBuffer, 0 ); * NKJ */
        UnmapViewOfFile( m_pvBuffer );
        m_pvBuffer = NULL;
    }

    if (m_hMemFile!=NULL) {
        CloseHandle( m_hMemFile );
        m_hMemFile = NULL;
    }
    return;
} // ILOG_FILE::DestroyMapping
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\odbcconn.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       odbcconn.cxx

   Abstract:

       This module defines member functions for ODBC_CONNECTION object.

   Author:

       Murali R. Krishnan    ( MuraliK )     16-Feb-1995

   Functions Exported:

       ODBC_PARAMETER::CopyValue( IN LPCWSTR pwszValue);
       ODBC_PARAMETER::Bind( IN HSTMT hstmt);

       ODBC_STATEMENT::~ODBC_STATEMENT()
       ODBC_STATEMENT::PrepareStatement( IN LPCSTR  pszStatement)
       ODBC_STATEMENT::PrepareStatement( IN LPCWSTR pwszStatement)
       ODBC_STATEMENT::BindParameter( IN PODBC_PARAMETER pOdbcParam)
       ODBC_STATEMENT::ExecuteStatement( VOID)
       ODBC_STATEMENT::ExecDirect( IN LPCSTR pwszSqlCommand,  IN DWORD cch)
       ODBC_STATEMENT::ExecDirect( IN LPCWSTR pwszSqlCommand, IN DWORD cch)
       ODBC_STATEMENT::QueryColNames( OUT STR * *  apstrCols,
                                      OUT DWORD *  cCols,
                                      IN  DWORD    cchMaxFieldSize = 0 );
       ODBC_STATEMENT::QueryValuesAsStr( OUT STR * * apstrValues,
                                         OUT BOOL *  pfLast );


       ODBC_CONNECTION::~ODBC_CONNECTION();
       ODBC_CONNECTION::Open();
       ODBC_CONNECTION::Close();
       ODBC_CONNECTION::GetLastErrorCode();
       ODBC_CONNECTION::AllocStatement();


   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "precomp.hxx"
# include "odbcconn.hxx"

LPSTR
ConvertUnicodeToAnsi(
    IN LPCWSTR  lpszUnicode
    );

//
//  Constants for display widths
//

#define MAX_NUM_PRECISION 15

//
//  Constant for all non string and non binary data.  40 is chosen to account
//  for things such as Oracle's numeric types, which can have up to 38 digits
//  of precision
//

#define MAX_NONCHAR_DATA_LEN        40

//
//  If no default maximum field size is specified, then use this value
//  as the maximum
//

#define DEFAULT_MAX_FIELD_SIZE      8192



/************************************************************
 *  Local Functions
 ************************************************************/

static inline VOID
CheckAndPrintErrorMessage( IN ODBC_CONNECTION * poc,
                           IN RETCODE rc)
{

# if DBG
    if ( !ODBC_CONNECTION::Success( rc))  {

        STR str;
        poc->GetLastErrorText( &str, NULL, rc );

        DBGPRINTF( ( DBG_CONTEXT,
                    "ODBC Error Code( %d). Text: %s\n",
                    rc,
                    str.QueryStr() ));
    }
# endif // DBG

    return;

} // CheckAndPrintErrorMessage()


static inline VOID
CheckAndPrintErrorMessage( IN ODBC_STATEMENT * pos,
                           IN RETCODE rc)
{

# if DBG
    if ( !ODBC_CONNECTION::Success( rc))  {

        STR str;
        pos->GetLastErrorText( &str );

        DBGPRINTF( ( DBG_CONTEXT,
                    "ODBC Error Code( %d). Text: %s\n",
                    rc,
                    str.QueryStr() ));
    }
# endif // DBG

    return;

} // CheckAndPrintErrorMessage()



# if 0  // was #if DBG. Not 64Bit compatible.


static VOID
PrintMultiString( IN char * pszMsg, IN DWORD cbLen, IN char * pmsz)
{

    DBGPRINTF( ( DBG_CONTEXT,
                "Values of %s. %d bytes.\n", pszMsg, cbLen));
    for( char * psz = pmsz; *psz != '\0'; psz += (strlen( psz) + 1)) {

        DBGPRINTF( ( DBG_CONTEXT, "%s\n", psz));
    }

    return;
} // PrintMultiString()



static VOID
AuxOdbcFunctions( IN HENV henv, IN HDBC hdbc)
/*++

  Function useful in walking throug a few additional ODBC functions
    to find out the ODBC setup information.
  Not to be part of the shipped code. Useful for development purposes.
  - MuraliK
--*/
{
    RETCODE rc;

    //
    // Set the trace file to a standard file.
    //
    rc = pSQLSetConnectOption( hdbc, SQL_OPT_TRACE, SQL_OPT_TRACE_ON);
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    rc = pSQLSetConnectOption( hdbc, SQL_OPT_TRACEFILE,
                             (unsigned long )
                             "%systemroot%\\system32\\gophsql.log");
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    UCHAR szDriverDesc[ 300];
    UCHAR szDriverAttrib[ 300];
    SWORD cbDD = 300;
    SWORD cbDA = 300;
    SWORD cbDDCur = 0;
    SWORD cbDACur = 0;

    szDriverDesc[0] = szDriverAttrib[0] = '\0';
    rc = pSQLDrivers( henv, SQL_FETCH_FIRST,
                    szDriverDesc, cbDD, &cbDDCur,
                    szDriverAttrib, cbDA, &cbDACur);
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    DBGPRINTF( ( DBG_CONTEXT,
                " SQLDrivers( %08x) ==> RetCode = %d."
                " Driver Desc. = ( %d bytes) %s. ",
                henv, rc, cbDDCur, szDriverDesc));
    PrintMultiString( " Driver Attributes", cbDACur, (char *) szDriverAttrib);


    szDriverDesc[0] = szDriverAttrib[0] = '\0';
    cbDDCur = cbDACur = 0;
    rc = pSQLDataSources( henv, SQL_FETCH_FIRST,
                        szDriverDesc, cbDD, &cbDDCur,
                        szDriverAttrib, cbDA, &cbDACur);
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    DBGPRINTF( ( DBG_CONTEXT,
                " SQLDataSources( %08x) ==> RetCode = %d."
                " Data Sources. = ( %d bytes) %s. ",
                henv, rc, cbDDCur, szDriverDesc));
    PrintMultiString( " Data Source Description", cbDACur,
                     (char *) szDriverAttrib);

    return;
} // AuxOdbcFunctions()


# endif // 0



/************************************************************
 *    Member Functions of ODBC_PARAMETER
 ************************************************************/


BOOL
ODBC_PARAMETER::CopyValue( IN LPCWSTR  pwszValue)
/*++
  Description:
    This function copies the given Unicode string as the value into
      current parameter marker to be used for future insertion.

  Arguments:
    pwszValue   pointer to null-terminated string containing Unicode value to
                    be copied into the parameter marker.

  Returns:
    TRUE on success and FALSE if there is any error.

  Note:
    Since ODBC does not support Unicode directly right now, we convert
      string value to be ANSI before copying the value over.
--*/
{
    BOOL fReturn = FALSE;

    CHAR * pszValue = ConvertUnicodeToAnsi( pwszValue );

    //
    // If successful then Copy ASCII value to buffer in the parameter block.
    //

    if ( pszValue != NULL) {

        fReturn = this->CopyValue( pszValue);

        LocalFree( pszValue);
    }

    return ( fReturn);
} // ODBC_PARAMETER::CopyValue()



BOOL
ODBC_PARAMETER::CopyValue( IN LPSYSTEMTIME lpst)
/*++
  Description:
    This function copies the given system time into the ODBC timestamp
     structure for the current parameter marker to be used for
     future insertion.

  Arguments:
   lpSystemTime   pointer to System Time structure containing current time.

  Returns:
    TRUE on success and FALSE if there is any error.

--*/
{
    TIMESTAMP_STRUCT * ptsOdbc;

    DBG_ASSERT( lpst != NULL);
    DBG_ASSERT( m_CType == SQL_C_TIMESTAMP);
    DBG_ASSERT( m_SqlType == SQL_TIMESTAMP);
    DBG_ASSERT( m_cbValueMax >= sizeof(TIMESTAMP_STRUCT));

    ptsOdbc = (TIMESTAMP_STRUCT * ) m_pValue;

    DBG_ASSERT( m_pValue != NULL);

    //
    // Copy the individual fields over properly
    // The types used in ODBC/Win32 are different
    //  So do a type specific copy of the values.
    //

    ptsOdbc->year   = (SWORD ) lpst->wYear;
    ptsOdbc->month  = (UWORD ) lpst->wMonth;
    ptsOdbc->day    = (UWORD ) lpst->wDay;
    ptsOdbc->hour   = (UWORD ) lpst->wHour;
    ptsOdbc->minute = (UWORD ) lpst->wMinute;
    ptsOdbc->second = (UWORD ) lpst->wSecond;
    ptsOdbc->fraction = (UDWORD ) lpst->wMilliseconds;

    return ( TRUE);
} // ODBC_PARAMETER::CopyValue()





RETCODE
ODBC_PARAMETER::Bind( IN HSTMT hStmt)
/*++
  Description:

    This functions binds the data about the parameter marker 'this'
     ( this object) represents to the statement provided.

  Arguments:
    hStmt        HANDLE for the statement to which this parameter
                  is to be bound.

  Returns:
    RETCODE value returned by SQLBindParamater().
--*/
{
    RETCODE  rc;
    DBG_ASSERT( hStmt != SQL_NULL_HSTMT);

    rc = pSQLBindParameter( hStmt,              // statement
                            QueryParamNumber(),
                            QueryParamType(),
                            QueryCType(),
                            QuerySqlType(),
                            QueryPrecision(),
                            QueryScale(),
                            QueryValue(),
                            QueryMaxCbValue(),
                            &(QueryCbValueRef())
                            );

    return ( rc);
} // ODBC_STATEMENT::BindParameter()





# if DBG

VOID
ODBC_PARAMETER::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing ODBC_PARAMETER ( %08x).\n"
                " Num=%u; Type=%d; CType=%d; SqlType=%d; Prec=%u; Scale=%d;"
                " CbMax=%d; Cb=%d.\n",
                this,
                QueryParamNumber(),
                QueryParamType(),
                QueryCType(),
                QuerySqlType(),
                QueryPrecision(),
                QueryScale(),
                QueryMaxCbValue(),
                QueryCbValue()));

    switch ( QuerySqlType()) {

      case SQL_INTEGER:
        {
            DWORD  dwValue = *(DWORD *) QueryValue();
            DBGPRINTF( ( DBG_CONTEXT, " Integer Value = %u\n", dwValue));
            break;
        }

      case SQL_CHAR:
        {
            LPCSTR pszValue = (LPCSTR ) QueryValue();
            DBGPRINTF( ( DBG_CONTEXT, " String Value( %08x) = %s\n",
                         pszValue, pszValue));
            break;
        }

      default:
        {
            DBGPRINTF( ( DBG_CONTEXT, " Type=%d. Unknown value at %08x\n",
                        QuerySqlType(), QueryValue()));
            break;
        }

    } // switch

    return;
} // ODBC_PARAMETER::Print()


# endif // DBG



/************************************************************
 * ODBC_STATEMENT  member functions
 ************************************************************/


ODBC_STATEMENT::~ODBC_STATEMENT( VOID)
{
    //
    // Free the statement handle
    //
    if ( m_hStmt != SQL_NULL_HSTMT) {

        m_rc = pSQLFreeStmt( m_hStmt, SQL_DROP);
        m_hStmt = SQL_NULL_HSTMT;

        // Ignore the error code here.
        DBG_ASSERT( ODBC_CONNECTION::Success( m_rc));

        IF_DEBUG( API_ENTRY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SqlFreeStmt() return code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    FreeColumnMemory();

} // ODBC_STATEMENT::~ODBC_STATEMENT()





BOOL
ODBC_STATEMENT::ExecDirect(
    IN LPCSTR pszSqlCommand,
    IN DWORD cchSqlCommand)
{
    BOOL fReturn;

    IF_DEBUG( API_ENTRY) {
        DBGPRINTF( ( DBG_CONTEXT,
                    " Executing the SQL command (%d bytes) %s.\n",
                    cchSqlCommand * sizeof( CHAR),
                    pszSqlCommand));
    }

    //
    //  SQLExecDirect only likes Unsigned chars !
    //
    m_rc = pSQLExecDirect( m_hStmt, (UCHAR FAR *) pszSqlCommand, cchSqlCommand);
    fReturn = ODBC_CONNECTION::Success( m_rc);

    IF_DEBUG( API_ENTRY) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " SQLExecDirect() returns code %d\n",
                    m_rc));
        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( fReturn);
} // ODBC_STATEMENT::ExecDirect()


#if 0
BOOL
ODBC_STATEMENT::ExecDirect(
    IN LPCWSTR pszSqlCommand,
    IN DWORD cchSqlCommand)
{
    BOOL fReturn = FALSE;
    char * pszCommand;

    if ( ( pszCommand = ConvertUnicodeToAnsi( pszSqlCommand ))
        != NULL ) {

        fReturn = ExecDirect( pszCommand, strlen( pszCommand));

        LocalFree( pszCommand);
    }

    return ( fReturn);
} // ODBC_STATEMENT::ExecDirect()

#endif




BOOL
ODBC_STATEMENT::PrepareStatement(IN LPCSTR    pszStatement)
/*++

  This function prepares the SQL statement for future execution.

  Arguments:
     pszStatement    pointer to null terminated string containing the
                        statement.

  Returns:
     TRUE on success and FALSE if there is any failure.
--*/
{
    BOOL fReturn;

    DBG_ASSERT( QueryErrorCode() == SQL_SUCCESS && pszStatement != NULL);

    m_rc = pSQLPrepare( m_hStmt, (UCHAR FAR *) pszStatement, SQL_NTS);

    IF_DEBUG( API_ENTRY) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " SQLPrepare( %s) returns ErrorCode = %d.\n",
                     pszStatement, m_rc));

        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( m_fPreparedStmt = ODBC_CONNECTION::Success( m_rc));
} // ODBC_STATEMENT::PrepareStatment()


#if 0

BOOL
ODBC_STATEMENT::PrepareStatement( IN LPCWSTR   pwszCommand)
/*++
  This function prepares an ODBC statement for execution.
  Since ODBC does not support UNICODE, we convert the statement into ANSI
   before calling the APIs.

  Arguments:
     pwszCommand      pointer to null-terminated string containing the
                       statement to be prepared.

  Returns:
     TRUE on success and FALSE if there is any failure.
--*/
{
    BOOL fReturn = FALSE;
    CHAR * pszCommand = NULL;

    DBG_ASSERT( pwszCommand != NULL);

    pszCommand = ConvertUnicodeToAnsi( pwszCommand );

    if ( pszCommand != NULL) {

        fReturn = PrepareStatement( pszCommand);

        LocalFree( pszCommand);

    } // pszCommand != NULL

    return ( fReturn);
} // ODBC_STATEMENT::PrepareStatement()
#endif




BOOL
ODBC_STATEMENT::BindParameter( IN PODBC_PARAMETER pOdbcParameter)
{

    DBG_ASSERT( ODBC_CONNECTION::Success( m_rc) && pOdbcParameter != NULL);

    m_rc = pOdbcParameter->Bind( m_hStmt);

    IF_DEBUG( API_ENTRY) {

        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( ODBC_CONNECTION::Success( m_rc));
} // ODBC_STATEMENT::BindParameter()





BOOL
ODBC_STATEMENT::ExecuteStatement( VOID)
/*++

  This function executes a prepared ODBC statement. At the end of execution,
   the transaction is also committed to ensure that the record is automatically
   written to the database.

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    DBG_ASSERT( m_fPreparedStmt != FALSE);

    if ( !ODBC_CONNECTION::Success( QueryErrorCode()) ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "!!WARNING!! - Attempting to use Invalid ODBC Connection!\n" ));
    }

    m_rc = pSQLExecute( m_hStmt);

    IF_DEBUG( API_ENTRY) {

        CheckAndPrintErrorMessage( this, m_rc);
    }

    return ( ODBC_CONNECTION::Success( m_rc));
} // ODBC_STATEMENT::ExecuteStatement()

BOOL
ODBC_STATEMENT::QueryRowCount(
    OUT DWORD * pcRows
    )
/*++

  Calls SQLRowCount on the current result set.

  NOTE: Not all database implementations support this!!

  Arguments:

    pcRows - Receives count of rows

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    m_rc = pSQLRowCount( m_hStmt,
                         (SDWORD *) pcRows );

    return ( ODBC_CONNECTION::Success( m_rc));
}


BOOL
ODBC_STATEMENT::QueryColNames(
    STR * *  pastrCols,
    DWORD  * cCols,
    DWORD    cchMaxFieldSize,
    BOOL *   pfHaveResultSet
    )
/*++

  This method returns the list of column names from the result table

  Arguments:

    pastrCols - Receives an array of STRs containing the column names
    cCols - Count of columns returned (zero for no result set)
    cchMaxFieldSize - Maximum buffer size to allocate for any data fields,
        zero means use the default value.
    pfHaveResultSet - Set to TRUE if the current query was a SELECT and thus has
        rows that can be enumerated

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    SWORD   nresultcols;
    SWORD   i;
    CHAR    achColName[64];
    SWORD   cchColName;
    SWORD   ColType;
    DWORD   cchColLength;
    SWORD   scale;
    SWORD   nullable;

    *pastrCols       = NULL;
    *cCols           = 0;
    *pfHaveResultSet = TRUE;

    //
    //  Return the old binding info if we already have it
    //

    if ( m_astrColNames )
    {
        *pastrCols = m_astrColNames;
        *cCols = m_cCols;

        return TRUE;
    }

    //
    //  Provide a default maximum field size if none was specified
    //

    if ( !cchMaxFieldSize )
        cchMaxFieldSize = DEFAULT_MAX_FIELD_SIZE;

    //
    //  See what kind of statement it was.  If there are no result
    //  columns, the statement is not a SELECT statement.
    //

    m_rc = pSQLNumResultCols( m_hStmt,
                              &nresultcols);

    if ( !ODBC_CONNECTION::Success( m_rc ))
        return FALSE;

    if ( nresultcols > 0 )
    {
        //
        //  Allocate an array of strings for the column names and the column
        //  values
        //

        m_cCols = nresultcols;
        *cCols  = m_cCols;

        m_astrColNames = new STR[m_cCols];
        m_astrValues   = new STR[m_cCols];
        m_acbValue     = new LONG[m_cCols];

        //
        //  Otherwise, get the column names of the result set and use the
        //  display_size() function to compute the length needed by each data
        //  type.  Next, bind the columns and specify all data will be
        //  converted to char.
        //

        for (i = 0; i < m_cCols; i++)
        {
            m_rc = pSQLDescribeCol( m_hStmt,
                                    i + 1,
                                    (UCHAR *) achColName,
                                    (SWORD)sizeof(achColName),
                                    &cchColName,
                                    &ColType,
                                    &cchColLength,
                                    &scale,
                                    &nullable);

            if ( !ODBC_CONNECTION::Success( m_rc ))
                return FALSE;

            //
            //  Select the buffer size for the retrieved data for this column
            //

            cchColLength = ODBC_CONNECTION::DisplaySize( ColType,
                                        min( cchColLength, cchMaxFieldSize) );

            //
            //  Copy the column name and set the column data size
            //

            if ( !m_astrColNames[i].Copy( achColName ) ||
                 !m_astrValues[i].Resize( cchColLength + 1 ))
            {
                return FALSE;
            }

            m_rc = pSQLBindCol( m_hStmt,
                                i + 1,
                                SQL_C_CHAR,
                                m_astrValues[i].QueryPtr(),
                                cchColLength,
                                &m_acbValue[i] );

            if ( !ODBC_CONNECTION::Success( m_rc ))
                return FALSE;
        }

        *pastrCols = m_astrColNames;
        *cCols     = m_cCols;
    }
    else
    {
        *pfHaveResultSet = FALSE;
    }

    return TRUE;
}


BOOL
ODBC_STATEMENT::QueryValuesAsStr(
    STR * * pastrValues,
    BOOL *  pfLast
    )
/*++

  This method gets the data at the current position.

  Arguments:

    pastrValues - Receives a pointer to an array of strings that contains
        the alphanumeric representation of that field

    pfLast - Set to TRUE if there are no more values to retrieve

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    *pastrValues = NULL;

    //
    //  Build the bindings if we haven't already
    //

    if ( !m_astrColNames )
    {
        STR * astrCols;
        DWORD cCols;
        BOOL  fHaveResultSet;

        if ( !QueryColNames( &astrCols,
                             &cCols,
                             0,
                             &fHaveResultSet ))
        {
            return FALSE;
        }
    }

    //
    //  If there are columns to enumerate, get them now
    //

    if ( m_astrColNames )
    {
        DWORD i;

        //
        //  Zero terminate the columns as some drivers don't write anything
        //  for NULL fields
        //

        for ( i = 0; i < m_cCols; i++ )
        {
            *((CHAR *) m_astrValues[i].QueryPtr()) = '\0';
        }

        //
        //  Fill in the binding values
        //

        m_rc = pSQLFetch( m_hStmt );

        if ( m_rc == SQL_NO_DATA_FOUND )
        {
            *pfLast = TRUE;
        }
        else
        {
            if ( !ODBC_CONNECTION::Success( m_rc ))
                return FALSE;

            *pfLast = FALSE;
        }

        *pastrValues = m_astrValues;
    }
    else
    {
        *pfLast = TRUE;
    }

    return TRUE;
}

BOOL
ODBC_STATEMENT::MoreResults(
    BOOL * pfMoreResults
    )
/*++

    Determines if there are any more results sets to return to the user

    pfMoreResults - Set to TRUE if there are more results in the result set

--*/
{
    *pfMoreResults = TRUE;

    m_rc = pSQLMoreResults( m_hStmt );

    if ( m_rc == SQL_NO_DATA_FOUND )
    {
        *pfMoreResults = FALSE;
        return TRUE;
    }

    if ( !ODBC_CONNECTION::Success( m_rc ))
        return FALSE;

    return TRUE;
}


VOID
ODBC_STATEMENT::FreeColumnMemory(
    VOID
    )
/*++
    This method frees memory allocated by the QueryColNames and
    QueryValuesAsStr methods.

--*/
{
    if ( m_astrColNames ) delete [] m_astrColNames;
    if ( m_astrValues )   delete [] m_astrValues;
    if ( m_acbValue )     delete [] m_acbValue;

    m_astrColNames = NULL;
    m_astrValues = NULL;
    m_acbValue = NULL;

}

# if DBG


VOID
ODBC_STATEMENT::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                " Printing ODBC_STATEMENT( %08x)."
                " HStmt = %08x. OdbcConn=%08x. RetCode = %d\n",
                m_hStmt, m_pOdbcConnection, m_rc));

} // ODBC_STATEMENT::Print()

# endif // DBG


/**************************************************
 *  Member Functions of class ODBC_CONNECTION
 **************************************************/


ODBC_CONNECTION::~ODBC_CONNECTION( VOID)
/*++
   This function closes the odbc connection ( if open) and cleans up.

--*/
{
    DBG_REQUIRE( Close());
    return;
} // ODBC_CONNECTION::~ODBC_CONNECTION()





BOOL
ODBC_CONNECTION::Open(
    IN LPCSTR   pszDataSource,
    IN LPCSTR   pszUserName,
    IN LPCSTR   pszPassword,
    IN BOOL     fLogFailureEvent)
/*++
  This function opens a new odbc connection to given data source
    using the user name and password supplied.

  Arguments:
    pszDataSource    pointer to null-terminated string containing ODBC
                         data source name
    pszUserName      pointer to null-terminated string containing UserName
    pszPassword      pointer to null-terminated string containing Password

  Returns:

    TRUE on success and FALSE if there is an error.
--*/
{
    BOOL fReturn = FALSE;

    DBG_ASSERT( pszDataSource != NULL &&
                pszUserName != NULL &&
                pszPassword != NULL);

    //
    //  Allocate an ODBC environment
    //

    m_rc = pSQLAllocEnv( &m_henv);
    fReturn = Success( m_rc);

    IF_DEBUG( API_ENTRY) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "SQLAllocEnv() returned ErrorCode %d. henv = %08x\n",
                    m_rc, m_henv));

        CheckAndPrintErrorMessage( this, m_rc);
    }

    if ( fReturn) {

        //
        // Establish memory for connection handle within the environment
        //

        m_rc = pSQLAllocConnect( m_henv, &m_hdbc);
        fReturn = Success( m_rc);

        IF_DEBUG( API_ENTRY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLAllocConnect() returns code %d. hdbc = %08x\n",
                        m_rc, m_hdbc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    if ( fReturn) {

        //
        // Use Following call to just printout the dynamic values for ODBC
        //
        // AuxOdbcFunctions( m_henv, m_hdbc);

#if 0
        {
            STR str;
            STR strOut;
            SWORD swStrOut;

            if ( !str.Append( pszDataSource )   ||
                 !str.Append( ";UID=" )         ||
                 !str.Append( pszUserName )     ||
                 !str.Append( ";PWD=" )         ||
                 !str.Append( pszPassword )     ||
                 !str.Append( ";APP=Internet Services") ||
                 !strOut.Resize( 255 ))
            {
                return FALSE;
            }

            m_rc = pSQLDriverConnect( m_hdbc,
                                      NULL,
                                      (UCHAR *) str.QueryStr(),
                                      SQL_NTS,
                                      (UCHAR *) strOut.QueryStr(),
                                      strOut.QuerySize(),
                                      &swStrOut,
                                      SQL_DRIVER_NOPROMPT );
        }
#else
        {
            m_rc = pSQLConnect( m_hdbc,
                               (UCHAR FAR *) pszDataSource, SQL_NTS,
                               (UCHAR FAR *) pszUserName,   SQL_NTS,
                               (UCHAR FAR *) pszPassword,   SQL_NTS);
        }
#endif

        fReturn = Success( m_rc);

        if ( !fReturn ) {

            //
            // Log it
            //

            if ( (g_eventLog != NULL ) && fLogFailureEvent)
            {

                STR     str;
                const CHAR*    tmpString[2];

                GetLastErrorText( &str, NULL, m_rc );

                tmpString[0] = pszDataSource;
                tmpString[1] = str.QueryStr();

                g_eventLog->LogEvent(
                        LOG_EVENT_ODBC_CONNECT_ERROR,
                        2,
                        tmpString,
                        m_rc);
            }
        }

        IF_DEBUG( API_ENTRY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLConnect( %s, %s, %s) returns code %d.\n",
                        pszDataSource,
                        pszUserName,
                        pszPassword,
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    m_fValid = fReturn;

    if ( !fReturn) {
        SetLastError( ERROR_GEN_FAILURE );
    }

    return ( fReturn);
} // ODBC_CONNECTION::Open()


#if 0


BOOL
ODBC_CONNECTION::Open(
    IN LPCWSTR  pwszDataSource,
    IN LPCWSTR  pwszUserName,
    IN LPCWSTR  pwszPassword)
/*++
  This function opens a new odbc connection to given data source
    using the user name and password supplied.

  Arguments:
    pwszDataSource    pointer to null-terminated string containing ODBC
                         data source name
    pwszUserName      pointer to null-terminated string containing UserName
    pwszPassword      pointer to null-terminated string containing Password

  Returns:
    TRUE on success and FALSE if there is an error.

  Note:
     Poor me.  ODBC Does not take UNICODE strings :(. 2/15/95
     So we will explicitly convert parameters to ANSI on stack.
--*/
{
    BOOL   fReturn;
    DWORD  dwError = NO_ERROR;
    CHAR * pszDataSource;
    CHAR * pszUserName;
    CHAR * pszPassword;

    //
    // Convert all parameters from UNICODE to ANSI
    //
    pszDataSource = ConvertUnicodeToAnsi( pwszDataSource );
    pszUserName   = ConvertUnicodeToAnsi( pwszUserName );
    pszPassword   = ConvertUnicodeToAnsi( pwszPassword );

    //
    // Make an ANSI open call.
    //
    fReturn = Open( pszDataSource, pszUserName, pszPassword);

    if ( !fReturn)  {

        dwError = GetLastError();
    }

    //
    //  Freeup the space allocated.
    //
    if ( pszDataSource != NULL) {

        LocalFree( pszDataSource);
        pszDataSource = NULL;
    }

    if ( pszUserName != NULL) {

        LocalFree( pszUserName);
        pszUserName = NULL;
    }

    if ( pszPassword != NULL) {

        //
        // Zero the password for security reasons.
        //
        memset( pszPassword, 0, strlen( pszPassword));

        LocalFree( pszPassword);
        pszPassword = NULL;
    }

    if ( !fReturn) {

        SetLastError( dwError);
    }

    return ( fReturn);
} // ODBC_CONNECTION::Open()
#endif



BOOL
ODBC_CONNECTION::Close( VOID)
/*++
  This function closes the connection established with the ODBC
   and frees up and dynamic memory used.

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:
    Intermediate failures are ignored. Normally they should not occur.

--*/
{
    BOOL fReturn = TRUE;


    //
    // Disconnect and free the connection.
    //
    if ( m_hdbc != SQL_NULL_HDBC) {

        m_rc = pSQLDisconnect( m_hdbc );

        //
        //  Disconnect is allowed to fail w/o being fatal so don't set
        //  fReturn
        //

        IF_DEBUG( API_ENTRY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "Warning: SQLDisconnect() returns code %d.\n",
                        m_rc));
            CheckAndPrintErrorMessage( this, m_rc);
        }

        m_rc = pSQLFreeConnect( m_hdbc);

        m_hdbc = SQL_NULL_HDBC;
        fReturn = fReturn && Success( m_rc);

        IF_DEBUG( API_ENTRY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLFreeConnect() returns code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    //
    //  Free the ODBC environment handle.
    //
    if ( m_henv != SQL_NULL_HENV) {

        m_rc = pSQLFreeEnv( m_henv);
        m_henv = SQL_NULL_HENV;
        fReturn = fReturn && Success( m_rc);

        IF_DEBUG( API_ENTRY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLFreeEnv() returns code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    return ( fReturn);
} // ODBC_CONNECTION::Close()





PODBC_STATEMENT
ODBC_CONNECTION::AllocStatement( VOID)
/*++
  Description:
    This function allocates a new ODBC statement object and also calls
     SQLAllocStatement to create the state required for establishing the
     statement in the ODBC Manager.

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{
    PODBC_STATEMENT pOdbcStmt = NULL;
    HSTMT   hstmt = SQL_NULL_HSTMT;

    DBG_ASSERT( Success( m_rc));

    //
    // Allocate a statement handle and associate it with the connection.
    //
    m_rc = pSQLAllocStmt( m_hdbc, &hstmt);

    IF_DEBUG( API_ENTRY) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "SqlAllocStmt() returns code %d."
                    " New Hstmt is : %08x\n",
                    m_rc, hstmt));
        CheckAndPrintErrorMessage( this, m_rc);
    }

    if ( ODBC_CONNECTION::Success( m_rc)) {

        pOdbcStmt = new ODBC_STATEMENT( this, hstmt);
    }

    return ( pOdbcStmt);
} // ODBC_CONNECTION::AllocStatement()


BOOL
ODBC_CONNECTION::SetConnectOption(
    IN UWORD      Option,
    IN SQLPOINTER Param
    )
/*++

  Sets various options on this connection

  Arguments:

    Option - Option to set
    Param - Option value (32 bit dword or pointer to null terminated string)

  Returns:
    TRUE on success and FALSE if there are any failures.  Failures are
    considered to be soft errors as the problem may be the driver doesn't
    support the option etc.

  Note:

--*/
{
    BOOL    fReturn = TRUE;
    RETCODE rc;

    if ( m_hdbc != SQL_NULL_HDBC)
    {
        rc = pSQLSetConnectOption( m_hdbc, Option, Param );

        fReturn = Success( rc);

        IF_DEBUG( API_ENTRY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLSetConnectOption( %d, %d ) returns code %d.\n",
                        Option,
                        Param,
                        rc));

            CheckAndPrintErrorMessage( this, rc);
        }
    }
    else
    {
        DBGPRINTF( ( DBG_CONTEXT,
                     "[SetConnectOption] Warning: Setting option on closed connection\n" ));
    }

    return fReturn;
}



BOOL
ODBC_CONNECTION::GetLastErrorText(
    OUT STR *    pstrError,
    IN  HSTMT    hstmt,
    IN  RETCODE  rc
    ) const
/*++

  This method returns the textual representation of the last ODBC or windows
  error that occurred.  Even though the ODBC methods return FALSE on failure,
  if it was an ODBC call that failed, then GetLastError won't return the
  needed error code.  Clients of this class should call this method to get
  a descriptive text string of the failure.

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:
    If this function returns FALSE, then a client should call GetLastError
    for the error code.

--*/
{
    BOOL fReturn = TRUE;

    if ( ODBC_CONNECTION::Success( rc)) {

        fReturn = pstrError->LoadString( GetLastError());

    } else {

        CHAR     rgchMsg[ SQL_MAX_MESSAGE_LENGTH + 10];
        CHAR     achState[30];
        CHAR     rgchFullMsg[ sizeof(rgchMsg) + sizeof(achState) + 60];
        SWORD    cbMsg;
        LONG     lError;
        DWORD    dwError;

        //
        //  If we're formatting as HTML, we bullet list the items
        //

        if ( !pstrError->Copy( (CHAR *) NULL ) )
        {
            return FALSE;
        }

        //
        //  Loop to pick up all of the errors
        //

        do {
            cbMsg = SQL_MAX_MESSAGE_LENGTH;

            rc = pSQLError( m_henv,
                            m_hdbc,
                            hstmt,
                            (UCHAR *) achState,
                            &lError,
                            (UCHAR *) rgchMsg,
                            cbMsg,
                            &cbMsg );

            if ( ODBC_CONNECTION::Success( rc)) {

                wsprintf( rgchFullMsg,
                             "[State=%s][Error=%d]%s\n",
                             achState, lError, rgchMsg);

                if ( !pstrError->Append( rgchFullMsg )) {

                    fReturn = FALSE;
                    break;
                }
            } else {

                //
                //  This is indicates there are no more error strings
                //  to pick up so we should get out
                //

                if ( rc == SQL_NO_DATA_FOUND ) {

                    //
                    //  Append the end of unorder list marker
                    //

                    rc = SQL_SUCCESS;
                    break;
                }
            }

        } while ( ODBC_CONNECTION::Success( rc) );

        if ( !ODBC_CONNECTION::Success( rc) )
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        "[GetLastErrorText] SqlError() returned error %d.\n",
                        rc));

            SetLastError( ERROR_GEN_FAILURE );
            fReturn = FALSE;
        }
    }

    return ( fReturn);

} // ODBC_CONNECTION::GetLastErrorText()



BOOL
ODBC_CONNECTION::GetLastErrorTextAsHtml(
    OUT STR *    pstrError,
    IN  HSTMT    hstmt,
    IN  RETCODE  rc
    ) const
/*++

  This method returns the textual representation of the last ODBC or windows
  error that occurred.  Even though the ODBC methods return FALSE on failure,
  if it was an ODBC call that failed, then GetLastError won't return the
  needed error code.  Clients of this class should call this method to get
  a descriptive text string of the failure.

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:
    If this function returns FALSE, then a client should call GetLastError
    for the error code.

--*/
{
    BOOL fReturn = TRUE;

    if ( ODBC_CONNECTION::Success( rc)) {

        fReturn = pstrError->LoadString( GetLastError());

    } else {

        CHAR     rgchMsg[ SQL_MAX_MESSAGE_LENGTH + 10];
        CHAR     achState[30];
        CHAR     rgchFullMsg[ sizeof(rgchMsg) + sizeof(achState) + 60];
        SWORD    cbMsg;
        LONG     lError;
        DWORD    dwError;

        //
        //  If we're formatting as HTML, we bullet list the items
        //

        if ( !pstrError->Copy( "<UL>" ))
        {
            return FALSE;
        }

        //
        //  Loop to pick up all of the errors
        //

        do {
            cbMsg = SQL_MAX_MESSAGE_LENGTH;

            rc = pSQLError( m_henv,
                            m_hdbc,
                            hstmt,
                            (UCHAR *) achState,
                            &lError,
                            (UCHAR *) rgchMsg,
                            cbMsg,
                            &cbMsg );

            if ( ODBC_CONNECTION::Success( rc)) {

                wsprintf( rgchFullMsg,
                          "<LI>[State=%s][Error=%d]%s\n",
                          achState, lError, rgchMsg);

                if ( !pstrError->Append( rgchFullMsg )) {

                    fReturn = FALSE;
                    break;
                }
            } else {

                //
                //  This is indicates there are no more error strings
                //  to pick up so we should get out
                //

                if ( rc == SQL_NO_DATA_FOUND ) {

                    //
                    //  Append the end of unorder list marker
                    //

                    if ( !pstrError->Append( "</UL>" )) {
                        return FALSE;
                    }

                    rc = SQL_SUCCESS;
                    break;
                }
            }

        } while ( ODBC_CONNECTION::Success( rc) );

        if ( !ODBC_CONNECTION::Success( rc) )
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        "[GetLastErrorText] SqlError() returned error %d.\n",
                        rc));

            SetLastError( ERROR_GEN_FAILURE );
            fReturn = FALSE;
        }
    }

    return ( fReturn);

} // ODBC_CONNECTION::GetLastErrorTextAsHtml()



BOOL
ODBC_CONNECTION::GetInfo(IN DWORD fInfoType,
                         IN PVOID rgbInfoValue,
                         IN DWORD cbInfoValueMax,
                         IN OUT DWORD * pcbInfoValue)
/*++
  This function obtains the value of the fInfoType for a specific
   ODBC Connection. It mimicks the SQLGetInfo() and uses it to obtain
   this value. On successful return the pointer rgbInfoValue contains
   the requested value and pcbInfoValue contains the size in bytes of
   data.

  Arguments:
    fInfoType - flag containing the Information Type (name) to be fetched.
    rgbInfoValue - pointer to buffer which will contain the return data.
    cbInfoValue  - size of rgbInfoValue in bytes.
    pcbInfoValue - pointer to location that will contain the size of
                    information stored in rgbInfoValue, on successful return.
                   If buffer is insufficient, this location will contain the
                    required number of bytes.

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    BOOL fReturn = FALSE;

    if ( m_hdbc != SQL_NULL_HDBC) {

        RETCODE rc;

        rc = pSQLGetInfo( m_hdbc, (UWORD ) fInfoType,
                         (PTR)   rgbInfoValue,
                         (SWORD) cbInfoValueMax,
                         (SWORD FAR *) pcbInfoValue);

        fReturn = Success( rc);

        IF_DEBUG( API_ENTRY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLGetInfo( %08x, %d, %08x, %d, %08x) returns %d.\n",
                        m_hdbc, fInfoType, rgbInfoValue, cbInfoValueMax,
                        pcbInfoValue, rc));

            CheckAndPrintErrorMessage( this, rc);
        }
    } else {

        DBGPRINTF( ( DBG_CONTEXT,
                    "[SQLGetInfo] Invalid Connection to ODBC\n"));
    }

    return (fReturn);
} // ODBC_CONNECTION::GetInfo()



DWORD
ODBC_CONNECTION::DisplaySize(
    SWORD coltype,
    DWORD collen
    )
{
    DWORD cbSize = MAX_NONCHAR_DATA_LEN;

    //
    //  Note that we always set the size to at least four bytes.  This prevents
    //  any possible problems if the column to be bound is NULLable, which can
    //  cause a NULL to be written for the data during a fetch
    //

    switch (coltype)
    {
      case SQL_CHAR:
      case SQL_VARCHAR:
      case SQL_LONGVARCHAR:
      case SQL_BINARY:
      case SQL_VARBINARY:
      case SQL_LONGVARBINARY:
        cbSize = max(collen + sizeof(CHAR), sizeof(PVOID));
        break;

      default:
        break;
    }

    return ( cbSize);
} // ODBC_CONNECTION::DisplaySize()




# if DBG
VOID
ODBC_CONNECTION::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing ODBC_CONNECTION ( %08x). fValid = %d\n"
                " HENV = %08x. HDBC = %08x. ReturnCode =%d\n",
                this, m_fValid,
                m_henv, m_hdbc, m_rc));
    return;
} // ODBC_CONNECTION::Print()


# endif // DBG


LPSTR
ConvertUnicodeToAnsi(
    IN LPCWSTR  lpszUnicode
    )
/*++
    Description:
        Converts given null-terminated string into ANSI in the buffer supplied.

    Arguments:
        lpszUnicode         null-terminated string in Unicode

    Returns:
        pointer to converted ANSI string. NULL on errors.

--*/
{

    DWORD cchLen;
    DWORD nBytes;
    LPSTR lpszAlloc = NULL;

    if ( lpszUnicode == NULL) {
        return (NULL);
    }

    //
    // multiply by 2 to accomodate DBCS
    //

    cchLen = wcslen( lpszUnicode);
    nBytes = (cchLen+1) * sizeof(CHAR) * 2;
    lpszAlloc = (LPSTR ) LocalAlloc( 0, nBytes );

    if ( lpszAlloc != NULL) {

        cchLen = WideCharToMultiByte( CP_ACP,
                                      WC_COMPOSITECHECK,
                                      lpszUnicode,
                                      -1,
                                      lpszAlloc,
                                      nBytes,
                                      NULL,  // lpszDefaultChar
                                      NULL   // lpfDefaultUsed
                                     );

        DBG_ASSERT(cchLen == (strlen(lpszAlloc)+1) );

        if ( cchLen == 0 ) {

            //
            // There was a failure. Free up buffer if need be.
            //

            DBGPRINTF((DBG_CONTEXT,"WideCharToMultiByte failed with %d\n",
                GetLastError()));

            LocalFree( lpszAlloc);
            lpszAlloc = NULL;

        } else {

            DBG_ASSERT( cchLen <= nBytes );
            DBG_ASSERT(lpszAlloc[cchLen-1] == '\0');

            lpszAlloc[cchLen-1] = '\0';
        }
    }

    return ( lpszAlloc);

} // ConvertUnicodeToAnsi
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\plugin1.h ===
// plugin1.h : main header file for PLUGIN1.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPlugin1App : See plugin1.cpp for implementation.

class CPlugin1App : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\script_i_stub.c ===
#include "script_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\logscript.cpp ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
      logscript.cpp

   Abstract:
      Base implementation for ILogScripting - Automation compatible logging interface

   Author:

       Saurab Nog    ( saurabn )    01-Feb-1998

   Project:

       IIS Logging 5.0

--*/

#include "precomp.hxx"
#include <stdio.h>
#include <script.h>
#include <LogScript.hxx>

extern DWORD FastDwToA(CHAR*   pBuf, DWORD   dwV);


/* ************************************************************************* */
/* ************************************************************************* */

CLogScript::CLogScript( 
    VOID
)
:
    m_pInputLogFile         ( NULL),
    m_pOutputLogFile        ( NULL),
    m_strInputLogFileName   ( ),
    m_pszLogLine            ( NULL),
    m_dwLogLineSize         ( 0)
{
    INITIALIZE_CRITICAL_SECTION( &m_csLock );
    ReadInetLogLine.iCustomFieldsCount = 0;
    ResetInetLogLine(ReadInetLogLine);

    m_szEmpty = A2BSTR("-");
}

/* ************************************************************************* */
/* ************************************************************************* */

CLogScript::~CLogScript(
    VOID
)
{
    LockCS();

    if ( m_pInputLogFile!=NULL) {
        fclose(m_pInputLogFile);
        m_pInputLogFile = NULL;
    }

    if ( (m_pszLogLine != NULL) && (m_dwLogLineSize != 0))
    {
        delete [] m_pszLogLine;
    }
    
    UnlockCS();
    DeleteCriticalSection( &m_csLock );
}

/* ************************************************************************* */
/* ************************************************************************* */

void 
CLogScript::ResetInetLogLine(INET_LOGLINE& InetLogLine)
{
    InetLogLine.pszClientHostName = NULL;
    InetLogLine.pszClientUserName = NULL;
    InetLogLine.pszServerAddress  = NULL;     // input ip address for connection
    InetLogLine.pszOperation      = NULL;     //  eg: 'get'  in FTP
    InetLogLine.pszTarget         = NULL;     // target path/machine name
    InetLogLine.pszParameters     = NULL;     // string containing parameters.
    InetLogLine.pszVersion        = NULL;     // protocol version string.
    InetLogLine.pszHTTPHeader     = NULL;     // Header Information
    InetLogLine.pszBytesSent      = NULL;     // count of bytes sent
    InetLogLine.pszBytesRecvd     = NULL;     // count of bytes recvd
    InetLogLine.pszTimeForProcessing = NULL;  // time required for processing
    InetLogLine.pszWin32Status    = NULL;     // Win32 error code. 0 for success
    InetLogLine.pszProtocolStatus = NULL;     // status: whatever service wants.
    InetLogLine.pszPort           = NULL;
    InetLogLine.pszSiteName       = NULL;     // Site name (not put in https log)
    InetLogLine.pszComputerName   = NULL;     // netbios name of Server

    InetLogLine.DateTime          = 0;        // Date & Time

    InetLogLine.pszUserAgent       = NULL;    // User Agent - Browser type
    InetLogLine.pszCookie          = NULL;
    InetLogLine.pszReferer         = NULL;    // Referring URL.
    
    for ( int i = 0; i < InetLogLine.iCustomFieldsCount-1; i++)
    {
        (InetLogLine.CustomFields[i]).pchData = NULL;
    }
}

/* ************************************************************************* */
/* ************************************************************************* */

//
// ILogScripting Interface
//

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScript::OpenLogFile(
    BSTR    szLogFileName,
    IOMode  Mode,
    BSTR    szServiceName,
    long    iServiceInstance,
    BSTR    szOutputLogFileFormat
)
{
    USES_CONVERSION;

    LockCS();

    if (ForReading == Mode)
    {
        if (m_pInputLogFile != NULL)
        {
            fclose(m_pInputLogFile);
            m_pInputLogFile = NULL;
        }

        m_strInputLogFileName.Copy(W2A(szLogFileName));
    
        if (m_pszLogLine == NULL)
        {
            m_dwLogLineSize = MAX_LOG_RECORD_LEN+1;
            m_pszLogLine = new CHAR[m_dwLogLineSize];

            if (m_pszLogLine == NULL)
                m_dwLogLineSize = 0;
        }
    }
    else
    {
        if (m_pOutputLogFile != NULL)
        {
            fclose(m_pOutputLogFile);
            m_pOutputLogFile = NULL;
        }

        m_strOutputLogFileName.Copy(W2A(szLogFileName));
    }

    UnlockCS();
    SysFreeString(szLogFileName);

    return(S_OK);
    
} // SetInputLogFile

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::CloseLogFiles(IOMode Mode)
{
    LockCS();
    
    if( ((ForReading == Mode) || (AllOpenFiles == Mode)) &&
        (m_pInputLogFile != NULL) 
      )
    {
        fclose(m_pInputLogFile);
        m_pInputLogFile = NULL;
    }

    if( ((ForWriting == Mode) || (AllOpenFiles == Mode)) &&
        (m_pOutputLogFile != NULL) 
      )
    {
        fclose(m_pOutputLogFile);
        m_pOutputLogFile = NULL;
    }
    
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScript::ReadFilter( DATE startDateTime,  DATE endDateTime)
{
    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::ReadLogRecord( VOID )
{

    HRESULT     hr = S_OK;

    LockCS();
    
    if (m_pInputLogFile == NULL)
    {
        m_pInputLogFile = fopen(m_strInputLogFileName.QueryStr(), "r");
        
        if (m_pInputLogFile == NULL)
        {
            return E_FAIL;
        }
    }

    ResetInetLogLine(ReadInetLogLine);
    
    //
    // Call the plugin to fill in the INET_LOGLINE structure
    //
    
    hr = ReadFileLogRecord(m_pInputLogFile, &ReadInetLogLine, m_pszLogLine, m_dwLogLineSize);

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    UnlockCS();
     
    return(hr);
    
} // ReadLogRecord

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScript::AtEndOfLog(VARIANT_BOOL *pfEndOfRead)
{
    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::WriteLogRecord(ILogScripting * pILogScripting)
{
    HRESULT     hr = S_OK;
    bool        fWriteHeader = false;

    LockCS();
    
    if (m_pOutputLogFile == NULL)
    {
        m_pOutputLogFile = fopen(m_strOutputLogFileName.QueryStr(), "w+");
        
        if (m_pOutputLogFile == NULL)
        {
            return E_FAIL;
        }

        fWriteHeader = true;
    }

    //
    // Call the plugin to write the INET_LOGLINE structure to file
    //
    
    hr = WriteFileLogRecord(m_pOutputLogFile, pILogScripting, fWriteHeader);

    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    UnlockCS();
     
    return(hr);
}
/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::get_DateTime( VARIANT * pvarDateTime)
{
    LockCS();
    pvarDateTime->vt   = VT_DATE;
    pvarDateTime->date = ReadInetLogLine.DateTime;
    UnlockCS();

    return S_OK;

}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::get_ServiceName(VARIANT * pvarServiceName)
{
    LockCS();
    SetVariantToBstr(pvarServiceName, ReadInetLogLine.pszSiteName) ;
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_ServerName(VARIANT * pvarServerName)
{
    LockCS();
    SetVariantToBstr(pvarServerName, ReadInetLogLine.pszComputerName);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_ClientIP(VARIANT * pvarClientIP)
{

    LockCS();
    SetVariantToBstr(pvarClientIP, ReadInetLogLine.pszClientHostName);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_UserName(VARIANT * pvarUserName)
{
    LockCS();
    SetVariantToBstr(pvarUserName, ReadInetLogLine.pszClientUserName);
    UnlockCS();
    
    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_ServerIP(VARIANT * pvarServerIP)
{
    LockCS();
    SetVariantToBstr(pvarServerIP, ReadInetLogLine.pszServerAddress);
    UnlockCS();
    
    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_Method(VARIANT * pvarMethod)
{
    LockCS();
    SetVariantToBstr(pvarMethod, ReadInetLogLine.pszOperation);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_URIStem(VARIANT * pvarURIStem)
{
    LockCS();
    SetVariantToBstr(pvarURIStem, ReadInetLogLine.pszTarget);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_URIQuery(VARIANT * pvarURIQuery)
{
    LockCS();
    SetVariantToBstr( pvarURIQuery, ReadInetLogLine.pszParameters);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::get_TimeTaken(VARIANT * pvarTimeTaken)
{
    LockCS();
    SetVariantToLong(pvarTimeTaken, ReadInetLogLine.pszTimeForProcessing);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_BytesSent( VARIANT * pvarBytesSent )
{
    LockCS();
    SetVariantToLong(pvarBytesSent, ReadInetLogLine.pszBytesSent);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_BytesReceived(VARIANT * pvarBytesReceived)
{
    LockCS();
    SetVariantToLong(pvarBytesReceived, ReadInetLogLine.pszBytesRecvd);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_Win32Status( VARIANT * pvarWin32Status )
{
    LockCS();
    SetVariantToLong(pvarWin32Status, ReadInetLogLine.pszWin32Status);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_ProtocolStatus( VARIANT * pvarProtocolStatus )
{
    LockCS();
    SetVariantToLong(pvarProtocolStatus, ReadInetLogLine.pszProtocolStatus);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */


STDMETHODIMP
CLogScript::get_ServerPort(VARIANT * pvarServerPort)
{
    LockCS();
    SetVariantToLong(pvarServerPort, ReadInetLogLine.pszPort);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::get_ProtocolVersion(VARIANT * pvarProtocolVersion)
{
    LockCS();
    SetVariantToBstr(pvarProtocolVersion, ReadInetLogLine.pszVersion);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::get_UserAgent(VARIANT * pvarUserAgent)
{
    LockCS();
    SetVariantToBstr(pvarUserAgent, ReadInetLogLine.pszUserAgent);
    UnlockCS();

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::get_Cookie(VARIANT * pvarCookie)
{
    LockCS();
    SetVariantToBstr(pvarCookie, ReadInetLogLine.pszCookie);
    UnlockCS();
    
    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::get_Referer(VARIANT * pvarReferer)
{
    LockCS();
    SetVariantToBstr(pvarReferer, ReadInetLogLine.pszReferer);
    UnlockCS();
    
    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP
CLogScript::get_CustomFields(VARIANT * pvarCustomFieldsArray)
{
    USES_CONVERSION;
    
    HRESULT hr = S_OK;
    BSTR    strData;
    int     cItems;

    cItems = ReadInetLogLine.iCustomFieldsCount;


    // we will leave that value in case of error
    pvarCustomFieldsArray->vt = VT_NULL;

    if ( 0 < cItems)
    {
 
        // Create 2D SafeArray & stuff with header & string pairs

        SAFEARRAYBOUND rgsabound[2];

        rgsabound[0].lLbound = rgsabound[1].lLbound = 0;

        rgsabound[0].cElements = ReadInetLogLine.iCustomFieldsCount;
        rgsabound[1].cElements = 2;
    
        SAFEARRAY * psaCustom = SafeArrayCreate(VT_VARIANT, 2, rgsabound);

        if ( NULL != psaCustom)
        {
            long i;
            long ix[2];
            VARIANT v;
            
            
            ix[1]=0;
            
            for ( i = 0; i < cItems; i++)
            {
                VariantInit(&v);
                v.vt = VT_BSTR;
                v.bstrVal = A2BSTR(ReadInetLogLine.CustomFields[i].szHeader);
                
                ix[0]=i;
                
                hr = SafeArrayPutElement( psaCustom, ix, &v );
                VariantClear(&v);
                
                if (FAILED (hr))
                {
                    goto exit_point;
                }
                
            }
            
            
            ix[1]=1;
            
            for ( i = 0; i < cItems; i++)
            {
                VariantInit(&v);
                v.vt = VT_BSTR;
                v.bstrVal = A2BSTR(ReadInetLogLine.CustomFields[i].pchData);
                
                ix[0]=i;
                
                hr = SafeArrayPutElement( psaCustom, ix, &v );
                VariantClear(&v);
                
                if (FAILED (hr))
                {
                    goto exit_point;
                }
            }
        }

        if (NULL != pvarCustomFieldsArray)
        {
            pvarCustomFieldsArray->vt = VT_ARRAY|VT_VARIANT;
            pvarCustomFieldsArray->parray = psaCustom;
        }
    }

exit_point:

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

VOID
CLogScript::SetVariantToBstr (VARIANT * pVar, LPSTR pCh)
{
    USES_CONVERSION;
    
    if ( NULL ==  pCh)
    {
        pVar->vt = VT_NULL;
    }
    else if ( 0 == strcmp( pCh, "-"))
    {
        pVar->vt = VT_EMPTY;
    }
    else
    {
        pVar->vt     = VT_BSTR;
        pVar->bstrVal= A2BSTR(pCh);
    }
}

/* ************************************************************************* */
/* ************************************************************************* */

VOID
CLogScript::SetVariantToLong (VARIANT * pVar, LPSTR pCh)
{
    if ( NULL ==  pCh)
    {
        pVar->vt = VT_NULL;
    }
    else if ( 0 == strcmp( pCh, "-"))
    {
        pVar->vt = VT_EMPTY;
    }
    else
    {
        pVar->vt    = VT_I4;
        pVar->lVal  = atol(pCh);
    }
}

/* ************************************************************************* */
/* ************************************************************************* */

BSTR  
CLogScript::GetBstrFromVariant (VARIANT * pVar)
{
    if ((VT_NULL == pVar->vt) || 
        (VT_EMPTY == pVar->vt)
       )
    {
        return m_szEmpty;
    }
    else
    {   
        return pVar->bstrVal;
    }
}

/* ************************************************************************* */
/* ************************************************************************* */

DWORD  
CLogScript::GetLongFromVariant (VARIANT * pVar, CHAR * pBuffer)
{
    if ((VT_NULL == pVar->vt) || 
        (VT_EMPTY == pVar->vt)
       )
    {
        pBuffer[0] = '-';
        pBuffer[1] = '\0';
        return 1;
    }
    else
    {   
        return FastDwToA(pBuffer, pVar->lVal);
    }
}

/* ************************************************************************* */
/* ************************************************************************* */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\sources.inc ===
DLLDEF=..\iislog.def
TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLENTRY=DLLEntry

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_CXX=1
USE_MSVCRT=1
WIN32_WINNT_VERSION=0x0500
USE_ATL=1

INCLUDES=..;\
       ..\..\idl\$(O);             \
       ..\..\comlog\$(O);          \
       $(IISBASEDIR)\inc;       \
       ..\..\scripting;

SOURCES=\
        ..\cofact.cxx      \
        ..\plugin.rc       \
        ..\filectl.cpp     \
        ..\asclogc.cpp     \
        ..\extlogc.cpp     \
        ..\ncslogc.cpp     \
        ..\dynodbc.cxx     \
        ..\ilogfile.cxx    \
        ..\misc.cpp        \
        ..\odbcconn.cxx    \
        ..\LogScript.cpp   \
        ..\script_i_stub.c

TARGETLIBS=\
       $(IISBASEDIR)\svcs\iisrtl\$(O)\iisrtl.lib     \
       $(SDK_LIB_PATH)\ole32.lib     \
       $(SDK_LIB_PATH)\kernel32.lib  \
       $(SDK_LIB_PATH)\user32.lib   \
       $(SDK_LIB_PATH)\advapi32.lib  \
       $(SDK_LIB_PATH)\oleaut32.lib  \
       $(SDK_LIB_PATH)\uuid.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\asclogc.cpp ===
/*++

   Copyright (c) 1996-1999  Microsoft Corporation

   Module  Name :
      asclogc.cpp

   Abstract:
      MS Logging Format implementation

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

#include "precomp.hxx"
#include <stdio.h>
#include <winnls.h>
#include <script.h>
#include "LogScript.hxx"
#include <ilogobj.hxx>
#include "filectl.hxx"
#include "asclogc.hxx"

CHAR    szAsciiNoPeriodPattern[] = "inetsv*.log";

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

CASCLOG::CASCLOG()
{
}

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

CASCLOG::~CASCLOG()
{
}

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

LPCSTR
CASCLOG::QueryNoPeriodPattern(
    VOID
    )
{
    return szAsciiNoPeriodPattern;
} // CASCLOG::QueryNoPeriodPattern

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

VOID
CASCLOG::FormNewLogFileName(
                IN LPSYSTEMTIME pstNow
                )
/*++
  This function that forms the new log file name based on
   type of periodic logging done.

  Arguments:
    pstNow     pointer to SystemTime which contains the current time.
    fBackup    flag indicating if we want to make current file a backup.

  Returns:
    TRUE on success in forming the name or FALSE if there is any error.

--*/
{

    I_FormNewLogFileName(pstNow,DEFAULT_LOG_FILE_NAME);
    return;

} // INET_FILE_LOG::FormNewLogFileName()

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

VOID
FormatLogDwords(
    IN IInetLogInformation * pLogObj,
    IN LPSTR *pBuffer,
    IN DWORD *pcbSize,
    IN PDWORD pRequired
    )
{

    CHAR    tmpBuf[32];
    DWORD   cbTmp;

    //
    // Processing Time
    //

    cbTmp = FastDwToA( tmpBuf, pLogObj->GetTimeForProcessing() );

    *pRequired += cbTmp;
    if ( *pRequired <= *pcbSize ) {
        tmpBuf[cbTmp] = ',';
        tmpBuf[cbTmp+1] = ' ';
        CopyMemory(*pBuffer, tmpBuf, cbTmp+2);
        *pBuffer += cbTmp+2;
    }

    //
    // Bytes Received
    //

    cbTmp = FastDwToA( tmpBuf, pLogObj->GetBytesRecvd() );

    *pRequired += cbTmp;
    if ( *pRequired <= *pcbSize ) {
        tmpBuf[cbTmp] = ',';
        tmpBuf[cbTmp+1] = ' ';
        CopyMemory(*pBuffer, tmpBuf, cbTmp+2);
        *pBuffer += cbTmp+2;
    }

    //
    // Bytes Sent
    //

    cbTmp = FastDwToA( tmpBuf, pLogObj->GetBytesSent() );

    *pRequired += cbTmp;
    if ( *pRequired <= *pcbSize ) {
        tmpBuf[cbTmp] = ',';
        tmpBuf[cbTmp+1] = ' ';
        CopyMemory(*pBuffer, tmpBuf, cbTmp+2);
        *pBuffer += cbTmp+2;
    }

    //
    // HTTP Status
    //

    cbTmp = FastDwToA( tmpBuf, pLogObj->GetProtocolStatus() );

    *pRequired += cbTmp;
    if ( *pRequired <= *pcbSize ) {
        tmpBuf[cbTmp] = ',';
        tmpBuf[cbTmp+1] = ' ';
        CopyMemory(*pBuffer, tmpBuf, cbTmp+2);
        *pBuffer += cbTmp+2;
    }

    //
    // Win32 status
    //

    cbTmp = FastDwToA( tmpBuf, pLogObj->GetWin32Status() );

    *pRequired += cbTmp;
    if ( *pRequired <= *pcbSize ) {
        tmpBuf[cbTmp] = ',';
        tmpBuf[cbTmp+1] = ' ';
        CopyMemory(*pBuffer, tmpBuf, cbTmp+2);
        *pBuffer += cbTmp+2;
    }

    return;

} // FormatLogDwords

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

BOOL
CASCLOG::FormatLogBuffer(
         IN IInetLogInformation *pLogObj,
         IN LPSTR                pBuf,
         IN DWORD                *pcbSize,
         OUT SYSTEMTIME          *pSystemTime
    )
{

    CHAR  rgchDateTime[ 32];

    PCHAR pBuffer = pBuf;
    PCHAR pTmp;
    DWORD cbTmp;
    DWORD nRequired;

    if ( pBuf == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Format is:
    // Host UserName Date Time Service ComputerName ServerIP
    //      msProcessingTime bytesR bytesS protocolStat Win32Stat
    //      Operation Target Parameters
    //

    //
    // Host ID
    //

    pTmp = pLogObj->GetClientHostName( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired = cbTmp + 2;  // 2 for delimiter
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';
    }

    //
    // UserName
    //

    pTmp = pLogObj->GetClientUserName( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp + 2;  //2 for delimiter
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';
    }

    //
    // Date/Time (already delimited)
    //

    m_DateTimeCache.SetLocalTime(pSystemTime);
    cbTmp = m_DateTimeCache.GetFormattedDateTime(pSystemTime,rgchDateTime);

    nRequired += cbTmp;
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, rgchDateTime, cbTmp);
        pBuffer += cbTmp;
    }

    //
    // Site Name
    //

    pTmp = pLogObj->GetSiteName( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp + 2;  // 2 for delimiter
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';
    }

    //
    // ComputerName
    //

    pTmp = pLogObj->GetComputerName( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp + 2;  // 2 for delimiter
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';
    }

    //
    // Server IP
    //

    pTmp = pLogObj->GetServerAddress( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp + 2;  // 2 for delimiter
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';
    }

    //
    // Use fast path ?
    // All numbers are < 4G (10 charaters)
    // add 2 per number for delimiters
    // so we need 10 * 5 numbers == 30 bytes
    //

    nRequired += 10;    // 10 for delimiters of 5 numbers

    if ( (nRequired + 50) <= *pcbSize ) {

        //
        // Processing Time
        //

        cbTmp = FastDwToA( pBuffer, pLogObj->GetTimeForProcessing() );
        nRequired += cbTmp;
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';

        //
        // Bytes Received
        //

        cbTmp = FastDwToA( pBuffer, pLogObj->GetBytesRecvd() );
        nRequired += cbTmp;
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';

        //
        // Bytes Sent
        //

        cbTmp = FastDwToA( pBuffer, pLogObj->GetBytesSent() );
        nRequired += cbTmp;
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';

        //
        // HTTP Status
        //

        cbTmp = FastDwToA( pBuffer, pLogObj->GetProtocolStatus() );
        nRequired += cbTmp;
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';

        //
        // Win32 status
        //

        cbTmp = FastDwToA( pBuffer, pLogObj->GetWin32Status() );
        nRequired += cbTmp;
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';

    } else {

        FormatLogDwords( pLogObj, &pBuffer, pcbSize, &nRequired );
    }

    //
    // Operation
    //

    pTmp = pLogObj->GetOperation( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp + 2; // 2 for delimiter
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';
    }

    //
    // Target
    //

    pTmp = pLogObj->GetTarget( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp + 2; // 2 for delimiter
    if ( nRequired <= *pcbSize ) {
        ConvertSpacesToPlus(pTmp);
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        *(pBuffer++) = ',';
        *(pBuffer++) = ' ';
    }

    //
    // Parameters
    //

    pTmp = pLogObj->GetParameters( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp + 1 + 2; //  1 for delimiter, 2 for EOL
    if ( nRequired <= *pcbSize ) {
        ConvertSpacesToPlus(pTmp);
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
        
        // NOTE
        // Documentation is ambiguous about the presence of a comma
        // at the end of the log record, but the comma is required
        // for backward compatability with site server

        *(pBuffer++) = ',';
        *(pBuffer++) = '\r';
        *(pBuffer++) = '\n';
    }

    if ( nRequired > *pcbSize ) {
        *pcbSize = nRequired;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(FALSE);
    } else {
        *pcbSize = nRequired;
        return(TRUE);
    }
} // FormatLogBuffer

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

HRESULT
CASCLOG::ReadFileLogRecord(
    IN  FILE                *fpLogFile, 
    IN  LPINET_LOGLINE      pInetLogLine,
    IN  PCHAR               pszLogLine,
    IN  DWORD               dwLogLineSize
)
{

    CHAR * pszTimeZone;
    CHAR * pCh;
    CHAR * szDateString, * szTimeString;

getnewline:

    pCh = pszLogLine;
    
    fgets(pCh, dwLogLineSize, fpLogFile);

    if (feof(fpLogFile))
    {
        return E_FAIL;
    }

    pCh = SkipWhite(pCh);
        
    if (('\n' == *pCh) || ('\0' == *pCh))
    {
        // Empty line. Get Next line

        goto getnewline;
    }

    //
    // We have a log line. Parse it.
    //
    // Format is:
    // Host UserName Date Time Service ComputerName ServerIP
    //      msProcessingTime bytesR bytesS protocolStat Win32Stat
    //      Operation Target Parameters
    //
    
    if ( NULL == (pCh = strtok(pCh,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszClientHostName = pCh; 

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszClientUserName = pCh;

    //
    // Date & Time.
    //

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    szDateString = pCh;

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    szTimeString = pCh;
    
    if ( ! ConvertASCDateToVariantDate(szDateString, szTimeString, &(pInetLogLine->DateTime)) )
    {
        return E_FAIL;
    }

    //
    // Service & Server information
    //
    
    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszSiteName = pCh;

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszComputerName = pCh;

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszServerAddress = pCh;

    //
    // Statistics - processing time, bytes recvd, bytes sent
    //
    
    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszTimeForProcessing = pCh;

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszBytesRecvd = pCh;

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszBytesSent = pCh;

    //
    // Status information - protocol, Win32
    //
    
    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszProtocolStatus = pCh;

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszWin32Status = pCh;

    //
    // Request information - operation, target, parameters
    //

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszOperation = pCh;

    if ( NULL == (pCh = strtok(NULL,",")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszTarget = pCh;

    if ( NULL == (pCh = strtok(NULL," ,\t\r\n")) )
    {
        return E_FAIL;
    }
    while  (isspace((UCHAR)(*pCh))) pCh++;
    pInetLogLine->pszParameters = pCh;

    return S_OK;
}

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

HRESULT
CASCLOG::WriteFileLogRecord(
            IN  FILE            *fpLogFile, 
            IN  ILogScripting   *pILogScripting,
            IN  bool            fWriteHeader
        )
{

    HRESULT hr = E_FAIL;
    CHAR    szLogLine[4096];  
    DWORD   dwIndex = 0;

    //
    // Format is:
    // Host, UserName, Date, Time, Service, ComputerName, ServerIP,
    //      msProcessingTime, bytesR, bytesS, protocolStat, Win32Stat,
    //      Operation, Target, Parameters,
    //

    VARIANT    szHostName, szUserName, szServiceName, szComputerName;
    VARIANT    szServerIP, szOperation, szTarget, szParameters;
    VARIANT    DateTime;
    VARIANT    lTimeForProcessing, lBytesSent, lBytesRecvd, lProtocolStatus, lWin32Status;

    SYSTEMTIME  sysTime; 
    CHAR  rgchDateTime[ 32];


    if (SUCCEEDED(pILogScripting->get_ClientIP      ( &szHostName))         &&
        SUCCEEDED(pILogScripting->get_UserName      ( &szUserName))         &&   
        SUCCEEDED(pILogScripting->get_DateTime      ( &DateTime))           &&
        SUCCEEDED(pILogScripting->get_ServiceName   ( &szServiceName))      &&
        SUCCEEDED(pILogScripting->get_ServerName    ( &szComputerName))     &&
        SUCCEEDED(pILogScripting->get_ServerIP      ( &szServerIP))         &&
        SUCCEEDED(pILogScripting->get_TimeTaken     ( &lTimeForProcessing)) &&
        SUCCEEDED(pILogScripting->get_BytesReceived ( &lBytesRecvd))        &&
        SUCCEEDED(pILogScripting->get_BytesSent     ( &lBytesSent))         &&
        SUCCEEDED(pILogScripting->get_ProtocolStatus( &lProtocolStatus))    &&
        SUCCEEDED(pILogScripting->get_Win32Status   ( &lWin32Status))       &&
        SUCCEEDED(pILogScripting->get_Method        ( &szOperation))        &&
        SUCCEEDED(pILogScripting->get_URIStem       ( &szTarget))           &&
        SUCCEEDED(pILogScripting->get_URIQuery      ( &szParameters))       &&
        VariantTimeToSystemTime( DateTime.date, &sysTime)
        )
    {

        m_DateTimeCache.GetFormattedDateTime( &sysTime, rgchDateTime);

        dwIndex = sprintf(szLogLine, "%ws, %ws, %s%ws, %ws, %ws,", 
                            GetBstrFromVariant( &szHostName), 
                            GetBstrFromVariant( &szUserName), 
                            rgchDateTime, // This guy already contains a trailing ", "
                            GetBstrFromVariant( &szServiceName), 
                            GetBstrFromVariant( &szComputerName), 
                            GetBstrFromVariant( &szServerIP)
                        );

        szLogLine[dwIndex++] = ' ';
        dwIndex += GetLongFromVariant( &lTimeForProcessing, szLogLine+dwIndex) ;

        szLogLine[dwIndex++] = ',';
        szLogLine[dwIndex++] = ' ';
        dwIndex += GetLongFromVariant( &lBytesRecvd, szLogLine+dwIndex);
        
        szLogLine[dwIndex++] = ',';
        szLogLine[dwIndex++] = ' ';
        dwIndex += GetLongFromVariant( &lBytesSent, szLogLine+dwIndex);
 
        szLogLine[dwIndex++] = ',';
        szLogLine[dwIndex++] = ' ';
        dwIndex += GetLongFromVariant( &lProtocolStatus, szLogLine+dwIndex);
        
        szLogLine[dwIndex++] = ',';
        szLogLine[dwIndex++] = ' ';
        dwIndex += GetLongFromVariant( &lWin32Status, szLogLine+dwIndex);

        sprintf( szLogLine+dwIndex ,", %ws, %ws, %ws",
                    GetBstrFromVariant( &szOperation), 
                    GetBstrFromVariant( &szTarget), 
                    GetBstrFromVariant( &szParameters)
                );

        // Include a , at the end of the log record. See NOTE in
        // FormatLogBuffer for more details on why.

        fprintf(fpLogFile, "%s,\n", szLogLine);

        hr = S_OK;
    }

    return hr;
}

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

BOOL 
CASCLOG::ConvertASCDateToVariantDate(PCHAR szDateString, PCHAR szTimeString, DATE * pDateTime)
{
    USES_CONVERSION;

    BOOL    fSuccess = FALSE;
    HRESULT hr;
    LCID    lcid;

    BSTR bstrDate;
    BSTR bstrTime;

    DATE dateTime;
    DATE dateDate;
    
    DECIMAL decDate;
    DECIMAL decTime;
    DECIMAL decDateTimeComposite;
    
    bstrDate = SysAllocString(A2OLE(szDateString));
    bstrTime = SysAllocString(A2OLE(szTimeString));

    if ((NULL == bstrDate) ||
        (NULL == bstrTime))
    {
        goto error_converting;
    }       

    lcid = GetSystemDefaultLCID();

    hr = VarDateFromStr(bstrTime, lcid, LOCALE_NOUSEROVERRIDE, &dateTime);
    if (FAILED(hr))
    {
        goto error_converting;
    }

    hr = VarDateFromStr(bstrDate, lcid, LOCALE_NOUSEROVERRIDE, &dateDate);
    if (FAILED(hr))
    {
        goto error_converting;
    }

    hr = VarDecFromDate(dateDate, &decDate);
    if (FAILED(hr))
    {
        goto error_converting;
    }

    hr = VarDecFromDate(dateTime, &decTime);
    if (FAILED(hr))
    {
        goto error_converting;
    }

    hr = VarDecAdd(&decDate, &decTime, &decDateTimeComposite);
    if (FAILED(hr))
    {
        goto error_converting;
    }   

    hr = VarDateFromDec(&decDateTimeComposite, pDateTime);
    if (FAILED(hr))
    {
        goto error_converting;
    }
    fSuccess = TRUE;

error_converting:

    if (NULL != bstrDate)
    {
        SysFreeString(bstrDate);
        bstrDate = NULL;
    }

    if (NULL != bstrTime)
    {
        SysFreeString(bstrTime);
        bstrTime = NULL;
    }

    return fSuccess;
}

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by plugin.rc
//
#define IDS_DATE                        1001
#define IDS_TIME                        1002
#define IDS_CLIENT_IP_ADDRESS           1003
#define IDS_USER_NAME                   1004
#define IDS_SERVICE_NAME                1005
#define IDS_SERVER_NAME                 1006
#define IDS_SERVER_IP                   1007
#define IDS_SERVER_PORT                 1008
#define IDS_METHOD                      1009
#define IDS_URI_STEM                    1010
#define IDS_URI_QUERY                   1011
#define IDS_HTTP_STATUS                 1012
#define IDS_WIN32_STATUS                1013
#define IDS_BYTES_SENT                  1014
#define IDS_BYTES_RECEIVED              1015
#define IDS_TIME_TAKEN                  1016
#define IDS_PROTOCOL_VERSION            1017
#define IDS_USER_AGENT                  1018
#define IDS_COOKIE                      1019
#define IDS_REFERER                     1020
#define IDS_EXTENDED_PROP               1021
#define IDS_HOST                        1022

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        207
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         232
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\ncslogc.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      nsclogp.cpp

   Abstract:
      NCSA Logging Format implementation

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/


#include "precomp.hxx"
#include <stdio.h>
#include <script.h>
#include "LogScript.hxx"
#include <ilogobj.hxx>
#include "filectl.hxx"
#include "ncslogc.hxx"

CHAR    szNCSANoPeriodPattern[] = "ncsa*.log";

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

CNCSALOG::CNCSALOG()
{
    //
    // set the time zone offset
    //

    {
        TIME_ZONE_INFORMATION tzTimeZone;
        DWORD dwError;
        DWORD minutes;
        DWORD hours;
        LONG bias;
        CHAR szTmp[MAX_PATH];

        dwError = GetTimeZoneInformation(&tzTimeZone);

        if ( dwError == 0xffffffff ) {

            bias = 0;
        } else {

            bias = tzTimeZone.Bias;
        }

        if ( bias > 0 ) 
        {
            lstrcpyA(m_szGMTOffset,"-");
            m_GMTDateCorrection = -1;

        } 
        else 
        {
            lstrcpyA(m_szGMTOffset,"+");
            m_GMTDateCorrection = 1;
            bias *= -1;
        }

        hours = bias/60;
        minutes = bias % 60;

        //
        // set up the "+0800" or "-0800" NCSA information
        //

        wsprintfA(szTmp,"%02lu",hours);
        lstrcatA(m_szGMTOffset,szTmp);

        wsprintfA(szTmp,"%02lu",minutes);
        lstrcatA(m_szGMTOffset,szTmp);

        m_GMTDateCorrection = m_GMTDateCorrection * ( hours/24.0 + minutes/60.0 );

    }
} // CNCSALOG::CNCSALOG()

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

CNCSALOG::~CNCSALOG()
{
}

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

LPCSTR
CNCSALOG::QueryNoPeriodPattern(
    VOID
    )
{
    return szNCSANoPeriodPattern;
} // CNCSALOG::QueryNoPeriodPattern

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

VOID
CNCSALOG::FormNewLogFileName(
                IN LPSYSTEMTIME pstNow
                )
/*++
  This function that forms the new log file name based on
   type of periodic logging done.

  Arguments:
    pstNow     pointer to SystemTime which contains the current time.

  Returns:
    TRUE on success in forming the name or FALSE if there is any error.

--*/
{

    I_FormNewLogFileName(pstNow,DEFAULT_NCSA_LOG_FILE_NAME);
    return;

} // INET_FILE_LOG::FormNewLogFileName()

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

BOOL
CNCSALOG::FormatLogBuffer(
         IN IInetLogInformation *pLogObj,
         IN LPSTR                pBuf,
         IN DWORD                *pcbSize,
         OUT SYSTEMTIME          *pLocalTime
        )
{
    CHAR  rgchDateTime[32];
    PCHAR pBuffer = pBuf;
    DWORD nRequired = 0;

    PCHAR pTmp;
    DWORD cbTmp;
    BOOL  fUseBytesSent = TRUE;

    if ( pBuf == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // We use local time
    //

    GetLocalTime(pLocalTime);

    INT cchDateTime = wsprintf( rgchDateTime,
                        _T(" [%02d/%s/%d:%02d:%02d:%02d %s] "),
                        pLocalTime->wDay,
                        Month3CharNames(pLocalTime->wMonth-1),
                        pLocalTime->wYear,
                        pLocalTime->wHour,
                        pLocalTime->wMinute,
                        pLocalTime->wSecond,
                        m_szGMTOffset
                        );

    //
    // Format is:
    // Host - UserName [date] Operation Target status bytes
    //

    //
    // HostName
    //

    pTmp = pLogObj->GetClientHostName( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp;
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
    }

    //
    // Append " - "
    //

    cbTmp = 3;
    pTmp = " - ";

    nRequired += cbTmp;
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
    }

    //
    // append user name
    //

    pTmp = pLogObj->GetClientUserName( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp;
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
    }

    //
    // append date time
    //

    pTmp = rgchDateTime;
    cbTmp = cchDateTime;

    nRequired += cbTmp;
    if ( nRequired <= *pcbSize ) {
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
    }

    //
    // Operation
    //

    pTmp = pLogObj->GetOperation( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    } else {
        if ( (_stricmp(pTmp,"PUT") == 0) ||
             (_stricmp(pTmp,"POST") == 0) ) {
            fUseBytesSent = FALSE;
        }
    }

    nRequired += (cbTmp + 1 + 1);   // +1 for delimeter, +1 for \"
    if ( nRequired <= *pcbSize ) {

        *(pBuffer++) = '\"';
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;

        //
        // Add space delimiter
        //

        *(pBuffer++) = ' ';
    }

    //
    // Target
    //

    pTmp = pLogObj->GetTarget( NULL, &cbTmp );
    if ( cbTmp == 0 ) {
        cbTmp = 1;
        pTmp = "-";
    }

    nRequired += cbTmp;
    if ( nRequired <= *pcbSize ) {
        ConvertSpacesToPlus(pTmp);
        CopyMemory(pBuffer, pTmp, cbTmp);
        pBuffer += cbTmp;
    }

    //
    // Parameters
    //

    pTmp = pLogObj->GetParameters( NULL, &cbTmp );
    
    if ( cbTmp != 0 ) {

        nRequired += cbTmp + 1;     // 1 for ?
        if ( nRequired <= *pcbSize ) {
            ConvertSpacesToPlus(pTmp);
            *(pBuffer++) = '?';
            CopyMemory(pBuffer, pTmp, cbTmp);
            pBuffer += cbTmp;
        }
    }
    
    //
    // close request block version + status + bytes
    //

    {
        CHAR tmpBuf[MAX_PATH];
        DWORD bytes;

        PCHAR pVersion = pLogObj->GetVersionString(NULL, &cbTmp);

        if (cbTmp ==0) {
            pVersion = "HTTP/1.0";
            cbTmp    = 8;
        }

        nRequired += cbTmp + 1 + 1 + 1;   // 1 for beginning delimiter, 1 for ", 1 for ending delimiter
        
        if ( nRequired <= *pcbSize ) {
            *(pBuffer++) = ' ';
            CopyMemory(pBuffer, pVersion, cbTmp);
            pBuffer += cbTmp;
            *(pBuffer++) = '"';
            *(pBuffer++) = ' ';
        }
        
        cbTmp = FastDwToA(tmpBuf, pLogObj->GetProtocolStatus());
        *(tmpBuf+cbTmp) = ' ';
        cbTmp++;

        bytes = fUseBytesSent ? pLogObj->GetBytesSent( ) :
                                pLogObj->GetBytesRecvd( );
        cbTmp += FastDwToA( tmpBuf+cbTmp, bytes);

        *(tmpBuf+cbTmp)   = '\r';
        *(tmpBuf+cbTmp+1) = '\n';
        cbTmp += 2;

        nRequired += cbTmp;
        if ( nRequired <= *pcbSize ) {
            CopyMemory(pBuffer, tmpBuf, cbTmp);
            pBuffer += cbTmp;
        }
    }

    if ( nRequired > *pcbSize ) {
        *pcbSize = nRequired;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(FALSE);
    } else {
        *pcbSize = nRequired;
        return(TRUE);
    }
} // CNCSALOG::FormatLogBuffer

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

HRESULT 
CNCSALOG::ReadFileLogRecord(
    IN  FILE                *fpLogFile, 
    IN  LPINET_LOGLINE       pInetLogLine,
    IN  PCHAR                pszLogLine,
    IN  DWORD                dwLogLineSize
)
{
    CHAR * pszTimeZone;
    CHAR * pCh;

    CHAR * szDateString, * szTimeString;
    double GMTCorrection;
    int    iSign = 1;

getnewline:

    pCh = pszLogLine;
    
    fgets(pCh, dwLogLineSize, fpLogFile);

    if (feof(fpLogFile))
    {
        return E_FAIL;
    }

    pCh = SkipWhite(pCh);
    
    if (('\n' == *pCh) || ('\0' == *pCh))
    {
        // Empty line. Get Next line

        goto getnewline;
    }

    //
    // We have a log line. 
    //
    // Format is:
    // Host - UserName [date] Operation Target status bytes
    //

    if ( NULL == (pCh = strtok(pCh," \t\r\n")) )
    {
        return E_FAIL;
    }
    pInetLogLine->pszClientHostName = pCh; 

    //
    // This field is always "-"
    //
    if ( ( NULL == (pCh = strtok(NULL," \t\r\n")) )||
         ('-' != *pCh) )
    {
        return E_FAIL;
    }

    if ( NULL == (pCh = strtok(NULL," \t\r\n")) )
    {
        return E_FAIL;
    }
    pInetLogLine->pszClientUserName = pCh;

    //
    // This is the date field. It starts with a [, followed by date:time timezone]
    //

    pCh += strlen(pCh)+1;
    if (*pCh != '[') 
    {
        return E_FAIL;
    }
    pCh++;


    if ( NULL == (pCh = strtok(pCh,":")) )
    {
        return E_FAIL;
    }
    szDateString = pCh;
    

    if ( NULL == (pCh = strtok(NULL," \t\r\n")) )
    {
        return E_FAIL;
    }
    szTimeString = pCh;
    
    pCh = strtok(NULL," \t\r\n");
    if ( (NULL == pCh) || ( ']' != *(pCh+strlen(pCh)-1)) || (strlen(pCh) < 4))
    {
        return E_FAIL;
    }
    pszTimeZone = pCh;

    //
    // Time Zone is in format [+/-]HHMM. Convert this to GMT and DATE format
    //
    
    if ( ! ConvertNCSADateToVariantDate(szDateString, szTimeString, &(pInetLogLine->DateTime)) )
    {
        return E_FAIL;
    }

    if (*pCh == '-')
    {
        iSign = -1;
        pszTimeZone = pCh+1;
    }
    else if (*pCh == '+')
    {
        iSign = 1;
        pszTimeZone = pCh+1;
    }

    GMTCorrection = (pszTimeZone[0]-'0' +pszTimeZone[1]-'0')/24.0 + 
                    (pszTimeZone[2]-'0' +pszTimeZone[3]-'0')/60.0;

    pInetLogLine->DateTime -= iSign*GMTCorrection;

    //
    // The Query String. Starts with " followed by method target version"
    //

    pCh += strlen(pCh)+1;
    *(pCh-2)='\0';                      // Zero out the ] for the time zone
    if ('"' != *pCh) 
    {
        return E_FAIL;
    }

    pCh++;

    
    if ( NULL == (pCh = strtok(pCh," \t\r\n")) )
    {
        return E_FAIL;
    }
    pInetLogLine->pszOperation = pCh;

    if ( NULL == (pCh = strtok(NULL," \t\r\n")) )
    {
        return E_FAIL;
    }
    pInetLogLine->pszTarget = pCh;

    //
    // In the Target, Parameters are separated by ?
    //
    pInetLogLine->pszParameters = strchr(pCh, '?');

    if (pInetLogLine->pszParameters != NULL)
    {
        *(pInetLogLine->pszParameters)='\0';
        (pInetLogLine->pszParameters)++;
    }

    pCh = strtok(NULL," \t\r\n");
    if ( (NULL == pCh) || ('"' != *(pCh+strlen(pCh)-1)) )
    {
        return E_FAIL;
    }
    pInetLogLine->pszVersion = pCh;

    //
    // Now the status code & bytes sent
    //

    pCh += strlen(pCh)+1;
    *(pCh-2)='\0';                      // Zero out the " for the version string

    if ( NULL == (pCh = strtok(pCh," \t\r\n")) )
    {
        return E_FAIL;
    }
    pInetLogLine->pszProtocolStatus = pCh;
  
    if ( NULL == (pCh = strtok(NULL," \t\r\n")) )
    {
        return E_FAIL;
    }
    pInetLogLine->pszBytesSent = pCh;

    return S_OK;
}


// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

HRESULT
CNCSALOG::WriteFileLogRecord(
            IN  FILE            *fpLogFile, 
            IN  ILogScripting   *pILogScripting,
            IN  bool            fWriteHeader
        )
{

    HRESULT hr = E_FAIL;
    CHAR    szLogLine[4096];  
    DWORD   dwIndex = 0;

    //
    // Format is:
    // Host - UserName [date] Operation Target status bytes
    //

    VARIANT    szHostName, szUserName, szOperation, szTarget, szParameters, szProtocolVersion;
    VARIANT    DateTime;
    VARIANT    lBytesSent, lProtocolStatus;

    SYSTEMTIME  localTime; 
    CHAR  rgchDateTime[ 32];


    if (SUCCEEDED(pILogScripting->get_ClientIP      ( &szHostName))     &&
        SUCCEEDED(pILogScripting->get_UserName      ( &szUserName))     &&   
        SUCCEEDED(pILogScripting->get_DateTime      ( &DateTime))       &&
        SUCCEEDED(pILogScripting->get_Method        ( &szOperation))    &&
        SUCCEEDED(pILogScripting->get_URIStem       ( &szTarget))       &&
        SUCCEEDED(pILogScripting->get_URIQuery      ( &szParameters))   &&
        SUCCEEDED(pILogScripting->get_BytesSent     ( &lBytesSent))     &&
        SUCCEEDED(pILogScripting->get_ProtocolStatus( &lProtocolStatus))&&
        SUCCEEDED(pILogScripting->get_ProtocolVersion( &szProtocolVersion))&&
        VariantTimeToSystemTime( DateTime.date+m_GMTDateCorrection, &localTime)
        )
    {


        sprintf(szLogLine, "%ws - %ws [%02d/%s/%d:%02d:%02d:%02d %s] \"%ws %ws", 
                    GetBstrFromVariant( &szHostName), 
                    GetBstrFromVariant( &szUserName), 
                    localTime.wDay, 
                    Month3CharNames(localTime.wMonth-1), 
                    localTime.wYear, 
                    localTime.wHour, 
                    localTime.wMinute, 
                    localTime.wSecond,
                    m_szGMTOffset, 
                    GetBstrFromVariant( &szOperation), 
                    GetBstrFromVariant( &szTarget)
                );

        if ( ( VT_NULL != szParameters.vt) &&
             ( VT_EMPTY != szParameters.vt )
           )
        {
            sprintf(szLogLine+strlen(szLogLine), "?%ws", GetBstrFromVariant( &szParameters));
        }

        sprintf(szLogLine+strlen(szLogLine), " %ws\"", GetBstrFromVariant( &szProtocolVersion));

        dwIndex = strlen(szLogLine);

        szLogLine[dwIndex++] = ' ';
        dwIndex += GetLongFromVariant( &lProtocolStatus, szLogLine+dwIndex );

        szLogLine[dwIndex++] = ' ';
        dwIndex += GetLongFromVariant( &lBytesSent, szLogLine+dwIndex );
        szLogLine[dwIndex++] = '\0';

        fprintf(fpLogFile, "%s\n", szLogLine);

        hr = S_OK;
    }

    return hr;
}

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------

BOOL
CNCSALOG::ConvertNCSADateToVariantDate(PCHAR szDateString, PCHAR szTimeString, DATE * pDateTime)
{

    PCHAR   pCh;
    WORD    iVal;
    CHAR    *szMonths[12] = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};

    SYSTEMTIME  sysTime;

    //
    // Process the Date. Format is 23/Sep/1997 ( Day/Month/Year )
    //

    pCh = szDateString;
    
    iVal = *pCh -'0';
    if ( *(pCh+1) != '/')
    {
        iVal = iVal*10 + *(pCh+1) - '0';
        pCh++;
    }
    sysTime.wDay = iVal;

    pCh += 2;

    for (int i=0; i<12;i++)
    {
        if ( 0 == strncmp(pCh,szMonths[i],3) )
        {
            sysTime.wMonth = i+1;
            break;
        }
    }

    pCh += 4;

    sysTime.wYear = (*pCh-'0')*1000 + ( *(pCh+1)-'0' )*100 + 
                    ( *(pCh+2)-'0')*10 + ( *(pCh+3)-'0');

    //
    // Process the Time. Format is 10:47:44 ( HH:MM:SS )
    //

    pCh = szTimeString;

    iVal = *pCh -'0';
    if ( *(pCh+1) != ':')
    {
        iVal = iVal*10 + *(pCh+1) - '0';
        pCh++;
    }
    sysTime.wHour = iVal;
    
    pCh += 2;

    iVal = *pCh -'0';
    if ( *(pCh+1) != ':')
    {
        iVal = iVal*10 + *(pCh+1) - '0';
        pCh++;
    }
    sysTime.wMinute = iVal;

    pCh += 2;

    iVal = *pCh -'0';
    if ( *(pCh+1) != '\0')
    {
        iVal = iVal*10 + *(pCh+1) - '0';
    }
    sysTime.wSecond = iVal;

    return SystemTimeToVariantTime(&sysTime, pDateTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\iis51\odblogc.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      odblogc.cpp

   Abstract:
      NCSA Logging Format implementation

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

#include "precomp.hxx"
#include "odbcconn.hxx"
#include <ilogobj.hxx>
#include "odblogc.hxx"

/************************************************************
 *    Symbolic Constants and Data
 ************************************************************/

# define MAX_SQL_FIELD_NAMES_LEN       ( 400)
# define MAX_SQL_FIELD_VALUES_LEN      ( 200)
# define MAX_SQL_IDENTIFIER_QUOTE_CHAR ( 50)

# define PSZ_UNKNOWN_FIELD_W      _T("-")
# define PSZ_UNKNOWN_FIELD_A      _T("-")

# define PSZ_GET_ERROR_FAILED_A    _T("ODBC:GetLastError() Failed")
# define LEN_PSZ_GET_ERROR_FAILED_A  sizeof(PSZ_GET_ERROR_FAILED_A)

# define PSZ_GET_ERROR_FAILED_W    _T("ODBC:GetLastError() Failed")
# define LEN_PSZ_GET_ERROR_FAILED_W  sizeof(PSZ_GET_ERROR_FAILED_W)

//
//  The template of SQL command has 3 arguments.
//   1. table name
//   2. field names
//   3. field values
// 1,2 and 3 are obained  during the first wsprintf
//

static const CHAR  sg_rgchSqlInsertCmdTemplate[] =
    _T("insert into %s ( %s) values ( %s)");

# define PSZ_SQL_INSERT_CMD_TEMPLATE    (  sg_rgchSqlInsertCmdTemplate)
# define LEN_PSZ_SQL_INSERT_CMD_TEMPLATE  \
           ( lstrlen( PSZ_SQL_INSERT_CMD_TEMPLATE))

//
// Leave %ws so that we can print the service and server name when this
//   string is used to generate an SQL statement.
//
static const CHAR sg_rgchStdLogFieldValues[] =
   _T(" ?, ?, ?, '%s', '%s', ?, ?, ?, ?, ?, ?, ?, ?, ?");

# define PSZ_INTERNET_STD_LOG_FORMAT_FIELD_NAMES  ( sg_rgchStdLogFieldNames)
# define PSZ_INTERNET_STD_LOG_FORMAT_FIELD_VALUES ( sg_rgchStdLogFieldValues)


//
// AllFieldInfo()
//  Defines all the fields required for SQL logging of the information
//   to the database using ODBC interfaces.
//  C arrays are numbered from offset 0.
//  SQL columns are numbered from 1.
//  field index values start from 0 and we adjust it when we talk of SQL col.
//  FieldInfo( symbolic-name, field-name,
//             field-index/column-number,
//             field-C-type, field-Sql-type,
//             field-precision, field-max-size, field-cb-value)
//

# define StringField( symName, fldName, fldIndex, prec)  \
FieldInfo( symName, fldName, fldIndex, SQL_C_CHAR, SQL_CHAR, \
          (prec), (prec), SQL_NTS)

# define NumericField( symName, fldName, fldIndex)  \
FieldInfo( symName, fldName, fldIndex, SQL_C_LONG, SQL_INTEGER, \
           0, sizeof( DWORD), 0)

# define TimeStampField( symName, fldName, fldIndex) \
FieldInfo( symName, fldName, fldIndex, SQL_C_TIMESTAMP, SQL_TIMESTAMP, \
          0, sizeof( TIMESTAMP_STRUCT), 0)

//
// fields that have constant value. we are interested in names of such fields.
// they have negative field indexes.
// These fields need not be generated as parameter markers.
//  ( Since they are invariants during lifetime of an INET_SQL_LOG oject)
//  Hence the field values will go into the command generated.
// Left here as a documentation aid and field-generation purposes.
//
# define ConstantValueField( synName, fldName) \
FieldInfo( synName, fldName, -1,  SQL_C_CHAR, SQL_CHAR, 0, 0, SQL_NTS)

//
// Ideally the "username" field should have MAX_USER_NAME_LEN as max size.
//  However, Access 7.0 limits varchar() size to be 255 (8 bits) :-(
//  So, we limit the size to be the least of the two ...
//
// FieldNames used are reserved. They are same as the names distributed
//   in the template log file. Do not change them at free will.
//
//

# define AllFieldInfo() \
 StringField(        CLIENT_HOST,       _T("ClientHost"),     0,   255)    \
 StringField(        USER_NAME,         _T("username"),       1,   255)    \
 TimeStampField(     REQUEST_TIME,      _T("LogTime"),        2)          \
 ConstantValueField( SERVICE_NAME,      _T("service"))                    \
 ConstantValueField( SERVER_NAME,       _T("machine"))                    \
 StringField(        SERVER_IPADDR,     _T("serverip"),       3,   50)    \
 NumericField(       PROCESSING_TIME,   _T("processingtime"), 4)          \
 NumericField(       BYTES_RECVD,       _T("bytesrecvd"),     5)          \
 NumericField(       BYTES_SENT,        _T("bytessent"),      6)          \
 NumericField(       SERVICE_STATUS,    _T("servicestatus"),  7)          \
 NumericField(       WIN32_STATUS,      _T("win32status"),    8)          \
 StringField(        SERVICE_OPERATION, _T("operation"),      9,  255)    \
 StringField(        SERVICE_TARGET,    _T("target"),        10,  255)    \
 StringField(        SERVICE_PARAMS,    _T("parameters"),    11,  255)    \


/************************************************************
 *    Type Definitions
 ************************************************************/

//
// Define the FieldInfo macro to generate a list of enumerations for
//  the indexes to be used in the array of field parameters.
//


# define FieldInfo(symName, field, index, cType, sqlType, prec, maxSz, cbVal) \
        i ## symName = (index),

enum LOGGING_VALID_COLUMNS {


    // fields run from 0 through iMaxFields
    AllFieldInfo()

    iMaxFields
}; // enum LOGGING_VALID_COLUMNS


# undef FieldInfo


# define FieldInfo(symName, field, index, cType, sqlType, prec, maxSz, cbVal) \
        fi ## symName,

enum LOGGING_FIELD_INDEXES {

    fiMinFields = -1,

    // fields run from 0 through fiMaxFields
    AllFieldInfo()

    fiMaxFields
}; // enum LOGGING_FIELD_INDEXES


# undef FieldInfo


struct FIELD_INFO {

    int     iParam;
    CHAR  * pszName;
    SWORD   paramType;
    SWORD   cType;
    SWORD   sqlType;
    UDWORD  cbColPrecision;
    SWORD   ibScale;
    SDWORD  cbMaxSize;
    SDWORD  cbValue;
}; // struct FIELD_INFO


//
// Define the FieldInfo macro to generate a list of data to be generated
//   for entering the data values in an array for parameter information.
//  Note the terminating ',' used here.
//

# define FieldInfo(symName, field, index, cType, sqlType, prec, maxSz, cbVal) \
  { ((index) + 1), field, SQL_PARAM_INPUT, cType, sqlType,  \
    ( prec), 0, ( maxSz), ( cbVal) },

/*

   The array of Fields: sg_rgFields contain the field information
    for logging to SQL database for the log-record of
    the services. The values are defined using the macros FieldInfo()
    defined above.


   If there is any need to add/delete/modify the parameters bound,
    one should modify the above table "AllFieldInfo" macro.

*/

static FIELD_INFO  sg_rgFields[] = {

    AllFieldInfo()

      //
      // The above macro after expansion terminates with a comma.
      //  Add dummy entry to complete initialization of array.
      //

      { 0, _T("dummy"), SQL_PARAM_INPUT, 0, 0, 0, 0, 0, 0}
};


# undef FieldInfo

//
// tick minute.
//

#define TICK_MINUTE         (60 * 1000)


/************************************************************
 *    Functions
 ************************************************************/

BOOL
GenerateFieldNames(IN PODBC_CONNECTION poc,
                   OUT CHAR * pchFieldNames,
                   IN DWORD    cchFieldNames);

inline BOOL
IsEmptyStr( IN LPCSTR psz)
{  return ( psz == NULL || *psz == _T('\0')); }

BOOL
CODBCLOG::PrepareStatement( VOID)
/*++
  This command forms the template SQL command used for insertion
    of log records. Then it prepares the SQL command( for later execution)
    using ODBC_CONNECTION::PrepareStatement().

  It should always be called after locking the INET_SQL_LOG object.

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.

  Note:
     The template for insertion is:

     insert into <table name> ( field names ...) values (  ?, ?, ...)
                                                         ^^^^
                                             Field values go here

    Field names are generated on a per logging format basis.
--*/
{
    BOOL   fReturn = FALSE;
    CHAR  rgchFieldNames[ MAX_SQL_FIELD_NAMES_LEN];
    CHAR  rgchFieldValues[ MAX_SQL_FIELD_VALUES_LEN];


    //
    // Obtain field names and field values ( template) for various log formats.
    //  The order of field names should match the order of field values
    //  generated by FormatLogInformation() for the format specified.
    //

    rgchFieldNames[ 0] = rgchFieldValues[ 0] = _T('\0');

    DWORD cchFields;

    fReturn = GenerateFieldNames(m_poc,
                                 rgchFieldNames,
                                 MAX_SQL_FIELD_NAMES_LEN);

    if ( !fReturn) {

        //DBGPRINTF(( DBG_CONTEXT,
        //           " Unable to generate field names. Error = %d\n",
        //           GetLastError()));
        //break;
        return(fReturn);
    }

    cchFields = wsprintf( (CHAR *)rgchFieldValues,
                           PSZ_INTERNET_STD_LOG_FORMAT_FIELD_VALUES,
                           QueryServiceName(),
                           QueryServerName());

    fReturn = (fReturn && (cchFields < MAX_SQL_FIELD_VALUES_LEN));
    //DBG_ASSERT( cchFields <  MAX_SQL_FIELD_VALUES_LEN);

    fReturn = TRUE;

    if ( fReturn) {

        CHAR * pwszSqlCommand;
        DWORD   cchReqd;

        //
        //  The required number of chars include sql insert template command
        //   and field names and table name.
        //

        cchReqd = ( LEN_PSZ_SQL_INSERT_CMD_TEMPLATE +
                   strlen( m_rgchTableName) +
                   strlen( rgchFieldNames)  +
                   strlen( rgchFieldValues) + 20);

        pwszSqlCommand = ( CHAR *) LocalAlloc( LPTR, cchReqd * sizeof( CHAR));
        m_poStmt = m_poc->AllocStatement();

        if ( ( fReturn = ( pwszSqlCommand != NULL) && ( m_poStmt != NULL))) {

            DWORD cchUsed;

            cchUsed = wsprintf( pwszSqlCommand,
                                PSZ_SQL_INSERT_CMD_TEMPLATE,
                                m_rgchTableName,
                                rgchFieldNames,
                                rgchFieldValues);
            //DBG_ASSERT( cchUsed < cchReqd);

            //IF_DEBUG(INETLOG) {
            //    DBGPRINTF( ( DBG_CONTEXT,
            //                " Sqlcommand generated is: %ws.\n",
            //                pwszSqlCommand));
            //}

            fReturn = ((cchUsed < cchReqd) &&
                       m_poStmt->PrepareStatement( pwszSqlCommand)
                       );

            LocalFree( pwszSqlCommand);         // free allocated memory
        }

    } // valid field names and filed values.


    //IF_DEBUG( INETLOG) {
    //
    //    DBGPRINTF( ( DBG_CONTEXT,
    //                "%s::PrepareStatement() returns %d.",
    //                QueryClassIdString(), fReturn));
    //}

    return ( fReturn);
} // INET_SQL_LOG::PrepareStatement()


BOOL
CODBCLOG::PrepareParameters( VOID)
/*++
  This function creates an array of ODBC_PARAMETER objects used for binding
    parameters to an already prepared statement. These ODBC_PARAMETER objects
    are then used for insertion of data values into the table specified,
    through ODBC.

  This function should always be called after locking the object.

  Arguments:
     None

  Returns:
     TRUE on success and FALSE if there is any failure.
--*/
{
    BOOL fReturn = FALSE;
    PODBC_PARAMETER * prgParams = NULL;
    DWORD cParams = 0;
    DWORD nParamsSeen = 0;

    DWORD i;

    //DBG_ASSERT( m_poStmt != NULL && m_poStmt->IsValid()  &&
    //            m_ppParams == NULL && m_cOdbcParams == 0);

    //
    // create sufficient space for iMaxFields pointers to ODBC objects.
    //
    prgParams = new PODBC_PARAMETER[ iMaxFields];


    if ( prgParams != NULL) {

        fReturn = TRUE;      // Assume everything will go on fine.
        cParams = iMaxFields;


        //
        // Create all the ODBC parameters.
        //  Walk through all field indexes and pick up the valid columns
        //
        for( nParamsSeen = 0, i =0; i < fiMaxFields; i++) {

            if ( sg_rgFields[i].iParam > 0) {

                WORD colNum = (WORD ) sg_rgFields[i].iParam;

                prgParams[nParamsSeen] =
                  new ODBC_PARAMETER(colNum,
                                     sg_rgFields[i].paramType,
                                     sg_rgFields[i].cType,
                                     sg_rgFields[i].sqlType,
                                     sg_rgFields[i].cbColPrecision
                                     );

                if ( prgParams[ nParamsSeen] == NULL) {

                    fReturn = FALSE;
                    //DBGPRINTF( ( DBG_CONTEXT,
                    //            " Failed to create Parameter[%d] %s. \n",
                    //            i, sg_rgFields[i].pszName));
                    break;
                }

                nParamsSeen++;
                //DBG_ASSERT( nParamsSeen <= cParams);
            }
        } // for creation of all ODBC parameters


        if ( fReturn) {
            //
            // Set buffers for values to be received during insertions.
            // Bind parameters to the statement using ODBC_CONNECTION object.
            //

            //DBG_ASSERT( nParamsSeen == cParams);

            for( nParamsSeen = 0, i = 0; i < fiMaxFields; i++) {

                if ( sg_rgFields[i].iParam > 0) {

                    if (!prgParams[nParamsSeen]->
                        SetValueBuffer(sg_rgFields[i].cbMaxSize,
                                       sg_rgFields[i].cbValue) ||
                        !m_poStmt->BindParameter( prgParams[nParamsSeen])
                        ) {

                        fReturn = FALSE;
                        //DBGPRINTF( ( DBG_CONTEXT,
                        //            " Binding Parameter [%u] (%08x) failed.\n",
                        //            nParamsSeen, prgParams[nParamsSeen]));
                        //DBG_CODE( prgParams[ i]->Print());
                        break;
                    }

                    nParamsSeen++;
                }
            } // for
        } // if all ODBC params were created.

        if ( !fReturn) {

            //
            // Free up the space used, since we were unsuccessful.
            //

            for( i = 0; i < iMaxFields; i++) {

                if ( prgParams[ i] != NULL) {

                    delete ( prgParams[ i]);
                    prgParams[i] = NULL;
                }
            } // for

            delete [] prgParams;
            prgParams = NULL;
            cParams = 0;
        }

    } // if array for pointers to ODBC params created successfully

    //
    // Set the values. Either invalid or valid ,depending on failure/success
    //
    m_ppParams    = prgParams;
    m_cOdbcParams = cParams;

    return ( fReturn);
} // INET_SQL_LOG::PrepareParameters()


BOOL
GenerateFieldNames(IN PODBC_CONNECTION poc,
                   OUT CHAR * pchFieldNames,
                   IN DWORD    cchFieldNames)
/*++
  This function generates the field names string from the names of the fields
   and identifier quote character for particular ODBC datasource in use.
--*/
{
    BOOL  fReturn = FALSE;
    CHAR  rgchQuote[MAX_SQL_IDENTIFIER_QUOTE_CHAR];
    DWORD cchQuote;

    //DBG_ASSERT( poc != NULL && pchFieldNames != NULL);

    pchFieldNames[0] = _T('\0');  // initialize

    //
    // Inquire and obtain the SQL identifier quote char for ODBC data source.
    //
    fReturn = poc->GetInfo(SQL_IDENTIFIER_QUOTE_CHAR,
                             rgchQuote, MAX_SQL_IDENTIFIER_QUOTE_CHAR,
                             &cchQuote);

    if ( !fReturn) {

        //DBG_CODE( {
        //    STR strError;
        //
        //    poc->GetLastErrorText( &strError);
        //
        //    DBGPRINTF(( DBG_CONTEXT,
        //           " ODBC_CONNECTION(%08x)::GetInfo(QuoteChar) failed."
        //               " Error = %s\n",
        //               poc, strError.QueryStr()));
        //});

    } else {

        DWORD i;
        DWORD cchUsed = 0;
        DWORD cchLen;

        //
        // ODBC returns " "  (blank) if there is no special character
        //  for quoting identifiers. we need to identify and string the same.
        // This needs to be done, other wise ODBC will complain when
        //  we give unwanted blanks before ","
        //

        if ( !strcmp( rgchQuote, _T(" "))) {

            rgchQuote[0] = _T('\0');  // string the quoted blank.
            cchQuote     = 0;
        } else {

            cchQuote = strlen( rgchQuote);
        }

        // for each column, generate the quoted literal string and concatenate.
        for( i = 0; i < fiMaxFields; i++) {

            DWORD cchLen1 =
              (strlen(sg_rgFields[i].pszName) + 2 * cchQuote + 2);

            if ( cchUsed + cchLen1 < cchFieldNames) {

                // space available for copying the data.
                cchLen = wsprintf( pchFieldNames + cchUsed,
                                   _T(" %s%s%s,"),
                                   rgchQuote,
                                   sg_rgFields[i].pszName,
                                   rgchQuote
                                   );

                //DBG_ASSERT( cchLen == cchLen1);
            }

            cchUsed += cchLen1;
        } // for


        if ( cchUsed >= cchFieldNames) {

            // buffer exceeded. return error.
            SetLastError( ERROR_INSUFFICIENT_BUFFER);
            fReturn = FALSE;

        } else {

            //
            // Reset the last character from being a ","
            //
            cchLen = (cchUsed > 0) ? (cchUsed - 1) : 0;
            pchFieldNames[cchLen] = _T('\0');
            fReturn = TRUE;
        }
    }

    //IF_DEBUG( INETLOG) {
    //
    //    DBGPRINTF(( DBG_CONTEXT,
    //               " GenerateFieldNames() returns %d."
    //               " Fields = %S\n",
    //               fReturn, pchFieldNames));
    //}

    return (fReturn);
} // GenerateFieldNames()


CODBCLOG::CODBCLOG()
{

    INITIALIZE_CRITICAL_SECTION( &m_csLock);

    m_poc               = NULL;
    m_poStmt            = NULL;
    m_ppParams          = NULL;
    m_fEnableEventLog   = true;

    m_TickResumeOpen    = GetTickCount() + TICK_MINUTE;
}


/////////////////////////////////////////////////////////////////////////////
// CODBCLOG::~CODBCLOG - Destructor

CODBCLOG::~CODBCLOG()
{
    TerminateLog( );
    DeleteCriticalSection( &m_csLock);
}


STDMETHODIMP
CODBCLOG::InitializeLog(
            LPCSTR pszInstanceName,
            LPCSTR pszMetabasePath,
            CHAR* pvIMDCOM )
{
    DWORD dwError = 0L;

    // load ODBC entry point
    LoadODBC();

    // get the default parameters

    DWORD   dwL = sizeof(m_rgchServerName);
    
    if ( !GetComputerName( m_rgchServerName, &dwL ) ) 
    {
        m_rgchServerName[0] = '\0';
    }

    strcpy( m_rgchServiceName, pszInstanceName);
    m_pvIMDCOM = (LPVOID)pvIMDCOM;

    if ( GetRegParameters( pszMetabasePath, pvIMDCOM ) == NO_ERROR )
    {

        // open database
        if ( m_poc == NULL )
        {
            Lock();

            m_poc = new ODBC_CONNECTION();

            if ( m_poc == NULL )
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
            } else
            {
                if ( !m_poc->Open( m_rgchDataSource, m_rgchUserName, m_rgchPassword ) ||
                     !PrepareStatement() ||
                     !PrepareParameters() )
                {
                    dwError = GetLastError();
                }

            }
            Unlock();
        }
    }

    return(dwError);
}

STDMETHODIMP
CODBCLOG::LogInformation(
        IInetLogInformation * ppvDataObj
        )
{
    DWORD       dwError   = ERROR_SUCCESS;
    BOOL        fReturn;
    SYSTEMTIME  stNow;

    STR         strClientHostName;
    STR         strClientUserName;
    STR         strServerIpAddress;
    STR         strOperation;
    STR         strTarget;
    STR         strParameters;

    PCHAR       pTmp;
    DWORD       cbSize;
    DWORD       dwBytesSent;
    DWORD       dwBytesRecvd;
    DWORD       dwProtocolStatus;
    DWORD       dwWin32Status;
    DWORD       dwTimeForProcessing;


    if (!( 
            m_poc != NULL && m_poc->IsValid() &&
            m_poStmt != NULL && m_poStmt->IsValid() &&
            m_ppParams != NULL 
       ))
    {
        //
        // Check if it is time to retry
        //
        
        DWORD tickCount = GetTickCount( );

        if ( (tickCount < m_TickResumeOpen) ||
             ((tickCount + TICK_MINUTE) < tickCount ) )  // The Tick counter is about to wrap.
        {
            return ERROR_INVALID_PARAMETER;
        }
    } 
   
    dwBytesSent = ppvDataObj->GetBytesSent( );
    dwBytesRecvd = ppvDataObj->GetBytesRecvd( );

    dwTimeForProcessing = ppvDataObj->GetTimeForProcessing( );
    dwWin32Status = ppvDataObj->GetWin32Status( );
    dwProtocolStatus = ppvDataObj->GetProtocolStatus( );

    pTmp = ppvDataObj->GetClientHostName( NULL, &cbSize);
    if ( cbSize == 0 ) {
        pTmp = "";
    }
    strClientHostName.Copy(pTmp);

    pTmp = ppvDataObj->GetClientUserName( NULL, &cbSize);
    if ( cbSize == 0 ) {
        pTmp = "";
    }
    strClientUserName.Copy(pTmp);

    pTmp = ppvDataObj->GetServerAddress( NULL, &cbSize);
    if ( cbSize == 0 ) {
        pTmp = "";
    }
    strServerIpAddress.Copy(pTmp);

    pTmp = ppvDataObj->GetOperation( NULL, &cbSize);
    if ( cbSize == 0 ) {
        pTmp = "";
    }
    strOperation.Copy(pTmp);

    pTmp = ppvDataObj->GetTarget( NULL, &cbSize);
    if ( cbSize == 0 ) {
        pTmp = "";
    }
    strTarget.Copy(pTmp);

    pTmp = ppvDataObj->GetParameters( NULL, &cbSize);
    if ( cbSize == 0 ) {
        pTmp = "";
    }
    strParameters.Copy(pTmp);

    LPCSTR     pszUserName  = strClientUserName.QueryStr();
    LPCSTR     pszOperation = strOperation.QueryStr();
    LPCSTR     pszTarget    = strTarget.QueryStr();
    LPCSTR     pszParameters= strParameters.QueryStr();
    LPCSTR     pszServerAddr= strServerIpAddress.QueryStr();
    
    SDWORD     cbParameters;
    SDWORD     cbTarget;
    
    cbParameters = strlen( pszParameters ? pszParameters : "" ) + 1;
    cbTarget     = strlen( pszTarget ? pszTarget : "" ) + 1;

    //
    //  Format the Date and Time for logging.
    //

    GetLocalTime( & stNow);

    if ( IsEmptyStr(pszUserName)) { pszUserName = QueryDefaultUserName();}
    if ( IsEmptyStr(pszOperation))  { pszOperation = PSZ_UNKNOWN_FIELD_A; }
    if ( IsEmptyStr(pszParameters)) { pszParameters= PSZ_UNKNOWN_FIELD_A; }
    if ( IsEmptyStr(pszTarget))     { pszTarget    = PSZ_UNKNOWN_FIELD_A; }
    if ( IsEmptyStr(pszServerAddr)) { pszServerAddr= PSZ_UNKNOWN_FIELD_A; }

    Lock();

    //
    // Reopen if necessary.
    //

    if (!(
            m_poc != NULL && m_poc->IsValid() &&
            m_poStmt != NULL && m_poStmt->IsValid() &&
            m_ppParams != NULL 
       ))
    {
        
        TerminateLog();
        
        m_TickResumeOpen =  GetTickCount( ) + TICK_MINUTE;

        m_poc = new ODBC_CONNECTION();

        if ( m_poc == NULL )
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        } 
        else
        {
            //
            // Try to open a new connection but don't log the failure in the eventlog
            //
                
            if ( !m_poc->Open( m_rgchDataSource, m_rgchUserName, m_rgchPassword, FALSE) ||
                 !PrepareStatement() ||
                 !PrepareParameters() )
            {
                dwError = GetLastError();

                if ( ERROR_SUCCESS == dwError)
                {
                    //
                    // Last Error wasn't set correctly
                    //

                    dwError = ERROR_GEN_FAILURE;
                }
            }
        }
        
        if ( ERROR_SUCCESS != dwError )
        {
            Unlock();
            return dwError;
        }
    }

    DBG_ASSERT(m_poc != NULL && m_poc->IsValid());
    DBG_ASSERT(m_poStmt != NULL && m_poStmt->IsValid());
    DBG_ASSERT(m_ppParams != NULL );

    //
    //  Truncate the parameters and target fields
    //

    if ( cbTarget > m_ppParams[ iSERVICE_TARGET]->QueryMaxCbValue() )
    {
        strTarget.SetLen(m_ppParams[ iSERVICE_TARGET]->QueryMaxCbValue()-1);
    }
    
    if ( cbParameters > m_ppParams[ iSERVICE_PARAMS]->QueryMaxCbValue() )
    {
        strParameters.SetLen(m_ppParams[ iSERVICE_PARAMS]->QueryMaxCbValue()-1);
    }

    //
    // Copy data values into parameter markers.
    // NYI: LARGE_INTEGERS are ignored. Only lowBytes used!
    //

    fReturn =
      (
        m_ppParams[ iCLIENT_HOST]->
          CopyValue( strClientHostName.QueryStr()) &&
        m_ppParams[ iUSER_NAME]->CopyValue( pszUserName) &&
        m_ppParams[ iREQUEST_TIME]->CopyValue( &stNow) &&
        m_ppParams[ iSERVER_IPADDR]->CopyValue( pszServerAddr) &&
        m_ppParams[ iPROCESSING_TIME]->
          CopyValue( dwTimeForProcessing) &&
        m_ppParams[ iBYTES_RECVD]->
          CopyValue( dwBytesRecvd) &&
        m_ppParams[ iBYTES_SENT]->
          CopyValue( dwBytesSent) &&
        m_ppParams[ iSERVICE_STATUS]->
          CopyValue( dwProtocolStatus) &&
        m_ppParams[ iWIN32_STATUS]->CopyValue( dwWin32Status) &&
        m_ppParams[ iSERVICE_OPERATION]->CopyValue( pszOperation)  &&
        m_ppParams[ iSERVICE_TARGET]->CopyValue( pszTarget)     &&
        m_ppParams[ iSERVICE_PARAMS]->CopyValue( pszParameters)
       );

    //
    // Execute insertion if parameters got copied properly.
    //

    if (fReturn)
    {
        fReturn = m_poStmt->ExecuteStatement(); 
    }

    Unlock();

    if ( !fReturn )
    {

        //
        // Execution of SQL statement failed.
        // Pass the error as genuine failure, indicating ODBC failed
        // Obtain and store the error string in the proper return field
        //

        TerminateLog();
        
        dwError = ERROR_GEN_FAILURE;

        if ( true == m_fEnableEventLog )
        {
            //
            // We have not written an event log before. Indicate error
            //

            if ( g_eventLog != NULL ) 
            {
                const CHAR*    tmpString[1];

                tmpString[0] = m_rgchDataSource;
                
                g_eventLog->LogEvent(
                     LOG_EVENT_ODBC_LOGGING_ERROR,
                     1,
                     tmpString,
                     GetLastError()
                     );
            }

            Lock();
            
            m_fEnableEventLog = false;
            m_TickResumeOpen  = GetTickCount() + TICK_MINUTE;

            Unlock();
        }
    }
    else
    {
        //
        // Success. Re-enable event logging
        //

        if (false == m_fEnableEventLog) 
        {

            if ( g_eventLog != NULL )
            {
                const CHAR*    tmpString[1];

                tmpString[0] = m_rgchDataSource;
                
                g_eventLog->LogEvent(
                    LOG_EVENT_ODBC_LOGGING_RESUMED,
                    1,
                    tmpString
                    );
            }
            
            m_fEnableEventLog = true;
        }        
    }

    return(dwError);
}

STDMETHODIMP
CODBCLOG::TerminateLog()
{
    DWORD dwError = NO_ERROR;

    Lock();
    if (m_poStmt != NULL )
    {
        delete m_poStmt;
        m_poStmt = NULL;
    }

    if (m_poc!= NULL)
    {
        if (!m_poc->Close())
        {
            dwError = GetLastError();
        }

        delete m_poc;
        m_poc=NULL;
    }

    if (m_ppParams!=NULL)
    {
        DWORD i;

        for (i=0;i<m_cOdbcParams;i++)
        {
            if (m_ppParams[i]!=NULL)
            {
                delete m_ppParams[i];
                m_ppParams[i]=NULL;
            }
        }

        delete []m_ppParams;
        m_ppParams = NULL;
        m_cOdbcParams=0;
    }

    Unlock();

    return(dwError);
}

STDMETHODIMP
CODBCLOG::SetConfig(
                        DWORD cbSize,
                        BYTE * log)
{
    return(0L);
}

STDMETHODIMP
CODBCLOG::GetConfig(
                        DWORD cbSize,
                        BYTE * log)
{
    PINETLOG_CONFIGURATIONA pLogConfig = (PINETLOG_CONFIGURATIONA)log;
    pLogConfig->inetLogType = INET_LOG_TO_SQL;
    strcpy( pLogConfig->u.logSql.rgchDataSource, m_rgchDataSource);
    strcpy( pLogConfig->u.logSql.rgchTableName, m_rgchTableName);
    strcpy( pLogConfig->u.logSql.rgchUserName, m_rgchUserName);
    strcpy( pLogConfig->u.logSql.rgchPassword, m_rgchPassword);
    return(0L);
}

DWORD
CODBCLOG::GetRegParameters(
                    LPCSTR pszRegKey,
                    LPVOID pvIMDCOM )
{
    DWORD err = NO_ERROR;
    do
    {
        MB      mb( (IMDCOM*) pvIMDCOM );
        DWORD   cb;

        if ( !mb.Open("") )
        {
            err = GetLastError();
            break;
        }

        cb = sizeof(m_rgchDataSource);
        if ( !mb.GetString( pszRegKey, MD_LOGSQL_DATA_SOURCES, IIS_MD_UT_SERVER, m_rgchDataSource, &cb ) )
        {
            strcpy(m_rgchDataSource,DEFAULT_LOG_SQL_DATASOURCE);
        }

        cb = sizeof(m_rgchTableName);
        if ( !mb.GetString( pszRegKey, MD_LOGSQL_TABLE_NAME, IIS_MD_UT_SERVER, m_rgchTableName, &cb ) )
        {
            strcpy(m_rgchTableName,DEFAULT_LOG_SQL_TABLE);
        }

        cb = sizeof(m_rgchUserName);
        if ( !mb.GetString( pszRegKey, MD_LOGSQL_USER_NAME, IIS_MD_UT_SERVER, m_rgchUserName, &cb ) )
        {
            strcpy(m_rgchUserName,DEFAULT_LOG_SQL_USER_NAME);
        }

        cb = sizeof(m_rgchPassword);
        if ( !mb.GetString( pszRegKey, MD_LOGSQL_PASSWORD, IIS_MD_UT_SERVER, m_rgchPassword, &cb, METADATA_INHERIT|METADATA_SECURE ) )
        {
            strcpy(m_rgchPassword,DEFAULT_LOG_SQL_PASSWORD);
        }

    } while (FALSE);
    return(err);
}

STDMETHODIMP
CODBCLOG::QueryExtraLoggingFields(
                    PDWORD  pcbSize,
                    TCHAR *pszFieldsList
                    )
/*++

Routine Description:
    get configuration information

Arguments:
    cbSize - size of the data structure
    log - log configuration data structure

Return Value:

--*/
{
    *pcbSize = 0;
    *pszFieldsList = '\0';
    return(0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\ppages\asclogp.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      asclogp.cpp

   Abstract:
      MS Logging Format implementation

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

// MSASCIILogPpg.cpp : Implementation of the CMSASCIILogPropPage property page class.

#include "stdafx.h"
#include "ASCLogP.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CMSASCIILogPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMSASCIILogPropPage, COlePropertyPage)
        //{{AFX_MSG_MAP(CMSASCIILogPropPage)
        // NOTE - ClassWizard will add and remove message map entries
        //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMSASCIILogPropPage, "MSIISLOG.MSASCIILogPropPage.1",
        0xff160658, 0xde82, 0x11cf, 0xbc, 0xa, 0, 0xaa, 0, 0x61, 0x11, 0xe0)


/////////////////////////////////////////////////////////////////////////////
// CMSASCIILogPropPage::CMSASCIILogPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CMSASCIILogPropPage

BOOL CMSASCIILogPropPage::CMSASCIILogPropPageFactory::UpdateRegistry(BOOL bRegister)
{
        if (bRegister)
                return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
                        m_clsid, IDS_MSASCIILOG_PPG);
        else
                return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CMSASCIILogPropPage::CMSASCIILogPropPage - Constructor

CMSASCIILogPropPage::CMSASCIILogPropPage() :
        COlePropertyPage(IDD, IDS_MSASCIILOG_PPG_CAPTION)
{
        //{{AFX_DATA_INIT(CMSASCIILogPropPage)
        m_strLogFileDirectory = _T("");
        m_dwSizeForTruncate = 0;
        //}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CMSASCIILogPropPage::DoDataExchange - Moves data between page and properties

void CMSASCIILogPropPage::DoDataExchange(CDataExchange* pDX)
{
        //{{AFX_DATA_MAP(CMSASCIILogPropPage)
        DDP_Text(pDX, IDC_FILE_DIRECTORY, m_strLogFileDirectory, _T("LogFileDirectory") );
        DDX_Text(pDX, IDC_FILE_DIRECTORY, m_strLogFileDirectory);
        DDP_Text(pDX, IDC_SIZE_CONTROL, m_dwSizeForTruncate, _T("SizeForTruncate") );
        DDX_Text(pDX, IDC_SIZE_CONTROL, m_dwSizeForTruncate);
        //}}AFX_DATA_MAP
        DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CMSASCIILogPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\ppages\asclogp.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      asclogp.h

   Abstract:
      MS Logging Format header file

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:
   
       IIS Logging 3.0

--*/

#ifndef _ASCLOGP_H_
#define _ASCLOGP_H_

// MSASCIILogPpg.h : Declaration of the CMSASCIILogPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CMSASCIILogPropPage : See MSASCIILogPpg.cpp.cpp for implementation.

class CMSASCIILogPropPage : public COlePropertyPage
{
        DECLARE_DYNCREATE(CMSASCIILogPropPage)
        DECLARE_OLECREATE_EX(CMSASCIILogPropPage)

// Constructor
public:
        CMSASCIILogPropPage();

// Dialog Data
        //{{AFX_DATA(CMSASCIILogPropPage)
        enum { IDD = IDD_PROPPAGE_MSASCIILOG };
        CString m_strLogFileDirectory;
        DWORD   m_dwSizeForTruncate;
        //}}AFX_DATA

// Implementation
protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
        //{{AFX_MSG(CMSASCIILogPropPage)
                // NOTE - ClassWizard will add and remove member functions here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};  // CMSASCIILogPropPage

#endif  // _ASCLOGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\ppages\cuslogp.cpp ===
// MSCustomLogPpg.cpp : Implementation of the CMSCustomLogPropPage property page class.

#include "stdafx.h"
#include "cusLogP.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CMSCustomLogPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMSCustomLogPropPage, COlePropertyPage)
        //{{AFX_MSG_MAP(CMSCustomLogPropPage)
        // NOTE - ClassWizard will add and remove message map entries
        //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMSCustomLogPropPage, "MSIISLOG.MSCustomLog.1",
        0xff160664, 0xde82, 0x11cf, 0xbc, 0xa, 0, 0xaa, 0, 0x61, 0x11, 0xe0)


/////////////////////////////////////////////////////////////////////////////
// CMSCustomLogPropPage::CMSCustomLogPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CMSCustomLogPropPage

BOOL CMSCustomLogPropPage::CMSCustomLogPropPageFactory::UpdateRegistry(BOOL bRegister)
{
        if (bRegister)
                return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
                        m_clsid, IDS_MSCustomLOG_PPG);
        else
                return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CMSCustomLogPropPage::CMSCustomLogPropPage - Constructor

CMSCustomLogPropPage::CMSCustomLogPropPage() :
        COlePropertyPage(IDD, IDS_MSCustomLOG_PPG_CAPTION)
{
        //{{AFX_DATA_INIT(CMSCustomLogPropPage)
        // NOTE: ClassWizard will add member initialization here
        //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CMSCustomLogPropPage::DoDataExchange - Moves data between page and properties

void CMSCustomLogPropPage::DoDataExchange(CDataExchange* pDX)
{
        //{{AFX_DATA_MAP(CMSCustomLogPropPage)
        // NOTE: ClassWizard will add DDP, DDX, and DDV calls here
        //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA_MAP
        DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CMSCustomLogPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\ppages\cuslogp.h ===
#ifndef _CUSLOGP_H_
#define _CUSLOGP_H_

// MSCustomLogPpg.h : Declaration of the CMSCustomLogPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CMSCustomLogPropPage : See MSCustomLogPpg.cpp.cpp for implementation.

class CMSCustomLogPropPage : public COlePropertyPage
{
        DECLARE_DYNCREATE(CMSCustomLogPropPage)
        DECLARE_OLECREATE_EX(CMSCustomLogPropPage)

// Constructor
public:
        CMSCustomLogPropPage();

// Dialog Data
        //{{AFX_DATA(CMSCustomLogPropPage)
        enum { IDD = IDD_PROPPAGE_MSCustomLOG };
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA

// Implementation
protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
        //{{AFX_MSG(CMSCustomLogPropPage)
                // NOTE - ClassWizard will add and remove member functions here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

};

#endif  // _CUSLOGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\plugin1.cpp ===
#include "precomp.hxx"
#include <stdio.h>
#include <script.h>
#include "LogScript.hxx"
#include <ilogobj.hxx>
#include "filectl.hxx"
#include "asclogc.hxx"
#include "ncslogc.hxx"
#include "lkrhash.h"
#include "extlogc.hxx"
#include "odbcconn.hxx"
#include "odblogc.hxx"

#include <initguid.h>
#include <iadmw.h>

#include "resource.h"

HINSTANCE   hDLLInstance;

BOOL
AddClsIdRegKeys(
    IN LPCSTR ControlKey,
    IN LPCSTR ClsId,
    IN LPCSTR ControlName,
    IN LPCSTR PPageClsId,
    IN LPCSTR PPageName,
    IN LPCSTR BitmapIndex
    );

BOOL
AddControlRegKeys(
    IN LPCSTR ControlKey,
    IN LPCSTR ControlName,
    IN LPCSTR ClsId,
    IN LPCSTR PPageClsId,
    IN LPCSTR PPageName,
    IN LPCSTR BitmapIndex
    );

VOID
DynUnloadODBC(
    VOID
    );

BOOL
CreateMetabaseKeys();

HRESULT SetAdminACL(
    IMSAdminBase        *pAdminBase,
    METADATA_HANDLE     hMeta,
    LPWSTR              wszKeyName 
    );

DWORD
GetPrincipalSID (
    LPTSTR              Principal,
    PSID                *Sid,
    BOOL                *pbWellKnownSID
    );

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_NCSALOG, CNCSALOG)
        OBJECT_ENTRY(CLSID_ODBCLOG, CODBCLOG)
        OBJECT_ENTRY(CLSID_EXTLOG, CEXTLOG)
        OBJECT_ENTRY(CLSID_ASCLOG, CASCLOG)
END_OBJECT_MAP()

#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisPlugInGuid, 
0x784d890F, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();
#endif
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

extern "C" {

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    );
}

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    )
/*++

Routine Description:

    DLL entrypoint.

Arguments:

    hDLL          - Instance handle.

    Reason        - The reason the entrypoint was called.
                    DLL_PROCESS_ATTACH
                    DLL_PROCESS_DETACH
                    DLL_THREAD_ATTACH
                    DLL_THREAD_DETACH

    Reserved      - Reserved.

Return Value:

    BOOL          - TRUE if the action succeeds.

--*/
{
    hDLLInstance = hDll;

    BOOL bReturn = TRUE;

    switch ( dwReason ) {

    case DLL_PROCESS_ATTACH:
        INITIALIZE_PLATFORM_TYPE();
#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT("iislog.dll");
        SET_DEBUG_FLAGS(DEBUG_ERROR);
#else
        CREATE_DEBUG_PRINT_OBJECT("iislog.dll", IisPlugInGuid);
#endif
        _Module.Init(ObjectMap,hDll);
        g_eventLog = new EVENT_LOG(IISLOG_EVENTLOG_SOURCE);

        if ( g_eventLog == NULL ) {
            DBGPRINTF((DBG_CONTEXT,
                "Unable to create eventlog[%s] object[err %d]\n",
                IISLOG_EVENTLOG_SOURCE, GetLastError()));
        }

        (VOID)IISGetPlatformType();

        DisableThreadLibraryCalls(hDll);
        break;

    case DLL_PROCESS_DETACH:

        if ( g_eventLog != NULL ) {
            delete g_eventLog;
            g_eventLog = NULL;
        }

        DynUnloadODBC( );
        _Module.Term();
        DELETE_DEBUG_PRINT_OBJECT( );
        break;

    default:
        break;
    }

    return bReturn;
} // DllEntry


//
// constants used in self registration
//

#define TYPELIB_CLSID       "{FF160650-DE82-11CF-BC0A-00AA006111E0}"

#define NCSA_CLSID          NCSALOG_CLSID   // %F
#define NCSA_KEY            "MSIISLOG.MSNCSALogCtrl.1"
#define NCSA_NAME           "MSNCSALog Control"
#define NCSA_PP_CLSID       "{FF160660-DE82-11CF-BC0A-00AA006111E0}"
#define NCSA_PP_NAME        "MSNCSALog Property Page"

#define ODBC_CLSID          ODBCLOG_CLSID   //5B
#define ODBC_KEY            "MSIISLOG.MSODBCLogCtrl.1"
#define ODBC_NAME           "MSODBCLog Control"
#define ODBC_PP_CLSID       "{FF16065C-DE82-11CF-BC0A-00AA006111E0}"
#define ODBC_PP_NAME        "MSODBCLog Property Page"

#define ASCII_CLSID         ASCLOG_CLSID    // 57
#define ASCII_KEY           "MSIISLOG.MSASCIILogCtrl.1"
#define ASCII_NAME          "MSASCIILog Control"
#define ASCII_PP_CLSID      "{FF160658-DE82-11CF-BC0A-00AA006111E0}"
#define ASCII_PP_NAME       "MSASCIILog Property Page"

#define CUSTOM_CLSID        EXTLOG_CLSID    // 63
#define CUSTOM_KEY          "MSIISLOG.MSCustomLogCtrl.1"
#define CUSTOM_NAME         "MSCustomLog Control"
#define CUSTOM_PP_CLSID     "{FF160664-DE82-11CF-BC0A-00AA006111E0}"
#define CUSTOM_PP_NAME      "MSCustomLog Property Page"

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    //
    // MS NCSA Log Support
    //

    if ( !AddControlRegKeys(
                    NCSA_KEY,
                    NCSA_NAME,
                    NCSA_CLSID,
                    NCSA_PP_CLSID,
                    NCSA_PP_NAME,
                    "4") ) {

        goto error;
    }

    //
    // MS ODBC Log Support
    //

    if ( !AddControlRegKeys(
                    ODBC_KEY,
                    ODBC_NAME,
                    ODBC_CLSID,
                    ODBC_PP_CLSID,
                    ODBC_PP_NAME,
                    "3") ) {

        goto error;
    }

    //
    // MS Ascii Log Support
    //

    if ( !AddControlRegKeys(
                    ASCII_KEY,
                    ASCII_NAME,
                    ASCII_CLSID,
                    ASCII_PP_CLSID,
                    ASCII_PP_NAME,
                    "2") ) {

        goto error;
    }

    //
    // MS Custom Log Support
    //

    if ( !AddClsIdRegKeys(
                    CUSTOM_KEY,
                    CUSTOM_CLSID,
                    CUSTOM_NAME,
                    CUSTOM_PP_CLSID,
                    CUSTOM_PP_NAME,
                    "2"
                    ) ) {
        goto error;
    }

    //
    // Metabase entries for W3C custom logging
    //

    if ( !CreateMetabaseKeys() ) {

        goto error;
    }

    return S_OK;

error:
    return E_UNEXPECTED;

} // DllRegisterServer


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{

    HKEY hCLSID;

    //
    // Delete controls
    //

    ZapRegistryKey(HKEY_CLASSES_ROOT,NCSA_KEY);
    ZapRegistryKey(HKEY_CLASSES_ROOT,ODBC_KEY);
    ZapRegistryKey(HKEY_CLASSES_ROOT,ASCII_KEY);

    //
    // Get CLSID handle
    //

    if ( RegOpenKeyExA(HKEY_CLASSES_ROOT,
                    "CLSID",
                    0,
                    KEY_ALL_ACCESS,
                    &hCLSID) != ERROR_SUCCESS ) {

        IIS_PRINTF((buff,"IISLOG: Cannot open CLSID key\n"));
        return E_UNEXPECTED;
    }

    ZapRegistryKey(hCLSID, NCSA_CLSID);
    ZapRegistryKey(hCLSID, NCSA_PP_CLSID);

    ZapRegistryKey(hCLSID, ODBC_CLSID);
    ZapRegistryKey(hCLSID, ODBC_PP_CLSID);

    ZapRegistryKey(hCLSID, ASCII_CLSID);
    ZapRegistryKey(hCLSID, ASCII_PP_CLSID);

    ZapRegistryKey(hCLSID, CUSTOM_CLSID);
    ZapRegistryKey(hCLSID, CUSTOM_PP_CLSID);

    RegCloseKey(hCLSID);

    //
    // Open the metabase path and remove Custom Logging keys
    //

    /*
    
    IMSAdminBase*       pMBCom = NULL;
    METADATA_HANDLE     hMeta = NULL;

    if ( SUCCEEDED( CoCreateInstance(GETAdminBaseCLSID(TRUE), NULL, CLSCTX_LOCAL_SERVER, 
                            IID_IMSAdminBase, (void **)(&pMBCom) )))
    {
        if ( SUCCEEDED( pMBCom->OpenKey( METADATA_MASTER_ROOT_HANDLE, L"LM",
                     METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, MB_TIMEOUT, 
                     &hMeta))  )
        {
            pMBCom->DeleteKey(hMeta, L"Logging/Custom Logging");
            pMBCom->CloseKey(hMeta);
        }

        pMBCom->Release();
    }

    */
    return S_OK;

} // DllUnregisterServer


BOOL
AddControlRegKeys(
    IN LPCSTR ControlKey,
    IN LPCSTR ControlName,
    IN LPCSTR ControlClsId,
    IN LPCSTR PPageClsId,
    IN LPCSTR PPageName,
    IN LPCSTR BitmapIndex
    )
{

    HKEY hProgID = NULL;
    HKEY hCLSID = NULL;

    BOOL fRet = FALSE;

    //
    // Add control name
    //

    hProgID = CreateKey(HKEY_CLASSES_ROOT,ControlKey,ControlName);
    if ( hProgID == NULL ) {
        goto exit;
    }

    hCLSID = CreateKey(hProgID,"CLSID",ControlClsId);
    if ( hCLSID == NULL ) {
        goto exit;
    }

    //
    // Add CLSID keys
    //

    if ( !AddClsIdRegKeys(
                    ControlKey,
                    ControlClsId,
                    ControlName,
                    PPageClsId,
                    PPageName,
                    BitmapIndex) ) {

        goto exit;
    }

    fRet = TRUE;

exit:
    if ( hProgID != NULL ) {
        RegCloseKey(hProgID);
    }

    if ( hCLSID != NULL ) {
        RegCloseKey(hCLSID);
    }

    return(fRet);

} // AddControlRegKeys


BOOL
AddClsIdRegKeys(
    IN LPCSTR ControlKey,
    IN LPCSTR ClsId,
    IN LPCSTR ControlName,
    IN LPCSTR PPageClsId,
    IN LPCSTR PPageName,
    IN LPCSTR BitmapIndex
    )
{
    BOOL fRet = FALSE;

    HKEY hCLSID = NULL;
    HKEY hRoot = NULL;
    HKEY hKey, hKey2;

    CHAR szName[MAX_PATH+1];

    HMODULE hModule;

    //
    // open CLASSES/CLSID
    //

    if ( RegOpenKeyEx(HKEY_CLASSES_ROOT,
                    "CLSID",
                    0,
                    KEY_ALL_ACCESS,
                    &hCLSID) != ERROR_SUCCESS ) {

        IIS_PRINTF((buff,"IISLOG: Cannot open CLSID key\n"));
        goto exit;
    }

    //
    // Create the Guid and set the control name
    //

    hRoot = CreateKey(hCLSID,ClsId,ControlName);

    if ( hRoot == NULL ) {
        goto exit;
    }

    //
    // Control
    //

    hKey = CreateKey(hRoot, "Control", "");
    if ( hKey == NULL ) {
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // InProcServer32
    //

    hModule=GetModuleHandleA("iislog.dll");
    if (hModule == NULL) {
        goto exit;
    }

    if (GetModuleFileName(hModule, szName, sizeof(szName)) == 0) {
        goto exit;
    }

    hKey = CreateKey(hRoot, "InProcServer32", szName);
    if ( hKey == NULL ) {
        goto exit;
    }

    if (RegSetValueExA(hKey,
                "ThreadingModel",
                NULL,
                REG_SZ,
                (LPBYTE)"Both",
                sizeof("Both")) != ERROR_SUCCESS) {

        RegCloseKey(hKey);
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // Misc Status
    //

    hKey = CreateKey(hRoot,"MiscStatus","0");
    if ( hKey == NULL ) {
        goto exit;
    }

    hKey2 = CreateKey(hKey,"1","131473");
    if ( hKey2 == NULL ) {
        RegCloseKey(hKey);
        goto exit;
    }

    RegCloseKey(hKey2);
    RegCloseKey(hKey);

    //
    // ProgID
    //

    hKey = CreateKey(hRoot,"ProgID",ControlKey);
    if ( hKey == NULL ) {
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // ToolboxBitmap32
    //

    {
        CHAR tmpBuf[MAX_PATH+1];
        strcpy(tmpBuf,szName);
        strcat(tmpBuf,", ");
        strcat(tmpBuf,BitmapIndex);

        hKey = CreateKey(hRoot,"ToolboxBitmap32",tmpBuf);
        if ( hKey == NULL ) {
            goto exit;
        }
        RegCloseKey(hKey);
    }

    //
    // TypeLib
    //

    hKey = CreateKey(hRoot,"TypeLib",TYPELIB_CLSID);
    if ( hKey == NULL ) {
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // Version
    //

    hKey = CreateKey(hRoot,"Version","1.0");
    if ( hKey == NULL ) {
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // Property page
    //

    RegCloseKey(hRoot);
    hRoot = NULL;

    hRoot = CreateKey(hCLSID, PPageClsId, PPageName);
    if ( hRoot == NULL ) {
        goto exit;
    }

    hKey = CreateKey(hRoot, "InProcServer32", szName );
    if ( hKey == NULL ) {
        goto exit;
    }

    RegCloseKey(hKey);

    fRet = TRUE;
exit:

    if ( hRoot != NULL ) {
        RegCloseKey(hRoot);
    }

    if ( hCLSID != NULL ) {
        RegCloseKey(hCLSID);
    }

    return fRet;

} // AddClsIdRegKeys


BOOL
CreateMetabaseKeys()
{
    USES_CONVERSION;

    typedef struct  _MB_PROP_
    {
        LPWSTR  wcsPath;
        DWORD   dwNameString;
        LPSTR   szHeaderName;
        DWORD   dwPropID;
        DWORD   dwPropMask;
        DWORD   dwDataType;
    }   MB_PROP;

    IMSAdminBase*   pMBCom;
    CHAR            szString[256];
    int             i;

    METADATA_HANDLE     hMeta = NULL;
    METADATA_RECORD     mdRecord;

    HRESULT             hr;
          
    MB_PROP mbProperties[] = 
    {
        { L"Logging/Custom Logging/Date", IDS_DATE, 
            EXTLOG_DATE_ID, MD_LOGEXT_FIELD_MASK, MD_EXTLOG_DATE, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Time", IDS_TIME,
            EXTLOG_TIME_ID, MD_LOGEXT_FIELD_MASK, MD_EXTLOG_TIME, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties", IDS_EXTENDED_PROP, 
            NULL, MD_LOGEXT_FIELD_MASK, 0, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/Client IP Address", IDS_CLIENT_IP_ADDRESS, 
            EXTLOG_CLIENT_IP_ID, 0, MD_EXTLOG_CLIENT_IP, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/User Name", IDS_USER_NAME, 
            EXTLOG_USERNAME_ID,  0, MD_EXTLOG_USERNAME, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/Service Name", IDS_SERVICE_NAME,
            EXTLOG_SITE_NAME_ID, 0, MD_EXTLOG_SITE_NAME, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/Server Name", IDS_SERVER_NAME, 
            EXTLOG_COMPUTER_NAME_ID, 0, MD_EXTLOG_COMPUTER_NAME, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/Server IP", IDS_SERVER_IP, 
            EXTLOG_SERVER_IP_ID, 0, MD_EXTLOG_SERVER_IP, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/Server Port", IDS_SERVER_PORT, 
            EXTLOG_SERVER_PORT_ID, 0, MD_EXTLOG_SERVER_PORT, MD_LOGCUSTOM_DATATYPE_ULONG},

        { L"Logging/Custom Logging/Extended Properties/Method", IDS_METHOD,
            EXTLOG_METHOD_ID, 0, MD_EXTLOG_METHOD, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/URI Stem", IDS_URI_STEM,
            EXTLOG_URI_STEM_ID, 0, MD_EXTLOG_URI_STEM, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/URI Query", IDS_URI_QUERY,
            EXTLOG_URI_QUERY_ID, 0, MD_EXTLOG_URI_QUERY, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/Protocol Status", IDS_HTTP_STATUS, 
            EXTLOG_HTTP_STATUS_ID, 0, MD_EXTLOG_HTTP_STATUS, MD_LOGCUSTOM_DATATYPE_ULONG},

        { L"Logging/Custom Logging/Extended Properties/Win32 Status", IDS_WIN32_STATUS, 
            EXTLOG_WIN32_STATUS_ID, 0, MD_EXTLOG_WIN32_STATUS, MD_LOGCUSTOM_DATATYPE_ULONG},

        { L"Logging/Custom Logging/Extended Properties/Bytes Sent", IDS_BYTES_SENT, 
            EXTLOG_BYTES_SENT_ID, 0, MD_EXTLOG_BYTES_SENT, MD_LOGCUSTOM_DATATYPE_ULONG},

        { L"Logging/Custom Logging/Extended Properties/Bytes Received", IDS_BYTES_RECEIVED, 
            EXTLOG_BYTES_RECV_ID, 0, MD_EXTLOG_BYTES_RECV, MD_LOGCUSTOM_DATATYPE_ULONG},

        { L"Logging/Custom Logging/Extended Properties/Time Taken", IDS_TIME_TAKEN, 
            EXTLOG_TIME_TAKEN_ID, 0, MD_EXTLOG_TIME_TAKEN, MD_LOGCUSTOM_DATATYPE_ULONG},

        { L"Logging/Custom Logging/Extended Properties/Protocol Version", IDS_PROTOCOL_VERSION,
            EXTLOG_PROTOCOL_VERSION_ID, 0, MD_EXTLOG_PROTOCOL_VERSION, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/Host", IDS_HOST,
            EXTLOG_HOST_ID, 0, EXTLOG_HOST, MD_LOGCUSTOM_DATATYPE_LPSTR},
            
        { L"Logging/Custom Logging/Extended Properties/User Agent", IDS_USER_AGENT,  
            EXTLOG_USER_AGENT_ID, 0, MD_EXTLOG_USER_AGENT, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/Cookie", IDS_COOKIE, 
            EXTLOG_COOKIE_ID, 0, MD_EXTLOG_COOKIE, MD_LOGCUSTOM_DATATYPE_LPSTR},   

        { L"Logging/Custom Logging/Extended Properties/Referer", IDS_REFERER, 
            EXTLOG_REFERER_ID, 0, MD_EXTLOG_REFERER, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"\0", 0, NULL, 0, 0, 0 },
    };

    //
    // Open the metabase path
    //
    
    if ( FAILED( CoCreateInstance(GETAdminBaseCLSID(TRUE), NULL, CLSCTX_LOCAL_SERVER, 
                            IID_IMSAdminBase, (void **)(&pMBCom) )))
    {
        return FALSE;
    }

    // Create the LM key
    if ( FAILED( pMBCom->OpenKey( METADATA_MASTER_ROOT_HANDLE, L"/",
                          METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, MB_TIMEOUT, 
                          &hMeta) ))
    {
        // Create the LM key
        pMBCom->Release();
        return FALSE;
    }

    hr = pMBCom->AddKey( hMeta, L"LM");
    if ( FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr))
    {
        goto cleanup;
    }
    pMBCom->CloseKey(hMeta);
    hMeta = NULL;

                          
    if ( FAILED( pMBCom->OpenKey( METADATA_MASTER_ROOT_HANDLE, L"LM",
                            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, MB_TIMEOUT, 
                            &hMeta) ))
    {
        pMBCom->Release();
        return FALSE;
    }

    //
    // Create the initial set of Keys.
    //

    hr = pMBCom->AddKey( hMeta, L"Logging");

    if ( FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr))
    {
       goto cleanup;
    }
    
    hr = pMBCom->AddKey( hMeta, L"Logging/Custom Logging");

    if ( FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr))
    {
       goto cleanup;
    }

    //
    // Set all the properties
    //
    
    mdRecord.dwMDUserType    = IIS_MD_UT_SERVER;

    for (i=0; 0 != mbProperties[i].wcsPath[0]; i++)
    {

        hr = pMBCom->AddKey( hMeta, mbProperties[i].wcsPath);
        
        if ( FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr))
        {
            goto cleanup;
        }

        // don't overwrite it entry already exist.
        if ( SUCCEEDED(hr) || (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr))
        {
        // We won't get here if the key already exists.
        mdRecord.dwMDAttributes = METADATA_INHERIT;    // name and header is not inheritable.
        
        mdRecord.dwMDDataType   = STRING_METADATA;

        if ( (0 != mbProperties[i].dwNameString) && 
             (0 < LoadString( hDLLInstance, mbProperties[i].dwNameString, szString, sizeof(szString)) )
           )
        {
            mdRecord.dwMDIdentifier = MD_LOGCUSTOM_PROPERTY_NAME;
            mdRecord.pbMDData       = (PBYTE)A2W(szString);
            mdRecord.dwMDDataLen    = (DWORD)((sizeof(WCHAR)/sizeof(BYTE)) * (wcslen((LPWSTR) mdRecord.pbMDData)+1));

            if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
            {
                goto cleanup;
            }
        }

        if ( NULL != mbProperties[i].szHeaderName)
        {
            mdRecord.dwMDIdentifier = MD_LOGCUSTOM_PROPERTY_HEADER;
            mdRecord.pbMDData       = (PBYTE) (A2W(mbProperties[i].szHeaderName));
            mdRecord.dwMDDataLen    = (DWORD)((sizeof(WCHAR)/sizeof(BYTE)) * (wcslen((LPWSTR) mdRecord.pbMDData)+1));

            if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
            {
                goto cleanup;
            }
        }

        mdRecord.dwMDDataType   = DWORD_METADATA;
        mdRecord.dwMDDataLen    = sizeof(DWORD);

        if ( 0 != mbProperties[i].dwPropID)
        {
            mdRecord.dwMDIdentifier = MD_LOGCUSTOM_PROPERTY_ID;
            mdRecord.pbMDData       = (PBYTE) &(mbProperties[i].dwPropID);

            if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
            {
                goto cleanup;
            }
        }

        if ( 0 != mbProperties[i].dwPropMask)
        {
            mdRecord.dwMDIdentifier = MD_LOGCUSTOM_PROPERTY_MASK;
            mdRecord.pbMDData       = (PBYTE) &(mbProperties[i].dwPropMask);

            if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
            {
                goto cleanup;
            }
        }

        mdRecord.dwMDIdentifier = MD_LOGCUSTOM_PROPERTY_DATATYPE;
        mdRecord.pbMDData       = (PBYTE) &(mbProperties[i].dwDataType);

        if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
        {
            goto cleanup;
        }

        WCHAR   wcsKeyType[] = L"IIsCustomLogModule";

        MD_SET_DATA_RECORD (    &mdRecord, 
                                MD_KEY_TYPE,
                                METADATA_NO_ATTRIBUTES,
                                IIS_MD_UT_SERVER,
                                STRING_METADATA,
                                sizeof(wcsKeyType),
                                wcsKeyType
                              );
                              
        if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
        {
          goto cleanup;
        }
        }
   }

    //
    // Set the Key Type and Services List Property
    //

    {
        WCHAR   wcsKeyType[] = L"IIsCustomLogModule";

        MD_SET_DATA_RECORD (    &mdRecord, 
                                MD_KEY_TYPE,
                                METADATA_NO_ATTRIBUTES,
                                IIS_MD_UT_SERVER,
                                STRING_METADATA,
                                sizeof(wcsKeyType),
                                wcsKeyType
                              );
                              
        if ( FAILED(pMBCom->SetData( hMeta, L"Logging/Custom Logging", &mdRecord)) )
        {
          goto cleanup;
        }

        WCHAR   wcsServices[] = L"W3SVC\0MSFTPSVC\0SMTPSVC\0NNTPSVC\0";
        

        MD_SET_DATA_RECORD (    &mdRecord, 
                                MD_LOGCUSTOM_SERVICES_STRING,
                                METADATA_INHERIT,
                                IIS_MD_UT_SERVER,
                                MULTISZ_METADATA,
                                sizeof(wcsServices),
                                wcsServices
                            );

        if ( FAILED(pMBCom->SetData( hMeta, L"Logging/Custom Logging", &mdRecord)) )
        {
            goto cleanup;
        }

    }

    //
    // Set the Admin ACL to allow everyone to read the /LM/Logging tree. This is to allow
    // operators to effectively use the ILogScripting components.
    //

    if (FAILED(SetAdminACL(pMBCom, hMeta, L"Logging")))
    {    
        goto cleanup;
    }
    if (NULL != hMeta)
    {
        pMBCom->CloseKey(hMeta);
    }
    pMBCom->Release();
    return TRUE;

cleanup:
    if (NULL != hMeta)
    {
        pMBCom->CloseKey(hMeta);
    }
    pMBCom->Release();
    
    return FALSE;

}

HRESULT SetAdminACL(
    IMSAdminBase *      pAdminBase,
    METADATA_HANDLE     hMeta,
    LPWSTR              wszKeyName 
    )
{
    BOOL                    b = FALSE;
    DWORD                   dwLength = 0;

    PSECURITY_DESCRIPTOR    pSD = NULL;
    PSECURITY_DESCRIPTOR    outpSD = NULL;
    DWORD                   cboutpSD  = 0;
    PACL                    pACLNew = NULL;
    DWORD                   cbACL = 0;
    PSID                    pAdminsSID = NULL, pEveryoneSID = NULL;
    BOOL                    bWellKnownSID = FALSE;
    METADATA_RECORD         mdr;
    HRESULT                 hr = NO_ERROR;

    // Initialize a new security descriptor
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
        // BugFix: 57647 Whistler
        //         Prefix bug pSD being used when NULL.
        //         EBK 5/5/2000         
        if (pSD == NULL)
        {
                hr = E_OUTOFMEMORY;
                goto cleanup;
        }

    InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);

    // Get Local Admins Sid
    GetPrincipalSID (_T("Administrators"), &pAdminsSID, &bWellKnownSID);

    // Get everyone Sid
    GetPrincipalSID (_T("Everyone"), &pEveryoneSID, &bWellKnownSID);

    // Initialize a new ACL, which only contains 2 aaace
    cbACL = sizeof(ACL) +
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminsSID) - sizeof(DWORD)) +
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pEveryoneSID) - sizeof(DWORD)) ;
    pACLNew = (PACL) LocalAlloc(LPTR, cbACL);

    // BugFix: 57646 Whistler
    //         Prefix bug pACLNew being used when NULL.
    //         EBK 5/5/2000         
    if (pACLNew == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    InitializeAcl(pACLNew, cbACL, ACL_REVISION);

    AddAccessAllowedAce(
        pACLNew,
        ACL_REVISION,
        FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE,
        pAdminsSID);

    AddAccessAllowedAce(
        pACLNew,
        ACL_REVISION,
        FILE_GENERIC_READ,
        pEveryoneSID);

    // Add the ACL to the security descriptor
    b = SetSecurityDescriptorDacl(pSD, TRUE, pACLNew, FALSE);
    b = SetSecurityDescriptorOwner(pSD, pAdminsSID, TRUE);
    b = SetSecurityDescriptorGroup(pSD, pAdminsSID, TRUE);

    // Security descriptor blob must be self relative
    b = MakeSelfRelativeSD(pSD, outpSD, &cboutpSD);
    outpSD = (PSECURITY_DESCRIPTOR)GlobalAlloc(GPTR, cboutpSD);

    // BugFix: 57648, 57649 Whistler
    //         Prefix bug outpSD being used when NULL.
    //         EBK 5/5/2000         
    if (outpSD == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    // BugFix: 57649 Whistler
    //         Prefix bug outpSD being used when not inintalized.
    //         EmilyK 2/19/2001       
    if ( !MakeSelfRelativeSD( pSD, outpSD, &cboutpSD ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }
   

    // below this modify pSD to outpSD

    // Apply the new security descriptor to the file
    dwLength = GetSecurityDescriptorLength(outpSD);

    mdr.dwMDIdentifier = MD_ADMIN_ACL;
    mdr.dwMDAttributes = METADATA_INHERIT | METADATA_REFERENCE | METADATA_SECURE;
    mdr.dwMDUserType = IIS_MD_UT_SERVER;
    mdr.dwMDDataType = BINARY_METADATA;
    mdr.dwMDDataLen = dwLength;
    mdr.pbMDData = (LPBYTE)outpSD;

    hr = pAdminBase->SetData(hMeta, wszKeyName, &mdr);

cleanup:
    // both of Administrators and Everyone are well-known SIDs, use FreeSid() to free them.
    if (outpSD)
        GlobalFree(outpSD);

    if (pAdminsSID)
        FreeSid(pAdminsSID);
    if (pEveryoneSID)
        FreeSid(pEveryoneSID);
    if (pSD)
        LocalFree((HLOCAL) pSD);
    if (pACLNew)
        LocalFree((HLOCAL) pACLNew);

    return (hr);
}


DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    )
{
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority;
    BYTE Count;
    DWORD dwRID[8];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));
    if ( lstrcmp(Principal,_T("Administrators")) == 0 ) {
        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;
    } else if ( lstrcmp(Principal,_T("System")) == 0) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;
    } else if ( lstrcmp(Principal,_T("Interactive")) == 0) {
        // INTERACTIVE
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;
    } else if ( lstrcmp(Principal,_T("Everyone")) == 0) {
        // Everyone
        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;
    } else {
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID) {
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority,
                                    (BYTE)Count,
                                    dwRID[0],
                                    dwRID[1],
                                    dwRID[2],
                                    dwRID[3],
                                    dwRID[4],
                                    dwRID[5],
                                    dwRID[6],
                                    dwRID[7],
                                    Sid) )
        return GetLastError();
    } else {
        // get regular account sid
        DWORD        sidSize;
        TCHAR        refDomain [256];
        DWORD        refDomainSize;
        DWORD        returnValue;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountName (NULL,
                           Principal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();
        if (returnValue != ERROR_INSUFFICIENT_BUFFER)
            return returnValue;

        *Sid = (PSID) malloc (sidSize);
        refDomainSize = 255;

        if (!LookupAccountName (NULL,
                                Principal,
                                *Sid,
                                &sidSize,
                                refDomain,
                                &refDomainSize,
                                &snu))
        {
            return GetLastError();
        }
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\ppages\ncslogp.cpp ===
// MSNCSALogPpg.cpp : Implementation of the CMSNCSALogPropPage property page class.

#include "stdafx.h"
#include "NCSLogP.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CMSNCSALogPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMSNCSALogPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CMSNCSALogPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMSNCSALogPropPage, "MSIISLOG.MSNCSALogPropPage.1",
	0xff160660, 0xde82, 0x11cf, 0xbc, 0xa, 0, 0xaa, 0, 0x61, 0x11, 0xe0)


/////////////////////////////////////////////////////////////////////////////
// CMSNCSALogPropPage::CMSNCSALogPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CMSNCSALogPropPage

BOOL CMSNCSALogPropPage::CMSNCSALogPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_MSNCSALOG_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CMSNCSALogPropPage::CMSNCSALogPropPage - Constructor

CMSNCSALogPropPage::CMSNCSALogPropPage() :
	COlePropertyPage(IDD, IDS_MSNCSALOG_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CMSNCSALogPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CMSNCSALogPropPage::DoDataExchange - Moves data between page and properties

void CMSNCSALogPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CMSNCSALogPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CMSNCSALogPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\iis51\plugin1.cpp ===
#include "precomp.hxx"
#include <stdio.h>
#include <script.h>
#include "LogScript.hxx"
#include <ilogobj.hxx>
#include "filectl.hxx"
#include "asclogc.hxx"
#include "ncslogc.hxx"
#include "lkrhash.h"
#include "extlogc.hxx"
#include "odbcconn.hxx"
#include "odblogc.hxx"

#include <initguid.h>
#include <iadmw.h>

#include "resource.h"

HINSTANCE   hDLLInstance;

BOOL
AddClsIdRegKeys(
    IN LPCSTR ControlKey,
    IN LPCSTR ClsId,
    IN LPCSTR ControlName,
    IN LPCSTR PPageClsId,
    IN LPCSTR PPageName,
    IN LPCSTR BitmapIndex
    );

BOOL
AddControlRegKeys(
    IN LPCSTR ControlKey,
    IN LPCSTR ControlName,
    IN LPCSTR ClsId,
    IN LPCSTR PPageClsId,
    IN LPCSTR PPageName,
    IN LPCSTR BitmapIndex
    );

VOID
DynUnloadODBC(
    VOID
    );

BOOL
CreateMetabaseKeys();

HRESULT SetAdminACL(
    IMSAdminBase        *pAdminBase,
    METADATA_HANDLE     hMeta,
    LPWSTR              wszKeyName 
    );

DWORD
GetPrincipalSID (
    LPTSTR              Principal,
    PSID                *Sid,
    BOOL                *pbWellKnownSID
    );

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_NCSALOG, CNCSALOG)
        OBJECT_ENTRY(CLSID_ODBCLOG, CODBCLOG)
        OBJECT_ENTRY(CLSID_EXTLOG, CEXTLOG)
        OBJECT_ENTRY(CLSID_ASCLOG, CASCLOG)
END_OBJECT_MAP()

#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisPlugInGuid, 
0x784d890F, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();
#endif
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

extern "C" {

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    );
}

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    )
/*++

Routine Description:

    DLL entrypoint.

Arguments:

    hDLL          - Instance handle.

    Reason        - The reason the entrypoint was called.
                    DLL_PROCESS_ATTACH
                    DLL_PROCESS_DETACH
                    DLL_THREAD_ATTACH
                    DLL_THREAD_DETACH

    Reserved      - Reserved.

Return Value:

    BOOL          - TRUE if the action succeeds.

--*/
{
    hDLLInstance = hDll;

    BOOL bReturn = TRUE;

    switch ( dwReason ) {

    case DLL_PROCESS_ATTACH:
        INITIALIZE_PLATFORM_TYPE();
#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT("iislog.dll");
        SET_DEBUG_FLAGS(DEBUG_ERROR);
#else
        CREATE_DEBUG_PRINT_OBJECT("iislog.dll", IisPlugInGuid);
#endif
        _Module.Init(ObjectMap,hDll);
        g_eventLog = new EVENT_LOG(IISLOG_EVENTLOG_SOURCE);

        if ( g_eventLog == NULL ) {
            DBGPRINTF((DBG_CONTEXT,
                "Unable to create eventlog[%s] object[err %d]\n",
                IISLOG_EVENTLOG_SOURCE, GetLastError()));
        }

        (VOID)IISGetPlatformType();

        DisableThreadLibraryCalls(hDll);
        break;

    case DLL_PROCESS_DETACH:

        if ( g_eventLog != NULL ) {
            delete g_eventLog;
            g_eventLog = NULL;
        }

        DynUnloadODBC( );
        _Module.Term();
        DELETE_DEBUG_PRINT_OBJECT( );
        break;

    default:
        break;
    }

    return bReturn;
} // DllEntry


//
// constants used in self registration
//

#define TYPELIB_CLSID       "{FF160650-DE82-11CF-BC0A-00AA006111E0}"

#define NCSA_CLSID          NCSALOG_CLSID   // %F
#define NCSA_KEY            "MSIISLOG.MSNCSALogCtrl.1"
#define NCSA_NAME           "MSNCSALog Control"
#define NCSA_PP_CLSID       "{FF160660-DE82-11CF-BC0A-00AA006111E0}"
#define NCSA_PP_NAME        "MSNCSALog Property Page"

#define ODBC_CLSID          ODBCLOG_CLSID   //5B
#define ODBC_KEY            "MSIISLOG.MSODBCLogCtrl.1"
#define ODBC_NAME           "MSODBCLog Control"
#define ODBC_PP_CLSID       "{FF16065C-DE82-11CF-BC0A-00AA006111E0}"
#define ODBC_PP_NAME        "MSODBCLog Property Page"

#define ASCII_CLSID         ASCLOG_CLSID    // 57
#define ASCII_KEY           "MSIISLOG.MSASCIILogCtrl.1"
#define ASCII_NAME          "MSASCIILog Control"
#define ASCII_PP_CLSID      "{FF160658-DE82-11CF-BC0A-00AA006111E0}"
#define ASCII_PP_NAME       "MSASCIILog Property Page"

#define CUSTOM_CLSID        EXTLOG_CLSID    // 63
#define CUSTOM_KEY          "MSIISLOG.MSCustomLogCtrl.1"
#define CUSTOM_NAME         "MSCustomLog Control"
#define CUSTOM_PP_CLSID     "{FF160664-DE82-11CF-BC0A-00AA006111E0}"
#define CUSTOM_PP_NAME      "MSCustomLog Property Page"

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    //
    // MS NCSA Log Support
    //

    if ( !AddControlRegKeys(
                    NCSA_KEY,
                    NCSA_NAME,
                    NCSA_CLSID,
                    NCSA_PP_CLSID,
                    NCSA_PP_NAME,
                    "4") ) {

        goto error;
    }

    //
    // MS ODBC Log Support
    //

    if ( !AddControlRegKeys(
                    ODBC_KEY,
                    ODBC_NAME,
                    ODBC_CLSID,
                    ODBC_PP_CLSID,
                    ODBC_PP_NAME,
                    "3") ) {

        goto error;
    }

    //
    // MS Ascii Log Support
    //

    if ( !AddControlRegKeys(
                    ASCII_KEY,
                    ASCII_NAME,
                    ASCII_CLSID,
                    ASCII_PP_CLSID,
                    ASCII_PP_NAME,
                    "2") ) {

        goto error;
    }

    //
    // MS Custom Log Support
    //

    if ( !AddClsIdRegKeys(
                    CUSTOM_KEY,
                    CUSTOM_CLSID,
                    CUSTOM_NAME,
                    CUSTOM_PP_CLSID,
                    CUSTOM_PP_NAME,
                    "2"
                    ) ) {
        goto error;
    }

    //
    // Metabase entries for W3C custom logging
    //

    if ( !CreateMetabaseKeys() ) {

        goto error;
    }

    return S_OK;

error:
    return E_UNEXPECTED;

} // DllRegisterServer


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{

    HKEY hCLSID;

    //
    // Delete controls
    //

    ZapRegistryKey(HKEY_CLASSES_ROOT,NCSA_KEY);
    ZapRegistryKey(HKEY_CLASSES_ROOT,ODBC_KEY);
    ZapRegistryKey(HKEY_CLASSES_ROOT,ASCII_KEY);

    //
    // Get CLSID handle
    //

    if ( RegOpenKeyExA(HKEY_CLASSES_ROOT,
                    "CLSID",
                    0,
                    KEY_ALL_ACCESS,
                    &hCLSID) != ERROR_SUCCESS ) {

        IIS_PRINTF((buff,"IISLOG: Cannot open CLSID key\n"));
        return E_UNEXPECTED;
    }

    ZapRegistryKey(hCLSID, NCSA_CLSID);
    ZapRegistryKey(hCLSID, NCSA_PP_CLSID);

    ZapRegistryKey(hCLSID, ODBC_CLSID);
    ZapRegistryKey(hCLSID, ODBC_PP_CLSID);

    ZapRegistryKey(hCLSID, ASCII_CLSID);
    ZapRegistryKey(hCLSID, ASCII_PP_CLSID);

    ZapRegistryKey(hCLSID, CUSTOM_CLSID);
    ZapRegistryKey(hCLSID, CUSTOM_PP_CLSID);

    RegCloseKey(hCLSID);

    //
    // Open the metabase path and remove Custom Logging keys
    //

    /*
    
    IMSAdminBase*       pMBCom = NULL;
    METADATA_HANDLE     hMeta = NULL;

    if ( SUCCEEDED( CoCreateInstance(GETAdminBaseCLSID(TRUE), NULL, CLSCTX_LOCAL_SERVER, 
                            IID_IMSAdminBase, (void **)(&pMBCom) )))
    {
        if ( SUCCEEDED( pMBCom->OpenKey( METADATA_MASTER_ROOT_HANDLE, L"LM",
                     METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, MB_TIMEOUT, 
                     &hMeta))  )
        {
            pMBCom->DeleteKey(hMeta, L"Logging/Custom Logging");
            pMBCom->CloseKey(hMeta);
        }

        pMBCom->Release();
    }

    */
    return S_OK;

} // DllUnregisterServer


BOOL
AddControlRegKeys(
    IN LPCSTR ControlKey,
    IN LPCSTR ControlName,
    IN LPCSTR ControlClsId,
    IN LPCSTR PPageClsId,
    IN LPCSTR PPageName,
    IN LPCSTR BitmapIndex
    )
{

    HKEY hProgID = NULL;
    HKEY hCLSID = NULL;

    BOOL fRet = FALSE;

    //
    // Add control name
    //

    hProgID = CreateKey(HKEY_CLASSES_ROOT,ControlKey,ControlName);
    if ( hProgID == NULL ) {
        goto exit;
    }

    hCLSID = CreateKey(hProgID,"CLSID",ControlClsId);
    if ( hCLSID == NULL ) {
        goto exit;
    }

    //
    // Add CLSID keys
    //

    if ( !AddClsIdRegKeys(
                    ControlKey,
                    ControlClsId,
                    ControlName,
                    PPageClsId,
                    PPageName,
                    BitmapIndex) ) {

        goto exit;
    }

    fRet = TRUE;

exit:
    if ( hProgID != NULL ) {
        RegCloseKey(hProgID);
    }

    if ( hCLSID != NULL ) {
        RegCloseKey(hCLSID);
    }

    return(fRet);

} // AddControlRegKeys


BOOL
AddClsIdRegKeys(
    IN LPCSTR ControlKey,
    IN LPCSTR ClsId,
    IN LPCSTR ControlName,
    IN LPCSTR PPageClsId,
    IN LPCSTR PPageName,
    IN LPCSTR BitmapIndex
    )
{
    BOOL fRet = FALSE;

    HKEY hCLSID = NULL;
    HKEY hRoot = NULL;
    HKEY hKey, hKey2;

    CHAR szName[MAX_PATH+1];

    HMODULE hModule;

    //
    // open CLASSES/CLSID
    //

    if ( RegOpenKeyEx(HKEY_CLASSES_ROOT,
                    "CLSID",
                    0,
                    KEY_ALL_ACCESS,
                    &hCLSID) != ERROR_SUCCESS ) {

        IIS_PRINTF((buff,"IISLOG: Cannot open CLSID key\n"));
        goto exit;
    }

    //
    // Create the Guid and set the control name
    //

    hRoot = CreateKey(hCLSID,ClsId,ControlName);

    if ( hRoot == NULL ) {
        goto exit;
    }

    //
    // Control
    //

    hKey = CreateKey(hRoot, "Control", "");
    if ( hKey == NULL ) {
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // InProcServer32
    //

    hModule=GetModuleHandleA("iislog.dll");
    if (hModule == NULL) {
        goto exit;
    }

    if (GetModuleFileName(hModule, szName, sizeof(szName)) == 0) {
        goto exit;
    }

    hKey = CreateKey(hRoot, "InProcServer32", szName);
    if ( hKey == NULL ) {
        goto exit;
    }

    if (RegSetValueExA(hKey,
                "ThreadingModel",
                NULL,
                REG_SZ,
                (LPBYTE)"Both",
                sizeof("Both")) != ERROR_SUCCESS) {

        RegCloseKey(hKey);
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // Misc Status
    //

    hKey = CreateKey(hRoot,"MiscStatus","0");
    if ( hKey == NULL ) {
        goto exit;
    }

    hKey2 = CreateKey(hKey,"1","131473");
    if ( hKey2 == NULL ) {
        RegCloseKey(hKey);
        goto exit;
    }

    RegCloseKey(hKey2);
    RegCloseKey(hKey);

    //
    // ProgID
    //

    hKey = CreateKey(hRoot,"ProgID",ControlKey);
    if ( hKey == NULL ) {
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // ToolboxBitmap32
    //

    {
        CHAR tmpBuf[MAX_PATH+1];
        strcpy(tmpBuf,szName);
        strcat(tmpBuf,", ");
        strcat(tmpBuf,BitmapIndex);

        hKey = CreateKey(hRoot,"ToolboxBitmap32",tmpBuf);
        if ( hKey == NULL ) {
            goto exit;
        }
        RegCloseKey(hKey);
    }

    //
    // TypeLib
    //

    hKey = CreateKey(hRoot,"TypeLib",TYPELIB_CLSID);
    if ( hKey == NULL ) {
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // Version
    //

    hKey = CreateKey(hRoot,"Version","1.0");
    if ( hKey == NULL ) {
        goto exit;
    }

    RegCloseKey(hKey);

    //
    // Property page
    //

    RegCloseKey(hRoot);
    hRoot = NULL;

    hRoot = CreateKey(hCLSID, PPageClsId, PPageName);
    if ( hRoot == NULL ) {
        goto exit;
    }

    hKey = CreateKey(hRoot, "InProcServer32", szName );
    if ( hKey == NULL ) {
        goto exit;
    }

    RegCloseKey(hKey);

    fRet = TRUE;
exit:

    if ( hRoot != NULL ) {
        RegCloseKey(hRoot);
    }

    if ( hCLSID != NULL ) {
        RegCloseKey(hCLSID);
    }

    return fRet;

} // AddClsIdRegKeys


BOOL
CreateMetabaseKeys()
{
    USES_CONVERSION;

    typedef struct  _MB_PROP_
    {
        LPWSTR  wcsPath;
        DWORD   dwNameString;
        LPSTR   szHeaderName;
        DWORD   dwPropID;
        DWORD   dwPropMask;
        DWORD   dwDataType;
    }   MB_PROP;

    IMSAdminBase*   pMBCom;
    CHAR            szString[256];
    int             i;

    METADATA_HANDLE     hMeta = NULL;
    METADATA_RECORD     mdRecord;

    HRESULT             hr;
          
    MB_PROP mbProperties[] = 
    {
        { L"Logging/Custom Logging/Date", IDS_DATE, 
            EXTLOG_DATE_ID, MD_LOGEXT_FIELD_MASK, MD_EXTLOG_DATE, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Time", IDS_TIME,
            EXTLOG_TIME_ID, MD_LOGEXT_FIELD_MASK, MD_EXTLOG_TIME, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties", IDS_EXTENDED_PROP, 
            NULL, MD_LOGEXT_FIELD_MASK, 0, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/Client IP Address", IDS_CLIENT_IP_ADDRESS, 
            EXTLOG_CLIENT_IP_ID, 0, MD_EXTLOG_CLIENT_IP, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/User Name", IDS_USER_NAME, 
            EXTLOG_USERNAME_ID,  0, MD_EXTLOG_USERNAME, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/Service Name", IDS_SERVICE_NAME,
            EXTLOG_SITE_NAME_ID, 0, MD_EXTLOG_SITE_NAME, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/Server Name", IDS_SERVER_NAME, 
            EXTLOG_COMPUTER_NAME_ID, 0, MD_EXTLOG_COMPUTER_NAME, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/Server IP", IDS_SERVER_IP, 
            EXTLOG_SERVER_IP_ID, 0, MD_EXTLOG_SERVER_IP, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/Server Port", IDS_SERVER_PORT, 
            EXTLOG_SERVER_PORT_ID, 0, MD_EXTLOG_SERVER_PORT, MD_LOGCUSTOM_DATATYPE_ULONG},

        { L"Logging/Custom Logging/Extended Properties/Method", IDS_METHOD,
            EXTLOG_METHOD_ID, 0, MD_EXTLOG_METHOD, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/URI Stem", IDS_URI_STEM,
            EXTLOG_URI_STEM_ID, 0, MD_EXTLOG_URI_STEM, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/URI Query", IDS_URI_QUERY,
            EXTLOG_URI_QUERY_ID, 0, MD_EXTLOG_URI_QUERY, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/Protocol Status", IDS_HTTP_STATUS, 
            EXTLOG_HTTP_STATUS_ID, 0, MD_EXTLOG_HTTP_STATUS, MD_LOGCUSTOM_DATATYPE_ULONG},

        { L"Logging/Custom Logging/Extended Properties/Win32 Status", IDS_WIN32_STATUS, 
            EXTLOG_WIN32_STATUS_ID, 0, MD_EXTLOG_WIN32_STATUS, MD_LOGCUSTOM_DATATYPE_ULONG},

        { L"Logging/Custom Logging/Extended Properties/Bytes Sent", IDS_BYTES_SENT, 
            EXTLOG_BYTES_SENT_ID, 0, MD_EXTLOG_BYTES_SENT, MD_LOGCUSTOM_DATATYPE_ULONG},

        { L"Logging/Custom Logging/Extended Properties/Bytes Received", IDS_BYTES_RECEIVED, 
            EXTLOG_BYTES_RECV_ID, 0, MD_EXTLOG_BYTES_RECV, MD_LOGCUSTOM_DATATYPE_ULONG},

        { L"Logging/Custom Logging/Extended Properties/Time Taken", IDS_TIME_TAKEN, 
            EXTLOG_TIME_TAKEN_ID, 0, MD_EXTLOG_TIME_TAKEN, MD_LOGCUSTOM_DATATYPE_ULONG},

        { L"Logging/Custom Logging/Extended Properties/Protocol Version", IDS_PROTOCOL_VERSION,
            EXTLOG_PROTOCOL_VERSION_ID, 0, MD_EXTLOG_PROTOCOL_VERSION, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/Host", IDS_HOST,
            EXTLOG_HOST_ID, 0, EXTLOG_HOST, MD_LOGCUSTOM_DATATYPE_LPSTR},
            
        { L"Logging/Custom Logging/Extended Properties/User Agent", IDS_USER_AGENT,  
            EXTLOG_USER_AGENT_ID, 0, MD_EXTLOG_USER_AGENT, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"Logging/Custom Logging/Extended Properties/Cookie", IDS_COOKIE, 
            EXTLOG_COOKIE_ID, 0, MD_EXTLOG_COOKIE, MD_LOGCUSTOM_DATATYPE_LPSTR},   

        { L"Logging/Custom Logging/Extended Properties/Referer", IDS_REFERER, 
            EXTLOG_REFERER_ID, 0, MD_EXTLOG_REFERER, MD_LOGCUSTOM_DATATYPE_LPSTR},

        { L"\0", 0, NULL, 0, 0, 0 },
    };

    //
    // Open the metabase path
    //
    
    if ( FAILED( CoCreateInstance(GETAdminBaseCLSID(TRUE), NULL, CLSCTX_LOCAL_SERVER, 
                            IID_IMSAdminBase, (void **)(&pMBCom) )))
    {
        return FALSE;
    }

    // Create the LM key
    if ( FAILED( pMBCom->OpenKey( METADATA_MASTER_ROOT_HANDLE, L"/",
                          METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, MB_TIMEOUT, 
                          &hMeta) ))
    {
        // Create the LM key
        pMBCom->Release();
        return FALSE;
    }

    hr = pMBCom->AddKey( hMeta, L"LM");
    if ( FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr))
    {
        goto cleanup;
    }
    pMBCom->CloseKey(hMeta);
    hMeta = NULL;

                          
    if ( FAILED( pMBCom->OpenKey( METADATA_MASTER_ROOT_HANDLE, L"LM",
                            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, MB_TIMEOUT, 
                            &hMeta) ))
    {
        pMBCom->Release();
        return FALSE;
    }

    //
    // Create the initial set of Keys.
    //

    hr = pMBCom->AddKey( hMeta, L"Logging");

    if ( FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr))
    {
       goto cleanup;
    }
    
    hr = pMBCom->AddKey( hMeta, L"Logging/Custom Logging");

    if ( FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr))
    {
       goto cleanup;
    }

    //
    // Set all the properties
    //
    
    mdRecord.dwMDUserType    = IIS_MD_UT_SERVER;

    for (i=0; 0 != mbProperties[i].wcsPath[0]; i++)
    {

        hr = pMBCom->AddKey( hMeta, mbProperties[i].wcsPath);
        
        if ( FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr))
        {
            goto cleanup;
        }

        // don't overwrite it entry already exist.
        if ( SUCCEEDED(hr) || (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr))
        {
        // We won't get here if the key already exists.
        mdRecord.dwMDAttributes = METADATA_INHERIT;    // name and header is not inheritable.
        
        mdRecord.dwMDDataType   = STRING_METADATA;

        if ( (0 != mbProperties[i].dwNameString) && 
             (0 < LoadString( hDLLInstance, mbProperties[i].dwNameString, szString, sizeof(szString)) )
           )
        {
            mdRecord.dwMDIdentifier = MD_LOGCUSTOM_PROPERTY_NAME;
            mdRecord.pbMDData       = (PBYTE)A2W(szString);
            mdRecord.dwMDDataLen    = (DWORD)((sizeof(WCHAR)/sizeof(BYTE)) * (wcslen((LPWSTR) mdRecord.pbMDData)+1));

            if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
            {
                goto cleanup;
            }
        }

        if ( NULL != mbProperties[i].szHeaderName)
        {
            mdRecord.dwMDIdentifier = MD_LOGCUSTOM_PROPERTY_HEADER;
            mdRecord.pbMDData       = (PBYTE) (A2W(mbProperties[i].szHeaderName));
            mdRecord.dwMDDataLen    = (DWORD)((sizeof(WCHAR)/sizeof(BYTE)) * (wcslen((LPWSTR) mdRecord.pbMDData)+1));

            if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
            {
                goto cleanup;
            }
        }

        mdRecord.dwMDDataType   = DWORD_METADATA;
        mdRecord.dwMDDataLen    = sizeof(DWORD);

        if ( 0 != mbProperties[i].dwPropID)
        {
            mdRecord.dwMDIdentifier = MD_LOGCUSTOM_PROPERTY_ID;
            mdRecord.pbMDData       = (PBYTE) &(mbProperties[i].dwPropID);

            if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
            {
                goto cleanup;
            }
        }

        if ( 0 != mbProperties[i].dwPropMask)
        {
            mdRecord.dwMDIdentifier = MD_LOGCUSTOM_PROPERTY_MASK;
            mdRecord.pbMDData       = (PBYTE) &(mbProperties[i].dwPropMask);

            if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
            {
                goto cleanup;
            }
        }

        mdRecord.dwMDIdentifier = MD_LOGCUSTOM_PROPERTY_DATATYPE;
        mdRecord.pbMDData       = (PBYTE) &(mbProperties[i].dwDataType);

        if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
        {
            goto cleanup;
        }

        WCHAR   wcsKeyType[] = L"IIsCustomLogModule";

        MD_SET_DATA_RECORD (    &mdRecord, 
                                MD_KEY_TYPE,
                                METADATA_NO_ATTRIBUTES,
                                IIS_MD_UT_SERVER,
                                STRING_METADATA,
                                sizeof(wcsKeyType),
                                wcsKeyType
                              );
                              
        if ( FAILED(pMBCom->SetData( hMeta, mbProperties[i].wcsPath, &mdRecord)) )
        {
          goto cleanup;
        }
        }
   }

    //
    // Set the Key Type and Services List Property
    //

    {
        WCHAR   wcsKeyType[] = L"IIsCustomLogModule";

        MD_SET_DATA_RECORD (    &mdRecord, 
                                MD_KEY_TYPE,
                                METADATA_NO_ATTRIBUTES,
                                IIS_MD_UT_SERVER,
                                STRING_METADATA,
                                sizeof(wcsKeyType),
                                wcsKeyType
                              );
                              
        if ( FAILED(pMBCom->SetData( hMeta, L"Logging/Custom Logging", &mdRecord)) )
        {
          goto cleanup;
        }

        WCHAR   wcsServices[] = L"W3SVC\0MSFTPSVC\0SMTPSVC\0NNTPSVC\0";
        

        MD_SET_DATA_RECORD (    &mdRecord, 
                                MD_LOGCUSTOM_SERVICES_STRING,
                                METADATA_INHERIT,
                                IIS_MD_UT_SERVER,
                                MULTISZ_METADATA,
                                sizeof(wcsServices),
                                wcsServices
                            );

        if ( FAILED(pMBCom->SetData( hMeta, L"Logging/Custom Logging", &mdRecord)) )
        {
            goto cleanup;
        }

    }

    //
    // Set the Admin ACL to allow everyone to read the /LM/Logging tree. This is to allow
    // operators to effectively use the ILogScripting components.
    //

    if (FAILED(SetAdminACL(pMBCom, hMeta, L"Logging")))
    {    
        goto cleanup;
    }
    if (NULL != hMeta)
    {
        pMBCom->CloseKey(hMeta);
    }
    pMBCom->Release();
    return TRUE;

cleanup:
    if (NULL != hMeta)
    {
        pMBCom->CloseKey(hMeta);
    }
    pMBCom->Release();
    
    return FALSE;

}

HRESULT SetAdminACL(
    IMSAdminBase *      pAdminBase,
    METADATA_HANDLE     hMeta,
    LPWSTR              wszKeyName 
    )
{
    BOOL                    b = FALSE;
    DWORD                   dwLength = 0;

    PSECURITY_DESCRIPTOR    pSD = NULL;
    PSECURITY_DESCRIPTOR    outpSD = NULL;
    DWORD                   cboutpSD  = 0;
    PACL                    pACLNew = NULL;
    DWORD                   cbACL = 0;
    PSID                    pAdminsSID = NULL, pEveryoneSID = NULL;
    BOOL                    bWellKnownSID = FALSE;
    METADATA_RECORD         mdr;
    HRESULT                 hr = NO_ERROR;

    // Initialize a new security descriptor
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
        // BugFix: 57647 Whistler
        //         Prefix bug pSD being used when NULL.
        //         EBK 5/5/2000         
        if (pSD == NULL)
        {
                hr = E_OUTOFMEMORY;
                goto cleanup;
        }

    InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);

    // Get Local Admins Sid
    GetPrincipalSID (_T("Administrators"), &pAdminsSID, &bWellKnownSID);

    // Get everyone Sid
    GetPrincipalSID (_T("Everyone"), &pEveryoneSID, &bWellKnownSID);

    // Initialize a new ACL, which only contains 2 aaace
    cbACL = sizeof(ACL) +
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminsSID) - sizeof(DWORD)) +
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pEveryoneSID) - sizeof(DWORD)) ;
    pACLNew = (PACL) LocalAlloc(LPTR, cbACL);

    // BugFix: 57646 Whistler
    //         Prefix bug pACLNew being used when NULL.
    //         EBK 5/5/2000         
    if (pACLNew == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    InitializeAcl(pACLNew, cbACL, ACL_REVISION);

    AddAccessAllowedAce(
        pACLNew,
        ACL_REVISION,
        FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE,
        pAdminsSID);

    AddAccessAllowedAce(
        pACLNew,
        ACL_REVISION,
        FILE_GENERIC_READ,
        pEveryoneSID);

    // Add the ACL to the security descriptor
    b = SetSecurityDescriptorDacl(pSD, TRUE, pACLNew, FALSE);
    b = SetSecurityDescriptorOwner(pSD, pAdminsSID, TRUE);
    b = SetSecurityDescriptorGroup(pSD, pAdminsSID, TRUE);

    // Security descriptor blob must be self relative
    b = MakeSelfRelativeSD(pSD, outpSD, &cboutpSD);
    outpSD = (PSECURITY_DESCRIPTOR)GlobalAlloc(GPTR, cboutpSD);

    // BugFix: 57648, 57649 Whistler
    //         Prefix bug outpSD being used when NULL.
    //         EBK 5/5/2000         
    if (outpSD == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    // BugFix: 57649 Whistler
    //         Prefix bug outpSD being used when not inintalized.
    //         EmilyK 2/19/2001       
    if ( !MakeSelfRelativeSD( pSD, outpSD, &cboutpSD ) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }
   

    // below this modify pSD to outpSD

    // Apply the new security descriptor to the file
    dwLength = GetSecurityDescriptorLength(outpSD);

    mdr.dwMDIdentifier = MD_ADMIN_ACL;
    mdr.dwMDAttributes = METADATA_INHERIT | METADATA_REFERENCE | METADATA_SECURE;
    mdr.dwMDUserType = IIS_MD_UT_SERVER;
    mdr.dwMDDataType = BINARY_METADATA;
    mdr.dwMDDataLen = dwLength;
    mdr.pbMDData = (LPBYTE)outpSD;

    hr = pAdminBase->SetData(hMeta, wszKeyName, &mdr);

cleanup:
    // both of Administrators and Everyone are well-known SIDs, use FreeSid() to free them.
    if (outpSD)
        GlobalFree(outpSD);

    if (pAdminsSID)
        FreeSid(pAdminsSID);
    if (pEveryoneSID)
        FreeSid(pEveryoneSID);
    if (pSD)
        LocalFree((HLOCAL) pSD);
    if (pACLNew)
        LocalFree((HLOCAL) pACLNew);

    return (hr);
}


DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    )
{
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority;
    BYTE Count;
    DWORD dwRID[8];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));
    if ( lstrcmp(Principal,_T("Administrators")) == 0 ) {
        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;
    } else if ( lstrcmp(Principal,_T("System")) == 0) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;
    } else if ( lstrcmp(Principal,_T("Interactive")) == 0) {
        // INTERACTIVE
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;
    } else if ( lstrcmp(Principal,_T("Everyone")) == 0) {
        // Everyone
        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;
    } else {
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID) {
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority,
                                    (BYTE)Count,
                                    dwRID[0],
                                    dwRID[1],
                                    dwRID[2],
                                    dwRID[3],
                                    dwRID[4],
                                    dwRID[5],
                                    dwRID[6],
                                    dwRID[7],
                                    Sid) )
        return GetLastError();
    } else {
        // get regular account sid
        DWORD        sidSize;
        TCHAR        refDomain [256];
        DWORD        refDomainSize;
        DWORD        returnValue;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountName (NULL,
                           Principal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();
        if (returnValue != ERROR_INSUFFICIENT_BUFFER)
            return returnValue;

        *Sid = (PSID) malloc (sidSize);
        refDomainSize = 255;

        if (!LookupAccountName (NULL,
                                Principal,
                                *Sid,
                                &sidSize,
                                refDomain,
                                &refDomainSize,
                                &snu))
        {
            return GetLastError();
        }
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\ppages\ncslogp.h ===
// MSNCSALogPpg.h : Declaration of the CMSNCSALogPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CMSNCSALogPropPage : See MSNCSALogPpg.cpp.cpp for implementation.

class CMSNCSALogPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CMSNCSALogPropPage)
	DECLARE_OLECREATE_EX(CMSNCSALogPropPage)

// Constructor
public:
	CMSNCSALogPropPage();

// Dialog Data
	//{{AFX_DATA(CMSNCSALogPropPage)
	enum { IDD = IDD_PROPPAGE_MSNCSALOG };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CMSNCSALogPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\scripting\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "script_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\ppages\odblogp.cpp ===
// MSODBCLogPpg.cpp : Implementation of the CMSODBCLogPropPage property page class.

#include "stdafx.h"
#include "ODBLogP.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CMSODBCLogPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMSODBCLogPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CMSODBCLogPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMSODBCLogPropPage, "MSIISLOG.MSODBCLogPropPage.1",
	0xff16065c, 0xde82, 0x11cf, 0xbc, 0xa, 0, 0xaa, 0, 0x61, 0x11, 0xe0)


/////////////////////////////////////////////////////////////////////////////
// CMSODBCLogPropPage::CMSODBCLogPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CMSODBCLogPropPage

BOOL CMSODBCLogPropPage::CMSODBCLogPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_MSODBCLOG_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CMSODBCLogPropPage::CMSODBCLogPropPage - Constructor

CMSODBCLogPropPage::CMSODBCLogPropPage() :
	COlePropertyPage(IDD, IDS_MSODBCLOG_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CMSODBCLogPropPage)
	m_DataSource = _T("");
	m_TableName = _T("");
	m_UserName = _T("");
	m_Password = _T("");
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CMSODBCLogPropPage::DoDataExchange - Moves data between page and properties

void CMSODBCLogPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CMSODBCLogPropPage)
	DDP_Text(pDX, IDC_SOURCE_NAME, m_DataSource, _T("DataSource") );
	DDX_Text(pDX, IDC_SOURCE_NAME, m_DataSource);
	DDP_Text(pDX, IDC_TABLE_NAME, m_TableName, _T("TableName") );
	DDX_Text(pDX, IDC_TABLE_NAME, m_TableName);
	DDP_Text(pDX, IDC_USER_NAME, m_UserName, _T("UserName") );
	DDX_Text(pDX, IDC_USER_NAME, m_UserName);
	DDP_Text(pDX, IDC_PASSWORD, m_Password, _T("Password") );
	DDX_Text(pDX, IDC_PASSWORD, m_Password);
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CMSODBCLogPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\scripting\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__B758F307_A3D6_11D1_8B9C_080009DCC2FA__INCLUDED_)
#define AFX_DLLDATAX_H__B758F307_A3D6_11D1_8B9C_080009DCC2FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__B758F307_A3D6_11D1_8B9C_080009DCC2FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\scripting\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\plugin\ppages\odblogp.h ===
// MSODBCLogPpg.h : Declaration of the CMSODBCLogPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CMSODBCLogPropPage : See MSODBCLogPpg.cpp.cpp for implementation.

class CMSODBCLogPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CMSODBCLogPropPage)
	DECLARE_OLECREATE_EX(CMSODBCLogPropPage)

// Constructor
public:
	CMSODBCLogPropPage();

// Dialog Data
	//{{AFX_DATA(CMSODBCLogPropPage)
	enum { IDD = IDD_PROPPAGE_MSODBCLOG };
	CString	m_DataSource;
	CString	m_TableName;
	CString	m_UserName;
	CString	m_Password;
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CMSODBCLogPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\scripting\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by script.rc
//
#define IDS_PROJNAME                    100
#define IDR_LOGSCRIPTING                101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\scripting\logscripting.cpp ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
      logscripting.cpp

   Abstract:
      LogScripting.cpp : Implementation of CLogScripting
                         Automation compatible logging interface

   Author:

       Saurab Nog    ( saurabn )    01-Feb-1998

   Project:

       IIS Logging 5.0

--*/



#include "stdafx.h"
#include "script.h"

#include <initguid.h>
#include <InetCom.h>
#include <LogType.h>
#include <ILogObj.hxx>

#include <limits.h>

#include <iadmw.h>
#include <iiscnfg.h>

#include <atlimpl.cpp>

#include "LogScripting.h"


#ifdef _NO_TRACING_
DECLARE_DEBUG_VARIABLE();
#endif
DECLARE_DEBUG_PRINTS_OBJECT();

const   int MB_TIMEOUT = 5000;

/////////////////////////////////////////////////////////////////////////////
// CLogScripting


CLogScripting::CLogScripting(VOID)
:
    m_iNumPlugins           ( -1),
    m_iReadPlugin           ( -1),
    m_iWritePlugin          ( -1),
    m_pPluginInfo           ( NULL),
    m_fDirectory            ( false),
    m_fEndOfReadRecords     ( true),
    m_StartDateTime         ( LONG_MIN),
    m_EndDateTime           ( LONG_MAX),
    m_hDirSearchHandle      ( INVALID_HANDLE_VALUE)
{
    m_wcsReadFileName[0]      = 0;
    m_wcsReadDirectoryName[0] = 0;
}

/* ************************************************************************* */
/* ************************************************************************* */

HRESULT CLogScripting::FinalConstruct()
{
    m_pMBCom        = NULL;

    ::CoCreateInstance(GETAdminBaseCLSID(TRUE), NULL, CLSCTX_LOCAL_SERVER, 
                       IID_IMSAdminBase, (void **)(&m_pMBCom));

    if (m_pMBCom)
    {
        CreateAllPlugins();
    }

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

void CLogScripting::FinalRelease()
{
    if ( m_pMBCom )
    {
        m_pMBCom->Release();
        m_pMBCom = NULL;
    }

    for(int i=0; i< m_iNumPlugins; i++)
    {
        if ( NULL != m_pPluginInfo[i].pILogScripting)
        {
            m_pPluginInfo[i].pILogScripting->CloseLogFiles(AllOpenFiles);
            m_pPluginInfo[i].pILogScripting->Release();
            m_pPluginInfo[i].pILogScripting = NULL;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
//                  Private Methods of CLogScripting
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

int CLogScripting:: CreateAllPlugins()
{
    int         i,j = 0;
    HRESULT     hr;

    typedef     ILogScripting *pILogScripting;
    
    m_iNumPlugins   = 0;

    if (GetListOfAvailablePlugins() && (m_iNumPlugins > 0))
    {
        //
        // Load all the plugins
        //

        for (i=j=0; i<m_iNumPlugins; i++)
        {
            hr = ::CoCreateInstance(m_pPluginInfo[i].clsid, NULL, CLSCTX_INPROC_SERVER, 
                        IID_ILogScripting, (void **)(& m_pPluginInfo[i].pILogScripting));

            if (SUCCEEDED(hr))
            {
                j++;
            }
            else
            {
                m_pPluginInfo[i].pILogScripting = NULL;
            }
        }
    }

    return j;           // Number of plugins successfully created.
}

/* ************************************************************************* */
/* ************************************************************************* */

bool CLogScripting::GetListOfAvailablePlugins()           
{
    USES_CONVERSION;

    m_pPluginInfo = new PLUGIN_INFO[4];
    
    if( m_pPluginInfo == NULL )
    {
        return false;
    }

    wcscpy(m_pPluginInfo[0].wcsFriendlyName, L"NCSA Common Log File Format");
    CLSIDFromString(A2W(NCSALOG_CLSID), &m_pPluginInfo[0].clsid);

    wcscpy(m_pPluginInfo[1].wcsFriendlyName, L"ODBC Logging");
    CLSIDFromString(A2W(ODBCLOG_CLSID), &m_pPluginInfo[1].clsid);

    wcscpy(m_pPluginInfo[2].wcsFriendlyName, L"Microsoft IIS Log File Format");
    CLSIDFromString(A2W(ASCLOG_CLSID), &m_pPluginInfo[2].clsid);

    wcscpy(m_pPluginInfo[3].wcsFriendlyName, L"W3C Extended Log File Format");
    CLSIDFromString(A2W(EXTLOG_CLSID), &m_pPluginInfo[3].clsid);

    m_iNumPlugins = 4;

    return true;
}

/* ************************************************************************* */
/* ************************************************************************* */

bool CLogScripting::GetNextFileName()
{

   	WIN32_FIND_DATAW	stFindFileData;
    PFileListEntry      pFileInfo;

    if (NULL == m_hDirSearchHandle)
    {
        return false;
    }

    if (INVALID_HANDLE_VALUE == m_hDirSearchHandle)
    {
        //
        // This is the first/new call. Clean up file Q by removing old file information.
        //

        while(! m_fQueue.empty())
        {
            pFileInfo = m_fQueue.top();
            m_fQueue.pop();
            delete pFileInfo;
        }

        //
        // Loop till we enumerate all files in this directory
        //

        WCHAR   wcsSearchPath[MAX_PATH+1];

        wcscpy(wcsSearchPath, m_wcsReadDirectoryName);
        wcscat(wcsSearchPath, L"\\*");

        if (m_hDirSearchHandle)
        {
            FindClose(m_hDirSearchHandle);
        }

        m_hDirSearchHandle = FindFirstFileW(wcsSearchPath, &stFindFileData);

        do
        {
            if (! (stFindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                pFileInfo = new FileListEntry;

                pFileInfo->Copy(stFindFileData);
                m_fQueue.push(pFileInfo);
            }
        }
        while ( FindNextFileW(m_hDirSearchHandle, &stFindFileData) );
    }


    //
    // Pop the lowest timestamp file
    //
    
    pFileInfo = NULL;

    if (! m_fQueue.empty())
    {
        pFileInfo = m_fQueue.top();
        m_fQueue.pop();
    }

    if (NULL == pFileInfo)
    {
        //
        // We have run out of files or some error occured. Prevent another search.
        //

        FindClose(m_hDirSearchHandle);
        m_hDirSearchHandle = NULL;
        m_wcsReadFileName[0] = 0;
        return false;
    }
    else
    {
        wcscpy(m_wcsReadFileName, m_wcsReadDirectoryName);
        wcscat(m_wcsReadFileName, L"\\");
        wcscat(m_wcsReadFileName, pFileInfo->wcsFileName);
        delete pFileInfo;
        return true;
    }
}

/* ************************************************************************* */
/* ************************************************************************* */

int CLogScripting::ParseLogFile()
{

    if (m_wcsReadFileName[0] == 0)
    {
        return INVALID_PLUGIN;
    }
    
    //
    // Linear search thru all plugins
    //

    for(int i=0; i < m_iNumPlugins; i++)
    {
        if ( m_pPluginInfo[i].pILogScripting != NULL )
        {
            m_pPluginInfo[i].pILogScripting->OpenLogFile(
                                                W2BSTR(m_wcsReadFileName),
                                                ForReading,
                                                L"",
                                                0,
                                                L""
                                             );

            if ( SUCCEEDED(m_pPluginInfo[i].pILogScripting->ReadLogRecord()) )
            {
                return i;
            }

            m_pPluginInfo[i].pILogScripting->CloseLogFiles(ForReading);
        }
    }

    //
    // None of the registered plugins knows how to read the log file. Sorry !!
    //

    return INVALID_PLUGIN;
}

/* ************************************************************************* */
/* ************************************************************************* */

HRESULT CLogScripting::InternalReadLogRecord()
{
    DATE    logDateTime = 0;
    HRESULT hr          = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);

    if (!m_fDirectory)
    {
        //
        // Simple case. Not a directory.
        //

        if ( INVALID_PLUGIN == m_iReadPlugin )
        {
            //
            // First use. Find a plugin to read the file.
            //

            if ( (m_iReadPlugin = ParseLogFile()) != INVALID_PLUGIN)
            {
                hr = S_OK;
            }

        }
        else
        {
            //
            // Read next record
            //

            hr =  m_pPluginInfo[m_iReadPlugin].pILogScripting->ReadLogRecord();
        }
    }
    else
    {
        //
        // Directory case
        //

        if (m_iReadPlugin != INVALID_PLUGIN)
        {
            hr =  m_pPluginInfo[m_iReadPlugin].pILogScripting->ReadLogRecord();

            if (SUCCEEDED(hr))
            {
                goto returnlabel;
            }
        }

        //
        // Either this is the first use or the last read failed
        //

        while (GetNextFileName())
        {
            if ( (m_iReadPlugin = ParseLogFile()) != INVALID_PLUGIN)
            {
                hr = S_OK;
                break;
            }
        }
    }

returnlabel:

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
//                  Methods of ILogRead
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CLogScripting::OpenLogFile(
    BSTR    szLogFileName,
    IOMode  Mode,
    BSTR    szServiceName,
    long    iServiceInstance,
    BSTR    szOutputLogFileFormat
)
{
    DWORD       dwFileAttrib;
    HRESULT     hr = E_INVALIDARG;
    WCHAR       szFilePath[MAX_PATH+1];

    BOOL  fHasFileName    = (( NULL != szLogFileName) && ( 0 != szLogFileName[0]));
    BOOL  fHasServiceName = (( NULL != szServiceName) && ( 0 != szServiceName[0]));

    BOOL  fHasOutputFormatName  = (( NULL != szOutputLogFileFormat) && 
                                   ( 0 != szOutputLogFileFormat[0]));
    
	CloseLogFiles(Mode);                                   
	
    if (ForReading == Mode)
    {
        //
        // If the File Name isn't specified but Service Name & ID are, get
        // the appropriate log directory and use that as the log file name.
        //

        if ( (!fHasFileName) && fHasServiceName && ( 0 != iServiceInstance))
        {
        
            METADATA_HANDLE     hMeta   = NULL;
            METADATA_RECORD     mdRecord;
            WCHAR               szTemp[MAX_PATH+1] = L"/LM/";
            DWORD               dwRequiredLen;

            if (m_pMBCom == NULL)
            {
                hr = E_FAIL;
                goto cleanup;
            }

           wcscat(szTemp, szServiceName);
           wcscat(szTemp, L"/");
           _ltow(iServiceInstance, szTemp+wcslen(szTemp),10);

            hr = m_pMBCom->OpenKey( METADATA_MASTER_ROOT_HANDLE, szTemp,
                                    METADATA_PERMISSION_READ, MB_TIMEOUT, &hMeta);

            if ( FAILED(hr))
            {
                goto cleanup;
            }

            //
            // prepare the metadata record for reading
            //

            mdRecord.dwMDIdentifier  = MD_LOGFILE_DIRECTORY;
            mdRecord.dwMDAttributes  = METADATA_INHERIT;
            mdRecord.dwMDUserType    = IIS_MD_UT_SERVER;
            mdRecord.dwMDDataType    = EXPANDSZ_METADATA;
            mdRecord.pbMDData        = (PBYTE)szTemp;
            mdRecord.dwMDDataLen     = MAX_PATH;

            hr = m_pMBCom->GetData(hMeta, L"", &mdRecord, &dwRequiredLen);
            m_pMBCom->CloseKey(hMeta);

            if ( FAILED(hr))
            {
                goto cleanup;
            }
            
            //
            //  Expand system variables used in this path.
            //

            if (ExpandEnvironmentStringsW(szTemp, szFilePath, MAX_PATH+1) != 0)
            {
                if ( wcslen(szFilePath) > MAX_PATH-wcslen(szServiceName)-10 )
                {
                    hr = E_OUTOFMEMORY;
                    goto cleanup;
                }

                wcscat(szFilePath,L"\\");
                wcscat(szFilePath,szServiceName);
                _ltow(iServiceInstance, szFilePath+wcslen(szFilePath),10);
                wcscat(szFilePath,L"\\");
                szLogFileName = szFilePath;
            }
        }
    }

    //
    // At this point szLogFileName should be defined.
    //

    hr = E_INVALIDARG;
    
    if ( (NULL == szLogFileName ) || ( 0 == szLogFileName[0]) ||
         ((ForReading != Mode ) && (ForWriting != Mode))
       )
    {
        goto cleanup;
    }

    if (ForReading == Mode)
    {
        //
        // Reset EOF flag
        //

        m_fEndOfReadRecords = false;
        
		//
		// Check if this is a valid file and/or a directory
		//

		if ( 0xFFFFFFFF != (dwFileAttrib = GetFileAttributesW(szLogFileName)) )
		{
			if (dwFileAttrib & FILE_ATTRIBUTE_DIRECTORY)
			{
				// This is a directory
    
				m_fDirectory = true;
				wcscpy(m_wcsReadDirectoryName, szLogFileName);
			}
			else
			{
			   wcscpy(m_wcsReadFileName, szLogFileName);
			}

			hr = S_OK;
		}
		else
		{
			// couldn't get file attributes. check for error code

			hr = HRESULT_FROM_WIN32(GetLastError());
		}
    }
    else
    {
        //
        // Find the correct plugin & set the value. If user didn't specify file format use W3C
        //

        if ( ( NULL == szOutputLogFileFormat) || 
             ( 0 == *szOutputLogFileFormat)
           )
        {
            //
            // Search based on the clsid of W3C Logging
            //
            
            for(int i=0; i< m_iNumPlugins; i++)
            {
                if ( (CLSID_EXTLOG  == m_pPluginInfo[i].clsid) &&
                     (NULL  != m_pPluginInfo[i].pILogScripting)
                   )
                {
                    m_iWritePlugin = i;
                    break;
                }
            }
        }
        else
        {

            //
            // Search based on format name provided by the user
            //
            
            for(int i=0; i< m_iNumPlugins; i++)
            {
                if ( (0     == _wcsicmp(m_pPluginInfo[i].wcsFriendlyName, 
                                        szOutputLogFileFormat)) &&
                     (NULL  != m_pPluginInfo[i].pILogScripting)
                   )
                {
                    m_iWritePlugin = i;
                    break;
                }
            }
        }

        if (0 <= m_iWritePlugin)
        {
            hr = m_pPluginInfo[m_iWritePlugin].pILogScripting->OpenLogFile( 
                                                W2BSTR(szLogFileName), 
                                                Mode,
                                                L"",
                                                0,
                                                L"");
        }
    }
    
cleanup:

    /*
    fix for bug 364649:
    No need to do that becuase oleaut does some thicks with mem allocation and free.
    That's true for both cscirtp and ASP, so I choose to remove these deltions. Even if 
    I am wrong, and it necesasry to free somehow that string, it is better to leak ~20 bytes than
    AV or currupt memory while deleting what was not allocated by sysallocstring

    if (fHasFileName)
    {
        SysFreeString(szLogFileName);
    }
    if (fHasServiceName)
    {
        SysFreeString(szServiceName);
    }
    if (fHasOutputFormatName)
    {
        SysFreeString(szOutputLogFileFormat);
    }
    */
    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::CloseLogFiles(IOMode Mode)
{
    if ((ForReading == Mode) || (AllOpenFiles == Mode))
    {
        if (m_iReadPlugin != INVALID_PLUGIN)
        {
            m_pPluginInfo[m_iReadPlugin].pILogScripting->CloseLogFiles(ForReading);
        }

        m_iReadPlugin               = INVALID_PLUGIN;           // Reset Plugin in Use
        m_fDirectory                = false;                
        m_hDirSearchHandle          = INVALID_HANDLE_VALUE;     // Reset Search Handle
        m_wcsReadFileName[0]        = 0;
        m_wcsReadDirectoryName[0]   = 0;
    }

    if ((ForWriting == Mode) || (AllOpenFiles == Mode))
    {
        if (m_iWritePlugin != INVALID_PLUGIN)
        {
            m_pPluginInfo[m_iWritePlugin].pILogScripting->CloseLogFiles(ForWriting);
        }

        m_iWritePlugin = INVALID_PLUGIN;                        // Reset Plugin in Use
    }

	return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::ReadFilter( DATE startDateTime,  DATE endDateTime)
{
    m_StartDateTime = startDateTime;
    m_EndDateTime   = endDateTime;

    return S_OK;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::ReadLogRecord()
{
    HRESULT hr          = E_FAIL;
    VARIANT logDateTime = {0};

    if ( m_fEndOfReadRecords )
    {
        return S_OK;
    }

    //
    // Read the next record. Only return records between the start & end times.
    //

    while ( SUCCEEDED( hr = InternalReadLogRecord() ) )
    {
        if ( SUCCEEDED(m_pPluginInfo[m_iReadPlugin].pILogScripting->get_DateTime(&logDateTime)) )
        {
            if ( (m_StartDateTime > logDateTime.date) || (m_EndDateTime < logDateTime.date))
            {
                //
                // Read next record
                //

                continue;
            }
        }

        break;
    }

    if ( FAILED(hr))
    {
        m_fEndOfReadRecords = true;
        hr = S_OK;
    }
    
    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::AtEndOfLog(VARIANT_BOOL *pfEndOfRead)
{
    DBG_ASSERT( NULL != pfEndOfRead);

    *pfEndOfRead = m_fEndOfReadRecords;
    return S_OK;
}


/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::WriteLogRecord(ILogScripting * pILogScripting)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pILogScripting);

    if (m_iWritePlugin >= 0)
    {
        hr = m_pPluginInfo[m_iWritePlugin].pILogScripting->WriteLogRecord(pILogScripting);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_DateTime(VARIANT * pvarDateTime)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarDateTime);

    if (m_fEndOfReadRecords)
    {
        pvarDateTime->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_DateTime(pvarDateTime);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_ServiceName(VARIANT * pvarServiceName)
{

    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarServiceName);

    if (m_fEndOfReadRecords)
    {
        pvarServiceName->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_ServiceName(pvarServiceName);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_ServerName(VARIANT * pvarServerName)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarServerName);

    if (m_fEndOfReadRecords)
    {
        pvarServerName->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_ServerName(pvarServerName);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_ClientIP(VARIANT * pvarClientIP)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarClientIP);

    if (m_fEndOfReadRecords)
    {
        pvarClientIP->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_ClientIP(pvarClientIP);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_UserName(VARIANT * pvarUserName)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarUserName);

    if (m_fEndOfReadRecords)
    {
        pvarUserName->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_UserName(pvarUserName);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_ServerIP(VARIANT * pvarServerIP)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarServerIP);

    if (m_fEndOfReadRecords)
    {
        pvarServerIP->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_ServerIP(pvarServerIP);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_Method(VARIANT * pvarMethod)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarMethod);

    if (m_fEndOfReadRecords)
    {
        pvarMethod->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_Method(pvarMethod);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_URIStem(VARIANT * pvarURIStem)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarURIStem);

    if (m_fEndOfReadRecords)
    {
        pvarURIStem->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_URIStem(pvarURIStem);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_URIQuery(VARIANT * pvarURIQuery)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarURIQuery);

    if (m_fEndOfReadRecords)
    {
        pvarURIQuery->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_URIQuery(pvarURIQuery);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_TimeTaken(VARIANT * pvarTimeTaken)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarTimeTaken);

    if (m_fEndOfReadRecords)
    {
        pvarTimeTaken->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_TimeTaken(pvarTimeTaken);
    }
    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_BytesSent(VARIANT * pvarBytesSent)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarBytesSent);

    if (m_fEndOfReadRecords)
    {
        pvarBytesSent->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_BytesSent(pvarBytesSent);
    }
    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_BytesReceived(VARIANT * pvarBytesReceived)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarBytesReceived);

    if (m_fEndOfReadRecords)
    {
        pvarBytesReceived->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_BytesReceived(pvarBytesReceived);
    }
    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_Win32Status(VARIANT * pvarWin32Status)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarWin32Status);

    if (m_fEndOfReadRecords)
    {
        pvarWin32Status->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_Win32Status(pvarWin32Status);
    }
    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_ProtocolStatus(VARIANT * pvarProtocolStatus)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarProtocolStatus);

    if (m_fEndOfReadRecords)
    {
        pvarProtocolStatus->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_ProtocolStatus(pvarProtocolStatus);
    }
    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_ServerPort(VARIANT * pvarServerPort)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarServerPort);

    if (m_fEndOfReadRecords)
    {
        pvarServerPort->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_ServerPort(pvarServerPort);
    }
    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_ProtocolVersion(VARIANT * pvarProtocolVersion)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarProtocolVersion);

    if (m_fEndOfReadRecords)
    {
        pvarProtocolVersion->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_ProtocolVersion(pvarProtocolVersion);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_UserAgent(VARIANT * pvarUserAgent)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarUserAgent);

    if (m_fEndOfReadRecords)
    {
        pvarUserAgent->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_UserAgent(pvarUserAgent);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_Cookie(VARIANT * pvarCookie)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarCookie);

    if (m_fEndOfReadRecords)
    {
        pvarCookie->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_Cookie(pvarCookie);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_Referer(VARIANT * pvarReferer)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarReferer);

    if (m_fEndOfReadRecords)
    {
        pvarReferer->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_Referer(pvarReferer);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */

STDMETHODIMP 
CLogScripting::get_CustomFields(VARIANT * pvarCustomFieldsArray)
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT( NULL != pvarCustomFieldsArray);

    if (m_fEndOfReadRecords)
    {
        pvarCustomFieldsArray->vt = VT_NULL;
        return S_OK;
    }

    if (m_iReadPlugin >= 0)
    {
        hr = m_pPluginInfo[m_iReadPlugin].pILogScripting->get_CustomFields(pvarCustomFieldsArray);
    }

    return hr;
}

/* ************************************************************************* */
/* ************************************************************************* */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\scripting\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B758F2FF_A3D6_11D1_8B9C_080009DCC2FA__INCLUDED_)
#define AFX_STDAFX_H__B758F2FF_A3D6_11D1_8B9C_080009DCC2FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _ATL_APARTMENT_THREADED

#define DEFAULT_TRACE_FLAGS     (DEBUG_ERROR)

#include <dbgutil.h>

#ifdef _ASSERTE
#undef _ASSERTE
#endif

#define _ASSERTE    DBG_ASSERT

#ifndef _ATL_NO_DEBUG_CRT
#define _ATL_NO_DEBUG_CRT
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B758F2FF_A3D6_11D1_8B9C_080009DCC2FA__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\scripting\logscripting.h ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
      logscripting.h

   Abstract:
      LogScripting.cpp : Declaration of the CLogScripting
                         Automation compatible logging interface

   Author:

       Saurab Nog    ( saurabn )    01-Feb-1998

   Project:

       IIS Logging 5.0

--*/

#ifndef _LOGSCRIPTING_
#define _LOGSCRIPTING_

#include "resource.h"       // main symbols

#pragma warning (disable: 4786 4788)

#include <algorithm>
#include <queue>
#include <deque>
#include <functional>

#define  INVALID_PLUGIN  -1

/////////////////////////////////////////////////////////////////////////////
// CLogScripting
class ATL_NO_VTABLE CLogScripting : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CLogScripting, &CLSID_LogScripting>,
	public IDispatchImpl<ILogScripting, &IID_ILogScripting, &LIBID_IISLog>
{
public:
	CLogScripting();
    HRESULT FinalConstruct();
	void FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_LOGSCRIPTING)
DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CLogScripting)
	COM_INTERFACE_ENTRY(ILogScripting)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

private:
    
    struct FileListEntry
    {
        WCHAR       wcsFileName[MAX_PATH+1];
        FILETIME    ftCreationTime;

        void Copy(const WIN32_FIND_DATAW& x)
        {
            wcscpy( wcsFileName, x.cFileName);
            memcpy( &ftCreationTime, &x.ftCreationTime, sizeof(FILETIME));
        }
    };

    typedef struct FileListEntry *PFileListEntry;

    struct FileTimeCompare
    {
        //
        // We need ascending order. So bigger TimeStamp is smaller
        //

        bool operator()(const PFileListEntry x, const PFileListEntry y) const
        {
            return ( CompareFileTime(&(x->ftCreationTime), &(y->ftCreationTime)) != -1);
        }
    };

    typedef std::priority_queue<PFileListEntry, std::vector<PFileListEntry>, FileTimeCompare>    
    FileQ;

private:

    //
    // Metabase pointer
    //

    IMSAdminBase*   m_pMBCom;

    //
    // Plugin information
    //

    typedef struct
    {
        ILogScripting * pILogScripting;
        CLSID           clsid;
        WCHAR           wcsFriendlyName[256];
    }
    PLUGIN_INFO, *PPLUGIN_INFO;

    int             m_iNumPlugins, m_iReadPlugin, m_iWritePlugin;
    PPLUGIN_INFO    m_pPluginInfo;

    //
    // File Path Information
    //

    bool            m_fDirectory;
    HANDLE          m_hDirSearchHandle;
    WCHAR           m_wcsReadFileName[MAX_PATH+1], m_wcsReadDirectoryName[MAX_PATH+1];

    //
    // Log Time Information
    //
    
    DATE            m_StartDateTime;
    DATE            m_EndDateTime;

    //
    // Flag to indicate end of Records
    //

    bool            m_fEndOfReadRecords;

    //
    // Directory listing
    //

    FileQ           m_fQueue;

    //
    //  Private member functions
    //

    int     ParseLogFile();
    bool    GetNextFileName();

    int     CreateAllPlugins();
    bool    GetListOfAvailablePlugins(); 

    HRESULT InternalReadLogRecord();

public:

    //
    // ILogScripting: Copied from the header file generated by MIDL.
    //

    virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE OpenLogFile( 
        /* [in] */                          BSTR    szLogFileName,
        /* [defaultvalue][optional][in] */  IOMode  Mode                  = ForReading,
        /* [defaultvalue][optional][in] */  BSTR    szServiceName         = L"", 
        /* [defaultvalue][optional][in] */  long    iServerInstance       = 0,
        /* [defaultvalue][optional][in] */  BSTR    szOutputLogFileFormat = L"");
    
    virtual /* [helpstring][id] */          HRESULT STDMETHODCALLTYPE CloseLogFiles( 
        /* [defaultvalue][optional][in] */  IOMode  Mode = AllOpenFiles);
    
    virtual /* [helpstring][id] */          HRESULT STDMETHODCALLTYPE ReadFilter( 
        /* [defaultvalue][optional][in] */  DATE    startDateTime = 0,
        /* [defaultvalue][optional][in] */  DATE    endDateTime   = 1000000);
    
    virtual /* [helpstring][id] */          HRESULT STDMETHODCALLTYPE ReadLogRecord( void);
    
    virtual /* [helpstring][id] */          HRESULT STDMETHODCALLTYPE AtEndOfLog( 
        /* [retval][ref][out] */            VARIANT_BOOL __RPC_FAR *pfEndOfRead);
    
    virtual /* [helpstring][id] */          HRESULT STDMETHODCALLTYPE WriteLogRecord( 
        /* [in] */                          ILogScripting __RPC_FAR *pILogScripting);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DateTime( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarDateTime);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServiceName( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarServiceName);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServerName( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarServerName);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClientIP( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarClientIP);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UserName( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarUserName);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServerIP( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarServerIP);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Method( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarMethod);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_URIStem( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarURIStem);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_URIQuery( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarURIQuery);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TimeTaken( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarTimeTaken);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BytesSent( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarBytesSent);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BytesReceived( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarBytesReceived);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Win32Status( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarWin32Status);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ProtocolStatus( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarProtocolStatus);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ServerPort( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarServerPort);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ProtocolVersion( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarProtocolVersion);

    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UserAgent( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarUserAgent);
        
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Cookie( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarCookie);
        
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Referer( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarReferer);
    
    virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CustomFields( 
        /* [retval][ref][out] */            VARIANT __RPC_FAR *pvarCustomFieldsArray);


};

#endif //_LOGSCRIPTING_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\scripting\script.cpp ===
// script.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To merge the proxy/stub code into the object DLL, add the file 
//		dlldatax.c to the project.  Make sure precompiled headers 
//		are turned off for this file, and add _MERGE_PROXYSTUB to the 
//		defines for the project.  
//
//		If you are not running WinNT4.0 or Win95 with DCOM, then you
//		need to remove the following define from dlldatax.c
//		#define _WIN32_WINNT 0x0400
//
//		Further, if you are running MIDL without /Oicf switch, you also 
//		need to remove the following define from dlldatax.c.
//		#define USE_STUBLESS_PROXY
//
//		Modify the custom build rule for script.idl by adding the following 
//		files to the Outputs.
//			script_p.c
//			dlldata.c
//		To build a separate proxy/stub DLL, 
//		run nmake -f scriptps.mk in the project directory.

#include "stdafx.h"

#include "resource.h"
#include "script.h"
#include "dlldatax.h"

#include "script_i.c"
#include <iadmw.h>
#include "LogScripting.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CHAR    g_szModuleName[] = "LogScript";

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_LogScripting, CLogScripting)
END_OBJECT_MAP()

#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisLogScriptGuid, 
0x784d8910, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#endif

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	lpReserved;
#ifdef _MERGE_PROXYSTUB
	if (!PrxDllMain(hInstance, dwReason, lpReserved))
		return FALSE;
#endif
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
        
#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT(g_szModuleName);
        SET_DEBUG_FLAGS(DEBUG_ERROR);
#else
        CREATE_DEBUG_PRINT_OBJECT(g_szModuleName, IisLogScriptGuid);
#endif

	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        DELETE_DEBUG_PRINT_OBJECT();
		_Module.Term();
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllCanUnloadNow() != S_OK)
		return S_FALSE;
#endif
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
	if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
		return S_OK;
#endif
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	HRESULT hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
	PrxDllUnregisterServer();
#endif
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\log\server\logging.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :
      Logging.cxx

   Abstract:
      Server Side logging object
      It is just a thin layer to call COMLOG

   Author:

       Terence Kwan    ( terryk )    18-Sep-1996

   Project:

       IIS Logging 3.0

--*/

#include "server.hxx"

#define SZ_COMLOG_DLL        "iscomlog.dll"

//
// Global dll entry points
//

P_ComLogInitializeLog       LOGGING::m_ComLogInitializeLog = NULL;
P_ComLogTerminateLog        LOGGING::m_ComLogTerminateLog = NULL;
P_ComLogLogInformation      LOGGING::m_ComLogLogInformation = NULL;
P_ComLogGetConfig           LOGGING::m_ComLogGetConfig = NULL;
P_ComLogSetConfig           LOGGING::m_ComLogSetConfig = NULL;
P_ComLogQueryExtraLogFields LOGGING::m_ComLogQueryExtraLogFields = NULL;
P_ComLogNotifyChange        LOGGING::m_ComLogNotifyChange = NULL;
P_ComLogCustomInformation   LOGGING::m_ComLogCustomInformation = NULL;

//
// initialize comlog modules
//

HINSTANCE                       LOGGING::m_hComLogDLL = NULL;
P_ComLogDllStartup              LOGGING::m_ComLogDllStartup = NULL;
P_ComLogDllCleanUp              LOGGING::m_ComLogDllCleanUp = NULL;

HANDLE Dummy_ComLogInitializeLog( LPCSTR pszInstanceName, LPCSTR, LPVOID )
{
    return(NULL);
}

DWORD
Dummy_ComLogTerminateLog(
    IN HANDLE hHandle
    )
{
    return(ERROR_PROC_NOT_FOUND);
}

DWORD
Dummy_ComLogLogInformation(
        HANDLE hHandle,
        const INETLOG_INFORMATION *pInetLogInfo
        )
{
    return(ERROR_PROC_NOT_FOUND);
}

DWORD Dummy_ComLogGetConfig( HANDLE hHandle, INETLOG_CONFIGURATIONA *pConfig )
{
    return(ERROR_PROC_NOT_FOUND);
}

DWORD Dummy_ComLogSetConfig( HANDLE hHandle, const INETLOG_CONFIGURATIONA *pConfig )
{
    return(ERROR_PROC_NOT_FOUND);
}

DWORD
Dummy_ComLogQueryExtraLogFields(
            HANDLE hHandle,
            PCHAR pszFields,
            PDWORD pcbBuf
            )
{
    return(ERROR_PROC_NOT_FOUND);
}

DWORD Dummy_ComLogDllCleanUp()
{
    return(ERROR_PROC_NOT_FOUND);
}

DWORD Dummy_ComLogNotifyChange( HANDLE hHandle )
{
    return(ERROR_PROC_NOT_FOUND);
}

DWORD 
Dummy_ComLogCustomInformation( 
        IN  HANDLE              hHandle, 
        IN  DWORD               cCount, 
        IN  PCUSTOM_LOG_DATA    pCustomLogData,
        IN  LPSTR               szHeaderSuffix
        )
{
    return(ERROR_PROC_NOT_FOUND);
}

/* ------------------------------------------------------------------------------ */

LOGGING::LOGGING(
        VOID
        )
/*++

Routine Description:
    Contructor for the logging object.

Arguments:
    lpszInstanceName - name of the instance. ie, w3svc
    dwInstanceId     - id of the instance

Return Value:

--*/
{
    m_Handle = NULL;
    m_fRequiredExtraLoggingFields = FALSE;
    m_szExtraLoggingFields[0] = '\0';
    m_fMetabaseModified = FALSE;
}

LOGGING::~LOGGING()
/*++

Routine Description:
    Destructor for the logging object.

Arguments:

Return Value:

--*/
{
    //
    // end of logging object
    //

    ShutdownLogging();
}

BOOL
LOGGING::ActivateLogging(
    IN LPCSTR pszServiceName,
    IN DWORD  dwInstanceId,
    IN LPCSTR pszMetabasePath,
    IN LPVOID pvIMDCOM
    )
{
    CHAR tmpBuf[MAX_PATH];

    LockExclusive();
    
    wsprintf(tmpBuf,"%s%u", pszServiceName, dwInstanceId);

    m_strInstanceName.Copy(tmpBuf);
    m_strMetabasePath.Copy(pszMetabasePath);
    m_pvIMDCOM = pvIMDCOM;

    ShutdownLogging();          // Shut down all previous handles.
    
    if ( m_ComLogInitializeLog != NULL ) {

        m_Handle = (*m_ComLogInitializeLog)(
                            m_strInstanceName.QueryStr(),
                            m_strMetabasePath.QueryStr(),
                            pvIMDCOM
                            );
    }

    if (m_Handle != NULL ) {

        DWORD cbSize = sizeof(m_szExtraLoggingFields);

        (*m_ComLogQueryExtraLogFields)(
                            m_Handle,
                            m_szExtraLoggingFields,
                            &cbSize
                            );

        m_fRequiredExtraLoggingFields =
            (m_szExtraLoggingFields[0] != '\0');
    }

    Unlock();
    
    return TRUE;
} // LOGGING::ActivateLogging


BOOL
LOGGING::ShutdownLogging()
/*++

Routine Description:
    Terminate the log configuration information.

Arguments:

Return Value:
    err - error code.
    It will return NERR_Success if no error

--*/
{
    // if we have not terminated yet, terminate it


    LockExclusive();
    
    if (m_Handle != NULL) 
    {
        (*m_ComLogTerminateLog)( m_Handle );
        m_Handle = NULL;
    }

    Unlock();
    
    return(TRUE);
}


BOOL
LOGGING::NotifyChange(
    DWORD PropertyID
    )
/*++

Routine Description:
    Notify change in the log configuration information.

Arguments:
    PropertyID - property ID, or zero to signal end of changes

Return Value:
    err - error code.
    It will return NERR_Success if no error

--*/
{
    LockExclusive();
    
    if ( ((PropertyID >= IIS_MD_LOG_BASE) && (PropertyID <= IIS_MD_LOG_LAST)) ||
         ((PropertyID >= IIS_MD_LOGCUSTOM_BASE) && (PropertyID <= IIS_MD_LOGCUSTOM_LAST))
       )
    {
        m_fMetabaseModified = TRUE;

    } 

    Unlock();
    
    return(TRUE);
}


DWORD
LOGGING::LogInformation(
            IN const INETLOG_INFORMATION * pInetLogInfo
            )
{
    DWORD   dwErr;

    if ( m_fMetabaseModified ) 
    {
        ActOnChange();
    }

    LockShared();
    
    dwErr = ((*m_ComLogLogInformation)( m_Handle, pInetLogInfo ));

    Unlock();
    
    return dwErr;
    
} // LOGGING::LogInformation


DWORD 
LOGGING::LogCustomInformation(
            IN  DWORD               cCount, 
            IN  PCUSTOM_LOG_DATA    pCustomLogData,
            IN  LPSTR               szHeaderSuffix
            )
{
    DWORD   dwErr;

    if ( m_fMetabaseModified ) 
    {
        ActOnChange();
    }

    LockShared();

    dwErr = ((*m_ComLogCustomInformation)( m_Handle, cCount, pCustomLogData, szHeaderSuffix));

    Unlock();
    
    return dwErr;
}



DWORD
LOGGING::GetConfig(
    INETLOG_CONFIGURATIONA *pLogConfig
    )
{
    DWORD   dwErr;

    if ( m_fMetabaseModified ) 
    {
        ActOnChange();
    }

    LockShared();

    dwErr = ((*m_ComLogGetConfig)( m_Handle, pLogConfig ));

    Unlock();

    return dwErr;
}

BOOL LOGGING::IsRequiredExtraLoggingFields()
{
    if ( m_fMetabaseModified )
    {
        ActOnChange();
    }

    return m_fRequiredExtraLoggingFields;
}

CHAR *LOGGING::QueryExtraLoggingFields()
{
    if ( m_fMetabaseModified )
    {
        ActOnChange();
    }

    return m_szExtraLoggingFields;
}

VOID
LOGGING::ActOnChange()
{
    LockExclusive();

    if ( m_fMetabaseModified )
    {
        if (m_ComLogNotifyChange != NULL) {

            DWORD cbSize = sizeof(m_szExtraLoggingFields);

            (*m_ComLogNotifyChange)( m_Handle );

            //
            // See if we need extra log fields
            //

            (*m_ComLogQueryExtraLogFields)(
                                m_Handle,
                                m_szExtraLoggingFields,
                                &cbSize
                                );

            m_fRequiredExtraLoggingFields =
                (m_szExtraLoggingFields[0] != '\0');
        }

        m_fMetabaseModified = FALSE;
    }

    Unlock();
}

DWORD
LOGGING::SetConfig(
        INETLOG_CONFIGURATIONA *pRpcLogConfig
        )
{
    DWORD cbSize = sizeof(m_szExtraLoggingFields);

    LockExclusive();
    
    DWORD dwReturn = (*m_ComLogSetConfig)( m_Handle, pRpcLogConfig );

    (*m_ComLogQueryExtraLogFields)(
                    m_Handle,
                    m_szExtraLoggingFields,
                    &cbSize
                    );

    m_fRequiredExtraLoggingFields =
        (m_szExtraLoggingFields[0] != '\0');

    Unlock();
    
    return(dwReturn);
}


//
// Statics
//

DWORD
LOGGING::Terminate()
/*++

Routine Description:
    Terminate the logging object and kill the waiting queue.

Arguments:

Return Value:
    always return NO_ERROR

--*/
{
    if ( m_hComLogDLL != NULL ) {

        DBGPRINTF((DBG_CONTEXT,"Terminate: Freed iscomlog.dll\n"));

        //
        // call ComLog to terminate itself
        //

        (*m_ComLogDllCleanUp)();
        FreeLibrary( m_hComLogDLL );
        m_hComLogDLL = NULL;
    }

    return(NO_ERROR);
}


DWORD
LOGGING::Initialize()
/*++

Routine Description:
    Initialize the logging object by loading the ComLog dll and
    set up all the dll entry point

Arguments:

Return Value:
    return NO_ERROR if no error
    otherwise return ERROR_DLL_NOT_FOUND or ERROR_PROC_NOT_FOUND

--*/
{
    DWORD err = NO_ERROR;

    DBG_ASSERT(m_hComLogDLL == NULL);

    m_hComLogDLL = LoadLibrary( SZ_COMLOG_DLL );
    
    if (m_hComLogDLL!=NULL)
    {
        if ((( m_ComLogInitializeLog = (P_ComLogInitializeLog)GetProcAddress( m_hComLogDLL, (const char *)"ComLogInitializeLog")) == NULL ) ||
            (( m_ComLogTerminateLog = (P_ComLogTerminateLog)GetProcAddress( m_hComLogDLL, (const char *)"ComLogTerminateLog")) == NULL ) ||
            (( m_ComLogLogInformation = (P_ComLogLogInformation)GetProcAddress( m_hComLogDLL, (const char *)"ComLogLogInformation"))== NULL ) ||
            (( m_ComLogGetConfig = (P_ComLogGetConfig)GetProcAddress( m_hComLogDLL, (const char *)"ComLogGetConfig"))== NULL ) ||
            (( m_ComLogSetConfig = (P_ComLogSetConfig)GetProcAddress( m_hComLogDLL, (const char *)"ComLogSetConfig"))== NULL ) ||
            (( m_ComLogQueryExtraLogFields = (P_ComLogQueryExtraLogFields)GetProcAddress( m_hComLogDLL, (const char *)"ComLogQueryExtraLogFields"))== NULL ) ||
            (( m_ComLogDllStartup = (P_ComLogDllStartup)GetProcAddress(m_hComLogDLL, (const char *)"ComLogDllStartup"))== NULL ) ||
            (( m_ComLogNotifyChange = (P_ComLogNotifyChange)GetProcAddress(m_hComLogDLL, (const char *)"ComLogNotifyChange"))== NULL ) ||
            (( m_ComLogDllCleanUp = (P_ComLogDllCleanUp)GetProcAddress(m_hComLogDLL, (const char *)"ComLogDllCleanUp"))== NULL ) ||
            (( m_ComLogCustomInformation = (P_ComLogCustomInformation)GetProcAddress(m_hComLogDLL, (const char *)"ComLogCustomInformation"))== NULL )
            )
        {
            DBGPRINTF((DBG_CONTEXT,"missing entry point in ComLog dll\n"));

            m_ComLogInitializeLog       = &(Dummy_ComLogInitializeLog   );
            m_ComLogTerminateLog        = &(Dummy_ComLogTerminateLog    );
            m_ComLogLogInformation      = &(Dummy_ComLogLogInformation  );
            m_ComLogGetConfig           = &(Dummy_ComLogGetConfig       );
            m_ComLogSetConfig           = &(Dummy_ComLogSetConfig       );
            m_ComLogDllCleanUp          = &(Dummy_ComLogDllCleanUp      );
            m_ComLogNotifyChange        = &(Dummy_ComLogNotifyChange    );
            m_ComLogQueryExtraLogFields = &(Dummy_ComLogQueryExtraLogFields  );
            m_ComLogCustomInformation   = &(Dummy_ComLogCustomInformation  );

            err = ERROR_PROC_NOT_FOUND;
        } else {

            //
            // Initialize ComLog
            //

            err = (*m_ComLogDllStartup)();
        }

    } else {
        DBGPRINTF((DBG_CONTEXT,"Failed to load iscomlog.dll\n"));
        err = ERROR_DLL_NOT_FOUND;
    }

    return(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\lonsi\chicago\kernel32.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    kernel32.cxx

Abstract:

    Windows 95 stub for kernel32 functions

Author:

    Johnson Apacible    (johnsona)      13-Nov-1996

--*/


#include "lonsiw95.hxx"

#pragma hdrstop


PVOID
WINAPI
FakeInterlockedCompareExchange (
    PVOID *Destination,
    PVOID Exchange,
    PVOID Comperand
    )
{
    PVOID   oldValue;

    ACQUIRE_LOCK( &LonsiLock );

    oldValue = *Destination;

    if ( (ULONG_PTR)oldValue == (ULONG_PTR)Comperand ) {
        *Destination = Exchange;
    }
    RELEASE_LOCK( &LonsiLock );

    return(oldValue);
} // InterlockedCompareExchange


LONG
WINAPI
FakeInterlockedExchangeAdd(
    LPLONG Addend,
    LONG Value
    )
{
    LONG    oldValue;

    ACQUIRE_LOCK( &LonsiLock );

    oldValue = *Addend;
    *Addend = Value + oldValue;

    RELEASE_LOCK( &LonsiLock );

    return(oldValue);
} // InterlockedExchangeAdd


LONG
WINAPI
FakeInterlockedIncrement(
    LPLONG Addend
    )
{
    LONG    newValue;

    ACQUIRE_LOCK( &LonsiLock );

    *Addend += 1;
    newValue = *Addend;

    RELEASE_LOCK( &LonsiLock );

    return(newValue);
} // InterlockedIncrement


LONG
WINAPI
FakeInterlockedDecrement(
    LPLONG Addend
    )
{
    LONG    newValue;

    ACQUIRE_LOCK( &LonsiLock );

    *Addend -= 1;
    newValue = *Addend;

    RELEASE_LOCK( &LonsiLock );

    return(newValue);
} // InterlockedDecrement
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\lonsi\chicago\logon32.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    logon32.cxx

Abstract:

    Provide a replacement for LogonUser to login a user
    as a net logon. Also support sub-authentication DLL IDs

Author:

    Philippe Choquier (phillich)    10-january-1996
    Created from base\advapi\logon32.c

--*/


#include "lonsiw95.hxx"
#include "svcloc.h"
#include "tslogon.hxx"
#include "lonsi.hxx"

#pragma hdrstop

BOOL
IISLogon32Initialize(
    IN PVOID    hMod,
    IN ULONG    Reason,
    IN PCONTEXT Context)
/*++

Routine Description:

    Initializes the critical section

Arguments:

    hMod -- reserved, must be NULL
    Reason -- DLL_PROCESS_ATTACH or DLL_PROCESS_DETACH
    Context -- reserved, must be NULL

Returns:

    TRUE if initialization success, else FALSE

--*/
{
    return(TRUE);
}


BOOL
WINAPI
IISLogonNetUserW(
    PWSTR           lpszUsername,
    PWSTR           lpszDomain,
    PSTR            lpszPassword,
    PWSTR           lpszWorkstation,
    DWORD           dwSubAuth,
    DWORD           dwLogonType,
    DWORD           dwLogonProvider,
    HANDLE *        phToken,
    LARGE_INTEGER * pExpiry
    )
/*++

Routine Description:

    Logs a user on via username and domain
    name via the LSA.

Arguments:

    lpszUsername -- user name
    lpszDomain -- domain validating the user name
    lpszPassword -- clear text password, can be empty if a sub-auth DLL
                    is used
    lpszWorkstation -- workstation requesting the login, can be NULL
                       for local workstation
    dwSubAuth -- sub-auth DLL ID
    dwLogonType -- one of LOGON32_LOGON_NETWORK, LOGON32_LOGON_IIS_NETWORK
    dwLogonProvider -- must be LOGON32_PROVIDER_DEFAULT
    phToken -- created access token
    pExpiry -- ptr to pwd expiration time

Returns:

    TRUE if success, FALSE if error

--*/
{
    DBG_ASSERT(FALSE);
    return(FALSE);
}


BOOL
WINAPI
IISLogonNetUserA(
    PSTR            lpszUsername,
    PSTR            lpszDomain,
    PSTR            lpszPassword,
    PSTR            lpszWorkstation,
    DWORD           dwSubAuth,
    DWORD           dwLogonType,
    DWORD           dwLogonProvider,
    HANDLE *        phToken,
    LARGE_INTEGER * pExpiry
    )
/*++

Routine Description:

    Logs a user on via username and domain
    name via the LSA.

Arguments:

    lpszUsername -- user name
    lpszDomain -- domain validating the user name
    lpszPassword -- clear text password, can be empty if a sub-auth DLL
                    is used
    lpszWorkstation -- workstation requesting the login, can be NULL
                       for local workstation
    dwSubAuth -- sub-auth DLL ID
    dwLogonType -- one of LOGON32_LOGON_NETWORK, LOGON32_LOGON_IIS_NETWORK
    dwLogonProvider -- must be LOGON32_PROVIDER_DEFAULT
    phToken -- created access token
    pExpiry -- ptr to pwd expiration time

Returns:

    TRUE if success, FALSE if error

--*/
{
    DBG_ASSERT(FALSE);
    return FALSE;
}


BOOL
WINAPI
IISNetUserCookieA(
    LPSTR       lpszUsername,
    DWORD       dwSeed,
    LPSTR       lpszCookieBuff,
    DWORD       dwBuffSize
    )
/*++

Routine Description:

    Compute logon validator ( to be used as password )
    for IISSuba

Arguments:

    lpszUsername -- user name
    dwSeed -- start value of cookie

Returns:

    TRUE if success, FALSE if error

--*/
{
    DBG_ASSERT(FALSE);
    return FALSE;
}


BOOL
WINAPI
IISLogonDigestUserA(
    PDIGEST_LOGON_INFO      pDigestLogonInfo,
    DWORD                   dwAlgo,
    HANDLE *                phToken
    )
/*++

Routine Description:

    Logs a user on via username and domain
    name via the LSA using Digest authentication

Arguments:
    pDigestLogonInfo - Digest parameters
    dwAlgo - Type of logon
    phToken - Filled with impersonation token upon success

Returns:

    TRUE if success, FALSE if error

--*/
{
    DBGPRINTF((DBG_CONTEXT, "IISLogonDigestUserA called\n"));
    DBG_ASSERT(FALSE);
    return(FALSE);
}



/*******************************************************************

    NAME:       GetDefaultDomainName

    SYNOPSIS:   Fills in the given array with the name of the default
                domain to use for logon validation.

    ENTRY:      pszDomainName - Pointer to a buffer that will receive
                    the default domain name.

                cchDomainName - The size (in charactesr) of the domain
                    name buffer.

    RETURNS:    TRUE if successful, FALSE if not.

    HISTORY:
        KeithMo     05-Dec-1994 Created.

********************************************************************/
BOOL
IISGetDefaultDomainName(
    CHAR  * pszDomainName,
    DWORD   cchDomainName
    )
{
    DBGPRINTF((DBG_CONTEXT, "IISGetDefaultDomainName called\n"));

    if ( cchDomainName > 0 ) {
        *pszDomainName = '\0';
    }
    return TRUE;

}  // IISGetDefaultDomainName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\lonsi\chicago\dllmain.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dllmain.cxx

Abstract:

    Main file for the Win95 LONSI(Library of Non-Standard Interfaces)

Author:

    Johnson Apacible    (johnsona)      13-Nov-1996

--*/


#include "lonsiw95.hxx"

#ifdef _NO_TRACING_
DECLARE_DEBUG_VARIABLE();
#else
#include <initguid.h>
DEFINE_GUID(IisLonsiW95, 
0x784d890C, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#endif
DECLARE_DEBUG_PRINTS_OBJECT();

CRITICAL_SECTION    LonsiLock;

extern "C"
BOOL WINAPI
DllEntry(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpvReserved
    )
{
    BOOL  fReturn = TRUE;

    switch ( dwReason ) {

    case DLL_PROCESS_ATTACH:

        INIT_LOCK( &LonsiLock );
#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT("lonsiw95");
#else
        CREATE_DEBUG_PRINT_OBJECT("lonsint", IisLonsiW95);
#endif

        if ( !VALID_DEBUG_PRINT_OBJECT()) {
            IIS_PRINTF((buff,"Cannot create debug object\n"));
            return ( FALSE);
        }

#ifdef _NO_TRACING_
        SET_DEBUG_FLAGS( DEBUG_ERROR );
#endif
        DisableThreadLibraryCalls(hDll);
        break;

    case DLL_PROCESS_DETACH:

        DELETE_DEBUG_PRINT_OBJECT();
        DELETE_LOCK( &LonsiLock );
        break;

    default:
        break ;
    }

    return ( fReturn);

} // DllEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\lonsi\chicago\security.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    security.cxx

Abstract:

    Windows 95 stub for SSPI functions

Author:

    Johnson Apacible    (johnsona)      13-Nov-1996

--*/


#include "lonsiw95.hxx"

#pragma hdrstop

#define SECURITY_WIN32
#include <sspi.h>
#include <issperr.h>


SECURITY_STATUS
SEC_ENTRY
AcceptSecurityContext(
    PCredHandle phCredential,               // Cred to base context
    PCtxtHandle phContext,                  // Existing context (OPT)
    PSecBufferDesc pInput,                  // Input buffer
    unsigned long fContextReq,              // Context Requirements
    unsigned long TargetDataRep,            // Target Data Rep
    PCtxtHandle phNewContext,               // (out) New context handle
    PSecBufferDesc pOutput,                 // (inout) Output buffers
    unsigned long SEC_FAR * pfContextAttr,  // (out) Context attributes
    PTimeStamp ptsExpiry                    // (out) Life span (OPT)
    )
{

    return(SEC_E_OK);
} // AcceptSecurityContext


SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleA(
    SEC_CHAR SEC_FAR * pszPrincipal,    // Name of principal
    SEC_CHAR SEC_FAR * pszPackage,      // Name of package
    unsigned long fCredentialUse,       // Flags indicating use
    void SEC_FAR * pvLogonId,           // Pointer to logon ID
    void SEC_FAR * pAuthData,           // Package specific data
    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
    PCredHandle phCredential,           // (out) Cred Handle
    PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    )
{
    return(SEC_E_OK);
} // AcquireCredentialsHandleA


SECURITY_STATUS SEC_ENTRY
CompleteAuthToken(
    PCtxtHandle phContext,              // Context to complete
    PSecBufferDesc pToken               // Token to complete
    )
{
    return(SEC_E_OK);
} // CompleteAuthToken


SECURITY_STATUS SEC_ENTRY
DeleteSecurityContext(
    PCtxtHandle phContext               // Context to delete
    )
{
    return(SEC_E_OK);
} // DeleteSecurityContext


SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesA(
    unsigned long SEC_FAR * pcPackages,     // Receives num. packages
    PSecPkgInfoA SEC_FAR * ppPackageInfo    // Receives array of info
    )
{
    return(SEC_E_OK);
} // EnumerateSecurityPackagesA


SECURITY_STATUS SEC_ENTRY
ImpersonateSecurityContext(
    PCtxtHandle phContext               // Context to impersonate
    )
{
    return(SEC_E_OK);
} // ImpersonateSecurityContext


SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextA(
    PCredHandle phCredential,               // Cred to base context
    PCtxtHandle phContext,                  // Existing context (OPT)
    SEC_CHAR SEC_FAR * pszTargetName,       // Name of target
    unsigned long fContextReq,              // Context Requirements
    unsigned long Reserved1,                // Reserved, MBZ
    unsigned long TargetDataRep,            // Data rep of target
    PSecBufferDesc pInput,                  // Input Buffers
    unsigned long Reserved2,                // Reserved, MBZ
    PCtxtHandle phNewContext,               // (out) New Context handle
    PSecBufferDesc pOutput,                 // (inout) Output Buffers
    unsigned long SEC_FAR * pfContextAttr,  // (out) Context attrs
    PTimeStamp ptsExpiry                    // (out) Life span (OPT)
    )
{
    return(SEC_E_OK);
} // InitializeSecurityContextA


SECURITY_STATUS SEC_ENTRY
FreeContextBuffer(
    void SEC_FAR * pvContextBuffer      // buffer to free
    )
{
    return(SEC_E_OK);
} // FreeContextBuffer


SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandle(
    PCredHandle phCredential            // Handle to free
    )
{
    return(SEC_E_OK);
} // FreeCredentialsHandle

SECURITY_STATUS SEC_ENTRY
QueryContextAttributesA(
    PCtxtHandle phContext,              // Context to query
    unsigned long ulAttribute,          // Attribute to query
    void SEC_FAR * pBuffer              // Buffer for attributes
    )
{
    return(SEC_E_OK);
} // QueryContextAttributesA

SECURITY_STATUS SEC_ENTRY
QuerySecurityContextToken(
    PCtxtHandle phContext,
    void SEC_FAR * Token
    )
{
    return(SEC_E_OK);
} // QuerySecurityContextToken


SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoA(
    SEC_CHAR SEC_FAR * pszPackageName,      // Name of package
    PSecPkgInfoA SEC_FAR *ppPackageInfo              // Receives package info
    )
{
    return(SEC_E_OK);
} // QuerySecurityPackageInfoA

SECURITY_STATUS SEC_ENTRY
RevertSecurityContext(
    PCtxtHandle phContext               // Context from which to re
    )
{
    return(SEC_E_OK);
} // RevertSecurityContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\lonsi\nt\dllmain.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dllmain.cxx

Abstract:

    Main file for the NT LONSI(Library of Non-Standard Interfaces)

Author:

    Johnson Apacible    (johnsona)      13-Nov-1996

--*/


#include "lonsint.hxx"
#include <inetsvcs.h>

#ifdef _NO_TRACING_
DECLARE_DEBUG_VARIABLE();
#else
#include <initguid.h>
DEFINE_GUID(IisLonsiNT, 
0x784d890D, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#endif
DECLARE_DEBUG_PRINTS_OBJECT();

extern CRITICAL_SECTION     Logon32Lock;

extern "C"
BOOL WINAPI
DllEntry(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpvReserved
    )
{
    BOOL  fReturn = TRUE;


    switch ( dwReason ) {

    case DLL_PROCESS_ATTACH:

#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT("lonsint");
#else
        CREATE_DEBUG_PRINT_OBJECT("lonsint", IisLonsiNT);
#endif

        if ( !VALID_DEBUG_PRINT_OBJECT()) {
            IIS_PRINTF((buff,"Cannot create debug object\n"));
            return ( FALSE);
        }

#ifdef _NO_TRACING_
        SET_DEBUG_FLAGS( DEBUG_ERROR );
#endif
        DisableThreadLibraryCalls(hDll);
        
        INITIALIZE_CRITICAL_SECTION( &Logon32Lock );

        break;

    case DLL_PROCESS_DETACH:

        DeleteCriticalSection( &Logon32Lock );

        DELETE_DEBUG_PRINT_OBJECT();
        break;

    default:
        break ;
    }

    return ( fReturn);

} // DllEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\lonsi\nt\logon32.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    logon32.cxx

Abstract:

    Provide a replacement for LogonUser to login a user
    as a net logon. Also support sub-authentication DLL IDs

Author:

    Philippe Choquier (phillich)    10-january-1996
    Created from base\advapi\logon32.c

--*/


#include "lonsint.hxx"

#pragma hdrstop

extern "C" {

#include <ntsam.h>
#include <ntlsa.h>
#include <ntmsv1_0.h>
#include <crypt.h>
#include <logonmsv.h>
#include <inetsec.h>
#define SECURITY_WIN32
#include <sspi.h>           // Security Support Provider APIs
#include <issperr.h>
}
#include <svcloc.h>
#include <lonsi.hxx>
#include <tslogon.hxx>

#if !defined(MSV1_0_RETURN_PASSWORD_EXPIRY)
#define MSV1_0_RETURN_PASSWORD_EXPIRY 0x40
#endif


//
// We dynamically load mpr.dll (no big surprise there), in order to call
// WNetLogonNotify, as defined in private\inc\mpr.h.  This prototype matches
// it -- consult the header file for all the parameters.
//
typedef (* LOGONNOTIFYFN)(LPCWSTR, PLUID, LPCWSTR, LPVOID,
                            LPCWSTR, LPVOID, LPWSTR, LPVOID, LPWSTR *);

#define LEN_ALIGN(a,b)  (((a)+b-1)&~(b-1))

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}

//
// The QuotaLimits are global, because the defaults
// are always used for accounts, based on server/wksta, and no one ever
// calls lsasetaccountquota
//

HANDLE      Logon32LsaHandle = NULL;
ULONG       Logon32MsvHandle = 0xFFFFFFFF;
WCHAR       Logon32DomainName[16] = L"";    // NOTE:  This should be DNLEN from
                                            // lmcons.h, but that would be a
                                            // lot of including
QUOTA_LIMITS    Logon32QuotaLimits;
LOGONNOTIFYFN   Logon32LogonNotify = NULL;
HINSTANCE       Logon32MprHandle = NULL;

CRITICAL_SECTION Logon32Lock;

#define LockLogon()     EnterCriticalSection( &Logon32Lock )
#define UnlockLogon()   LeaveCriticalSection( &Logon32Lock )

SID_IDENTIFIER_AUTHORITY L32SystemSidAuthority = SECURITY_NT_AUTHORITY;
SID_IDENTIFIER_AUTHORITY L32LocalSidAuthority = SECURITY_LOCAL_SID_AUTHORITY;


#define COMMON_CREATE_SUSPENDED 0x00000001  // Suspended, do not Resume()
#define COMMON_CREATE_PROCESSSD 0x00000002  // Whack the process SD
#define COMMON_CREATE_THREADSD  0x00000004  // Whack the thread SD

BOOL
IISLogon32Initialize(
    IN PVOID    hMod,
    IN ULONG    Reason,
    IN PCONTEXT Context)
/*++

Routine Description:

    Initializes the critical section

Arguments:

    hMod -- reserved, must be NULL
    Reason -- DLL_PROCESS_ATTACH or DLL_PROCESS_DETACH
    Context -- reserved, must be NULL

Returns:

    TRUE if initialization success, else FALSE

--*/
{
    return( TRUE );
}


PSID
L32CreateLogonSid(
    PLUID LogonId OPTIONAL
    )
/*++

Routine Description:

    Creates a logon sid for a new logon.

Arguments:

    LogonId -- If non NULL, on return the LUID that is part of the logon
               sid is returned here.

Returns:

    Logon SID or NULL if error

--*/
{
    NTSTATUS Status;
    ULONG   Length;
    PSID    Sid;
    LUID    Luid;

    //
    // Generate a locally unique id to include in the logon sid
    //

    Status = NtAllocateLocallyUniqueId(&Luid);
    if (!NT_SUCCESS(Status)) {
        return(NULL);
    }


    //
    // Allocate space for the sid and fill it in.
    //

    Length = RtlLengthRequiredSid(SECURITY_LOGON_IDS_RID_COUNT);

    Sid = (PSID)LocalAlloc(LMEM_FIXED, Length);

    if (Sid != NULL) {

        RtlInitializeSid(Sid, &L32SystemSidAuthority, SECURITY_LOGON_IDS_RID_COUNT);

        ASSERT(SECURITY_LOGON_IDS_RID_COUNT == 3);

        *(RtlSubAuthoritySid(Sid, 0)) = SECURITY_LOGON_IDS_RID;
        *(RtlSubAuthoritySid(Sid, 1 )) = Luid.HighPart;
        *(RtlSubAuthoritySid(Sid, 2 )) = Luid.LowPart;
    }


    //
    // Return the logon LUID if required.
    //

    if (LogonId != NULL) {
        *LogonId = Luid;
    }

    return(Sid);
}


BOOL
L32pInitLsa(
    void
    )
/*++

Routine Description:

    Initialize connection with LSA

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    char    MyName[MAX_PATH];
    char *  ModuleName;
    STRING  LogonProcessName;
    STRING  PackageName;
    ULONG   dummy;
    NTSTATUS Status;
    BOOLEAN WasEnabled;

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        return(FALSE);
    }

    if (GetModuleFileNameA(NULL, MyName, MAX_PATH))
    {
        ModuleName = strrchr(MyName, '\\');
        if (!ModuleName)
        {
            ModuleName = MyName;
        }
    }
    else
    {
        BaseSetLastNTError(STATUS_OBJECT_NAME_NOT_FOUND);
        return(FALSE);
    }


    //
    // Hookup to the LSA and locate our authentication package.
    //

    RtlInitString(&LogonProcessName, ModuleName);
    Status = LsaRegisterLogonProcess(
                 &LogonProcessName,
                 &Logon32LsaHandle,
                 &dummy
                 );


    //
    // Turn off the privilege now.
    //
    if (!WasEnabled)
    {
        (VOID) RtlAdjustPrivilege(SE_TCB_PRIVILEGE, FALSE, FALSE, &WasEnabled);
    }

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return(FALSE);
    }


    //
    // Connect with the MSV1_0 authentication package
    //
    RtlInitString(&PackageName, "MICROSOFT_AUTHENTICATION_PACKAGE_V1_0");
    Status = LsaLookupAuthenticationPackage (
                Logon32LsaHandle,
                &PackageName,
                &Logon32MsvHandle
                );

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        (VOID) LsaDeregisterLogonProcess( Logon32LsaHandle );
        Logon32LsaHandle = NULL;
        return(FALSE);
    }

    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   L32pNotifyMpr
//
//  Synopsis:   Loads the MPR DLL and notifies the network providers (like
//              csnw) so they know about this logon session and the credentials
//
//  Arguments:  [NewLogon] -- New logon information
//              [LogonId]  -- Logon ID
//
//  History:    4-24-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
L32pNotifyMpr(
    PMSV1_0_INTERACTIVE_LOGON   NewLogon,
    PLUID                       LogonId
    )
{
    MSV1_0_INTERACTIVE_LOGON    OldLogon;
    LPWSTR                      LogonScripts;
    DWORD                       status;

    if ( Logon32MprHandle == NULL )
    {
        LockLogon();

        if ( Logon32MprHandle == NULL)
        {
            Logon32MprHandle =  LoadLibrary("mpr.dll");
            if (Logon32MprHandle != NULL) {

                Logon32LogonNotify = (LOGONNOTIFYFN) GetProcAddress(
                                        Logon32MprHandle,
                                        "WNetLogonNotify");

            }
        }

        UnlockLogon();

    }

    if ( Logon32LogonNotify != NULL )
    {


        CopyMemory(&OldLogon, NewLogon, sizeof(OldLogon));

        status = Logon32LogonNotify(
                        L"Windows NT Network Provider",
                        LogonId,
                        L"MSV1_0:Interactive",
                        (LPVOID)NewLogon,
                        L"MSV1_0:Interactive",
                        (LPVOID)&OldLogon,
                        L"SvcCtl",          // StationName
                        NULL,               // StationHandle
                        &LogonScripts);     // LogonScripts

        if (status == NO_ERROR) {
            if (LogonScripts != NULL ) {
                (void) LocalFree(LogonScripts);
            }
        }

        return( TRUE );
    }

    return( FALSE );
}


NTSTATUS
L32pLogonNetUser(
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Domain,
    IN PSTRING Password,
    IN PUNICODE_STRING Workstation,
    IN DWORD dwSubAuth,
    IN PSID LogonSid,
    OUT PLUID LogonId,
    OUT PHANDLE LogonToken,
    OUT PQUOTA_LIMITS Quotas,
    OUT PVOID *pProfileBuffer,
    OUT PULONG pProfileBufferLength,
    OUT PNTSTATUS pSubStatus
    )
/*++

Routine Description:

    Wraps up the call to LsaLogonUser

Arguments:

    LsaHandle -- handle to LSA package
    AuthenticationPackage -- ID of authentication package to use
    LogonType -- Interactive, network, ...
    UserName -- User Name
    Domain -- Domain validating the user name
    Password -- clear text password, can be empty if a sub-auth package is used
    Workstation -- workstation where the login take place, can be NULL
                   if local login
    dwSubAuth -- Sub-authentication DLL ID
    LogonSid -- Logon SID for this session
    LogonId -- created logon ID
    LogonToken -- created logon token
    Quotas -- quota info
    pProfileBuffer -- account profile
    pProfileBufferLength -- account profile length
    pSubStatus -- substatus for authentication failure

Returns:

    0 if success, else NT status

--*/
{
    NTSTATUS Status;
    STRING OriginName;
    TOKEN_SOURCE SourceContext;
    PMSV1_0_LM20_LOGON MsvAuthInfo;
    PMSV1_0_LM20_LOGON MsvNetAuthInfo;
    PMSV1_0_INTERACTIVE_LOGON MsvInterAuthInfo;
    PMSV1_0_SUBAUTH_LOGON MsvSubAuthInfo;
    PVOID AuthInfoBuf;
    ULONG AuthInfoSize;
    PTOKEN_GROUPS TokenGroups;
    PSID LocalSid;
    UNICODE_STRING UnicodePassword;
    //WCHAR ComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD ComputerNameLength;

    NT_RESPONSE NtResponse;
    LM_RESPONSE LmResponse;

    union {
        LUID            Luid;
        NT_CHALLENGE    NtChallenge;
    } Challenge;

    NT_OWF_PASSWORD PasswordHash;
    OEM_STRING  LmPassword;
    UCHAR       LmPasswordBuf[ LM20_PWLEN + 1 ];
    LM_OWF_PASSWORD LmPasswordHash;


#if DBG
    if (!RtlValidSid(LogonSid))
    {
        return(STATUS_INVALID_PARAMETER);
    }
#endif

    //
    // Initialize source context structure
    //

    strncpy(SourceContext.SourceName, "IIS     ", sizeof(SourceContext.SourceName)); // LATER from res file

    Status = NtAllocateLocallyUniqueId(&SourceContext.SourceIdentifier);

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    UnicodePassword.Buffer = NULL;

    //
    // Set logon origin
    //

    RtlInitString(&OriginName, "IIS security API");

    //
    // For network logons, do the magic.
    //

    if ( LogonType == Network )
    {
#if 0
        ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;

        if (!GetComputerNameW( ComputerName, &ComputerNameLength ) )
        {
            return( STATUS_INVALID_PARAMETER );
        }
#else
        ComputerNameLength = wcslen( Workstation->Buffer );
#endif

        if (!RtlCreateUnicodeStringFromAsciiz( &UnicodePassword, Password->Buffer ))
        {
            return STATUS_NO_MEMORY;
        }

        AuthInfoSize = sizeof( MSV1_0_LM20_LOGON ) +
                        sizeof( WCHAR ) * ( wcslen( UserName->Buffer ) + 1 +
                                            wcslen( Domain->Buffer ) + 1 +
                                            ComputerNameLength + 1) +
                                            NT_RESPONSE_LENGTH +
                                            LM_RESPONSE_LENGTH ;

        MsvNetAuthInfo = (PMSV1_0_LM20_LOGON)
                         (AuthInfoBuf = RtlAllocateHeap( RtlProcessHeap(),
                                                        HEAP_ZERO_MEMORY,
                                                        AuthInfoSize ));

        if ( !MsvNetAuthInfo )
        {
            return( STATUS_NO_MEMORY );
        }

        //
        // Start packing in the string
        //

        MsvNetAuthInfo->MessageType = MsV1_0NetworkLogon;

        //
        // Copy the user name into the authentication buffer
        //

        MsvNetAuthInfo->UserName.Length =
                    (USHORT)sizeof(WCHAR)*wcslen(UserName->Buffer);
        MsvNetAuthInfo->UserName.MaximumLength =
                    MsvNetAuthInfo->UserName.Length + sizeof(WCHAR);

        MsvNetAuthInfo->UserName.Buffer = (PWSTR)(MsvNetAuthInfo+1);
        wcscpy(MsvNetAuthInfo->UserName.Buffer, UserName->Buffer);


        //
        // Copy the domain name into the authentication buffer
        //

        MsvNetAuthInfo->LogonDomainName.Length =
                     (USHORT)sizeof(WCHAR)*wcslen(Domain->Buffer);
        MsvNetAuthInfo->LogonDomainName.MaximumLength =
                     MsvNetAuthInfo->LogonDomainName.Length + sizeof(WCHAR);

        MsvNetAuthInfo->LogonDomainName.Buffer = (PWSTR)
                                     ((PBYTE)(MsvNetAuthInfo->UserName.Buffer) +
                                     MsvNetAuthInfo->UserName.MaximumLength);

        wcscpy(MsvNetAuthInfo->LogonDomainName.Buffer, Domain->Buffer);

        //
        // Copy the workstation name into the buffer
        //

        MsvNetAuthInfo->Workstation.Length = (USHORT)
                            (sizeof(WCHAR) * ComputerNameLength);

        MsvNetAuthInfo->Workstation.MaximumLength =
                            MsvNetAuthInfo->Workstation.Length + sizeof(WCHAR);

        MsvNetAuthInfo->Workstation.Buffer = (PWSTR)
                            ((PBYTE) (MsvNetAuthInfo->LogonDomainName.Buffer) +
                            MsvNetAuthInfo->LogonDomainName.MaximumLength );

        wcscpy( MsvNetAuthInfo->Workstation.Buffer, Workstation->Buffer );

        //
        // Now, generate the bits for the challenge
        //

        Status = NtAllocateLocallyUniqueId( &Challenge.Luid );

        if ( !NT_SUCCESS(Status) )
        {
            RtlFreeHeap( RtlProcessHeap(), 0, MsvNetAuthInfo );

            return( Status );
        }

        RtlCopyMemory(  MsvNetAuthInfo->ChallengeToClient,
                        & Challenge,
                        MSV1_0_CHALLENGE_LENGTH );

        //
        // Set up space for response
        //

        MsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer = (PCHAR)
                    ((PBYTE) (MsvNetAuthInfo->Workstation.Buffer) +
                    MsvNetAuthInfo->Workstation.MaximumLength );

        MsvNetAuthInfo->CaseSensitiveChallengeResponse.Length =
                            NT_RESPONSE_LENGTH;

        MsvNetAuthInfo->CaseSensitiveChallengeResponse.MaximumLength =
                            NT_RESPONSE_LENGTH;

        RtlCalculateNtOwfPassword(
                    & UnicodePassword,
                    & PasswordHash );

        RtlCalculateNtResponse(
                & Challenge.NtChallenge,
                & PasswordHash,
                & NtResponse );

        RtlCopyMemory(  MsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer,
                        & NtResponse,
                        NT_RESPONSE_LENGTH );

        //
        // Now do the painful LM compatible hash, so anyone who is maintaining
        // their account from a WfW machine will still have a password.
        //

        LmPassword.Buffer = (CHAR*)LmPasswordBuf;
        LmPassword.Length = LmPassword.MaximumLength = LM20_PWLEN + 1;

        Status = RtlUpcaseUnicodeStringToOemString(
                        & LmPassword,
                        & UnicodePassword,
                        FALSE );

        if ( NT_SUCCESS(Status) )
        {

            MsvNetAuthInfo->CaseInsensitiveChallengeResponse.Buffer = (PCHAR)
               ((PBYTE) (MsvNetAuthInfo->CaseSensitiveChallengeResponse.Buffer) +
               MsvNetAuthInfo->CaseSensitiveChallengeResponse.MaximumLength );

            MsvNetAuthInfo->CaseInsensitiveChallengeResponse.Length =
                            LM_RESPONSE_LENGTH;

            MsvNetAuthInfo->CaseInsensitiveChallengeResponse.MaximumLength =
                            LM_RESPONSE_LENGTH;


            RtlCalculateLmOwfPassword(
                        LmPassword.Buffer,
                        & LmPasswordHash );

            ZeroMemory( LmPassword.Buffer, LmPassword.Length );

            RtlCalculateLmResponse(
                        & Challenge.NtChallenge,
                        & LmPasswordHash,
                        & LmResponse );

            RtlCopyMemory(  MsvNetAuthInfo->CaseInsensitiveChallengeResponse.Buffer,
                            & LmResponse,
                            LM_RESPONSE_LENGTH );
        }
        else
        {
            //
            // If we're here, the NT (supplied) password is longer than the
            // limit allowed for LM passwords.  NULL out the field, so that
            // MSV knows not to worry about it.
            //

            RtlZeroMemory( &MsvNetAuthInfo->CaseInsensitiveChallengeResponse,
                           sizeof( STRING ) );
        }

        MsvNetAuthInfo->ParameterControl = MSV1_0_RETURN_PASSWORD_EXPIRY;
    }
    else if ( LogonType == (SECURITY_LOGON_TYPE)IIS_Network )
    {
        if (!RtlCreateUnicodeStringFromAsciiz( &UnicodePassword, Password->Buffer ))
        {
            return STATUS_NO_MEMORY;
        }

        //
        // Build logon structure for IIS network logons. We'll be using the subauth DLL
        // in this case
        //

        AuthInfoSize = sizeof(MSV1_0_SUBAUTH_LOGON) +
            sizeof(WCHAR)*(wcslen(UserName->Buffer) + 1 +
                           wcslen(Domain->Buffer)   + 1 +
                           wcslen(Workstation->Buffer) + 1 ) +
            sizeof(WCHAR)*wcslen(UnicodePassword.Buffer) +
            LEN_ALIGN(strlen(Password->Buffer),sizeof(WCHAR));

        AuthInfoBuf = RtlAllocateHeap( RtlProcessHeap(),
                                       HEAP_ZERO_MEMORY,
                                       AuthInfoSize);
        MsvSubAuthInfo = (PMSV1_0_SUBAUTH_LOGON)AuthInfoBuf;

        if (MsvSubAuthInfo == NULL) {
            return(STATUS_NO_MEMORY);
        }

        //
        // This authentication buffer will be used for a logon attempt
        //

        MsvSubAuthInfo->MessageType = MsV1_0SubAuthLogon;

        MsvSubAuthInfo->SubAuthPackageId = dwSubAuth;

        //
        // Copy the domain name into the authentication buffer
        //

        MsvSubAuthInfo->LogonDomainName.Length =
                     (USHORT)sizeof(WCHAR)*wcslen(Domain->Buffer);
        MsvSubAuthInfo->LogonDomainName.MaximumLength =
                     MsvSubAuthInfo->LogonDomainName.Length + sizeof(WCHAR);
        MsvSubAuthInfo->LogonDomainName.Buffer = (PWSTR)(MsvSubAuthInfo+1);

        wcscpy(MsvSubAuthInfo->LogonDomainName.Buffer, Domain->Buffer);


        //
        // Copy the user name into the authentication buffer
        //

        MsvSubAuthInfo->UserName.Length =
                    (USHORT)sizeof(WCHAR)*wcslen(UserName->Buffer);
        MsvSubAuthInfo->UserName.MaximumLength =
                    MsvSubAuthInfo->UserName.Length + sizeof(WCHAR);
        MsvSubAuthInfo->UserName.Buffer = (PWSTR)
                                     ((PBYTE)(MsvSubAuthInfo->LogonDomainName.Buffer) +
                                     MsvSubAuthInfo->LogonDomainName.MaximumLength);
        wcscpy(MsvSubAuthInfo->UserName.Buffer, UserName->Buffer);


        //
        // Copy the workstation
        //

        MsvSubAuthInfo->Workstation.Length =
                     (USHORT)sizeof(WCHAR)*wcslen(Workstation->Buffer);
        MsvSubAuthInfo->Workstation.MaximumLength =
                     MsvSubAuthInfo->Workstation.Length + sizeof(WCHAR);

        MsvSubAuthInfo->Workstation.Buffer = (PWSTR)
                                     ((PBYTE)(MsvSubAuthInfo->UserName.Buffer) +
                                     MsvSubAuthInfo->UserName.MaximumLength);
        wcscpy(MsvSubAuthInfo->Workstation.Buffer, Workstation->Buffer);


        memset( MsvSubAuthInfo->ChallengeToClient,
                '\0',
                sizeof(MsvSubAuthInfo->ChallengeToClient) );

        MsvSubAuthInfo->AuthenticationInfo1.Buffer =
                     ((PCHAR)(MsvSubAuthInfo->Workstation.Buffer) +
                     MsvSubAuthInfo->Workstation.MaximumLength);
        MsvSubAuthInfo->AuthenticationInfo1.Length = (USHORT)sizeof(WCHAR)*wcslen(UnicodePassword.Buffer);

        MsvSubAuthInfo->AuthenticationInfo1.MaximumLength
            = MsvSubAuthInfo->AuthenticationInfo1.Length;

        memcpy( MsvSubAuthInfo->AuthenticationInfo1.Buffer,
                UnicodePassword.Buffer,
                MsvSubAuthInfo->AuthenticationInfo1.Length );

        MsvSubAuthInfo->AuthenticationInfo2.Buffer =
                     ((PCHAR)(MsvSubAuthInfo->AuthenticationInfo1.Buffer) +
                     MsvSubAuthInfo->AuthenticationInfo1.MaximumLength);

        MsvSubAuthInfo->AuthenticationInfo2.Length = (USHORT)strlen(Password->Buffer);

        MsvSubAuthInfo->AuthenticationInfo2.MaximumLength
            = LEN_ALIGN(MsvSubAuthInfo->AuthenticationInfo2.Length,sizeof(WCHAR));

        memcpy( MsvSubAuthInfo->AuthenticationInfo2.Buffer,
                Password->Buffer,
                MsvSubAuthInfo->AuthenticationInfo2.Length );

        MsvSubAuthInfo->ParameterControl = (dwSubAuth << MSV1_0_SUBAUTHENTICATION_DLL_SHIFT)
                | MSV1_0_UPDATE_LOGON_STATISTICS
                | MSV1_0_DONT_TRY_GUEST_ACCOUNT
                | MSV1_0_CLEARTEXT_PASSWORD_ALLOWED
                | MSV1_0_RETURN_PASSWORD_EXPIRY
                | MSV1_0_SUBAUTHENTICATION_DLL_EX
                | MSV1_0_DISABLE_PERSONAL_FALLBACK
                ;

        LogonType = Network;
    }
    else
    {
        //
        // Build logon structure for non-network logons - service,
        // batch, interactive
        //

        if (!RtlCreateUnicodeStringFromAsciiz( &UnicodePassword, Password->Buffer ))
        {
            return STATUS_NO_MEMORY;
        }

        AuthInfoSize = sizeof(MSV1_0_INTERACTIVE_LOGON) +
            sizeof(WCHAR)*(wcslen(UserName->Buffer) + 1 +
                           wcslen(Domain->Buffer)   + 1 +
                           wcslen(UnicodePassword.Buffer) + 1 );

        AuthInfoBuf = RtlAllocateHeap( RtlProcessHeap(),
                                       HEAP_ZERO_MEMORY,
                                       AuthInfoSize);
        MsvInterAuthInfo = (PMSV1_0_INTERACTIVE_LOGON)AuthInfoBuf;

        if (MsvInterAuthInfo == NULL)
        {
            return STATUS_NO_MEMORY;
        }

        //
        // This authentication buffer will be used for a logon attempt
        //

        MsvInterAuthInfo->MessageType = MsV1_0InteractiveLogon;


        //
        // Copy the user name into the authentication buffer
        //

        MsvInterAuthInfo->UserName.Length =
                    (USHORT)sizeof(WCHAR)*wcslen(UserName->Buffer);
        MsvInterAuthInfo->UserName.MaximumLength =
                    MsvInterAuthInfo->UserName.Length + sizeof(WCHAR);

        MsvInterAuthInfo->UserName.Buffer = (PWSTR)(MsvInterAuthInfo+1);
        wcscpy(MsvInterAuthInfo->UserName.Buffer, UserName->Buffer);


        //
        // Copy the domain name into the authentication buffer
        //

        MsvInterAuthInfo->LogonDomainName.Length =
                     (USHORT)sizeof(WCHAR)*wcslen(Domain->Buffer);
        MsvInterAuthInfo->LogonDomainName.MaximumLength =
                     MsvInterAuthInfo->LogonDomainName.Length + sizeof(WCHAR);

        MsvInterAuthInfo->LogonDomainName.Buffer = (PWSTR)
                                     ((PBYTE)(MsvInterAuthInfo->UserName.Buffer) +
                                     MsvInterAuthInfo->UserName.MaximumLength);

        wcscpy(MsvInterAuthInfo->LogonDomainName.Buffer, Domain->Buffer);

        //
        // Copy the password into the authentication buffer
        // Hide it once we have copied it.  Use the same seed value
        // that we used for the original password in pGlobals.
        //


        MsvInterAuthInfo->Password.Length =
                     (USHORT)sizeof(WCHAR)*wcslen(UnicodePassword.Buffer);
        MsvInterAuthInfo->Password.MaximumLength =
                     MsvInterAuthInfo->Password.Length + sizeof(WCHAR);

        MsvInterAuthInfo->Password.Buffer = (PWSTR)
                                     ((PBYTE)(MsvInterAuthInfo->LogonDomainName.Buffer) +
                                     MsvInterAuthInfo->LogonDomainName.MaximumLength);

        wcscpy(MsvInterAuthInfo->Password.Buffer, UnicodePassword.Buffer);
    }

    //
    // Create logon token groups
    //

#define TOKEN_GROUP_COUNT   2 // We'll add the local SID and the logon SID

    TokenGroups = (PTOKEN_GROUPS) RtlAllocateHeap(RtlProcessHeap(), 0,
                                    sizeof(TOKEN_GROUPS) +
                  (TOKEN_GROUP_COUNT - ANYSIZE_ARRAY) * sizeof(SID_AND_ATTRIBUTES));

    if (TokenGroups == NULL) {
        RtlFreeHeap(RtlProcessHeap(), 0, AuthInfoBuf);
        return(STATUS_NO_MEMORY);
    }

    //
    // Fill in the logon token group list
    //

    Status = RtlAllocateAndInitializeSid(
                    &L32LocalSidAuthority,
                    1,
                    SECURITY_LOCAL_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &LocalSid
                    );


    TokenGroups->GroupCount = TOKEN_GROUP_COUNT;
    TokenGroups->Groups[0].Sid = LogonSid;
    TokenGroups->Groups[0].Attributes =
            SE_GROUP_MANDATORY | SE_GROUP_ENABLED |
            SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_LOGON_ID;
    TokenGroups->Groups[1].Sid = LocalSid;
    TokenGroups->Groups[1].Attributes =
            SE_GROUP_MANDATORY | SE_GROUP_ENABLED |
            SE_GROUP_ENABLED_BY_DEFAULT;

    //
    // Now try to log this one on
    //

    Status = LsaLogonUser (
                 LsaHandle,
                 &OriginName,
                 LogonType,
                 AuthenticationPackage,
                 AuthInfoBuf,
                 AuthInfoSize,
                 TokenGroups,
                 &SourceContext,
                 pProfileBuffer,
                 pProfileBufferLength,
                 LogonId,
                 LogonToken,
                 Quotas,
                 pSubStatus
                 );

    //
    // Discard token group list
    //

    RtlFreeHeap(RtlProcessHeap(), 0, TokenGroups);

    //
    // Notify all the network providers, if this is a NON network logon
    //

    if ( NT_SUCCESS( Status ) &&
         LogonType != Network &&
         LogonType != IIS_Network )
    {
        L32pNotifyMpr( (PMSV1_0_INTERACTIVE_LOGON)AuthInfoBuf, LogonId );
    }

    //
    // Discard authentication buffer
    //

    RtlFreeHeap(RtlProcessHeap(), 0, AuthInfoBuf);

    if ( UnicodePassword.Buffer != NULL )
    {
        RtlFreeUnicodeString(&UnicodePassword);
    }

    RtlFreeSid(LocalSid);

    return(Status);
}


BOOL
WINAPI
IISLogonNetUserW(
    PWSTR           lpszUsername,
    PWSTR           lpszDomain,
    PSTR            lpszPassword,
    PWSTR           lpszWorkstation,
    DWORD           dwSubAuth,
    DWORD           dwLogonType,
    DWORD           dwLogonProvider,
    HANDLE *        phToken,
    LARGE_INTEGER * pExpiry
    )
/*++

Routine Description:

    Logs a user on via username and domain
    name via the LSA.

Arguments:

    lpszUsername -- user name
    lpszDomain -- domain validating the user name
    lpszPassword -- clear text password, can be empty if a sub-auth DLL
                    is used
    lpszWorkstation -- workstation requesting the login, can be NULL
                       for local workstation
    dwSubAuth -- sub-auth DLL ID
    dwLogonType -- one of LOGON32_LOGON_NETWORK, LOGON32_LOGON_IIS_NETWORK
    dwLogonProvider -- must be LOGON32_PROVIDER_DEFAULT
    phToken -- created access token
    pExpiry -- ptr to pwd expiration time

Returns:

    TRUE if success, FALSE if error

--*/
{

    NTSTATUS    Status;
    ULONG       PackageId;
    UNICODE_STRING  Username;
    UNICODE_STRING  Domain;
    STRING      Password;
    UNICODE_STRING  Workstation;
    LUID        LogonId;
    PSID        pLogonSid;
    PVOID       Profile;
    ULONG       ProfileLength;
    NTSTATUS    SubStatus;
    SECURITY_LOGON_TYPE LogonType;
    WCHAR       achComputerName[MAX_COMPUTERNAME_LENGTH+1];

    //
    // Validate the provider
    //
    if (dwLogonProvider == LOGON32_PROVIDER_DEFAULT)
    {
        dwLogonProvider = LOGON32_PROVIDER_WINNT35;
    }

    if (dwLogonProvider != LOGON32_PROVIDER_WINNT35)
    {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return(FALSE);
    }

    switch (dwLogonType)
    {
        case LOGON32_LOGON_IIS_NETWORK:
            LogonType = (SECURITY_LOGON_TYPE)IIS_Network;
            break;

        case LOGON32_LOGON_NETWORK:
            LogonType = Network;
            break;

        case LOGON32_LOGON_INTERACTIVE:
            LogonType = Interactive;
            break;

        case LOGON32_LOGON_BATCH:
            LogonType = Batch;
            break;

        case LOGON32_LOGON_SERVICE:
            LogonType = Service;
            break;
            
        case LOGON32_LOGON_NETWORK_CLEARTEXT:
            LogonType = NetworkCleartext;
            break;

        default:
            BaseSetLastNTError(STATUS_INVALID_PARAMETER);
            return(FALSE);
            break;
    }

    if ( lpszWorkstation == NULL )
    {
        DWORD dwL = MAX_COMPUTERNAME_LENGTH+1;
        if ( !GetComputerNameW( achComputerName, &dwL ) )
        {
            return(FALSE);
        }
        lpszWorkstation = achComputerName;
    }

    //
    // If the MSV handle is -1, grab the lock, and try again:
    //

    if (Logon32MsvHandle == 0xFFFFFFFF)
    {
        LockLogon();

        //
        // If the MSV handle is still -1, init our connection to lsa.  We
        // have the lock, so no other threads can be trying this right now.
        //
        if (Logon32MsvHandle == 0xFFFFFFFF)
        {
            if (!L32pInitLsa())
            {
                UnlockLogon();
                return( FALSE );
            }
        }

        UnlockLogon();
    }

    //
    // Validate the parameters.  NULL or empty domain or NULL or empty
    // user name is invalid.
    //

    RtlInitUnicodeString(&Username, lpszUsername);
    if (Username.Length == 0)
    {
        BaseSetLastNTError(STATUS_INVALID_PARAMETER);
        return(FALSE);
    }

    RtlInitUnicodeString(&Domain, lpszDomain);
    RtlInitString(&Password, lpszPassword);

    //
    // Finally, init the workstation
    //
    RtlInitUnicodeString(&Workstation, lpszWorkstation);


    //
    // Get a logon sid to refer to this guy (not that anyone will be able to
    // use it...
    //
    pLogonSid = L32CreateLogonSid(NULL);
    if (!pLogonSid)
    {
        BaseSetLastNTError(STATUS_NO_MEMORY);
        return(FALSE);
    }


    //
    // Attempt the logon
    //
    Status = L32pLogonNetUser(
                    Logon32LsaHandle,
                    Logon32MsvHandle,
                    LogonType,
                    &Username,
                    &Domain,
                    &Password,
                    &Workstation,
                    dwSubAuth,
                    pLogonSid,
                    &LogonId,
                    phToken,
                    &Logon32QuotaLimits,
                    &Profile,
                    &ProfileLength,
                    &SubStatus);

    //
    // Done with logon sid, regardless of result:
    //

    LocalFree( pLogonSid );

    if (!NT_SUCCESS(Status))
    {
        if (Status == STATUS_ACCOUNT_RESTRICTION)
        {
            BaseSetLastNTError(SubStatus);
        }
        else
        {
            BaseSetLastNTError(Status);
        }

        return(FALSE);
    }

    if (Profile != NULL)
    {
        if ( pExpiry != NULL )
        {
            switch ( dwLogonType )
            {
                case LOGON32_LOGON_IIS_NETWORK:
                case LOGON32_LOGON_NETWORK:
                    memcpy( pExpiry,
                            &(((PMSV1_0_LM20_LOGON_PROFILE)Profile)
                                ->LogoffTime),
                            sizeof(LARGE_INTEGER) );
                    break;

                default:
                    //
                    // if pwd never expire, MustChange.HighPart == 0x7fffffff
                    // if user cannot change pwd, CanChange == LastSet
                    //

                    if ( ((PMSV1_0_INTERACTIVE_PROFILE)Profile)
                             ->PasswordMustChange.HighPart
                         != 0x7fffffff )
                    {
                        memcpy( pExpiry,
                                &(((PMSV1_0_INTERACTIVE_PROFILE)Profile)
                                  ->PasswordMustChange),
                                sizeof(LARGE_INTEGER) );
                    }
                    else
                    {
                        ((PMSV1_0_INTERACTIVE_PROFILE)Profile)
                            ->PasswordMustChange.LowPart = 0xffffffff;
                        ((PMSV1_0_INTERACTIVE_PROFILE)Profile)
                            ->PasswordMustChange.HighPart = 0x7fffffff;
                    }
                    break;
            }
        }

        LsaFreeReturnBuffer(Profile);
    }

    return(TRUE);
}


BOOL
WINAPI
IISLogonNetUserA(
    PSTR            lpszUsername,
    PSTR            lpszDomain,
    PSTR            lpszPassword,
    PSTR            lpszWorkstation,
    DWORD           dwSubAuth,
    DWORD           dwLogonType,
    DWORD           dwLogonProvider,
    HANDLE *        phToken,
    LARGE_INTEGER * pExpiry
    )
/*++

Routine Description:

    Logs a user on via username and domain
    name via the LSA.

Arguments:

    lpszUsername -- user name
    lpszDomain -- domain validating the user name
    lpszPassword -- clear text password, can be empty if a sub-auth DLL
                    is used
    lpszWorkstation -- workstation requesting the login, can be NULL
                       for local workstation
    dwSubAuth -- sub-auth DLL ID
    dwLogonType -- one of LOGON32_LOGON_NETWORK, LOGON32_LOGON_IIS_NETWORK
    dwLogonProvider -- must be LOGON32_PROVIDER_DEFAULT
    phToken -- created access token
    pExpiry -- ptr to pwd expiration time

Returns:

    TRUE if success, FALSE if error

--*/
{
    UNICODE_STRING Username;
    UNICODE_STRING Domain;
    UNICODE_STRING Workstation;
    NTSTATUS Status;
    BOOL    bRet;

    Username.Buffer = NULL;
    Domain.Buffer = NULL;
    Workstation.Buffer = NULL;

    if ( !RtlCreateUnicodeStringFromAsciiz(&Username, lpszUsername) )
    {
        bRet = FALSE;
        goto Cleanup;
    }

    if (!RtlCreateUnicodeStringFromAsciiz(&Domain, lpszDomain))
    {
        bRet = FALSE;
        goto Cleanup;
    }

    if ( lpszWorkstation )
    {
        if (!RtlCreateUnicodeStringFromAsciiz(&Workstation, lpszWorkstation))
        {
            bRet = FALSE;
            goto Cleanup;
        }
    }

    bRet = IISLogonNetUserW(
        Username.Buffer,
        Domain.Buffer,
        lpszPassword,
        Workstation.Buffer,
        dwSubAuth,
        dwLogonType,
        dwLogonProvider,
        phToken,
        pExpiry
        ) ;

Cleanup:

    if (Username.Buffer)
    {
        RtlFreeUnicodeString(&Username);
    }

    if (Domain.Buffer)
    {
        RtlFreeUnicodeString(&Domain);
    }

    if (Workstation.Buffer)
    {
        RtlFreeUnicodeString(&Workstation);
    }

    return bRet;
}


BOOL
WINAPI
IISNetUserCookieA(
    LPSTR       lpszUsername,
    DWORD       dwSeed,
    LPSTR       lpszCookieBuff,
    DWORD       dwBuffSize
    )
/*++

Routine Description:

    Compute logon validator ( to be used as password )
    for IISSuba

Arguments:

    lpszUsername -- user name
    dwSeed -- start value of cookie

Returns:

    TRUE if success, FALSE if error

--*/
{
    UNICODE_STRING Username;
    LPWSTR lpwszUserName;
    NTSTATUS Status;
#define TOHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

    if ( dwBuffSize < sizeof(dwSeed)*2 + 1 )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    if ( !RtlCreateUnicodeStringFromAsciiz(&Username, lpszUsername) )
    {
        return FALSE;
    }

    lpwszUserName = Username.Buffer;
    while ( *lpwszUserName )
    {
        dwSeed = ((dwSeed << 5) | ( dwSeed >> 27 )) ^ ((*lpwszUserName++)&0xff);
    }

    RtlFreeUnicodeString(&Username);

    lpszCookieBuff[0] = '0' + IISSUBA_COOKIE;
    lpszCookieBuff[1] = '"';

    for ( UINT x = 0, y = 2 ; x < sizeof(dwSeed) ; ++x )
    {
        UINT v;
        v = ((LPBYTE)&dwSeed)[x]>>4;
        lpszCookieBuff[y++] = TOHEX( v );
        v = ((LPBYTE)&dwSeed)[x]&0x0f;
        lpszCookieBuff[y++] = TOHEX( v );
    }
    lpszCookieBuff[y] = '\0';

    return TRUE;
}


BOOL
WINAPI
IISLogonDigestUserA(
    PDIGEST_LOGON_INFO      pDigestLogonInfo,
    DWORD                   dwAlgo,
    HANDLE *                phToken
    )
/*++

Routine Description:

    Logs a user on via username and domain
    name via the LSA using Digest authentication

Arguments:

    pDigestLogonInfo - Digest parameters for use in logon
    dwAlgo - type of logon
    phToken -- created access token

Returns:

    TRUE if success, FALSE if error

--*/
{
    UNICODE_STRING Username;
    UNICODE_STRING Domain;
    STRING         Password;
    NTSTATUS       Status;
    BOOL           bRet;
    char           achA[3];
    int            l;

    Username.Buffer = NULL;
    Domain.Buffer = NULL;
    Password.Buffer = NULL;

    if (!RtlCreateUnicodeStringFromAsciiz(&Username, 
                                          pDigestLogonInfo->pszNtUser))
    {
        bRet = FALSE;
        goto Cleanup;
    }

    if (!RtlCreateUnicodeStringFromAsciiz(&Domain, 
                                          pDigestLogonInfo->pszDomain))
    {
        bRet = FALSE;
        goto Cleanup;
    }

    achA[0] = (int)dwAlgo + '0';
    achA[1] = '"';
    achA[2] = '\0';

    l = strlen(achA) + 
        strlen(pDigestLogonInfo->pszRealm) + 
        strlen(pDigestLogonInfo->pszURI) + 
        strlen(pDigestLogonInfo->pszMethod) +
        strlen(pDigestLogonInfo->pszNonce) + 
        strlen(pDigestLogonInfo->pszCurrentNonce) + 
        strlen(pDigestLogonInfo->pszResponse) +
        strlen(pDigestLogonInfo->pszUser) + 
        strlen(pDigestLogonInfo->pszQOP) + 
        strlen(pDigestLogonInfo->pszCNonce) +
        strlen(pDigestLogonInfo->pszNC) + 
        32;
        
    if ( Password.Buffer = (CHAR*)RtlAllocateHeap( RtlProcessHeap(), HEAP_ZERO_MEMORY, l) )
    {
        Password.MaximumLength = (USHORT)l;
    }
    else
    {
        Password.MaximumLength = 0;
    }
    Password.Length = 0;

    if( !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, achA)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszRealm)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszURI)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszMethod)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszNonce)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszCurrentNonce)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszResponse)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszUser)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszQOP)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszCNonce)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, pDigestLogonInfo->pszNC)) ||
        !NT_SUCCESS( Status = RtlAppendAsciizToString( &Password, "\"")) )
    {
        BaseSetLastNTError(Status);
        bRet = FALSE;
        goto Cleanup;
    }

    bRet = IISLogonNetUserW(
        Username.Buffer,
        Domain.Buffer,
        Password.Buffer,
        NULL,
        IIS_SUBAUTH_ID,
        LOGON32_LOGON_IIS_NETWORK,
        LOGON32_PROVIDER_DEFAULT,
        phToken,
        NULL
        ) ;

Cleanup:

    if (Username.Buffer)
    {
        RtlFreeUnicodeString(&Username);
    }

    if (Domain.Buffer)
    {
        RtlFreeUnicodeString(&Domain);
    }

    if ( Password.Buffer )
    {
        RtlFreeHeap(RtlProcessHeap(), 0, Password.Buffer );
    }

    return bRet;
}



/*******************************************************************

    NAME:       GetDefaultDomainName

    SYNOPSIS:   Fills in the given array with the name of the default
                domain to use for logon validation.

    ENTRY:      pszDomainName - Pointer to a buffer that will receive
                    the default domain name.

                cchDomainName - The size (in charactesr) of the domain
                    name buffer.

    RETURNS:    TRUE if successful, FALSE if not.

    HISTORY:
        KeithMo     05-Dec-1994 Created.

********************************************************************/
BOOL
IISGetDefaultDomainName(
    CHAR  * pszDomainName,
    DWORD   cchDomainName
    )
{
    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    INT                         Result;
    DWORD                       err             = 0;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;

    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if( !NT_SUCCESS( NtStatus ) )
    {
        DBGPRINTF((  DBG_CONTEXT,
                    "cannot open lsa policy, error %08lX\n",
                     NtStatus ));

        err = LsaNtStatusToWinError( NtStatus );

        // Failure LsaOpenPolicy() does not guarantee that 
        // LsaPolicyHandle was not touched.

        LsaPolicyHandle = NULL;

        goto Cleanup;
    }

    //
    //  Query the domain information from the policy object.
    //

    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *)&DomainInfo );

    if( !NT_SUCCESS( NtStatus ) )
    {

        DBGPRINTF((  DBG_CONTEXT,
                    "cannot query lsa policy info, error %08lX\n",
                     NtStatus ));

        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    //
    //  Convert the name from UNICODE to ANSI.
    //

    Result = WideCharToMultiByte( CP_ACP,
                                  0,                    // flags
                                  (LPCWSTR)DomainInfo->DomainName.Buffer,
                                  DomainInfo->DomainName.Length / sizeof(WCHAR),
                                  pszDomainName,
                                  cchDomainName - 1,    // save room for '\0'
                                  NULL,
                                  NULL );

    if( Result <= 0 )
    {
        err = GetLastError();

        DBGPRINTF((  DBG_CONTEXT,
                    "cannot convert domain name to ANSI, error %d\n",
                     err ));

        goto Cleanup;
    }

    //
    //  Ensure the ANSI string is zero terminated.
    //


    DBG_ASSERT( (DWORD)Result < cchDomainName );

    pszDomainName[Result] = '\0';

    //
    //  Success!
    //


    DBG_ASSERT( err == 0 );

Cleanup:

    if( DomainInfo != NULL )
    {
        LsaFreeMemory( (PVOID)DomainInfo );
    }

    if( LsaPolicyHandle != NULL )
    {
        LsaClose( LsaPolicyHandle );
    }

    if ( err )
    {
        SetLastError( err );
        return FALSE;
    }

    return TRUE;

}   // IISGetDefaultDomainName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\comtest\sink.cxx ===
#include <windows.h>
#include <ole2.h>
#include <imd.h>
#include <stdio.h>
#include <sink.hxx>

//extern HANDLE          hevtDone;

CImpIMDCOMSINK::CImpIMDCOMSINK()
{
    m_dwRefCount=0;
}

CImpIMDCOMSINK::~CImpIMDCOMSINK()
{
}

HRESULT
CImpIMDCOMSINK::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IMDCOMSINK) {
        *ppObject = (IMDCOMSINK *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CImpIMDCOMSINK::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CImpIMDCOMSINK::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}

HRESULT STDMETHODCALLTYPE
CImpIMDCOMSINK::ComMDSinkNotify(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [in] */ DWORD dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT __RPC_FAR pcoChangeList[  ])
{
    DWORD i, j;
    printf("Recieved callback for handle %X\n", hMDHandle);
    for (i = 0; i < dwMDNumElements; i++) {
        printf("Change Type = %X, Path = %s\n", pcoChangeList[i].dwMDChangeType, pcoChangeList[i].pszMDPath);
        for (j = 0; j < pcoChangeList[i].dwMDNumDataIDs; j++) {
            printf("\tData Changed ID = %X\n", pcoChangeList[i].pdwMDDataIDs[j]);
        }
    }
    printf("\n");
    return (0);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\comtest\main.cxx ===
#include <windows.h>
#define INITGUID

#include <ole2.h>
#include <stdio.h>
#include <mdmsg.h>
#include <mdcommsg.h>
#include <imd.h>
#include <sink.hxx>

// {BA4E57F0-FAB6-11cf-9D1A-00AA00A70D51}
//static const GUID CLSID_MDCOM =
//{ 0xba4e57f0, 0xfab6, 0x11cf, { 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51 } };
// {BA4E57F1-FAB6-11cf-9D1A-00AA00A70D51}
//static const GUID IID_IMDCOMSRVFACTORY =
//{ 0xba4e57f1, 0xfab6, 0x11cf, { 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51 } };

// {C1AA48C0-FACC-11cf-9D1A-00AA00A70D51}
//static const GUID IID_IMDCOM =
//{ 0xc1aa48c0, 0xfacc, 0x11cf, { 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51 } };

#define MD_TEST_MAX_STRING_LEN   2048
#define MD_TEST_MAX_BINARY_LEN   2048

#define FILL_RETURN_BUFF   for(ReturnIndex=0;ReturnIndex<sizeof(ReturnBuf);ReturnIndex++)ReturnBuf[ReturnIndex]=0xff;
#define SET_RETURN_DATA    {ReturnDataLen=sizeof(ReturnBuf);ReturnUserType=0;ReturnDataType=0;ReturnAttributes=(METADATA_INHERIT | METADATA_PARTIAL_PATH);FILL_RETURN_BUFF}
#define MD_SET_DATA_RECORD(PMDR, ID, ATTR, UTYPE, DTYPE, DLEN, PD) \
            { \
            (PMDR)->dwMDIdentifier=ID; \
            (PMDR)->dwMDAttributes=ATTR | g_dwSecurityFlags; \
            (PMDR)->dwMDUserType=UTYPE; \
            (PMDR)->dwMDDataType=DTYPE; \
            (PMDR)->dwMDDataLen=DLEN; \
            (PMDR)->pbMDData=PD; \
            }

#define TIMEOUT_VALUE      1000
#define INITIAL_TIMEOUT_VALUE 15000

#define DWORD_DATA_NAME    1
#define BINARY_DATA_NAME   2
#define STRING_DATA_NAME   3
#define BAD_BINARY_DATA_NAME 4

#define DWORD_DATA_NAME_INHERIT 5
#define DWORD_DATA_NAME_NO_INHERIT 6

#define REFERENCE_DATA_NAME  7

#define EXPANDSZ_DATA_NAME   8

#define MULTISZ_DATA_NAME   9

#define INSERT_PATH_DATA_NAME  10

#define MAX_DATA_ENTRIES   5
#define MY_GREATEROF(p1,p2) ((p1) > (p2))?(p1):(p2)
#define MAX_BUFFER_LEN     MY_GREATEROF((MD_TEST_MAX_STRING_LEN * sizeof(TCHAR)), MD_TEST_MAX_BINARY_LEN)
#define BUFFER_SIZE        5000

#define HUNDREDNANOSECONDSPERSECOND (DWORDLONG)10000000
#define HUNDREDNANOSECONDSPERMINUTE (HUNDREDNANOSECONDSPERSECOND * (DWORDLONG)60)
#define HUNDREDNANOSECONDSPERHOUR (HUNDREDNANOSECONDSPERMINUTE * (DWORDLONG)60)
#define HUNDREDNANOSECONDSPERDAY (HUNDREDNANOSECONDSPERHOUR * (DWORDLONG)24)
#define HUNDREDNANOSECONDSPERYEAR ((HUNDREDNANOSECONDSPERDAY * (DWORDLONG)365) + (HUNDREDNANOSECONDSPERDAY / (DWORDLONG)4))

#define INSERT_PATH_DATA "The path be inserted here: " MD_INSERT_PATH_STRING ":Before here"

#define SET_GETALL_PARMS(p1) dwBufferSize = BUFFER_SIZE;dwNumDataEntries = MAX_DATA_ENTRIES;dwDataSetNumber=0;for (i=0;i<p1;i++){structDataEntries[i].pbMDData=binDataEntries[i];}

#define RELEASE_INTERFACE(p)\
{\
  IUnknown* pTmp = (IUnknown*)p;\
  p = NULL;\
  if (NULL != pTmp)\
    pTmp->Release();\
}

DWORD g_dwSecurityFlags = 0;

VOID
PrintTime(PFILETIME pftTime)
{
    DWORDLONG dwlTime = *(PDWORDLONG)pftTime;
    printf("Year = %d\n", ((DWORD)(dwlTime / (DWORDLONG)HUNDREDNANOSECONDSPERYEAR)) + 1601);
    printf("Day = %d\n", (DWORD)((dwlTime % (DWORDLONG)HUNDREDNANOSECONDSPERYEAR) / (DWORDLONG)HUNDREDNANOSECONDSPERDAY));
    printf("Time = %d minutes\n", (DWORD)((dwlTime % (DWORDLONG)HUNDREDNANOSECONDSPERDAY) / (DWORDLONG)HUNDREDNANOSECONDSPERMINUTE));

    ULARGE_INTEGER uliTime = *(PULARGE_INTEGER)pftTime;
    printf("Time High Word = %X, Low Word = %X\n", uliTime.HighPart, uliTime.LowPart);

}

LPSTR
ConvertDataTypeToString(DWORD dwDataType)
{
    LPTSTR strReturn;
    switch (dwDataType) {
    case DWORD_METADATA:
        strReturn = "DWORD";
        break;
    case STRING_METADATA:
        strReturn = "STRING";
        break;
    case BINARY_METADATA:
        strReturn = "BINARY";
        break;
    case EXPANDSZ_METADATA:
        strReturn = "EXPANDSZ";
        break;
    case MULTISZ_METADATA:
        strReturn = "MULTISZ";
        break;
    case ALL_METADATA:
        strReturn = "ALL";
        break;
    default:
        strReturn = "Invalid Data Type";
    }
    return (strReturn);
}

VOID
PrintDataBuffer(PMETADATA_RECORD pmdrData, BOOL bPrintData, LPSTR strInitialString)
{
    DWORD i;
    if (strInitialString != NULL) {
        printf("%s\n", strInitialString);
    }
    printf("Identifier = %x, Attributes = %x, UserType = %x, DataType = %s, DataLen = %x, DataTag = %x",
        pmdrData->dwMDIdentifier, pmdrData->dwMDAttributes, pmdrData->dwMDUserType,
        ConvertDataTypeToString(pmdrData->dwMDDataType), pmdrData->dwMDDataLen, pmdrData->dwMDDataTag);
    if (bPrintData) {
        printf(", Data = ");
        if (pmdrData->pbMDData != NULL) {
            switch (pmdrData->dwMDDataType) {
            case DWORD_METADATA:
                printf("%x", *(DWORD *)(pmdrData->pbMDData));
                break;
            case STRING_METADATA:
            case EXPANDSZ_METADATA:
                printf("%s", (LPTSTR)(pmdrData->pbMDData));
                break;
            case BINARY_METADATA:
                for (i = 0; i < pmdrData->dwMDDataLen; i++) {
                    printf("%.2x ", ((PBYTE)(pmdrData->pbMDData))[i]);
                }
                break;
            case MULTISZ_METADATA:
                printf("\n\t");
                LPSTR pszData = (LPSTR) pmdrData->pbMDData;
                for (i = 0; i < pmdrData->dwMDDataLen; i++) {
                    if (pszData[i] != '\0') {
                        printf("%c", pszData[i]);
                    }
                    else {
                        printf("\n\t");
                    }
                }
                break;
            }
        }
        else {
            printf("NULL");
        }
    }
    printf("\n");
}

VOID
PrintGetAllDataBuffer(PBYTE pbBase, PMETADATA_GETALL_RECORD pmdgarData, BOOL bPrintData, LPSTR strInitialString)
{
    DWORD i;
    if (strInitialString != NULL) {
        printf("%s\n", strInitialString);
    }
    printf("Identifier = %x, Attributes = %x, UserType = %x, DataType = %s, DataLen = %x, DataTag = %x",
        pmdgarData->dwMDIdentifier, pmdgarData->dwMDAttributes, pmdgarData->dwMDUserType,
        ConvertDataTypeToString(pmdgarData->dwMDDataType), pmdgarData->dwMDDataLen, pmdgarData->dwMDDataTag);
    if (bPrintData) {
        PBYTE pbData;
        if (pmdgarData->dwMDDataTag != 0) {
            printf(", Reference Data Address = 0x%x", (DWORD)pmdgarData->pbMDData);
        }
        else {
            printf(", Data = ");
            pbData = pbBase + (pmdgarData->dwMDDataOffset);
            switch (pmdgarData->dwMDDataType) {
            case DWORD_METADATA:
                printf("%x", *(DWORD *)pbData);
                break;
            case STRING_METADATA:
            case EXPANDSZ_METADATA:
                printf("%s", (LPTSTR)pbData);
                break;
            case BINARY_METADATA:
                for (i = 0; i < pmdgarData->dwMDDataLen; i++) {
                    printf("%.2x ", ((PBYTE)pbData)[i]);
                }
                break;
            case MULTISZ_METADATA:
                printf("\n\t");
                LPSTR pszData = (LPSTR) pbData;
                for (i = 0; i < pmdgarData->dwMDDataLen; i++) {
                    if (pszData[i] != '\0') {
                        printf("%c", pszData[i]);
                    }
                    else {
                        printf("\n\t");
                    }
                }
                break;
            }
        }
    }
    printf("\n");
}

LPSTR ConvertReturnCodeToString(DWORD ReturnCode)
{
    LPSTR RetCode = NULL;
    switch (ReturnCode) {
    case ERROR_SUCCESS:
        RetCode = "ERROR_SUCCESS";
        break;
    case ERROR_PATH_NOT_FOUND:
        RetCode = "ERROR_PATH_NOT_FOUND";
        break;
    case ERROR_INVALID_HANDLE:
        RetCode = "ERROR_INVALID_HANDLE";
        break;
    case ERROR_INVALID_DATA:
        RetCode = "ERROR_INVALID_DATA";
        break;
    case ERROR_INVALID_PARAMETER:
        RetCode = "ERROR_INVALID_PARAMETER";
        break;
    case ERROR_NOT_SUPPORTED:
        RetCode = "ERROR_NOT_SUPPORTED";
        break;
    case ERROR_ACCESS_DENIED:
        RetCode = "ERROR_ACCESS_DENIED";
        break;
    case ERROR_NOT_ENOUGH_MEMORY:
        RetCode = "ERROR_NOT_ENOUGH_MEMORY";
        break;
    case ERROR_FILE_NOT_FOUND:
        RetCode = "ERROR_FILE_NOT_FOUND";
        break;
    case ERROR_DUP_NAME:
        RetCode = "ERROR_DUP_NAME";
        break;
    case ERROR_PATH_BUSY:
        RetCode = "ERROR_PATH_BUSY";
        break;
    case ERROR_NO_MORE_ITEMS:
        RetCode = "ERROR_NO_MORE_ITEMS";
        break;
    case ERROR_INSUFFICIENT_BUFFER:
        RetCode = "ERROR_INSUFFICIENT_BUFFER";
        break;
    case ERROR_PROC_NOT_FOUND:
        RetCode = "ERROR_PROC_NOT_FOUND";
        break;
    case ERROR_INTERNAL_ERROR:
        RetCode = "ERROR_INTERNAL_ERROR";
        break;
    case MD_ERROR_NOT_INITIALIZED:
        RetCode = "MD_ERROR_NOT_INITIALIZED";
        break;
    case MD_ERROR_DATA_NOT_FOUND:
        RetCode = "MD_ERROR_DATA_NOT_FOUND";
        break;
    case MD_ERROR_INVALID_VERSION:
        RetCode = "MD_ERROR_INVALID_VERSION";
        break;
    case MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE:
        RetCode = "MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE";
        break;
    case ERROR_ALREADY_EXISTS:
        RetCode = "ERROR_ALREADY_EXISTS";
        break;
    case MD_WARNING_PATH_NOT_FOUND:
        RetCode = "MD_WARNING_PATH_NOT_FOUND";
        break;
    case MD_WARNING_DUP_NAME:
        RetCode = "MD_WARNING_DUP_NAME";
        break;
    case MD_WARNING_INVALID_DATA:
        RetCode = "MD_WARNING_INVALID_DATA";
        break;
    case ERROR_INVALID_NAME:
        RetCode = "ERROR_INVALID_NAME";
        break;
    case REGDB_E_CLASSNOTREG:
        RetCode = "REGDB_E_CLASSNOTREG";
        break;
    case ERROR_NO_SYSTEM_RESOURCES:
        RetCode = "ERROR_NO_SYSTEM_RESOURCES";
        break;
    default:
        RetCode = "Unrecognized Error Code";
        break;
    }
    return (RetCode);
}

DWORD ConvertHresToDword(HRESULT hRes)
{
    return HRESULTTOWIN32(hRes);
}

LPSTR ConvertHresToString(HRESULT hRes)
{
    LPSTR strReturn = NULL;

    if ((HRESULT_FACILITY(hRes) == FACILITY_WIN32) ||
        (HRESULT_FACILITY(hRes) == FACILITY_INTERNET) ||
        (hRes == 0)) {
        strReturn = ConvertReturnCodeToString(ConvertHresToDword(hRes));
    }
    else {
        strReturn = "Unrecognized hRes facility";
    }
    return(strReturn);
}

void
ConsumeRegistry(IMDCOM * pcCom, METADATA_HANDLE hHandle, LPTSTR pszPath, DWORD dwUnitSize = 10000);

void
ConsumeRegistry(IMDCOM * pcCom, METADATA_HANDLE hHandle, LPTSTR pszPath, DWORD dwUnitSize)
{
    METADATA_RECORD mdrData;
    HRESULT hRes = ERROR_SUCCESS;
    DWORD i;

    BYTE *bData = new BYTE[dwUnitSize];

    if (bData != NULL) {

        for (i = 0; i < dwUnitSize; i++) {
            bData[i] = 0;
        }

        for (i = 0; SUCCEEDED(hRes); i++) {
            MD_SET_DATA_RECORD(&mdrData, i, METADATA_NO_ATTRIBUTES, 0, BINARY_METADATA, dwUnitSize, bData)
            hRes = pcCom->ComMDSetMetaData(hHandle,
                (PBYTE)pszPath,
                &mdrData);
            printf("MDSetMetaData(hHandle, %s, &mdrData); Returns %s\n",
                pszPath,
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                hRes = pcCom->ComMDSaveData();
                printf("\nMDSaveData(); Returns hRes = %X, %s\n",
                    hRes,
                    ConvertHresToString(hRes));

            }
            (bData[i % dwUnitSize])++;
        }
        delete (bData);
    }
}

DWORD
SetMultisz(LPSTR pszBuffer, LPSTR ppszStrings[], DWORD dwNumStrings)
{
    DWORD i;
    LPSTR pszIndex = pszBuffer;

    for (i = 0; i < dwNumStrings; i++) {
        strcpy(pszIndex, ppszStrings[i]);
        pszIndex += strlen(pszIndex) + 1;
    }

    *pszIndex = '\0';

    return ((pszIndex - pszBuffer) + 1);

}

DWORD
GetMultiszDataLen(LPSTR pszData)
{
    DWORD i;

    for (i = 1; (pszData[i-1] != (TCHAR)'\0') || (pszData[i] != (TCHAR)'\0'); i++) {
    }

    return(i + 1);
}

DWORD __cdecl
main( INT    cArgs,
      char * pArgs[] )
{
    DWORD RetCode;
    DWORD TestDword = 3;
    int TestBinary[] = {1,2,3,4};
    int i, j, ReturnIndex;
    DWORD ReturnDword = 0;
    DWORD ReturnAttributes = 0;
    DWORD ReturnDataType = 0;
    DWORD ReturnUserType = 0;
    METADATA_RECORD mdrData;
    UCHAR ReturnBuf[MAX_BUFFER_LEN];
    DWORD ReturnDataLen = sizeof(ReturnBuf);
    DWORD dwRequiredDataLen = 0;
    DWORD dwRequiredBufferLen = 0;
    TCHAR NameBuf[METADATA_MAX_NAME_LEN];
    METADATA_HANDLE OpenHandle, RootHandle;
    DWORD ReturnDataIdentifier;
    METADATA_RECORD structDataEntries[MAX_DATA_ENTRIES];
    BYTE binDataEntries[MAX_DATA_ENTRIES][MAX_BUFFER_LEN];
    DWORD dwNumDataEntries;
    BYTE pbBuffer[BUFFER_SIZE];
    DWORD dwBufferSize = BUFFER_SIZE;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = NULL;
    OLECHAR rgchName[256];
    DWORD dwSystemChangeNumber;
    DWORD dwDataSetNumber;
    METADATA_HANDLE_INFO mhiInfo;
    FILETIME ftTime;
    LPSTR ppszData[10];
    DWORD dwMultiszLen;

    IClassFactory * pcsfFactory = NULL;
    IClassFactory * pcsfFactory2 = NULL;
    IMDCOM * pcCom = NULL;
    HRESULT hRes;
    CImpIMDCOMSINK *pEventSink = new CImpIMDCOMSINK();
    IConnectionPoint* pConnPoint = NULL;
    IConnectionPointContainer* pConnPointContainer = NULL;
    DWORD dwCookie;
    BOOL bSinkConnected = FALSE;

    if (cArgs > 1) {
        j = 1;

        if (_stricmp(pArgs[1], "-s") == 0) {
            g_dwSecurityFlags = METADATA_SECURE;
            j++;
        }

        if (j < cArgs) {
            for (i = 0; pArgs[j][i] != '\0'; i++) {
                rgchName[i] = (OLECHAR) pArgs[j][i];
            }
            csiName.pwszName =  rgchName;
            csiName.pAuthInfo = NULL;
            pcsiParam = &csiName;
        }
    }

    hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (FAILED(hRes)) {
        printf("CoInitializeEx Failed\n");
    }
/*
    hRes = CoCreateInstance(GETMDCLSID(TRUE), NULL, CLSCTX_SERVER, IID_IMDCOM, (void**) &pcCom);
    if (FAILED(hRes)) {
        printf("CoCreateInstance Attaching to service failed, hRes = %X\n", hRes);
        hRes = CoCreateInstance(GETMDCLSID(FALSE), NULL, CLSCTX_SERVER, IID_IMDCOM, (void**) &pcCom);
    }
    if (FAILED(hRes)) {
        printf("CoCreateInstance attaching to exe failed, hRes = %X\n", hRes);
    }
    else {
*/

    hRes = CoGetClassObject(GETMDCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);
    hRes = CoGetClassObject(GETMDCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory2);
    printf("CoGetClassObject(GETMDCLSID(TRUE), ...; Returns hRes = %x, %s\n",
        hRes, ConvertHresToString(hRes));
    if (FAILED(hRes)) {
        hRes = CoGetClassObject(GETMDCLSID(FALSE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);
        printf("CoGetClassObject(GETMDCLSID(FALSE), ...; Returns hRes = %x, %s\n",
            hRes, ConvertHresToString(hRes));
    }

    if (FAILED(hRes)) {
    }
    else {
        hRes = pcsfFactory->CreateInstance(NULL, IID_IMDCOM, (void **) &pcCom);
        printf("Factory->CreateInstance(...); Returns hRes = %X, %s\n",
            hRes, ConvertHresToString(hRes));

        pcsfFactory->Release();
        printf("Factory->Release() called\n");

        if (FAILED(hRes)) {
            printf("Factory->CreateInstance failed, hRes = %X\n", hRes);
        }
        else {
/*
        hRes = pcCom->ComMDInitialize();

        hRes = pcCom->ComMDAddMetaObject(METADATA_MASTER_ROOT_HANDLE, sizeof("Garbage"), (unsigned char *)"Garbage");

        hRes = pcCom->ComMDTerminate(FALSE);

        hRes = pcCom->ComMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, sizeof(""), (PBYTE)"", METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle);
        printf("MDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, NULL, METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle); Returns %s\n",
            ConvertHresToString(hRes));
*/


        // First query the object for its Connection Point Container. This
        // essentially asks the object in the server if it is connectable.
        hRes = pcCom->QueryInterface(
               IID_IConnectionPointContainer,
               (PVOID *)&pConnPointContainer);
        if SUCCEEDED(hRes)
        {
          // Find the requested Connection Point. This AddRef's the
          // returned pointer.
          hRes = pConnPointContainer->FindConnectionPoint(IID_IMDCOMSINK, &pConnPoint);
          if (SUCCEEDED(hRes)) {
              hRes = pConnPoint->Advise((IUnknown *)pEventSink, &dwCookie);
              if (SUCCEEDED(hRes)) {
                  bSinkConnected = TRUE;
              }
              printf("pConnPoint->Advise((IUnknown *)pEventSink, &dwCookie); Returns %s\n", ConvertHresToString(hRes));
          }

          RELEASE_INTERFACE(pConnPointContainer);
        }


        hRes = pcCom->ComMDInitialize();
        printf("MDInitialize(); Returns %s\n", ConvertHresToString(hRes));

        if (SUCCEEDED(hRes))  {

            hRes = pcCom->ComMDInitialize();
            printf("MDInitialize(); Returns %s\n", ConvertHresToString(hRes));

            if (SUCCEEDED(hRes))  {
                hRes = pcCom->ComMDTerminate(FALSE);
                printf("\nMDTerminate(FALSE); Returns %s\n",
                    ConvertHresToString(hRes));
            }

            hRes = pcCom->ComMDGetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, (PBYTE)"Root Object", &ftTime);
            printf("MDGetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->ComMDGetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, NULL, &ftTime);
            printf("MDGetLastChangeTime(METADATA_MASTER_ROOT_HANDLE, NULL, &ftTime); Returns %s\n",
                ConvertHresToString(hRes));
            if (SUCCEEDED(hRes)) {
                PrintTime(&ftTime);
            }

            hRes = pcCom->ComMDGetSystemChangeNumber(&dwSystemChangeNumber);
            printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                ConvertHresToString(hRes));
            if (!FAILED(hRes)) {
                printf("System Change Number = %d\n", dwSystemChangeNumber);
            }

            hRes = pcCom->ComMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, NULL, METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, INITIAL_TIMEOUT_VALUE, &RootHandle);
            printf("MDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, \"\", METADATA_PERMISSION_WRITE || METADATA_PERMISSION_READ, TIMEOUT_VALUE, &RootHandle); Returns %s\n",
                ConvertHresToString(hRes));

            if (!FAILED(hRes)) {

                hRes = pcCom->ComMDDeleteAllMetaData(RootHandle, (PBYTE)"Root Object", ALL_METADATA, ALL_METADATA);
                printf("MDDeleteAllMetaData(RootHandle, (PBYTE)\"Root Object\", ALL_METADATA, ALL_METADATA); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteAllMetaData(RootHandle, (PBYTE)"junk 1", ALL_METADATA, ALL_METADATA);
                printf("MDDeleteAllMetaData(RootHandle, (PBYTE)\"junk 1\", ALL_METADATA, ALL_METADATA); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteChildMetaObjects(RootHandle, (PBYTE)"junk 1");
                printf("MDDeleteChildObjects(RootHandle, (PBYTE)\"junk 1\"); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteChildMetaObjects(RootHandle, (PBYTE)"Root Object");
                printf("MDDeleteChildObjects(RootHandle, (PBYTE)\"Root Object\"); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteMetaObject(RootHandle, (PBYTE)"Root Object");
                printf("MDDeleteMetaObject(RootHandle, TEXT(\"Root Object\")); Returns %s\n",
                    ConvertHresToString(hRes));

                //
                // Delete everything we created last time.
                //

                hRes = pcCom->ComMDDeleteMetaObject(RootHandle, (PBYTE)"junk 1");
                printf("MDDeleteMetaObject(RootHandle, TEXT(\"junk 1\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetHandleInfo(RootHandle, &mhiInfo);
                printf("MDGetHandleInfo(RootHandle, &mhiInfo); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("Handle Change Number = %d, Handle Permissions = %X\n", mhiInfo.dwMDSystemChangeNumber, mhiInfo.dwMDPermissions);
                }

                hRes = pcCom->ComMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, (PBYTE)"", METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle);
                printf("MDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, \"\", METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDAddMetaObject(RootHandle, (PBYTE)"junk 1/junk 2/junk 3/junk 4");
                printf("MDAddMetaObject(RootHandle, \"junk 1/junk 2/junk 3/junk 4\"); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetSystemChangeNumber(&dwSystemChangeNumber);
                printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("System Change Number = %d\n", dwSystemChangeNumber);
                }

                hRes = pcCom->ComMDAddMetaObject(RootHandle,
                    (PBYTE) "junk 1/This is a very long name for a metaobject and should generate an error"
                    " qwerq asf asf asdf asdf asdf fasd asdf fasd asdf asdf dfas fasd asdf sdfa asdf fsd asdf"
                    " fsd sdf asdf asdf  fsd fasd sdfa sdfa asdf fas  sdf fasd asdf asfd asfl  asfpok sadfop asf 012345");
                printf("MDAddMetaObject(RootHandle, \"junk 1/This is a very long name for a metaobject and should generate"
                       " an error qwerq asf asf asdf asdf asdf fasd asdf fasd asdf asdf dfas fasd asdf sdfa asdf fsd asdf"
                       " fsd sdf asdf asdf  fsd fasd sdfa sdfa asdf fas  sdf fasd asdf asfd asfl  asfpok sadfop asf\"));"
                       " Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetSystemChangeNumber(&dwSystemChangeNumber);
                printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("System Change Number = %d\n", dwSystemChangeNumber);
                }

                hRes = pcCom->ComMDAddMetaObject(RootHandle, (PBYTE)"Root Object");
                printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object\")); Returns %s\n",
                    ConvertHresToString(hRes));

//                ConsumeRegistry(pcCom, RootHandle, "Root Object");

                hRes = pcCom->ComMDAddMetaObject(RootHandle, (PBYTE)"Root Object/Child Object1");
                printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object1\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1", &ftTime);
                printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                hRes = pcCom->ComMDAddMetaObject(RootHandle, (PBYTE)"Root Object/Child Object2");
                printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object2\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDAddMetaObject(RootHandle, (PBYTE)"Root Object/Child Object2");
                printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object2\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1", &ftTime);
                printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                hRes = pcCom->ComMDAddMetaObject(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1");
                printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1", &ftTime);
                printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                hRes = pcCom->ComMDAddMetaObject(RootHandle, (PBYTE)"Root Object/Reference Object1");
                printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Reference Object1\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDAddMetaObject(RootHandle, (PBYTE)"Root Object/Subject Object1");
                printf("MDAddMetaObject(RootHandle, TEXT(\"Root Object/Subject Object1\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetDataSetNumber(RootHandle, (PBYTE)"Root Object/Child Object1", &dwDataSetNumber);
                printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1\", &dwDataSetNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("Data Set Number = %d\n", dwDataSetNumber);
                }

                hRes = pcCom->ComMDGetDataSetNumber(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1", &dwDataSetNumber);
                printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &dwDataSetNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("Data Set Number = %d\n", dwDataSetNumber);
                }

                hRes = pcCom->ComMDGetDataSetNumber(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1/Doesn't Exist", &dwDataSetNumber);
                printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1/GrandChild Object1/Doesn't Exist\", &dwDataSetNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("Data Set Number = %d\n", dwDataSetNumber);
                }

                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, 4, (PBYTE)NULL)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, 0, (PBYTE)NULL)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",&mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                ppszData[0] = "Hello ";
                ppszData[1] = "World ";
                ppszData[2] = "Test ";
                dwMultiszLen = SetMultisz((LPSTR)binDataEntries, ppszData, 3);
                MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, dwMultiszLen - 1, (PBYTE)binDataEntries)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                ppszData[0] = "Hello ";
                ppszData[1] = "World ";
                ppszData[2] = "Test ";
                dwMultiszLen = SetMultisz((LPSTR)binDataEntries, ppszData, 3);
                MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, MULTISZ_METADATA, dwMultiszLen, (PBYTE)binDataEntries)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",&mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                ppszData[0] = "Hello ";
                ppszData[1] = INSERT_PATH_DATA;
                ppszData[2] = "Test ";
                dwMultiszLen = SetMultisz((LPSTR)binDataEntries, ppszData, 3);
                MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME, METADATA_INSERT_PATH | METADATA_INHERIT, 0, MULTISZ_METADATA, dwMultiszLen, (PBYTE)binDataEntries)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, MULTISZ_DATA_NAME,  METADATA_INSERT_PATH | METADATA_INHERIT, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",&mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                hRes = ERROR_SUCCESS;
                printf("\nThis Enum should include the MULTISZ Data %x without path replacement ID. Get normally.\n", MULTISZ_DATA_NAME);
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, 0, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->ComMDEnumMetaData(RootHandle,
                        (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                    }
                }

                hRes = ERROR_SUCCESS;
                printf("\nThis Enum should include the MULTISZ Data %x with path replacement ID. Get normally.\n", MULTISZ_DATA_NAME);
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, 0, METADATA_INSERT_PATH, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->ComMDEnumMetaData(RootHandle,
                        (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                    }
                }

                hRes = pcCom->ComMDGetDataSetNumber(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1/Doesn't Exist", &dwDataSetNumber);
                printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1/GrandChild Object1/Doesn't Exist\", &dwDataSetNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("Data Set Number = %d\n", dwDataSetNumber);
                }

                hRes = pcCom->ComMDDeleteMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    DWORD_DATA_NAME, ALL_METADATA);

                printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), DWORD_DATA_NAME, ALL_METADATA); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetDataSetNumber(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1/Doesn't Exist", &dwDataSetNumber);
                printf("MDGetDataSetNumber(RootHandle,(PBYTE)\"Root Object/Child Object1/GrandChild Object1/Doesn't Exist\", &dwDataSetNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("Data Set Number = %d\n", dwDataSetNumber);
                }

                hRes = pcCom->ComMDGetSystemChangeNumber(&dwSystemChangeNumber);
                printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("System Change Number = %d\n", dwSystemChangeNumber);
                }


/*
                hRes = pcCom->ComMDSetReferenceObject(RootHandle, (PBYTE)"Root Object/Reference Object1",
                    RootHandle, (PBYTE)"Root Object/Reference Object1");
                printf("MDSetReferenceObject(RootHandle, TEXT(\"Root Object/Reference Object1\"),\n\tRootHandle, TEXT(\"Root Object/Reference Object1\")); Returns %s\n",
                    ConvertHresToString(hRes));
*/

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",&mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, &dwRequiredDataLen); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                hRes = pcCom->ComMDGetSystemChangeNumber(&dwSystemChangeNumber);
                printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("System Change Number = %d\n", dwSystemChangeNumber);
                }

                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, METADATA_INHERIT, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword);
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, (PBYTE)"Root Object", &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetSystemChangeNumber(&dwSystemChangeNumber);
                printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("System Change Number = %d\n", dwSystemChangeNumber);
                }

                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, METADATA_NO_ATTRIBUTES, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, (PBYTE)"Root Object", &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1", &ftTime);
                printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, METADATA_INHERIT, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1", &ftTime);
                printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, sizeof("STRING Data"), (PBYTE)"STRING Data")
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, METADATA_INHERIT, 0, EXPANDSZ_METADATA, sizeof("STRING Data"), (PBYTE)"STRING Data")
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,(PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                    ConvertHresToString(hRes));

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE)ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, sizeof("STRING Data for Binary Name"), (PBYTE)"STRING Data for Binary Name")
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));


                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, sizeof(TestBinary), (PBYTE)TestBinary)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_INHERIT, 0, 0, sizeof(TestBinary), (PBYTE)TestBinary)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, BAD_BINARY_DATA_NAME, METADATA_INHERIT, 0, BINARY_METADATA, 0x80000000, (PBYTE)TestBinary)
                PrintDataBuffer(&mdrData, FALSE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                if (pcsiParam == NULL) {

                    printf("\nTESTING REFERENCE DATA\n\n");

                    MD_SET_DATA_RECORD(&mdrData, REFERENCE_DATA_NAME, METADATA_REFERENCE, 0, STRING_METADATA, sizeof("STRING Data"), (PBYTE)"STRING Data")
                    PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                    hRes = pcCom->ComMDSetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                        &mdrData);
                    printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));

                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, REFERENCE_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    }
                    else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                        printf("DataLen = %X\n", dwRequiredDataLen);
                    }

                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, REFERENCE_DATA_NAME, METADATA_REFERENCE, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                        hRes = pcCom->ComMDAddRefReferenceData(mdrData.dwMDDataTag);
                        printf("MDAddRefReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                            ConvertHresToString(hRes));
                        hRes = pcCom->ComMDReleaseReferenceData(mdrData.dwMDDataTag);
                        printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                            ConvertHresToString(hRes));
                        hRes = pcCom->ComMDReleaseReferenceData(mdrData.dwMDDataTag);
                        printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                            ConvertHresToString(hRes));
                    }
                    else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                        printf("DataLen = %X\n", dwRequiredDataLen);
                    }

                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, REFERENCE_DATA_NAME, METADATA_REFERENCE, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                        hRes = pcCom->ComMDReleaseReferenceData(mdrData.dwMDDataTag);
                        printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                            ConvertHresToString(hRes));
                    }
                    else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                        printf("DataLen = %X\n", dwRequiredDataLen);
                    }

                    hRes = ERROR_SUCCESS;
                    printf("\nThis Enum should include the reference ID %x. Get normally.\n", REFERENCE_DATA_NAME);
                    for (i=0;hRes == ERROR_SUCCESS; i++) {
                        FILL_RETURN_BUFF;
                        MD_SET_DATA_RECORD(&mdrData, 0, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                        PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                        hRes = pcCom->ComMDEnumMetaData(RootHandle,
                            (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                            &mdrData, i, &dwRequiredDataLen);
                        printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                            ConvertHresToString(hRes));
                        if (hRes == ERROR_SUCCESS) {
                            PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                            if (mdrData.dwMDDataTag != 0) {
                                hRes = pcCom->ComMDReleaseReferenceData(mdrData.dwMDDataTag);
                                printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                                    ConvertHresToString(hRes));

                            }
                        }
                    }

                    hRes = ERROR_SUCCESS;
                    printf("\nThis Enum should include the reference ID %x. Get by reference.\n", REFERENCE_DATA_NAME);
                    for (i=0;hRes == ERROR_SUCCESS; i++) {
                        FILL_RETURN_BUFF;
                        MD_SET_DATA_RECORD(&mdrData, 0, METADATA_REFERENCE, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                        PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                        hRes = pcCom->ComMDEnumMetaData(RootHandle,
                            (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                            &mdrData, i, &dwRequiredDataLen);
                        printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                            ConvertHresToString(hRes));
                        if (hRes == ERROR_SUCCESS) {
                            PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                            if (mdrData.dwMDDataTag != 0) {
                                hRes = pcCom->ComMDReleaseReferenceData(mdrData.dwMDDataTag);
                                printf("MDReleaseReferenceData(mdrData.dwMDDataTag); Returns %s\n",
                                    ConvertHresToString(hRes));

                            }
                        }
                    }

                    SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                    printf("\nThis GetAll should include the reference ID %x. Get normally.\n", REFERENCE_DATA_NAME);
                    hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                        (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                        METADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                        &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                    printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                           "\tMETADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                           " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                           ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                            PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))), TRUE, "GetAll Output Values");
                            DWORD dwDT = ((PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))))->dwMDDataTag;
                            if (dwDT != 0) {
                                hRes = pcCom->ComMDReleaseReferenceData(dwDT);
                                printf("MDReleaseReferenceData(dwDT); Returns %s\n",
                                    ConvertHresToString(hRes));

                            }
                        }
                    }

                    SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                    printf("\nThis GetAll should include the reference ID %x. Get by reference.\n", REFERENCE_DATA_NAME);
                    hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                        (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                        METADATA_REFERENCE, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                        &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                    printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                           "\tMETADATA_REFERENCE, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                           " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                           ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                            PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))), TRUE, "GetAll Output Values");
                            DWORD dwDT = ((PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_GETALL_RECORD))))->dwMDDataTag;
                            if (dwDT != 0) {
                                hRes = pcCom->ComMDReleaseReferenceData(dwDT);
                                printf("MDReleaseReferenceData(dwDT); Returns %s\n",
                                    ConvertHresToString(hRes));

                            }
                        }
                    }

                    hRes = pcCom->ComMDDeleteMetaData(RootHandle,
                        (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                        REFERENCE_DATA_NAME, ALL_METADATA);
                    printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), REFERENCE_DATA_NAME, ALL_METADATA); returns %s\n",
                        ConvertHresToString(hRes));

                    printf("\nEND TESTING REFERENCE DATA\n\n");

                }

                MD_SET_DATA_RECORD(&mdrData, INSERT_PATH_DATA_NAME, METADATA_INSERT_PATH | METADATA_INHERIT, 0, STRING_METADATA, sizeof(INSERT_PATH_DATA), (PBYTE)INSERT_PATH_DATA)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, INSERT_PATH_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, INSERT_PATH_DATA_NAME, METADATA_INSERT_PATH, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                printf("\nThis Enum should include the INSERT_PATH Data %x with path replacement ID.\n", INSERT_PATH_DATA_NAME);
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, 0, METADATA_INSERT_PATH | METADATA_INHERIT, 0, STRING_METADATA, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->ComMDEnumMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                    }
                    else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                        printf("DataLen = %X\n", dwRequiredDataLen);
                    }
                }


                for (i = 0; i < BUFFER_SIZE; i++) {
                    pbBuffer[i] = 0xff;
                }
                dwBufferSize = 0;
                printf("\nThis GetAll should return ERROR_INSUFFICIENT_BUFFER.\n");
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    METADATA_INSERT_PATH | METADATA_INHERIT, ALL_METADATA, STRING_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                       "\tMETADATA_INSERT_PATH | METADATA_INHERIT, ALL_METADATA, STRING_METADATA, &dwNumDataEntries,"
                       " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                       ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                    }
                }

                for (i = 0; i < BUFFER_SIZE; i++) {
                    pbBuffer[i] = 0xff;
                }
                dwBufferSize = (dwRequiredBufferLen < BUFFER_SIZE) ? dwRequiredBufferLen : BUFFER_SIZE;
                printf("\nThis GetAll should include the INSERT_PATH Data %x with path replacement ID.\n", INSERT_PATH_DATA_NAME);
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    METADATA_INSERT_PATH | METADATA_INHERIT, ALL_METADATA, STRING_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                       "\tMETADATA_INSERT_PATH | METADATA_INHERIT, ALL_METADATA, STRING_METADATA, &dwNumDataEntries,"
                       " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                       ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                    }
                }

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, 0, (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &mdrData, &dwRequiredDataLen); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should SUCCEED.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle,
                    (PBYTE)"Root Object/Doesn't Exist",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with ERROR_PATH_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle,
                    (PBYTE)"Root Object/Doesn't Exist",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), DWORD_DATA_NAME_NO_INHERIT,\n\t &ReturnAttributes, &ReturnUserType, &ReturnDataType, &ReturnDataLen, (PVOID) ReturnBuf); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with MD_ERROR_DATA_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle,
                    (PBYTE)"Root Object/Doesn't Exist",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                printf("\nThis Get should FAIL with ERROR_PATH_NOT_FOUND.\n");
                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_NO_INHERIT, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle,
                    (PBYTE)"Root Object/Doesn't Exist",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }

                hRes = ERROR_SUCCESS;
                printf("\nThis Enum should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->ComMDEnumMetaData(RootHandle,
                        (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                    }
                }

                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                printf("\nThis GetAll is a test case of a failure reported by Philippe\n");
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    (PBYTE)"LM/W3SVC/1//Scripts",
                    METADATA_INHERIT | METADATA_PARTIAL_PATH, 2, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"LM/W3SVC/1//Scripts\"),\n"
                       "\tMETADATA_INHERIT | METADATA_PARTIAL_PATH,2, ALL_METADATA, &dwNumDataEntries,"
                       "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);"
                       " Returns %s\n", ConvertHresToString(hRes));
                printf("dwBufferSize = %d, dwDataSetNumber = %d\n", dwBufferSize, dwDataSetNumber);
                if (hRes == ERROR_SUCCESS) {
                    printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                    }
                }

                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                printf("\nThis GetAll is a test case of a failure reported by Philippe\n");
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    (PBYTE)"LM/W3SVC/1//Scripts/garbage/",
                    METADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"LM/W3SVC/1//Scripts/garbage/\"),\n"
                       "\tMETADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                       "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                       ConvertHresToString(hRes));
                printf("dwBufferSize = %d, dwDataSetNumber = %d\n", dwBufferSize, dwDataSetNumber);
                if (hRes == ERROR_SUCCESS) {
                    printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                    }
                }

                //SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                dwBufferSize = 0;
                printf("\nThis GetAll should return ERROR_INSUFFICIENT_BUFFER");
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                       "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, "
                       "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen));"
                       " Returns %s\n", ConvertHresToString(hRes));
                printf("dwRequiredBufferLen = %d, dwDataSetNumber = %d\n", dwRequiredBufferLen, dwDataSetNumber);

                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                dwBufferSize = 101;
                printf("\nThis GetAll should return ERROR_INSUFFICIENT_BUFFER");
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                       "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, "
                       "&dwDataSetNumber, dwBufferSize, (PBYTE)pbBuffer, &dwRequiredBufferLen));"
                       " Returns %s\n", ConvertHresToString(hRes));
                printf("dwRequiredBufferLen = %d\n", dwRequiredBufferLen);

                for (i = 0; i < BUFFER_SIZE; i++) {
                    pbBuffer[i] = 0xff;
                }
                dwBufferSize = (dwRequiredBufferLen < BUFFER_SIZE)? dwRequiredBufferLen : BUFFER_SIZE;
                printf("\nThis GetAll should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                       "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                       " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                       ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                    }
                }

                hRes = ERROR_SUCCESS;
                printf("\nThis Enum should not include ID %x or %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->ComMDEnumMetaData(RootHandle,
                        (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData, i); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                    }
                }

                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                printf("\nThis GetAll should not include ID %x or %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    METADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"),\n"
                       "\tMETADATA_NO_ATTRIBUTES, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                       " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                       ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                    }
                }

                hRes = ERROR_SUCCESS;
                printf("\nThis Partial Path Enum should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, (METADATA_INHERIT | METADATA_PARTIAL_PATH), 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->ComMDEnumMetaData(RootHandle,
                        (PBYTE)"Root Object/Doesn't Exist",
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData, i); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                    }
                }

                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                printf("\nThis Partial Path GetAll should include ID %x but not ID %x.\n", DWORD_DATA_NAME_INHERIT, DWORD_DATA_NAME_NO_INHERIT);
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    (PBYTE)"Root Object/Doesn't Exist",
                    METADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,
                    &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"),\n"
                       "\tMETADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, &dwNumDataEntries,"
                       " &dwDataSetNumber, dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                       ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                    }
                }

                hRes = ERROR_SUCCESS;
                printf("\nThis Partial Path Enum should FAIL with ERROR_PATH_NOT_FOUND\n");
                for (i=0;hRes == ERROR_SUCCESS; i++) {
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, METADATA_NO_ATTRIBUTES, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf);
                    PrintDataBuffer(&mdrData, FALSE, "EnumData Input Values");
                    hRes = pcCom->ComMDEnumMetaData(RootHandle,
                        (PBYTE)"Root Object/Doesn't Exist",
                        &mdrData, i, &dwRequiredDataLen);
                    printf("MDEnumMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"), &mdrData, i); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "EnumData Output Values");
                    }
                }

                SET_GETALL_PARMS(MAX_DATA_ENTRIES);
                printf("\nThis Partial Path GetAll should FAIL with ERROR_PATH_NOT_FOUND\n");
                hRes = pcCom->ComMDGetAllMetaData(RootHandle,
                    (PBYTE)"Root Object/Doesn't Exist",
                    METADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwDataSetNumber,
                    dwBufferSize, pbBuffer, &dwRequiredBufferLen);
                printf("\nMDGetAllMetaData(RootHandle, TEXT(\"Root Object/Doesn't Exist\"),\n"
                       "\tMETADATA_INHERIT, ALL_METADATA, ALL_METADATA, &dwNumDataEntries, &dwDataSetNumber,"
                       " dwBufferSize, pbBuffer, &dwRequiredBufferLen); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    printf("dwDataSetNumber = %d\n", dwDataSetNumber);
                    for (i=0;(DWORD)i<dwNumDataEntries;i++) {
                        PrintGetAllDataBuffer(pbBuffer, (PMETADATA_GETALL_RECORD)(pbBuffer + (i * sizeof(METADATA_RECORD))), TRUE, "GetAll Output Values");
                    }
                }

                hRes = pcCom->ComMDGetSystemChangeNumber(&dwSystemChangeNumber);
                printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("System Change Number = %d\n", dwSystemChangeNumber);
                }

                hRes = pcCom->ComMDCopyMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    RootHandle,
                    (PBYTE)"Root Object/Child Object1",
                    METADATA_INHERIT | METADATA_PARTIAL_PATH, ALL_METADATA, ALL_METADATA, TRUE);
                printf("\nMDCopyMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), RootHandle,\n\tTEXT(\"Root Object/Child Object1\"), METADATA_INHERIT | METADATA_PARTIAL_PATH, 0, TRUE); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDCopyMetaObject(RootHandle, (PBYTE)"/Root Object", RootHandle, (PBYTE)"junk 1/Root Object", TRUE, TRUE);
                printf("MDCopyMetaObject(RootHandle, (PBYTE)\"/Root Object\", RootHandle, (PBYTE)\"junk 1/Root Object\", TRUE, TRUE); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDCopyMetaObject(RootHandle, (PBYTE)"junk 1/Root Object", RootHandle, (PBYTE)"junk 1/junk 2/NewCopyName", TRUE, TRUE);
                printf("MDCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", TRUE, TRUE); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDCopyMetaObject(RootHandle, (PBYTE)"junk 1/Root Object", RootHandle, (PBYTE)"junk 1/junk 2/NewCopyName", TRUE, TRUE);
                printf("MDCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", TRUE, TRUE); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDCopyMetaObject(RootHandle, (PBYTE)"junk 1/Root Object", RootHandle, (PBYTE)"junk 1/NewCopyTree/NewCopyName", TRUE, TRUE);
                printf("MDCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/NewCopyTree/NewCopyName\", TRUE, TRUE); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDCopyMetaObject(RootHandle, (PBYTE)"junk 1/Root Object", RootHandle, (PBYTE)"junk 1/NewCopyTree2/Root Object", TRUE, TRUE);
                printf("MDCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/NewCopyTree2/Root Object\", TRUE, TRUE); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDCopyMetaObject(RootHandle, (PBYTE)"junk 1/Root Object", RootHandle, (PBYTE)"junk 1/junk 2/NewCopyName", FALSE, TRUE);
                printf("MDCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", FALSE, TRUE); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDCopyMetaObject(RootHandle, (PBYTE)"junk 1/Root Object", RootHandle, (PBYTE)"junk 1/junk 2/NewCopyName", FALSE, FALSE);
                printf("MDCopyMetaObject(RootHandle, (PBYTE)\"junk 1/Root Object\", RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", FALSE, FALSE); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDRenameMetaObject(RootHandle, (PBYTE)"junk 1/junk 2/NewCopyName", (PBYTE)"Renamed Object Long Name To Generate Resize");
                printf("MDRenameMetaObject(RootHandle, (PBYTE)\"junk 1/junk 2/NewCopyName\", (PBYTE)\"Renamed Object Long Name To Generate Resize\"); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetSystemChangeNumber(&dwSystemChangeNumber);
                printf("MDGetSystemChangeNumber(&dwSystemChangeNumber); Returns %s\n",
                    ConvertHresToString(hRes));
                if (!FAILED(hRes)) {
                    printf("System Change Number = %d\n", dwSystemChangeNumber);
                }

                ftTime.dwHighDateTime = 1;
                ftTime.dwLowDateTime = 2;

                hRes = pcCom->ComMDSetLastChangeTime(RootHandle, (PBYTE)"Root Object", &ftTime);
                printf("MDSetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                hRes = pcCom->ComMDSetLastChangeTime(RootHandle, NULL, &ftTime);
                printf("MDSetLastChangeTime(RootHandle, NULL, &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                hRes = pcCom->ComMDChangePermissions(RootHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ);
                printf("MDChangePermissions(RootHandle, METADATA_PERMISSION_READ); Returns %s\n\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDOpenMetaObject(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    METADATA_PERMISSION_READ, TIMEOUT_VALUE, &OpenHandle);
                printf("MDOpenMetaObject(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), METADATA_PERMISSION_READ, &OpenHandle); Returns %s\n\n",
                    ConvertHresToString(hRes));

                if (hRes == ERROR_SUCCESS) {

                    hRes = pcCom->ComMDGetHandleInfo(OpenHandle, &mhiInfo);
                    printf("MDGetHandleInfo(RootHandle, &mhiInfo); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (!FAILED(hRes)) {
                        printf("Handle Change Number = %d, Handle Permissions = %X\n", mhiInfo.dwMDSystemChangeNumber, mhiInfo.dwMDPermissions);
                    }

                    for (i=0;hRes == ERROR_SUCCESS;i++) {
                        hRes = pcCom->ComMDEnumMetaObjects(OpenHandle, (PBYTE)"", (PBYTE)NameBuf, i);
                        printf("MDEnumMetaObjects(OpenHandle, NULL, (LPTSTR)NameBuf, i); returns %s\n",
                            ConvertHresToString(hRes));
                    }

                    hRes = pcCom->ComMDChangePermissions(RootHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
                    printf("\nMDChangePermissions(RootHandle, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE); Returns %s\n\n",
                        ConvertHresToString(hRes));

                    hRes = pcCom->ComMDChangePermissions(OpenHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
                    printf("MDChangePermissions(OpenHandle, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE); Returns %s\n\n",
                        ConvertHresToString(hRes));

                    hRes = pcCom->ComMDCloseMetaObject(OpenHandle);
                    printf("MDCloseMetaObject(OpenHandle); Returns %s\n\n",
                        ConvertHresToString(hRes));
                }

                for (i=0;hRes == ERROR_SUCCESS;i++) {
                    hRes = pcCom->ComMDEnumMetaObjects(RootHandle, (PBYTE)"", (PBYTE)NameBuf, i);
                    printf("MDEnumMetaObjects(RootHandle, NULL, (LPTSTR)NameBuf, i); returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        printf("Object Name = %s\n", NameBuf);
                    }
                }

                hRes = pcCom->ComMDSaveData();
                printf("\nMDSaveData(); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDSaveData(RootHandle);
                printf("\nMDSaveData(RootHandle); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDSaveData(OpenHandle);
                printf("\nMDSaveData(OpenHandle); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDChangePermissions(RootHandle, TIMEOUT_VALUE, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
                printf("\nMDChangePermissions(RootHandle, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE); Returns %s\n\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1", &ftTime);
                printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, 0, 0, BINARY_METADATA, 0, NULL)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,(PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                    ConvertHresToString(hRes));

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &mdrData, &dwRequiredDataLen); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                MD_SET_DATA_RECORD(&mdrData, BINARY_DATA_NAME, 0, 0, BINARY_METADATA, 1, NULL)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,(PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                    ConvertHresToString(hRes));

                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, STRING_METADATA, 0, NULL)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,(PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                    ConvertHresToString(hRes));

                FILL_RETURN_BUFF;
                MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                hRes = pcCom->ComMDGetMetaData(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData, &dwRequiredDataLen);
                printf("MDGetMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &mdrData, &dwRequiredDataLen); Returns %s\n",
                    ConvertHresToString(hRes));
                if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                }
                else if (hRes == ERROR_INSUFFICIENT_BUFFER) {
                    printf("DataLen = %X\n", dwRequiredDataLen);
                }

                MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME, 0, 0, DWORD_METADATA, 0, NULL)
                PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                hRes = pcCom->ComMDSetMetaData(RootHandle,(PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    &mdrData);
                printf("MDSetMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), &mdrData); Returns %s\n\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    BINARY_DATA_NAME, BINARY_METADATA);
                printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), BINARY_DATA_NAME, BINARY_METADATA); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDGetLastChangeTime(RootHandle, (PBYTE)"Root Object", &ftTime);
                printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                hRes = pcCom->ComMDGetLastChangeTime(RootHandle, (PBYTE)"Root Object/Child Object1/GrandChild Object1", &ftTime);
                printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                hRes = pcCom->ComMDSetLastChangeTime(RootHandle, (PBYTE)"Root Object", &ftTime);
                printf("MDSetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                hRes = pcCom->ComMDGetLastChangeTime(RootHandle, (PBYTE)"Root Object", &ftTime);
                printf("MDGetLastChangeTime(RootHandle, (PBYTE)\"Root Object\", &ftTime); Returns %s\n",
                    ConvertHresToString(hRes));
                if (SUCCEEDED(hRes)) {
                    PrintTime(&ftTime);
                }

                hRes = pcCom->ComMDDeleteMetaData(RootHandle,
                    (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                    BINARY_DATA_NAME, STRING_METADATA);
                printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Child Object1/GrandChild Object1\"), BINARY_DATA_NAME, STRING_METADATA); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteMetaData(RootHandle,
                    (PBYTE)"Root Object",
                    BINARY_DATA_NAME, ALL_METADATA);
                printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object\"), BINARY_DATA_NAME, ALL_METADATA); returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteMetaData(RootHandle,
                    (PBYTE)"Root Object/Trash",
                    BINARY_DATA_NAME, ALL_METADATA);
                printf("MDDeleteMetaData(RootHandle, TEXT(\"Root Object/Trash\"), BINARY_DATA_NAME, ALL_METADATA); returns %s\n\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteAllMetaData(RootHandle,
                                                     (PBYTE)"Root Object/Child Object1/GrandChild Object1",
                                                      ALL_METADATA,
                                                      ALL_METADATA);
                printf("MDDeleteAllMetaData(RootHandle, (PBYTE)\"Root Object/Child Object1/GrandChild Object1\", ALL_METADATA, ALL_METADATA); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteAllMetaData(RootHandle,
                                                     (PBYTE)"Root Object",
                                                      ALL_METADATA,
                                                      ALL_METADATA);
                printf("MDDeleteAllMetaData(RootHandle, (PBYTE)\"Root Object\", ALL_METADATA, ALL_METADATA); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteMetaObject(RootHandle, (PBYTE)"Root Object/Child Object1");
                printf("MDDeleteMetaObject(RootHandle, TEXT(\"Root Object/Child Object1\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteMetaObject(RootHandle, (PBYTE)"Root Object");
                printf("MDDeleteMetaObject(RootHandle, TEXT(\"Root Object\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteChildMetaObjects(RootHandle, (PBYTE)"junk 1");
                printf("MDDeleteChildObjects(RootHandle, (PBYTE)\"junk 1\"); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDBackup(RootHandle,
                                          (PBYTE)"NamedBackup",
                                          MD_BACKUP_NEXT_VERSION,
                                          MD_BACKUP_OVERWRITE | MD_BACKUP_SAVE_FIRST);

                printf("\nMDBackup(...); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDBackup(RootHandle,
                                          (PBYTE)"NamedBackup",
                                          27,
                                          MD_BACKUP_OVERWRITE | MD_BACKUP_SAVE_FIRST);

                printf("\nMDBackup(...); Returns %s\n",
                    ConvertHresToString(hRes));


                hRes = pcCom->ComMDCloseMetaObject(RootHandle);
                printf("MDCloseMetaObject(RootHandle); Returns %s\n",
                    ConvertHresToString(hRes));

                CHAR pszBackupName[MD_BACKUP_MAX_LEN];
                DWORD dwBackupVersion;
                FILETIME ftBackupTime;
                hRes = ERROR_SUCCESS;
                for (i = 0;SUCCEEDED(hRes);i++) {
                    pszBackupName[0] = (CHAR)'\0';
                    hRes = pcCom->ComMDEnumBackups((PBYTE) pszBackupName,
                                                   &dwBackupVersion,
                                                   &ftBackupTime,
                                                   i);

                    printf("\nMDEnumBackups(...); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (SUCCEEDED(hRes)) {
                        printf("\tBackupName = %s, Backup Version = %d\n", pszBackupName, dwBackupVersion);
                    }
                }

                //
                // Restore blows away existing handles,
                // so do this here, where all handles are closed.
                //

                hRes = pcCom->ComMDRestore((PBYTE)"NamedBackup",
                                           27,
                                           0);

                printf("\nMDRestore(...); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDDeleteBackup((PBYTE)"NamedBackup",
                                                27);


            }
/*
            hRes = pcCom->ComMDRemoveCallBack(&MDCallBack);
            printf("\nMDRemoveCallBack(&MDCallBack); Returns %s\n",
                ConvertHresToString(hRes));
*/

            hRes = pcCom->ComMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, (PBYTE)"", METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, TIMEOUT_VALUE, &RootHandle);
            printf("\n\nMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, sizeof(\"\"), \"\", METADATA_PERMISSION_WRITE || METADATA_PERMISSION_READ, TIMEOUT_VALUE, &RootHandle); Returns %s\n",
                ConvertHresToString(hRes));

            if (hRes == ERROR_SUCCESS) {

                hRes = pcCom->ComMDAddMetaObject(RootHandle, (PBYTE)"//");
                printf("\nMDAddMetaObject(RootHandle, TEXT(\"//\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDAddMetaObject(RootHandle, (PBYTE)"Root Object/instance1//");
                printf("\nMDAddMetaObject(RootHandle, TEXT(\"Root Object/instance1//\")); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDCloseMetaObject(RootHandle);
                printf("MDCloseMetaObject(RootHandle); Returns %s\n",
                    ConvertHresToString(hRes));

                hRes = pcCom->ComMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, (PBYTE)"Root Object/instance1/", METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, TIMEOUT_VALUE, &OpenHandle);
                printf("\nMDOpenMetaObject(METADATA_MASTER_ROOT_HANDLE, sizeof(\"Root Object/instance1/\"), (PBYTE)\"Root Object/instance1/\", METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE, TIMEOUT_VALUE, &OpenHandle); Returns %s\n",
                    ConvertHresToString(hRes));

                if (hRes == ERROR_SUCCESS) {

                    MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, METADATA_INHERIT, 0, DWORD_METADATA, sizeof(DWORD), (PBYTE)&TestDword);
                    PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                    hRes = pcCom->ComMDSetMetaData(OpenHandle, (PBYTE)"//", &mdrData);
                    printf("MDSetMetaData(OpenHandle, sizeof(\"//\"), (PBYTE)\"//\", &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));

                    MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, METADATA_INHERIT, 0, STRING_METADATA, sizeof("STRING Data"), (PBYTE)"STRING Data")
                    PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                    hRes = pcCom->ComMDSetMetaData(OpenHandle,
                        (PBYTE)"/",
                        &mdrData);
                    printf("MDSetMetaData(RootHandle, sizeof(\"/\"), TEXT(\"Root Object/instance1/\", &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));

                    MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, METADATA_INHERIT, 0, EXPANDSZ_METADATA, sizeof("STRING Data"), (PBYTE)"STRING Data")
                    PrintDataBuffer(&mdrData, TRUE, "SetData Input Values");
                    hRes = pcCom->ComMDSetMetaData(OpenHandle,
                        (PBYTE)"/",
                        &mdrData);
                    printf("MDSetMetaData(RootHandle, sizeof(\"/\"), TEXT(\"Root Object/instance1/\", &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));

                    printf("\nThis Get should SUCCEED.\n");
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(OpenHandle,
                        (PBYTE)"//",
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(OpenHandle, TEXT(\"//\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    }

                    printf("\nThis Get should FAIL with ERROR_DATA_NOT_FOUND.\n");
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, DWORD_DATA_NAME_INHERIT, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(OpenHandle,
                        (PBYTE)"/",
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(OpenHandle, TEXT(\"/\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    }

                    printf("\nThis Get should SUCCEED.\n");
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(OpenHandle,
                        (PBYTE)"/",
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(OpenHandle, TEXT(\"/\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    }

                    printf("\nThis Get should SUCCEED.\n");
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(OpenHandle,
                        (PBYTE)"/",
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(OpenHandle, TEXT(\"/\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    }

                    printf("\nThis Get should SUCCEED.\n");
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, METADATA_INHERIT, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(OpenHandle,
                        (PBYTE)"//",
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(OpenHandle, TEXT(\"//\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    }

                    printf("\nThis Get should SUCCEED.\n");
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, METADATA_INHERIT, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(OpenHandle,
                        (PBYTE)"//",
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(OpenHandle, TEXT(\"//\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                        PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    }

                    printf("\nThis Get should FAIL with ERROR_DATA_NOT_FOUND.\n");
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, STRING_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(OpenHandle,
                        (PBYTE)"//",
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(OpenHandle, TEXT(\"//\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    }

                    printf("\nThis Get should FAIL with ERROR_DATA_NOT_FOUND.\n");
                    FILL_RETURN_BUFF;
                    MD_SET_DATA_RECORD(&mdrData, EXPANDSZ_DATA_NAME, 0, 0, 0, sizeof(ReturnBuf), (PBYTE) ReturnBuf)
                    PrintDataBuffer(&mdrData, FALSE, "GetData Input Values");
                    hRes = pcCom->ComMDGetMetaData(OpenHandle,
                        (PBYTE)"//",
                        &mdrData, &dwRequiredDataLen);
                    printf("MDGetMetaData(OpenHandle, TEXT(\"//\"), &mdrData); Returns %s\n",
                        ConvertHresToString(hRes));
                    if (hRes == ERROR_SUCCESS) {
                    PrintDataBuffer(&mdrData, TRUE, "GetData Output Values");
                    }

                    hRes = pcCom->ComMDCloseMetaObject(OpenHandle);
                    printf("MDCloseMetaObject(OpenHandle); Returns %s\n",
                        ConvertHresToString(hRes));
                }
            }
        }
        hRes = pcCom->ComMDTerminate(TRUE);
        printf("\nMDTerminate(FALSE); Returns %s\n",
            ConvertHresToString(hRes));

        if (bSinkConnected) {
            hRes = pConnPoint->Unadvise(dwCookie);
        }
        pcCom->Release();
    }

    }
    CoFreeUnusedLibraries();

    CoUninitialize();

    delete (pEventSink);

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\comsrv\srvmain.cxx ===
// ===========================================================================
// File: S S E R V E R . C P P
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Description:
//
//  This is the server-portion of the SIMPLE Network OLE sample. This
// application implements the CLSID_SimpleObject class as a LocalServer.
// Instances of this class support a limited form of the IStream interface --
// calls to IStream::Read and IStream::Write will "succeed" (they do nothing),
// and calls on any other methods fail with E_NOTIMPL.
//
//  The purpose of this sample is to demonstrate what is minimally required
// to implement an object that can be used by clients (both those on the same
// machine using OLE and those using Network OLE across the network).
//
// Instructions:
//
//  To use this sample:
//   * build it using the NMAKE command. NMAKE will create SSERVER.EXE and
//     SCLIENT.EXE.
//   * edit the SSERVER.REG file to make the LocalServer32 key point to the
//     location of SSERVER.EXE, and run the INSTALL.BAT command (it simply
//     performs REGEDIT SSERVER.REG)
//   * run SSERVER.EXE. it should display the message "Waiting..."
//   * run SCLIENT.EXE on the same machine using no command-line arguments,
//     or from another machine using the machine-name (UNC or DNS) as the sole
//     command-line argument. it will connect to the server, perform some read
//     and write calls, and disconnect. both SSERVER.EXE and SCLIENT.EXE will
//     automatically terminate. both applications will display some status text.
//   * you can also run SCLIENT.EXE from a different machine without having first
//     run SSERVER.EXE on the machine. in this case, SSERVER.EXE will be launched
//     by OLE in the background and you will be able to watch the output of
//     SCLIENT.EXE but the output of SSERVER.EXE will be hidden.
//   * to examine the automatic launch-security features of Network OLE, try
//     using the '...\CLSID\{...}\LaunchPermission = Y' key commented out in
//     the SSERVER.REG file and reinstalling it. by setting different read-access
//     privileges on this key (using the Security/Permissions... dialog in the
//     REGEDT32 registry tool built into the system) you can allow other
//     users to run the SCLIENT.EXE program from their accounts.
//
// Copyright 1996 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================

// %%Includes: ---------------------------------------------------------------
#define INITGUID
#include <mdcommon.hxx>

// %%Globals: ----------------------------------------------------------------
HANDLE          hevtDone;

// {BA4E57F0-FAB6-11cf-9D1A-00AA00A70D51}
//extern const GUID CLSID_MDCOM;
//DEFINE_GUID(CLSID_MDCOM, 0xba4e57f0, 0xfab6, 0x11cf, 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51);

STDAPI DllRegisterServer(void);
STDAPI DllUnregisterServer(void);
// ---------------------------------------------------------------------------
// %%Function: Message
//
//  Formats and displays a message to the console.
// ---------------------------------------------------------------------------
 void
Message(LPTSTR szPrefix, HRESULT hr)
{
    LPTSTR   szMessage;

    if (hr == S_OK)
        {
        printf(szPrefix);
        printf(TEXT("\n"));
        return;
        }

    if (HRESULT_FACILITY(hr) == FACILITY_WINDOWS)
        hr = HRESULT_CODE(hr);

    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        hr,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language
        (LPTSTR)&szMessage,
        0,
        NULL );

    printf(TEXT("%s: %s(%lx)\n"), szPrefix, szMessage, hr);

    LocalFree(szMessage);
}  // Message

// ---------------------------------------------------------------------------
// %%Function: main
// ---------------------------------------------------------------------------
 void __cdecl
main( INT    cArgs,
      char * pArgs[] )
{
    HRESULT hr;
    DWORD   dwRegister;

    if (cArgs >= 2) {
        if ((*pArgs[1] == 'R') || (*pArgs[1] == 'r')) {
            if (FAILED(DllRegisterServer())) {
                printf("Failed to Register Server\n");
            }
            else {
                printf("Server Registered Successfully\n");
            }
        }

        else if ((*pArgs[1] == 'U') || (*pArgs[1] == 'u')) {
            if (FAILED(DllUnregisterServer())) {
                printf("Failed to UnRegister Server\n");
            }
            else {
                printf("Server UnRegistered Successfully\n");
            }
        }
        else {
            printf("Invalid parameter");
        }
    }

    // create the thread which is signaled when the instance is deleted
    hevtDone = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (hevtDone == NULL)
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        Message(TEXT("Server: CreateEvent"), hr);
        exit(hr);
        }
/*
    // initialize COM for free-threading
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))
        {
        Message(TEXT("Server: CoInitializeEx"), hr);
        exit(hr);
        }
    CMDCOMSrvFactory   *pMDClassFactory = new CMDCOMSrvFactory;
    // register the class-object with OLE
    hr = CoRegisterClassObject(CLSID_MDCOM, pMDClassFactory,
        CLSCTX_SERVER, REGCLS_MULTIPLEUSE, &dwRegister);
    if (FAILED(hr))
        {
        Message(TEXT("Server: CoRegisterClassObject"), hr);
        exit(hr);
        }
*/

    BOOL bReturn = InitComMetadata(TRUE);
    if (!bReturn) {
        exit(bReturn);
    }

    HRESULT hRes;
    IMDCOM * pcCom = NULL;

    hRes = CoCreateInstance(CLSID_MDCOMEXE, NULL, CLSCTX_SERVER, IID_IMDCOM, (void**) &pcCom);

    hRes = pcCom->ComMDInitialize();
    printf("MDInitialize(); Returns %X\n", hRes);

    hRes = pcCom->ComMDTerminate(FALSE);
    printf("MDTerminate(FALSE); Returns %X\n", hRes);

    pcCom->Release();

    Message(TEXT("Server: Waiting"), S_OK);

    // wait until an object is created and deleted.
    WaitForSingleObject(hevtDone, 500000);

    CloseHandle(hevtDone);

//    CoUninitialize();
    bReturn = TerminateComMetadata();

    Message(TEXT("Server: Done"), S_OK);
    Sleep(5000);
}  // main

// EOF =======================================================================


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\baseobj.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    baseobj.cxx

Abstract:

    Basic Object Class for IIS MetaBase.

Author:

    Michael W. Thomas            20-May-96

Revision History:

--*/

#include <mdcommon.hxx>


CMDBaseObject::CMDBaseObject(
    LPSTR strName,
    LPSTR strTag
    )
/*++

Routine Description:

    Constructor for an object.

Arguments:

Name - The name of the object.

Tag  - Optional tag for the object. Intended to store a physical path.

Return Value:

--*/
    :
    m_strMDName(strName),
    m_bufKey(),
    m_pboParent(NULL),
    m_pbocChildHead (NULL),
    m_cbo(0),
    m_phtChildren(NULL),
    m_dwReadCounter (0),
    m_dwReadPathCounter (0),
    m_dwWriteCounter (0),
    m_dwWritePathCounter (0),
    m_dwNumNonInheritableData (0)
{
    BOOL  fRet;
    DWORD i;

    m_dwDataSetNumber = InterlockedExchangeAdd ((LONG *)&g_dwCMDBaseObjectNextUniqueDataSetNumber,2);
    if (m_dwDataSetNumber==0 || m_dwDataSetNumber==0xFFFFFFFF) // check for possible zero
    {
        m_dwDataSetNumber = InterlockedExchangeAdd ((LONG *)&g_dwCMDBaseObjectNextUniqueDataSetNumber,2);
    }

    fRet = GenerateKey();
    MD_ASSERT(fRet);

    for (i = 0; i < INVALID_END_METADATA; i++) {
        m_pdcarrayDataHead[i] = NULL;
    }
    SetLastChangeTime();
};



CMDBaseObject::CMDBaseObject(
    LPWSTR strName,
    LPWSTR strTag
    )
/*++

Routine Description:

    Constructor for an object.

Arguments:

Name - The name of the object.

Tag  - Optional tag for the object. Intended to store a physical path.

Return Value:

--*/
    :
    m_strMDName(strName),
    m_bufKey(),
    m_pboParent(NULL),
    m_pbocChildHead (NULL),
    m_cbo(0),
    m_phtChildren(NULL),
    m_dwReadCounter (0),
    m_dwReadPathCounter (0),
    m_dwWriteCounter (0),
    m_dwWritePathCounter (0),
    m_dwNumNonInheritableData (0)
{
    BOOL  fRet;
    DWORD i;

    m_dwDataSetNumber = InterlockedExchangeAdd ((LONG *)&g_dwCMDBaseObjectNextUniqueDataSetNumber,2);
    if (m_dwDataSetNumber==0 || m_dwDataSetNumber==0xFFFFFFFF) // check for possible zero
    {
        m_dwDataSetNumber = InterlockedExchangeAdd ((LONG *)&g_dwCMDBaseObjectNextUniqueDataSetNumber,2);
    }

    fRet = GenerateKey();  
    MD_ASSERT(fRet);

    for (i = 0; i < INVALID_END_METADATA; i++) {
        m_pdcarrayDataHead[i] = NULL;
    }
    SetLastChangeTime();
};



CMDBaseObject::~CMDBaseObject()
/*++

Routine Description:

    Destructor for an object. Deletes all data and recursively deletes
    all child objects.

Arguments:

Return Value:

--*/
{
    PDATA_CONTAINER pdcIndex, pdcSave;
    PBASEOBJECT_CONTAINER pbocIndex, pbocSave;
    int i;

    for (i = 1; i < INVALID_END_METADATA; i++) {
        for (pdcIndex=m_pdcarrayDataHead[i];pdcIndex!=NULL;pdcIndex=pdcSave) {
            pdcSave=pdcIndex->NextPtr;
            DeleteDataObject(pdcIndex->pbdDataObject);
            delete(pdcIndex);
        }
    }

    if (m_phtChildren)
        delete(m_phtChildren);

    for (pbocIndex=m_pbocChildHead;pbocIndex!=NULL;pbocIndex=pbocSave) {
        pbocSave=pbocIndex->NextPtr;
        delete(pbocIndex->pboMetaObject);
        delete(pbocIndex);
    }
}



BOOL
CMDBaseObject::SetName(
    LPSTR strName,
    BOOL bUnicode
    )

/*++

Routine Description:

    Sets the name of an object.

Arguments:

    Name - The name of the object.

Return Value:

     BOOL - TRUE is succeeded.

--*/
{
    BOOL fRet;

    if (bUnicode)
        fRet = m_strMDName.SafeCopy((LPWSTR)strName);
    else
        fRet = m_strMDName.SafeCopy((LPSTR)strName);

    if (fRet)
        return GenerateKey();
    /* else */
        return FALSE;
};



BOOL
CMDBaseObject::SetName(
    LPWSTR strName
    )

/*++

Routine Description:

    Sets the name of an object.

Arguments:

    Name - The name of the object.

Return Value:

    BOOL - TRUE is succeeded.

--*/
{
    BOOL fRet;

    fRet = m_strMDName.SafeCopy(strName);
    if (fRet)
        return GenerateKey();
    /* else */
        return FALSE;
};



HRESULT
CMDBaseObject::InsertChildObject(
         IN CMDBaseObject *pboChild
         )
/*++

Routine Description:

    Inserts a child object into the list of child objects.

Arguments:

    Child - the object to insert.

Return Value:

    DWORD - ERROR_SUCCESS
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_DUP_NAME
--*/

{
    MD_ASSERT(pboChild != NULL);
    MD_ASSERT(pboChild->m_bufKey.QuerySize() > 0);

    HRESULT hresReturn = ERROR_SUCCESS;
    PBASEOBJECT_CONTAINER pbocNew = new BASEOBJECT_CONTAINER;

    // Bail if not enough memory.
    if (pbocNew == NULL)
        return RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);

    pbocNew->pboMetaObject = pboChild;
    pbocNew->NextPtr = NULL;
    pboChild->SetParent(this);


    hresReturn = AddChildObjectToHash(pboChild,
                                      pbocNew);

    // Attach to the chain at the end (to keep enumeration ordering)
    if (SUCCEEDED(hresReturn))
    {
        if (m_pbocChildHead == NULL)
            m_pbocChildHead = pbocNew;
        else
            m_pbocChildTail->NextPtr = pbocNew;
        m_pbocChildTail = pbocNew;

        m_cbo++;
        SetLastChangeTime();
    }
    else
        delete pbocNew;

    return(hresReturn);
}

CMDBaseObject *
CMDBaseObject::GetChildObject(
    IN OUT LPSTR &strName,
    OUT HRESULT *phresReturn,
    IN BOOL bUnicode
    )
/*++

Routine Description:

    Gets a child object by name. Updates strName to point past the end of the Name if found.

Arguments:

    Name - name of the object. End delimeter can be '\0', '\\', or '/'.

Return Value:

    CBaseObject * - The child object or NULL if the child is not found.

Notes:

--*/
{
    PBASEOBJECT_CONTAINER pbocCurrent = NULL;
    CMDBaseObject *pboReturn = NULL;
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pchDelimiter = strName;

    // Find the delimiter.  Change to terminate character.
    if (bUnicode)
    {
        LPWSTR pchDelimiterW = (LPWSTR) pchDelimiter;
        WCHAR chW;

        while ((chW = *pchDelimiterW) != MD_ALT_PATH_DELIMETERW &&
                                  chW != MD_PATH_DELIMETERW &&
                                  chW != (WCHAR)L'\0')
            {
            pchDelimiterW++;
            }
        pchDelimiter = (LPSTR) pchDelimiterW;
    }
    else
    {
        CHAR chA;

        while ((chA = *(LPSTR) pchDelimiter) != MD_ALT_PATH_DELIMETERA &&
                                         chA != MD_PATH_DELIMETERA &&
                                         chA != (CHAR) '\0')
            {
            (LPSTR) pchDelimiter = CharNextExA(CP_ACP,
                                               (LPSTR) pchDelimiter,
                                               0);
            }
    }

    // Find the child.
    pboReturn = FindChild(strName, DIFF(pchDelimiter-strName), bUnicode, phresReturn);

    // If we found the name, move up the pointer to the delimiter
    if (pboReturn != NULL)
    {
        MD_ASSERT(*phresReturn == ERROR_SUCCESS);

        strName = pchDelimiter;
    }

#if 0    // SAB
    // If we didn't find the name, return the "not found" error.
    else if (*phresReturn == ERROR_SUCCESS)
    {
        *phresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
    }
#endif

    return(pboReturn);
}

CMDBaseObject *
CMDBaseObject::EnumChildObject(
         IN DWORD dwEnumObjectIndex
         )
/*++

Routine Description:

    Gets a child object by index.

Arguments:

    EnumObjectIndex - The 0 based index of the object to get.

Return Value:

    CMDBaseObject * - The child object or NULL if the child is not found.

Notes:

--*/
{
    PBASEOBJECT_CONTAINER pbocCurrent;
    CMDBaseObject *pboReturn;
    DWORD i;

    for (pbocCurrent = m_pbocChildHead, i=0;
        (pbocCurrent!=NULL) && (i < dwEnumObjectIndex);
        pbocCurrent=pbocCurrent->NextPtr, i++) {
    }
    if (pbocCurrent != NULL) {
        pboReturn = pbocCurrent->pboMetaObject;
    }
    else {
        pboReturn = NULL;
    }
    return (pboReturn);
}

PBASEOBJECT_CONTAINER
CMDBaseObject::NextChildObject(
         IN PBASEOBJECT_CONTAINER pbocCurrent
         )
/*++

Routine Description:

    Given a BASEOBJECT_CONTAINER returns the next BASEOBJECT_CONTAINER in the linked list.
	Much more efficient than EnumchildObject, if the whole list is being traversed.

Arguments:

    pbocCurrent - Current container object.

Return Value:

    PBASEOBJECT_CONTAINER - The child object container or NULL if the container is not found.

Notes:

--*/
{
	if (pbocCurrent == NULL)
	{
		return m_pbocChildHead;
	}

	return pbocCurrent->NextPtr;
}


HRESULT
CMDBaseObject::RemoveChildObject(
         IN LPTSTR strName,
         IN BOOL bUnicode
         )
/*++

Routine Description:

    Removes a child object from the list of child objects and deletes it.

Arguments:

    Name        - The name of the object to remove.

Return Value:

    DWORD - ERROR_SUCCESS
            ERROR_PATH_NOT_FOUND

--*/

{
    MD_ASSERT (strName != NULL);

    CMDBaseObject*          pboCurrent;
    BASEOBJECT_CONTAINER*   pbocPrev;
    HRESULT hresReturn;

    // Find the object, including the previous container.
    pboCurrent = FindChild(strName,
                           /* Length */ -1,
                           bUnicode,
                           &hresReturn,
                           /* fUseHash */ FALSE,
                           &pbocPrev);

    if (hresReturn == ERROR_SUCCESS)
    {   // Either we found it, or it's not there.  But no errors occurred.
        if (pboCurrent != NULL)
        {   // We found it.
            BASEOBJECT_CONTAINER* pbocCurrent;

            RemoveChildObjectFromHash(pboCurrent);

            // Remove from the container chain, keeping a pointer to the container to delete.
            if (pbocPrev == NULL)
            {
                pbocCurrent = m_pbocChildHead;
                MD_ASSERT(pbocCurrent != NULL);
                m_pbocChildHead = pbocCurrent->NextPtr;
                // If tail pointed to pbocCurrent, then head will become NULL,
                // in which case tail will be ignored.
            }
            else
            {
                pbocCurrent = pbocPrev->NextPtr;
                MD_ASSERT(pbocCurrent != NULL);
                pbocPrev->NextPtr = pbocCurrent->NextPtr;
                if (m_pbocChildTail == pbocCurrent)
                {
                    MD_ASSERT(pbocPrev->NextPtr == NULL);
                    m_pbocChildTail = pbocPrev;
                }
            }

            // Delete the container.  The base object itself is deleted as part of
            // CMDHandle::RemoveNotifications.
            delete pbocCurrent;

            MD_ASSERT(m_cbo != 0);
            m_cbo--;
            SetLastChangeTime();
        }

        // If FindChild() succeeded but didn't find anything, return the error.
        else
        {
            hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
        }
    }

    return hresReturn;
}

HRESULT
CMDBaseObject::AddChildObjectToHash(
         IN CMDBaseObject *pboChild,
         IN BASEOBJECT_CONTAINER* pbocChild
         )
/*++

Routine Description:

    Add child object from the hash table.

Arguments:

    Child       - The object to remove.
    pbocChild   - The container for the child object. If NULL,
                  the child must already be on the child list.
                  This routine will find the child container, and will
                  not check the child list for ERROR_DUP_NAME.

Return Value:

    DWORD - ERROR_SUCCESS
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_DUP_NAME

--*/
{
    HRESULT hresReturn = NO_ERROR;
    BOOL bCheckForDups = (pbocChild == NULL) ? FALSE : TRUE;

    // Should we create the hash table now?
    if (m_phtChildren == NULL && m_cbo >= cboCreateHashThreashold)
    {   // Time to create hash table
        // Just skip if we can't create table for some reason.

        m_phtChildren = new CChildNodeHashTable;
        if (m_phtChildren != NULL)
        {   // Create successful.  Let's fill the sucker.
            BASEOBJECT_CONTAINER* pboc = m_pbocChildHead;
            while (pboc != NULL)
            {
                LK_RETCODE ret;

                MD_ASSERT(pboc->pboMetaObject != NULL);
                MD_ASSERT(pboc->pboMetaObject->m_bufKey.QuerySize() > 0);

                ret = m_phtChildren->InsertRecord(pboc,
                                                  /* fOverwrite */ FALSE);
                MD_ASSERT(ret == LK_SUCCESS);
                if (ret != LK_SUCCESS)
                {
                    delete m_phtChildren;
                    m_phtChildren = NULL;
                    break;
                }

                pboc = pboc->NextPtr;
            }
        }
    }

    // Use hash table if it exists.
    if (m_phtChildren != NULL)
    {
        LK_RETCODE ret;

        if (pbocChild == NULL) {

            //
            // Need container for insert function.
            // If it came in as NULL, then the node is not
            // really new (ie. rename) and should already be
            // on the list, so find it.
            //


            BASEOBJECT_CONTAINER* pbocIndex = m_pbocChildHead;
            while ((pbocIndex != NULL) && (pbocIndex->pboMetaObject != pboChild)) {
                pbocIndex = pbocIndex->NextPtr;
            }

            DBG_ASSERT((pbocIndex != NULL) && (pbocIndex->pboMetaObject == pboChild));
            pbocChild = pbocIndex;
        }


        // Put in hash table.  This looks for dups.
        ret = m_phtChildren->InsertRecord(pbocChild,
                                         /* fOverwrite */ FALSE);
        if (ret == LK_KEY_EXISTS)
        {
            DBG_ASSERT(!"Duplicate entry in hash table");
            return RETURNCODETOHRESULT(ERROR_DUP_NAME);
        }
        if (ret != LK_SUCCESS)
        {
            MD_ASSERT(ret == LK_SUCCESS);   // Put up debug assert now.
            delete m_phtChildren;
            m_phtChildren = NULL;
            goto NoHashTable;
        }
    }

    // If hash table doesn't exist, check for duplicate by searching chain.
    else
    {
NoHashTable:
        if (m_pbocChildHead != NULL && bCheckForDups)
        {
            LPSTR strChildName;

            // Check for duplicates
            strChildName = pboChild->GetName(/* bUnicode */ TRUE);
            if (strChildName == NULL)
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            else if (FindChild(strChildName,
                              /* Length */ -1,
                              /* bUnicode */ TRUE,
                              &hresReturn,
                              /* fUseHash */ FALSE,
                              NULL) != NULL)
            {
                hresReturn = RETURNCODETOHRESULT(ERROR_DUP_NAME);
            }
        }
    }

    return hresReturn;
}

VOID
CMDBaseObject::RemoveChildObjectFromHash(
         IN CMDBaseObject *pboChild
         )
/*++

Routine Description:

    Removes a child object from the hash table.

Arguments:

    Child       - The object to remove.

Return Value:

    none

--*/
{
    // Delete from the hash table.
    if (m_phtChildren != NULL)
    {
        m_phtChildren->DeleteKey(&pboChild->m_bufKey);

        // Delete the hash table if we've gone below the threashold.
        if (m_cbo <= cboDeleteHashThreashold)
        {
            delete m_phtChildren;
            m_phtChildren = NULL;
        }
    }
}

HRESULT
CMDBaseObject::RemoveChildObject(
         IN CMDBaseObject *pboChild
         )
/*++

Routine Description:

    Removes a child object from the list of child objects and deletes it.

Arguments:

    Name        - The name of the object to remove.

Return Value:

    DWORD - ERROR_SUCCESS
            ERROR_PATH_NOT_FOUND

--*/

{
    MD_ASSERT (pboChild != NULL);

    BASEOBJECT_CONTAINER* pbocCurrent;
    BASEOBJECT_CONTAINER* pbocPrev;
    HRESULT hresReturn;

    // Find the object in the container chain.
    pbocPrev = NULL;
    pbocCurrent = m_pbocChildHead;
    while (pbocCurrent != NULL && pbocCurrent->pboMetaObject != pboChild)
    {
        pbocPrev = pbocCurrent;
        pbocCurrent = pbocCurrent->NextPtr;
    }

    if (pbocCurrent != NULL)
    {    // Found it
        MD_ASSERT (pbocCurrent->pboMetaObject == pboChild);

        RemoveChildObjectFromHash(pboChild);

        // Remove from the container chain.
        if (pbocPrev == NULL)
        {
            m_pbocChildHead = pbocCurrent->NextPtr;
            // If tail pointed to pbocCurrent, then head will become NULL,
            // in which case tail will be ignored.
        }
        else
        {
            pbocPrev->NextPtr = pbocCurrent->NextPtr;
            if (m_pbocChildTail == pbocCurrent)
            {
                MD_ASSERT(pbocPrev->NextPtr == NULL);
                m_pbocChildTail = pbocPrev;
            }
        }

        // Delete it.  Actual base object is deleted as part of
        // CMDHandle::RemoveNotifications.
        delete pbocCurrent;
        hresReturn = ERROR_SUCCESS;

        MD_ASSERT(m_cbo != 0);
        m_cbo--;
        SetLastChangeTime();
    }
    else {
        hresReturn = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
    }

    return hresReturn;
}

HRESULT
CMDBaseObject::InsertDataObject(
         IN CMDBaseData *pbdInsert
         )
/*++

Routine Description:

    Inserts a data object into the list of data objects of that type.

Arguments:

    Data    - The data object to insert.

Return Value:

    DWORD   - ERROR_SUCCESS
              ERROR_INTERNAL_ERROR

Notes:

    Does not check for duplicates. This should be checked by the calling routine.

--*/
{
    HRESULT hresReturn = ERROR_SUCCESS;
    MD_ASSERT (pbdInsert != NULL);
    PDATA_CONTAINER *pdcHead;
    PDATA_CONTAINER pdcNew;

    pdcNew = new (DATA_CONTAINER);
    if (pdcNew == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
    }
    else {
        pdcHead = &(m_pdcarrayDataHead[pbdInsert->GetDataType()]);
        pdcNew->NextPtr = NULL;
        pdcNew->pbdDataObject = pbdInsert;
        if (*pdcHead == NULL) {
            *pdcHead = pdcNew;
        }
        else {
            //
            // It seems likely that the first paths read in will be the most common
            // paths, so insert at end of list
            //
            PDATA_CONTAINER pdcIndex;
            for (pdcIndex = *pdcHead;
                pdcIndex->NextPtr != NULL;
                pdcIndex = pdcIndex->NextPtr) {
            }
            MD_ASSERT(pdcIndex!=NULL);
            MD_ASSERT(pdcIndex->NextPtr==NULL);
            pdcIndex->NextPtr = pdcNew;
            if ((pbdInsert->GetAttributes() & METADATA_INHERIT) == 0) {
                m_dwNumNonInheritableData++;
            }
        }
    }
    if (SUCCEEDED(hresReturn)) {
        SetLastChangeTime();
    }
    return(hresReturn);
}

HRESULT
CMDBaseObject::SetDataObject(
         IN CMDBaseData *pbdNew
         )
/*++

Routine Description:

    Sets a data object.
    If data of that name does not already exist,
    it creates and inserts a data object into the list of data objects
    of that type.
    If data of that name aready exists, it sets the new data values.

Arguments:

    Data       - The data to insert.

Return Value:

    DWORD   - ERROR_SUCCESS
              ERROR_NOT_ENOUGH_MEMORY
              ERROR_INTERNAL_ERROR

Notes:

    Checks for duplicates.

--*/
{
    HRESULT hresReturn;
    MD_ASSERT (pbdNew != NULL);
    CMDBaseData *pbdOld = GetDataObject(pbdNew->GetIdentifier(), METADATA_NO_ATTRIBUTES, ALL_METADATA); //Check for all types
    if (pbdOld == pbdNew) {
        //
        // It's already there, leave it alone.
        //
        hresReturn = ERROR_SUCCESS;
    }
    else {
        //
        // Insert the new first so if there's a problem leave the old.
        //
        hresReturn = InsertDataObject(pbdNew);
        if (SUCCEEDED(hresReturn)) {
            pbdNew->IncrementReferenceCount();
            if (pbdOld != NULL) {
                hresReturn = RemoveDataObject(pbdOld, TRUE);
                MD_ASSERT(SUCCEEDED(hresReturn));
            }
        }
    }
    return(hresReturn);
}

HRESULT
CMDBaseObject::SetDataObject(
         IN PMETADATA_RECORD pmdrMDData,
         IN BOOL bUnicode)
/*++

Routine Description:

    Sets a data object.
    If data of that name does not already exist,
    it creates and inserts a data object into the list of data objects
    of that type.
    If data of that name aready exists, it sets the new data values.

Arguments:

    Data - The data to set.

        Identifier - The identifier of the data.

        Attributes - The flags for the data.
                          METADATA_INHERIT

        UserType   - The User Type for the data. User Defined.

        DataType   - The Type of the data.
                          DWORD_METADATA
                          STRING_METADATA
                          BINARY_METADATA

        DataLen    - The length of the data. Only used if DataType == BINARY_METADATA.

        Data       - Pointer to the data.

Return Value:

    DWORD   - ERROR_SUCCESS
              ERROR_NOT_ENOUGH_MEMORY
              ERROR_INTERNAL_ERROR
              MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE

Notes:

    Checks for duplicates.

--*/
{
    HRESULT hresReturn;
    CMDBaseData *pbdNew;

    CMDBaseData *pbdOld = GetDataObject(pmdrMDData->dwMDIdentifier, METADATA_NO_ATTRIBUTES, ALL_METADATA); //Check for all types
    if ((pbdOld != NULL) &&
        ((pbdOld->GetAttributes() & METADATA_SECURE) != 0) &&
        ((pmdrMDData->dwMDAttributes & METADATA_SECURE) == 0)) {
        hresReturn = MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE;
    }
    else {

        pbdNew = MakeDataObject(pmdrMDData, bUnicode);

        if (pbdNew == NULL) {
            hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        }
        else {
            if (pbdOld == pbdNew) {
                //
                // It's already there, just correct the ref count,
                // which MakeDataObject incremented.
                //
                DeleteDataObject(pbdNew);
                hresReturn = ERROR_SUCCESS;
            }
            else {
                hresReturn = InsertDataObject(pbdNew);
                if (FAILED(hresReturn)) {
                    DeleteDataObject(pbdNew);
                    pbdNew = NULL;
                }
                else {
                    if (pbdOld!=NULL) {
                        //
                        // Data exists with same name.
                        // Need to delete old data.
                        //
                        hresReturn = RemoveDataObject(pbdOld, TRUE);
                        MD_ASSERT(SUCCEEDED(hresReturn));
                    }
                }
            }
        }
    }
    return(hresReturn);
}

HRESULT
CMDBaseObject::RemoveDataObject(
         IN CMDBaseData *pbdRemove,
         IN BOOL bDelete
         )
/*++

Routine Description:

    Removes and optionally deletes a data object.

Arguments:

    Remove      - The data object to remove.

    Delete      - If true, the object is deleted.

Return Value:

    BOOL        - TRUE if the data was successfully removed.
                  FALSE if the data object is not associated with this metaobject.

--*/
{
    HRESULT hresReturn;
    MD_ASSERT (pbdRemove != NULL);
    PDATA_CONTAINER *ppdcHead;
    PDATA_CONTAINER pdcSave;

    ppdcHead = &(m_pdcarrayDataHead[pbdRemove->GetDataType()]);
    if (*ppdcHead == NULL) {
        hresReturn = MD_ERROR_DATA_NOT_FOUND;
    }
    else {
        if ((*ppdcHead)->pbdDataObject == pbdRemove) {
            pdcSave = *ppdcHead;
            *ppdcHead = (*ppdcHead)->NextPtr;
            delete pdcSave;
            hresReturn = ERROR_SUCCESS;
        }
        else {
            PDATA_CONTAINER ppdcIndex;
            for (ppdcIndex = *ppdcHead;
                (ppdcIndex->NextPtr!=NULL) && (ppdcIndex->NextPtr->pbdDataObject!=pbdRemove);
                ppdcIndex=ppdcIndex->NextPtr) {
            }
            if (ppdcIndex->NextPtr==NULL) {
                hresReturn = MD_ERROR_DATA_NOT_FOUND;
            }
            else {
                MD_ASSERT(ppdcIndex->NextPtr->pbdDataObject == pbdRemove);
                pdcSave = ppdcIndex->NextPtr;
                ppdcIndex->NextPtr = pdcSave->NextPtr;
                delete (pdcSave);
                hresReturn = ERROR_SUCCESS;
            }
        }
    }

    if (SUCCEEDED(hresReturn)) {
        if ((pbdRemove->GetAttributes() & METADATA_INHERIT) == 0) {
            m_dwNumNonInheritableData--;
        }
        if (bDelete) {
            DeleteDataObject(pbdRemove);
        }
        SetLastChangeTime();
    }
    return (hresReturn);
}

CMDBaseData *
CMDBaseObject::RemoveDataObject(
         IN DWORD dwIdentifier,
         IN DWORD dwDataType,
         IN BOOL bDelete
         )
/*++

Routine Description:

    Removes and optionally deletes a data object.

Arguments:

    Name        - The name of the data to remove.

    DataType    - Optional type of the data to remove. If specified, only data of that
                  type will be removed.

    bDelete  - If true, the object is deleted.

Return Value:

    CMDBaseData * - Pointer to the data object removed. If bDelete == TRUE, the pointer will still be
                    returned, but will not be valid.
                    NULL if the data was not found.

--*/
{
    CMDBaseData *pbdRemove;
    pbdRemove=GetDataObject(dwIdentifier, METADATA_NO_ATTRIBUTES, dwDataType);
    if (pbdRemove != NULL) {
        MD_REQUIRE(RemoveDataObject(pbdRemove, bDelete) == ERROR_SUCCESS);
    }
    return(pbdRemove);
}



bool
CMDBaseObject::GenerateKey()
{
    LPSTR       pstr = (LPSTR) m_strMDName.QueryStrW();

    if (pstr == NULL)
        return FALSE;

    return GenerateBufFromStr(pstr,
                              /* cch */ -1,
                              /* fUnicode */ TRUE,
                              &m_bufKey);
}



bool
CMDBaseObject::GenerateBufFromStr(
    IN const char*     pstr,
    IN int             cch,
    IN BOOL            fUnicode,
    OUT CMDKeyBuffer*  pbuf)

/*++

Routine Description:

    Fills the given buffer with the object key based on the given string.

Arguments:

    str         - The string to convert into the key.
    fUnicode    - TRUE if the string is unicode, FALSE if ansi.
    pbuf        - Pointer to the buffer that will contain the new key.

Return Value:

    BOOL        - FALSE if out-of-memory allocating the buffer.

--*/
{
    BUFFER  bufUnicode;     // Use this to hold unicode string if needed.
    int     cchRet;         // Length of actual converted string.

    MD_ASSERT(cch != 0);    // Must either be -1 or a non-null string length.

    // If not unicode, convert to unicode now.
    if (!fUnicode)
    {
        // If we know the size, guess at the unicode size.
        if (cch > 0)
            if (!bufUnicode.Resize(cch*2+50))
                return FALSE;


        // Loop until we have big enough buffer to hold unicode string
        while(TRUE)
        {
            // Buffer length can't be zero, or MultiByteToWideChar() will
            // interpret this by returning "required buffer length" and do
            // no conversion.
            MD_ASSERT(bufUnicode.QuerySize() > 1);

            cchRet = MultiByteToWideChar(CP_ACP,
                                         MB_PRECOMPOSED,
                                         pstr,
                                         cch,
                                         (LPWSTR) bufUnicode.QueryPtr(),
                                         bufUnicode.QuerySize()/2);

            // Handle error during conversion.
            if (cchRet == 0)
            {
                // If error wasn't lack of buffer, fail.
                if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                    return FALSE;

                // Otherwise, make the buffer larger and try again.
                /* else */
                    if (!bufUnicode.Resize(bufUnicode.QuerySize()+50))
                        return FALSE;
            }

            // Succeed, continue.
            else
                break;
        }

        // Point to the buffer now.
        pstr = (char *) bufUnicode.QueryPtr();
        cch = cchRet * 2;
    }

    // If we know the length, guess at the destination length.
    if (cch > 0)
    {
        if (!pbuf->Resize(cch))
            return FALSE;
    }

    // Otherwise, reset the length to whatever is allocated.
    else
        pbuf->SyncSize();

    // Loop until we have a buffer large enough.
    while (TRUE)
    {
        // Buffer size can't be 0, because LCMapString will interpret
        // this by returning "required buffer length" and not actually
        // converting the string.
        MD_ASSERT(pbuf->QuerySize() > 0);
        cchRet = LCMapStringW(LOCALE_SYSTEM_DEFAULT,
                             LCMAP_UPPERCASE,
                             (LPWSTR) pstr,
                             (cch < 0) ? cch : cch/2,
                             (LPWSTR) pbuf->QueryPtr(),
                             pbuf->QuerySize()/2);

        // Handle errors
        if (cchRet == 0)
        {
            // If error wasn't lack of buffer, fail.
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                return FALSE;

            // Otherwise, make the buffer larger and try again.
            /* else */
                if (!pbuf->Resize(pbuf->QuerySize() + 50))
                    return FALSE;
        }
        else
            break;
    }

    // If last character is a null-terminator, remove it in the key.
    if (*((LPWSTR) pbuf->QueryPtr() + cchRet - 1) == (WCHAR) '\0')
        cchRet--;

    // Resize the buffer to the final length.  Length includes null-terminator.
    if (!pbuf->Resize(cchRet*2))
    {
        return FALSE;
    }

    return TRUE;
}



CMDBaseData *
CMDBaseObject::GetDataObjectByType(
         IN DWORD dwIdentifier,
         IN DWORD dwDataType
         )
/*++

Routine Description:

    Gets a data object from the list passed in.

Arguments:

    Identifier  - The identifier of the data to get.

    ListHead    - The head of the list to search.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    PDATA_CONTAINER pdcIndex;
    CMDBaseData *pbdReturn = NULL;

    MD_ASSERT((dwDataType > ALL_METADATA) && (dwDataType < INVALID_END_METADATA));

    for (pdcIndex=m_pdcarrayDataHead[dwDataType];pdcIndex!=NULL;pdcIndex=pdcIndex->NextPtr) {
        if (dwIdentifier == pdcIndex->pbdDataObject->GetIdentifier()) {
            break;
        }
    }
    if (pdcIndex != NULL) {
        pbdReturn = pdcIndex->pbdDataObject;
    }
    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::GetDataObject(
         IN DWORD dwIdentifier,
         IN DWORD dwAttributes,
         IN DWORD dwDataType,
         CMDBaseObject **ppboAssociated
         )
/*++

Routine Description:

    Gets a data object.

Arguments:

    Identifier  - The identifier of the data to get.

    DataType    - Optional type of the data to get.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    CMDBaseData *pbdReturn = NULL;
    DWORD i;

    if (dwDataType == ALL_METADATA) {
        for (i = 1; (pbdReturn == NULL) && (i < INVALID_END_METADATA); i++) {
            pbdReturn = GetDataObjectByType(dwIdentifier, i);
        }
    }
    else {
        pbdReturn = GetDataObjectByType(dwIdentifier, dwDataType);
    }
    if ((ppboAssociated != NULL) && (pbdReturn != NULL)) {
        //
        // Found data in this object
        //
        *ppboAssociated = this;
    }
    if ((pbdReturn == NULL) &&
        (dwAttributes & METADATA_INHERIT) &&
        (GetParent()!=NULL)) {
        pbdReturn = GetParent()->GetInheritableDataObject(dwIdentifier,
                                                            dwDataType,
                                                            ppboAssociated);
    }
    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::GetInheritableDataObject(
         IN DWORD dwIdentifier,
         IN DWORD dwDataType,
         CMDBaseObject **ppboAssociated
         )
/*++

Routine Description:

    Gets a data object.

Arguments:

    Identifier  - The identifier of the data to get.

    DataType    - Optional type of the data to get.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    CMDBaseData *pbdReturn = NULL;
    DWORD i;

    if (dwDataType == ALL_METADATA) {
        for (i = 1; (pbdReturn == NULL) && (i < INVALID_END_METADATA); i++) {
            pbdReturn = GetDataObjectByType(dwIdentifier, i);
        }
    }
    else {
        pbdReturn = GetDataObjectByType(dwIdentifier, dwDataType);
    }

    if ((pbdReturn != NULL) &&
        ((pbdReturn->GetAttributes() & METADATA_INHERIT) == 0)) {
        pbdReturn = NULL;
    }
    if ((ppboAssociated != NULL) && (pbdReturn != NULL)) {
        //
        // Found data in this object
        //
        *ppboAssociated = this;
    }
    if ((pbdReturn == NULL) && (GetParent() != NULL)) {
        pbdReturn = GetParent()->GetInheritableDataObject(dwIdentifier,
                                                            dwDataType,
                                                            ppboAssociated);
    }
    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::EnumDataObjectByType(
         IN DWORD &dwEnumDataIndex,
         IN DWORD dwUserType,
         IN DWORD dwDataType
         )
/*++

Routine Description:

    Gets a data object from the list passed in.

Arguments:

    EnumDataIndex - The 0 based index of the data to get.
                    Updated by the number of matching entries found,
                    not including the entry returned, if any.

    UserType      - Optional UserType of the data to get.

    ListHead      - The head of the list to search.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    PDATA_CONTAINER pdcIndex;
    CMDBaseData *dataReturn = NULL;

    MD_ASSERT((dwDataType > ALL_METADATA) && (dwDataType < INVALID_END_METADATA));

    if (dwUserType == ALL_METADATA) {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL) && dwEnumDataIndex != 0;
            pdcIndex=pdcIndex->NextPtr, dwEnumDataIndex--) {
        }
    }
    else {
        for (pdcIndex=m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if (dwUserType == pdcIndex->pbdDataObject->GetUserType()) {
                if (dwEnumDataIndex == 0) {
                    break;
                }
                dwEnumDataIndex--;
            }
        }
    }
    if (pdcIndex != NULL) {
        dataReturn = pdcIndex->pbdDataObject;
    }
    return (dataReturn);
}

CMDBaseData *
CMDBaseObject::EnumDataObject(
         IN DWORD dwEnumDataIndex,
         IN DWORD dwAttributes,
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         CMDBaseObject **ppboAssociated
         )
/*++

Routine Description:

    Enumerates a data object.

Arguments:

    EnumDataIndex - The 0 based index of the data to get.

    Attributes    - Specifies the Attributes of the get operation.

    UserType      - Optional UserType of the data to get.

    DataType      - Optional type of the data to get.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    CMDBaseData *pbdReturn = NULL;
    PVOID *ppvMainDataBuf;
    DWORD dwNumBufferEntries;
    DWORD i;

    if (dwDataType == ALL_METADATA) {
        for (i = 1; (pbdReturn == NULL) && (i < INVALID_END_METADATA); i++) {
            pbdReturn = EnumDataObjectByType(dwEnumDataIndex, dwUserType, i);
        }
    }
    else {
        pbdReturn = EnumDataObjectByType(dwEnumDataIndex, dwUserType, dwDataType);
    }

    if ((ppboAssociated != NULL) && (pbdReturn != NULL)) {
        //
        // Found data in this object
        //
        *ppboAssociated = this;
    }

    if ((pbdReturn == NULL) && (dwAttributes & METADATA_INHERIT) && (GetParent() != NULL)) {
        //
        // Not in current object and inherited data is specified.
        // Build list of data objects in current meta object,
        // and call parent for inherited data.
        //
        ppvMainDataBuf = GetMainDataBuffer();
        MD_ASSERT (ppvMainDataBuf != NULL);
        dwNumBufferEntries = 0;
        CopyDataObjectsToBuffer(dwUserType, dwDataType, ppvMainDataBuf, dwNumBufferEntries, FALSE);
        pbdReturn = GetParent()->EnumInheritableDataObject(dwEnumDataIndex,
                                                           dwUserType,
                                                           dwDataType,
                                                           ppvMainDataBuf,
                                                           dwNumBufferEntries,
                                                           ppboAssociated);
        FreeMainDataBuffer(ppvMainDataBuf);
    }

    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::EnumInheritableDataObjectByType(
         IN DWORD &dwEnumDataIndex,
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         IN OUT PVOID *ppvMainDataBuf,
         IN OUT DWORD &dwNumBufferEntries)
/*++

Routine Description:

    Gets a data object from the list passed in.

Arguments:

    EnumDataIndex - The 0 based index of the data to get.
                    Updated by the number of matching entries found,
                    not including the entry returned, if any.

    UserType      - Optional UserType of the data to get.

    ListHead      - The head of the list to search.

    MainDataBuf   - The buffer filled with previously enumerated values.

    NumBufferEntries - The number of entries in MainDataBuf.

Return Value:

    CMDBaseData * - Pointer to the data object found.
                    NULL if the data was not found.

--*/
{
    PDATA_CONTAINER pdcIndex;
    CMDBaseData *pbdReturn = NULL;

    MD_ASSERT((dwDataType > ALL_METADATA) && (dwDataType < INVALID_END_METADATA));

    if (dwUserType == ALL_METADATA) {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if (((pdcIndex->pbdDataObject->GetAttributes() & METADATA_INHERIT) != 0) &&
                !IsDataInBuffer(pdcIndex->pbdDataObject->GetIdentifier(), ppvMainDataBuf)) {
                if (dwEnumDataIndex == 0) {
                    break;
                }
                else {
                    if (!(InsertItemIntoDataBuffer((PVOID)pdcIndex->pbdDataObject, ppvMainDataBuf, dwNumBufferEntries))) {
                        pdcIndex = NULL;
                        MD_ASSERT(FALSE);
                        break;
                    }
                }
                dwEnumDataIndex--;
            }
        }
    }
    else {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if (dwUserType == pdcIndex->pbdDataObject->GetUserType() &&
                ((pdcIndex->pbdDataObject->GetAttributes() & METADATA_INHERIT) != 0) &&
                !IsDataInBuffer(pdcIndex->pbdDataObject->GetIdentifier(), ppvMainDataBuf)) {
                if (dwEnumDataIndex == 0) {
                    break;
                }
                else {
                    if (!(InsertItemIntoDataBuffer((PVOID)pdcIndex->pbdDataObject, ppvMainDataBuf, dwNumBufferEntries))) {
                        pdcIndex = NULL;
                        MD_ASSERT(FALSE);
                        break;
                    }
                }
                dwEnumDataIndex--;
            }
        }
    }
    if (pdcIndex != NULL) {
        pbdReturn = pdcIndex->pbdDataObject;
    }
    return (pbdReturn);
}

CMDBaseData *
CMDBaseObject::EnumInheritableDataObject(
         DWORD &dwEnumDataIndex,
         DWORD dwUserType,
         DWORD dwDataType,
         CMDBaseObject **ppboAssociated)
{
    PVOID *ppvMainDataBuf = GetMainDataBuffer();
    DWORD dwNumBufferEntries = 0;
    CMDBaseData *pbdReturn;

    MD_ASSERT(ppvMainDataBuf != NULL);
    pbdReturn = EnumInheritableDataObject(dwEnumDataIndex,
                                            dwUserType,
                                            dwDataType,
                                            ppvMainDataBuf,
                                            dwNumBufferEntries,
                                            ppboAssociated);
    FreeMainDataBuffer(ppvMainDataBuf);

    return(pbdReturn);
}

CMDBaseData *
CMDBaseObject::EnumInheritableDataObject(
         IN OUT DWORD &dwEnumDataIndex,
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         IN OUT PVOID *ppvMainDataBuf,
         IN OUT DWORD &dwNumBufferEntries,
         CMDBaseObject **ppboAssociated)
{
   CMDBaseData *pbdReturn = NULL;
   DWORD i;

   if (dwDataType == ALL_METADATA) {
       for (i = 1; (pbdReturn == NULL) && (i < INVALID_END_METADATA); i++) {
           pbdReturn = EnumInheritableDataObjectByType(dwEnumDataIndex,
                                                       dwUserType,
                                                       i,
                                                       ppvMainDataBuf,
                                                       dwNumBufferEntries);
       }
   }
   else {
       pbdReturn = EnumInheritableDataObjectByType(dwEnumDataIndex,
                                                   dwUserType,
                                                   dwDataType,
                                                   ppvMainDataBuf,
                                                   dwNumBufferEntries);
   }

   if ((ppboAssociated != NULL) && (pbdReturn != NULL)) {
       //
       // Found data in this object
       //
       *ppboAssociated = this;
   }
   if ((pbdReturn == NULL) && (GetParent() != NULL)) {
       //
       // Not in current object.
       // Call parent for inherited data.
       //
       pbdReturn = GetParent()->EnumInheritableDataObject(dwEnumDataIndex,
                                                            dwUserType,
                                                            dwDataType,
                                                            ppvMainDataBuf,
                                                            dwNumBufferEntries,
                                                            ppboAssociated);
   }

   return (pbdReturn);
}

VOID
CMDBaseObject::CopyDataObjectsToBufferByType(
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         OUT PVOID *ppvMainDataBuf,
         IN OUT DWORD &dwNumBufferEntries,
         IN BOOL bInheritableOnly)
/*++

Routine Description:

    Copies all data objects which match the criteria specified
    by the parameters to MainDataBuf.

Arguments:

    UserType      - Optional UserType of the data to copy.

    ListHead      - The list of data objects.

    MainDataBuf   - The buffer to copy the data objects to.

    NumBufferEntries - The Number of data objects in MainDataBuf.

    bInheritableOnly - If TRUE, only copies data objects that are
                       inheritable and not already in the buffer.

Return Value:

--*/

{
    PDATA_CONTAINER pdcIndex;

    MD_ASSERT((dwDataType > ALL_METADATA) && (dwDataType < INVALID_END_METADATA));

    if (dwUserType == ALL_METADATA) {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if ((!bInheritableOnly) ||
                (((pdcIndex->pbdDataObject->GetAttributes() & METADATA_INHERIT) != 0) &&
                !IsDataInBuffer(pdcIndex->pbdDataObject->GetIdentifier(), ppvMainDataBuf))){
                if (!(InsertItemIntoDataBuffer((PVOID)pdcIndex->pbdDataObject, ppvMainDataBuf, dwNumBufferEntries))) {
                    MD_ASSERT(FALSE);
                    break;
                }
            }
        }
    }
    else {
        for (pdcIndex = m_pdcarrayDataHead[dwDataType];
            (pdcIndex!=NULL);
            pdcIndex=pdcIndex->NextPtr) {
            if (dwUserType == pdcIndex->pbdDataObject->GetUserType()) {
                if ((!bInheritableOnly) ||
                    (((pdcIndex->pbdDataObject->GetAttributes() & METADATA_INHERIT) != 0) &&
                    !IsDataInBuffer(pdcIndex->pbdDataObject->GetIdentifier(), ppvMainDataBuf))){
                    if (!(InsertItemIntoDataBuffer((PVOID)pdcIndex->pbdDataObject, ppvMainDataBuf, dwNumBufferEntries))) {
                        MD_ASSERT(FALSE);
                        break;
                    }
                }
            }
        }
    }
}

VOID
CMDBaseObject::CopyDataObjectsToBuffer(
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         OUT PVOID *ppvMainDataBuf,
         IN OUT DWORD &dwNumBufferEntries,
         IN BOOL bInheritableOnly)

/*++

Routine Description:

    Copies all data objects which match the criteria specified
    by the parameters to MainDataBuf.

Arguments:

    UserType      - Optional UserType of the data to copy.

    DataType      - Optional UserType of the data to copy.

    MainDataBuf   - The buffer to copy the data objects to.

    NumBufferEntries - The Number of data objects in MainDataBuf.

    bInheritableOnly - If TRUE, only copies data objects that are
                       inheritable and not already in the buffer.

Return Value:

--*/
{
    DWORD i;

    if (dwDataType == ALL_METADATA) {
        for (i = 1; i < INVALID_END_METADATA; i++) {
            CopyDataObjectsToBufferByType(dwUserType, i, ppvMainDataBuf, dwNumBufferEntries, bInheritableOnly);
        }
    }
    else {
        CopyDataObjectsToBufferByType(dwUserType, dwDataType, ppvMainDataBuf, dwNumBufferEntries, bInheritableOnly);
    }
}

DWORD
CMDBaseObject::GetAllDataObjects(
         OUT PVOID *ppvMainDataBuf,
         IN DWORD dwAttributes,
         IN DWORD dwUserType,
         IN DWORD dwDataType,
         IN BOOL bInheritableOnly
         )
/*++

Routine Description:

    Gets all data objects which match the criteria specified by the parameters.

Arguments:

    MainDataBuf   - The buffer to store the data objects in.

    Attributes    - Specifies the Attributes of the get operation.

    UserType      - Optional UserType of the data to get.

    DataType      - Optional type of the data to get.

    bInheritableOnly - If TRUE, only gets data objects that are
                       inheritable and not already in the buffer.

Return Value:

    DWORD         - Number of Data Objects in Buffer.

--*/
{
    DWORD dwNumBufferEntries;
    CMDBaseObject *objIndex;

    //
    // Not in current object and inherited data is specified.
    // Build list of data objects in current meta object,
    // and call parent for inherited data.
    //
    MD_ASSERT (ppvMainDataBuf != NULL);
    dwNumBufferEntries = 0;
    CopyDataObjectsToBuffer(dwUserType,
                            dwDataType,
                            ppvMainDataBuf,
                            dwNumBufferEntries,
                            bInheritableOnly);
    if (dwAttributes & METADATA_INHERIT) {
        for (objIndex = GetParent(); objIndex != NULL; objIndex = objIndex->GetParent()) {
            objIndex->CopyDataObjectsToBuffer(dwUserType,
                                              dwDataType,
                                              ppvMainDataBuf,
                                              dwNumBufferEntries,
                                              TRUE);
        }
    }
    return (dwNumBufferEntries);
}

HRESULT
CMDBaseObject::GetDataRecursive(
         IN OUT BUFFER *pbufMainDataBuf,
         IN DWORD dwMDIdentifier,
         IN DWORD dwMDDataType,
         IN OUT DWORD &rdwNumMetaObjects)
{
    CMDBaseObject *pboChild;
    DWORD i;
    MD_ASSERT (pbufMainDataBuf != NULL);
    HRESULT hresReturn = ERROR_SUCCESS;


    if (GetDataObject(dwMDIdentifier,
                      METADATA_NO_ATTRIBUTES,
                      dwMDDataType,
                      NULL) != NULL) {
        DWORD dwSize = sizeof(CMDBaseObject *) * (rdwNumMetaObjects + 1);
        if (pbufMainDataBuf->QuerySize() < dwSize) {
            if (!pbufMainDataBuf->Resize(dwSize + (sizeof(CMDBaseObject *) * 1000))) {
                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
            }
        }
        if (SUCCEEDED(hresReturn)) {
            ((CMDBaseObject **)(pbufMainDataBuf->QueryPtr()))[rdwNumMetaObjects++] = (CMDBaseObject *)this;
        }
    }

    for (i = 0;
         SUCCEEDED(hresReturn) &&
             (pboChild = EnumChildObject(i)) != NULL;
         i++) {
        hresReturn = pboChild->GetDataRecursive(pbufMainDataBuf,
                                                dwMDIdentifier,
                                                dwMDDataType,
                                                rdwNumMetaObjects);
    }

    return hresReturn;
}

VOID
CMDBaseObject::SetLastChangeTime(PFILETIME pftLastChangeTime)
{
    if (pftLastChangeTime != NULL) {
        m_ftLastChangeTime = *pftLastChangeTime;
    }
    else {
        GetSystemTimeAsFileTime(&m_ftLastChangeTime);
    }
}

PFILETIME
CMDBaseObject::GetLastChangeTime()
{
    return &m_ftLastChangeTime;
}

DWORD
CMDBaseObject::GetObjectLevel()
{
    DWORD dwLevel = 0;

    if (m_pboParent != NULL) {
        dwLevel = m_pboParent->GetObjectLevel() + 1;
    }

    return dwLevel;
}

BOOL
CMDBaseObject::IsDataInBuffer(
         IN DWORD dwIdentifier,
         IN PVOID *ppvMainDataBuf)
/*++

Routine Description:

    Checks if the buffer contains an object with the specified id.

Arguments:

    Identifier    - The id to check for.

    MainDataBuf   - The buffer to search.

Return Value:

    BOOL          - TRUE if the buffer contains data with the specified id.

--*/
{
    BOOL bReturn = FALSE;
    DWORD i;
    CMDBaseData *pbdDataObject;
    for (i = 0;
        (pbdDataObject = (CMDBaseData *)GetItemFromDataBuffer(ppvMainDataBuf, i)) != NULL;
        i++) {
        if (pbdDataObject->GetIdentifier() == dwIdentifier) {
            bReturn = TRUE;
            break;
        }
    }
    return (bReturn);
}

#if 0   // No longer used.  /SAB

BOOL
CMDBaseObject::CompareDelimitedString(
         IN LPTSTR strNonDelimitedString,
         IN OUT LPTSTR &strDelimitedString,
         IN BOOL bUnicode)
/*++

Routine Description:

    Compared a nondelimeted string to a delimeted string.
    Updates Delimited String on success to point past the string.

Arguments:

    NonDelimiterString - The nondelimited string.

    DelimiterString - The delimited string.

Return Value:

    BOOL          - TRUE if strings are the same.

--*/
{
    LPTSTR i,j;
    BOOL RetCode = FALSE;
    j = strDelimitedString;
    DWORD dwStringLen;

/*

    //
    // Change in semantics. To differentiate between "/" and "//",
    // the leading delimeter is skipped before we get here.
    //
    // Skip leading delimeter, if any
    //
    if ((*j == MD_PATH_DELIMETER) || (*j == MD_ALT_PATH_DELIMETER)) {
        j++;
    }
*/

    if (bUnicode) {
        dwStringLen = wcslen((LPWSTR)strNonDelimitedString);
        //
        // Compare up to delimiter
        // Actually we don't need to check for the delimiter here
        // because NonDelimitedString cannot contain delimiter, so
        // *j==*i will fail on delimiter. Also do not need to check if *i
        // == \0 because *j==*i would fail if *j were not also equal to \0
    //    for (i=strNonDelimitedString;((*j == *i) && (*j!=(TCHAR)'\0'));i++,j++) {
    //    }
        if (_wcsnicmp((LPWSTR)strDelimitedString, (LPWSTR)strNonDelimitedString, dwStringLen) == 0) {
            if (((*((LPWSTR)strDelimitedString + dwStringLen)==MD_ALT_PATH_DELIMETERW) ||
                (*((LPWSTR)strDelimitedString + dwStringLen)==MD_PATH_DELIMETERW) ||
                (*((LPWSTR)strDelimitedString + dwStringLen)== (WCHAR)'\0'))) {   //We have a match
                RetCode = TRUE;
                strDelimitedString += dwStringLen * sizeof(WCHAR);    //Point to next section or \0
            }
        }
    }
    else {
        dwStringLen = MD_STRLEN(strNonDelimitedString);
        //
        // Compare up to delimiter
        // Actually we don't need to check for the delimiter here
        // because NonDelimitedString cannot contain delimiter, so
        // *j==*i will fail on delimiter. Also do not need to check if *i
        // == \0 because *j==*i would fail if *j were not also equal to \0
    //    for (i=strNonDelimitedString;((*j == *i) && (*j!=(TCHAR)'\0'));i++,j++) {
    //    }
        if (MD_STRNICMP(strDelimitedString, strNonDelimitedString, dwStringLen) == 0) {
            DWORD dwStrBytes = MD_STRBYTES(strNonDelimitedString);
            if (((*(strDelimitedString + dwStrBytes)==MD_ALT_PATH_DELIMETERA) ||
                (*(strDelimitedString + dwStrBytes)==MD_PATH_DELIMETERA) ||
                (*(strDelimitedString + dwStrBytes)== (CHAR)'\0'))) {   //We have a match
                RetCode = TRUE;
                strDelimitedString += dwStrBytes;    //Point to next section or \0
            }
        }
    }
    return (RetCode);
}

#endif


CMDBaseObject*
CMDBaseObject::FindChild(
LPSTR                   szName,     // Name of child to find.
int                     cchName,    // Length of the name.
BOOL                    fUnicode,   // TRUE if unicode name.
HRESULT*                phresult,   // Result code.
BOOL                    fUseHash,   // Allow use of hash table
BASEOBJECT_CONTAINER**  ppbocPrev)  // If non-NULL & !fUseHash, prev. object container in list.
{
    UCHAR                   localBufferForBufKey[SIZE_FOR_ON_STACK_BUFFER];
    CMDKeyBuffer            bufKey (localBufferForBufKey,SIZE_FOR_ON_STACK_BUFFER);
    BASEOBJECT_CONTAINER*   pbocCurrent = NULL;

    MD_ASSERT(phresult != NULL);

    //
    // Trap case of being called with an empty path segment.
    // GenerateBufFromStr should not be called with cch == 0
    //
    if( cchName == 0 )
    {
        *phresult = RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND);
        return NULL;
    }

    // Convert the given string to a key.
    if (!GenerateBufFromStr(szName, cchName, fUnicode, &bufKey))
        {
        *phresult = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
        }

    // Use hash table if it exists and we are allowed to.
    if (fUseHash && m_phtChildren != NULL)
    {
        m_phtChildren->FindKey(&bufKey, &pbocCurrent);
    }

    // Otherwise use brute force linear search.
    else
    {
        BASEOBJECT_CONTAINER* pbocPrev = NULL;

        pbocCurrent = m_pbocChildHead;
        while (pbocCurrent != NULL &&
               !FCompareKeys(&bufKey, &pbocCurrent->pboMetaObject->m_bufKey))
        {
            pbocPrev = pbocCurrent;
            pbocCurrent = pbocCurrent->NextPtr;
        }

        if (ppbocPrev != NULL)
            *ppbocPrev = pbocPrev;
    }

    *phresult = ERROR_SUCCESS;

    if (pbocCurrent != NULL)
        return pbocCurrent->pboMetaObject;
    /* else */
        return NULL;
}

void CMDBaseObject::CascadingDataCleanup()
/*++

Routine Description:

    Deletes all data and recursively deletes all data of child objects.

Arguments:

Return Value:

--*/
{
    PDATA_CONTAINER pdcIndex, pdcSave;
    PBASEOBJECT_CONTAINER pbocIndex, pbocSave;
    int i;

    for (i = 1; i < INVALID_END_METADATA; i++) {
        for (pdcIndex=m_pdcarrayDataHead[i];pdcIndex!=NULL;pdcIndex=pdcSave) {
            pdcSave=pdcIndex->NextPtr;
            delete(pdcIndex);
        }
        m_pdcarrayDataHead[i] = NULL;
    }

    for (pbocIndex=m_pbocChildHead;pbocIndex!=NULL;pbocIndex=pbocSave) {
        pbocSave=pbocIndex->NextPtr;
        pbocIndex->pboMetaObject->CascadingDataCleanup();
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\cofact.cxx ===
#include <mdcommon.hxx>

// {BA4E57F0-FAB6-11cf-9D1A-00AA00A70D51}
//DEFINE_GUID(CLSID_MDCOM, 0xba4e57f0, 0xfab6, 0x11cf, 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51);
// {BA4E57F1-FAB6-11cf-9D1A-00AA00A70D51}
//static const GUID IID_IMDCOMSRVFACTORY =
//{ 0xba4e57f1, 0xfab6, 0x11cf, { 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51 } };

// {C1AA48C0-FACC-11cf-9D1A-00AA00A70D51}
//static const GUID IID_IMDCOM =
//{ 0xc1aa48c0, 0xfacc, 0x11cf, { 0x9d, 0x1a, 0x0, 0xaa, 0x0, 0xa7, 0xd, 0x51 } };

CMDCOMSrvFactory::CMDCOMSrvFactory()
    :m_mdcObject()
{
    m_dwRefCount=0;
    //
    // Addref object, so refcount doesn't go to 0 if all clients release.
    //
    m_mdcObject.AddRef();
}

CMDCOMSrvFactory::~CMDCOMSrvFactory()
{
    m_mdcObject.Release();
}
HRESULT
CMDCOMSrvFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void ** ppObject)
{
    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }
    if (FAILED(m_mdcObject.QueryInterface(riid, ppObject))) {
        return E_NOINTERFACE;
    }
    return NO_ERROR;
}

HRESULT
CMDCOMSrvFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        InterlockedIncrement((long *)&g_dwRefCount);
    }
    else {
        InterlockedDecrement((long *)&g_dwRefCount);
    }
    return NO_ERROR;
}

HRESULT
CMDCOMSrvFactory::QueryInterface(REFIID riid, void **ppObject)
{
    if (riid==IID_IUnknown || riid == IID_IClassFactory) {
        if (SUCCEEDED(m_mdcObject.GetConstructorError())) {
            *ppObject = (IClassFactory *) this;
        }
        else {
            return m_mdcObject.GetConstructorError();
        }
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CMDCOMSrvFactory::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CMDCOMSrvFactory::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // There must only be one copy of this. So keep the first one around regardless.
    //
//    if (dwRefCount == 0) {
//        delete this;
//    }
    return dwRefCount;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppObject)
{
    if ((rclsid != CLSID_MDCOM)    && 
        (rclsid != CLSID_MDCOMEXE)) {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    if (FAILED(g_pFactory->QueryInterface(riid, ppObject))) {
        *ppObject = NULL;
        return E_INVALIDARG;
    }
    return NO_ERROR;
}

HRESULT _stdcall DllCanUnloadNow() {
        if (g_dwRefCount) {
                return S_FALSE;
                }
        else {
                return S_OK;
                }
}

STDAPI DllRegisterServer(void)
{
    HKEY hKeyCLSID, hKeyInproc32;
    DWORD dwDisposition;
    HMODULE hModule;
    DWORD dwReturn = ERROR_SUCCESS;

    dwReturn = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                              TEXT("CLSID\\{BA4E57F0-FAB6-11cf-9D1A-00AA00A70D51}"),
                              NULL,
                              TEXT(""),
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKeyCLSID,
                              &dwDisposition);
    if (dwReturn == ERROR_SUCCESS) {
        dwReturn = RegSetValueEx(hKeyCLSID,
                                 TEXT(""),
                                 NULL,
                                 REG_SZ,
                                 (BYTE*) TEXT("MD COM Server"),
                                 sizeof(TEXT("MD COM Server")));
        if (dwReturn == ERROR_SUCCESS) {
            dwReturn = RegCreateKeyEx(hKeyCLSID,
                "InprocServer32",
                NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                &hKeyInproc32, &dwDisposition);

            if (dwReturn == ERROR_SUCCESS) {
                hModule=GetModuleHandle(TEXT("METADATA.DLL"));
                if (!hModule) {
                    dwReturn = GetLastError();
                }
                else {
                    TCHAR szName[MAX_PATH+1];
                    if (GetModuleFileName(hModule,
                                          szName,
                                          sizeof(szName)) == NULL) {
                        dwReturn = GetLastError();
                    }
                    else {
                        dwReturn = RegSetValueEx(hKeyInproc32,
                                                 TEXT(""),
                                                 NULL,
                                                 REG_SZ,
                                                 (BYTE*) szName,
                                                 sizeof(TCHAR)*(lstrlen(szName)+1));
                        if (dwReturn == ERROR_SUCCESS) {
                            dwReturn = RegSetValueEx(hKeyInproc32,
                                                     TEXT("ThreadingModel"),
                                                     NULL,
                                                     REG_SZ,
                                                     (BYTE*) TEXT("Both"),
                                                     sizeof(TEXT("Both")));
                        }
                    }
                }
                RegCloseKey(hKeyInproc32);
            }
        }
        RegCloseKey(hKeyCLSID);
    }

    if( dwReturn == ERROR_SUCCESS )
    {
        dwReturn = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                  TEXT("CLSID\\{8ad3dcf8-869e-4c0e-89c2-86d7710610aa}"),
                                  NULL,
                                  TEXT(""),
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKeyCLSID,
                                  &dwDisposition);
        if (dwReturn == ERROR_SUCCESS) {
            dwReturn = RegSetValueEx(hKeyCLSID,
                                     TEXT(""),
                                     NULL,
                                     REG_SZ,
                                     (BYTE*) TEXT("MD COM2 Server"),
                                     sizeof(TEXT("MD COM2 Server")));
            if (dwReturn == ERROR_SUCCESS) {
                dwReturn = RegCreateKeyEx(hKeyCLSID,
                    "InprocServer32",
                    NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                    &hKeyInproc32, &dwDisposition);

                if (dwReturn == ERROR_SUCCESS) {
                    hModule=GetModuleHandle(TEXT("METADATA.DLL"));
                    if (!hModule) {
                        dwReturn = GetLastError();
                    }
                    else {
                        TCHAR szName[MAX_PATH+1];
                        if (GetModuleFileName(hModule,
                                              szName,
                                              sizeof(szName)) == NULL) {
                            dwReturn = GetLastError();
                        }
                        else {
                            dwReturn = RegSetValueEx(hKeyInproc32,
                                                     TEXT(""),
                                                     NULL,
                                                     REG_SZ,
                                                     (BYTE*) szName,
                                                     sizeof(TCHAR)*(lstrlen(szName)+1));
                            if (dwReturn == ERROR_SUCCESS) {
                                dwReturn = RegSetValueEx(hKeyInproc32,
                                                         TEXT("ThreadingModel"),
                                                         NULL,
                                                         REG_SZ,
                                                         (BYTE*) TEXT("Both"),
                                                         sizeof(TEXT("Both")));
                            }
                        }
                    }
                    RegCloseKey(hKeyInproc32);
                }
            }
            RegCloseKey(hKeyCLSID);
        }
    }

    return RETURNCODETOHRESULT(dwReturn);
}

STDAPI DllUnregisterServer(void)
{
    DWORD dwReturn = ERROR_SUCCESS;

#if 0
    if ( IISGetPlatformType() != PtWindows95 ) {

        //
        // Delete Crypto Keys
        //

        HRESULT hres;
        hres = IISCryptoInitialize();

        if (SUCCEEDED(hres)) {

            IISCryptoDeleteStandardContainer(0);

            IISCryptoDeleteStandardContainer(CRYPT_MACHINE_KEYSET);

            IISCryptoTerminate();

        }
    }
#endif

    dwReturn = RegDeleteKey(HKEY_CLASSES_ROOT,
                    TEXT("CLSID\\{BA4E57F0-FAB6-11cf-9D1A-00AA00A70D51}\\InprocServer32"));
    if (dwReturn == ERROR_SUCCESS) {
        dwReturn = RegDeleteKey(HKEY_CLASSES_ROOT,
                    TEXT("CLSID\\{BA4E57F0-FAB6-11cf-9D1A-00AA00A70D51}"));
    }

    if( dwReturn == ERROR_SUCCESS )
    {
        dwReturn = RegDeleteKey(HKEY_CLASSES_ROOT,
                        TEXT("CLSID\\{8ad3dcf8-869e-4c0e-89c2-86d7710610aa}\\InprocServer32"));
        if (dwReturn == ERROR_SUCCESS) {
            dwReturn = RegDeleteKey(HKEY_CLASSES_ROOT,
                        TEXT("CLSID\\{8ad3dcf8-869e-4c0e-89c2-86d7710610aa}"));
        }
    }

    return RETURNCODETOHRESULT(dwReturn);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\cbin.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    cbin.cxx

    This module contains a light weight binary class


    FILE HISTORY:
        MichTh      17-May-1996 Created, based on string.cxx
*/


//
// Normal includes only for this module to be active
//
# include <cbin.hxx>
# include "dbgutil.h"

# include <tchar.h>

//
//  Private Definations
//

/*******************************************************************

    NAME:       CBIN::CBIN

    SYNOPSIS:   Construct a string object

    ENTRY:      Optional object initializer

    NOTES:      If the object is not valid (i.e. !IsValid()) then GetLastError
                should be called.

                The object is guaranteed to construct successfully if nothing
                or NULL is passed as the initializer.

    HISTORY:
        Johnl   17-Aug-1994     Created

********************************************************************/


CBIN::CBIN( DWORD cbLen, const PVOID pbInit )
{
    AuxInit(cbLen, pbInit);
}

CBIN::CBIN( const CBIN & cbin )
{
    AuxInit(cbin.QueryCB(), cbin.QueryPtr());
}

VOID CBIN::AuxInit( DWORD cbLen, PVOID pbInit)
{
    BOOL fRet;

    _fValid   = TRUE;

    if ( pbInit )
    {
        fRet = Resize( cbLen );


        if ( !fRet )
        {
            _fValid = FALSE;
            return;
        }

        SetCB(cbLen);
        ::memcpy( QueryPtr(), pbInit, cbLen );
    }
    else {
        SetCB(0);
    }
}

/*******************************************************************

    NAME:       CBIN::Append

    SYNOPSIS:   Appends the buffer onto this one.

    ENTRY:      Object to append

    NOTES:

    HISTORY:
        Johnl   17-Aug-1994     Created

********************************************************************/

BOOL CBIN::Append( DWORD cbLen, const PVOID pbBuf )
{
    if ( pbBuf )
    {

        return AuxAppend(pbBuf, cbLen);
    }

    return TRUE;
}

BOOL CBIN::Append( const CBIN   & cbin )
{
        return Append(cbin.QueryCB(), cbin.QueryPtr());
}

BOOL CBIN::AuxAppend( PVOID pbBuf, UINT cbLen, BOOL fAddSlop )
{
    DBG_ASSERT( pbBuf != NULL );

    UINT cbThis = QueryCB();

    //
    //  Only resize when we have to.  When we do resize, we tack on
    //  some extra space to avoid extra reallocations.
    //
    //  Note: QuerySize returns the requested size of the string buffer,
    //        *not* the strlen of the buffer
    //

    if ( QuerySize() < cbThis + cbLen)
    {
        if ( !Resize( cbThis + cbLen) )
            return FALSE;
    }

    SetCB(cbThis + cbLen);
    memcpy( (BYTE *) QueryPtr() + cbThis,
            pbBuf,
            cbLen);

    return TRUE;
}

/*******************************************************************

    NAME:       CBIN::Copy

    SYNOPSIS:   Copies the string into this one.

    ENTRY:      Object to Copy

    NOTES:      A copy is a special case of Append so we just zero terminate
                *this and append the string.

    HISTORY:
        Johnl   17-Aug-1994     Created

********************************************************************/

BOOL CBIN::Copy( DWORD cbLen, const PVOID pbBuf )
{
    SetCB(0);

    if ( pbBuf )
    {
        return AuxAppend( pbBuf, cbLen, FALSE );
    }

    return TRUE;
}

BOOL CBIN::Copy( const CBIN   & cbin )
{
    if ( cbin.IsEmpty()) {
        // To avoid pathological allocation of small chunk of memory
        SetCB(0);
        return ( TRUE);
    }

    return Copy( cbin.QueryCB(), cbin.QueryPtr() );
}

/*******************************************************************

    NAME:       CBIN::Resize

    SYNOPSIS:   Resizes or allocates string memory, NULL terminating
                if necessary

    ENTRY:      cbNewRequestedSize - New string size

    NOTES:

    HISTORY:
        Johnl   12-Sep-1994     Created

********************************************************************/

BOOL CBIN::Resize( UINT cbNewRequestedSize )
{
    if ( !BUFFER::Resize( cbNewRequestedSize ))
        return FALSE;

    return TRUE;
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\gbuf.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    gbuf.cxx

Abstract:

    IIS MetaBase subroutines to support global buffers

Author:

    Michael W. Thomas            12-July-96

Revision History:

--*/

#include <mdcommon.hxx>

HRESULT
InitBufferPool()
/*++

Routine Description:

    Initializes the pool of buffers.

Arguments:

Return Value:

    DWORD - ERROR_SUCCESS
            ERROR_NOT_ENOUGH_MEMORY
            Errors returned by CreateSemaphore
Notes:

--*/
{
    DWORD RetCode = ERROR_SUCCESS;
    DWORD i;

    g_ppvDataBufferBlock = NULL;
    g_pbcDataContainerBlock = NULL;
    if ((g_ppvDataBufferBlock = (PVOID *) new PVOID[NUM_DATA_BUFFERS][DATA_BUFFER_LEN]) == NULL) {
        RetCode = ERROR_NOT_ENOUGH_MEMORY;
    }
    else if ((g_pbcDataContainerBlock = (PBUFFER_CONTAINER) new BUFFER_CONTAINER[NUM_DATA_BUFFERS]) == NULL) {
        RetCode = ERROR_NOT_ENOUGH_MEMORY;
    }
    else {
        g_pbcDataFreeBufHead = NULL;
        g_pbcDataUsedBufHead = NULL;
        for (i = 0; i < NUM_DATA_BUFFERS; i++) {
            g_pbcDataContainerBlock[i].ppvBuffer = g_ppvDataBufferBlock + (i * DATA_BUFFER_LEN);
            g_pbcDataContainerBlock[i].NextPtr = g_pbcDataFreeBufHead;
            g_pbcDataFreeBufHead = g_pbcDataContainerBlock + i;
        }

        g_hDataBufferSemaphore = IIS_CREATE_SEMAPHORE(
                                     "g_hDataBufferSemaphore",
                                     &g_hDataBufferSemaphore,
                                     NUM_DATA_BUFFERS,
                                     NUM_DATA_BUFFERS
                                     );
        if (g_hDataBufferSemaphore == NULL) {
            RetCode = GetLastError();
        }
        else {
            INITIALIZE_CRITICAL_SECTION(&g_csDataBufferCritSec);
        }
    }
    if (RetCode != ERROR_SUCCESS) {
        delete (g_ppvDataBufferBlock);
        delete (g_pbcDataContainerBlock);
    }
    return RETURNCODETOHRESULT(RetCode);
}

VOID
DeleteBufferPool()
/*++

Routine Description:

    Deletes the pool of buffers.

Arguments:

Return Value:

Notes:

--*/
{
    delete (g_ppvDataBufferBlock);
    delete (g_pbcDataContainerBlock);
    DeleteCriticalSection(&g_csDataBufferCritSec);
    CloseHandle(g_hDataBufferSemaphore);
}

PVOID *
GetDataBuffer()
/*++

Routine Description:

    Gets a buffer.

Arguments:

Return Value:

    PVOID * - The buffer.

Notes:

--*/
{
    DWORD dwError;
    PVOID *ppvReturn = NULL;
    PBUFFER_CONTAINER pbcTemp;
    DWORD i;
    //
    // Use a dual synchonization scheme.
    // The semaphore is used to guarantee
    // a buffer is available.
    // The critical section is used to
    // contol access to global data.
    //
    dwError = WaitForSingleObject(g_hDataBufferSemaphore,
                                 INFINITE);
    if (dwError != WAIT_FAILED) {
        EnterCriticalSection(&g_csDataBufferCritSec);
        MD_ASSERT(g_pbcDataFreeBufHead != NULL);
        ppvReturn = g_pbcDataFreeBufHead->ppvBuffer;
        pbcTemp = g_pbcDataFreeBufHead->NextPtr;
        g_pbcDataFreeBufHead->NextPtr = g_pbcDataUsedBufHead;
        g_pbcDataUsedBufHead = g_pbcDataFreeBufHead;
        g_pbcDataFreeBufHead = pbcTemp;
        LeaveCriticalSection(&g_csDataBufferCritSec);
        for (i = 0; i < DATA_BUFFER_LEN; i++) {
            ppvReturn[i] = NULL;
        }
    }
    return (ppvReturn);
}

VOID
FreeDataBuffer(
         PVOID *ppvBuffer)
{
/*++

Routine Description:

    Gets a buffer.

Arguments:

    ppvBuffer - The buffer.

Return Value:

Notes:

--*/
    PBUFFER_CONTAINER pbcTemp;
    EnterCriticalSection(&g_csDataBufferCritSec);
    MD_ASSERT(g_pbcDataUsedBufHead != NULL);
    //
    // Just grab any container. It's more efficient to set ppvBuffer
    // than to find the right container.
    // Of course, this eliminates error checking. The caller is
    // responsible to make sure that it only passes in correct addresses.
    //
    pbcTemp = g_pbcDataUsedBufHead->NextPtr;
    g_pbcDataUsedBufHead->NextPtr = g_pbcDataFreeBufHead;
    g_pbcDataFreeBufHead = g_pbcDataUsedBufHead;
    g_pbcDataUsedBufHead = pbcTemp;
    g_pbcDataFreeBufHead->ppvBuffer = ppvBuffer;
    LeaveCriticalSection(&g_csDataBufferCritSec);
    MD_REQUIRE(ReleaseSemaphore(g_hDataBufferSemaphore,
                               1,
                               NULL));
}

BOOL
InsertItemIntoDataBuffer(
         PVOID pvItem,
         PVOID *ppvMainDataBuf,
         DWORD &dwNumBufferEntries)
{
/*++

Routine Description:

    Appends an item to the buffer at the specified location. This
    must be an append. Random insertion is not supported.
    This is actually a 2 tiered buffer scheme, where the first buffer
    is used an array of buffers.
    Items are pointers.

Arguments:

    Item             - The pointer to add to the buffer.

    MainDataBuf      - The buffer.

    NumBufferEntries - The number of entries currently in the buffer.

Return Value:

    BOOL       - TRUE if the item was added successfully.

Notes:

--*/
    BOOL bReturn = TRUE;
    DWORD dwMainBufIndex = dwNumBufferEntries / (DATA_BUFFER_LEN - 1);
    DWORD dwSubBufIndex = dwNumBufferEntries % (DATA_BUFFER_LEN - 1);
    PVOID *ppvCurrentDataBuf = ppvMainDataBuf;
    int i;

    MD_ASSERT(ppvMainDataBuf != NULL);
    for (i = 0; i < ((int)dwMainBufIndex - 1); i++) {

        //
        // Go to the buffer before the one we want,
        // in case we need to get the final one.
        //

        MD_ASSERT(ppvCurrentDataBuf[DATA_BUFFER_LEN - 1] != NULL);
        ppvCurrentDataBuf = (PVOID *)(ppvCurrentDataBuf[DATA_BUFFER_LEN -1]);
    }

    if ((dwMainBufIndex != 0) && (dwSubBufIndex == 0)) {
        MD_ASSERT(ppvCurrentDataBuf[DATA_BUFFER_LEN - 1] == NULL);
        ppvCurrentDataBuf[DATA_BUFFER_LEN - 1] = GetDataBuffer();
    }

    MD_ASSERT((dwMainBufIndex == 0) || (i == (int)dwMainBufIndex - 1));
    if (dwMainBufIndex != 0) {
        ppvCurrentDataBuf = (PVOID *)(ppvCurrentDataBuf[DATA_BUFFER_LEN - 1]);
    }

    MD_ASSERT(ppvCurrentDataBuf[dwSubBufIndex] == 0);
    ppvCurrentDataBuf[dwSubBufIndex] = pvItem;
    dwNumBufferEntries++;

    return(bReturn);
}

PVOID
GetItemFromDataBuffer(
         PVOID *ppvMainDataBuf,
         DWORD dwItemNum)
/*++

Routine Description:

    Gets the specified item from the buffer.

Arguments:

    MainDataBuf   - The buffer.

    ItemNum       - The number of the item to get.

Return Value:

    PVOID         - The Item from that location.
                    NULL if no item exists at that location.

Notes:

--*/
{
    DWORD dwMainBufIndex = dwItemNum / (DATA_BUFFER_LEN - 1);
    DWORD dwSubBufIndex = dwItemNum % (DATA_BUFFER_LEN - 1);
    PVOID pvReturn;
    PVOID *ppvCurrentDataBuf = ppvMainDataBuf;
    int i;

    MD_ASSERT(ppvMainDataBuf != NULL);
    for (i = 0; i < (int)dwMainBufIndex; i++) {
        ppvCurrentDataBuf = (PVOID *)(ppvCurrentDataBuf[DATA_BUFFER_LEN -1]);
    }

    if (ppvCurrentDataBuf == NULL) {
        pvReturn = NULL;
    }
    else {
        pvReturn = ppvCurrentDataBuf[dwSubBufIndex];
    }
    return(pvReturn);
}

VOID
FreeMainDataBuffer(
         PVOID *ppvMainDataBuf)
/*++

Routine Description:

    Frees a main data buffer. Deletes all sub buffers.

Arguments:

    MainDataBuf   - The main data buffer.

Return Value:

Notes:

--*/
{
    MD_ASSERT(ppvMainDataBuf != NULL);
    PVOID *ppvCurrentDataBuf;
    PVOID *ppvNextDataBuf;

    for ( ppvCurrentDataBuf = ppvMainDataBuf;
          ppvCurrentDataBuf != NULL;
          ppvCurrentDataBuf = ppvNextDataBuf ) {
        ppvNextDataBuf = (PVOID *)(ppvCurrentDataBuf[DATA_BUFFER_LEN - 1]);
        FreeDataBuffer(ppvCurrentDataBuf);
    }
}

PVOID *
GetMainDataBuffer()
/*++

Routine Description:

    Gets a main data buffer. Deletes all sub buffers.

Arguments:

Return Value:

    PVOID * - The main data buffer.

Notes:

--*/
{
    return(GetDataBuffer());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\globals.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    globals.cxx

Abstract:

    IIS MetaBase global variables

Author:

    Michael W. Thomas            31-May-96

Revision History:

--*/
#include <mdcommon.hxx>

//
// Access to global data structures is synchronized by
// acquiring g_rMasterResource with read or write
// permission.
//

CMDCOMSrvFactory    *g_pFactory = NULL;

ULONG                g_dwRefCount = 0;

CMDBaseObject       *g_pboMasterRoot;

TS_RESOURCE         *g_rMasterResource;

TS_RESOURCE         *g_rSinkResource;

CMDHandle           *g_phHandleHead;

METADATA_HANDLE      g_mhHandleIdentifier;

DWORD                g_dwSystemChangeNumber = 0;
DWORD                g_dwSchemaChangeNumber = 1;
DWORD                g_dwLastSchemaChangeNumber = 1;

DWORD                g_dwMajorVersionNumber = MD_MAJOR_VERSION_NUMBER;

DWORD                g_dwMinorVersionNumber = MD_MINOR_VERSION_NUMBER;

HANDLE               g_phEventHandles[EVENT_ARRAY_LENGTH];

HANDLE               g_hReadSaveSemaphore;

DWORD                g_dwInitialized = 0;

HRESULT              g_hresInitWarning = ERROR_SUCCESS;

CMDBaseData        **g_ppbdDataHashTable;

DWORD                g_dwWriteNumber;

DWORD                g_dwLastSaveChangeNumber;

BOOL                 g_bSaveDisallowed;

DWORD                g_dwEnableEditWhileRunning = 0;

ULONG				 g_ulHistoryMajorVersionNumber;

DWORD				 g_dwEnableHistory;

DWORD                g_dwMaxHistoryFiles;

FILETIME             g_XMLSchemaFileTimeStamp;
FILETIME             g_BINSchemaFileTimeStamp;

//
// The following globals are used by edit while running to determine if the
// file change notification received was due to a programmatic save 
// (SaveAllData), or due to a user edit. They are all protected by the
// g_csEditWhileRunning critical section:
//

CRITICAL_SECTION     g_csEditWhileRunning;
FILETIME             g_EWRProcessedMetabaseTimeStamp;
FILETIME             g_MostRecentMetabaseFileLastWriteTimeStamp;
ULONG                g_ulMostRecentMetabaseVersion;
BOOL                 g_bSavingMetabaseFileToDisk;

//
// Data Buffer
// Access to these is synchronized via
// g_csDataBufferCritSec
//

PBUFFER_CONTAINER    g_pbcDataFreeBufHead;

PBUFFER_CONTAINER    g_pbcDataUsedBufHead;

PVOID               *g_ppvDataBufferBlock;

PBUFFER_CONTAINER    g_pbcDataContainerBlock;

HANDLE               g_hDataBufferSemaphore;

CRITICAL_SECTION     g_csDataBufferCritSec;

//
// Data File
//

STR                  *g_strRealFileName;
STR                  *g_strSchemaFileName;
STR                  *g_strTempFileName;
STR                  *g_strBackupFileName;

STR                  *g_pstrBackupFilePath;

PSID                 g_psidSystem;
PSID                 g_psidAdmin;
PACL                 g_paclDiscretionary;
PSECURITY_DESCRIPTOR g_psdStorage;


//
// GlobalISTHelper class
//

CWriterGlobalHelper* g_pGlobalISTHelper;

//
// Unicode versions of strings & their lengths.
// Initialized in  : InitializeUnicodeGlobalDataFileValues
// Set in          : SetUnicodeGlobalDataFileValues
// UnInitialized in: UnInitializeUnicodeGlobalDataFileValues
//

LPWSTR		       g_wszTempFileName;
LPWSTR		       g_wszRealFileName;
LPWSTR		       g_wszBackupFileName;
LPWSTR		       g_wszSchemaFileName;
LPWSTR		       g_wszRealFileNameWithoutPath;
LPWSTR		       g_wszMetabaseDir;
LPWSTR		       g_wszRealFileNameWithoutPathWithoutExtension;
LPWSTR		       g_wszRealFileNameExtension;
LPWSTR             g_wszSchemaFileNameWithoutPath;
LPWSTR             g_wszSchemaFileNameWithoutPathWithoutExtension;
LPWSTR             g_wszSchemaFileNameExtension;
LPWSTR		       g_wszHistoryFileDir;
LPWSTR		       g_wszHistoryFileSearchString;
LPWSTR             g_wszErrorFileSearchString;
LPWSTR             g_wszSchemaExtensionFile;
	
ULONG		       g_cchTempFileName;
ULONG		       g_cchRealFileName;
ULONG		       g_cchBackupFileName;
ULONG		       g_cchSchemaFileName;
ULONG		       g_cchRealFileNameWithoutPath;
ULONG		       g_cchMetabaseDir;
ULONG		       g_cchRealFileNameWithoutPathWithoutExtension;
ULONG		       g_cchRealFileNameExtension;
ULONG              g_cchSchemaFileNameWithoutPath;
ULONG              g_cchSchemaFileNameWithoutPathWithoutExtension;
ULONG              g_cchSchemaFileNameExtension;
ULONG		       g_cchHistoryFileDir;
ULONG		       g_cchHistoryFileSearchString;
ULONG              g_cchErrorFileSearchString;
ULONG              g_cchSchemaExtensionFile;

//
// This is the array that holds the handle to the metabase schema and data 
// files. These files are locked when edit while running is disabled and
// this array holds these handles. It is protected by the read/save semaphore.
//

HANDLE g_ahMetabaseFile[cMetabaseFileTypes];

//
// ListenerController is the object that controls edit while running
//

CListenerController* g_pListenerController = NULL;

//
// Global event logging object
//
ICatalogErrorLogger2*          g_pEventLog = NULL;

//
// Debugging stuff
//

    DECLARE_DEBUG_VARIABLE();
    DECLARE_DEBUG_PRINTS_OBJECT();

DWORD           g_dwProcessAttached = 0;



DWORD g_dwCMDBaseObjectNextUniqueDataSetNumber = 1;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\connect.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    connect.cxx

Abstract:

    IIS MetaBase connection point code.

Author:

    Michael W. Thomas            02-Oct-96

Revision History:

--*/
/*+==========================================================================
  File:      CONNECT.CPP

  Summary:   Implementation file for the connection points (and their
             connections) offered by the connectable objects in the
             STOSERVE server sample. COM objects are implemented for
             Connection Point Enumerators, Connection Points, and
             Connection Enumerators.

             For a comprehensive tutorial code tour of this module's
             contents and offerings see the accompanying STOSERVE.TXT
             file. For more specific technical details on the internal
             workings see the comments dispersed throughout the module's
             source code.

  Classes:   COEnumConnectionPoints, COConnectionPoint, and
             COEnumConnections.

  Functions: none.

  Origin:    6-10-96: atrent - Editor inheritance from CONSERVE OLE
             Tutorial Code Sample. Very little change was required.

----------------------------------------------------------------------------
  This file is part of the Microsoft OLE Tutorial Code Samples.

  Copyright (C) Microsoft Corporation, 1996.  All rights reserved.

  This source code is intended only as a supplement to Microsoft
  Development Tools and/or on-line documentation.  See these other
  materials for detailed information regarding Microsoft code samples.

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
  PARTICULAR PURPOSE.
==========================================================================+*/


/*---------------------------------------------------------------------------
  We include WINDOWS.H for all Win32 applications.
  We include OLE2.H because we will be making calls to the OLE Libraries.
  We include OLECTL.H because it has definitions for connectable objects.
  We include APPUTIL.H because we will be building this application using
    the convenient Virtual Window and Dialog classes and other
    utility functions in the APPUTIL Library (ie, APPUTIL.LIB).
  We include IPAPER.H and PAPGUIDS.H for the common paper-related
    Interface class, GUID, and CLSID specifications.
  We include SERVER.H because it has internal class declarations and
    resource ID definitions specific for this DLL.
  We include CONNECT.H for object class declarations for the various
    connection point and connection COM objects used in CONSERVE.
  We include PAPER.H because it has the class COEnumConnectionPoints
    declarations as well as the COPaper class declaration.
---------------------------------------------------------------------------*/
#include <mdcommon.hxx>


/*---------------------------------------------------------------------------
  COEnumConnectionPoints's implementation of its main COM object class
  including Constructor, Destructor, QueryInterface, AddRef, Release,
  Next, Skip, Reset, and Clone.
---------------------------------------------------------------------------*/

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::COEnumConnectionPoints

  Summary:  COEnumConnectionPoints Constructor.

  Args:     IUnknown* pHostObj
              Pointer to the host object whose connection points are
              being enumerated.

  Modifies: m_cRefs, m_pHostObj, m_iEnumIndex, m_cConnPts, and m_paConnPts.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COEnumConnectionPoints::COEnumConnectionPoints(
  IUnknown* pHostObj)
{
  // Zero the COM object's reference count.
  m_cRefs = 0;

  // Assign the Host Object pointer.
  m_pHostObj = pHostObj;

  // Initialize the Connection Point enumerator variables.
  m_iEnumIndex = 0;
  m_cConnPts = 0;
  m_paConnPts = NULL;

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::~COEnumConnectionPoints

  Summary:  COEnumConnectionPoints Destructor.

  Args:     void

  Modifies: m_paConnPts.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COEnumConnectionPoints::~COEnumConnectionPoints(void)
{
  if (NULL != m_paConnPts)
  {
    UINT i;

    // Release all the connection point interface pointers.
    for (i=0; i<m_cConnPts; i++)
      if (NULL != m_paConnPts[i])
        m_paConnPts[i]->Release();

    // Delete the array of interface pointers.
    delete [] m_paConnPts;
  }

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Init

  Summary:  COEnumConnectionPoints Initialization method.  Create any
            necessary arrays, structures, and objects.

  Args:     ULONG cConnPts,
              Number of Connections Points.
            IConnectionPoint** paConnPts,
              Pointer to array of connection point interface pointers.
            ULONG iEnumIndex
              The initial Enumerator index value.

  Modifies: m_cConnPts, m_paConnPts, m_iEnumIndex.

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COEnumConnectionPoints::Init(
          ULONG cConnPts,
          IConnectionPoint** paConnPts,
          ULONG iEnumIndex)
{
  HRESULT hr = NOERROR;
  UINT i;

  // Remember the number of Connection points.
  m_cConnPts = cConnPts;

  // Remember the initial enumerator index.
  m_iEnumIndex = iEnumIndex;

  // Create a copy of the array of connection points and keep it inside
  // this enumerator COM object.
  m_paConnPts = new IConnectionPoint* [(UINT) cConnPts];

  // Fill the array copy with the IConnectionPoint interface pointers from
  // the array passed. AddRef for each new Interface pointer copy made.
  if (NULL != m_paConnPts)
  {
    for (i=0; i<cConnPts; i++)
    {
      m_paConnPts[i] = paConnPts[i];
      m_paConnPts[i]->AddRef();
    }
  }
  else
    hr = E_OUTOFMEMORY;

  return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::QueryInterface

  Summary:  QueryInterface of the COEnumConnectionPoints non-delegating
            IUnknown implementation.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            PPVOID ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::QueryInterface(
               REFIID riid,
               PPVOID ppv)
{
  HRESULT hr = E_NOINTERFACE;

  *ppv = NULL;

  // The IEnumConnectionPoints interface is implemented directly in
  // this COM object rather than being a nested interface implementation.
  if (IID_IUnknown == riid || IID_IEnumConnectionPoints == riid)
    *ppv = (LPVOID)this;

  if (NULL != *ppv)
  {
    // We've handed out a pointer to the interface so obey the COM rules
    // and AddRef the reference count.
    ((LPUNKNOWN)*ppv)->AddRef();
    hr = NOERROR;
  }

  return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::AddRef

  Summary:  AddRef of the COEnumConnectionPoints non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COEnumConnectionPoints::AddRef(void)
{
  ULONG cRefs;

  cRefs = ++m_cRefs;

  // Also AddRef the host object to ensure it stays around as long as
  // this enumerator.
  m_pHostObj->AddRef();

  return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Release

  Summary:  Release of the COEnumConnectionPoints non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COEnumConnectionPoints::Release(void)
{
  ULONG cRefs;

  // Pass this release along to the Host object being enumerated.
  m_pHostObj->Release();

  cRefs = --m_cRefs;

  if (0 == cRefs)
  {
    // We artificially bump the main ref count to prevent reentrancy via
    // the main object destructor.
    m_cRefs++;
    delete this;
  }

  return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Next

  Summary:  The Next member method of this IEnumConnectionPoints interface
            implementation. Called by outside clients of a
            COEnumConnectionPoints object to request that a number of next
            connection point interface pointers be deposited into an array
            supplied by the caller.

  Args:     ULONG cReq
              Number of connection points requested for return (starting at
              the current Enumerator index).
            IConnectionPoint** paConnPts,
              Pointer to a caller's output array that will receive the
              enumerated IConnectionPoint interface pointers.
            ULONG* cEnumerated)
              Pointer to a ULONG variable that will contain the number of
              connection points actually enumerated by this call.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::Next(
               ULONG cReq,
               IConnectionPoint** paConnPts,
               ULONG* pcEnumerated)
{
  HRESULT hr = NOERROR;
  ULONG cRet = 0;

  // Make sure the argument values passed are valid.
  if (NULL != m_paConnPts)
  {
    if (NULL != paConnPts)
    {
      if (NULL != *paConnPts && m_iEnumIndex < m_cConnPts)
      {
        if (NULL != pcEnumerated)
          *pcEnumerated = 0L;
        else
          if (1L != cReq)
            hr = E_POINTER;
      }
      else
        hr = S_FALSE;
    }
    else
      hr = E_POINTER;
  }
  else
    hr = S_FALSE;

  if (SUCCEEDED(hr))
  {
    // Starting at the current Enumerator index, loop to assign the
    // requested number of output connection point interface pointers.
    for (; m_iEnumIndex < m_cConnPts && cReq > 0;
           paConnPts++, cRet++, cReq--)
    {
      // Assign from the inside Enumerator array to the specified receiving
      // array.
      *paConnPts = m_paConnPts[m_iEnumIndex++];
      // After assigning a copy of an IConnectionPoint pointer, AddRef it.
      if (NULL != *paConnPts)
        (*paConnPts)->AddRef();
    }

    // Assign the output number of connection points enumerated.
    if (NULL != pcEnumerated)
      *pcEnumerated = cRet;
  }

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Skip

  Summary:  The Skip member method of this IEnumConnectionPoints interface
            implementation. Starting at the current Enumerator index, skip
            the specified number of connection point items.

  Args:     ULONG cSkip
              Number of Connection Point items to skip.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::Skip(
               ULONG cSkip)
{
  HRESULT hr = NOERROR;

  // If there really is a connection point array and the requested
  // amount of skip does not exceed the number of connection points,
  // then bump the index by the requested skip amount.
  if (NULL != m_paConnPts && (m_iEnumIndex + cSkip) < m_cConnPts)
    m_iEnumIndex += cSkip;
  else
    hr = S_FALSE;

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Reset

  Summary:  The Reset member method of the IEnumConnectionPoints interface
            implementation. Resets the Enumeration index to the first
            connection point item in the array.

  Args:     void.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::Reset(
               void)
{
  // Zero the main Enumerator index.
  m_iEnumIndex = 0;

  return NOERROR;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnectionPoints::Clone

  Summary:  The Clone member method of this IEnumConnectionPoints
            interface implementation. Creates a new clone of this entire
            Connection Point enumerator COM object.

  Args:     IEnumConnectionPoints** ppIEnum
              Address of the caller's output pointer variable that will
              receive the IEnumConnectionPoints interface pointer of the
              new enumerator clone.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnectionPoints::Clone(
               IEnumConnectionPoints** ppIEnum)
{
  HRESULT hr;
  COEnumConnectionPoints* pCOEnum;

  // NULL the output variable first.
  *ppIEnum = NULL;

  // Create the Clone Enumerator COM object.
  pCOEnum = new COEnumConnectionPoints(m_pHostObj);
  if (NULL != pCOEnum)
  {
    // Initialize it with same values as in this existing enumerator.
    hr = pCOEnum->Init(m_cConnPts, m_paConnPts, m_iEnumIndex);
    if (SUCCEEDED(hr))
    {
        // QueryInterface to return the requested interface pointer.
        // An AddRef will be conveniently done by the QI.
        hr = pCOEnum->QueryInterface(
                        IID_IEnumConnectionPoints,
                        (PPVOID)ppIEnum);
    }
    else
    {
        delete pCOEnum;
    }
  }
  else
    hr = E_OUTOFMEMORY;

  return hr;
}


/*---------------------------------------------------------------------------
  COConnectionPoint's implementation of its main COM object class
  including Constructor, Destructor, QueryInterface, AddRef, Release,
  GetConnectionInterface, GetConnectionPointContainer, Advise, Unadvise,
  and EnumConnections.
---------------------------------------------------------------------------*/

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::COConnectionPoint

  Summary:  COConnectionPoint Constructor.

  Args:     IUnknown* pHostObj
              Pointer to IUnknown of the connectable object offering this
              connection point.

  Modifies: ...

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COConnectionPoint::COConnectionPoint(
  IUnknown* pHostObj)
{
  // Zero the COM object's reference count.
  m_cRefs = 0;

  // Remember an IUnknown pointer to the connectable object that offers
  // this connection point. Since this connection point object's lifetime
  // is geared to that of the connectable object there is no need to
  // AddRef the following copied pointer to the connectable object.
  m_pHostObj = pHostObj;

  // Initialize the Connection Point variables.
  m_dwNextCookie = COOKIE_START_VALUE;
  m_uiMaxIndex = 0;
  m_cConnections = 0;
  m_paConnections = NULL;

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::~COConnectionPoint

  Summary:  COConnectionPoint Destructor.

  Args:     void

  Modifies: m_paConnections.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COConnectionPoint::~COConnectionPoint(void)
{
  UINT i;
  IUnknown* pUnk;

  if (NULL != m_paConnections)
  {
    // Release all the connection sink interface pointers.
    for (i=0; i<m_uiMaxIndex; i++)
    {
      pUnk = m_paConnections[i].pUnk;
      if (NULL != pUnk)
        pUnk->Release();
    }

    // Delete the array of interface pointers.
    delete [] m_paConnections;
  }

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Init

  Summary:  COConnectionPoint Initialization method.  Create any
            necessary arrays, structures, and subordinate objects.

  Args:     REFIID riid
              Reference to the IID of the Sink interface associated with
              this connection point.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COConnectionPoint::Init(
          REFIID riid)
{
  HRESULT hr = NOERROR;
  CONNECTDATA* paConns;

  // Keep a copy of the reference to the IID of the sink interface
  // associated with this connection point. Needed for later
  // use by the GetConnectionInterface method.
  m_iidSink = riid;

  // Build the initial dynamic array for connections.
  paConns = new CONNECTDATA[ALLOC_CONNECTIONS];
  if (NULL != paConns)
  {
    // Zero the array.
    memset(paConns, 0, ALLOC_CONNECTIONS * sizeof(CONNECTDATA));

    // Rig this connection point object so that it will use the
    // new internal array of connections.
    m_uiMaxIndex = ALLOC_CONNECTIONS;
    m_paConnections = paConns;
  }
  else
    hr = E_OUTOFMEMORY;

  return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::QueryInterface

  Summary:  QueryInterface of the COConnectionPoint non-delegating
            IUnknown implementation.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            PPVOID ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::QueryInterface(
               REFIID riid,
               PPVOID ppv)
{
  HRESULT hr = E_NOINTERFACE;

  *ppv = NULL;

  // The IConnectionPoint interface is implemented directly in this
  // COM object rather than being a nested interface implementation.
  if (IID_IUnknown == riid || IID_IConnectionPoint == riid)
    *ppv = (LPVOID)this;

  if (NULL != *ppv)
  {
    // We've handed out a pointer to the interface so obey the COM rules
    // and AddRef the reference count.
    ((LPUNKNOWN)*ppv)->AddRef();
    hr = NOERROR;
  }

  return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::AddRef

  Summary:  AddRef of the COConnectionPoint non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COConnectionPoint::AddRef(void)
{
  ULONG cRefs;
  cRefs = InterlockedIncrement((long *)&m_cRefs);
  return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Release

  Summary:  Release of the COConnectionPoint non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COConnectionPoint::Release(void)
{
  ULONG cRefs;

    cRefs = InterlockedDecrement((long *)&m_cRefs);

    if (0 == cRefs)
    {
      // We artificially bump the main ref count to prevent reentrancy via
      // the main object destructor. We relinquish thread ownership of this
      // object prior to deleting it--a good practice.
      InterlockedIncrement((long *)&m_cRefs);
      delete this;
    }

  return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::GetSlot

  Summary:  An internal private utility member method to obtain a free
            slot in the dynamic connections array. GetSlot will expand the
            dynamic array for more entries if needed. To guarantee thread
            safety, this private method should always be called within the
            protection of a bracketed OwnThis, UnOwnThis pair.

  Args:     UINT* puiFreeSlot
              Address of an output variable to receive the free slot index.

  Modifies: m_uiMaxIndex, m_paConnections.

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COConnectionPoint::GetSlot(
          UINT* puiFreeSlot)
{
  HRESULT hr = NOERROR;
  BOOL bOpen = FALSE;
  UINT i;
  CONNECTDATA* paConns;

  // Zero the output variable.
  *puiFreeSlot = 0;

  // Loop to find an empty slot.
  for (i=0; i<m_uiMaxIndex; i++)
  {
    if (m_paConnections[i].dwCookie == 0)
    {
      // We found an open empty slot.
      *puiFreeSlot = i;
      bOpen = TRUE;
      break;
    }
  }

  if (!bOpen)
  {
    // We didn't find an existing open slot in the array--it's full.
    // Expand the array by ALLOC_CONNECTIONS entries and assign the
    // appropriate output index.
    paConns = new CONNECTDATA[m_uiMaxIndex + ALLOC_CONNECTIONS];
    if (NULL != paConns)
    {
      // Copy the content of the old full array to the new larger array.
      for (i=0; i<m_uiMaxIndex; i++)
      {
        paConns[i].pUnk = m_paConnections[i].pUnk;
        paConns[i].dwCookie = m_paConnections[i].dwCookie;
      }

      // Zero (ie mark as empty) the expanded portion of the new array.
      for (i=m_uiMaxIndex; i<m_uiMaxIndex+ALLOC_CONNECTIONS; i++)
      {
        paConns[i].pUnk = NULL;
        paConns[i].dwCookie = 0;
      }

      // New larger array is ready--delete the old array.
      delete [] m_paConnections;

      // Rig the connection point to use the new larger array.
      m_paConnections = paConns;

      // Assign the output free slot as first entry in new expanded area.
      *puiFreeSlot = m_uiMaxIndex;

      // Calculate the new max index.
      m_uiMaxIndex += ALLOC_CONNECTIONS;
    }
    else
      hr = E_OUTOFMEMORY;
  }

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::FindSlot

  Summary:  An internal private utility member method to find an existing
            slot (identified by the specified dwCookie value) in the
            dynamic connections array.

  Args:     DWORD dwCookie,
              The connection key (cookie) to find.
            UINT* puiSlot)
              Address of an output variable to receive the slot index.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COConnectionPoint::FindSlot(
          DWORD dwCookie,
          UINT* puiSlot)
{
  HRESULT hr = CONNECT_E_NOCONNECTION;
  UINT i;

  // Loop to find the Cookie.
  for (i=0; i<m_uiMaxIndex; i++)
  {
    if (dwCookie == m_paConnections[i].dwCookie)
    {
      // If a cookie match is found, assign the output slot index.
      *puiSlot = i;
      hr = NOERROR;
      break;
    }
  }

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::GetConnectionInterface

  Summary:  The GetConnectionInterface member method of this
            IConnectionPoint interface implementation. Called to get the
            IID of the Sink interface associated with this connection
            point.

  Args:     IID* piidSink
              Pointer to the IID of the associated sink interface.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::GetConnectionInterface(
               IID* piidSink)
{
  HRESULT hr = NOERROR;

  if (NULL != piidSink)
    *piidSink = m_iidSink;
  else
    hr = E_POINTER;

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::GetConnectionPointContainer

  Summary:  The GetConnectionPointContainer member method of this
            IConnectionPoint interface implementation. Called to get the
            connection point container that contains this connection
            point.

  Args:     IConnectionPointContainer** ppConnPtCon
              Address of the pointer variable that will recieve the
              IConnectionPointContainer interface pointer.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::GetConnectionPointContainer(
               IConnectionPointContainer** ppConnPtCon)
{
  HRESULT hr;

  // Use QueryInterface to get the interface pointer and to perform the
  // needed AddRef on the returned pointer.
  hr = m_pHostObj->QueryInterface(
                     IID_IConnectionPointContainer,
                     (PPVOID) ppConnPtCon);

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Advise

  Summary:  The Advise member method of this IConnectionPoint interface
            implementation. Called by clients to establish a connection of
            their sink to this connection point. Uses the CThreaded
            OwnThis mechanism to provide mutually exclusive access by
            multiple threads.

  Args:     IUnknown* pUnkSink
              IUnknown interface pointer of the Sink object in the client.
            DWORD* pdwCookie
              Pointer to a DWORD in the client that will receive a unique
              key used by the client to refer to the connection established
              by this Advise call.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::Advise(
               IUnknown* pUnkSink,
               DWORD* pdwCookie)
{
  HRESULT hr = NOERROR;
  UINT uiFreeSlot = 0;
  IUnknown* pISink = NULL;

  g_rSinkResource->Lock(TSRES_LOCK_WRITE);
    // Zero the output connection key.
    *pdwCookie = 0;

    // Get the specific associated client Sink interface that this
    // connection point expects to use for notifications.
    hr = pUnkSink->QueryInterface(m_iidSink, (PPVOID)&pISink);
    if (SUCCEEDED(hr))
    {
      // Store the specific sink interface in this connection point's
      // array of live connections. First find a free slot (expand the
      // array if needed).
      hr = GetSlot(&uiFreeSlot);
      if (SUCCEEDED(hr))
      {
        // Assign the new slot with the connection entry.
        m_paConnections[uiFreeSlot].pUnk = pISink;
        m_paConnections[uiFreeSlot].dwCookie = m_dwNextCookie;

        // Assign the output Cookie value.
        *pdwCookie = m_dwNextCookie;

        // Increment the Cookie counter.
        m_dwNextCookie++;

        // Increment the number of live connections.
        m_cConnections++;
      }
    }
    else
      hr = CONNECT_E_CANNOTCONNECT;

  g_rSinkResource->Unlock();

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::Unadvise

  Summary:  The Unadvise member method of this IConnectionPoint interface
            implementation. Called by clients to disconnect a connection
            of their sink to this connection point. The connection is
            identified by the dwCookie argument (obtained by a previous
            Advise call). Uses the CThreaded OwnThis mechanism to provide
            mutually exclusive access by multiple threads.

  Args:     DWORD dwCookie
              Connection key that was obtained by a previous Advise call.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::Unadvise(
               DWORD dwCookie)
{
  HRESULT hr = NOERROR;
  UINT uiSlot;

  if (0 != dwCookie)
  {
      g_rSinkResource->Lock(TSRES_LOCK_WRITE);
      hr = FindSlot(dwCookie, &uiSlot);
      if (SUCCEEDED(hr))
      {
        // Release the sink interface.
        RELEASE_INTERFACE(m_paConnections[uiSlot].pUnk);

        // Mark the array entry as empty.
        m_paConnections[uiSlot].dwCookie = 0;

        // Decrement the number of live connections.
        m_cConnections--;
      }

      g_rSinkResource->Unlock();
  }
  else
    hr = E_INVALIDARG;

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COConnectionPoint::EnumConnections

  Summary:  The EnumConnections member method of this IConnectionPoint
            interface implementation. Called to obtain an IEnumConnections
            enumerator interface that can be used to enumerate the
            connections of this connection point. Uses the CThreaded
            OwnThis mechanism to ensure mutually exclusive access by
            multiple threads.

  Args:     IEnumConnections** ppIEnum
              Address of the caller's output pointer variable that will
              receive the enumerator IEnumConnections interface pointer.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COConnectionPoint::EnumConnections(
               IEnumConnections** ppIEnum)
{
  HRESULT hr = OLE_E_NOCONNECTION;
  CONNECTDATA* paConns;
  COEnumConnections* pCOEnum;
  UINT i,j;

  g_rSinkResource->Lock(TSRES_LOCK_READ);
  // Zero the output enumerator interface pointer.
  *ppIEnum = NULL;

  if (0 != m_cConnections) {
      // Create an array of CONNECTDATA structures.
      paConns = new CONNECTDATA[(UINT)m_cConnections];
      if (NULL != paConns) {
          for (i=0, j=0; i<m_uiMaxIndex && j<m_cConnections; i++) {
            // Copy non-empty entries only.
            if (0 != m_paConnections[i].dwCookie) {
              // Assign the occupied entry.
              paConns[j].pUnk = (IUnknown*)m_paConnections[i].pUnk;
              paConns[j].dwCookie = m_paConnections[i].dwCookie;
              j++;
            }
          }

          // Create a new COM object for enumerating connections. Pass
          // 'this' as a pHostObj pointer used later to ensure the host
          // connection point object stays alive as long as the enumerator
          // that enumerates connections to that connection point.
          pCOEnum = new COEnumConnections(this);
          if (NULL != pCOEnum)
          {
              // Use the previously constructed (paConns) array of connections
              // to init the new COEnumConnections COM object. The Init will
              // build yet another internal copy of this array. Set the
              // initial enumerator index to 0.
              hr = pCOEnum->Init(m_cConnections, paConns, 0);

              // QueryInterface to return the requested interface pointer.
              // An AddRef will be conveniently done by the QI.
              if (SUCCEEDED(hr)) {
                hr = pCOEnum->QueryInterface(
                                IID_IEnumConnections,
                                (PPVOID)ppIEnum);
              }
          }
          else {
              hr = E_OUTOFMEMORY;
          }

          // We're done with the locally constructed array copy--delete it.
          delete [] paConns;
      }
      else {
          hr = E_OUTOFMEMORY;
      }
  }

  g_rSinkResource->Unlock();

  return hr;
}


/*---------------------------------------------------------------------------
  COEnumConnections's implementation of its main COM object class
  including Constructor, Destructor, QueryInterface, AddRef, Release,
  Next, Skip, Reset, and Clone.
---------------------------------------------------------------------------*/

/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::COEnumConnections

  Summary:  COEnumConnections Constructor.

  Args:     IUnknown* pHostObj
              Pointer to IUnknown interface of the host Connection Point
              COM object whose connections are being enumerated.

  Modifies: m_cRefs, m_pHostObj, m_iEnumIndex, m_cConnections,
            and m_paConnections.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COEnumConnections::COEnumConnections(
  IUnknown* pHostObj)
{
  // Zero the COM object's reference count.
  m_cRefs = 0;

  // Assign the Host Object pointer.
  m_pHostObj = pHostObj;

  // Initialize the Connection Point enumerator variables.
  m_iEnumIndex = 0;
  m_cConnections = 0;
  m_paConnections = NULL;

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::~COEnumConnections

  Summary:  COEnumConnections Destructor.

  Args:     void

  Modifies: m_paConnections.

  Returns:  void
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
COEnumConnections::~COEnumConnections(void)
{
  if (NULL != m_paConnections)
  {
    UINT i;

    // Release all the connected sink interface pointers.
    for (i=0; i<m_cConnections; i++)
      m_paConnections[i].pUnk->Release();

    // Delete the array of connections.
    delete [] m_paConnections;
  }

  return;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Init

  Summary:  COEnumConnections Initialization method.  Create any
            necessary arrays, structures, and objects.

  Args:     ULONG cConnections
              Number of Connections.
            CONNECTDATA* paConnections,
              Pointer to array of connections.
            ULONG iEnumIndex
              The Enumerator index initial value.

  Modifies: m_cConnections, m_paConnections, m_pHostObj, m_iEnumIndex.

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
HRESULT COEnumConnections::Init(
          ULONG cConnections,
          CONNECTDATA* paConnections,
          ULONG iEnumIndex)
{
  HRESULT hr = NOERROR;
  UINT i;

  // Remember the number of live Connections.
  m_cConnections = cConnections;

  // Remember the initial enumerator index.
  m_iEnumIndex = iEnumIndex;

  // Create a copy of the array of connections and keep it inside
  // this enumerator COM object.
  m_paConnections = new CONNECTDATA [(UINT) cConnections];

  // Fill the array copy with the connection data from the connections
  // array passed. AddRef for each new sink Interface pointer copy made.
  if (NULL != m_paConnections)
  {
    for (i=0; i<cConnections; i++)
    {
      m_paConnections[i] = paConnections[i];
      m_paConnections[i].pUnk->AddRef();
    }
  }
  else
    hr = E_OUTOFMEMORY;

  return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::QueryInterface

  Summary:  QueryInterface of the COEnumConnections non-delegating
            IUnknown implementation.

  Args:     REFIID riid,
              [in] GUID of the Interface being requested.
            PPVOID ppv)
              [out] Address of the caller's pointer variable that will
              receive the requested interface pointer.

  Modifies: .

  Returns:  HRESULT
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::QueryInterface(
               REFIID riid,
               PPVOID ppv)
{
  HRESULT hr = E_NOINTERFACE;

  *ppv = NULL;

  // The IEnumConnections interface is implemented directly in
  // this COM object rather than being a nested interface implementation.
  if (IID_IUnknown == riid || IID_IEnumConnections == riid)
    *ppv = (LPVOID)this;

  if (NULL != *ppv)
  {
    // We've handed out a pointer to the interface so obey the COM rules
    // and AddRef the reference count.
    ((LPUNKNOWN)*ppv)->AddRef();
    hr = NOERROR;
  }

  return (hr);
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::AddRef

  Summary:  AddRef of the COEnumConnections non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COEnumConnections::AddRef(void)
{
  ULONG cRefs;

  cRefs = InterlockedIncrement((long *)&m_cRefs);

  // Also AddRef the host object to ensure it stays around as long as
  // this enumerator.
  m_pHostObj->AddRef();

  return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Release

  Summary:  Release of the COEnumConnections non-delegating IUnknown
            implementation.

  Args:     void

  Modifies: m_cRefs.

  Returns:  ULONG
              New value of m_cRefs (COM object's reference count).
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP_(ULONG) COEnumConnections::Release(void)
{
  ULONG cRefs;

  // Pass this release along to the Host object being enumerated.
  m_pHostObj->Release();

  cRefs = InterlockedDecrement((long *)&m_cRefs);

  if (0 == cRefs)
  {
    // We artificially bump the main ref count to prevent reentrancy via
    // the main object destructor.
    InterlockedIncrement((long *)&m_cRefs);
    delete this;
  }

  return cRefs;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Next

  Summary:  The Next member method of this IEnumConnections interface
            implementation. Called by outside clients of a
            COEnumConnections object to request a number of next
            connections be returned in an array supplied by the caller.

  Args:     ULONG cReq
              Number of connection points requested for return (starting at
              the current Enumerator index).
            CONNECTDATA* paConnections,
              Pointer to a caller's output array that will receive the
              enumerated connection data structures.
            ULONG* pcEnumerated)
              Pointer to a ULONG variable that will contain the number of
              connection points actually enumerated by this call.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::Next(
               ULONG cReq,
               CONNECTDATA* paConnections,
               ULONG* pcEnumerated)
{
  HRESULT hr = NOERROR;
  ULONG cRet = 0;

  // Make sure the argument values passed are valid.
  if (NULL != m_paConnections)
  {
    if (NULL != paConnections)
    {
      if (m_iEnumIndex < m_cConnections)
      {
        if (NULL != pcEnumerated)
          *pcEnumerated = 0L;
        else
          if (1L != cReq)
            hr = E_POINTER;
      }
      else
        hr = S_FALSE;
    }
    else
      hr = E_POINTER;
  }
  else
    hr = S_FALSE;

  if (SUCCEEDED(hr))
  {
    // Starting at the current Enumerator index, loop to assign the
    // requested number of output connection data structures.
    for (; m_iEnumIndex < m_cConnections && cReq > 0;
           paConnections++, m_iEnumIndex++, cRet++, cReq--)
    {
      // Because we are assigning a copy of a connection's data, AddRef
      // its sink interface pointer.
      if (NULL != m_paConnections[m_iEnumIndex].pUnk)
        m_paConnections[m_iEnumIndex].pUnk->AddRef();

      // Assign a connection's data from the inside Enumerator array to
      // the specified output receiving array.
      *paConnections = m_paConnections[m_iEnumIndex];
    }

    // Assign the output number of connections enumerated.
    if (NULL != pcEnumerated)
      *pcEnumerated = cRet;
  }

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Skip

  Summary:  The Skip member method of this IEnumConnections interface
            implementation. Starting at the current Enumerator index, skip
            the specified number of connection items.

  Args:     ULONG cSkip
              Number of Connection items to skip.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::Skip(
               ULONG cSkip)
{
  HRESULT hr = NOERROR;

  // If there really is a connection array and the requested
  // amount of skip does not exceed the number of connections,
  // then bump the index by the requested skip amount.
  if (NULL != m_paConnections && (m_iEnumIndex + cSkip) < m_cConnections)
    m_iEnumIndex += cSkip;
  else
    hr = S_FALSE;

  return hr;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Reset

  Summary:  The Reset member method of the IEnumConnections interface
            implementation. Resets the Enumeration index to the first
            connection item in the array.

  Args:     void.

  Modifies: .

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::Reset(
               void)
{
  // Zero the main Enumerator index.
  m_iEnumIndex = 0;

  return NOERROR;
}


/*M+M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M+++M
  Method:   COEnumConnections::Clone

  Summary:  The Clone member method of this IEnumConnections interface
            implementation. Creates a new clone of this entire Connection
            enumerator COM object and returns a pointer to its
            IEnumConnections interface.

  Args:     IEnumConnections** ppIEnum
              Address of the caller's output pointer variable that will
              receive the IEnumConnections interface pointer of the
              new enumerator clone.

  Modifies: ...

  Returns:  HRESULT
              Standard OLE result code. NOERROR for success.
M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M---M-M*/
STDMETHODIMP COEnumConnections::Clone(
               IEnumConnections** ppIEnum)
{
  HRESULT hr;
  COEnumConnections* pCOEnum;

  // NULL the output variable first.
  *ppIEnum = NULL;

  // Create the Clone Enumerator COM object.
  pCOEnum = new COEnumConnections(m_pHostObj);
  if (NULL != pCOEnum)
  {
    // Initialize it with same values as in this existing enumerator.
    hr = pCOEnum->Init(m_cConnections, m_paConnections, m_iEnumIndex);
    if (SUCCEEDED(hr))
    {
      // QueryInterface to return the requested interface pointer.
      // An AddRef will be conveniently done by the QI.
        hr = pCOEnum->QueryInterface(
                        IID_IEnumConnections,
                        (PPVOID)ppIEnum);
    }
    else
    {
        delete pCOEnum;
    }
  }
  else
    hr = E_OUTOFMEMORY;

  return hr;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\handle.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    metasub.cxx

Abstract:

    IIS MetaBase handle routines

Author:

    Michael W. Thomas            04-Oct-96

Revision History:

Notes:

--*/

#include <mdcommon.hxx>

DWORD
CMDHandle::SetChangeData(CMDBaseObject *pboChanged,
         DWORD          dwChangeType,
         DWORD          dwDataID,
         LPWSTR         pszOldName)
{
    PCHANGE_ENTRY pceIndex;
    DWORD i;
    DWORD dwReturn = ERROR_SUCCESS;
    for (pceIndex = m_pceChangeList; pceIndex != NULL; pceIndex = pceIndex->NextPtr) {
        if (pceIndex->pboChanged == pboChanged) {
            break;
        }
    }
    if (pceIndex == NULL) {
        pceIndex = new(CHANGE_ENTRY);
        if (pceIndex == NULL) {
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        }
        else {
            pceIndex->dwNumDataIDs = 0;
            pceIndex->pbufDataIDs = NULL;
            pceIndex->dwChangeType = 0;
            pceIndex->pboChanged = pboChanged;
            pceIndex->NextPtr = m_pceChangeList;
            pceIndex->pStrOrigName = NULL;
            m_pceChangeList = pceIndex;
        }
    }
    if (dwReturn == ERROR_SUCCESS) {
        MD_ASSERT(pceIndex != NULL);
        pceIndex->dwChangeType |= dwChangeType;
        if ((dwChangeType == MD_CHANGE_TYPE_SET_DATA) ||
            (dwChangeType == MD_CHANGE_TYPE_DELETE_DATA) ||
            (dwChangeType == MD_CHANGE_TYPE_RENAME_OBJECT && pszOldName != NULL )) {
            if (pceIndex->pbufDataIDs == NULL) {
                pceIndex->pbufDataIDs = new BUFFER();
                if (pceIndex->pbufDataIDs == NULL) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            if (dwReturn == ERROR_SUCCESS && pceIndex->pStrOrigName == NULL && pszOldName !=NULL) {
                pceIndex->pStrOrigName = new STRAU();
                if (pceIndex->pStrOrigName == NULL) {
                    dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    // sucess 
                    // we are taking the old name of metabase key only once. 
                    // so if subsequent renames will happen we will return the oldest one
                    pceIndex->pStrOrigName->Copy (pszOldName);
                }
            }
            if (dwReturn == ERROR_SUCCESS) {
                for (i = 0; i < pceIndex->dwNumDataIDs; i++) {
                    if (((DWORD *)(pceIndex->pbufDataIDs->QueryPtr()))[i] == dwDataID) {
                        break;
                    }
                }
                if (i == pceIndex->dwNumDataIDs) {
                    if (!pceIndex->pbufDataIDs->Resize((pceIndex->dwNumDataIDs + 1) * sizeof(DWORD))) {
                        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else {
                        ((DWORD *)(pceIndex->pbufDataIDs->QueryPtr()))[pceIndex->dwNumDataIDs] = dwDataID;
                        pceIndex->dwNumDataIDs++;
                    }
                }
            }
        }
    }
    return dwReturn;
}

CMDHandle::~CMDHandle()
{
    RemoveNotifications();
}


PCHANGE_ENTRY
CMDHandle::EnumChangeEntries(DWORD dwIndex)
{
    PCHANGE_ENTRY pceIndex;
    DWORD i;
    for (i = 0, pceIndex = m_pceChangeList;
         pceIndex != NULL && i < dwIndex;
         i++, pceIndex = pceIndex->NextPtr) {
    }
    return pceIndex;
}

DWORD
CMDHandle::GetNumChangeEntries()
{
    DWORD dwCount = 0;
    PCHANGE_ENTRY pceIndex;

    for (pceIndex = m_pceChangeList;
        pceIndex !=NULL;
        pceIndex = pceIndex->NextPtr) {
        dwCount++;
    }

    return dwCount;
}

VOID
CMDHandle::RemoveNotifications()
{
    PCHANGE_ENTRY pceIndex, pceNext;
    for (pceIndex = m_pceChangeList; pceIndex != NULL; pceIndex = pceNext) {
        pceNext = pceIndex->NextPtr;
        delete(pceIndex->pbufDataIDs);
        delete(pceIndex->pStrOrigName);
        if ((pceIndex->dwChangeType & MD_CHANGE_TYPE_DELETE_OBJECT) != 0) {
            delete(pceIndex->pboChanged);
        }
        delete(pceIndex);
    }
    m_pceChangeList = NULL;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\infocomm\metadata\dll\comobj.cxx ===
#define INITGUID
#include <mdcommon.hxx>
#include <inetsvcs.h>
#include <issched.hxx>
#include <mbs.hxx>
#include <ptrmap.hxx>
#include <tuneprefix.h>

CIdToPointerMapper  *g_PointerMapper = NULL;


CMDCOM::CMDCOM():
    m_ImpIConnectionPointContainer(),
    m_hresConstructorError(ERROR_SUCCESS)
{
    UINT i;
    HRESULT hRes;

    m_dwRefCount = 0;
    g_hReadSaveSemaphore = NULL;

    g_PointerMapper = new CIdToPointerMapper (DEFAULT_START_NUMBER_OF_MAPS, DEFAULT_INCREASE_NUMBER_OF_MAPS);
    MD_ASSERT(g_PointerMapper);

    fFlusherInitialized = FALSE;
    dwMBFlushCookie = 0;
    msMBFlushTime = INETA_MB_FLUSH_DEFAULT;
    INITIALIZE_CRITICAL_SECTION( &csFlushLock );
    INITIALIZE_CRITICAL_SECTION( &g_csEditWhileRunning );


    // Null all entries in the connection point array.
    for (i=0; i<MAX_CONNECTION_POINTS; i++)
      m_aConnectionPoints[i] = NULL;

    HRESULT hr = NOERROR;

    g_hReadSaveSemaphore = IIS_CREATE_SEMAPHORE(
                               "g_hReadSaveSemaphore",
                               &g_hReadSaveSemaphore,
                               1,
                               1
                               );

    if( g_hReadSaveSemaphore == NULL ) {
        hr = GetLastHResult();
        IIS_PRINTF((buff,"CreateSemaphore Failed with %x\n",hr));
    }
    else {

        COConnectionPoint* pCOConnPt;

        m_ImpIConnectionPointContainer.Init(this);
        // Rig this COPaper COM object to be connectable. Assign the connection
        // point array. This object's connection points are determined at
        // compile time--it currently has 2 connection points, one for ANSI,
        // one for UNICODE. Create a connection
        // point object for these and assign them into the array. This array could
        // easily grow to support additional connection points in the future.

        // First try creating a new connection point object. Pass 'this' as the
        // pHostObj pointer used by the connection point to pass its AddRef and
        // Release calls back to the host connectable object.
        pCOConnPt = new COConnectionPoint((IUnknown*)this);
        if (NULL != pCOConnPt)
        {
          // If creation succeeded then initialize it (including creating
          // its initial dynamic connection array).
          hr = pCOConnPt->Init(IID_IMDCOMSINK_A);
          MD_ASSERT(SUCCEEDED(hr));

          // If the init succeeded then use QueryInterface to obtain the
          // IConnectionPoint interface on the new connection point object.
          // The interface pointer is assigned directly into the
          // connection point array. The QI also does the needed AddRef.
          if (SUCCEEDED(hr))
          {
            hr = pCOConnPt->QueryInterface(
                              IID_IConnectionPoint,
                              (PPVOID)&m_aConnectionPoints[MD_CONNPOINT_WRITESINK_A]);
            MD_ASSERT(SUCCEEDED(hr));
          }
          if( FAILED(hr) )
          {
            delete pCOConnPt;
          }
        }
        pCOConnPt = new COConnectionPoint((IUnknown*)this);
        if (NULL != pCOConnPt)
        {
          // If creation succeeded then initialize it (including creating
          // its initial dynamic connection array).
          hr = pCOConnPt->Init(IID_IMDCOMSINK_W);
          MD_ASSERT(SUCCEEDED(hr));

          // If the init succeeded then use QueryInterface to obtain the
          // IConnectionPoint interface on the new connection point object.
          // The interface pointer is assigned directly into the
          // connection point array. The QI also does the needed AddRef.
          if (SUCCEEDED(hr))
          {
            hr = pCOConnPt->QueryInterface(
                              IID_IConnectionPoint,
                              (PPVOID)&m_aConnectionPoints[MD_CONNPOINT_WRITESINK_W]);
            MD_ASSERT(SUCCEEDED(hr));
          }
          if( FAILED(hr) )
          {
            delete pCOConnPt;
          }
        }
    }
    m_hresConstructorError = hr;
}

CMDCOM::~CMDCOM()
{
//    SetEvent(hevtDone);
    UINT i;
    IConnectionPoint* pIConnectionPoint;
    // Do final release of the connection point objects.
    // If this isn't the final release, then the client has an outstanding
    // unbalanced reference to a connection point and a memory leak may
    // likely result because the host COPaper object is now going away yet
    // a connection point for this host object will not end up deleting
    // itself (and its connections array).
    for (i=0; i<MAX_CONNECTION_POINTS; i++)
    {
      pIConnectionPoint = m_aConnectionPoints[i];
      RELEASE_INTERFACE(pIConnectionPoint);
    }

    if (g_hReadSaveSemaphore != NULL) {
        CloseHandle(g_hReadSaveSemaphore);
    }
   DeleteCriticalSection( &csFlushLock );
   DeleteCriticalSection( &g_csEditWhileRunning );
   MD_ASSERT(g_PointerMapper);
   delete g_PointerMapper;

}

HRESULT
CMDCOM::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IMDCOM) {
        *ppObject = (IMDCOM *) this;
        AddRef();
    }
    else if ( IID_IMDCOM2 == riid )
    {
        *ppObject = (IMDCOM2 *) this;
        AddRef();
    }
    else if (IID_IConnectionPointContainer == riid) {
      *ppObject = &m_ImpIConnectionPointContainer;
      AddRef();
    }
    else {
        return E_NOINTERFACE;
    }
    return NO_ERROR;
}

ULONG
CMDCOM::AddRef()
{
    DWORD dwRefCount;
    InterlockedIncrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CMDCOM::Release()
{
    DWORD dwRefCount;
    InterlockedDecrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // This is now a member of class factory.
    // It is not dynamically allocated, so don't delete it.
    //
/*
    if (dwRefCount == 0) {
        delete this;
        return 0;
    }
*/
    return dwRefCount;
}

HRESULT
CMDCOM::ComMDInitialize()
/*++

Routine Description:

    Initializes the metadata database. This must be called before any other API.
    Reads in the existing database, if found. If errors occur reading in the
    existing database, warnings are returned and the metabase is initialized
    with not data.

Arguments:

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            ERROR_ALREADY_INITIALIZED
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_INVALID_DATA
            MD_WARNING_PATH_NOT_FOUND
            MD_WARNING_DUP_NAME
            MD_WARNING_INVALID_DATA

Notes:
    This could take a long time to process, as it may load in a large amount of data.
    If a warning code is returned, the database has been successfully initialized, but
    some data in the database was not loaded successfully.

--*/
{
    InitializeFlusher ();
    return InitWorker(FALSE, NULL, NULL, NULL);
}

HRESULT
CMDCOM::ComMDTerminate(IN BOOL bSaveData)
/*++

Routine Description:

    DeInitailizes the metadata database. This must be before the application terminates
    or dunloads the dll.

Arguments:

    SaveData      - If TRUE, the metadata is saved before terminating.
                    If the save fails, the metadata is not terminated.

Return Value:

    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_NOT_ENOUGH_MEMORY
              Errors from the file system.

Notes:
    This could take a long time to process, as it may save a large amount of data.

--*/
{

    return TerminateWorker1(FALSE);
}


HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDShutdown( void)
{
    HRESULT hresReturn;
    BOOL bSaveData;
    IIS_CRYPTO_STORAGE CryptoStorage;
    PIIS_CRYPTO_BLOB pSessionKeyBlob;


    TerminateFlusher ();
    SendShutdownNotifications();

    //
    // Give applications some time to close their interfaces,
    // but don't wait too long, user is waiting.
    // Wait until references are closed, unless they take too long.
    // IISADMIN and factory both have refences we do not wait for.
    //

    //
    // Note, there are four references to the CMDCOM object that
    // are allowed to be active after this point.
    // 1)  The reference taken in dllmain ( cleans up in dllmain ).
    // 2)  The reference owned by COADMIN itself 
    //     ( this is called as part of it's shutdown )
    // 3)  The reference owned by the MDWriter for backup and restore 
    //     ( it is released after TerminateComAdmindata is called )
    // 4)  The reference owned by the Metabase holder, 
    //     which is used to validate that the metabase is up
    //     and working if iisadmin is started.  
    //     ( it is also released after the TerminateComAdmindata is called )
    //
    for (int i = 0;
         (InterlockedIncrement((long *)&m_dwRefCount) > 5) &&
             (i < MD_SHUTDOWN_WAIT_SECONDS);
         i++) {
        InterlockedDecrement((long *)&m_dwRefCount);
        Sleep(1000);
    }

    InterlockedDecrement((long *)&m_dwRefCount);

    hresReturn = InitStorageAndSessionKey(
                     &CryptoStorage,
                     &pSessionKeyBlob
                     );

    if( SUCCEEDED(hresReturn) ) {

        //
        // Need to hold a read lock here to make sure
        // Terminate doesn't occur during SaveAllData.
        //
        // Cannot hold a write lock, as SaveAllData gets
        // a read lock after getting ReadSaveSemaphore
        //

        g_rMasterResource->Lock(TSRES_LOCK_READ);

        if (g_dwInitialized > 0) {
            hresReturn = SaveAllData(TRUE, &CryptoStorage, pSessionKeyBlob);
        }
        else {
            if (g_dwInitialized > 0) {
                MD_REQUIRE(WaitForSingleObject(g_hReadSaveSemaphore, INFINITE) != WAIT_TIMEOUT);
                g_bSaveDisallowed = TRUE;
                MD_REQUIRE(ReleaseSemaphore(g_hReadSaveSemaphore, 1, NULL));
            }
            else {
                g_bSaveDisallowed = TRUE;
            }
        }
        g_rMasterResource->Unlock();
        ::IISCryptoFreeBlob(pSessionKeyBlob);
    }

    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDAddMetaObjectA(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath)
{
    return ComMDAddMetaObjectD(hMDHandle,
                               pszMDPath,
                               FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDAddMetaObjectW(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ LPCWSTR pszMDPath)
{
    return ComMDAddMetaObjectD(hMDHandle,
                               (PBYTE) pszMDPath,
                               TRUE);
}

HRESULT
CMDCOM::ComMDAddMetaObjectD(IN METADATA_HANDLE hMDHandle,
        IN PBYTE pszMDPath,
        IN BOOL bUnicode)
/*++

Routine Description:

    Creates a meta object and adds it to the list of child objects for the object specified by Path.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path  - Path of the object to be added, relative to the path of Handle.
            Must not be NULL.
            eg. "Root Object/Child/GrandChild"

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_INVALID_PARAMETER
            ERROR_ACCESS_DENIED
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_PATH_NOT_FOUND
            ERROR_DUP_NAME
            ERROR_INVALID_NAME

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.

--*/
{
    HRESULT hresReturn;
    CMDHandle *hHandleObject;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else {
        WCHAR strPath[METADATA_MAX_NAME_LEN];
        LPSTR pszTempPath = (LPSTR)pszMDPath;

        //
        // ExtractNameFromPath assumes no preceding delimeter
        //

        if (pszTempPath != NULL) {
            SkipPathDelimeter(pszTempPath, bUnicode);
        }

        //
        // Make sure at least one new object was specified
        //

        hresReturn = ExtractNameFromPath(pszTempPath,
                                         (LPSTR)strPath,
                                         bUnicode);

        if (FAILED(hresReturn)) {
            hresReturn = E_INVALIDARG;
        }
        else {
            g_rMasterResource->Lock(TSRES_LOCK_WRITE);
    
            hHandleObject = GetHandleObject(hMDHandle);

            if(hHandleObject != NULL)
            {
                hresReturn = AddObjectToDataBase(hMDHandle, 
                                                 hHandleObject, 
                                                (LPSTR)pszMDPath, 
                                                bUnicode);
                if (SUCCEEDED(hresReturn)) {
                    g_dwSystemChangeNumber++;

                    INCREMENT_SCHEMA_CHANGE_NUMBER(hMDHandle, 
                                                   hHandleObject, 
                                                   (LPSTR)pszMDPath,
                                                   bUnicode);
                }
            }
            else 
            {
                hresReturn = E_HANDLE;
            }
            g_rMasterResource->Unlock();
        }
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaObjectA(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath)
{
    return ComMDDeleteMetaObjectD(hMDHandle,
                                  pszMDPath,
                                  FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteMetaObjectW(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ LPCWSTR pszMDPath)
{
    return ComMDDeleteMetaObjectD(hMDHandle,
                                  (PBYTE)pszMDPath,
                                  TRUE);
}

HRESULT
CMDCOM::ComMDDeleteMetaObjectD(IN METADATA_HANDLE hMDHandle,
        IN PBYTE pszMDPath,
        IN BOOL bUnicode)
/*++

Routine Description:

    Deletes a meta object and all of its data. Recursively deletes all descendants.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path - Path of object to be deleted, relative to the path of Handle.
           Must not be NULL.
           eg. "Root Object/Child/GrandChild"

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_INVALID_PARAMETER
            ERROR_PATH_NOT_FOUND
            ERROR_ACCESS_DENIED

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.

--*/
{
    HRESULT hresReturn;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((LPSTR)pszMDPath == NULL) {
       hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);

        CMDHandle *hMDHandleObject = GetHandleObject(hMDHandle);

        if(hMDHandleObject != NULL)
        {
            hresReturn = RemoveObjectFromDataBase(hMDHandle, 
                                                  hMDHandleObject, 
                                                  (LPSTR)pszMDPath, 
                                                  bUnicode); 
        }
        else 
        {
            hresReturn = E_HANDLE;
        }

        if (SUCCEEDED(hresReturn)) {
            g_dwSystemChangeNumber++;

            INCREMENT_SCHEMA_CHANGE_NUMBER(hMDHandle, 
                                           hMDHandleObject,
                                           (LPSTR)pszMDPath,
                                           bUnicode);
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteChildMetaObjectsA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath)
{
    return ComMDDeleteChildMetaObjectsD(hMDHandle,
                                        pszMDPath,
                                        FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteChildMetaObjectsW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath)
{
    return ComMDDeleteChildMetaObjectsD(hMDHandle,
                                        (PBYTE)pszMDPath,
                                        TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDDeleteChildMetaObjectsD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        IN BOOL bUnicode)
/*++

Routine Description:

    Deletes all child meta objects of the specified object, with all of their
    data. Recursively deletes all descendants of the child objects.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path - Path of the parent of the objects to be deleted, relative to the path of Handle.
           eg. "Root Object/Child"

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_PATH_NOT_FOUND
            ERROR_ACCESS_DENIED

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.

--*/
{
    HRESULT hresReturn;
    LPSTR pszPath = (LPSTR)pszMDPath;
    CMDBaseObject *pboParent;
    CMDBaseObject *pboChild;
    CMDHandle *phoHandle;

    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        hresReturn = GetObjectFromPath(pboParent, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            phoHandle = GetHandleObject(hMDHandle);
            MD_ASSERT (phoHandle != NULL);
            while ((pboChild = pboParent->EnumChildObject(0)) != NULL) {
                MD_REQUIRE(pboParent->RemoveChildObject(pboChild) == ERROR_SUCCESS);
                if (phoHandle->SetChangeData(pboChild, MD_CHANGE_TYPE_DELETE_OBJECT, 0) != ERROR_SUCCESS) {
                    delete(pboChild);
                }
            }
            g_dwSystemChangeNumber++;

            INCREMENT_SCHEMA_CHANGE_NUMBER(hMDHandle, 
                                           phoHandle, 
                                           (LPSTR)pszMDPath,
                                           bUnicode);
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaObjectsA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
    /* [in] */ DWORD dwMDEnumObjectIndex)
{
    return ComMDEnumMetaObjectsD(hMDHandle,
                                 pszMDPath,
                                 pszMDName,
                                 dwMDEnumObjectIndex,
                                 FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaObjectsW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [size_is][out] */ LPWSTR pszMDName,
    /* [in] */ DWORD dwMDEnumObjectIndex)
{
    return ComMDEnumMetaObjectsD(hMDHandle,
                                 (PBYTE)pszMDPath,
                                 (PBYTE)pszMDName,
                                 dwMDEnumObjectIndex,
                                 TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDEnumMetaObjectsD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [size_is][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [size_is][out] */ unsigned char __RPC_FAR *pszMDName,
        /* [in] */ DWORD dwMDEnumObjectIndex,
        IN BOOL bUnicode)
/*++

Routine Description:

    Enumerates all child metaobjects once per call. Child Objects are numbers from 0 to NumObjects - 1, where
    NumObjects is the number of current child objects. If EnumObjectIndex is >= NumObjects, ERROR_NO_MORE_ITEMS
    is returned.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    Path - Path of parent object, relative to the path of Handle.
           eg. "Root Object/Child/GrandChild"
    Name - Buffer where the Name of the object is returned. Must be at least METADATA_MAX_NAME_LEN characters long.

    EnumObjectIndex - Index of the value to be retrieved. The caller is expected to set this to 0 before the first call and increment
           it by 1 on each successive call until ERROR_NO_MORE_ITEMS is returned.
Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_INVALID_PARAMETER
            ERROR_ACCESS_DENIED
            ERROR_PATH_NOT_FOUND
            ERROR_NO_MORE_ITEMS

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid handle, but provides no gaurantee that other threads will
    not also change things. If a consistent data state is desired, use a handle returned by MDOpenMetaObject.

--*/
{
    HRESULT hresReturn;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((LPSTR)pszMDName == NULL) {
        hresReturn = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        CMDBaseObject *pboAffected, *pboChild;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            pboChild = pboAffected->EnumChildObject(dwMDEnumObjectIndex);
            if (pboChild != NULL) {
                PVOID pvName = (PVOID)pboChild->GetName(bUnicode);
                if (pvName == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    if (bUnicode) {
                        wcscpy((LPWSTR)pszMDName, (LPWSTR)pvName);
                    }
                    else {
                        MD_STRCPY((LPSTR)pszMDName, (LPSTR)pvName);
                    }
                }
                hresReturn = ERROR_SUCCESS;
            }
            else {
                hresReturn = RETURNCODETOHRESULT(ERROR_NO_MORE_ITEMS);
            }
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaObjectA(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
    /* [in] */ BOOL bMDOverwriteFlag,
    /* [in] */ BOOL bMDCopyFlag)
{
    return ComMDCopyMetaObjectD(hMDSourceHandle,
                                pszMDSourcePath,
                                hMDDestHandle,
                                pszMDDestPath,
                                bMDOverwriteFlag,
                                bMDCopyFlag,
                                FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaObjectW(
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ LPCWSTR pszMDDestPath,
    /* [in] */ BOOL bMDOverwriteFlag,
    /* [in] */ BOOL bMDCopyFlag)
{
    return ComMDCopyMetaObjectD(hMDSourceHandle,
                                (PBYTE)pszMDSourcePath,
                                hMDDestHandle,
                                (PBYTE)pszMDDestPath,
                                bMDOverwriteFlag,
                                bMDCopyFlag,
                                TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDCopyMetaObjectD(
        /* [in] */ METADATA_HANDLE hMDSourceHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDSourcePath,
        /* [in] */ METADATA_HANDLE hMDDestHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDDestPath,
        /* [in] */ BOOL bMDOverwriteFlag,
        /* [in] */ BOOL bMDCopyFlag,
        IN BOOL bUnicode)
/*++

Routine Description:

    Copies or moves Source meta object and it's data and descendants to Dest. The
    copied object is a child of Dest.

Arguments:

    SourceHandle - The handle or the object to be copied. If copyflag is specified, read permission
                   is requried. If not, read/write permission is required.

    SourcePath  - Path of the object to be copied, relative to the path of SourceHandle.
            eg. "Root Object/Child/GrandChild"

    DestHandle - The handle of the new location for the object. Write permission is required.

    DestPath  - The path of the new location for the object, relative to the path of
            DestHandle. The new object will be a child of the object specified by
            DestHandle/DestPath. Must not be a descendant of SourceHandle/SourePath.
            eg. "Root Object/Child2"

    OverwriteFlag - Determines the behavior if the a meta object with the same name as Source is
            already a child of Dest.
            If TRUE, the existing object and all of its data and
            descandants are deleted prior to copying/moving Source.
            If FALSE, the existing object, data, and descendants remain, and Source is merged
            in. In cases of data conflicts, the Source data overwrites the Dest data.

    CopyFlag - Determines whether Source is deleted from its original location.
            If TRUE, a copy is performed. Source is not deleted from its original location.
            If FALSE, a move is performed. Source is deleted from its original location.

Return Value:

    DWORD - Return Code
            ERROR_SUCCESS
            MD_ERROR_NOT_INITIALIZED
            ERROR_INVALID_PARAMETER
            ERROR_ACCESS_DENIED
            ERROR_NOT_ENOUGH_MEMORY
            ERROR_PATH_NOT_FOUND
            ERROR_DUP_NAME

Notes:

--*/
{
    return CopyMetaObject(
        hMDSourceHandle,
        pszMDSourcePath,
        true,
        NULL,
        hMDDestHandle,
        pszMDDestPath,
        bMDOverwriteFlag,
        bMDCopyFlag,
        bUnicode);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRenameMetaObjectA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName)
{
    return ComMDRenameMetaObjectD(hMDHandle,
                                  pszMDPath,
                                  pszMDNewName,
                                  FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRenameMetaObjectW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [string][in][unique] */ LPCWSTR pszMDNewName)
{
    return ComMDRenameMetaObjectD(hMDHandle,
                                  (PBYTE)pszMDPath,
                                  (PBYTE)pszMDNewName,
                                  TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDRenameMetaObjectD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
        /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDNewName,
        IN BOOL bUnicode)
{
    HRESULT hresReturn = ERROR_SUCCESS;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (((LPSTR)pszMDNewName == NULL) ||

        //
        // ExtractNameFromPath, below, checks name length so don't need to
        // check that here.
        //

        (bUnicode &&
            ((wcschr((LPWSTR)pszMDNewName, MD_PATH_DELIMETERW) != NULL) ||
             (wcschr((LPWSTR)pszMDNewName, MD_ALT_PATH_DELIMETERA) != NULL))) ||
        (!bUnicode &&
            ((MD_STRCHR((LPSTR)pszMDNewName, MD_PATH_DELIMETERA) != NULL) ||
             (MD_STRCHR((LPSTR)pszMDNewName, MD_ALT_PATH_DELIMETERA) != NULL)))) {
        hresReturn = E_INVALIDARG;
    }
    else {
        WCHAR strName[METADATA_MAX_NAME_LEN];
        LPSTR pszNewName = (LPSTR)pszMDNewName;
        LPSTR pszTempName = pszNewName;

        hresReturn = ExtractNameFromPath(pszTempName, (LPSTR)strName, bUnicode);

        if (SUCCEEDED(hresReturn)) {
            g_rMasterResource->Lock(TSRES_LOCK_WRITE);
            CMDBaseObject *pboAffected, *pboParent;
            hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
            if (SUCCEEDED(hresReturn)) {
                pboParent = pboAffected->GetParent();
                if ( pboParent == NULL) {
                    //
                    // Can't rename MasterRoot
                    //
                    hresReturn = E_INVALIDARG;

                }
                else {
                    if (pboAffected->GetParent()->GetChildObject(pszNewName, &hresReturn, bUnicode) != NULL) {
                        hresReturn = RETURNCODETOHRESULT(ERROR_ALREADY_EXISTS);
                    }
                    if (SUCCEEDED(hresReturn)) {

                        BUFFER OriginalKeyName;
                        DWORD  dwStringLen = 0;

                        hresReturn= GetObjectPath(pboAffected,
                                                 &OriginalKeyName,
                                                 dwStringLen,
                                                 g_pboMasterRoot,
                                                 bUnicode);

                        if (SUCCEEDED(hresReturn)) {
                            //
                            // First Remove the object, to get it out of the hash table.
                            //

                            pboParent->RemoveChildObjectFromHash( pboAffected );

                            //
                            // Must use pszMDNewName, as this does not include delimeters
                            //

                            if (!pboAffected->SetName((LPSTR)pszMDNewName, bUnicode)) {
                                hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);

                                //
                                // Attempt to reinsert the object
                                // Preserve previous error code by ignoreing this one.
                                //

                                pboParent->AddChildObjectToHash(pboAffected);
                            }
                            else {
                                CMDHandle *phoHandle;

                                //
                                // Reinsert the object with the new name.
                                //

                                hresReturn = pboParent->AddChildObjectToHash( pboAffected );

                                phoHandle = GetHandleObject(hMDHandle);

                                g_dwSystemChangeNumber++;

                                MD_ASSERT(phoHandle != NULL);

                                INCREMENT_SCHEMA_CHANGE_NUMBER(hMDHandle,
                                                               phoHandle,
                                                               (LPSTR)pszMDNewName,
                                                               bUnicode
                                                               );
                                phoHandle->SetChangeData(pboAffected, MD_CHANGE_TYPE_RENAME_OBJECT, 
                                                         0, (LPWSTR)OriginalKeyName.QueryPtr ());
                            }
                        }


                    }

                }
            }
            g_rMasterResource->Unlock();
        }
    }
    return hresReturn;
}


HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData)
{
    return ComMDSetMetaDataD(hMDHandle,
                             pszMDPath,
                             pmdrMDData,
                             FALSE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData)
{
    return ComMDSetMetaDataD(hMDHandle,
                             (PBYTE)pszMDPath,
                             pmdrMDData,
                             TRUE);
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDSetMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [size_is][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [in] */ PMETADATA_RECORD pmdrMDData,
        IN BOOL bUnicode)
/*++

Routine Description:

    Sets a data object.
    If data of that name does not already exist, it creates and
    inserts a data object into the list of data objects of that type.
    If data of that name aready exists, it sets the new data values.

Arguments:

    Handle - A handle returned by MDOpenMetaObject with write permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    Data       - The data to set. See IMD.H.

Return Value:

    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_PATH_NOT_FOUND
              ERROR_ACCESS_DENIED
              ERROR_NOT_ENOUGH_MEMORY
              MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE

Notes:
    METADATA_MASTER_ROOT_HANDLE is not valid for this operation.
    Duplicate data names are not allowed, even for different types.
--*/
{
    HRESULT hresReturn;
    CMDHandle *hHandleObject;
    LPSTR pszPath = (LPSTR)pszMDPath;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if (!ValidateData(pmdrMDData, bUnicode)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_WRITE);
        CMDBaseObject *AffectedObject;

        hHandleObject = GetHandleObject(hMDHandle);

        if(hHandleObject != NULL)
        {
            hresReturn = GetObjectFromPathWithHandle(AffectedObject, 
                                                     hMDHandle, 
                                                     hHandleObject, 
                                                     METADATA_PERMISSION_WRITE, 
                                                     pszPath, 
                                                     bUnicode); 
        }
        else 
        {
            hresReturn = E_HANDLE;
        }

        if (hresReturn == RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND)) {
            pszPath = (LPSTR)pszMDPath;
            MD_ASSERT(pszMDPath != NULL);

            hresReturn = AddObjectToDataBase(hMDHandle, 
                                             hHandleObject,
                                             (LPSTR)pszMDPath, 
                                             bUnicode);
            if (SUCCEEDED(hresReturn)) {
                g_dwSystemChangeNumber++;

                INCREMENT_SCHEMA_CHANGE_NUMBER(hMDHandle,
                                               hHandleObject, 
                                               (LPSTR)pszMDPath,
                                               bUnicode);

                hresReturn = GetObjectFromPath(AffectedObject, hMDHandle, METADATA_PERMISSION_WRITE, pszPath, bUnicode);
                MD_ASSERT(SUCCEEDED(hresReturn));
            }
        }

        if (SUCCEEDED(hresReturn)) {
            hresReturn = AffectedObject->SetDataObject(pmdrMDData, bUnicode);
        }
        if (SUCCEEDED(hresReturn)) {
            g_dwSystemChangeNumber++;

            INCREMENT_SCHEMA_CHANGE_NUMBER(hMDHandle,
                                           hHandleObject, 
                                           (LPSTR)pszMDPath,
                                           bUnicode);

            PREFIX_ASSUME(GetHandleObject(hMDHandle) != NULL, "GetHandleObject(hMDHandle) is guaranteed not to return NULL");
            GetHandleObject(hMDHandle)->SetChangeData(AffectedObject, MD_CHANGE_TYPE_SET_DATA, pmdrMDData->dwMDIdentifier);
        }
        g_rMasterResource->Unlock();
    }
    return hresReturn;
}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataA(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ unsigned char __RPC_FAR *pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    return ComMDGetMetaDataD(hMDHandle,
                             pszMDPath,
                             pmdrMDData,
                             pdwMDRequiredDataLen,
                             FALSE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataW(
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen)
{
    return ComMDGetMetaDataD(hMDHandle,
                             (PBYTE)pszMDPath,
                             pmdrMDData,
                             pdwMDRequiredDataLen,
                             TRUE);

}

HRESULT STDMETHODCALLTYPE
CMDCOM::ComMDGetMetaDataD(
        /* [in] */ METADATA_HANDLE hMDHandle,
        /* [string][in] */ unsigned char __RPC_FAR *pszMDPath,
        /* [out][in] */ PMETADATA_RECORD pmdrMDData,
        /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
        IN BOOL bUnicode)
/*++

Routine Description:

    Gets one metadata value.

Arguments:

    Handle - METADATA_MASTER_ROOT_HANDLE or a handle returned by MDOpenMetaObject with read permission.

    Path       - The path of the meta object with which this data is associated, relative to the
                 path of Handle.

    Data       - The data structure. See IMD.H.

    RequiredDataLen - If ERROR_INSUFFICIENT_BUFFER is returned, this is set to the required buffer size.

Return Value:

    DWORD   - ERROR_SUCCESS
              MD_ERROR_NOT_INITIALIZED
              ERROR_INVALID_PARAMETER
              ERROR_ACCESS_DENIED
              ERROR_PATH_NOT_FOUND
              MD_ERROR_DATA_NOT_FOUND
              ERROR_INSUFFICIENT_BUFFER

Notes:
    METADATA_MASTER_ROOT_HANDLE is a valid handle, but provides no gaurantee that other threads will
    not also change things. If a consistent data state is desired, use a handle returned by
    ComMDOpenMetaObject.
--*/
{
    HRESULT hresReturn;
    CMDBaseData *pbdRetrieve;
    CMDBaseObject *pboAssociated;
    LPSTR pszPath = (LPSTR)pszMDPath;
    BOOL bInheritableOnly = FALSE;
    if (g_dwInitialized == 0) {
        hresReturn = MD_ERROR_NOT_INITIALIZED;
    }
    else if ((pmdrMDData == NULL) ||
        ((pmdrMDData->dwMDDataLen != 0) && (pmdrMDData->pbMDData == NULL)) ||
        ((pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH) &&
            !(pmdrMDData->dwMDAttributes & METADATA_INHERIT)) ||
        (pmdrMDData->dwMDDataType >= INVALID_END_METADATA)) {
        hresReturn = E_INVALIDARG;
    }
    else {
        g_rMasterResource->Lock(TSRES_LOCK_READ);
        CMDBaseObject *pboAffected = NULL;
        hresReturn = GetObjectFromPath(pboAffected, hMDHandle, METADATA_PERMISSION_READ, pszPath, bUnicode);
        if (SUCCEEDED(hresReturn)) {
            //
            // Found the object, get the data.
            //
            pbdRetrieve = pboAffected->GetDataObject(pmdrMDData->dwMDIdentifier,
                                                     pmdrMDData->dwMDAttributes,
                                                     pmdrMDData->dwMDDataType,
                                                     &pboAssociated);
        }
        else if ((hresReturn == (RETURNCODETOHRESULT(ERROR_PATH_NOT_FOUND))) && (pboAffected != NULL) &&
            (pmdrMDData->dwMDAttributes & METADATA_PARTIAL_PATH)) {
            //
            // Object not found, get inheritable data.
            //
            pbdRetrieve = pboAffected->GetInheritableDataObject(pmdrMDData->dwMDIdentifier,
                                                                pmdrMDData->dwMDDataType,
                                                                &pboAssociated);
            hresReturn = ERROR_SUCCESS;
            bInheritableOnly = TRUE;
        }
        if (SUCCEEDED(hresReturn)) {
            if (pbdRetrieve == NULL) {
                hresReturn = MD_ERROR_DATA_NOT_FOUND;
            }
            else {
                PBYTE pbData = (PBYTE)(pbdRetrieve->GetData(bUnicode));
                DWORD dwDataLen = pbdRetrieve->GetDataLen(bUnicode);
                if (pbData == NULL) {
                    hresReturn = RETURNCODETOHRESULT(ERROR_NOT_ENOUGH_MEMORY);
                }
                else {
                    if (((pmdrMDData->dwMDAttributes) & (pbdRetrieve->GetAttributes()) &
        