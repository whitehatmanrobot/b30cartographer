t iDitherCount = 0;
HBRUSH hbrDither = NULL;

int nSysColorChanges = 0;
DWORD rgbFace;			// globals used a lot
DWORD rgbShadow;
DWORD rgbHilight;
DWORD rgbFrame;

int iThumbCount = 0;
HBITMAP hbmThumb = NULL;     // the thumb bitmap

#define CCS_ALIGN (CCS_TOP|CCS_NOMOVEY|CCS_BOTTOM)


static HBITMAP NEAR PASCAL CreateDitherBitmap()
{
    PBITMAPINFO pbmi;
    HBITMAP hbm;
    HDC hdc;
    int i;
    long patGray[8];
    DWORD rgb;

    pbmi = (PBITMAPINFO)LocalAlloc(LPTR, sizeof(BITMAPINFOHEADER) + (sizeof(RGBQUAD) * 16));
    if (!pbmi)
        return NULL;

    pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth = 8;
    pbmi->bmiHeader.biHeight = 8;
    pbmi->bmiHeader.biPlanes = 1;
    pbmi->bmiHeader.biBitCount = 1;
    pbmi->bmiHeader.biCompression = BI_RGB;

    rgb = GetSysColor(COLOR_BTNFACE);
    pbmi->bmiColors[0].rgbBlue  = GetBValue(rgb);
    pbmi->bmiColors[0].rgbGreen = GetGValue(rgb);
    pbmi->bmiColors[0].rgbRed   = GetRValue(rgb);
    pbmi->bmiColors[0].rgbReserved = 0;

    rgb = GetSysColor(COLOR_BTNHIGHLIGHT);
    pbmi->bmiColors[1].rgbBlue  = GetBValue(rgb);
    pbmi->bmiColors[1].rgbGreen = GetGValue(rgb);
    pbmi->bmiColors[1].rgbRed   = GetRValue(rgb);
    pbmi->bmiColors[1].rgbReserved = 0;


    /* initialize the brushes */

    for (i = 0; i < 8; i++)
       if (i & 1)
           patGray[i] = 0xAAAA5555L;   //  0x11114444L; // lighter gray
       else
           patGray[i] = 0x5555AAAAL;   //  0x11114444L; // lighter gray

    hdc = GetDC(NULL);

    hbm = CreateDIBitmap(hdc, &pbmi->bmiHeader, CBM_INIT, patGray, pbmi, DIB_RGB_COLORS);

    ReleaseDC(NULL, hdc);

    LocalFree(pbmi);

    return hbm;
}

/*---------------------------------------------------------------------------
   MySetObjectOwner
   Purpose:  Call SetObjectOwner in GDI, eliminating "<Object> not released"
             error messages when an app terminates.
   Returns:  Yep
  ---------------------------------------------------------------------------*/
static void MySetObjectOwner(HANDLE hObject)
{
#ifndef _WIN32
	VOID (FAR PASCAL *lpSetObjOwner)(HANDLE, HANDLE);
	HMODULE hMod;

	hMod = GetModuleHandle("GDI");
	if (hMod)
	{
		(FARPROC)lpSetObjOwner = GetProcAddress(hMod, MAKEINTRESOURCE(461));
		if (lpSetObjOwner)
		{
			(lpSetObjOwner)(hObject, hInst);
		}
	}
#endif
}

// initialize the hbrDither global brush
// Call this with bIgnoreCount == TRUE if you just want to update the
// current dither brush.

BOOL FAR PASCAL CreateDitherBrush(BOOL bIgnoreCount)
{
	HBITMAP hbmGray;
	HBRUSH hbrSave;

	if (bIgnoreCount && !iDitherCount)
	{
		return TRUE;
	}

	if (iDitherCount>0 && !bIgnoreCount)
	{
		iDitherCount++;
		return TRUE;
	}

	hbmGray = CreateDitherBitmap();
	if (hbmGray)
	{
		hbrSave = hbrDither;
		hbrDither = CreatePatternBrush(hbmGray);
		DeleteObject(hbmGray);
		if (hbrDither)
		{
                        MySetObjectOwner(hbrDither);
			if (hbrSave)
			{
				DeleteObject(hbrSave);
			}
			if (!bIgnoreCount)
			{
				iDitherCount = 1;
			}
			return TRUE;
		}
		else
		{
			hbrDither = hbrSave;
		}
	}

	return FALSE;
}

BOOL FAR PASCAL FreeDitherBrush(void)
{
    iDitherCount--;

    if (iDitherCount > 0)
        return FALSE;

    if (hbrDither)
        DeleteObject(hbrDither);
    hbrDither = NULL;

    return TRUE;
}


// initialize the hbmThumb global bitmap
// Call this with bIgnoreCount == TRUE if you just want to update the
// current bitmap.

void FAR PASCAL CreateThumb(BOOL bIgnoreCount)
{
	HBITMAP hbmSave;

	if (bIgnoreCount && !iThumbCount)
	{
		return;
	}

	if (iThumbCount && !bIgnoreCount)
	{
		++iThumbCount;
		return;
	}

	hbmSave = hbmThumb;

	hbmThumb = CreateMappedBitmap(hInst, IDB_THUMB, CMB_MASKED, NULL, 0);

	if (hbmThumb)
	{
		if (hbmSave)
		{
			DeleteObject(hbmSave);
		}
		if (!bIgnoreCount)
		{
			iThumbCount = 1;
		}
	}
	else
	{
		hbmThumb = hbmSave;
	}
}

void FAR PASCAL DestroyThumb(void)
{
	iThumbCount--;

	if (iThumbCount <= 0)
	{
		if (hbmThumb)
		{
			DeleteObject(hbmThumb);
		}
		hbmThumb = NULL;
		iThumbCount = 0;
	}
}

// Note that the trackbar will pass in NULL for pTBState, because it
// just wants the dither brush to be updated.

void FAR PASCAL CheckSysColors(void)
{
	static COLORREF rgbSaveFace    = 0xffffffffL,
	                rgbSaveShadow  = 0xffffffffL,
	                rgbSaveHilight = 0xffffffffL,
	                rgbSaveFrame   = 0xffffffffL;

	rgbFace    = GetSysColor(COLOR_BTNFACE);
	rgbShadow  = GetSysColor(COLOR_BTNSHADOW);
	rgbHilight = GetSysColor(COLOR_BTNHIGHLIGHT);
	rgbFrame   = GetSysColor(COLOR_WINDOWFRAME);

	if (rgbSaveFace!=rgbFace || rgbSaveShadow!=rgbShadow
		|| rgbSaveHilight!=rgbHilight || rgbSaveFrame!=rgbFrame)
	{
		++nSysColorChanges;
		// Update the brush for pushed-in buttons
		CreateDitherBrush(TRUE);
		CreateThumb(TRUE);

		rgbSaveFace    = rgbFace;
		rgbSaveShadow  = rgbShadow;
		rgbSaveHilight = rgbHilight;
		rgbSaveFrame   = rgbFrame;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd\ctlspriv.h ===
//#define WINVER 0x400
#define _3DSTUFF

#define BUILDDLL

#ifndef STRICT
#define STRICT
#endif

/* disable "non-standard extension" warnings in our code
 */
#ifndef RC_INVOKED
#if 0
#pragma warning(disable:4001)
#endif
#endif

#include <windows.h>

#ifdef WIN32
#include <win32.h>
#else // WIN32
#define GETWINDOWID(hwnd)		GetWindowWord(hwnd, GWW_ID)
#endif

#define NOUPDOWN
#define NOSTATUSBAR
#define NOMENUHELP
#define NOBTNLIST
#define NODRAGLIST
#define NOPROGRESS
#include "commctrl.h"

#ifdef WIN32
#define SETWINDOWPOINTER(hwnd, name, p)	SetWindowLong(hwnd, 0, (LONG)p)
#define GETWINDOWPOINTER(hwnd, name)	((name)GetWindowLong(hwnd, 0))
#else // WIN32
#define SETWINDOWPOINTER(hwnd, name, p)	SetWindowWord(hwnd, 0, (WORD)p)
#define GETWINDOWPOINTER(hwnd, name)	((name)GetWindowWord(hwnd, 0))
#endif
#define ALLOCWINDOWPOINTER(name, size)	((name)LocalAlloc(LPTR, size))
#define FREEWINDOWPOINTER(p)		LocalFree((HLOCAL)p)

BOOL    WINAPI MyGetPrivateProfileStruct(LPCTSTR, LPCTSTR, LPVOID, UINT, LPCTSTR);
BOOL    WINAPI MyWritePrivateProfileStruct(LPCTSTR, LPCTSTR, LPVOID, UINT, LPCTSTR);


extern HINSTANCE hInst;

BOOL FAR PASCAL InitToolbarClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitStatusClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitHeaderClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitButtonListBoxClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitTrackBar(HINSTANCE hInstance);
BOOL FAR PASCAL InitUpDownClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitProgressClass(HINSTANCE hInstance);

void FAR PASCAL NewSize(HWND hWnd, int nClientHeight, LONG style,
      int left, int top, int width, int height);

#define IDS_SPACE	0x0400

/* System MenuHelp
 */
#define MH_SYSMENU	(0x8000 - MINSYSCOMMAND)
#define IDS_SYSMENU	(MH_SYSMENU-16)
#define IDS_HEADER	(MH_SYSMENU-15)
#define IDS_HEADERADJ	(MH_SYSMENU-14)
#define IDS_TOOLBARADJ	(MH_SYSMENU-13)

/* Cursor ID's
 */
#define IDC_SPLIT	100
#define IDC_MOVEBUTTON	102

#define IDC_STOP	103
#define IDC_COPY	104
#define IDC_MOVE	105

/* Icon ID's
 */
#define IDI_INSERT	150

/* AdjustDlgProc stuff
 */
#define ADJUSTDLG	200
#define IDC_BUTTONLIST	201
#define IDC_RESET	202
#define IDC_CURRENT	203
#define IDC_REMOVE	204
#define IDC_HELP	205
#define IDC_MOVEUP	206
#define IDC_MOVEDOWN	207

/* bitmap IDs
 */

#define IDB_THUMB       300

/* These are the internal structures used for a status bar.  The header
 * bar code needs this also
 */
typedef struct tagSTRINGINFO
  {
    DWORD dwString;
    UINT uType;
    int right;
  } STRINGINFO, *PSTRINGINFO;

typedef struct tagSTATUSINFO
  {
    HFONT hStatFont;
    BOOL bDefFont;

    int nFontHeight;
    int nMinHeight;
    int nBorderX, nBorderY, nBorderPart;

    STRINGINFO sSimple;

    int nParts;
    STRINGINFO sInfo[1];
  } STATUSINFO, *PSTATUSINFO;

#define SBT_NOSIMPLE	0x00ff	/* Flags to indicate normal status bar */

/* This is the default status bar face name
 */
extern TCHAR szSansSerif[];

/* Note that window procedures in protect mode only DLL's may be called
 * directly.
 */
void FAR PASCAL PaintStatusWnd(HWND hWnd, PSTATUSINFO pStatusInfo,
      PSTRINGINFO pStringInfo, int nParts, int nBorderX, BOOL bHeader);
LRESULT CALLBACK StatusWndProc(HWND hWnd, UINT uMessage, WPARAM wParam,
      LPARAM lParam);

/* toolbar.c */

typedef struct tagTBBMINFO {		/* info for recreating the bitmaps */
    int nButtons;
    HINSTANCE hInst;
    WORD wID;
    HBITMAP hbm;
} TBBMINFO, NEAR *PTBBMINFO;

typedef struct tagTBSTATE {		/* instance data for toolbar window */
    PTBBUTTON pCaptureButton;
    HWND hdlgCust;
    HWND hwndCommand;
    int nBitmaps;
    PTBBMINFO pBitmaps;
    HBITMAP hbmCache;
    PTSTR *pStrings;
    int nStrings;
    UINT uStructSize;
    int iDxBitmap;
    int iDyBitmap;
    int iButWidth;
    int iButHeight;
    int iYPos;
    int iBarHeight;
    int iNumButtons;
    int nSysColorChanges;
    WORD wButtonType;
    TBBUTTON Buttons[1];
} TBSTATE, NEAR *PTBSTATE;

typedef struct tagOLDTBBUTTON
{
/*REVIEW: index, command, flag words, resource ids should be UINT */
    int iBitmap;	/* index into bitmap of this button's picture */
    int idCommand;	/* WM_COMMAND menu ID that this button sends */
    BYTE fsState;	/* button's state */
    BYTE fsStyle;	/* button's style */
    int idsHelp;	/* string ID for button's status bar help */
} OLDTBBUTTON;
typedef OLDTBBUTTON FAR* LPOLDTBBUTTON;

static HBITMAP FAR PASCAL SelectBM(HDC hDC, PTBSTATE pTBState, int nButton);
static void FAR PASCAL DrawButton(HDC hdc, int x, int y, int dx, int dy,PTBSTATE pTBState, PTBBUTTON ptButton, BOOL bCache);
static int  FAR PASCAL TBHitTest(PTBSTATE pTBState, int xPos, int yPos);
static int  FAR PASCAL PositionFromID(PTBSTATE pTBState, int id);
static void FAR PASCAL BuildButtonTemplates(void);
static void FAR PASCAL TBInputStruct(PTBSTATE pTBState, LPTBBUTTON pButtonInt, LPTBBUTTON pButtonExt);
static void FAR PASCAL TBOutputStruct(PTBSTATE pTBState, LPTBBUTTON pButtonInt, LPTBBUTTON pButtonExt);

/* tbcust.c */
extern BOOL FAR PASCAL SaveRestore(HWND hWnd, PTBSTATE pTBState, BOOL bWrite,
      LPTSTR FAR *lpNames);
extern void FAR PASCAL CustomizeTB(HWND hWnd, PTBSTATE pTBState, int iPos);
extern void FAR PASCAL MoveButton(HWND hwndToolbar, PTBSTATE pTBState,
      int nSource);

/* cutils.c */
void FAR PASCAL NewSize(HWND hWnd, int nHeight, LONG style, int left, int top, int width, int height);
BOOL FAR PASCAL CreateDitherBrush(BOOL bIgnoreCount);	/* creates hbrDither */
BOOL FAR PASCAL FreeDitherBrush(void);
void FAR PASCAL CreateThumb(BOOL bIgnoreCount);
void FAR PASCAL DestroyThumb(void);
void FAR PASCAL CheckSysColors(void);

extern HBRUSH hbrDither;
extern HBITMAP hbmThumb;
extern int nSysColorChanges;
extern DWORD rgbFace;			// globals used a lot
extern DWORD rgbShadow;
extern DWORD rgbHilight;
extern DWORD rgbFrame;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd\muldiv32.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  muldiv32.c
//
//  Description: math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//  History:
//       9/21/93    cjp     [curtisp]
//       9/23/93    stl     [toddla]
//
//==========================================================================;

#include <windows.h>
#include "muldiv32.h"

#if !defined(_WIN32) && !defined(_WIN32)

#pragma warning(disable:4035 4704)

#define ASM66 _asm _emit 0x66 _asm
#define DB    _asm _emit

#define EAX_TO_DXAX \
    DB      0x66    \
    DB      0x0F    \
    DB      0xA4    \
    DB      0xC2    \
    DB      0x10

//--------------------------------------------------------------------------;
//
//  LONG MulDiv32(a,b,c)    = (a * b) / c
//
//--------------------------------------------------------------------------;

LONG FAR PASCAL MulDiv32(LONG a,LONG b,LONG c)
{
    ASM66   mov     ax,word ptr a   //  mov  eax, a
    ASM66   mov     bx,word ptr b   //  mov  ebx, b
    ASM66   mov     cx,word ptr c   //  mov  ecx, c
    ASM66   imul    bx              //  imul ebx
    ASM66   idiv    cx              //  idiv ecx
    EAX_TO_DXAX

} // MulDiv32()

//--------------------------------------------------------------------------;
//
//  DWORD MulDivRN(a,b,c)   = (a * b + c/2) / c
//
//--------------------------------------------------------------------------;

DWORD FAR PASCAL MulDivRN(DWORD a,DWORD b,DWORD c)
{
    ASM66   mov     ax,word ptr a   //  mov  eax, a
    ASM66   mov     bx,word ptr b   //  mov  ebx, b
    ASM66   mov     cx,word ptr c   //  mov  ecx, c
    ASM66   mul     bx              //  mul  ebx
    ASM66   mov     bx,cx           //  mov  ebx,ecx
    ASM66   shr     bx,1            //  sar  ebx,1
    ASM66   add     ax,bx           //  add  eax,ebx
    ASM66   adc     dx,0            //  adc  edx,0
    ASM66   div     cx              //  div  ecx
    EAX_TO_DXAX

} // MulDiv32()

//--------------------------------------------------------------------------;
//
//  DWORD MulDivRU(a,b,c)   = (a * b + c-1) / c
//
//--------------------------------------------------------------------------;

DWORD FAR PASCAL MulDivRU(DWORD a,DWORD b,DWORD c)
{
    ASM66   mov     ax,word ptr a   //  mov  eax, a
    ASM66   mov     bx,word ptr b   //  mov  ebx, b
    ASM66   mov     cx,word ptr c   //  mov  ecx, c
    ASM66   mul     bx              //  mul  ebx
    ASM66   mov     bx,cx           //  mov  ebx,ecx
    ASM66   dec     bx              //  dec  ebx
    ASM66   add     ax,bx           //  add  eax,ebx
    ASM66   adc     dx,0            //  adc  edx,0
    ASM66   div     cx              //  div  ecx
    EAX_TO_DXAX

} // MulDivRU32()

//--------------------------------------------------------------------------;
//
//  DWORD MulDivRD(a,b,c)   = (a * b) / c
//
//--------------------------------------------------------------------------;

DWORD FAR PASCAL MulDivRD(DWORD a,DWORD b,DWORD c)
{
    ASM66   mov     ax,word ptr a   //  mov  eax, a
    ASM66   mov     bx,word ptr b   //  mov  ebx, b
    ASM66   mov     cx,word ptr c   //  mov  ecx, c
    ASM66   mul     bx              //  mul  ebx
    ASM66   div     cx              //  div  ecx
    EAX_TO_DXAX

} // MulDivRD32()

#pragma warning(default:4035 4704)

#else   // _WIN32

#include <largeint.h>

//--------------------------------------------------------------------------;
//
//  LONG MulDiv32(a,b,c)    = (a * b) / c
//
//--------------------------------------------------------------------------;

LONG FAR PASCAL MulDiv32(LONG a,LONG b,LONG c)
{
    LARGE_INTEGER lRemain;

    return LargeIntegerDivide(
        EnlargedIntegerMultiply(a,b),
        ConvertLongToLargeInteger(c),
        &lRemain).LowPart;

} // MulDiv32()

//--------------------------------------------------------------------------;
//
//  DWORD MulDivRD(a,b,c)   = (a * b) / c
//
//--------------------------------------------------------------------------;

DWORD FAR PASCAL MulDivRD(DWORD a,DWORD b,DWORD c)
{
    return ExtendedLargeIntegerDivide(
        EnlargedUnsignedMultiply(a,b), c, &a).LowPart;

} // MulDivRD()

//--------------------------------------------------------------------------;
//
//  DWORD MulDivRU(a,b,c)   = (a * b + c-1) / c
//
//--------------------------------------------------------------------------;

DWORD FAR PASCAL MulDivRU(DWORD a,DWORD b,DWORD c)
{
    return ExtendedLargeIntegerDivide(
        LargeIntegerAdd(
            EnlargedUnsignedMultiply(a,b),
            ConvertUlongToLargeInteger(c-1)),
        c,&a).LowPart;

} // MulDivRU()

#if 0 // we use Win32 GDI MulDiv function, not this.
//--------------------------------------------------------------------------;
//
//  DWORD MulDivRN(a,b,c)   = (a * b + c/2) / c
//
//--------------------------------------------------------------------------;

DWORD FAR PASCAL MulDivRN(DWORD a,DWORD b,DWORD c)
{
    return ExtendedLargeIntegerDivide(
        LargeIntegerAdd(
            EnlargedUnsignedMultiply(a,b),
            ConvertUlongToLargeInteger(c/2)),
        c,&a).LowPart;

} // MulDivRN()

#endif

#endif  // _WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd\mciwnd.c ===
/*----------------------------------------------------------------------------*\
 *
 *  MCIWnd
 *
 *----------------------------------------------------------------------------*/

//  This stuff is not going to work 64-bit
#pragma warning(disable:4312)


#include "mciwndi.h"
#ifdef DAYTONA
// Include if debug string is read from registry
#include <profile.h>
#endif

#ifndef _WIN32
// variable args won't work in a DLL with DS!=SS unless _WINDLL is defined
#define WINDLL
#define _WINDLL
#define __WINDLL
#endif

#include <stdarg.h>
#include <stdlib.h>

#if defined CHICAGO && defined _WIN32
#define CHICAGO32
#endif

#define SQUAWKNUMZ(num) #num
#define SQUAWKNUM(num) SQUAWKNUMZ(num)
#define SQUAWK __FILE__ "(" SQUAWKNUM(__LINE__) ") :squawk: "

#ifdef _WIN32
#define MCIWndOpenA(hwnd, sz, f)     (LONG)MCIWndSM(hwnd, MCIWNDM_OPENA, (WPARAM)(UINT)(f),(LPARAM)(LPVOID)(sz))
#endif

#if !defined NUMELMS
    #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

#ifdef UNICODE
#include <wchar.h>

//
//  Assist with unicode conversions
//

int Iwcstombs(LPSTR lpstr, LPCWSTR lpwstr, int len)
{
    return WideCharToMultiByte(GetACP(), 0, lpwstr, -1, lpstr, len, NULL, NULL);
}

int Imbstowcs(LPWSTR lpwstr, LPCSTR lpstr, int len)
{
    return MultiByteToWideChar(GetACP(),
                               MB_PRECOMPOSED,
                               lpstr,
                               -1,
                               lpwstr,
                               len);
}

#endif

#ifdef CHICAGO
extern BOOL gfIsRTL;
#else
#define gfIsRTL 0
#endif

LRESULT CALLBACK _LOADDS MCIWndProc(HWND hwnd, unsigned msg, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK _LOADDS SubClassedTrackbarWndProc(HWND hwnd, unsigned msg, WPARAM wParam, LPARAM lParam);

STATICFN HBRUSH NEAR PASCAL CreateDitherBrush(void);

STATICFN LRESULT OwnerDraw(PMCIWND p, UINT msg, WPARAM wParam, LPARAM lParam);
STATICFN BOOL NEAR PASCAL mciDialog(HWND hwnd);
STATICFN void NEAR PASCAL MCIWndCopy(PMCIWND p);

BOOL FAR _cdecl _loadds MCIWndRegisterClass(void)
{
    WNDCLASS cls;

    // !!! We need to register a global class with the hinstance of the DLL
    // !!! because it's the DLL that has the code for the window class.
    // !!! Otherwise, the class goes away on us and things start to blow!
    // !!! HACK HACK HACK The hInstance is the current DS which is the high
    // !!! word of the address of all global variables --- sorry NT
#ifndef _WIN32
    HINSTANCE hInstance = (HINSTANCE)HIWORD((LPVOID)&hInst); // random global
#else
    extern HINSTANCE ghInst;	// in video\init.c
    HINSTANCE hInstance = ghInst;
#endif

    // If we're already registered, we're OK
    if (GetClassInfo(hInstance, aszMCIWndClassName, &cls))
	return TRUE;

    // !!! Save the instance that created the class in a global for cutils.c
    // !!! which may need to know this.  I know, it's ugly.
    hInst = hInstance;

    cls.lpszClassName   = aszMCIWndClassName;
    cls.lpfnWndProc     = (WNDPROC)MCIWndProc;
    cls.style           = CS_GLOBALCLASS | CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS | CS_OWNDC;
    cls.hCursor         = LoadCursor(NULL,IDC_ARROW);
    cls.hIcon           = NULL;
    cls.lpszMenuName    = NULL;
    cls.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1);
    cls.hInstance	= hInstance;
    cls.cbClsExtra      = 0;
    cls.cbWndExtra      = sizeof(LPVOID); // big enough for far pointer

    if (RegisterClass(&cls)) {

        InitCommonControls();

        // !!! Other one-time initialization

	return TRUE;
    }

    return FALSE;
}


//
// Create the window
//
//
#ifdef UNICODE
// HACK ALERT:
// (see comments in MCIWndiCreate
// we set a flag to say that the szFile parameter is unicode.  Otherwise if
// the parent window is ansi (which is likely) we will try and interpret the
// string as ascii.  This is not safe if MCIWndCreate is called on multiple
// threads, but I do not want (currently... let me change my mind) to add
// a critical section to prevent multiple thread access.  Unfortunately
// there is no simple way to pass another parameter to MCIWndiCreate as
// the interface goes through the wndproc WM_CREATE message.

BOOL fFileNameIsUnicode = FALSE;
#endif

HWND FAR _cdecl _loadds MCIWndCreate(HWND hwndParent, HINSTANCE hInstance,
                      DWORD dwStyle, LPCTSTR szFile)
{
    HWND hwnd;
    int x,y,dx,dy;
    DWORD dwStyleEx;

#ifdef _WIN32
    #define GetCurrentInstance()    GetModuleHandle(NULL);
#else
    #define GetCurrentInstance()    SELECTOROF(((LPVOID)&hwndParent))
#endif

    if (hInstance == NULL)
        hInstance = GetCurrentInstance();

    if (!MCIWndRegisterClass())
	return NULL;

    if (HIWORD(dwStyle) == 0)
    {
	if (hwndParent)
	    dwStyle |= WS_CHILD | WS_BORDER | WS_VISIBLE;
	else
	    dwStyle |= WS_OVERLAPPEDWINDOW | WS_VISIBLE;
    }

    // !!! Do we really want to do this?
    dwStyle |= WS_CLIPCHILDREN | WS_CLIPSIBLINGS;

    x = y = dy = 0;
    dx = STANDARD_WIDTH;

    // If we're making a top level window, pick some reasonable position
    if (hwndParent == NULL && !(dwStyle & WS_POPUP)) {
        x = CW_USEDEFAULT;
	// Visible overlapped windows treat y as a ShowWindow flag
	if (dwStyle & WS_VISIBLE)
	    y = SW_SHOW;
    }

    // Our preview open dialog rips if we don't provide a non-zero ID for a
    // child window.
    dwStyleEx = gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0;
#ifdef UNICODE
    fFileNameIsUnicode = TRUE;
    // strictly... we should enter a critical section here to lock out
    // all other MCIWndCreate calls.
#endif
    hwnd = CreateWindowEx(dwStyleEx,
                          aszMCIWndClassName, szNULL, dwStyle,
                          x, y, dx, dy,
                          hwndParent,
                          (HMENU)((dwStyle & WS_CHILD) ? 0x42 : 0),
                          hInstance, (LPVOID)szFile);
#ifdef UNICODE
    fFileNameIsUnicode = FALSE;
#endif
    return hwnd;
}

#ifdef UNICODE
// ansi thunk for above function - stub
HWND FAR _cdecl _loadds MCIWndCreateA(HWND hwndParent, HINSTANCE hInstance,
                    DWORD dwStyle, LPCSTR szFile)
{
    WCHAR * lpW;
    int sz;
    HWND    hwnd;

    if (szFile == NULL) {
        return MCIWndCreateW(hwndParent, hInstance, dwStyle, NULL);
    }

    sz = lstrlenA(szFile) + 1;

    lpW = (WCHAR *) LocalAlloc(LPTR, sizeof(WCHAR) * sz);
    if (!lpW) {
        return NULL;
    }

    Imbstowcs(lpW, szFile, sz);

    hwnd = MCIWndCreateW(hwndParent, hInstance, dwStyle, lpW);

    LocalFree ((HLOCAL)lpW);

    return hwnd;
}
#else
#if defined _WIN32
HWND FAR _loadds MCIWndCreateW(HWND hwndParent, HINSTANCE hInstance,
                    DWORD dwStyle, LPCWSTR szFile)
{
    #pragma message (SQUAWK "maybe later add support here")
    return NULL;
}
#endif
#endif // UNICODE

//
// Give a notification of something interesting to the proper authorites.
//
STATICFN LRESULT NotifyOwner(PMCIWND p, unsigned msg, WPARAM wParam, LPARAM lParam
)
{
    if (p->hwndOwner)
        return SendMessage(p->hwndOwner, msg, wParam, lParam);
    else
        return 0;
}


//
// If an error occured, set our error code and maybe bring up a dialog
// Clears the error code if command was successful.
//
STATICFN void MCIWndiHandleError(PMCIWND p, MCIERROR dw)
{
    TCHAR       ach[128];

    // Set/Clear our error code
    p->dwError = dw;

    if (dw) {

	// We want to bring up a dialog on errors, so do so.
	// Don't bring up a dialog while we're moving the thumb around because
	// that'll REALLY confuse the mouse capture
	if (!(p->dwStyle & MCIWNDF_NOERRORDLG) && !p->fScrolling &&
							!p->fTracking) {
            mciGetErrorString(p->dwError, ach, NUMELMS(ach));
	    MessageBox(p->hwnd, ach, LoadSz(IDS_MCIERROR),
		       MB_ICONEXCLAMATION | MB_OK);
	}

	// The "owner" wants to know the error.  We tell him after we
	// bring up the dialog, because otherwise, our VBX never gets this
	// event.  (Weird...)
	if (p->dwStyle & MCIWNDF_NOTIFYERROR) {
	    NotifyOwner(p, MCIWNDM_NOTIFYERROR, (WPARAM)p->hwnd, p->dwError);
	}

    }
}

//
// Send an MCI GetDevCaps command and return whether or not it's supported
// This will not set our error code
//
STATICFN BOOL MCIWndDevCaps(PMCIWND p, DWORD item)
{
    MCI_GETDEVCAPS_PARMS   mciDevCaps;
    DWORD               dw;

    if (p->wDeviceID == 0)
        return FALSE;

    mciDevCaps.dwItem = (DWORD)item;

    dw = mciSendCommand(p->wDeviceID, MCI_GETDEVCAPS, MCI_GETDEVCAPS_ITEM,
			(DWORD_PTR)(LPVOID)&mciDevCaps);

    if (dw == 0)
	return (BOOL)mciDevCaps.dwReturn;
    else
	return FALSE;
}

//
// Send an MCI Status command.
// This will not set our error code
//
STATICFN DWORD MCIWndStatus(PMCIWND p, DWORD item, DWORD err)
{
    MCI_STATUS_PARMS    mciStatus;
    DWORD               dw;

    if (p->wDeviceID == 0)
	return err;

    mciStatus.dwItem = (DWORD)item;

    dw = mciSendCommand(p->wDeviceID, MCI_STATUS, MCI_STATUS_ITEM,
			(DWORD_PTR)(LPVOID)&mciStatus);

    if (dw == 0)
	return (DWORD) mciStatus.dwReturn;
    else
	return err;
}

//
// Send an MCI String command
// Optionally set our error code.  Never clears it.
//
STATICFN DWORD MCIWndString(PMCIWND p, BOOL fSetErr, LPTSTR sz, ...)
{
    TCHAR   ach[MAX_PATH];
    int     i;
    DWORD   dw;
    va_list va;

    if (p->wDeviceID == 0)
	return 0;

    for (i=0; *sz && *sz != TEXT(' '); )
	ach[i++] = *sz++;

    i += wsprintf(&ach[i], TEXT(" %d "), (UINT)p->alias);

    va_start(va,sz);
    i += wvsprintf(&ach[i], sz, va);
    va_end(va);

    dw = mciSendString(ach, NULL, 0, NULL);

    DPF("MCIWndString('%ls'): %ld",(LPTSTR)ach, dw);

    if (fSetErr)
	MCIWndiHandleError(p, dw);

    return dw;
}


STATICFN long mciwnd_atol(LPTSTR sz)
{
    long l;

    //!!! check for (-) sign?
    for (l=0; *sz >= TEXT('0') && *sz <= TEXT('9'); sz++)
        l = l*10 + (*sz - TEXT('0'));

    return l;
}

#define SLASH(c)     ((c) == TEXT('/') || (c) == TEXT('\\'))

/*--------------------------------------------------------------+
| FileName  - return a pointer to the filename part of szPath   |
|             with no preceding path.                           |
+--------------------------------------------------------------*/
LPTSTR FAR FileName(LPTSTR szPath)
{
    LPCTSTR   sz;

    sz = &szPath[lstrlen(szPath)];
    for (; sz>szPath && !SLASH(*sz) && *sz!=TEXT(':');)
        sz = CharPrev(szPath, sz);
    return (sz>szPath ? (LPTSTR)++sz : (LPTSTR)sz);
}

//
// Sends an MCI String command and converts the return string to an integer
// Optionally sets our error code.  Never clears it.
//
STATICFN DWORD MCIWndGetValue(PMCIWND p, BOOL fSetErr, LPTSTR sz, DWORD err, ...)
{
    TCHAR   achRet[20];
    TCHAR   ach[MAX_PATH];
    DWORD   dw;
    int     i;
    va_list va;

    for (i=0; *sz && *sz != TEXT(' '); )
	ach[i++] = *sz++;

    if (p->wDeviceID)
        i += wsprintf(&ach[i], TEXT(" %d "), (UINT)p->alias);
    va_start(va, err);
    i += wvsprintf(&ach[i], sz, va);  //!!!use varargs
    va_end(va);

    dw = mciSendString(ach, achRet, NUMELMS(achRet), NULL);

    DPF("MCIWndGetValue('%ls'): %ld",(LPTSTR)ach, dw);

    if (fSetErr)
        MCIWndiHandleError(p, dw);

    if (dw == 0) {
        DPF("GetValue('%ls'): %ld",(LPTSTR)ach, mciwnd_atol(achRet));
        return mciwnd_atol(achRet);
    } else {
        DPF("MCIGetValue('%ls'): error=%ld",(LPTSTR)ach, dw);
	return err;
    }
}

//
// Send an MCI command and get the return string back
// This never sets our error code.
//
// Note: szRet can be the same string as sz
//
STATICFN DWORD MCIWndGet(PMCIWND p, LPTSTR sz, LPTSTR szRet, int len, ...)
{
    TCHAR   ach[MAX_PATH];
    int     i;
    DWORD   dw;
    va_list va;

    if (!p->wDeviceID) {
	szRet[0] = 0;
	return 0L;
    }

    for (i=0; *sz && *sz != TEXT(' '); )
	ach[i++] = *sz++;

    i += wsprintf(&ach[i], TEXT(" %d "), (UINT)p->alias);
    va_start(va, len);
    i += wvsprintf(&ach[i], sz, va);  //!!!use varargs
    va_end(va);

    // initialize to NULL return string
    szRet[0] = 0;

    dw = mciSendString(ach, szRet, len, p->hwnd);

    DPF("MCIWndGet('%ls'): '%ls'",(LPTSTR)ach, (LPTSTR)szRet);

    return dw;
}

//
// Gets the source or destination rect from the MCI device
// Does NOT set our error code since this is an internal function
//
STATICFN void MCIWndRect(PMCIWND p, LPRECT prc, BOOL fSource)
{
    MCI_DGV_RECT_PARMS      mciRect;
    DWORD dw=0;

    SetRectEmpty(prc);

    if (p->wDeviceID)
        dw = mciSendCommand(p->wDeviceID, MCI_WHERE,
            (DWORD)fSource ? MCI_DGV_WHERE_SOURCE : MCI_DGV_WHERE_DESTINATION,
            (DWORD_PTR)(LPVOID)&mciRect);

    if (dw == 0)
        *prc = mciRect.rc;

    prc->right  += prc->left;
    prc->bottom += prc->top;
}


STATICFN VOID MCIWndiSizePlaybar(PMCIWND p)
{
    RECT rc;
    UINT w, h;

    // No playbar!!
    if (p->dwStyle & MCIWNDF_NOPLAYBAR)
	return;

    #define SLOP 0     // Left outdent of toolbar

    // How big a window are we putting a toolbar on?
    GetClientRect(p->hwnd, &rc);
    w = rc.right;
    h = rc.bottom;

    SetWindowPos(p->hwndToolbar, NULL,
		-SLOP, h - TB_HEIGHT, w + SLOP, TB_HEIGHT,
		SWP_NOZORDER);

    // Make sure it's visible now
    ShowWindow(p->hwndToolbar, SW_SHOW);

    // Figure out where the toolbar ends and the trackbar begins
    SendMessage(p->hwndToolbar, TB_GETITEMRECT,
	(int)SendMessage(p->hwndToolbar, TB_COMMANDTOINDEX,
		TOOLBAR_END, 0),
	(LPARAM)(LPVOID)&rc);

    // Place the trackbar next to the end of the toolbar
    SetWindowPos(p->hwndTrackbar, HWND_TOP, rc.right,
		h - TB_HEIGHT + 2,
		w - rc.right, TB_HEIGHT,	// !!!
		0);

    //!!! Maybe put menu button on right side of trackbar?  So
    //!!! make sep the right size (size of the track bar!)
}

// Resize the window by the given percentage
// 0 means use DESTINATION rect and size it automatically
STATICFN VOID MCIWndiSize(PMCIWND p, int iSize)
{
    RECT rc, rcT;
    int  dx, dy;

    // If we're given a percentage, we take it from the SOURCE size.
    // For default, (zero), we use the destination size
    if (iSize)
        rc = p->rcNormal; /* get the original "normal size" rect */
    else {
	if (p->wDeviceID)
            MCIWndRect(p, &rc, FALSE);/* get the current (destination) size */
	else
	    SetRect(&rc, 0, 0, 0, 0);
	iSize = 100;
    }

    rc.bottom = MulDiv(rc.bottom, iSize, 100);
    rc.right = MulDiv(rc.right, iSize, 100);

    // Now set the movie to play in the new rect
    if (!IsRectEmpty(&rc))
        MCIWndString(p, FALSE, szPutDest,
	    0, 0, rc.right - rc.left, rc.bottom - rc.top);
	
    // If we're not supposed to resize our window to this new rect, at least
    // we'll fix up the toolbar before we leave (the buttons may have changed)
    if (p->dwStyle & MCIWNDF_NOAUTOSIZEWINDOW) {
	MCIWndiSizePlaybar(p);
	return;
    }

    // We're not a windowed device, or we're closed - don't touch our width
    if (IsRectEmpty(&rc)) {
        GetClientRect(p->hwnd, &rcT);
        rc.right = rcT.right;
    }

    // If we will have a playbar, grow the window by its height
    if (!(p->dwStyle & MCIWNDF_NOPLAYBAR))
        rc.bottom += TB_HEIGHT;

    // Now get the size for our window by growing it by its non-client size
    AdjustWindowRect(&rc, GetWindowLong(p->hwnd, GWL_STYLE), FALSE);

    // Now we have the new size for our MCIWND.  If the SetWindowPos didn't
    // actually result in changing its size, it will not generate a WM_SIZE
    // and it won't fix the toolbar or set the dest rect correctly, so we'll
    // have to call a WM_SIZE ourselves.  It's not enough to check the size
    // we are trying to make it, because it may not give us the size we want
    // (WM_GETMINMAXINFO) so we have to compare the original size and the
    // ultimate size.
    // Sometimes if it only changes by one pixel, it STILL won't generate a
    // WM_SIZE.
    GetWindowRect(p->hwnd, &rcT);

    SetWindowPos(p->hwnd, NULL, 0, 0, rc.right - rc.left,
                    rc.bottom - rc.top,
                    SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE);

    GetWindowRect(p->hwnd, &rc);
    dx = ABS((rcT.right - rcT.left) - (rc.right - rc.left));
    dy = ABS((rcT.bottom - rcT.top) - (rc.bottom - rc.top));
    if (dx < 2 && dy < 2) {
	PostMessage(p->hwnd, WM_SIZE, 0, 0);
    }
}


//
// Figure out the position in ms of the beginning of the track we're on
//
STATICFN DWORD MCIWndiPrevTrack(PMCIWND p)
{
    DWORD	dw;
    int		iTrack;

    if (!p->fHasTracks)
	return 0;

    MCIWndString(p, FALSE, szSetFormatTMSF);
    dw = MCIWndStatus(p, MCI_STATUS_POSITION, 0); // return value is 0xFFSSMMTT
    iTrack = LOWORD(dw) & 0xFF;
    // If we're less than 1 second into the track, choose the previous track
    if ((iTrack > p->iFirstTrack) && (!(LOWORD(dw) & 0xFF00)) &&
			((HIWORD(dw) & 0xFF) == 0))
	iTrack--;
    dw = p->pTrackStart[iTrack - p->iFirstTrack];
    MCIWndString(p, FALSE, szSetFormatMS);
    return dw;
}

//
// Figure out the position in ms of the beginning of the next track
//
STATICFN DWORD MCIWndiNextTrack(PMCIWND p)
{
    DWORD	dw;
    int		iTrack;

    if (!p->fHasTracks)
	return 0;

    MCIWndString(p, FALSE, szSetFormatTMSF);
    dw = MCIWndStatus(p, MCI_STATUS_POSITION, 0); // return value is 0xTTMMSSFF
    iTrack = (LOWORD(dw) & 0xFF) + 1;
    if (iTrack >= p->iNumTracks + p->iFirstTrack)
	iTrack--;
    dw = p->pTrackStart[iTrack - p->iFirstTrack];
    MCIWndString(p, FALSE, szSetFormatMS);
    return dw;
}


//
// Figure out where the tracks begin for making tics
//
STATICFN void MCIWndiCalcTracks(PMCIWND p)
{
    int		i;

    if (!p->fHasTracks)
	return;

    p->iNumTracks = (int)MCIWndGetValue(p, FALSE, szStatusNumTracks, 0);
    p->iFirstTrack = MCIWndGetValue(p, FALSE, szStatusPosTrack, 0, 0) == 0
		? 1 : 0;

    if (p->pTrackStart)
	LocalFree((HANDLE)p->pTrackStart);

    if (p->iNumTracks) {
	p->pTrackStart = (LONG *)LocalAlloc(LPTR,
						p->iNumTracks * sizeof(LONG));
	if (p->pTrackStart == NULL) {
	    p->iNumTracks = 0;
	    p->fHasTracks = FALSE;
	}
	for (i = 0; i < p->iNumTracks; i++) {
	    p->pTrackStart[i] =
		MCIWndGetValue(p, FALSE, szStatusPosTrack, 0,
		    p->iFirstTrack + i);
	}
    }
}


//
// Mark tics on the trackbar for the beginning of tracks
//
STATICFN void MCIWndiMarkTics(PMCIWND p)
{
    int		i;

    if (!p->fHasTracks)
	return;

    SendMessage(p->hwndTrackbar, TBM_SETTIC, 0, p->dwMediaStart);
    for (i = 0; i < p->iNumTracks; i++) {
	SendMessage(p->hwndTrackbar, TBM_SETTIC, 0, p->pTrackStart[i]);
    }
    SendMessage(p->hwndTrackbar, TBM_SETTIC,0, p->dwMediaStart + p->dwMediaLen);
}

STATICFN VOID MCIWndiValidateMedia(PMCIWND p)
{
    DWORD dw;

    if (!p->wDeviceID) {
	p->fMediaValid = FALSE;
	return;
    }

    dw = p->dwMediaLen;
    p->fMediaValid = TRUE;
    p->dwMediaStart = MCIWndGetStart(p->hwnd);
    p->dwMediaLen = MCIWndGetLength(p->hwnd);
    // !!! do something special if len=0?

    // We have a playbar, so set the ranges of the trackbar if we've changed
    if (dw != p->dwMediaLen && !(p->dwStyle & MCIWNDF_NOPLAYBAR)) {
	// must set position first or zero length range won't move thumb
        SendMessage(p->hwndTrackbar, TBM_CLEARTICS, TRUE, 0);
        SendMessage(p->hwndTrackbar, TBM_SETPOS, TRUE, p->dwMediaStart);
	SendMessage(p->hwndTrackbar, TBM_SETRANGEMIN, 0, p->dwMediaStart);
	SendMessage(p->hwndTrackbar, TBM_SETRANGEMAX, 0,
		p->dwMediaStart + p->dwMediaLen);

        MCIWndiCalcTracks(p);
        MCIWndiMarkTics(p);
    }
}

//
// Create the filter for the open dialog.  Caution: Don't overflow pchD !!!
//
STATICFN void MCIWndiBuildMeAFilter(LPTSTR pchD)
{
    LPTSTR      pchS;
    TCHAR       ach[128];

    // Our filter will look like:  "MCI Files\0*.avi;*.wav\0All Files\0*.*\0"
    // The actual extensions for the MCI files will come from the list in
    // the "mci extensions" section of win.ini

    lstrcpy(pchD, LoadSz(IDS_MCIFILES));

    // Creates a list like: "avi\0wav\0mid\0"
    GetProfileString(szMCIExtensions, NULL, szNULL, ach, NUMELMS(ach));
	
    for (pchD += lstrlen(pchD)+1, pchS = ach; *pchS;
		pchD += lstrlen(pchS)+3, pchS += lstrlen(pchS)+1) {
        lstrcpy(pchD, TEXT("*."));
	lstrcpy(pchD + 2, pchS);
        lstrcpy(pchD + 2 + lstrlen(pchS), TEXT(";"));
    }
    if (pchS != ach)
	--pchD;		// erase the last ;
    *pchD = TEXT('\0');
    lstrcpy(++pchD, LoadSz(IDS_ALLFILES));
    pchD += lstrlen(pchD) + 1;
    lstrcpy(pchD, TEXT("*.*\0"));
}

//
// Create the playbar windows we'll need later
//
STATICFN void MCIWndiMakeMeAPlaybar(PMCIWND p)
{
    TBBUTTON            tb[8];
    extern HINSTANCE ghInst;	// in video\init.c
    DWORD               dwStyleEx;


    // They don't want a playbar
    if (p->dwStyle & MCIWNDF_NOPLAYBAR)
	return;


#define MENUSEP 2
    tb[0].iBitmap = MENUSEP;
    tb[0].idCommand = -1;
    tb[0].fsState = 0;
    tb[0].fsStyle = TBSTYLE_SEP;
    tb[0].iString = -1;

    tb[1].iBitmap = 0;
    tb[1].idCommand = MCI_PLAY;
    tb[1].fsState = TBSTATE_ENABLED | TBSTATE_HIDDEN;
    tb[1].fsStyle = TBSTYLE_BUTTON;
    tb[1].iString = -1;

    tb[2].iBitmap = 2;
    tb[2].idCommand = MCI_STOP;
    tb[2].fsState = TBSTATE_ENABLED | TBSTATE_HIDDEN;
    tb[2].fsStyle = TBSTYLE_BUTTON;
    tb[2].iString = -1;

    tb[3].iBitmap = 4;
    tb[3].idCommand = MCI_RECORD;
    tb[3].fsState = TBSTATE_ENABLED | TBSTATE_HIDDEN;
    tb[3].fsStyle = TBSTYLE_BUTTON;
    tb[3].iString = -1;

    tb[4].iBitmap = 5;
    tb[4].idCommand = IDM_MCIEJECT;
    tb[4].fsState = TBSTATE_ENABLED | TBSTATE_HIDDEN;
    tb[4].fsStyle = TBSTYLE_BUTTON;
    tb[4].iString = -1;

    tb[5].iBitmap = MENUSEP;
    tb[5].idCommand = -1;
    tb[5].fsState = 0;
    tb[5].fsStyle = TBSTYLE_SEP;
    tb[5].iString = -1;

    tb[6].iBitmap = 3;
    tb[6].idCommand = IDM_MENU;
    tb[6].fsState = TBSTATE_ENABLED;
    tb[6].fsStyle = TBSTYLE_BUTTON;
    tb[6].iString = -1;

    tb[7].iBitmap = 4;
    tb[7].idCommand = TOOLBAR_END;
    tb[7].fsState = 0;
    tb[7].fsStyle = TBSTYLE_SEP;
    tb[7].iString = -1;

//    if (p->hbmToolbar)
//	DeleteObject(p->hbmToolbar);
    // Must use DLL's ghInst to get Bitmap
//    p->hbmToolbar = LoadBitmap(ghInst, MAKEINTRESOURCE(IDBMP_TOOLBAR));

    // Create invisible for now so it doesn't flash
    p->hwndToolbar = CreateToolbarEx(p->hwnd, TBSTYLE_BUTTON | TBSTYLE_TOOLTIPS
        | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
            CCS_NOPARENTALIGN | CCS_NORESIZE,
        ID_TOOLBAR, 8,
//	NULL, (UINT)p->hbmToolbar,
	ghInst, IDBMP_TOOLBAR,
	(LPTBBUTTON)&tb[0], 8,
        13, 13, 13, 13, sizeof(TBBUTTON));	// buttons are 13x13

    dwStyleEx = gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0;
    p->hwndTrackbar = CreateWindowEx(dwStyleEx,
        TRACKBAR_CLASS, NULL,
        WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
        0, 0, 0, 0, p->hwnd, NULL, GetWindowInstance(p->hwnd), NULL);

    // The trackbar eats key presses so we need to sub class it to see when
    // CTRL-1, CTRL-2, etc. are pressed
    fnTrackbarWndProc = (WNDPROC)GetWindowLongPtr(p->hwndTrackbar, GWLP_WNDPROC);
    SetWindowLongPtr(p->hwndTrackbar, GWLP_WNDPROC,
		(LONG_PTR)SubClassedTrackbarWndProc);

    // Force ValidateMedia to actually update
    p->dwMediaStart = p->dwMediaLen = 0;

    // Set the proper range for the scrollbar
    MCIWndiValidateMedia(p);
}


//
// Gray/ungray toolbar buttons as necessary
//
STATICFN void MCIWndiPlaybarGraying(PMCIWND p)
{
    DWORD	dwMode;

    if (!(p->dwStyle & MCIWNDF_NOPLAYBAR)) {
	dwMode = MCIWndGetMode(p->hwnd, NULL, 0);

	if (dwMode == MCI_MODE_PLAY) {
	    // Hide PLAY Show STOP
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		MCI_PLAY, TRUE);
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		MCI_STOP, FALSE);
	    SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		MCI_STOP, TRUE);
	    if (p->fCanRecord)
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    MCI_RECORD, FALSE);	// !!! can't record ???
	    if (p->fCanEject)
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    IDM_MCIEJECT, TRUE);

	// Treat PAUSE mode like STOP mode
	} else if (dwMode == MCI_MODE_PAUSE ||
		   dwMode == MCI_MODE_STOP) {
	    // Hide STOP Show PLAY
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		MCI_STOP, TRUE);
	    if (p->fCanPlay) {
		SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		    MCI_PLAY, FALSE);
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    MCI_PLAY, TRUE);
	    }
	    if (p->fCanRecord)
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    MCI_RECORD, TRUE);
	    if (p->fCanEject)
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    IDM_MCIEJECT, TRUE);

	} else if (dwMode == MCI_MODE_RECORD) {
	    // Hide PLAY Show STOP
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		MCI_PLAY, TRUE);
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		MCI_STOP, FALSE);
	    SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		MCI_STOP, TRUE);
	    SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		MCI_RECORD, FALSE);
	    if (p->fCanEject)
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    IDM_MCIEJECT, TRUE);	// !!! safe ???

	    // recording can change the length
	    p->fMediaValid = FALSE;

	} else if (dwMode == MCI_MODE_SEEK) {
	    // Hide PLAY Show STOP
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		MCI_PLAY, TRUE);
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		MCI_STOP, FALSE);
	    SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		MCI_STOP, TRUE);
	    if (p->fCanRecord)
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    MCI_RECORD, FALSE);
	    if (p->fCanEject)
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    IDM_MCIEJECT, FALSE);
	} else {
	    // OPEN, NOT_READY, etc. etc.
	    // Disable everything
	    if (p->fCanPlay) {
		SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		    MCI_PLAY, FALSE);
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    MCI_PLAY, FALSE);
	    }
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		MCI_STOP, TRUE);
	    if (p->fCanRecord)
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    MCI_RECORD, FALSE);
	    if (p->fCanEject)
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    IDM_MCIEJECT, FALSE);

	    // Clear all tics
	    SendMessage(p->hwndTrackbar, TBM_CLEARTICS,1,0);

	    // Clean out the trackbar
	    // Make a note to re-query start, length later
	    SendMessage(p->hwndTrackbar, TBM_SETPOS,
				TRUE, 0); // set b4 range
	    SendMessage(p->hwndTrackbar, TBM_SETRANGE,
				0, 0);
	    p->fMediaValid = FALSE;
	}
    }
}


//
// Set up the toolbar to have the right buttons
//
STATICFN void MCIWndiFixMyPlaybar(PMCIWND p)
{
    if (p->dwStyle & MCIWNDF_NOPLAYBAR)
	return;

    if (!p->wDeviceID) {
	//
        // gray the toolbar, go to some default buttons, and set zero len track
        //
        if (!(p->dwStyle & MCIWNDF_NOPLAYBAR)) {
            SendMessage(p->hwndToolbar, TB_HIDEBUTTON,   MCI_PLAY,    FALSE);
            SendMessage(p->hwndToolbar, TB_ENABLEBUTTON, MCI_PLAY,    FALSE);
            SendMessage(p->hwndToolbar, TB_HIDEBUTTON,   MCI_STOP,    TRUE );
            SendMessage(p->hwndToolbar, TB_HIDEBUTTON,   MCI_RECORD,  TRUE );
            SendMessage(p->hwndToolbar, TB_HIDEBUTTON,   IDM_MCIEJECT,TRUE );
            SendMessage(p->hwndToolbar, TB_HIDEBUTTON,   IDM_MENU,
		p->dwStyle & MCIWNDF_NOMENU);

            SendMessage(p->hwndTrackbar, TBM_SETPOS, TRUE, 0); // set b4 range
            SendMessage(p->hwndTrackbar, TBM_SETRANGE, 0, 0);
	}
    }

    if (p->wDeviceID) {
	//
	// Use the appropriate buttons
	//
        if (p->fCanPlay)
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON, MCI_PLAY, FALSE);
        else
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON, MCI_PLAY, TRUE);
        if (p->fCanRecord && (p->dwStyle & MCIWNDF_RECORD))
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON, MCI_RECORD, FALSE);
        else
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON, MCI_RECORD, TRUE);
        if (p->fCanEject)
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON, IDM_MCIEJECT, FALSE);
        else
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON, IDM_MCIEJECT, TRUE);

        SendMessage(p->hwndToolbar, TB_HIDEBUTTON, IDM_MENU,
		p->dwStyle & MCIWNDF_NOMENU);

	// COMMCTRL toolbar bug ... re-arranging buttons screws up the state
	// of the existing buttons, so we better re-gray things
	MCIWndiPlaybarGraying(p);
    }
}

//
// Make an appropriate menu
//
STATICFN void MCIWndiMakeMeAMenu(PMCIWND p)
{
    HMENU hmenu, hmenuWindow = NULL, hmenuVolume = NULL, hmenuSpeed = NULL;
    int	  i;
    WORD  j;

    //
    // Create the floating popup menu BY HAND since we have no resource file
    //

    // Destroy the old menu
    if (p->hmenu) {
        DestroyMenu(p->hmenu);
	if (p->hbrDither) {
	    DeleteObject(p->hbrDither);
	    p->hbrDither = NULL;
	}
    }
    p->hmenu = NULL;
    p->hmenuVolume = NULL;
    p->hmenuSpeed = NULL;


    // We don't want a menu!
    if (p->dwStyle & MCIWNDF_NOMENU)
	return;

    //
    // If we don't want an open command, and nothing's open, don't make
    // a menu.
    //
    if (!p->wDeviceID && (p->dwStyle & MCIWNDF_NOOPEN))
	return;

    //
    // Create the WINDOW sub-popup
    // !!! Do we want to have this menu if an AUTOSIZE flag is off?
    //
    if (p->wDeviceID && p->fCanWindow) {
	hmenuWindow = CreatePopupMenu();
	if (hmenuWindow) {
            AppendMenu(hmenuWindow, MF_ENABLED, IDM_MCIZOOM+50,
			LoadSz(IDS_HALFSIZE));
	    AppendMenu(hmenuWindow, MF_ENABLED, IDM_MCIZOOM+100,
			LoadSz(IDS_NORMALSIZE));
	    AppendMenu(hmenuWindow, MF_ENABLED, IDM_MCIZOOM+200,
			LoadSz(IDS_DOUBLESIZE));
	}
    }

    //
    // Create the VOLUME sub-popup
    //
    if (p->wDeviceID && p->fVolume) {
	hmenuVolume = CreatePopupMenu();
        if (hmenuVolume) {

	    // !!! Hack
	    // Put a bad menu item at the top.  When WINDOWS tries to select
	    // it after we bring up the menu, we won't let it.  We want the
	    // thumb to stay on the current value.
            AppendMenu(hmenuVolume, MF_ENABLED | MF_OWNERDRAW,
			IDM_MCIVOLUME + VOLUME_MAX + 1, NULL);

	    // Create all the Real menu items.  Make the menu VOLUME_MAX items
	    // tall even though the number of unique entries may be less
            for (i=IDM_MCIVOLUME + p->wMaxVol; i>=IDM_MCIVOLUME; i-=5)
		for (j=0; j < VOLUME_MAX / p->wMaxVol; j++)
                    AppendMenu(hmenuVolume, MF_ENABLED | MF_OWNERDRAW, i, NULL);

	    // Now put a filler item at the bottom so every REAL item falls
 	    // inside the channel and there's a unique thumb position for each
	    // item.
            AppendMenu(hmenuVolume, MF_ENABLED | MF_OWNERDRAW,
			IDM_MCIVOLUME + VOLUME_MAX + 2, NULL);

	    // Now CHECK the current volume so the thumb can draw there
	    // round to nearest 5 so it matches a menu item identifier
            i = ((int)MCIWndGetValue(p, FALSE, szStatusVolume, 1000) / 50) * 5;
            CheckMenuItem(hmenuVolume, IDM_MCIVOLUME + i, MF_CHECKED);
        }
    }

    //
    // Create the SPEED sub-popup
    //
    if (p->wDeviceID && p->fSpeed) {
	hmenuSpeed = CreatePopupMenu();
	if (hmenuSpeed) {

	    // !!! Hack from Hell
	    // Put a bogus menu item at the top.  When WINDOWS tries to select
	    // it after we bring up the menu, we won't let it.  We want the
	    // thumb to stay on the current value.
            AppendMenu(hmenuSpeed, MF_ENABLED | MF_OWNERDRAW,
			IDM_MCISPEED + SPEED_MAX + 1, NULL);

	    // Create all the Real menu items
            for (i=IDM_MCISPEED + SPEED_MAX; i>=IDM_MCISPEED; i-=5)
                AppendMenu(hmenuSpeed, MF_ENABLED | MF_OWNERDRAW, i, NULL);

	    // Now put a filler item at the bottom so every REAL item falls
 	    // inside the channel and there's a unique thumb position for each
	    // item.
            AppendMenu(hmenuSpeed, MF_ENABLED | MF_OWNERDRAW,
			IDM_MCISPEED + SPEED_MAX + 2, NULL);

	    // Now CHECK the current speed so the thumb can draw there
	    // round to nearest 5 so it matches a menu item identifier
            i = ((int)MCIWndGetValue(p, FALSE, szStatusSpeed, 1000) / 50) * 5;
            CheckMenuItem(hmenuSpeed, IDM_MCISPEED + i, MF_CHECKED);
        }
    }

    hmenu = CreatePopupMenu();

    if (hmenu) {

	if (p->wDeviceID && p->dwStyle & MCIWNDF_NOPLAYBAR) {
	    if (p->fCanPlay) {
	    	AppendMenu(hmenu, MF_ENABLED, MCI_PLAY, LoadSz(IDS_PLAY));
	    	AppendMenu(hmenu, MF_ENABLED, MCI_STOP, LoadSz(IDS_STOP));
	    }
	    if (p->fCanRecord && (p->dwStyle & MCIWNDF_RECORD))
	        AppendMenu(hmenu, MF_ENABLED, MCI_RECORD, LoadSz(IDS_RECORD));
	    if (p->fCanEject)
	    	AppendMenu(hmenu, MF_ENABLED, IDM_MCIEJECT, LoadSz(IDS_EJECT));
	    if (p->fCanPlay ||
			(p->fCanRecord && (p->dwStyle & MCIWNDF_RECORD)) ||
			p->fCanEject)
                AppendMenu(hmenu, MF_SEPARATOR, 0, NULL);
	
	}

	if (hmenuWindow)
            AppendMenu(hmenu, MF_ENABLED|MF_POPUP, (UINT_PTR)hmenuWindow,
		LoadSz(IDS_VIEW));
	if (hmenuVolume)
	    AppendMenu(hmenu, MF_ENABLED|MF_POPUP, (UINT_PTR)hmenuVolume,
		LoadSz(IDS_VOLUME));
	if (hmenuSpeed)
            AppendMenu(hmenu, MF_ENABLED|MF_POPUP, (UINT_PTR)hmenuSpeed,
		LoadSz(IDS_SPEED));

	if (hmenuWindow || hmenuVolume || hmenuSpeed)
            AppendMenu(hmenu, MF_SEPARATOR, 0, NULL);

        if (p->wDeviceID && p->fCanRecord && (p->dwStyle & MCIWNDF_RECORD))
            AppendMenu(hmenu, MF_ENABLED, IDM_MCINEW, LoadSz(IDS_NEW));

	if (!(p->dwStyle & MCIWNDF_NOOPEN))
	    AppendMenu(hmenu, MF_ENABLED, IDM_MCIOPEN,  LoadSz(IDS_OPEN));

        if (p->wDeviceID && p->fCanSave && (p->dwStyle & MCIWNDF_RECORD))
            AppendMenu(hmenu, MF_ENABLED, MCI_SAVE, LoadSz(IDS_SAVE));

	if (p->wDeviceID) {
	    if (!(p->dwStyle & MCIWNDF_NOOPEN)) {
		AppendMenu(hmenu, MF_ENABLED, IDM_MCICLOSE, LoadSz(IDS_CLOSE));
	
                AppendMenu(hmenu, MF_SEPARATOR, 0, NULL);
	    }

	    AppendMenu(hmenu, p->fAllowCopy ? MF_ENABLED : MF_GRAYED,
				IDM_COPY, LoadSz(IDS_COPY));
	
	    if (p->fCanConfig)
                AppendMenu(hmenu, MF_ENABLED, IDM_MCICONFIG,
			LoadSz(IDS_CONFIGURE));

	    // !!! Should we only show this in debug, or if a flag is set?
            AppendMenu(hmenu, MF_ENABLED, IDM_MCICOMMAND, LoadSz(IDS_COMMAND));
	}

	p->hmenu = hmenu;
	p->hmenuVolume = hmenuVolume;
	p->hmenuSpeed = hmenuSpeed;

        p->hbrDither = CreateDitherBrush(); // we'll need this for OwnerDraw
    }
}

//
// Set up everything for an empty window
//
STATICFN LONG MCIWndiClose(PMCIWND p, BOOL fRedraw)
{
    MCI_GENERIC_PARMS   mciGeneric;

    // Oh no!  The MCI device (probably MMP) has hooked our window proc and if
    // we close the device, it will go away, and the hook will DIE!  We need to
    // do everything BUT the closing of the device.  We'll delay that.
    if (GetWindowLongPtr(p->hwnd, GWLP_WNDPROC) != (LONG_PTR)MCIWndProc &&
    		p->wDeviceID && p->fCanWindow) {
        MCIWndString(p, FALSE, szWindowHandle, NULL);	// GO AWAY, DEVICE!
	PostMessage(p->hwnd, MCI_CLOSE, 0, p->wDeviceID);
    } else if (p->wDeviceID)
	// buggy drivers crash if we pass a null parms address
        mciSendCommand(p->wDeviceID, MCI_CLOSE, 0, (DWORD_PTR)(LPVOID)&mciGeneric);

    //
    // if the device had a palette, we need to send palette changes to
    // every window because we just deleted the palette that was realized.
    //
    if (p->fHasPalette) {
	// If we're dying this won't go through unless we SEND
	SendMessage(p->hwnd, MCIWNDM_PALETTEKICK, 0, 0);
    }

    // execute this function even if there's no deviceID since we may want
    // to gray things

    // The next timer will kill itself since wDeviceID is NULL
    p->wDeviceID = 0;
    p->achFileName[0] = 0;	// kill the filename
    p->dwMediaLen = 0;		// so next open will invalidate media

    // We don't want to redraw cuz we're opening a new file right away
    if (!fRedraw)
	return 0;

    // One of the show bits is on... clear the caption
    if (p->dwStyle & MCIWNDF_SHOWALL)
        SetWindowText(p->hwnd, LoadSz(IDS_NODEVICE));

    // Gray all the stuff on the playbar
    MCIWndiFixMyPlaybar(p);

    // Make an appropriate menu for our null device
    MCIWndiMakeMeAMenu(p);

    // Possibly snap ourselves to a small size since there's no device loaded
    // Also reposition the toolbar after it's been fixed up
    MCIWndiSize(p, 0);

    // We need to notify our "owner" that we've closed
    // note that a unicode szNull is also a valid ansi szNull.
    // so we dont have to thunk this for MCIWNDF_NOTIFYANSI
    // !!! This flag can have more than one bit set so the test is different
    if (p->dwStyle & MCIWNDF_NOTIFYMEDIA & ~MCIWNDF_NOTIFYANSI)
        NotifyOwner(p, MCIWNDM_NOTIFYMEDIA, (WPARAM)p->hwnd,
		(LPARAM)(LPVOID)szNULL);

    InvalidateRect(p->hwnd, NULL, TRUE);
    return 0;
}

#ifdef UNICODE
//
// Check to see if our parent is unicode.  We need this test to determine
// if the passed filename is unicode or ascii
//
BOOL TestForUnicode(HWND hwnd)
{
    HWND    hwndSave;

    /*
    ** Find the top level window associated with hwnd
    */
    hwndSave = hwnd;

    while ( hwndSave != (HWND)NULL ) {

        hwnd = hwndSave;
        hwndSave = GetParent( hwndSave );
    }
    return(IsWindowUnicode(hwnd));
}
#endif

//
// This is the WM_CREATE msg of our WndProc
//
STATICFN BOOL MCIWndiCreate(HWND hwnd, LPARAM lParam)
{
    PMCIWND             p;
    DWORD_PTR		dw;
    TCHAR               ach[20];
    HWND                hwndP;

    p = (PMCIWND)LocalAlloc(LPTR, sizeof(MCIWND));

    if (!p)
        return FALSE;

    SetWindowLongPtr(hwnd, 0, (UINT_PTR)p);

    p->hwnd = hwnd;
    p->hwndOwner = GetParent(hwnd);	// we'll send notifications here
    // Otherwise see if there's an owner
    if (p->hwndOwner == NULL)
	p->hwndOwner = GetWindowOwner(hwnd);
    p->alias = (UINT)(UINT_PTR)hwnd;
    p->dwStyle = GetWindowLong(hwnd, GWL_STYLE);

    DragAcceptFiles(p->hwnd, (p->dwStyle & (MCIWNDF_NOMENU | MCIWNDF_NOOPEN)) == 0);

    if (!(p->dwStyle & WS_CAPTION))
          p->dwStyle &= ~MCIWNDF_SHOWALL;

    // !!! Don't remove NOTIFY bits if there's no owner, because someone might
    // set one later.

    dw = (DWORD_PTR)((LPCREATESTRUCT)lParam)->lpCreateParams;

    //
    // see if we are in a MDIClient
    //
    if ((p->dwStyle & WS_CHILD) && (hwndP = GetParent(hwnd))) {
        GetClassName(hwndP, ach, NUMELMS(ach));
        p->fMdiWindow = lstrcmpi(ach, szMDIClient) == 0;

        if (p->fMdiWindow)
            dw = ((LPMDICREATESTRUCT)dw)->lParam;
    }

    MCIWndiMakeMeAPlaybar(p);

//  if (szOpenFilter[0] == 0)
//      MCIWndiBuildMeAFilter(szOpenFilter);

    // Set the default timer frequencies
    p->iActiveTimerRate = ACTIVE_TIMER;
    p->iInactiveTimerRate = INACTIVE_TIMER;

    // initialize the OFN structure we'll use to open files
    p->achFileName[0] = TEXT('\0');
    p->ofn.lStructSize = sizeof(OPENFILENAME);
    p->ofn.hwndOwner = hwnd;
    p->ofn.hInstance = NULL;
//  p->ofn.lpstrFilter = szOpenFilter;
    p->ofn.lpstrCustomFilter = NULL;
    p->ofn.nMaxCustFilter = 0;
    p->ofn.nFilterIndex = 0;
;   p->ofn.lpstrFile = p->achFileName;
;   p->ofn.nMaxFile = NUMELMS(p->achFileName);
    p->ofn.lpstrFileTitle = NULL;
    p->ofn.nMaxFileTitle = 0;
    p->ofn.lpstrInitialDir = NULL;
    p->ofn.lpstrTitle = NULL; // "Open Device";
    p->ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    p->ofn.nFileOffset = 0;
    p->ofn.nFileExtension = 0;
    p->ofn.lpstrDefExt = NULL;
    p->ofn.lCustData = 0;
    p->ofn.lpfnHook = NULL;
    p->ofn.lpTemplateName = NULL;

    p->hicon = LoadIcon(hInst, MAKEINTRESOURCE(MPLAYERICON));

    // Gray stuff; disable things that aren't applicable with no device loaded
    MCIWndClose(hwnd);

#ifndef UNICODE
    if (dw && *(LPSTR)dw)     // treat extra parm as a filename
        MCIWndOpen(hwnd, (LPSTR)dw, 0);

#else //UNICODE
    /*
    ** Check that owner window is also Unicode.
    ** First check that there is a parameter to pass
    */

    if (dw) {

        // We now have to work out whether the extra parameter is
	// a unicode or ascii string pointer.  If we have gone through
	// our internal ascii open routines then the parameter will have
	// been converted to unicode.  If an application has registered the
	// mciwnd class, and then creates a window directly the conversion
	// will not have happened.

	if (fFileNameIsUnicode
	    || TestForUnicode(p->hwndOwner)) {

            if (dw && *(LPWSTR)dw)     // treat extra parm as a filename
                MCIWndOpen(hwnd, (LPWSTR)dw, 0);
        }
        else {

            if (dw && *(LPSTR)dw) {   // treat extra parm as a filename
                MCIWndOpenA(hwnd, (LPSTR)dw, 0);
            }
        }
    }

#endif

    return TRUE;
}

//
// Brings up an OpenDialog or a SaveDialog for the application and returns the
// filename.  Returns TRUE if a file name was chosen, FALSE on error or CANCEL.
//
STATICFN BOOL MCIWndOpenDlg(PMCIWND p, BOOL fSave, LPTSTR szFile, int len)
{
    BOOL f;

    // !!! Maybe this is a device name and our GetOpenFileName will fail.
    // !!! Find someway of bringing up an initial filename anyway?
    szFile[0] = 0;

    p->ofn.lpstrFile = szFile;
    p->ofn.nMaxFile = len;
    if (fSave)
        p->ofn.Flags = OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    else
        p->ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;

    //
    // use achReturn to hold the MCI Filter.
    //
    MCIWndiBuildMeAFilter(p->achReturn);
    p->ofn.lpstrFilter = p->achReturn;

    /* prompt user for file to open or save */
    if (fSave)
        f = GetSaveFileNamePreview(&(p->ofn));
    else
        f = GetOpenFileNamePreview(&(p->ofn));

    return f;
}

// Set our timer, if it's needed
STATICFN void MCIWndiSetTimer(PMCIWND p)
{
    // We need a TIMER to notify the "owner" when things change
    if (!(p->dwStyle & MCIWNDF_NOPLAYBAR) ||
         (p->dwStyle & MCIWNDF_NOTIFYMODE) ||
         (p->dwStyle & MCIWNDF_SHOWMODE) ||
         (p->dwStyle & MCIWNDF_SHOWPOS) ||
	 (p->dwStyle & MCIWNDF_NOTIFYPOS)) {
	p->wTimer = SetTimer(p->hwnd, TIMER1,
		p->fActive? p->iActiveTimerRate : p->iInactiveTimerRate,
		NULL);
    }
}

//
// Set the caption based on what they want to see... Name? Pos? Mode?
//
STATICFN VOID MCIWndiSetCaption(PMCIWND p)
{
    TCHAR        ach[200], achMode[40], achT[40], achPos[40];

    // Don't touch their window text if they don't want us to
    if (!(p->dwStyle & MCIWNDF_SHOWALL))
	return;

    ach[0] = TEXT('\0');

    if (p->wDeviceID == 0)
	return;

    if (p->dwStyle & MCIWNDF_SHOWNAME)
        wsprintf(ach, TEXT("%s"), FileName(p->achFileName));

    if (p->dwStyle & (MCIWNDF_SHOWPOS | MCIWNDF_SHOWMODE))
        lstrcat(ach, TEXT(" ("));

    if (p->dwStyle & MCIWNDF_SHOWPOS) {

	// Get the pretty version of the position as a string
        MCIWndGetPositionString(p->hwnd, achPos, NUMELMS(achPos));

        if (p->dwStyle & MCIWNDF_SHOWMODE)
            wsprintf(achT, TEXT("%s - "), (LPTSTR)achPos);
	else
            wsprintf(achT, TEXT("%s"), (LPTSTR)achPos);
	lstrcat(ach, achT);
    }

    if (p->dwStyle & MCIWNDF_SHOWMODE) {
        MCIWndGet(p, szStatusMode, achMode, NUMELMS(achMode));
	lstrcat(ach, achMode);
    }

    if (p->dwStyle & (MCIWNDF_SHOWPOS | MCIWNDF_SHOWMODE))
        lstrcat(ach, TEXT(")"));

    SetWindowText(p->hwnd, ach);
}

//
// Save a file.  Returns 0 for success
//
STATICFN LRESULT MCIWndiSave(PMCIWND p, WPARAM wFlags, LPTSTR szFile)
{
    TCHAR    ach[128];
    LRESULT    dw;

    //
    // If we don't have a filename to save, then get one from a dialog
    //
    if (szFile == (LPVOID)-1L) {
	lstrcpy(ach, p->achFileName);
        if (!MCIWndOpenDlg(p, TRUE, ach, NUMELMS(ach)))
            return -1;
        szFile = ach;
    }

    //
    // HACK HACK: This is a temporary method of stopping a very long file name
    // from overflowing the internal members of the MCIWND struct, which uses
    // only 128 chars for achFileName as well as in achReturn array.
    // Since this was designed in the days of Windows 3.1, 128 chars for handling
    // filename was more than sufficient.  So we'll fail the call for any filename
    // longer than that.  That will keep it from overflowing the internal buffers.
    //
#define MAX_FILENAME_LENGTH   128
    if (lstrlen(szFile) >= MAX_FILENAME_LENGTH)
    {
        DPF("WARNING: MCIWndiSave() got very long (%d chars) filename.\n", lstrlen(szFile)) ;
        p->dwError = MCIERR_INVALID_FILE ;  // error out
        return p->dwError ;
    }

    // !!! All good little boys should be saving to background... don't wait
    dw = MCIWndString(p, TRUE, szSave, szFile);
    if (dw == 0) {
	// Fix the filename of the current file
	lstrcpy(p->achFileName, szFile);
	// Fix the window caption
	MCIWndiSetCaption(p);
	// It's now OK to copy again. (For MCIWAVE, something freshly
	// recorded isn't persisted to the file and wouldn't have been
	// copied with our copy command, so it was disabled).
	p->fAllowCopy = TRUE;
	MCIWndiMakeMeAMenu(p);
    }
    return dw;
}

//
// Actually open a file and set up the window.  Returns 0 for success
//
STATICFN LRESULT MCIWndiOpen(PMCIWND p, WPARAM wFlags, LPTSTR szFile)
{
    DWORD               dw = 0;
    HCURSOR             hcurPrev;
    TCHAR               ach[128];
    UINT                wDeviceID;
    BOOL 		fNew = (wFlags & MCIWNDOPENF_NEW) != 0;

    //
    // We're opening an existing file, szFile is that filename
    // If we don't have a filename to open, then get one from a dialog
    //
    if (!fNew && szFile == (LPVOID)-1L) {
	lstrcpy(ach, p->achFileName);
        if (!MCIWndOpenDlg(p, FALSE, ach, NUMELMS(ach)))
            return -1;
        szFile = ach;
    }

    //
    // We want to open a new file, szFile is the device to open
    // If it's NULL, we use the current device
    //
    if (fNew && (szFile == NULL || *szFile == 0)) {
	// There is no device, so we can't do anything
	if (!p->wDeviceID)
	    return 42;	// !!! failure
        MCIWndGetDevice(p->hwnd, ach, NUMELMS(ach));
	szFile = ach;
    }

    // save the current device ID so we can put it back in case open fails.
    wDeviceID = p->wDeviceID;
    KillTimer(p->hwnd, TIMER1);	// setting the deviceID to 0 will mess up timer
    p->wDeviceID = 0;		// and if open fails, we don't want that
    p->alias++;			// use a new alias

    //
    // HACK HACK: Same too long file name problem (as in MCIWndiSave) is plugged
    // by erroring out on a file name longer than 128 chars.
    //
// #define MAX_FILENAME_LENGTH   128
    if (lstrlen(szFile) >= MAX_FILENAME_LENGTH)
    {
        DPF("WARNING: MCIWndiOpen() got very long (%d chars) filename.\n", lstrlen(szFile)) ;
        p->dwError = MCIERR_INVALID_FILE ;  // error out
        return p->dwError ;
    }

    /*
     * Show the hourglass cursor -- who knows how long this stuff
     * will take
     */
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Open a NEW file
    if (fNew) {
	dw = MCIWndGetValue(p, TRUE, szNew, 0,
		szFile, (UINT)p->alias);

    // open an existing file
    } else {

 	// first, try to open it shareable
        // don't show or update errors since we try to open it twice
        //
        // dont try shareable for "file" devices
        // hack to check for extension.
        //
#ifdef LATER
   !!! HACK ALERT !!!
	For NT (and probably Chicago) this test is VERY error prone.  If
	we have a long file name then we are in big trouble....
#endif
#if 0 //  IF the file exists, then do not open shareable.
    // This section, or something like it, should replace the gross hack
    // below.  Checking for a '.' as the fourth last character... yuk!
	{
	DWORD attr = GetFileAttributes(szFile);
	if (attr != (DWORD)(~0))
	    // The error value is -1, i.e. bitwise inverse of 0
            dw = 0;   // Force non shareable
        else
            dw = MCIWndGetValue(p, FALSE, szOpenShareable, 0,
                (LPTSTR)szFile, (UINT)p->alias);
	}
#else
	{
	    UINT n = lstrlen(szFile);
            if (n > 4 && szFile[n-4] == TEXT('.'))
                dw = 0;
            else
                dw = MCIWndGetValue(p, FALSE, szOpenShareable, 0,
                    (LPTSTR)szFile, (UINT)p->alias);
	}
#endif

        // Error! Try again, not shareable.
        if (dw == 0) {
            dw = MCIWndGetValue(p, FALSE, szOpen, 0,
                (LPTSTR)szFile, (UINT)p->alias);
	    // Last ditch attempt! Try AVI. It'll open anything.  This time,
	    // show, set errors.
	    if (dw == 0) {
                dw = MCIWndGetValue(p, TRUE, szOpenAVI, 0,
                    (LPTSTR)szFile, (UINT)p->alias);
	    }
	}
    }

    if (hcurPrev)
	SetCursor(hcurPrev);

    //
    // Ack! No deviceID... we failed to open
    //
    if (dw == 0)
    {
        p->wDeviceID = wDeviceID;
        MCIWndiSetTimer(p);	// Put the timer back now that DeviceID is back
//	p->achFileName[0] = 0;	// don't hurt the old filename!
	p->alias--;		// back to old alias
	// in case error box or open box wiped us out and we didn't paint
	// because our p->wDeviceID was null because of our open hack
	InvalidateRect(p->hwnd, NULL, TRUE);
        return p->dwError;
    }

    //
    // it worked, now close the old device and open the new.
    //
    if (wDeviceID)
    {
	p->wDeviceID = wDeviceID;
	p->alias--;	// back to old alias so the close might actually work
	MCIWndiClose(p, FALSE);	// don't redraw
	p->alias++;	// new alias again (ACK!)
    }

    p->wDeviceID = (UINT)dw;
    p->dwMode = (DWORD)~0L;	// first mode set will be detected as a change
    p->dwPos = (DWORD)~0L;	// first pos set will be detected as a change

    // Copy the file or device name into our filename spot.  Set the window
    // caption (if desired).
    lstrcpy(p->achFileName, szFile);
    MCIWndiSetCaption(p);	// wDeviceID must be set before calling this

    // !!! p->wDeviceType = QueryDeviceTypeMCI(p->wDeviceID);

    p->fAllowCopy = TRUE;	// until recorded into

    // Now set the playback window to be our MCI window
    p->fCanWindow = MCIWndString(p, FALSE, szWindowHandle, (UINT_PTR)p->hwnd) == 0;

    if (p->fCanWindow)
        MCIWndGetDest(p->hwnd, &p->rcNormal);
    else
	SetRect(&p->rcNormal, 0, 0, 0, 0);

    // Find out if the device supports palettes.
    p->fHasPalette = MCIWndString(p, FALSE, szStatusPalette) == 0;

    //
    // Now find out the capabilities of this device
    //

// !!! What about these ???
// MCI_GETDEVCAPS_DEVICE_TYPE      0x00000004L
// MCI_GETDEVCAPS_COMPOUND_DEVICE  0x00000006L

    // Find out if the device can record
    p->fCanRecord = MCIWndDevCaps(p, MCI_GETDEVCAPS_CAN_RECORD);

    // Find out if the device can play
    p->fCanPlay = MCIWndDevCaps(p, MCI_GETDEVCAPS_CAN_PLAY);

    // Find out if the device can save
    p->fCanSave = MCIWndDevCaps(p, MCI_GETDEVCAPS_CAN_SAVE);

    // Find out if the device can eject
    p->fCanEject = MCIWndDevCaps(p, MCI_GETDEVCAPS_CAN_EJECT);

    // Find out if the device is file based
    p->fUsesFiles = MCIWndDevCaps(p, MCI_GETDEVCAPS_USES_FILES);

    // Find out if the device has video
    p->fVideo = MCIWndDevCaps(p, MCI_GETDEVCAPS_HAS_VIDEO);

    // Find out if the device has video
    p->fAudio = MCIWndDevCaps(p, MCI_GETDEVCAPS_HAS_AUDIO);

    // Find out if the device can configure
    p->fCanConfig = (MCIWndString(p, FALSE, szConfigureTest) == 0);

    //
    //
    //

    // Now see if we support speed - try normal, half, and max
    p->fSpeed = MCIWndString(p, FALSE, szSetSpeed1000Test) == 0 &&
                MCIWndString(p, FALSE, szSetSpeed500Test) == 0 &&
                MCIWndString(p, FALSE, szSetSpeedTest, SPEED_MAX * 10) == 0;

    // Now see if we support volume - try normal, mute, and max
    p->fVolume = MCIWndString(p, FALSE, szSetVolumeTest, VOLUME_MAX * 5) ==0 &&
                 MCIWndString(p, FALSE, szSetVolume0Test) == 0;
    p->wMaxVol = 100;
    // If someone happens to support double volume, let's give it to them.
    if (MCIWndString(p, FALSE, szSetVolumeTest, VOLUME_MAX * 10) == 0)
	p->wMaxVol = 200;

    // See if the device would support tmsf mode.  If so, use milliseconds mode
    // and later on we'll fake knowing where tracks begin and end
    p->fHasTracks = (MCIWndString(p, FALSE, szSetFormatTMSF) == 0);
    if (p->fHasTracks) {
        dw = MCIWndString(p, FALSE, szSetFormatMS);
 	if (dw != 0)
	    p->fHasTracks = FALSE;
    }

    if (!p->fHasTracks) {
        // Force us into a reasonable time format
        dw = MCIWndString(p, FALSE, szSetFormatFrames);
        if (dw != 0)
	    dw = MCIWndString(p, FALSE, szSetFormatMS);
        if (dw != 0)
	    ;		// !!! What to do? Don't turn playbar off without
    }	 		// !!! destroying it...

    // Set the media length and trackbar range
    MCIWndiValidateMedia(p);

    // Fix the toolbar buttons for the new device
    MCIWndiFixMyPlaybar(p);

    // Make an appropriate menu for this device
    MCIWndiMakeMeAMenu(p);

    // We need a TIMER to notify the "owner" when things change
    MCIWndiSetTimer(p);

    // Set the size of the movie (and maybe the window) and re-draw new toolbar
    MCIWndiSize(p, p->iZoom);

#if 0 // We need the focus on our main window to get key accelerators
    // Bring focus to the thumb so caret will flash
    // I know the WM_SETFOCUS msg does this, but it seems to need to happen here
    // too.
    if (p->hwndTrackbar && GetFocus() == p->hwnd)
	SetFocus(p->hwndTrackbar);
#endif

    // We need to notify our "owner" that we've opened a new file
    // !!! This flag can have more than one bit set so the test is different
    if (p->dwStyle & MCIWNDF_NOTIFYMEDIA & ~MCIWNDF_NOTIFYANSI) {
#ifdef UNICODE
        if (p->dwStyle & MCIWNDF_NOTIFYANSI) {

            char * lpA;
            int sz;
            sz = lstrlen(szFile) + 1;
            lpA = (char *)LocalAlloc(LPTR, sz * sizeof(char));
            if (lpA) {
	       Iwcstombs(lpA, szFile, sz);
               NotifyOwner(p, MCIWNDM_NOTIFYMEDIA, (WPARAM)p->hwnd,(LPARAM)lpA);
               LocalFree ((HLOCAL)lpA);
            }
        }
        else
#endif
        {
            NotifyOwner(p, MCIWNDM_NOTIFYMEDIA, (WPARAM)p->hwnd,
			(LPARAM)szFile);
        }
    }

    // Make sure the newly opened movie paints in the window now
    InvalidateRect(p->hwnd, NULL, TRUE);

    return 0;	// success
}

STATICFN LONG MCIWndiChangeStyles(PMCIWND p, UINT mask, UINT value)
{
    DWORD	dwOldStyle = p->dwStyle;
    DWORD	dwMaskOff, dwValue, dwChanged;

    //
    // Using the mask, change the appropriate bits in the style
    //
    dwMaskOff = dwOldStyle & (~(DWORD)mask);
    dwValue   = (DWORD)mask & (DWORD)value;
    p->dwStyle = dwMaskOff | dwValue;

    //
    // Which bits changed?
    //
    dwChanged = (dwOldStyle & (DWORD)mask) ^ (dwValue & (DWORD)mask);

    //
    // We changed whether or not we want a menu button or a record button
    // on the playbar
    //
    if (dwChanged & (MCIWNDF_NOMENU | MCIWNDF_NOOPEN | MCIWNDF_RECORD)) {
	MCIWndiMakeMeAMenu(p);	// add/remove record from the menu
	// We have a playbar, so fix it
	if (!(p->dwStyle & MCIWNDF_NOPLAYBAR)) {
	    MCIWndiFixMyPlaybar(p);
	    MCIWndiSize(p, 0);
	}
    }

    //
    // We changed the show/don't show playbar flag!
    //
    if (dwChanged & MCIWNDF_NOPLAYBAR) {

 	// Remove the playbar
	if (p->dwStyle & MCIWNDF_NOPLAYBAR) {
	    DestroyWindow(p->hwndToolbar);
	    DestroyWindow(p->hwndTrackbar);
	    p->hwndToolbar = NULL;
	    p->hwndTrackbar = NULL;	
	    MCIWndiMakeMeAMenu(p);	// since toolbar's gone, menus change

	    if (!(p->dwStyle & MCIWNDF_NOAUTOSIZEWINDOW)) {
	        // Now resize the window smaller to account for the missing
		// playbar.  Don't touch the movie size.
		MCIWndiSize(p, 0);

	    // If the window isn't being resized, we may still need to grow
	    // the movie size a bit to take up the extra space where the toolbar
	    // vanished. (happens automatically in the previous case)
	    } else if (!(p->dwStyle & MCIWNDF_NOAUTOSIZEMOVIE)) {
		PostMessage(p->hwnd, WM_SIZE, 0, 0L);
	    }	

	// Add a playbar
	} else {
	    MCIWndiMakeMeAPlaybar(p);
	    MCIWndiFixMyPlaybar(p);
	    MCIWndiMakeMeAMenu(p);	// since toolbar's used, menus change

	    if (!(p->dwStyle & MCIWNDF_NOAUTOSIZEWINDOW)) {
	        // Now resize the window a little bigger to account for the new
		// playbar.  Don't touch the movie size.
		MCIWndiSize(p, 0);

	    // If the window isn't being resized, we may still need to shrink
	    // the movie size because the toolbar covers up some extra space.
	    // (happens automatically in the previous case)
	    } else if (!(p->dwStyle & MCIWNDF_NOAUTOSIZEMOVIE)) {
		PostMessage(p->hwnd, WM_SIZE, 0, 0L);

	    // Irregardless, we need to fix the toolbar
	    } else
		// Put the toolbar in a reasonable spot
		MCIWndiSizePlaybar(p);
	}
    }

    //
    // We changed a SHOW flag and need to reset the caption
    //
    if (dwChanged & MCIWNDF_SHOWALL)
	MCIWndiSetCaption(p);

    //
    // We turned the AUTOSIZEMOVIE flag on and need to resize the device.
    // This happens before AUTOSIZEWINDOW so if both flags are turned on
    // the movie will snap to the window not vice versa.
    // !!! Should we even snap it right now?
    //
    if (dwChanged & MCIWNDF_NOAUTOSIZEMOVIE &&
				!(p->dwStyle & MCIWNDF_NOAUTOSIZEMOVIE))
	PostMessage(p->hwnd, WM_SIZE, 0, 0);

    //
    // We turned the AUTOSIZEWINDOW flag on
    // Snap our window to the current movie size.
    //
    if (dwChanged & MCIWNDF_NOAUTOSIZEWINDOW &&
				!(p->dwStyle & MCIWNDF_NOAUTOSIZEWINDOW))
	MCIWndiSize(p, 0);

    DragAcceptFiles(p->hwnd, (p->dwStyle & MCIWNDF_NOMENU | MCIWNDF_NOOPEN) == 0);

    return 0;	// !!! success ?
}


//
// We're about to play.  We might want to seek to the beginning first if we're
// at the end, or seek to the end first if we're at the beginning and playing
// backwards.
//
STATICFN void MCIWndiPlaySeek(PMCIWND p, BOOL fBackwards)
{

    // Playing backwards? If we're at the beginning, seek to the end

    if (fBackwards) {
	if (MCIWndGetPosition(p->hwnd) <= MCIWndGetStart(p->hwnd))
	    MCIWndSeek(p->hwnd, MCIWND_END);
	return;
    }

    // Playing forwards.
    // If we're near the end, rewind before playing
    // Some devices are broken so we can't just test being at the end

    // Frames mode ... last or second to last frame
    if (MCIWndGetTimeFormat(p->hwnd, NULL, 0) == MCI_FORMAT_FRAMES) {
	if (MCIWndGetPosition(p->hwnd) >= MCIWndGetEnd(p->hwnd) - 1)
	    MCIWndSeek(p->hwnd, MCIWND_START);

    // Millisecond mode ... within last 1/4 second
    } else if (MCIWndGetTimeFormat(p->hwnd, NULL, 0) ==
					MCI_FORMAT_MILLISECONDS) {
	if (MCIWndGetEnd(p->hwnd) - MCIWndGetPosition(p->hwnd) < 250)
	    MCIWndSeek(p->hwnd, MCIWND_START);

    // something else ... no hack
    } else {
	if (MCIWndGetPosition(p->hwnd) == MCIWndGetEnd(p->hwnd))
	    MCIWndSeek(p->hwnd, MCIWND_START);
    }
}


//
// Handle our WM_TIMER
//
STATICFN void MCIWndiTimerStuff(PMCIWND p)
{
    DWORD	dwMode;
    DWORD	dwPos;

    //
    // Someone's interested in knowing the mode of the device
    //
    if ((p->dwStyle & MCIWNDF_NOTIFYMODE) ||
		!(p->dwStyle & MCIWNDF_NOPLAYBAR) ||
		(p->dwStyle & MCIWNDF_SHOWMODE)) {

	dwMode = MCIWndGetMode(p->hwnd, NULL, 0);

	//
	// If we haven't set the trackbar range or media length yet
	// because we weren't ready, maybe we can do it now!
	// Also, don't update media until you're done recording.
	//
	if (dwMode != MCI_MODE_NOT_READY && dwMode != MCI_MODE_OPEN &&
		dwMode != MCI_MODE_RECORD && p->fMediaValid == FALSE)
	    MCIWndiValidateMedia(p);

	//
	// No device loaded?  Time to kill our timer
	//
        if (p->wDeviceID == 0)
	    KillTimer(p->hwnd, TIMER1);

	//
	// The mode has changed!
	//
	if (dwMode != p->dwMode) {

	    p->dwMode = dwMode;

	    //
	    // Notify the "owner" of the mode change
	    //
	    if ((p->dwStyle & MCIWNDF_NOTIFYMODE))
		NotifyOwner(p, MCIWNDM_NOTIFYMODE, (WPARAM)p->hwnd, dwMode);

	    //
	    // Set the Window Caption to include the new mode
	    //
	    if ((p->dwStyle & MCIWNDF_SHOWMODE))
		MCIWndiSetCaption(p);

	    //
	    // Fix up the toolbar bitmaps if the mode has changed
	    //
	    MCIWndiPlaybarGraying(p);
	}
    }

    //
    // Someone's interested in knowing the new position
    //
    if (!(p->dwStyle & MCIWNDF_NOPLAYBAR) ||
	 (p->dwStyle & MCIWNDF_NOTIFYPOS) ||
	 (p->dwStyle & MCIWNDF_SHOWPOS)) {

	dwPos = MCIWndGetPosition(p->hwnd);

	//
	// The position has changed!
	//
	if (dwPos != p->dwPos) {

	    //
	    // Make sure start and length haven't changed too (format change) ?
	    //
	    MCIWndiValidateMedia(p);

	    p->dwPos = dwPos;

	    //
	    // Notify the "owner" of the position change
	    //
	    if ((p->dwStyle & MCIWNDF_NOTIFYPOS))
		NotifyOwner(p, MCIWNDM_NOTIFYPOS, (WPARAM)p->hwnd, dwPos);

	    //
	    // Set the Window Caption to include the new position
	    //
	    if ((p->dwStyle & MCIWNDF_SHOWPOS))
		MCIWndiSetCaption(p);

	    //
	    // Update the trackbar to the new position but not while
	    // we're dragging the thumb
	    //
	    if (!(p->dwStyle & MCIWNDF_NOPLAYBAR) && !p->fScrolling && p->dwMode != MCI_MODE_SEEK)
		SendMessage(p->hwndTrackbar, TBM_SETPOS, TRUE, dwPos);
	}
    }
}


STATICFN void MCIWndiDrop(HWND hwnd, WPARAM wParam)
{
    TCHAR       szPath[MAX_PATH];
    UINT	nDropped;

    // Get number of files dropped
    nDropped = DragQueryFile((HANDLE)wParam, (UINT)-1, NULL, 0);

    if (nDropped) {
	SetActiveWindow(hwnd);

	// Get the file that was dropped....
        DragQueryFile((HANDLE)wParam, 0, szPath, NUMELMS(szPath));

	MCIWndOpen(hwnd, szPath, 0);
    }
    DragFinish((HANDLE)wParam);     /* Delete structure alocated */
}

//--------ansi thunk functions ---------------------------------

#ifdef UNICODE

STATICFN LRESULT MCIWndiOpenA(PMCIWND p, WPARAM wFlags, LPCSTR szFile)
{
    WCHAR * lpW;
    int sz;
    LRESULT l;

    if ((szFile == NULL) || (szFile == (LPSTR)-1)) {
	return MCIWndiOpen(p, wFlags, (LPTSTR)szFile);
    }

    sz = lstrlenA(szFile) + 1;
    lpW = (WCHAR *)LocalAlloc(LPTR, sz * sizeof(WCHAR));
    if (!lpW) {
	return -1;
    }
    Imbstowcs(lpW, szFile, sz);

    l = MCIWndiOpen(p, wFlags, lpW);

    LocalFree((HLOCAL)lpW);
    return l;
}


// ansi version of MCIWndGet
STATICFN DWORD MCIWndGetA(PMCIWND p, LPSTR sz, LPSTR szRet, int len, ...)
{
    char    ach[MAX_PATH];
    int     i;
    DWORD   dw;
    va_list va;

    if (!p->wDeviceID) {
	szRet[0] = 0;
	return 0L;
    }

    for (i=0; *sz && *sz != ' '; )
	ach[i++] = *sz++;

    i += wsprintfA(&ach[i], " %d ", (UINT)p->alias);
    va_start(va, len);
    i += wvsprintfA(&ach[i], sz, va);  //!!!use varargs
    va_end(va);

    // initialize to NULL return string
    szRet[0] = 0;

    dw = mciSendStringA(ach, szRet, len, p->hwnd);

    DPF("MCIWndGetA('%s'): '%s'", (LPSTR)ach, (LPSTR)szRet);

    return dw;
}
#endif

/*--------------------------------------------------------------+
| MCIWndCommand - WM_COMMAND processing for MCIWnd class        |                         |
|                                                               |
+--------------------------------------------------------------*/

static LRESULT MCIWndCommands (
   PMCIWND p,         // IN:
   HWND    hwnd,      // IN:
   WPARAM  wParam,    // IN:
   LPARAM  lParam)    // IN:
{
   WORD wID = GET_WM_COMMAND_ID(wParam, lParam);
   HWND hwndCtl = GET_WM_COMMAND_HWND(wParam, lParam);
   WORD wNotify = GET_WM_COMMAND_CMD(wParam, lParam);

   // Check for ZOOM commands
   if (wID >= IDM_MCIZOOM && wID < IDM_MCIZOOM + 1000)
       MCIWndSetZoom(hwnd, wID - IDM_MCIZOOM);

   // !!! Hack from Hell
   // If our bogus top menu item is selected, turn it into the REAL
   // menu item closest to it.
   //
   if (wID == IDM_MCIVOLUME + VOLUME_MAX + 1)
       wID = IDM_MCIVOLUME + p->wMaxVol;
   if (wID == IDM_MCIVOLUME + VOLUME_MAX + 2)
       wID = IDM_MCIVOLUME;

   // VOLUME command? Uncheck old one, reset volume, and check new one
   // Round to the nearest 5 to match a menu identifier
   if (wID >=IDM_MCIVOLUME && wID <=IDM_MCIVOLUME + p->wMaxVol) {
	// 42 means we're auditioning changes as we drag the menu bar, but
	// we don't actually want to remember this value permanently (see
	// OwnerDraw).
        if (MCIWndSetVolume(hwnd, (wID - IDM_MCIVOLUME) * 10) == 0
                               && lParam != 42) {
           CheckMenuItem(p->hmenuVolume, p->uiHack, MF_UNCHECKED);
           CheckMenuItem(p->hmenuVolume, wID, MF_CHECKED);
       }
   }

   // !!! Hack from Hell
   // If our bogus top menu item is selected, turn it into the REAL
   // menu item closest to it.
   if (wID == IDM_MCISPEED + SPEED_MAX + 1)
       wID = IDM_MCISPEED + SPEED_MAX;
   if (wID == IDM_MCISPEED + SPEED_MAX + 2)
       wID = IDM_MCISPEED;

   // SPEED command? Uncheck old one, reset speed, and check new one
   // Round to the nearest 5 to match a menu identifier
   if (wID >=IDM_MCISPEED && wID <= IDM_MCISPEED + SPEED_MAX) {
	// 42 means we're auditioning changes as we drag the menu bar, but
	// we don't actually want to remember this value permanently (see
	// OwnerDraw).
        if (MCIWndSetSpeed(hwnd, (wID - IDM_MCISPEED) * 10) == 0
                               && lParam != 42) {
           CheckMenuItem(p->hmenuSpeed, p->uiHack, MF_UNCHECKED);
           CheckMenuItem(p->hmenuSpeed, wID, MF_CHECKED);
       }
   }

   switch(wID)
   {
       case MCI_RECORD:
           if (GetKeyState(VK_SHIFT) < 0)
           {
               //!!! toggle?
               //MCIWndRecordPreview(hwnd);
           }
           else
           {
                MCIWndRecord(hwnd);
		// would not copy newly recorded stuff anyway
		p->fAllowCopy = FALSE;
		MCIWndiMakeMeAMenu(p);
	
           }
           break;

       //            PLAY = normal play
       //      SHIFT+PLAY = play backward
       //       CTRL+PLAY = play fullscreen
       // SHIFT+CTRL+PLAY = play fullscreen backward
       //
       case MCI_PLAY:

#define MaybeRepeat (p->fRepeat ? (LPTSTR)szRepeat : (LPTSTR)szNULL)

           // NOTE: We never set errors for the repeat play, because
           // lots of device don't support it and would fail.

           if (GetKeyState(VK_SHIFT) < 0)
               // If we're at the beginning, seek to the end.
               MCIWndiPlaySeek(p, TRUE);
           else
               // If we're at the end, seek to the beginning.
               MCIWndiPlaySeek(p, FALSE);

           if (GetKeyState(VK_CONTROL) < 0)
           {
               if (GetKeyState(VK_SHIFT) < 0) {
                   if (MCIWndString(p, FALSE, szPlayFullscreenReverse,
                                                       MaybeRepeat))
                       MCIWndString(p, TRUE, szPlayFullscreenReverse,
                                                       (LPTSTR)szNULL);
               } else {
                   if (MCIWndString(p, FALSE, szPlayFullscreen,
                                                       MaybeRepeat))
                       MCIWndString(p, TRUE, szPlayFullscreen,
                                                       (LPTSTR)szNULL);
               }

           } else if (GetKeyState(VK_SHIFT) < 0) {
               if (MCIWndString(p, FALSE, szPlayReverse, MaybeRepeat))
                   MCIWndString(p, TRUE, szPlayReverse, (LPTSTR)szNULL);
           } else {
               if (MCIWndString(p, FALSE, szPlay, MaybeRepeat))
                   MCIWndString(p, TRUE, szPlay, (LPTSTR)szNULL);
           }

           // Kick ourselves to fix up toolbar since mode changed
           MCIWndiTimerStuff(p);

           break;

       case MCI_STOP:
           return MCIWndStop(hwnd);

       case MCI_PAUSE:
           return MCIWndPause(hwnd);

       case IDM_MCINEW:
           return MCIWndNew(hwnd, NULL);

       case IDM_MCIOPEN:
           return MCIWndOpenDialog(hwnd);

       case MCI_SAVE:
           return MCIWndSaveDialog(hwnd);

       case IDM_MCICLOSE:
           return MCIWndClose(hwnd);

       case IDM_MCICONFIG:
           MCIWndString(p, TRUE, szConfigure);

           // AVI's configure box might change the size (zoom by 2)
           // so we better call our size routine.
           MCIWndiSize(p, 0);

           // Taking ZOOM X 2 off might leave the outside not painted
           InvalidateRect(hwnd, NULL, TRUE);
           break;

       case IDM_MCICOMMAND:
           mciDialog(hwnd);

           // call mciwndisize?
           break;

       case IDM_COPY:
           MCIWndCopy(p);
           break;

       case IDM_MCIREWIND:
           return MCIWndSeek(hwnd, MCIWND_START);

       case IDM_MCIEJECT:
           return MCIWndEject(hwnd);

// When somebody presses a toolbar button in 16 bit Chicago, we are told
// about it via a WM_COMMAND.  32 bit Chicago and NT uses WM_NOTIFY, handled
// elsewhere.
#ifndef _WIN32
       case ID_TOOLBAR: {
           RECT rc;
           RECT rcT;
           MSG  msgT;

	   // We're only interested in a pressing of the Menu button
           if (wNotify != TBN_BEGINDRAG ||
               (UINT)hwndCtl != IDM_MENU ||
               !SendMessage(p->hwndToolbar, TB_ISBUTTONENABLED,
                       IDM_MENU, 0) ||
               !p->hmenu)
           break;

           SendMessage(p->hwndToolbar, TB_GETITEMRECT,
               (int)SendMessage(p->hwndToolbar, TB_COMMANDTOINDEX,
                       IDM_MENU, 0),
               (LPARAM)(LPVOID)&rc);
           rcT = rc;
           ClientToScreen(p->hwndToolbar, (LPPOINT)&rc);
           ClientToScreen(p->hwndToolbar, (LPPOINT)&rc + 1);

           // Push the button down (accelerator won't have done this)
           SendMessage(p->hwndToolbar, TB_PRESSBUTTON, IDM_MENU,
               TRUE);

           // Don't allow error dlgs to come up while we're tracking.
           // That would cause windows to shatter and send shrapnel
           // flying.
           p->fTracking = TRUE;
           TrackPopupMenu(p->hmenu, 0, rc.left, rc.bottom - 1, 0,
                       hwnd, &rc);  // don't dismiss menu inside button
           p->fTracking = FALSE;

           // Bring the button back up.
           SendMessage(p->hwndToolbar, TB_PRESSBUTTON, IDM_MENU,
               FALSE);

           // What if we press the menu button to make the menu go
           // away?  It's just going to bring the menu back up again!
           // So we need to pull the click out of the queue.
           // There are bugs in the toolbar code to prevent me from
           // doing this any other way (like disabling the button)
           if (PeekMessage(&msgT, p->hwndToolbar, WM_LBUTTONDOWN,
                               WM_LBUTTONDOWN, PM_NOREMOVE)) {
#ifdef _WIN32
               POINT pt = {MAKEPOINTS(msgT.lParam).x,
                           MAKEPOINTS(msgT.lParam).y };
#else
               POINT pt = MAKEPOINT(msgT.lParam);
#endif
               if (PtInRect(&rcT, pt))
                   PeekMessage(&msgT, p->hwndToolbar, WM_LBUTTONDOWN,
                               WM_LBUTTONDOWN, PM_REMOVE);
           }
           break;
       }
#endif

       default:
           break;
   }

   return 0;
}


/*--------------------------------------------------------------+
| SubClassedTrackbarWndProc - eat key presses that do something |
| 	special so trackbar never sees them.                    |
+--------------------------------------------------------------*/
LRESULT CALLBACK _LOADDS SubClassedTrackbarWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg) {
	case WM_KEYDOWN:
	case WM_KEYUP:
	case WM_SYSCHAR:
	    return SendMessage(GetParent(hwnd), msg, wParam, lParam);
    }

    return CallWindowProc(fnTrackbarWndProc, hwnd, msg, wParam, lParam);
}


/*--------------------------------------------------------------+
| MCIWndProc - MCI window's window proc                         |
|                                                               |
+--------------------------------------------------------------*/
LRESULT CALLBACK _LOADDS MCIWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PMCIWND             p;
    DWORD	    	dw;
    HDC		    	hdc;
    PAINTSTRUCT	    	ps;
    DWORD               dwPos;
    POINT		pt;
    MINMAXINFO FAR 	*lpmmi;
    RECT		rc;
    BOOL                f;
    TCHAR               ach[80];
    MCI_GENERIC_PARMS   mciGeneric;
    LPRECT              prc;
    int			i;
    HWND		hwndD;

    p = (PMCIWND)(UINT)GetWindowLong(hwnd, 0);

    switch(msg){
        case WM_CREATE:
            if (!MCIWndiCreate(hwnd, lParam))
                return -1;

            break;

        // Make the trackbar background BTNFACE to match the colour scheme
#ifdef _WIN32
	case WM_CTLCOLORBTN:
	case WM_CTLCOLORDLG:
	case WM_CTLCOLOREDIT:
	case WM_CTLCOLORLISTBOX:
	case WM_CTLCOLORMSGBOX:
	case WM_CTLCOLORSCROLLBAR:
	case WM_CTLCOLORSTATIC:
    	    if ((HWND)lParam == p->hwndTrackbar) {
#else
        case WM_CTLCOLOR:
            if ((HWND)LOWORD(lParam) == p->hwndTrackbar) {
#endif
            //  return (LRESULT)(UINT)GetStockObject(LTGRAY_BRUSH);
		SetBkColor((HDC)wParam, GetSysColor(COLOR_BTNFACE));
		SetTextColor((HDC)wParam, GetSysColor(COLOR_BTNTEXT));
                return (LRESULT)(UINT_PTR)GetSysColorBrush(COLOR_BTNFACE);
            }
            break;

	case MCI_SAVE:
	    // wParam presently unused and not given by the macro
            return MCIWndiSave(p, wParam, (LPTSTR)lParam);

#ifdef _WIN32
        case MCIWNDM_OPEN:
#else
        case MCI_OPEN:
#endif
            return MCIWndiOpen(p, wParam, (LPTSTR)lParam);

#ifdef UNICODE
        // ansi thunk for above
        case MCIWNDM_OPENA:
            return MCIWndiOpenA(p, wParam, (LPSTR)lParam);
#endif

	case MCIWNDM_NEW:
	    return MCIWndiOpen(p, MCIWNDOPENF_NEW, (LPTSTR)lParam);

#ifdef UNICODE
	//ansi thunk for above
	case MCIWNDM_NEWA:
	    return MCIWndiOpenA(p, MCIWNDOPENF_NEW, (LPSTR) lParam);
#endif
	
        case MCI_PLAY:

	    if (!p->wDeviceID)
		return 0;
	    // Seek to the beginning if we're near the end
	    MCIWndiPlaySeek(p, FALSE);

	case MCI_STOP:
	case MCI_PAUSE:
	case MCI_RESUME:
	case MCI_RECORD:

	    dw = 0;
	    // Report/Show errors for this
	    if (p->wDeviceID) {
		// buggy drivers crash if we pass a null parms address
	        dw = mciSendCommand(p->wDeviceID, msg, 0,
			(DWORD_PTR)(LPVOID)&mciGeneric);
		if (dw == 0 && msg == MCI_RECORD) {
		    // RECORDING dirties MCIWAVE and what we would copy would
		    // still be the old file, so just disable it to save grief.
		    p->fAllowCopy = FALSE;
		    MCIWndiMakeMeAMenu(p);
		}
		MCIWndiHandleError(p, dw);
		// kick ourselves to show new Mode
		MCIWndiTimerStuff(p);
	    }
	    return dw;

	case MCIWNDM_PLAYREVERSE:

	    if (!p->wDeviceID)
		return 0;
	    // Seek to the end if we're near the beginning
	    MCIWndiPlaySeek(p, TRUE);
            dw = MCIWndString(p, TRUE, szPlayReverse, (LPTSTR)szNULL);
	    // kick ourselves to show new Mode
	    MCIWndiTimerStuff(p);
	    return dw;

        case MCI_CLOSE:
	    if (lParam)
		// We delayed the closing of the MCI device because the MCI
		// device may have hooked our window proc and be on our stack
		// and killing it before would have destroyed the universe.
		// buggy drivers crash if we pass a null parms address
        	return mciSendCommand((UINT)lParam, MCI_CLOSE, 0,
			(DWORD_PTR)(LPVOID)&mciGeneric);
		
	    else
	        // Do all the stuff for closing
	        return MCIWndiClose(p, TRUE);

	case MCIWNDM_EJECT:
	    return MCIWndString(p, TRUE, szSetDoorOpen);

	case MCIWNDM_PLAYFROM:
	    if (lParam == MCIWND_START)
	        dw = MCIWndString(p, TRUE, szPlayFrom, MCIWndGetStart(hwnd));
	    else
	        dw = MCIWndString(p, TRUE, szPlayFrom, (LONG)lParam);
	    MCIWndiTimerStuff(p);	// kick ourselves to see mode change
	    return dw;

	case MCIWNDM_PLAYTO:
	    if (lParam == MCIWND_END)
	        dw = MCIWndString(p, TRUE, szPlayTo, MCIWndGetEnd(hwnd));
	    else if (lParam == MCIWND_START)
	        dw = MCIWndString(p, TRUE, szPlayTo, MCIWndGetStart(hwnd));
	    else
	        dw = MCIWndString(p, TRUE, szPlayTo, (LONG)lParam);
	    MCIWndiTimerStuff(p);	// kick ourselves to see mode change
	    return dw;

	case MCI_STEP:
            return MCIWndString(p, TRUE, szStep, (LONG)lParam);

	case MCI_SEEK:
	    if (lParam == MCIWND_START)
                return MCIWndString(p, TRUE, szSeek, MCIWndGetStart(hwnd));
	    else if (lParam == MCIWND_END)
                return MCIWndString(p, TRUE, szSeek, MCIWndGetEnd(hwnd));
	    else
                return MCIWndString(p, TRUE, szSeek, (LONG)lParam);

	case MCIWNDM_SETREPEAT:
	    p->fRepeat = (BOOL)lParam;
	    return 0;

	case MCIWNDM_GETREPEAT:
	    return p->fRepeat;

	case MCIWNDM_GETDEVICEID:
	    return p->wDeviceID;

	case MCIWNDM_GETALIAS:
	    return p->alias;

	case MCIWNDM_GETMODE:
            if (lParam)
                MCIWndGet(p, szStatusMode, (LPTSTR)lParam, (UINT)wParam);
	    return MCIWndStatus(p, MCI_STATUS_MODE, MCI_MODE_NOT_READY);

#ifdef UNICODE
	// ansi thunk for above
	case MCIWNDM_GETMODEA:
    	    if (lParam) {
		MCIWndGetA(p, szStatusModeA, (LPSTR)lParam, (UINT)wParam);
	    }
	    return MCIWndStatus(p, MCI_STATUS_MODE, MCI_MODE_NOT_READY);
#endif

	// Return the position as a string if they give us a buffer
	case MCIWNDM_GETPOSITION:
#ifdef UNICODE
	case MCIWNDM_GETPOSITIONA:
#endif
            if (lParam) {
		// If we can do tracks, let's give them a pretty string
		if (p->fHasTracks)
        	    MCIWndString(p, FALSE, szSetFormatTMSF);
#ifdef UNICODE
		if (msg == MCIWNDM_GETPOSITIONA) {
		    MCIWndGetA(p, szStatusPositionA,
			(LPSTR)lParam,(UINT)wParam);
		}
		else
#endif
		{
		    MCIWndGet(p, szStatusPosition,
			(LPTSTR)lParam,(UINT)wParam);
		}

		if (p->fHasTracks)
        	    MCIWndString(p, FALSE, szSetFormatMS);
	    }
	    return MCIWndStatus(p, MCI_STATUS_POSITION, 0);


	case MCIWNDM_GETSTART:
	    // Start is a command that works differently
            return MCIWndGetValue(p, FALSE, szStatusStart, 0);

	case MCIWNDM_GETLENGTH:
	    return MCIWndStatus(p, MCI_STATUS_LENGTH, 0);

	case MCIWNDM_GETEND:
	    return MCIWndGetStart(hwnd) + MCIWndGetLength(hwnd);

        case MCIWNDM_SETZOOM:
            p->iZoom = (int)lParam;
	    MCIWndiSize(p, (int)lParam);
            return 0;

        case MCIWNDM_GETZOOM:
            return p->iZoom ? p->iZoom : 100;

        case MCIWNDM_GETPALETTE:
            return MCIWndGetValue(p, FALSE, szStatusPalette, 0);

        case MCIWNDM_SETPALETTE:
            return MCIWndString(p, TRUE, szSetPalette, (HPALETTE)wParam);

	//
	// Returns our error code
	//
	case MCIWNDM_GETERROR:
	    if (lParam) {
                mciGetErrorString(p->dwError, (LPTSTR)lParam, (UINT)wParam);
	    }
	    dw = p->dwError;
	//    p->dwError = 0L;	// we never clear the error
	    return dw;

#ifdef UNICODE
	// ansi thunk for above
	case MCIWNDM_GETERRORA:
	    if (lParam) {
		mciGetErrorStringA(p->dwError, (LPSTR)lParam, (UINT)wParam);
	    }
	    return p->dwError;
#endif

	case MCIWNDM_GETFILENAME:
	    if (lParam)
                lstrcpyn((LPTSTR)lParam, p->achFileName, (UINT)wParam);
            return (lParam == 0);    // !!!

#ifdef UNICODE
	// ansi thunk for above
	case MCIWNDM_GETFILENAMEA:
            if (lParam) {
		Iwcstombs((LPSTR)lParam, p->achFileName, (UINT)wParam);
	    }
	    return (lParam == 0);
#endif

	case MCIWNDM_GETDEVICE:
	    if (lParam)
                return MCIWndGet(p, szSysInfo, (LPTSTR)lParam,
		    (UINT)wParam);
	    return 42;	// !!!

#ifdef UNICODE
	// ansi thunk for above
	case MCIWNDM_GETDEVICEA:
	    if (lParam) {
		return MCIWndGetA(p, szSysInfoA, (LPSTR)lParam, (UINT)wParam);
	    } else {
		return 42; // why do they do this??
	    }
#endif


	case MCIWNDM_SETVOLUME:
	    // Uncheck the current volume, and check the new one.
	    // Round to nearest 5 so it matches a menu item identifier
            i = ((int)MCIWndGetValue(p, FALSE, szStatusVolume, 1000) / 50) * 5;
	    if (p->hmenuVolume)
                CheckMenuItem(p->hmenuVolume, IDM_MCIVOLUME + i, MF_UNCHECKED);
            dw = MCIWndString(p, TRUE, szSetVolume, (int)lParam);
            i = ((int)lParam / 50) * 5;
	    if (p->hmenuVolume)
                CheckMenuItem(p->hmenuVolume, IDM_MCIVOLUME + i, MF_CHECKED);
	    return dw;

	case MCIWNDM_GETVOLUME:
	    return MCIWndGetValue(p, FALSE, szStatusVolume, 1000);

	case MCIWNDM_SETSPEED:
	    // Uncheck the current speed, and check the new one.
	    // Round to nearest 5 so it matches a menu item identifier
            i = ((int)MCIWndGetValue(p, FALSE, szStatusSpeed, 1000) / 50) * 5;
	    if (p->hmenuSpeed)
                CheckMenuItem(p->hmenuSpeed, IDM_MCISPEED + i, MF_UNCHECKED);
            dw = MCIWndString(p, TRUE, szSetSpeed, (int)lParam);
            i = ((int)lParam / 50) * 5;
	    if (p->hmenuSpeed)
                CheckMenuItem(p->hmenuSpeed, IDM_MCISPEED + i, MF_CHECKED);
	    return dw;

	case MCIWNDM_GETSPEED:
            return MCIWndGetValue(p, FALSE, szStatusSpeed, 1000);

	case MCIWNDM_SETTIMEFORMAT:
            dw = MCIWndString(p, TRUE, szSetFormat, (LPTSTR)lParam);
	    MCIWndiValidateMedia(p);
	    return dw;

#ifdef UNICODE
	// ansi thunk for above
	case MCIWNDM_SETTIMEFORMATA:
	{
	    WCHAR * lpW;
	    int sz = lstrlenA( (LPSTR) lParam) + 1;
	    lpW = (WCHAR *) LocalAlloc(LPTR, sz * sizeof(WCHAR));
            if (lpW) {
                Imbstowcs(lpW, (LPSTR) lParam, sz);
		dw = MCIWndString(p, TRUE, szSetFormat, (LPTSTR)lpW);
		MCIWndiValidateMedia(p);
		LocalFree((HLOCAL)lpW);
	    } else {
		dw = MCIERR_OUT_OF_MEMORY;
	    }
	    return dw;
	}
#endif


	case MCIWNDM_GETTIMEFORMAT:
	    if (lParam)
                MCIWndGet(p, szStatusFormat, (LPTSTR)lParam, (UINT)wParam);
	    return MCIWndStatus(p, MCI_STATUS_TIME_FORMAT, 0);	// !!!

#ifdef UNICODE
	// ansi thunk for above
	case MCIWNDM_GETTIMEFORMATA:
	    if (lParam) {
		MCIWndGetA(p, szStatusFormatA, (LPSTR) lParam, (UINT)wParam);
	    }
	    return MCIWndStatus(p, MCI_STATUS_TIME_FORMAT, 0);
#endif


	case MCIWNDM_VALIDATEMEDIA:
	    MCIWndiValidateMedia(p);
	    break;

 	case MCIWNDM_GETSTYLES:
	    return (UINT)(p->dwStyle & 0xFFFF);

 	case MCIWNDM_CHANGESTYLES:
	    return MCIWndiChangeStyles(p, (UINT)wParam, (UINT)lParam);

        case MCIWNDM_SETACTIVETIMER:
	    if (wParam)
	        p->iActiveTimerRate = (unsigned)wParam;
	
	    if (p->fActive) {
                KillTimer(hwnd, TIMER1);
                MCIWndiSetTimer(p);
	    }
	    break;

        case MCIWNDM_SETINACTIVETIMER:
	    if (wParam)
	        p->iInactiveTimerRate = (unsigned)wParam;
	
	    if (!p->fActive) {
                KillTimer(hwnd, TIMER1);
                MCIWndiSetTimer(p);
	    }
	    break;

        case MCIWNDM_SETTIMERS:
	    if (wParam)
	        p->iActiveTimerRate = (unsigned)wParam;
	    if (lParam)
                p->iInactiveTimerRate = (unsigned)lParam;

            KillTimer(hwnd, TIMER1);
            MCIWndiSetTimer(p);

	    break;

	case MCIWNDM_GETACTIVETIMER:
	    return p->iActiveTimerRate;

	case MCIWNDM_GETINACTIVETIMER:
	    return p->iInactiveTimerRate;

        case MCIWNDM_SENDSTRING:
	    //
	    // App wants to send a string command.

	    // special case the CLOSE command to do our clean up
	    lstrcpyn(ach, (LPTSTR)lParam, lstrlen(szClose) + 1);
            if (lstrcmpi((LPTSTR)ach, szClose) == 0)
		return MCIWndClose(hwnd);

	    // Always sets/clears our error code
            dw = MCIWndGet(p, (LPTSTR)lParam, p->achReturn,NUMELMS(p->achReturn));
	    MCIWndiHandleError(p, dw);
	    // kick ourselves in case mode changed from this command
	    MCIWndiTimerStuff(p);
            return dw;

#ifdef UNICODE
	// ansi thunk for above
	// convert string and then re-send message rather than using
	// MCIWndGetA since we need to store the error string in UNICODE.
	case MCIWNDM_SENDSTRINGA:
	{
            WCHAR * lpW;
            int sz = lstrlenA( (LPSTR) lParam) + 1;
            lpW = (WCHAR *)LocalAlloc(LPTR, sz * sizeof(WCHAR));
            if (lpW) {
                Imbstowcs(lpW, (LPSTR) lParam, sz);

		dw = (DWORD) MCIWndProc(hwnd, MCIWNDM_SENDSTRING, 0,
                        (LPARAM) (LPTSTR)lpW);

		LocalFree((HLOCAL)lpW);
	    } else {
		dw = MCIERR_OUT_OF_MEMORY;
	    }
	    return dw;
	}
#endif

	// Gets the return string from the most recent MCIWndSendString()
        case MCIWNDM_RETURNSTRING:
	    if (lParam)
                lstrcpyn((LPTSTR)lParam, p->achReturn, (DWORD) wParam);
            return (lParam == 0);    // !!!

#ifdef UNICODE
	// ansi thunk for above
	case MCIWNDM_RETURNSTRINGA:
            if (lParam) {
		Iwcstombs((LPSTR) lParam, p->achReturn, (DWORD) wParam);
	    }
	    return (lParam == 0);
#endif

        case MCIWNDM_REALIZE:
	    // buggy drivers crash if we pass a null parms address
            dw = mciSendCommand(p->wDeviceID, MCI_REALIZE,
                (BOOL)wParam ? MCI_ANIM_REALIZE_BKGD : MCI_ANIM_REALIZE_NORM,
		(DWORD_PTR)(LPVOID)&mciGeneric);
            break;

        case MCIWNDM_GET_SOURCE:
	    MCIWndRect(p, (LPRECT)lParam, TRUE);
	    return 0L;

	case MCIWNDM_GET_DEST:
	    MCIWndRect(p, (LPRECT)lParam, FALSE);
	    return 0L;

        case MCIWNDM_PUT_SOURCE:
            prc = (LPRECT)lParam;

            return MCIWndString(p, FALSE, szPutSource,
		  prc->left, prc->top,
		  prc->right - prc->left,
                  prc->bottom - prc->top);

	case MCIWNDM_PUT_DEST:
	    prc = (LPRECT)lParam;

	    return MCIWndString(p, FALSE, szPutDest,
		  prc->left, prc->top,
		  prc->right - prc->left,
                  prc->bottom - prc->top);

        case MCIWNDM_CAN_PLAY:   return p->fCanPlay;
        case MCIWNDM_CAN_WINDOW: return p->fCanWindow;
        case MCIWNDM_CAN_RECORD: return p->fCanRecord;
        case MCIWNDM_CAN_SAVE:   return p->fCanSave;
        case MCIWNDM_CAN_EJECT:  return p->fCanEject;
        case MCIWNDM_CAN_CONFIG: return p->fCanConfig;

	case WM_TIMER:

	    // This timer means we've moved the mouse off of the menu and need
	    // to snap the thumb back to the original value
	    if (wParam == TIMER2) {
		KillTimer(hwnd, TIMER2);

		// If only this would cause OwnerDraw to execute, we could see
		// the thumb bounce back to it's default place.  Alas, no can do
		//CheckMenuItem(p->hmenuHack, p->uiHack, MF_UNCHECKED);
		//CheckMenuItem(p->hmenuHack, p->uiHack, MF_CHECKED);

		// This code will at least set the parameter back even though
		// the thumb won't physically move.
		if (p->hmenuHack == p->hmenuVolume)
		    MCIWndSetVolume(hwnd, (p->uiHack - IDM_MCIVOLUME) * 10);
		else
		    MCIWndSetSpeed(hwnd, (p->uiHack - IDM_MCISPEED) * 10);
	    }

	    //
	    // This is not our timer. Bail.
	    //
	    if (wParam != TIMER1)
		break;

	    MCIWndiTimerStuff(p);

	    break;

	case WM_GETMINMAXINFO:

            // bug fix?
            //
            if (!p)
                break;

	    // We don't want anybody messing with the window size
	    if (p->dwStyle & MCIWNDF_NOAUTOSIZEWINDOW)
		break;

	    // do we have a playbar?
	    f = !(p->dwStyle & MCIWNDF_NOPLAYBAR);

            lpmmi = (MINMAXINFO FAR *)(lParam);
            SetRect(&rc, 0, 0, SMALLEST_WIDTH, f ? TB_HEIGHT : 0);
            AdjustWindowRect(&rc, GetWindowLong(hwnd, GWL_STYLE), FALSE);
            lpmmi->ptMinTrackSize.y = rc.bottom - rc.top;
            lpmmi->ptMinTrackSize.x = rc.right - rc.left;

            if (!(p->wDeviceID) || !(p->fCanWindow))
                    lpmmi->ptMaxTrackSize.y = lpmmi->ptMinTrackSize.y;
            break;

        case WM_SIZE:

	    GetClientRect(hwnd, &rc);

	    if (!IsIconic(hwnd)) {
		// if we have a playbar, fix it up to the new size
                f = !(p->dwStyle & MCIWNDF_NOPLAYBAR);

                if (f) {
                    MCIWndiSizePlaybar(p);
                    rc.bottom -= TB_HEIGHT;
                }

                if (!(p->dwStyle & MCIWNDF_NOAUTOSIZEMOVIE))
                    MCIWndString(p, FALSE, szPutDest, 0,0, rc.right, rc.bottom);

	    } else {
                if (!(p->dwStyle & MCIWNDF_NOAUTOSIZEMOVIE))
                    MCIWndString(p, FALSE, szPutDest, 0,0, rc.right, rc.bottom);
	    }

	    // We need to notify the "owner" that our size changed.  Watch for
	    // excessive recursion, which happens with the VfW 1.1d MCIPUZZL
	    // sample app.  That sample's NOTIFYSIZE handler resizes the owner
	    // window as a function of the MCI window size using
	    // AdjustWindowRect().  AdjustWindowRect() used to have a bug which
	    // MCIPUZZL adjusted for by adding 1 to the window height.
	    // Since the AdjustWindowRect() bug has been fixed, that sample
	    // would recurse infinitely because it will size the owner window
	    // one larger which will then resize the MCIWnd one larger which
	    // will then notify the owner which will resize the owner wnd one
	    // larger, etc...
	    if (p->cOnSizeReentered < 3) {
		p->cOnSizeReentered++;
		if (p->dwStyle & MCIWNDF_NOTIFYSIZE) {
		    NotifyOwner(p, MCIWNDM_NOTIFYSIZE, (WPARAM)p->hwnd, (LPARAM)NULL);
		}
		p->cOnSizeReentered--;
	    }
	    break;

        case WM_RBUTTONDOWN:
        case WM_NCRBUTTONDOWN:
        case WM_PARENTNOTIFY:

	    // If we haven't got a menu, or we don't want it, bail
            if (!p->hmenu || p->dwStyle & MCIWNDF_NOMENU)
                break;

	    // If this is not a right button down, bail
            if (msg == WM_PARENTNOTIFY && wParam != WM_RBUTTONDOWN)
                break;

	    GetCursorPos(&pt);

	    // Don't allow error dlgs to come up while we're tracking.  That
	    // would cause windows to enter the twilight zone.
	    p->fTracking = TRUE;
	    TrackPopupMenu(p->hmenu,
		TPM_RIGHTBUTTON, pt.x, pt.y, 0, hwnd, NULL);
	    p->fTracking = FALSE;

            return 0;

        case WM_PALETTECHANGED:
	    if ((HWND)wParam != hwnd && p->fHasPalette)
		InvalidateRect(hwnd, NULL, FALSE);
	    break;

	case WM_QUERYNEWPALETTE:
	    if (p->fHasPalette)
		MCIWndRealize(hwnd, FALSE);
            break;

	// Send a WM_PALETTECHANGED to everyone in the system.  We need to do
	// this manually sometimes because of GDI.
	case MCIWNDM_PALETTEKICK:

	    hwndD = GetDesktopWindow();	// tell everyone DESKTOP changed it
            PostMessage((HWND)-1, WM_PALETTECHANGED, (WPARAM)hwndD, 0);

	    // DESKTOP won't repaint if we give it it's own HWND, so pick a
	    // random window and PRAY it'll stay valid.
	    hwndD = GetActiveWindow();
	    hwndD = GetWindow(hwndD, GW_HWNDLAST);
            PostMessage(GetDesktopWindow(), WM_PALETTECHANGED, (WPARAM)hwndD,0);
	    return 0;

	case MCIWNDM_OPENINTERFACE:
	    wsprintf(ach, szInterface, lParam);
            return MCIWndiOpen(p, 0, (LPTSTR)ach);

	case MCIWNDM_SETOWNER:
	    p->hwndOwner = (HWND)wParam;
	    return 0;

        case WM_ERASEBKGND:
            if (p->fCanWindow) {
                MCIWndRect(p, &rc, FALSE);
                SaveDC((HDC)wParam);
                ExcludeClipRect((HDC)wParam, rc.left, rc.top, rc.right,
                    rc.bottom);
                DefWindowProc(hwnd, msg, wParam, lParam);
                RestoreDC((HDC)wParam, -1);
                return 0;
            }
            break;

        case WM_PAINT:
	    hdc = BeginPaint(hwnd, &ps);
            if (p->wDeviceID && p->fCanWindow)
            {
                MCI_ANIM_UPDATE_PARMS mciUpdate;
		
                mciUpdate.hDC = hdc;

                dw = mciSendCommand(p->wDeviceID, MCI_UPDATE,
                            MCI_ANIM_UPDATE_HDC | MCI_WAIT |
                            MCI_DGV_UPDATE_PAINT,
                            (DWORD_PTR)(LPVOID)&mciUpdate);

                if (dw != 0) /* if the update fails then erase */
                    DefWindowProc(hwnd, WM_ERASEBKGND, (WPARAM)hdc, 0);
	    } else if (IsIconic(hwnd)) {
		DefWindowProc(hwnd, WM_ICONERASEBKGND, (WPARAM)hdc, 0);
		DrawIcon(ps.hdc, 0, 0, p->hicon);
	    }
	    EndPaint(hwnd, &ps);
	    break;
	
	case WM_KEYDOWN:
		switch(wParam) {
		    case VK_LEFT:
			SendMessage(hwnd, WM_HSCROLL, TB_LINEUP, 0); return 0;
		    case VK_RIGHT:
			SendMessage(hwnd, WM_HSCROLL, TB_LINEDOWN, 0); return 0;
		    case VK_PRIOR:
			SendMessage(hwnd, WM_HSCROLL, TB_PAGEUP, 0); return 0;
		    case VK_NEXT:
			SendMessage(hwnd, WM_HSCROLL, TB_PAGEDOWN, 0); return 0;
		    case VK_HOME:
			SendMessage(hwnd, WM_HSCROLL, TB_TOP, 0); return 0;
		    case VK_END:
			SendMessage(hwnd, WM_HSCROLL, TB_BOTTOM, 0); return 0;

		    case VK_UP:
		    case VK_DOWN:
			dw = MCIWndGetValue(p, FALSE, szStatusVolume, 1000);
			if (wParam == VK_UP)
			    i = min((int)p->wMaxVol * 10, (int) dw + 100);
			else
			    i = max(0, (int) dw - 100);
			
			MCIWndSetVolume(p->hwnd, i);
			return 0;	// break will ding
		    default:
			break;
		}
	    break;


	case WM_KEYUP:
	    switch(wParam) {
		case VK_LEFT:
		case VK_RIGHT:
		case VK_PRIOR:
		case VK_NEXT:
		case VK_HOME:
		case VK_END:
		    if (p->fScrolling)
		        SendMessage(hwnd, WM_HSCROLL, TB_ENDTRACK, 0);
		    return 0;	// break will ding
                case VK_ESCAPE:
                    MCIWndStop(hwnd);
                    return 0;
		default:
		    break;
	    }
			
    	    if (GetKeyState(VK_CONTROL) & 0x8000) {
		switch(wParam) {
		    case '1':
		    case '2':
		    case '3':
		    case '4':
			// Don't let somebody resize us if we're not normally
			// resizable.
			if (!(p->dwStyle & MCIWNDF_NOAUTOSIZEWINDOW) &&
				(p->dwStyle & WS_THICKFRAME))
			    MCIWndSetZoom(hwnd, 100 * (wParam - '0'));
			return 0;	// break will ding
		    case 'P':
			MCIWndPlay(hwnd); return 0;
		    case 'S':
			MCIWndStop(hwnd); return 0;
		    case 'D':
			// The key accelerator should only work if we gave
			// them a menu for this command
			if (!(p->dwStyle & MCIWNDF_NOMENU))
			    PostMessage(hwnd, WM_COMMAND, IDM_MCICONFIG, 0);
			return 0;
		    case 'C':
			PostMessage(hwnd, WM_COMMAND, IDM_COPY, 0); return 0;
		    case VK_F5:
			// The key accelerator should only work if we gave
			// them a menu for this command
			if (!(p->dwStyle & MCIWNDF_NOMENU))
			    PostMessage(hwnd, WM_COMMAND, IDM_MCICOMMAND, 0);
			return 0;
		    case 'F':
		    case 'O':
			if (!(p->dwStyle & MCIWNDF_NOOPEN))
			    MCIWndOpenDialog(hwnd);
			return 0;
		    case 'M':
			PostMessage(hwnd, WM_COMMAND,
				GET_WM_COMMAND_MPS(ID_TOOLBAR, IDM_MENU,
					TBN_BEGINDRAG));
			return 0;
		    default:
			break;
		}
	    }
	    break;

	case WM_SYSCHAR:
	    switch(wParam) {
	        case '1':
	        case '2':
	        case '3':
	        case '4':
		    // Don't let somebody resize us if we're not normally
		    // resizable.
		    if (!(p->dwStyle & MCIWNDF_NOAUTOSIZEWINDOW) &&
				(p->dwStyle & WS_THICKFRAME))
			MCIWndSetZoom(hwnd, 100 / ((UINT) wParam - '0'));
		    return 0;	// break will ding
	        default:
		    break;
	    }
	    break;

	case WM_HSCROLL:

#define FORWARD	 1
#define BACKWARD 2

            dwPos = (DWORD) SendMessage(p->hwndTrackbar, TBM_GETPOS, 0, 0);

	    // nothing to do - spurious END without BEGIN
	    if (!p->fScrolling && wParam == TB_ENDTRACK)
		break;

	    // Turn seek exactly off while scrolling and remember what it was
	    // Also, remember if we were playing just before we seeked so we
	    // can continue playing after the seek (so moving the thumb doesn't
	    // stop the play).
            if (!p->fScrolling) {
                p->fScrolling = TRUE;
		// Wierd artifacts happen if you turn seek exactly off while
		// seeking. You see the key frame and then the actual frame.
		// Nobody can remember why this was ever a good idea.
		//p->fSeekExact = MCIWndSeekExact(p, FALSE);
		// if we're still seeking from last time, don't change this
		if (p->dwMode != MCI_MODE_SEEK)
                    p->fPlayAfterSeek = (p->dwMode == MCI_MODE_PLAY);
		// Now which direction was it playing in?
		if (p->fPlayAfterSeek) {
                    MCIWndGet(p, szStatusForward, ach, NUMELMS(ach));
                    if (ach[0] == TEXT('F') || ach[0] == TEXT('f'))
			p->fPlayAfterSeek = BACKWARD;
		    else	// by default, choose forward. Some devices
				// don't understand this command and fail.
			p->fPlayAfterSeek = FORWARD;
		}
            }

	    switch(wParam)
	    {
		case TB_LINEUP:
		    dwPos--; break;
		case TB_LINEDOWN:
		    dwPos++; break;
		case TB_PAGEUP:
		    if (p->fHasTracks) {
			dwPos = MCIWndiPrevTrack(p); break;
		    } else {
                        dwPos -= p->dwMediaLen / 16; break;
		    }
		case TB_PAGEDOWN:
		    if (p->fHasTracks) {
			dwPos = MCIWndiNextTrack(p); break;
		    } else {
                        dwPos += p->dwMediaLen / 16; break;
		    }
		case TB_TOP:
		    dwPos = p->dwMediaStart; break;
		case TB_BOTTOM:
		    dwPos = p->dwMediaStart + p->dwMediaLen; break;
		case TB_THUMBTRACK:
		case TB_THUMBPOSITION:
		    break;
		case TB_ENDTRACK:
		    // All done.  Put seek exact back to what it used to be
		    p->fScrolling = FALSE;
		    // Don't do this anymore (see above)
		    //MCIWndSeekExact(p, p->fSeekExact);
		    break;

		default:
		    break;

	    }

	    // If we're windowed, update the position as we scroll.  That would
	    // be annoying for CD or wave, though.  Also, update as soon as we
	    // let go of the thumb.  Also, never seek around while we're open
	    // or not ready.
	    if ((p->fCanWindow || !p->fScrolling) && p->dwMode != MCI_MODE_OPEN
					&& p->dwMode != MCI_MODE_NOT_READY) {
	        MCIWndSeek(hwnd, dwPos);
		MCIWndiTimerStuff(p);	// kick ourselves to update mode
	    }

	    // After we're done, if we were playing before, go back to playing
	    if (!p->fScrolling && p->fPlayAfterSeek) {
		if (p->fPlayAfterSeek == FORWARD)
                    MCIWndPlay(hwnd);
		else
                    MCIWndPlayReverse(hwnd);
		MCIWndiTimerStuff(p);	// kick ourselves to update mode
	    }

	    // Set the trackbar to the (possibly) new position
	    SendMessage(p->hwndTrackbar, TBM_SETPOS, TRUE, dwPos);
            break;

        case WM_MENUSELECT:
            break;

	// Sent from a toolbar button being pressed
        case WM_COMMAND:
            return MCIWndCommands (p, hwnd, wParam, lParam);
            break;

// When somebody presses a toolbar button in 32 bit Chicago-land, we are told
// about it via a WM_NOTIFY.  Else, we are sent a WM_COMMAND, handled elsewhere.
#ifdef _WIN32
       case WM_NOTIFY: {

#define lpHdr ((TBNOTIFY *)lParam)

           if (lpHdr->hdr.code == TBN_BEGINDRAG) {

               RECT rc;
               RECT rcT;
               MSG  msgT;


	   // We're only interested in a pressing of the Menu button
               if (lpHdr->hdr.idFrom != ID_TOOLBAR ||
	       lpHdr->iItem != IDM_MENU ||
               !SendMessage(p->hwndToolbar, TB_ISBUTTONENABLED,
                       IDM_MENU, 0) ||
               !p->hmenu)
           break;

           SendMessage(p->hwndToolbar, TB_GETITEMRECT,
               (int)SendMessage(p->hwndToolbar, TB_COMMANDTOINDEX,
                       IDM_MENU, 0),
               (LPARAM)(LPVOID)&rc);
           rcT = rc;
           ClientToScreen(p->hwndToolbar, (LPPOINT)&rc);
           ClientToScreen(p->hwndToolbar, (LPPOINT)&rc + 1);

           // Push the button down (accelerator won't have done this)
           SendMessage(p->hwndToolbar, TB_PRESSBUTTON, IDM_MENU,
               TRUE);

           // Don't allow error dlgs to come up while we're tracking.
           // That would cause windows to shatter and send shrapnel
           // flying.
           p->fTracking = TRUE;
           TrackPopupMenu(p->hmenu, 0, rc.left, rc.bottom - 1, 0,
                       hwnd, &rc);  // don't dismiss menu inside button
           p->fTracking = FALSE;

           // Bring the button back up.
           SendMessage(p->hwndToolbar, TB_PRESSBUTTON, IDM_MENU,
               FALSE);

           // What if we press the menu button to make the menu go
           // away?  It's just going to bring the menu back up again!
           // So we need to pull the click out of the queue.
           // There are bugs in the toolbar code to prevent me from
           // doing this any other way (like disabling the button)
           if (PeekMessage(&msgT, p->hwndToolbar, WM_LBUTTONDOWN,
                               WM_LBUTTONDOWN, PM_NOREMOVE)) {
               POINT pt = {MAKEPOINTS(msgT.lParam).x,
                           MAKEPOINTS(msgT.lParam).y };
               if (PtInRect(&rcT, pt))
                   PeekMessage(&msgT, p->hwndToolbar, WM_LBUTTONDOWN,
                               WM_LBUTTONDOWN, PM_REMOVE);
           }
           }
           else if (lpHdr->hdr.code == TTN_NEEDTEXT) {

                LPTOOLTIPTEXT   lpTt;
                extern HINSTANCE ghInst;	// in video\init.c

                lpTt = (LPTOOLTIPTEXT)lParam;
                LoadString( ghInst, (UINT) lpTt->hdr.idFrom,
                            lpTt->szText, NUMELMS(lpTt->szText) );
                return 0;
           }
           break;
       }
#endif

        case WM_DESTROY:
	    // !!! MMP CLOSE will be deferred till AFTER the DESTROY

	    // Don't palette kick when we're going down.
	    // 
	    p->fHasPalette = FALSE;
            MCIWndiClose(p, FALSE);  //don't leave us playing into a random DC
	    break;

	// We can't free our pointer until now, because WM_NCDESTROY is the
	// guaranteed last message we'll get.  If we do it sooner, we could
	// fault trying to use it.
	case WM_NCDESTROY:

	    if (p->hmenu) {
                DestroyMenu(p->hmenu);
		if (p->hbrDither) {
		    DeleteObject(p->hbrDither);
		    p->hbrDither = NULL;
		}
	    }

 	    if (p->pTrackStart)
		LocalFree((HANDLE)p->pTrackStart);

	    if (p->hfont) {
		// !!! Someone else may have to go and create it again, but oh
		// !!! well.
		DeleteObject(p->hfont);
		p->hfont = NULL;
	    }

	    if (p->hicon) {
		DestroyIcon(p->hicon);
		p->hicon = NULL;
	    }
	
//	    if (p->hbmToolbar) {
//		DeleteObject(p->hbmToolbar);
//		p->hbmToolbar = NULL;
//	    }

	    // We can't destroy our pointer and then fall through and use it
	    f = p->fMdiWindow;
	    LocalFree((HLOCAL) p);
            SetWindowLong(hwnd, 0, 0);       // our p
	    if (f)
		return DefMDIChildProc(hwnd, msg, wParam, lParam);
	    else
		return DefWindowProc(hwnd, msg, wParam, lParam);

	// Use a different rate for the timer depending on if we're active
	// or not.
        case WM_NCACTIVATE:
	    // MDI windows need to realize their palette here
	    if (p->wDeviceID && p->fMdiWindow && p->fHasPalette)
		MCIWndRealize(hwnd, wParam == FALSE);
#if 0
	case WM_ACTIVATE:
	    p->fActive = wParam;
	    KillTimer(hwnd, TIMER1);
	    MCIWndiSetTimer(p);
#endif
	    break;
	
	case WM_SETFOCUS:
	    p->fActive = TRUE;
	    KillTimer(hwnd, TIMER1);
	    MCIWndiSetTimer(p);
	    break;

	case WM_KILLFOCUS:
	    p->fActive = FALSE;
	    KillTimer(hwnd, TIMER1);
	    MCIWndiSetTimer(p);
	    break;

	// If the user uses MCINOTIFY we pass the notify on to the "owner"
	case MM_MCINOTIFY:
	    // Kick ourselves to update toolbar/titles since getting a notify
	    // means that stuff might have changed.
	    MCIWndiTimerStuff(p);
	    return NotifyOwner(p, msg, wParam, lParam);
	
        case WM_DRAWITEM:
        case WM_MEASUREITEM:
        case WM_DELETEITEM:
            OwnerDraw(p, msg, wParam, lParam);
            return TRUE;        // !!!

        case WM_SYSCOMMAND:
            switch (wParam & ~0xF) {
                case SC_MINIMIZE:
		    // Minimizing from MAXIMIZED state better do the same thing
		    // as restore or windows will always think it's maximized
		    // and start wierding out on us (Chico bug 19541).
		    if (IsZoomed(hwnd)) {
			wParam = SC_RESTORE | (wParam & 0xF);
			break;	// MUST let DefWndProc run
		    }
                    if (p->wDeviceID && p->fCanWindow) {
                        RECT rc;
                        MCIWndGetDest(hwnd, &rc);
                        if (rc.right  > p->rcNormal.right &&
                            rc.bottom > p->rcNormal.bottom) {

			    // We pressed buttons on the title bar... we really
			    // better autosize window.
			    DWORD dw = p->dwStyle;
			    p->dwStyle &= ~MCIWNDF_NOAUTOSIZEWINDOW;
                            MCIWndSetZoom(hwnd, 100);
			    p->dwStyle = dw;
                            return 0;
                        }
                    }
                    break;

                case SC_MAXIMIZE:
                    if (p->fCanWindow && !IsIconic(hwnd)) {
                        RECT rc;
                        MCIWndGetDest(hwnd, &rc);
                        if (rc.right  < p->rcNormal.right &&
                            rc.bottom < p->rcNormal.bottom) {

			    // We pressed buttons on the title bar... we really
			    // better autosize window.
			    DWORD dw = p->dwStyle;
			    p->dwStyle &= ~MCIWNDF_NOAUTOSIZEWINDOW;
                            MCIWndSetZoom(hwnd, 100);
			    p->dwStyle = dw;
                            return 0;
                        }
                        if (rc.right  >= p->rcNormal.right &&
                            rc.right  <  p->rcNormal.right*2 &&
                            rc.bottom >= p->rcNormal.bottom &&
                            rc.bottom <  p->rcNormal.bottom*2) {

			    // We pressed buttons on the title bar... we really
			    // better autosize window.
			    DWORD dw = p->dwStyle;
			    p->dwStyle &= ~MCIWNDF_NOAUTOSIZEWINDOW;
                            MCIWndSetZoom(hwnd, 200);
			    p->dwStyle = dw;
                            return 0;
                        }
                    }
                    break;
            }
            break;

	case WM_DROPFILES:
	    MCIWndiDrop(hwnd, wParam);
	    break;

	case WM_QUERYDRAGICON:
	    return (LONG_PTR)(UINT_PTR)p->hicon;
    }

    if (p && p->fMdiWindow)
        return DefMDIChildProc(hwnd, msg, wParam, lParam);
    else
        return DefWindowProc(hwnd, msg, wParam, lParam);
}

STATICFN void NEAR PASCAL PatRect(HDC hdc,int x,int y,int dx,int dy)
{
    RECT    rc;

    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}

#define FillRC(hdc, prc)    PatRect(hdc, (prc)->left, (prc)->top, (prc)->right - (prc)->left, (prc)->bottom-(prc)->top)

STATICFN HBITMAP NEAR PASCAL CreateDitherBitmap(void)
{
    PBITMAPINFO pbmi;
    HBITMAP hbm;
    HDC hdc;
    int i;
    long patGray[8];
    DWORD rgb;

    pbmi = (PBITMAPINFO)LocalAlloc(LPTR, sizeof(BITMAPINFOHEADER) +
		(sizeof(RGBQUAD) * 16));
    if (!pbmi)
        return NULL;

    pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth = 8;
    pbmi->bmiHeader.biHeight = 8;
    pbmi->bmiHeader.biPlanes = 1;
    pbmi->bmiHeader.biBitCount = 1;
    pbmi->bmiHeader.biCompression = BI_RGB;

    rgb = GetSysColor(COLOR_BTNFACE);
    pbmi->bmiColors[0].rgbBlue  = GetBValue(rgb);
    pbmi->bmiColors[0].rgbGreen = GetGValue(rgb);
    pbmi->bmiColors[0].rgbRed   = GetRValue(rgb);
    pbmi->bmiColors[0].rgbReserved = 0;

    rgb = GetSysColor(COLOR_BTNHIGHLIGHT);
    pbmi->bmiColors[1].rgbBlue  = GetBValue(rgb);
    pbmi->bmiColors[1].rgbGreen = GetGValue(rgb);
    pbmi->bmiColors[1].rgbRed   = GetRValue(rgb);
    pbmi->bmiColors[1].rgbReserved = 0;


    /* initialize the brushes */

    for (i = 0; i < 8; i++)
       if (i & 1)
           patGray[i] = 0xAAAA5555L;   //  0x11114444L; // lighter gray
       else
           patGray[i] = 0x5555AAAAL;   //  0x11114444L; // lighter gray

    hdc = GetDC(NULL);

    hbm = CreateDIBitmap(hdc, &pbmi->bmiHeader, CBM_INIT, patGray, pbmi,
		DIB_RGB_COLORS);

    ReleaseDC(NULL, hdc);

    LocalFree((HANDLE)pbmi);

    return hbm;
}

STATICFN HBRUSH NEAR PASCAL CreateDitherBrush(void)
{
    HBITMAP hbmGray;
    HBRUSH  hbrDither;

    hbmGray = CreateDitherBitmap();
    if (hbmGray) {
	hbrDither = CreatePatternBrush(hbmGray);
	DeleteObject(hbmGray);
	return hbrDither;
    }
    return NULL;
}

//
// Draw the channel for the volume and speed menu controls
//
STATICFN void NEAR PASCAL DrawChannel(HDC hdc, LPRECT prc, HBRUSH hbrDither)
{
    HBRUSH hbrTemp;

    int iWidth = prc->right - prc->left;

    // draw the frame around the window
    SetBkColor(hdc, GetSysColor(COLOR_WINDOWFRAME));

    PatRect(hdc, prc->left, prc->top,      iWidth, 1);
    PatRect(hdc, prc->left, prc->bottom-2, iWidth, 1);
    PatRect(hdc, prc->left, prc->top,      1, prc->bottom-prc->top-1);
    PatRect(hdc, prc->right-1, prc->top, 1, prc->bottom-prc->top-1);

    SetBkColor(hdc, GetSysColor(COLOR_BTNHIGHLIGHT));
    PatRect(hdc, prc->left, prc->bottom-1, iWidth, 1);

    SetBkColor(hdc, GetSysColor(COLOR_BTNSHADOW));
    PatRect(hdc, prc->left+1, prc->top + 1, iWidth-2,1);

    // draw the background in dither gray
    hbrTemp = SelectObject(hdc, hbrDither);

    if (hbrTemp) {
        PatBlt(hdc, prc->left+1, prc->top + 2,
            iWidth-2, prc->bottom-prc->top-4, PATCOPY);
        SelectObject(hdc, hbrTemp);
    }
}

STATICFN LRESULT OwnerDraw(PMCIWND p, UINT msg, WPARAM wParam, LPARAM lParam)
{
    RECT        rc, rcMenu, rcChannel, rcThumb;
    HDC         hdc;
    int         i,dx,dy,len;
    SIZE        size;
    TCHAR       ach[10];
    HWND        hwnd = p->hwnd;

    #define lpMIS  ((LPMEASUREITEMSTRUCT)lParam)
    #define lpDIS  ((LPDRAWITEMSTRUCT)lParam)

    #define WIDTH_FROM_THIN_AIR 14
    #define CHANNEL_INDENT	6	// for VOLUME and SPEED menu trackbar
    #define MENU_WIDTH          10
    #define THUMB               5
    #define MENU_ITEM_HEIGHT	2

    switch (msg)
    {
        case WM_MEASUREITEM:

            if (p->hfont == NULL)
                p->hfont = CreateFont (8, 0, 0, 0,
		                FW_NORMAL,FALSE,FALSE,FALSE,
		                ANSI_CHARSET,OUT_DEFAULT_PRECIS,
                                CLIP_DEFAULT_PRECIS,PROOF_QUALITY,
		                VARIABLE_PITCH | FF_DONTCARE,
                                szSmallFonts);

	    //
	    // The first and last menu items are the spaces above and below
	    // the channel, so they need to be taller.
	    //
	    if (lpMIS->itemID == IDM_MCIVOLUME + VOLUME_MAX + 1
		|| lpMIS->itemID == IDM_MCISPEED + SPEED_MAX + 1
	    	|| lpMIS->itemID == IDM_MCIVOLUME + VOLUME_MAX + 2
		|| lpMIS->itemID == IDM_MCISPEED + SPEED_MAX + 2) {

                lpMIS->itemHeight = CHANNEL_INDENT;
                lpMIS->itemWidth  = MENU_WIDTH;
	    } else {
                lpMIS->itemHeight = MENU_ITEM_HEIGHT;
                lpMIS->itemWidth  = MENU_WIDTH;
	    }

	    return TRUE;

        case WM_DRAWITEM:
            rc  = lpDIS->rcItem;
            hdc = lpDIS->hDC;

	    //
	    // Something has been deselected.  If we don't see a new selection
	    // soon, it means we've dragged the cursor off the menu, and we
	    // should pop the thumb back to its original spot.
	    //
	    if ((lpDIS->itemAction & ODA_SELECT) &&
				!(lpDIS->itemState & ODS_SELECTED))
		SetTimer(p->hwnd, TIMER2, 500, NULL);
		
            //
	    // When asked to draw the selected or checked menu item, we will
	    // draw the entire menu.  Otherwise, we don't do a thing
            //
	    if (lpDIS->itemState & (ODS_SELECTED | ODS_CHECKED)) {

		// This is the item that is checked, or the original spot for
		// the thumb.  Remember it so when we drag off the menu, we
		// can bounce the thumb back here.
		if (lpDIS->itemState & ODS_CHECKED) {
		    p->uiHack = lpDIS->itemID;
	            if (p->uiHack >= IDM_MCISPEED &&
	            		p->uiHack <= IDM_MCISPEED + SPEED_MAX)
			p->hmenuHack = p->hmenuSpeed;
		    else
			p->hmenuHack = p->hmenuVolume;
		}

		// Something is being selected.  Obviously the mouse is still
		// on the menu.  Scrap our timer that was waiting to see if
		// we've dragged off the menu.
		if (lpDIS->itemState & ODS_SELECTED)
		    KillTimer(p->hwnd, TIMER2);

		// !!! Hack from Hell !!!
	        // If we try to highlight the bogus menu items, bail!
	        if (lpDIS->itemID == IDM_MCIVOLUME + VOLUME_MAX + 1)
		    break;
	        if (lpDIS->itemID == IDM_MCIVOLUME + VOLUME_MAX + 2)
		    break;
	        if (lpDIS->itemID == IDM_MCISPEED + SPEED_MAX + 1)
		    break;
	        if (lpDIS->itemID == IDM_MCISPEED + SPEED_MAX + 2)
		    break;

		// Actually set the parameter to the value we're dragging so
		// we can hear it change as we move the slider.
		// 42 means DON'T CHECK it (remember which item was originally
		// checked).
		SendMessage(hwnd, WM_COMMAND, lpDIS->itemID, 42);

		//
		// Get the rect of our menu window.  GetClipBox is
		// not quite right, so we'll adjust for the border.  Our lpDIS
		// contains the proper width of the client area, so we'll use
		// that.
		//

                GetClipBox(hdc, &rc);
                rc.top++;	//!!! top border width
                rc.bottom -= 2;	//!!! bottom border width
                rc.left = lpDIS->rcItem.left;
                rc.right = lpDIS->rcItem.right;
	 	rcMenu = rc;	// This is the rect of the whole menu

		// !!!
		// Deflate the rect to the area we want the channel to be
		// drawn in.  Use HACKY constants.
		// !!!
                i = (rc.right - rc.left - WIDTH_FROM_THIN_AIR) / 2;
                rc.top    += CHANNEL_INDENT;
                rc.bottom -= CHANNEL_INDENT;
                rc.left   += i;
                rc.right  -= i;
		rcChannel = rc;	// This is the rect of the channel

		//
		// See where the thumb belongs
		//
                rc = lpDIS->rcItem;
		rc.bottom = rc.top + 2;		// Ouch! Make sure size is 2
		
		//
		// Don't draw the thumb higher than the top of the channel
		//
		if (rc.top < rcChannel.top) {
		    rc.top = rcChannel.top;
		    rc.bottom = rc.top + 2;	// itemHeight
		}

		//
		// Don't draw the thumb below the bottom of the channel
		//
		if (rc.top > rcChannel.bottom - 2) {	// where border is
		    rc.top = rcChannel.bottom - 2;
		    rc.bottom = rc.top + 2;
		}

		//
		// Munge the rect in a bit and draw the thumb there
		//
                rc.left  += 2;
                rc.right -= 2;
                rc.bottom+= THUMB;
                rc.top   -= THUMB;

#if 0
		// Make the thumb a little bigger on the checked value
	        if (lpDIS->itemState & ODS_CHECKED) {
		    rc.top -= 1;
		    rc.bottom += 1;
		}
#endif

		rcThumb = rc;	// This is the rect of the thumb

                dx = rc.right  - rc.left;
                dy = rc.bottom - rc.top;

                SetBkColor(hdc, GetSysColor(COLOR_WINDOWFRAME));
                PatRect(hdc, rc.left+1, rc.top, dx-2,1        );
                PatRect(hdc, rc.left+1, rc.bottom-1,dx-2,1    );
                PatRect(hdc, rc.left, rc.top+1, 1,dy-2        );
                PatRect(hdc, rc.right-1,  rc.top+1, 1,dy-2    );

                InflateRect(&rc,-1,-1);
                dx = rc.right  - rc.left;
                dy = rc.bottom - rc.top;

                SetBkColor(hdc, GetSysColor(COLOR_BTNHIGHLIGHT));
                PatRect(hdc, rc.left,   rc.top,   1,dy);
                PatRect(hdc, rc.left,   rc.top,   dx,1);

                SetBkColor(hdc, GetSysColor(COLOR_BTNSHADOW));
                PatRect(hdc, rc.right-1,rc.top+1, 1,dy-1);
                PatRect(hdc, rc.left+1, rc.bottom-1, dx-1,1);

                InflateRect(&rc,-1,-1);

                SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));
                SelectObject(hdc, p->hfont);
                len = wsprintf(ach, TEXT("%d"), lpMIS->itemID % 1000);

                GetTextExtentPoint(hdc, ach, len, &size);
                ExtTextOut(hdc,
                    (rc.right  + rc.left - size.cx)/2,
                    (rc.bottom + rc.top - size.cy)/2,
                    ETO_OPAQUE,&rc,ach,len,NULL);

		//
		// Exclude the ClipRect that all that garbage drew into
		//
                ExcludeClipRect(hdc, rcThumb.left, rcThumb.top,
                        rcThumb.right, rcThumb.bottom);

		//
		// Next, draw the channel
                //
                DrawChannel(hdc, &rcChannel, p->hbrDither);
		ExcludeClipRect(hdc, rcChannel.left, rcChannel.top,
                        rcChannel.right, rcChannel.bottom);

		//
		// Lastly, fill the entire menu rect with the menu colour
		//
                SetBkColor(hdc, GetSysColor(COLOR_MENU));
                FillRC(hdc, &rcMenu);
            }

            return TRUE;

	case WM_DELETEITEM:
	    return TRUE;
    }
    return TRUE;
}


//
// Code to implement the MCI command dialog box
//

void PositionWindowNearParent(HWND hwnd)
{
    RECT    rc;
    RECT    rcParent;

    GetWindowRect(hwnd, &rc);
    rc.bottom -= rc.top;
    rc.right -= rc.left;
    GetWindowRect(GetParent(hwnd), &rcParent);

    if (rcParent.bottom + rc.bottom <
				GetSystemMetrics(SM_CYSCREEN)) {
	SetWindowPos(hwnd, NULL,
		     min(rc.left, GetSystemMetrics(SM_CXSCREEN) - rc.right),
		     rcParent.bottom,
		     0, 0,
		     SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
    } else if (rc.bottom < rcParent.top) {
	SetWindowPos(hwnd, NULL,
		     min(rc.left, GetSystemMetrics(SM_CXSCREEN) - rc.right),
		     rcParent.top - rc.bottom,
		     0, 0,
		     SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
    }
}

/*--------------------------------------------------------------+
| mciDialog - bring up the dialog for MCI Send Command          |
|                                                               |
+--------------------------------------------------------------*/
INT_PTR FAR PASCAL _loadds mciDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    TCHAR   ach[255];
    TCHAR   achT[40];
    UINT    w;
    DWORD   dw;
    PMCIWND p;
    HWND    hwndP;

    switch (msg)
    {
        case WM_INITDIALOG:
	    // Remember our actually true parent
	    SetWindowLongPtr(hwnd, DWLP_USER, lParam);
	    PositionWindowNearParent(hwnd);
            return TRUE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam,lParam))
            {
                case IDOK:
                    Edit_SetSel (GetDlgItem (hwnd, IDC_MCICOMMAND), 0, -1);
                    w = GetDlgItemText(hwnd, IDC_MCICOMMAND, ach, NUMELMS(ach));

		    hwndP = (HWND)GetWindowLongPtr(hwnd, DWLP_USER);
		    p = (PMCIWND)(UINT)GetWindowLong(hwndP, 0);

		    // special case the CLOSE command to do our clean up
	    	    lstrcpyn(achT, (LPTSTR)ach, lstrlen(szClose) + 1);
		    if (lstrcmpi((LPTSTR)achT, szClose) == 0) {
			MCIWndClose(hwndP);
			break;
		    }

                    dw = MCIWndGet(p, ach, ach, NUMELMS(ach));

                    if (dw != 0)
                        mciGetErrorString(dw, ach, NUMELMS(ach));

                    SetDlgItemText(hwnd, IDC_RESULT, ach);

	    	    // kick ourselves in case mode changed from this command
	    	    MCIWndiTimerStuff(p);
                    break;

                case IDCANCEL:
                    EndDialog(hwnd, FALSE);
                    break;
            }
            break;
    }

    return FALSE;
}

STATICFN BOOL NEAR PASCAL mciDialog(HWND hwnd)
{
    DialogBoxParam(hInst, MAKEINTATOM(DLG_MCICOMMAND), hwnd,
                mciDlgProc, (LPARAM)hwnd);
    return TRUE;
}


//
// Code to implement the Copy command:
//
//
// MCIWnd tries to copy the same things to the clipboard that VfW MPlayer
// would have.
//

#define SLASH(c)     ((c) == TEXT('/') || (c) == TEXT('\\'))
/**************************************************************************

    convert a file name to a fully qualifed path name, if the file
    exists on a net drive the UNC name is returned.

***************************************************************************/

STATICFN BOOL NetParseFile(LPTSTR szFile, LPTSTR szPath)
{
    TCHAR       achDrive[4];
    TCHAR       achRemote[128];
    int         cbRemote = NUMELMS(achRemote);

    // Dynamically link to WNetGetConnection.  That way MPR.DLL will only
    // get pulled in if it is needed.
#ifdef UNICODE
    typedef DWORD (APIENTRY *LPWNETGETCONNECTION)(
        LPCWSTR lpLocalName,
        LPWSTR lpRemoteName,
        LPDWORD lpnLength
        );
    char  szWNetGetConnection[] = "WNetGetConnectionW";
#else
    typedef DWORD (APIENTRY *LPWNETGETCONNECTION)(
        LPCSTR lpLocalName,
        LPSTR lpRemoteName,
        LPDWORD lpnLength
        );
    char  szWNetGetConnection[] = "WNetGetConnectionA";
#endif

    TCHAR szMpr[] = TEXT("MPR.DLL");
    LPWNETGETCONNECTION lpFn;
    HINSTANCE hInst;


    if (szPath == NULL)
        szPath = szFile;
    else
        szPath[0] = 0;

    //
    // Fully qualify the file name
    //
#ifdef _WIN32
    {
        LPTSTR pfile;
        TCHAR  achPath[MAX_PATH];

        achPath[0] = 0;
        if (GetFullPathName(szFile, MAX_PATH, achPath, &pfile) == 0) {
             return FALSE;
	}
        lstrcpy( szPath, achPath );
    }
#else
    {
        OFSTRUCT of;

        if (OpenFile(szFile, &of, OF_PARSE) == -1)
            return FALSE;

        lstrcpy(szPath, of.szPathName);
    }
#endif

    //
    // if the file is not drive based (probably UNC)
    //
    if (szPath[1] != TEXT(':'))
        return TRUE;

    achDrive[0] = szPath[0];
    achDrive[1] = TEXT(':');
    achDrive[2] = TEXT('\0');

    hInst = LoadLibrary(szMpr);
    if (hInst == NULL) {
        return FALSE;
    }
    *(FARPROC *)&lpFn = GetProcAddress( hInst, szWNetGetConnection);

    if ( (*lpFn)(achDrive, achRemote, &cbRemote) != WN_SUCCESS) {
        FreeLibrary(hInst);
        return FALSE;
    }

    FreeLibrary(hInst);

    if (!SLASH(achRemote[0]) || !SLASH(achRemote[1]))
	return TRUE;

    lstrcat(achRemote, szPath+2);
    lstrcpy(szPath, achRemote);

    return TRUE;
}



SZCODE aszMPlayerName[]           = TEXT("MPlayer");
HANDLE GetMPlayerData(PMCIWND p)
{
    TCHAR       szFileName[MAX_PATH];
    TCHAR	ach[40];
    TCHAR       szDevice[40];
    HANDLE      h;
    LPSTR       psz;
    int         len;
    LPTSTR      lpszCaption = szFileName;
    UINT	wOptions;
    RECT	rc;
    BOOL	fCompound, fFile;
    DWORD	dw;
    MCI_GETDEVCAPS_PARMS    mciDevCaps; /* for the MCI_GETDEVCAPS command */

    //
    // Get the Device Name
    //
    MCIWndGet(p, TEXT("sysinfo installname"), szDevice, NUMELMS(szDevice));

    //
    // determine if the device is simple or compound
    //
    mciDevCaps.dwItem = MCI_GETDEVCAPS_COMPOUND_DEVICE;
    dw = mciSendCommand(p->wDeviceID, MCI_GETDEVCAPS,
        MCI_GETDEVCAPS_ITEM, (DWORD_PTR)(LPSTR)&mciDevCaps);
    fCompound = (dw == 0 && mciDevCaps.dwReturn != 0);

    //
    // determine if the device handles files
    //
    if (fCompound) {
        mciDevCaps.dwItem = MCI_GETDEVCAPS_USES_FILES;
        dw = mciSendCommand(p->wDeviceID, MCI_GETDEVCAPS,
            MCI_GETDEVCAPS_ITEM, (DWORD_PTR)(LPSTR)&mciDevCaps);
        fFile = (dw == 0 && mciDevCaps.dwReturn != 0);
    }

    //
    // Compound devices that support files have an associated filename
    //
    if (fCompound && fFile) {
        lstrcpy(szFileName, p->achFileName);

        //
        // Sometimes the filename is really "device!filename" so we have to peel
        // the real filename out of it
        //
        lstrcpyn(ach, szFileName, lstrlen(szDevice) + 1);
        if ((lstrcmpi(szDevice, ach) == 0) &&
                        (szFileName[lstrlen(szDevice)] == TEXT('!'))) {
            lstrcpy(szFileName, &(p->achFileName[lstrlen(szDevice) + 1]));
        }

        NetParseFile(szFileName, (LPTSTR)NULL);
#ifndef _WIN32
        OemToAnsi(szFileName,szFileName);       // Map extended chars.
#endif
    } else {
        szFileName[0] = TEXT('\0');
    }

#ifdef DEBUG
    DPF("  GetLink: %ls|%ls!%ls\n",
        (LPTSTR)aszMPlayerName,
        (LPTSTR)szFileName,
        (LPTSTR)szDevice);
#endif

    /* How much data will we be writing? */
    len = 9 +                    // all the delimeters
          lstrlen(aszMPlayerName) +
          lstrlen(szFileName) +
          lstrlen(szDevice) +
          5 + 10 + 10 + 10 +     // max length of int and long strings
          lstrlen(lpszCaption);

    h = GlobalAlloc(GMEM_DDESHARE|GMEM_ZEROINIT, len);
    if (!h)
        return NULL;
    psz = GlobalLock(h);

    wOptions = 0x0030; // !!!! OPT_PLAY|OPT_BAR

    switch (MCIWndStatus(p, MCI_STATUS_TIME_FORMAT, 0)) {
	case MCI_FORMAT_FRAMES:
	    wOptions |= 1;	// frame mode
	    break;
	
	case MCI_FORMAT_MILLISECONDS:
	    wOptions |= 2;	// time mode
	    break;
    }
	
    MCIWndRect(p, &rc, FALSE);

    wsprintfA(psz,
#ifdef UNICODE
              "%ls%c%ls%c%ls%c%d%c%d%c%d%c%d%c%d%c%ls%c",
#else
              "%s%c%s%c%s%c%d%c%ld%c%ld%c%ld%c%d%c%s%c",
#endif
              (LPTSTR)aszMPlayerName, '\0',
              (LPTSTR)szFileName, '\0',
              (LPTSTR)szDevice, ',',
              wOptions, ',',
              0L, ',', // !!! sel start
              0L, ',', // !!! sel length
              p->dwPos, ';',
              rc.bottom - rc.top, ',',
              lpszCaption, '\0');

    return h;
}

HBITMAP FAR PASCAL BitmapMCI(PMCIWND p)
{
    HDC         hdc, hdcMem;
    HBITMAP     hbm, hbmT;
    HBRUSH      hbrOld;
    DWORD       dw;
    RECT        rc;
    HBRUSH hbrWindowColour;

    /* Minimum size of bitmap is icon size */
    int ICON_MINX = GetSystemMetrics(SM_CXICON);
    int ICON_MINY = GetSystemMetrics(SM_CYICON);

    /* Get size of a frame or an icon that we'll be drawing */
    MCIWndRect(p, &rc, FALSE);

    SetRect(&rc, 0, 0,
	    max(ICON_MINX, rc.right - rc.left),
	    max(ICON_MINX, rc.bottom - rc.top));

    hdc = GetDC(NULL);
    if (hdc == NULL)
        return NULL;
    hdcMem = CreateCompatibleDC(NULL);
    if (hdcMem == NULL) {
        ReleaseDC(NULL, hdc);
        return NULL;
    }

    /* Big enough to hold text caption too, if necessary */
    hbm = CreateCompatibleBitmap(hdc, rc.right, rc.bottom);
    ReleaseDC(NULL, hdc);
    if (hbm == NULL) {
        DeleteDC(hdcMem);
        return NULL;
    }

    hbmT = SelectObject(hdcMem, hbm);

    hbrWindowColour     = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
    hbrOld = SelectObject(hdcMem, hbrWindowColour);
    PatBlt(hdcMem, 0,0, rc.right, rc.bottom, PATCOPY);
    SelectObject(hdcMem, hbrOld);
    DeleteObject(hbrWindowColour);

    if (p->wDeviceID && p->fCanWindow)
    {
	MCI_ANIM_UPDATE_PARMS mciUpdate;

	mciUpdate.hDC = hdcMem;

	dw = mciSendCommand(p->wDeviceID, MCI_UPDATE,
		    MCI_ANIM_UPDATE_HDC | MCI_WAIT,
		    (DWORD_PTR)(LPVOID)&mciUpdate);
    } else {
	DrawIcon(hdcMem, rc.left, rc.top, p->hicon);
    }

    if (hbmT)
        SelectObject(hdcMem, hbmT);
    DeleteDC(hdcMem);

    return hbm;
}

HPALETTE CopyPalette(HPALETTE hpal)
{
    PLOGPALETTE ppal;
    int         nNumEntries = 0;
    int         i;

    if (!hpal)
        return NULL;

    GetObject(hpal,sizeof(int),(LPVOID)&nNumEntries);

    if (nNumEntries == 0)
        return NULL;

    ppal = (PLOGPALETTE)LocalAlloc(LPTR,sizeof(LOGPALETTE) +
                nNumEntries * sizeof(PALETTEENTRY));

    if (!ppal)
        return NULL;

    ppal->palVersion    = 0x300;
    ppal->palNumEntries = (WORD) nNumEntries;

    GetPaletteEntries(hpal,0,nNumEntries,ppal->palPalEntry);

    for (i=0; i<nNumEntries; i++)
        ppal->palPalEntry[i].peFlags = 0;

    hpal = CreatePalette(ppal);

    LocalFree((HANDLE)ppal);
    return hpal;
}

HANDLE FAR PASCAL PictureFromDib(HANDLE hdib, HPALETTE hpal)
{
    LPMETAFILEPICT      pmfp;
    HANDLE              hmfp;
    HANDLE              hmf;
    HANDLE              hdc;
    LPBITMAPINFOHEADER  lpbi;

    if (!hdib)
        return NULL;

    lpbi = (LPVOID)GlobalLock(hdib);
    if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
        lpbi->biClrUsed = 1 << lpbi->biBitCount;

    hdc = CreateMetaFile(NULL);
    if (!hdc)
        return NULL;

    SetWindowOrgEx(hdc, 0, 0, NULL);
    SetWindowExtEx(hdc, (int)lpbi->biWidth, (int)lpbi->biHeight, NULL);

    if (hpal)
    {
        SelectPalette(hdc,hpal,FALSE);
        RealizePalette(hdc);
    }

    SetStretchBltMode(hdc, COLORONCOLOR);

    StretchDIBits(hdc,
        0,0,(int)lpbi->biWidth, (int)lpbi->biHeight,
        0,0,(int)lpbi->biWidth, (int)lpbi->biHeight,
        (LPBYTE)lpbi + (int)lpbi->biSize + (int)lpbi->biClrUsed * sizeof(RGBQUAD),
        (LPBITMAPINFO)lpbi,
        DIB_RGB_COLORS,
        SRCCOPY);

    if (hpal)
        SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);

    hmf = CloseMetaFile(hdc);

    if (hmfp = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE, sizeof(METAFILEPICT)))
    {
        pmfp = (LPMETAFILEPICT)GlobalLock(hmfp);

        hdc = GetDC(NULL);
#if 1
        pmfp->mm   = MM_ANISOTROPIC;
        pmfp->hMF  = hmf;
        pmfp->xExt = MulDiv((int)lpbi->biWidth ,2540,GetDeviceCaps(hdc, LOGPIXELSX));
        pmfp->yExt = MulDiv((int)lpbi->biHeight,2540,GetDeviceCaps(hdc, LOGPIXELSX));
#else
        pmfp->mm   = MM_TEXT;
        pmfp->hMF  = hmf;
        pmfp->xExt = (int)lpbi->biWidth;
        pmfp->yExt = (int)lpbi->biHeight;
#endif
        ReleaseDC(NULL, hdc);
    }
    else
    {
        DeleteMetaFile(hmf);
    }

    return hmfp;
}

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */

/*
 *  DibFromBitmap()
 *
 *  Will create a global memory block in DIB format that represents the DDB
 *  passed in
 *
 */
HANDLE FAR PASCAL DibFromBitmap(HBITMAP hbm, HPALETTE hpal)
{
    BITMAP               bm;
    BITMAPINFOHEADER     bi;
    BITMAPINFOHEADER FAR *lpbi;
    DWORD                dw;
    HANDLE               hdib;
    HDC                  hdc;
    HPALETTE             hpalT;

    if (!hbm)
        return NULL;

    GetObject(hbm,sizeof(bm),(LPVOID)&bm);

    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = (bm.bmPlanes * bm.bmBitsPixel) > 8 ? 24 : 8;
    bi.biCompression        = BI_RGB;
    bi.biSizeImage          = (DWORD)WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = bi.biBitCount == 8 ? 256 : 0;
    bi.biClrImportant       = 0;

    dw  = bi.biSize + bi.biClrUsed * sizeof(RGBQUAD) + bi.biSizeImage;

    hdib = GlobalAlloc(GHND | GMEM_DDESHARE, dw);

    if (!hdib)
        return NULL;

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hdib);
    *lpbi = bi;

    hdc = CreateCompatibleDC(NULL);

    if (hpal)
    {
        hpalT = SelectPalette(hdc,hpal,FALSE);
        RealizePalette(hdc);
    }

    GetDIBits(hdc, hbm, 0, (UINT)bi.biHeight,
        (LPBYTE)lpbi + (int)lpbi->biSize + (int)lpbi->biClrUsed * sizeof(RGBQUAD),
        (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

    if (hpal)
        SelectPalette(hdc,hpalT,FALSE);

    DeleteDC(hdc);

    return hdib;
}

SZCODE aszNative[]            = TEXT("Native");
SZCODE aszOwnerLink[]         = TEXT("OwnerLink");

// Pretend to be MPlayer copying to the clipboard
STATICFN void NEAR PASCAL MCIWndCopy(PMCIWND p)
{
    UINT	cfNative;
    UINT	cfOwnerLink;
    HBITMAP	hbm;
    HPALETTE	hpal;
    HANDLE	hdib;
    HANDLE	hmfp;

    cfNative    = RegisterClipboardFormat(aszNative);
    cfOwnerLink = RegisterClipboardFormat(aszOwnerLink);

    if (p->wDeviceID) {
	OpenClipboard(p->hwnd);
	
        EmptyClipboard();

        SetClipboardData(cfNative, GetMPlayerData(p));
        SetClipboardData(cfOwnerLink, GetMPlayerData(p));

	hbm  = BitmapMCI(p);
	hpal = MCIWndGetPalette(p->hwnd);
	hpal = CopyPalette(hpal);

	if (hbm) {
	    hdib = DibFromBitmap(hbm, hpal);

	    hmfp = PictureFromDib(hdib, hpal);

	    if (hmfp)
		SetClipboardData(CF_METAFILEPICT, hmfp);

	    if (hdib)
		SetClipboardData(CF_DIB, hdib);

	    DeleteObject(hbm);
	}

	if (hpal)
	    SetClipboardData(CF_PALETTE, hpal);

        CloseClipboard();
    }
}

/*****************************************************************************
 ****************************************************************************/

#ifdef DEBUG

STATICFN void cdecl dprintf(PSTR szFormat, ...)
{
    char ach[128];
    va_list va;

    static BOOL fDebug = -1;

    if (fDebug == -1) {
        fDebug = mmGetProfileIntA(szDebug, MODNAME, FALSE);
    }

    if (!fDebug)
        return;

    lstrcpyA(ach, MODNAME ": ");
    va_start(va,szFormat);
    wvsprintfA(ach+lstrlenA(ach),szFormat, va);
    va_end(va);
    lstrcatA(ach, "\r\n");

    OutputDebugStringA(ach);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd\mciwndi.h ===
/*----------------------------------------------------------------------------*\
 *
 *  MCIWnd
 *
 *    MCIWnd window class *internal* header file.
 *
 *----------------------------------------------------------------------------*/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <win32.h>
#include <digitalv.h>
#include <commdlg.h>
#include <shellapi.h>
#include <vfw.h>

#define NOUPDOWN
#define NOSTATUSBAR
#define NOMENUHELP
#define NOBTNLIST
#define NODRAGLIST
#define NOPROGRESS
#define NOHOTKEY

#include <commctrl.h>

#include "strings.h"

/**************************************************************************
***************************************************************************/

#define GetWS(hwnd)     GetWindowLong(hwnd, GWL_STYLE)
#define PutWS(hwnd, f)  SetWindowLong(hwnd, GWL_STYLE, f)
#define TestWS(hwnd,f)  (GetWS(hwnd) & f)
#define SetWS(hwnd, f)  ((PutWS(hwnd, GetWS(hwnd) | f) & (f)) != (f))
#define ClrWS(hwnd, f)  ((PutWS(hwnd, GetWS(hwnd) & ~(f)) & (f)) != 0)

/******************************************************************************
 *****************************************************************************/

#ifdef DEBUG
    #define MODNAME "MCIWnd"
    static void cdecl dprintf(PSTR sz, ...);
    #define DPF     dprintf
#else
    #define DPF     ; / ## /
#endif

#define ABS(x)  ((int)(x) > 0) ? (x) : (-(x))

#if !defined NUMELMS
    #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

// the place we load internationalizable strings into
static TCHAR szString[128];
#define LoadSz(ID) (LoadString(hInst, ID, szString, NUMELMS(szString)), szString)

#if defined(UNICODE)
// unicode conversions - without using the C-runtime for which we would
// need to set up the locale

int Iwcstombs(LPSTR lpstr, LPCWSTR lpwstr, int len);
int Imbstowcs(LPWSTR lpwstr, LPCSTR lpstr, int len);

#endif

/******************************************************************************
 *****************************************************************************/

// !!! Ack!  A global in a library!  But the Common Control code needs
// !!! to know the instance that registered the class.  I think.
HINSTANCE hInst;

TCHAR aszMCIWndClassName[] = MCIWND_WINDOW_CLASS;

WNDPROC fnTrackbarWndProc;

/******************************************************************************
 *****************************************************************************/

// icky constants
#define TIMER1  	42
#define TIMER2  	43
#define ACTIVE_TIMER	500
#define INACTIVE_TIMER	2000

#define ID_TOOLBAR	747
#define TB_HEIGHT       26        	// toolbar windows are this high
#define STANDARD_WIDTH  300		// width of non-windowed toolbar
#define SMALLEST_WIDTH  60		// smallest width allowed

#define IDM_MCIZOOM	 11000
#define IDM_MCIVOLUME	 12000
#define VOLUME_MAX	 200
#define IDM_MCISPEED	 13000
#define SPEED_MAX    	 200

#define IDM_MCINEW	103
#define IDM_MCIOPEN	104
#define IDM_MCICLOSE	105
#define IDM_MCIREWIND   106
#define IDM_MENU        107	// menu button and menu id
#define IDM_MCIEJECT    108	// eject button id
#define TOOLBAR_END     109	// last item in toolbar
#define IDM_MCICONFIG   110     // bring up a configure box
#define IDM_MCICOMMAND	111
#define IDM_COPY	112

/******************************************************************************
 *****************************************************************************/

typedef struct {
    HWND    hwnd;
    HWND    hwndOwner;
    UINT    alias;
    UINT    wDeviceID;
    UINT    wDeviceType;
    MCIERROR dwError;
    DWORD   dwStyle;
    BOOL    fHasTracks;
    int	    iNumTracks;
    int	    iFirstTrack;
    LONG    *pTrackStart;
    BOOL    fRepeat;
    BOOL    fCanWindow;
    BOOL    fHasPalette;
    BOOL    fCanRecord;
    BOOL    fCanPlay;
    BOOL    fCanSave;
    BOOL    fCanEject;
    BOOL    fCanConfig;
    BOOL    fAllowCopy;
    BOOL    fUsesFiles;
    BOOL    fVideo;
    BOOL    fAudio;
    BOOL    fMdiWindow;
    BOOL    fScrolling;
    BOOL    fTracking;
  //BOOL    fSeekExact;
    BOOL    fVolume;
    UINT    wMaxVol;
    BOOL    fSpeed;
    BOOL    fPlayAfterSeek;
    BOOL    fActive;            // Is this window active right now?
    BOOL    fMediaValid;        // have dwMediaStart and dwMediaLen been set?
    RECT    rcNormal;
    HMENU   hmenu;
    HMENU   hmenuVolume;
    HMENU   hmenuSpeed;
    HFONT   hfont;
#ifdef DAYTONA
//    HBITMAP hbmToolbar;		// commctrl needs an HBITMAP
#endif
    HWND    hwndToolbar;
    HWND    hwndTrackbar;
    DWORD   dwMediaStart;
    DWORD   dwMediaLen;
    UINT_PTR wTimer;
    DWORD   dwMode;
    DWORD   dwPos;
    UINT    iZoom;
    UINT    iActiveTimerRate;
    UINT    iInactiveTimerRate;
    TCHAR    achFileName[128]; // to store open filename
    TCHAR    achReturn[128];   // to store result of the last SendString
    OPENFILENAME ofn;   // Remember current extension, etc. for opening files
    UINT    uiHack;	// For OwnerDraw hack
    HMENU   hmenuHack;	// For OwnerDraw hack
    HBRUSH  hbrDither;	// For OwnerDraw
    HICON   hicon;
    int     cOnSizeReentered;
} MCIWND, NEAR * PMCIWND;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd\mciwnd.h ===
// begin_vfw32
/*----------------------------------------------------------------------------*\
 *
 *  MCIWnd
 *
 *    MCIWnd window class header file.
 *
 *    the MCIWnd window class is a window class for controling MCI devices
 *    MCI devices include, wave files, midi files, AVI Video, cd audio,
 *    vcr, video disc, and others..
 *
 *    to learn more about MCI and mci command sets see the
 *    "Microsoft Multimedia Programmers's guide" in the Win31 SDK
 *
 *    the easiest use of the MCIWnd class is like so:
 *
 *          hwnd = MCIWndCreate(hwndParent, hInstance, 0, "chimes.wav");
 *          ...
 *          MCIWndPlay(hwnd);
 *          MCIWndStop(hwnd);
 *          MCIWndPause(hwnd);
 *          ....
 *          MCIWndDestroy(hwnd);
 *
 *    this will create a window with a play/pause, stop and a playbar
 *    and start the wave file playing.
 *
 *    mciwnd.h defines macros for all the most common MCI commands, but
 *    any string command can be used if needed.
 *
 *    Note: unlike the mciSendString() API, no alias or file name needs
 *    to be specifed, since the device to use is implied by the window handle.
 *
 *          MCIWndSendString(hwnd, "setaudio stream to 2");
 *
 *    (C) Copyright Microsoft Corp. 1991-1995.  All rights reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files.
 *
 *    If you did not get this from Microsoft Sources, then it may not be the
 *    most current version.  This sample code in particular will be updated
 *    and include more documentation.
 *
 *    Sources are:
 *       CompuServe: WINSDK forum, MDK section.
 *       Anonymous FTP from ftp.uu.net vendor\microsoft\multimedia
 *
 * WIN32:
 *
 *    MCIWnd supports both ansi and unicode interfaces. For any message that
 *    takes or returns a text string, two versions of the message are defined,
 *    appended with A or W for Ansi or Wide Char. The message or api itself
 *    is defined to be one or other of these depending on whether you have
 *    UNICODE defined in your application.
 *    Thus for the api MCIWndCreate, there are in fact two apis,
 *    MCIWndCreateA and MCIWndCreateW. If you call MCIWndCreate, this will be
 *    re-routed to MCIWndCreateA unless UNICODE is defined when building your
 *    application. In any one application, you can mix calls to the
 *    Ansi and Unicode entrypoints.
 *
 *    If you use SendMessage instead of the macros below such as MCIWndOpen(),
 *    you will see that the messages have changed for WIN32, to support Ansi
 *    and Unicode entrypoints. In particular, MCI_OPEN has been replaced by
 *    MCWNDM_OPENA, or MCIWNDM_OPENW (MCIWNDM_OPEN is defined to be one or
 *    other of these).
 *
 *    Also, note that the WIN32 implementation of MCIWnd uses UNICODE
 *    so all apis and messages supporting ANSI strings do so by mapping them
 *    UNICODE strings and then calling the corresponding UNICODE entrypoint.
 *
 *----------------------------------------------------------------------------*/

// end_vfw32
#ifndef INC_MCIWND
#define INC_MCIWND

#if !defined(_WIN32) && !defined(LPTSTR)
    #define LPTSTR LPSTR
#endif

// begin_vfw32
#ifdef __cplusplus
// MFC Redefines SendMessage, so make sure we get the global one....
#define MCIWndSM ::SendMessage  /* SendMessage in C++*/
#else
#define MCIWndSM SendMessage    /* SendMessage in C */
#endif  /* __cplusplus */
// end_vfw32

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _WIN32
// begin_vfw32
#define MCIWND_WINDOW_CLASS TEXT("MCIWndClass")
// end_vfw32
#else
#define MCIWND_WINDOW_CLASS "MCIWndClass"
#endif

#ifdef _WIN32
// begin_vfw32
HWND 
VFWAPIV 
MCIWndCreateA(
    IN HWND hwndParent, 
    IN HINSTANCE hInstance,
    IN DWORD dwStyle,
    IN LPCSTR szFile
    );

HWND 
VFWAPIV 
MCIWndCreateW(
    IN HWND hwndParent, 
    IN HINSTANCE hInstance,
    IN DWORD dwStyle,
    IN LPCWSTR szFile
    );

#ifdef UNICODE
#define MCIWndCreate    MCIWndCreateW
#else
#define MCIWndCreate    MCIWndCreateA
#endif
BOOL VFWAPIV MCIWndRegisterClass(void);
// end_vfw32
#else
HWND FAR _cdecl _loadds MCIWndCreate(HWND hwndParent, HINSTANCE hInstance,
                      DWORD dwStyle,LPCSTR szFile);
BOOL FAR _cdecl _loadds MCIWndRegisterClass(void);
#endif
// begin_vfw32

// Flags for the MCIWndOpen command
#define MCIWNDOPENF_NEW	            0x0001  // open a new file

// window styles
#define MCIWNDF_NOAUTOSIZEWINDOW    0x0001  // when movie size changes
#define MCIWNDF_NOPLAYBAR           0x0002  // no toolbar
#define MCIWNDF_NOAUTOSIZEMOVIE     0x0004  // when window size changes
#define MCIWNDF_NOMENU              0x0008  // no popup menu from RBUTTONDOWN
#define MCIWNDF_SHOWNAME            0x0010  // show name in caption
#define MCIWNDF_SHOWPOS             0x0020  // show position in caption
#define MCIWNDF_SHOWMODE            0x0040  // show mode in caption
#define MCIWNDF_SHOWALL             0x0070  // show all

#define MCIWNDF_NOTIFYMODE         0x0100  // tell parent of mode change
#define MCIWNDF_NOTIFYPOS          0x0200  // tell parent of pos change
#define MCIWNDF_NOTIFYSIZE         0x0400  // tell parent of size change
#define MCIWNDF_NOTIFYERROR        0x1000  // tell parent of an error
#define MCIWNDF_NOTIFYALL          0x1F00  // tell all

#define MCIWNDF_NOTIFYANSI	   0x0080

// end_vfw32
#ifdef _WIN32
// begin_vfw32

// The MEDIA notification includes a text string.
// To receive notifications in ANSI instead of unicode set the
// MCIWNDF_NOTIFYANSI style bit. The macro below includes this bit
// by default unless you define UNICODE in your application.

#define MCIWNDF_NOTIFYMEDIAA       0x0880  // tell parent of media change
#define MCIWNDF_NOTIFYMEDIAW       0x0800  // tell parent of media change

#ifdef UNICODE
#define MCIWNDF_NOTIFYMEDIA         MCIWNDF_NOTIFYMEDIAW
#else
#define MCIWNDF_NOTIFYMEDIA         MCIWNDF_NOTIFYMEDIAA
#endif

// end_vfw32
#else

#define MCIWNDF_NOTIFYMEDIA        0x0800  // tell parent of media change

#endif
// begin_vfw32


#define MCIWNDF_RECORD              0x2000  // Give a record button
#define MCIWNDF_NOERRORDLG          0x4000  // Show Error Dlgs for MCI cmds?
#define MCIWNDF_NOOPEN		    0x8000  // Don't allow user to open things




// can macros

#define MCIWndCanPlay(hwnd)         (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_PLAY,0,0)
#define MCIWndCanRecord(hwnd)       (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_RECORD,0,0)
#define MCIWndCanSave(hwnd)         (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_SAVE,0,0)
#define MCIWndCanWindow(hwnd)       (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_WINDOW,0,0)
#define MCIWndCanEject(hwnd)        (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_EJECT,0,0)
#define MCIWndCanConfig(hwnd)       (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_CONFIG,0,0)
#define MCIWndPaletteKick(hwnd)     (BOOL)MCIWndSM(hwnd,MCIWNDM_PALETTEKICK,0,0)

#define MCIWndSave(hwnd, szFile)    (LONG)MCIWndSM(hwnd, MCI_SAVE, 0, (LPARAM)(LPVOID)(szFile))
#define MCIWndSaveDialog(hwnd)      MCIWndSave(hwnd, -1)

// if you dont give a device it will use the current device....
#define MCIWndNew(hwnd, lp)         (LONG)MCIWndSM(hwnd, MCIWNDM_NEW, 0, (LPARAM)(LPVOID)(lp))

#define MCIWndRecord(hwnd)          (LONG)MCIWndSM(hwnd, MCI_RECORD, 0, 0)
// end_vfw32
#ifdef _WIN32
#define MCIWndOpenA(hwnd, sz, f)     (LONG)MCIWndSM(hwnd, MCIWNDM_OPENA, (WPARAM)(UINT)(f),(LPARAM)(LPVOID)(sz))
// begin_vfw32
#define MCIWndOpen(hwnd, sz, f)     (LONG)MCIWndSM(hwnd, MCIWNDM_OPEN, (WPARAM)(UINT)(f),(LPARAM)(LPVOID)(sz))
// end_vfw32
#else
#define MCIWndOpen(hwnd, sz, f)     (LONG)MCIWndSM(hwnd, MCI_OPEN, (WPARAM)(UINT)(f),(LPARAM)(LPVOID)(sz))
#endif
// begin_vfw32
#define MCIWndOpenDialog(hwnd)      MCIWndOpen(hwnd, -1, 0)
#define MCIWndClose(hwnd)           (LONG)MCIWndSM(hwnd, MCI_CLOSE, 0, 0)
#define MCIWndPlay(hwnd)            (LONG)MCIWndSM(hwnd, MCI_PLAY, 0, 0)
#define MCIWndStop(hwnd)            (LONG)MCIWndSM(hwnd, MCI_STOP, 0, 0)
#define MCIWndPause(hwnd)           (LONG)MCIWndSM(hwnd, MCI_PAUSE, 0, 0)
#define MCIWndResume(hwnd)          (LONG)MCIWndSM(hwnd, MCI_RESUME, 0, 0)
#define MCIWndSeek(hwnd, lPos)      (LONG)MCIWndSM(hwnd, MCI_SEEK, 0, (LPARAM)(LONG)(lPos))
#define MCIWndEject(hwnd)           (LONG)MCIWndSM(hwnd, MCIWNDM_EJECT, 0, 0)

#define MCIWndHome(hwnd)            MCIWndSeek(hwnd, MCIWND_START)
#define MCIWndEnd(hwnd)             MCIWndSeek(hwnd, MCIWND_END)

#define MCIWndGetSource(hwnd, prc)  (LONG)MCIWndSM(hwnd, MCIWNDM_GET_SOURCE, 0, (LPARAM)(LPRECT)(prc))
#define MCIWndPutSource(hwnd, prc)  (LONG)MCIWndSM(hwnd, MCIWNDM_PUT_SOURCE, 0, (LPARAM)(LPRECT)(prc))

#define MCIWndGetDest(hwnd, prc)    (LONG)MCIWndSM(hwnd, MCIWNDM_GET_DEST, 0, (LPARAM)(LPRECT)(prc))
#define MCIWndPutDest(hwnd, prc)    (LONG)MCIWndSM(hwnd, MCIWNDM_PUT_DEST, 0, (LPARAM)(LPRECT)(prc))

#define MCIWndPlayReverse(hwnd)     (LONG)MCIWndSM(hwnd, MCIWNDM_PLAYREVERSE, 0, 0)
#define MCIWndPlayFrom(hwnd, lPos)  (LONG)MCIWndSM(hwnd, MCIWNDM_PLAYFROM, 0, (LPARAM)(LONG)(lPos))
#define MCIWndPlayTo(hwnd, lPos)    (LONG)MCIWndSM(hwnd, MCIWNDM_PLAYTO,   0, (LPARAM)(LONG)(lPos))
#define MCIWndPlayFromTo(hwnd, lStart, lEnd) (MCIWndSeek(hwnd, lStart), MCIWndPlayTo(hwnd, lEnd))

#define MCIWndGetDeviceID(hwnd)     (UINT)MCIWndSM(hwnd, MCIWNDM_GETDEVICEID, 0, 0)
#define MCIWndGetAlias(hwnd)        (UINT)MCIWndSM(hwnd, MCIWNDM_GETALIAS, 0, 0)
#define MCIWndGetMode(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETMODE, (WPARAM)(UINT)(len), (LPARAM)(LPTSTR)(lp))
#define MCIWndGetPosition(hwnd)     (LONG)MCIWndSM(hwnd, MCIWNDM_GETPOSITION, 0, 0)
#define MCIWndGetPositionString(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETPOSITION, (WPARAM)(UINT)(len), (LPARAM)(LPTSTR)(lp))
#define MCIWndGetStart(hwnd)        (LONG)MCIWndSM(hwnd, MCIWNDM_GETSTART, 0, 0)
#define MCIWndGetLength(hwnd)       (LONG)MCIWndSM(hwnd, MCIWNDM_GETLENGTH, 0, 0)
#define MCIWndGetEnd(hwnd)          (LONG)MCIWndSM(hwnd, MCIWNDM_GETEND, 0, 0)

#define MCIWndStep(hwnd, n)         (LONG)MCIWndSM(hwnd, MCI_STEP, 0,(LPARAM)(long)(n))

#define MCIWndDestroy(hwnd)         (VOID)MCIWndSM(hwnd, WM_CLOSE, 0, 0)
#define MCIWndSetZoom(hwnd,iZoom)   (VOID)MCIWndSM(hwnd, MCIWNDM_SETZOOM, 0, (LPARAM)(UINT)(iZoom))
#define MCIWndGetZoom(hwnd)         (UINT)MCIWndSM(hwnd, MCIWNDM_GETZOOM, 0, 0)
#define MCIWndSetVolume(hwnd,iVol)  (LONG)MCIWndSM(hwnd, MCIWNDM_SETVOLUME, 0, (LPARAM)(UINT)(iVol))
#define MCIWndGetVolume(hwnd)       (LONG)MCIWndSM(hwnd, MCIWNDM_GETVOLUME, 0, 0)
#define MCIWndSetSpeed(hwnd,iSpeed) (LONG)MCIWndSM(hwnd, MCIWNDM_SETSPEED, 0, (LPARAM)(UINT)(iSpeed))
#define MCIWndGetSpeed(hwnd)        (LONG)MCIWndSM(hwnd, MCIWNDM_GETSPEED, 0, 0)
#define MCIWndSetTimeFormat(hwnd, lp) (LONG)MCIWndSM(hwnd, MCIWNDM_SETTIMEFORMAT, 0, (LPARAM)(LPTSTR)(lp))
#define MCIWndGetTimeFormat(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETTIMEFORMAT, (WPARAM)(UINT)(len), (LPARAM)(LPTSTR)(lp))
#define MCIWndValidateMedia(hwnd)   (VOID)MCIWndSM(hwnd, MCIWNDM_VALIDATEMEDIA, 0, 0)

#define MCIWndSetRepeat(hwnd,f)     (void)MCIWndSM(hwnd, MCIWNDM_SETREPEAT, 0, (LPARAM)(BOOL)(f))
#define MCIWndGetRepeat(hwnd)       (BOOL)MCIWndSM(hwnd, MCIWNDM_GETREPEAT, 0, 0)

// end_vfw32
#ifdef _WIN32
// begin_vfw32
#define MCIWndUseFrames(hwnd)       MCIWndSetTimeFormat(hwnd, TEXT("frames"))
#define MCIWndUseTime(hwnd)         MCIWndSetTimeFormat(hwnd, TEXT("ms"))
// end_vfw32
#else
#define MCIWndUseFrames(hwnd)       MCIWndSetTimeFormat(hwnd, "frames")
#define MCIWndUseTime(hwnd)         MCIWndSetTimeFormat(hwnd, "ms")
#endif
// begin_vfw32

#define MCIWndSetActiveTimer(hwnd, active)				\
	(VOID)MCIWndSM(hwnd, MCIWNDM_SETACTIVETIMER,			\
	(WPARAM)(UINT)(active), 0L)
#define MCIWndSetInactiveTimer(hwnd, inactive)				\
	(VOID)MCIWndSM(hwnd, MCIWNDM_SETINACTIVETIMER,		\
	(WPARAM)(UINT)(inactive), 0L)
#define MCIWndSetTimers(hwnd, active, inactive)				      \
	    (VOID)MCIWndSM(hwnd, MCIWNDM_SETTIMERS,(WPARAM)(UINT)(active), \
	    (LPARAM)(UINT)(inactive))
#define MCIWndGetActiveTimer(hwnd)					\
	(UINT)MCIWndSM(hwnd, MCIWNDM_GETACTIVETIMER,	0, 0L);
#define MCIWndGetInactiveTimer(hwnd)					\
	(UINT)MCIWndSM(hwnd, MCIWNDM_GETINACTIVETIMER, 0, 0L);

#define MCIWndRealize(hwnd, fBkgnd) (LONG)MCIWndSM(hwnd, MCIWNDM_REALIZE,(WPARAM)(BOOL)(fBkgnd),0)

#define MCIWndSendString(hwnd, sz)  (LONG)MCIWndSM(hwnd, MCIWNDM_SENDSTRING, 0, (LPARAM)(LPTSTR)(sz))
#define MCIWndReturnString(hwnd, lp, len)  (LONG)MCIWndSM(hwnd, MCIWNDM_RETURNSTRING, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))
#define MCIWndGetError(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETERROR, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))

//#define MCIWndActivate(hwnd, f)     (void)MCIWndSM(hwnd, WM_ACTIVATE, (WPARAM)(BOOL)(f), 0)

#define MCIWndGetPalette(hwnd)      (HPALETTE)MCIWndSM(hwnd, MCIWNDM_GETPALETTE, 0, 0)
#define MCIWndSetPalette(hwnd, hpal) (LONG)MCIWndSM(hwnd, MCIWNDM_SETPALETTE, (WPARAM)(HPALETTE)(hpal), 0)

#define MCIWndGetFileName(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETFILENAME, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))
#define MCIWndGetDevice(hwnd, lp, len)   (LONG)MCIWndSM(hwnd, MCIWNDM_GETDEVICE, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))

#define MCIWndGetStyles(hwnd) (UINT)MCIWndSM(hwnd, MCIWNDM_GETSTYLES, 0, 0L)
#define MCIWndChangeStyles(hwnd, mask, value) (LONG)MCIWndSM(hwnd, MCIWNDM_CHANGESTYLES, (WPARAM)(UINT)(mask), (LPARAM)(LONG)(value))

#define MCIWndOpenInterface(hwnd, pUnk)  (LONG)MCIWndSM(hwnd, MCIWNDM_OPENINTERFACE, 0, (LPARAM)(LPUNKNOWN)(pUnk))

#define MCIWndSetOwner(hwnd, hwndP)  (LONG)MCIWndSM(hwnd, MCIWNDM_SETOWNER, (WPARAM)(hwndP), 0)


// Messages an app will send to MCIWND

// all the text-related messages are defined out of order above (they need
// to be defined before the MCIWndOpen() macros

#define MCIWNDM_GETDEVICEID	(WM_USER + 100)
#define MCIWNDM_GETSTART	(WM_USER + 103)
#define MCIWNDM_GETLENGTH	(WM_USER + 104)
#define MCIWNDM_GETEND		(WM_USER + 105)
#define MCIWNDM_EJECT		(WM_USER + 107)
#define MCIWNDM_SETZOOM		(WM_USER + 108)
#define MCIWNDM_GETZOOM         (WM_USER + 109)
#define MCIWNDM_SETVOLUME	(WM_USER + 110)
#define MCIWNDM_GETVOLUME	(WM_USER + 111)
#define MCIWNDM_SETSPEED	(WM_USER + 112)
#define MCIWNDM_GETSPEED	(WM_USER + 113)
#define MCIWNDM_SETREPEAT	(WM_USER + 114)
#define MCIWNDM_GETREPEAT	(WM_USER + 115)
#define MCIWNDM_REALIZE         (WM_USER + 118)
#define MCIWNDM_VALIDATEMEDIA   (WM_USER + 121)
#define MCIWNDM_PLAYFROM	(WM_USER + 122)
#define MCIWNDM_PLAYTO          (WM_USER + 123)
#define MCIWNDM_GETPALETTE      (WM_USER + 126)
#define MCIWNDM_SETPALETTE      (WM_USER + 127)
#define MCIWNDM_SETTIMERS	(WM_USER + 129)
#define MCIWNDM_SETACTIVETIMER	(WM_USER + 130)
#define MCIWNDM_SETINACTIVETIMER (WM_USER + 131)
#define MCIWNDM_GETACTIVETIMER	(WM_USER + 132)
#define MCIWNDM_GETINACTIVETIMER (WM_USER + 133)
#define MCIWNDM_CHANGESTYLES	(WM_USER + 135)
#define MCIWNDM_GETSTYLES	(WM_USER + 136)
#define MCIWNDM_GETALIAS	(WM_USER + 137)
#define MCIWNDM_PLAYREVERSE	(WM_USER + 139)
#define MCIWNDM_GET_SOURCE      (WM_USER + 140)
#define MCIWNDM_PUT_SOURCE      (WM_USER + 141)
#define MCIWNDM_GET_DEST        (WM_USER + 142)
#define MCIWNDM_PUT_DEST        (WM_USER + 143)
#define MCIWNDM_CAN_PLAY        (WM_USER + 144)
#define MCIWNDM_CAN_WINDOW      (WM_USER + 145)
#define MCIWNDM_CAN_RECORD      (WM_USER + 146)
#define MCIWNDM_CAN_SAVE        (WM_USER + 147)
#define MCIWNDM_CAN_EJECT       (WM_USER + 148)
#define MCIWNDM_CAN_CONFIG      (WM_USER + 149)
#define MCIWNDM_PALETTEKICK     (WM_USER + 150)
#define MCIWNDM_OPENINTERFACE	(WM_USER + 151)
#define MCIWNDM_SETOWNER	(WM_USER + 152)


// end_vfw32
#ifdef _WIN32
// begin_vfw32

//define both A and W messages
#define MCIWNDM_SENDSTRINGA	(WM_USER + 101)
#define MCIWNDM_GETPOSITIONA	(WM_USER + 102)
#define MCIWNDM_GETMODEA	(WM_USER + 106)
#define MCIWNDM_SETTIMEFORMATA  (WM_USER + 119)
#define MCIWNDM_GETTIMEFORMATA  (WM_USER + 120)
#define MCIWNDM_GETFILENAMEA    (WM_USER + 124)
#define MCIWNDM_GETDEVICEA      (WM_USER + 125)
#define MCIWNDM_GETERRORA       (WM_USER + 128)
#define MCIWNDM_NEWA		(WM_USER + 134)
#define MCIWNDM_RETURNSTRINGA	(WM_USER + 138)
#define MCIWNDM_OPENA		(WM_USER + 153)

#define MCIWNDM_SENDSTRINGW	(WM_USER + 201)
#define MCIWNDM_GETPOSITIONW	(WM_USER + 202)
#define MCIWNDM_GETMODEW	(WM_USER + 206)
#define MCIWNDM_SETTIMEFORMATW  (WM_USER + 219)
#define MCIWNDM_GETTIMEFORMATW  (WM_USER + 220)
#define MCIWNDM_GETFILENAMEW    (WM_USER + 224)
#define MCIWNDM_GETDEVICEW      (WM_USER + 225)
#define MCIWNDM_GETERRORW       (WM_USER + 228)
#define MCIWNDM_NEWW		(WM_USER + 234)
#define MCIWNDM_RETURNSTRINGW	(WM_USER + 238)
#define MCIWNDM_OPENW		(WM_USER + 252)

// map defaults to A or W depending on app's UNICODE setting
#ifdef UNICODE
#define MCIWNDM_SENDSTRING      MCIWNDM_SENDSTRINGW
#define MCIWNDM_GETPOSITION     MCIWNDM_GETPOSITIONW
#define MCIWNDM_GETMODE         MCIWNDM_GETMODEW
#define MCIWNDM_SETTIMEFORMAT   MCIWNDM_SETTIMEFORMATW
#define MCIWNDM_GETTIMEFORMAT   MCIWNDM_GETTIMEFORMATW
#define MCIWNDM_GETFILENAME     MCIWNDM_GETFILENAMEW
#define MCIWNDM_GETDEVICE       MCIWNDM_GETDEVICEW
#define MCIWNDM_GETERROR        MCIWNDM_GETERRORW
#define MCIWNDM_NEW             MCIWNDM_NEWW
#define MCIWNDM_RETURNSTRING    MCIWNDM_RETURNSTRINGW
#define MCIWNDM_OPEN		MCIWNDM_OPENW
#else
#define MCIWNDM_SENDSTRING      MCIWNDM_SENDSTRINGA
#define MCIWNDM_GETPOSITION     MCIWNDM_GETPOSITIONA
#define MCIWNDM_GETMODE         MCIWNDM_GETMODEA
#define MCIWNDM_SETTIMEFORMAT   MCIWNDM_SETTIMEFORMATA
#define MCIWNDM_GETTIMEFORMAT   MCIWNDM_GETTIMEFORMATA
#define MCIWNDM_GETFILENAME     MCIWNDM_GETFILENAMEA
#define MCIWNDM_GETDEVICE       MCIWNDM_GETDEVICEA
#define MCIWNDM_GETERROR        MCIWNDM_GETERRORA
#define MCIWNDM_NEW             MCIWNDM_NEWA
#define MCIWNDM_RETURNSTRING    MCIWNDM_RETURNSTRINGA
#define MCIWNDM_OPEN		MCIWNDM_OPENA
#endif

// note that the source text for MCIWND will thus contain
// support for eg MCIWNDM_SENDSTRING (both the 16-bit entrypoint and
// in win32 mapped to MCIWNDM_SENDSTRINGW), and MCIWNDM_SENDSTRINGA (the
// win32 ansi thunk).

// end_vfw32
#else

// 16-bit Windows defines

#define MCIWNDM_SENDSTRING	(WM_USER + 101)
#define MCIWNDM_GETPOSITION	(WM_USER + 102)
#define MCIWNDM_GETMODE		(WM_USER + 106)
#define MCIWNDM_SETTIMEFORMAT   (WM_USER + 119)
#define MCIWNDM_GETTIMEFORMAT   (WM_USER + 120)
#define MCIWNDM_GETFILENAME     (WM_USER + 124)
#define MCIWNDM_GETDEVICE       (WM_USER + 125)
#define MCIWNDM_GETERROR        (WM_USER + 128)
#define MCIWNDM_NEW		(WM_USER + 134)
#define MCIWNDM_RETURNSTRING	(WM_USER + 138)

#endif
// begin_vfw32






// Messages MCIWND will send to an app
// !!! Use less messages and use a code instead to indicate the type of notify? /* ;Internal */
#define MCIWNDM_NOTIFYMODE      (WM_USER + 200)  // wp = hwnd, lp = mode
#define MCIWNDM_NOTIFYPOS	(WM_USER + 201)  // wp = hwnd, lp = pos
#define MCIWNDM_NOTIFYSIZE	(WM_USER + 202)  // wp = hwnd
#define MCIWNDM_NOTIFYMEDIA     (WM_USER + 203)  // wp = hwnd, lp = fn
#define MCIWNDM_NOTIFYERROR     (WM_USER + 205)  // wp = hwnd, lp = error

// special seek values for START and END
#define MCIWND_START                -1
#define MCIWND_END                  -2

#ifndef MCI_PLAY
    /* MCI command message identifiers */
#ifndef _WIN32
    // win32 apps send MCIWNDM_OPEN
    #define MCI_OPEN                        0x0803
#endif
    #define MCI_CLOSE                       0x0804
    #define MCI_PLAY                        0x0806
    #define MCI_SEEK                        0x0807
    #define MCI_STOP                        0x0808
    #define MCI_PAUSE                       0x0809
    #define MCI_STEP                        0x080E
    #define MCI_RECORD                      0x080F
    #define MCI_SAVE                        0x0813
    #define MCI_CUT                         0x0851
    #define MCI_COPY                        0x0852
    #define MCI_PASTE                       0x0853
    #define MCI_RESUME                      0x0855
    #define MCI_DELETE                      0x0856
#endif

#ifndef MCI_MODE_NOT_READY
    /* return values for 'status mode' command */
    #define MCI_MODE_NOT_READY      (524)
    #define MCI_MODE_STOP           (525)
    #define MCI_MODE_PLAY           (526)
    #define MCI_MODE_RECORD         (527)
    #define MCI_MODE_SEEK           (528)
    #define MCI_MODE_PAUSE          (529)
    #define MCI_MODE_OPEN           (530)
#endif

// end_vfw32
#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd\preview.h ===
/****************************************************************************
 *
 *  MODULE  : PREVIEW.H
 *
 ****************************************************************************/

#if !defined INC_PREVIEW
#define INC_PREVIEW

// begin_vfw32
#ifdef OFN_READONLY
// end_vfw32

#ifdef WIN32

#ifndef VFWAPI
    #define VFWAPI  WINAPI
    #define VFWAPIV WINAPIV
#endif

// begin_vfw32

    BOOL 
    VFWAPI 
    GetOpenFileNamePreviewA(
        IN OUT LPOPENFILENAMEA lpofn
        );

    BOOL 
    VFWAPI 
    GetSaveFileNamePreviewA(
        IN OUT LPOPENFILENAMEA lpofn
        );

    BOOL 
    VFWAPI 
    GetOpenFileNamePreviewW(
        IN OUT LPOPENFILENAMEW lpofn
        );

    BOOL 
    VFWAPI 
    GetSaveFileNamePreviewW(
        IN OUT LPOPENFILENAMEW lpofn
        );

    #ifdef UNICODE
        #define GetOpenFileNamePreview          GetOpenFileNamePreviewW
        #define GetSaveFileNamePreview          GetSaveFileNamePreviewW
    #else
        #define GetOpenFileNamePreview          GetOpenFileNamePreviewA
        #define GetSaveFileNamePreview          GetSaveFileNamePreviewA
    #endif

// end_vfw32

#else

    BOOL  FAR PASCAL _loadds GetOpenFileNamePreview(LPOPENFILENAME lpofn);
    BOOL  FAR PASCAL _loadds GetSaveFileNamePreview(LPOPENFILENAME lpofn);

#endif // WIN32
// begin_vfw32
#endif // OFN_READONLY
// end_vfw32
#endif // INC_PREVIEW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd\preview.c ===
/****************************************************************************
 *
 *  MODULE  : PREVIEW.C
 *
 ****************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include <commdlg.h>
#include <win32.h>

#include <vfw.h>

#define SQUAWKNUMZ(num) #num
#define SQUAWKNUM(num) SQUAWKNUMZ(num)
#define SQUAWK __FILE__ "(" SQUAWKNUM(__LINE__) ") :squawk: "

typedef struct {
    BOOL        bUnicode;
    HWND        hwnd;               // common dialog handle.
    LPOPENFILENAME pofn;

    LPARAM      lCustData;          // hold old value
    DWORD       Flags;
    LPOFNHOOKPROC lpfnHook;

    RECT        rcPreview;
    RECT        rcImage;
    RECT        rcText;
    HWND        hwndMci;
    HFONT       hfont;
    HPALETTE    hpal;
    HANDLE      hdib;
    TCHAR       Title[128];

}   PreviewStuff, FAR *PPreviewStuff;

#define PREVIEW_PROP    TEXT("PreviewStuff")

#ifdef _WIN32
    #define SetPreviewStuff(hwnd, p) SetProp(hwnd,PREVIEW_PROP,(LPVOID)(p))
    #define GetPreviewStuff(hwnd) (PPreviewStuff)(LPVOID)GetProp(hwnd, PREVIEW_PROP)
    #define RemovePreviewStuff(hwnd) RemoveProp(hwnd,PREVIEW_PROP)
#else
    #define SetPreviewStuff(hwnd, p) SetProp(hwnd,PREVIEW_PROP,HIWORD(p))
    #define GetPreviewStuff(hwnd) (PPreviewStuff)MAKELONG(0, GetProp(hwnd, PREVIEW_PROP))
    #define RemovePreviewStuff(hwnd) RemoveProp(hwnd,PREVIEW_PROP)
    #define CharNext AnsiNext
    #define CharPrev AnsiPrev
    #define CharUpperBuff AnsiUpperBuff
    #define CharLower AnsiLower
#endif

/***************************************************************************
 *
 ****************************************************************************/

STATICFN BOOL   PreviewOpen (HWND hwnd, LPOPENFILENAME pofn);
STATICFN BOOL   PreviewFile (PPreviewStuff p, LPTSTR szFile);
STATICFN BOOL   PreviewPaint(PPreviewStuff p);
STATICFN BOOL   PreviewSize (PPreviewStuff p);
STATICFN BOOL   PreviewClose(PPreviewStuff p);

STATICFN HANDLE GetRiffDisp(LPTSTR lpszFile, LPTSTR szText, int iLen);

/***************************************************************************
 *
 ****************************************************************************/

STATICFN BOOL PreviewOpen(HWND hwnd, LPOPENFILENAME pofn)
{
    LOGFONT lf;
    PPreviewStuff p;
    RECT rc;

    p = (LPVOID)pofn->lCustData;
    pofn->lCustData = p->lCustData;

    SetPreviewStuff(hwnd, p);

    p->hwnd = hwnd;
    p->pofn = pofn;

    //
    // create a MCI window for preview.
    //
    p->hwndMci = MCIWndCreate(p->hwnd, NULL,
//          MCIWNDF_NOAUTOSIZEWINDOW    |
//          MCIWNDF_NOPLAYBAR           |
//          MCIWNDF_NOAUTOSIZEMOVIE     |
            MCIWNDF_NOMENU              |
//          MCIWNDF_SHOWNAME            |
//          MCIWNDF_SHOWPOS             |
//          MCIWNDF_SHOWMODE            |
//          MCIWNDF_RECORD              |
            MCIWNDF_NOERRORDLG          |
            WS_CHILD | WS_BORDER,
            NULL);

    //
    // locate the preview in the lower corner of the dialog (below the
    // cancel button)
    //
    GetClientRect(hwnd, &p->rcPreview);
    GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rc);
    ScreenToClient(hwnd, (LPPOINT)&rc);
    ScreenToClient(hwnd, (LPPOINT)&rc+1);

// The open space we're allowed to use in the dialog is different in NT and on
// Win31.  Under NT there is a network button at the bottom of the dialog on
// the right hand side, so we use the area from just under the CANCEL button to
// a little more than 1 button height from the bottom of the dialog.
// Under Win31, the network button is under CANCEL, so we use the area a little
// over one button height under CANCEL, to just about the bottom of the dialog.
#ifdef _WIN32
    if (1)
#else
    if (GetWinFlags() & WF_WINNT)
#endif
    {
	p->rcPreview.top   = rc.bottom + 4;
	p->rcPreview.left  = rc.left;
	p->rcPreview.right = rc.right;
	p->rcPreview.bottom -= (rc.bottom - rc.top) + 12;
    } else {
	p->rcPreview.top   = rc.bottom + (rc.bottom - rc.top) + 12;
	p->rcPreview.left  = rc.left;
	p->rcPreview.right = rc.right;
	p->rcPreview.bottom -= 4;          // leave a little room at the bottom
    }

    //
    // create a font to use.
    //
    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), (LPVOID)&lf, 0);
    p->hfont = CreateFontIndirect(&lf);

    return TRUE;
}

/***************************************************************************
 *
 ****************************************************************************/

STATICFN BOOL PreviewClose(PPreviewStuff p)
{
    if (p == NULL)
        return FALSE;

    PreviewFile(p, NULL);

    RemovePreviewStuff(p->hwnd);

    if (p->hfont)
    {
        DeleteObject(p->hfont);
        p->hfont = NULL ;
    }

    if (p->hwndMci)
    {
        MCIWndDestroy(p->hwndMci);
        p->hwndMci = NULL ;
    }

    return TRUE;
}

/***************************************************************************
 *
 ****************************************************************************/

#define SLASH(c)     ((c) == TEXT('/') || (c) == TEXT('\\'))

STATICFN LPTSTR NiceName(LPTSTR szPath)
{
    LPTSTR   sz;
    LPTSTR   lpsztmp;

    for (sz=szPath; *sz; sz++)
        ;
    for (; sz>szPath && !SLASH(*sz) && *sz!=TEXT(':'); sz =CharPrev(szPath, sz))
        ;
    if(sz>szPath) sz = CharNext(sz) ;

    for(lpsztmp = sz; *lpsztmp  && *lpsztmp != TEXT('.'); lpsztmp = CharNext(lpsztmp))
	;
    *lpsztmp = TEXT('\0');

    CharLower(sz);
    CharUpperBuff(sz, 1);

    return sz;
}

/***************************************************************************
 *
 ****************************************************************************/

STATICFN BOOL PreviewFile(PPreviewStuff p, LPTSTR szFile)
{
    if (p == NULL || !p->hwndMci)
        return FALSE;

    p->Title[0] = 0;

    ShowWindow(p->hwndMci, SW_HIDE);
    MCIWndClose(p->hwndMci);

    if (p->hdib)
        GlobalFree(p->hdib);

    if (p->hpal)
        DeleteObject(p->hpal);

    p->hdib = NULL;
    p->hpal = NULL;

    PreviewPaint(p);

    if (szFile == NULL)
        return TRUE;

    if (MCIWndOpen(p->hwndMci, szFile, 0) == 0)
    {
        lstrcpy(p->Title, NiceName(szFile));

        if (MCIWndUseTime(p->hwndMci) == 0)
        {
            LONG len;
            UINT min,sec;

            len = MCIWndGetLength(p->hwndMci);

            if (len > 0)
            {
                #define ONE_HOUR    (60ul*60ul*1000ul)
                #define ONE_MINUTE  (60ul*1000ul)
                #define ONE_SECOND  (1000ul)

                min  = (UINT)(len / ONE_MINUTE) % 60;
                sec  = (UINT)(len / ONE_SECOND) % 60;

                wsprintf(p->Title + lstrlen(p->Title), TEXT(" (%02d:%02d)"), min, sec);
            }
        }
    }

    PreviewSize(p);
    PreviewPaint(p);
    return TRUE;
}

/***************************************************************************
 *
 ****************************************************************************/

STATICFN BOOL PreviewSize(PPreviewStuff p)
{
    RECT    rc;
    RECT    rcImage;
    RECT    rcText;
    RECT    rcPreview;
    HDC     hdc;
    int     dx;
    int     dy;
    int     dyPlayBar;

    SetRectEmpty(&p->rcText);
    SetRectEmpty(&p->rcImage);

    //
    // if nothing to do clear it.
    //
    if (p->Title[0] == 0 && p->hdib == NULL)
        return FALSE;

    rcPreview = p->rcPreview;

    //
    // compute the text rect, using DrawText
    //
    hdc = GetDC(p->hwnd);
    SelectObject(hdc, p->hfont);

    rcText = rcPreview;
    rcText.bottom = rcText.top;

    DrawText(hdc, p->Title, -1, &rcText, DT_CALCRECT|DT_LEFT|DT_WORDBREAK);
    ReleaseDC(p->hwnd, hdc);

    //
    // compute the image size
    //
    MCIWndChangeStyles(p->hwndMci, MCIWNDF_NOPLAYBAR, MCIWNDF_NOPLAYBAR);
    GetWindowRect(p->hwndMci, &rc);
    dx = rc.right - rc.left;
    dy = rc.bottom - rc.top;
    MCIWndChangeStyles(p->hwndMci, MCIWNDF_NOPLAYBAR, 0);
    GetWindowRect(p->hwndMci, &rc);
    dyPlayBar = rc.bottom - rc.top - dy;

    rcImage = rcPreview;
    rcImage.bottom -= dyPlayBar;

    //
    //  if wider than preview area scale to fit
    //
    if (dx > rcImage.right - rcImage.left)
    {
        rcImage.bottom = rcImage.top + MulDiv(dy,rcImage.right-rcImage.left,dx);
    }
    //
    //  if x2 will fit then use it
    //
    else if (dx * 2 < rcImage.right - rcImage.left)
    {
        rcImage.right  = rcImage.left + dx*2;
        rcImage.bottom = rcImage.top + dy*2;
    }
    //
    //  else center the image in the preview area
    //
    else
    {
        rcImage.right  = rcImage.left + dx;
        rcImage.bottom = rcImage.top + dy;
    }

    if (rcImage.bottom > rcPreview.bottom - (rcText.bottom - rcText.top) - dyPlayBar)
    {
        rcImage.bottom = rcPreview.bottom - (rcText.bottom - rcText.top) - dyPlayBar;
        rcImage.right  = rcPreview.left + MulDiv(dx,rcImage.bottom-rcImage.top,dy);
        rcImage.left   = rcPreview.left;
    }

    rcImage.bottom += dyPlayBar;

    //
    //  now center
    //
    dx = ((rcPreview.right - rcPreview.left) - (rcText.right - rcText.left))/2;
    OffsetRect(&rcText, dx, 0);

    dx = ((rcPreview.right - rcPreview.left) - (rcImage.right - rcImage.left))/2;
    OffsetRect(&rcImage, dx, 0);

    dy  = rcPreview.bottom - rcPreview.top;
    dy -= rcImage.bottom - rcImage.top;
    dy -= rcText.bottom - rcText.top;

    if (dy < 0)
        dy = 0;
    else
        dy = dy / 2;

    OffsetRect(&rcImage, 0, dy);
    OffsetRect(&rcText, 0, dy + rcImage.bottom - rcImage.top + 2);

    //
    // store RECTs
    //
    p->rcImage = rcImage;
    p->rcText = rcText;

    //
    // position window.
    //
    SetWindowPos(p->hwndMci, NULL, rcImage.left, rcImage.top,
        rcImage.right - rcImage.left, rcImage.bottom - rcImage.top,
        SWP_NOZORDER | SWP_NOACTIVATE);

    ShowWindow(p->hwndMci, SW_SHOW);

    return TRUE;
}


/***************************************************************************
 *
 ****************************************************************************/

STATICFN BOOL PreviewPaint(PPreviewStuff p)
{
    HDC     hdc;
    HBRUSH  hbr;
    HWND    hwnd = p->hwnd;

    if (p == NULL)
        return TRUE;

    hdc = GetDC(hwnd);

  #ifdef _WIN32
    hbr = (HBRUSH)DefWindowProc(hwnd, WM_CTLCOLORDLG, (WPARAM)hdc, (LPARAM)hwnd);
  #else
    hbr = (HBRUSH)DefWindowProc(hwnd, WM_CTLCOLOR, (WPARAM)hdc, MAKELONG(hwnd, CTLCOLOR_DLG));
  #endif

////FillRect(hdc, &p->rcPreview, hbr);
    FillRect(hdc, &p->rcText, hbr);

    SelectObject(hdc, p->hfont);
    DrawText(hdc, p->Title, -1, &p->rcText, DT_LEFT|DT_WORDBREAK);

    ReleaseDC(hwnd, hdc);
    return TRUE;
}

/***************************************************************************
 *
 ****************************************************************************/

#pragma message (SQUAWK "should use the correct header for cmb1, etc")

    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
    /* Edit controls */
#define edt1        0x0480

#define ID_TIMER    1234
#define PREVIEWWAIT 1000

UINT_PTR FAR PASCAL _loadds GetFileNamePreviewHook(HWND hwnd, unsigned msg, WPARAM wParam, LPARAM lParam)
{
    int i;
    TCHAR ach[80];

    PPreviewStuff p;

    p = GetPreviewStuff(hwnd);

    switch (msg) {
        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case lst1:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE)
                    {
                        KillTimer(hwnd, ID_TIMER);
                        SetTimer(hwnd, ID_TIMER, PREVIEWWAIT, NULL);
                    }
                    break;

                case IDOK:
                case IDCANCEL:
                    KillTimer(hwnd, ID_TIMER);
                    PreviewFile(p, NULL);
                    break;

                case cmb1:
                case cmb2:
                case lst2:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE)
                    {
                        KillTimer(hwnd, ID_TIMER);
                        PreviewFile(p, NULL);
                    }
                    break;
            }
            break;

        case WM_TIMER:
            if (wParam == ID_TIMER)
            {
                KillTimer(hwnd, ID_TIMER);

                ach[0] = 0;
                i = (int)SendDlgItemMessage(hwnd, lst1, LB_GETCURSEL, 0, 0L);
                SendDlgItemMessage(hwnd, lst1, LB_GETTEXT, i, (LPARAM)(LPTSTR)ach);
                PreviewFile(p, ach);
                return TRUE;
            }
            break;

        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            if (p && p->hwndMci)
                SendMessage(p->hwndMci, msg, wParam, lParam);
	    break;

        case WM_PAINT:
            PreviewPaint(p);
            break;

        case WM_INITDIALOG:
            PreviewOpen(hwnd, (LPOPENFILENAME)lParam);

            p = GetPreviewStuff(hwnd);

            if (!(p->Flags & OFN_ENABLEHOOK))
                return TRUE;

            break;

        case WM_DESTROY:
            PreviewClose(p);
            break;
    }

    if (p && (p->Flags & OFN_ENABLEHOOK))
        return (int)p->lpfnHook(hwnd, msg, wParam, lParam);
    else
        return FALSE;
}

/***************************************************************************
 *
 ****************************************************************************/

STATICFN BOOL GetFileNamePreview(LPOPENFILENAME lpofn, BOOL fSave, BOOL bUnicode)
{
    BOOL f;
    PPreviewStuff p;

//////// Link to COMMDLG
    HINSTANCE h;
    BOOL (WINAPI *GetFileNameProc)(OPENFILENAME FAR*) = NULL;
    char procname[60];

    if (fSave) {
	lstrcpyA(procname, "GetSaveFileName");
    } else {
	lstrcpyA(procname, "GetOpenFileName");
    }
#ifdef _WIN32
    if (bUnicode) {
	lstrcatA(procname, "W");
    } else {
    	lstrcatA(procname, "A");
    }
#endif

#ifdef _WIN32
    if ((h = LoadLibrary(TEXT("COMDLG32.DLL"))) != NULL) {
        (FARPROC)GetFileNameProc = GetProcAddress(h, procname);
#else
    if ((h = LoadLibrary(TEXT("COMMDLG.DLL"))) >= (HINSTANCE)HINSTANCE_ERROR) {
        (FARPROC)GetFileNameProc = GetProcAddress(h, procname);
#endif
    }

    if (GetFileNameProc == NULL)
        return FALSE;      //!!! what's the right error here?
////////////////

#ifndef OFN_NONETWORKBUTTON
#define OFN_NONETWORKBUTTON 0x00020000
#endif

    // If we have a READ ONLY checkbox, or both HELP and NETWORK, then it's in
    // our way, so get rid of it. (keep NETWORK, lose HELP)

    if (!(lpofn->Flags & OFN_HIDEREADONLY))
	lpofn->Flags |= OFN_HIDEREADONLY;
    if ((lpofn->Flags & OFN_SHOWHELP) && !(lpofn->Flags & OFN_NONETWORKBUTTON))
	lpofn->Flags &= ~OFN_SHOWHELP;

    p = (LPVOID)GlobalAllocPtr(GHND, sizeof(PreviewStuff));

    if (p == NULL)
    {
        f = GetFileNameProc(lpofn);
    }
    else
    {
	p->bUnicode  = bUnicode;
        p->lpfnHook  = lpofn->lpfnHook;
        p->Flags     = lpofn->Flags;
        p->lCustData = lpofn->lCustData;

        lpofn->lpfnHook = (LPVOID)GetFileNamePreviewHook;
        lpofn->Flags |= OFN_ENABLEHOOK;
        lpofn->lCustData = (LPARAM)p;

        f = GetFileNameProc(lpofn);

        lpofn->lpfnHook  = p->lpfnHook;
        lpofn->Flags     = p->Flags;

        GlobalFreePtr(p);
    }

    FreeLibrary(h);     //!!! should we free DLL?
    return f;
}

#ifdef _WIN32

/**************************************************************************
* @doc EXTERNAL
*
* @api BOOL | GetOpenFileNamePreview | This is just like <f GetOpenFileName>
*   in COMMDLG, but with a preview window so people can see what movie
*   they're opening.
*
* @parm LPOPENFILENAME | lpofn | See the documentation for <f GetOpenFileName>.
*
* @rdesc Returns true if a file was opened.
*
* @xref GetOpenFileName
*
*************************************************************************/
BOOL FAR PASCAL _loadds GetOpenFileNamePreviewW(LPOPENFILENAMEW lpofn)
{
    return GetFileNamePreview((LPOPENFILENAME)lpofn, FALSE, TRUE);
}

/**************************************************************************
* @doc EXTERNAL
*
* @api BOOL | GetSaveFileNamePreview | This is just like <f GetSaveFileName>
*   in COMMDLG, but with a preview window so people can see what movie
*   they're saving over.
*
* @parm LPOPENFILENAME | lpofn | See the documentation for <f GetSaveFileName>.
*
* @rdesc Returns true if a file was opened.
*
* @xref GetSaveFileName
*
*************************************************************************/
BOOL FAR PASCAL _loadds GetSaveFileNamePreviewW(LPOPENFILENAMEW lpofn)
{
    return GetFileNamePreview((LPOPENFILENAME)lpofn, TRUE, TRUE);
}

// ansi thunks for above two functions
BOOL FAR PASCAL _loadds GetOpenFileNamePreviewA(LPOPENFILENAMEA lpofn)
{
    return GetFileNamePreview((LPOPENFILENAME)lpofn, FALSE, FALSE);
}

BOOL FAR PASCAL _loadds GetSaveFileNamePreviewA(LPOPENFILENAMEA lpofn)
{
    return GetFileNamePreview((LPOPENFILENAME)lpofn, TRUE, FALSE);
}

#else
BOOL FAR PASCAL _loadds GetOpenFileNamePreview(LPOPENFILENAME lpofn)
{
    return GetFileNamePreview(lpofn, FALSE, FALSE);
}

BOOL FAR PASCAL _loadds GetSaveFileNamePreview(LPOPENFILENAME lpofn)
{
    return GetFileNamePreview(lpofn, TRUE, FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description: math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//  Description:
//
//  History:
//       9/21/93    cjp     [curtisp] 
//       9/23/93    stl     [toddla]
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32

#ifdef __cplusplus
extern "C"
{
#endif

extern LONG  FAR PASCAL MulDiv32(LONG  a,LONG  b,LONG  c);
extern DWORD FAR PASCAL MulDivRN(DWORD a,DWORD b,DWORD c);
extern DWORD FAR PASCAL MulDivRD(DWORD a,DWORD b,DWORD c);
extern DWORD FAR PASCAL MulDivRU(DWORD a,DWORD b,DWORD c);

#if defined(WIN32) || defined(_WIN32)
    // GDI32s MulDiv is the same as MulDivRN
    #define MulDivRN(a,b,c)   (DWORD)MulDiv((LONG)(a),(LONG)(b),(LONG)(c))
#endif

//
//  some code references these by other names.
//
#define muldiv32    MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#ifdef __cplusplus
}
#endif
#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd\strings.h ===
/****************************************************************************/
/*		            Please internationalize me			    */
/****************************************************************************/

// Make sure these don't conflict with other MSVIDEO numbers!
#define MCIWND_BASE	333

#define IDS_MCIFILES 	(MCIWND_BASE + 0)
#define IDS_ALLFILES 	(MCIWND_BASE + 1)
#define IDS_MCIERROR 	(MCIWND_BASE + 2)
#define IDS_NODEVICE 	(MCIWND_BASE + 3)
#define IDS_HALFSIZE 	(MCIWND_BASE + 4)
#define IDS_NORMALSIZE  (MCIWND_BASE + 5)
#define IDS_DOUBLESIZE 	(MCIWND_BASE + 6)
#define IDS_PLAY 	(MCIWND_BASE + 7)
#define IDS_STOP 	(MCIWND_BASE + 8)
#define IDS_RECORD 	(MCIWND_BASE + 9)
#define IDS_EJECT 	(MCIWND_BASE + 10)
#define IDS_CLOSE 	(MCIWND_BASE + 11)
#define IDS_NEW 	(MCIWND_BASE + 12)
#define IDS_VIEW 	(MCIWND_BASE + 13)
#define IDS_VOLUME 	(MCIWND_BASE + 14)
#define IDS_SPEED 	(MCIWND_BASE + 15)
#define IDS_OPEN 	(MCIWND_BASE + 16)
#define IDS_SAVE 	(MCIWND_BASE + 17)
#define IDS_CONFIGURE 	(MCIWND_BASE + 18)
#define IDS_COMMAND 	(MCIWND_BASE + 19)
#define IDS_COPY 	(MCIWND_BASE + 20)

#ifndef CHICAGO
#define IDS_TT_PLAY     0x806       // same as MCI_PLAY
#define IDS_TT_STOP     0x808       // same as MCI_STOP
#define IDS_TT_RECORD   0x80F       // same as MCI_RECORD
#define IDS_TT_EJECT    108         // same as IDM_MCIEJECT
#define IDS_TT_MENU     107         // same as IDM_MENU
#endif


/****************************************************************************/
/*		       Please don't internationalize me			    */
/****************************************************************************/

#define DLG_MCICOMMAND  942
#define IDC_MCICOMMAND  10
#define IDC_RESULT      11
#define MPLAYERICON	943
#define IDBMP_TOOLBAR   959

SZCODE	szNULL[] = TEXT("");
SZCODEA szNULLA[] = "";
SZCODE  szMCIExtensions[] = TEXT("MCI Extensions");
SZCODE  szPutDest[] = TEXT("put destination at %d %d %d %d");
SZCODE  szPutSource[] = TEXT("put source at %d %d %d %d");
SZCODE  szSetFormatTMSF[] = TEXT("set time format tmsf");
SZCODE  szSetFormatMS[] = TEXT("set time format ms");
SZCODE  szSetFormatFrames[] = TEXT("set time format frames");
SZCODE  szSetFormat[] = TEXT("set time format %s");
SZCODE  szStatusFormat[] = TEXT("status time format");
SZCODEA  szStatusFormatA[] = "status time format";
SZCODE  szStatusNumTracks[] = TEXT("status number of tracks");
SZCODE  szStatusPosTrack[] = TEXT("status position track %d");
SZCODE  szStatusVolume[] = TEXT("status volume");
SZCODE  szStatusSpeed[] = TEXT("status speed");
SZCODE  szSetSpeed[] = TEXT("set speed %d");
SZCODE  szSetVolume[] = TEXT("setaudio volume to %d");
SZCODE  szSysInfo[] = TEXT("sysinfo installname");
SZCODEA  szSysInfoA[] = "sysinfo installname";
SZCODE  szSetPalette[] = TEXT("setvideo palette handle to %d");
SZCODE  szMDIClient[] = TEXT("MDIClient");
SZCODE  szSave[] = TEXT("save \"%s\"");
SZCODE  szNew[] = TEXT("open new type %s alias %d wait");
SZCODE  szOpenShareable[] = TEXT("open \"%s\" alias %d wait shareable");
SZCODE  szOpen[] = TEXT("open \"%s\" alias %d wait");
SZCODE  szOpenAVI[] = TEXT("open \"%s\" alias %d wait type AVIVideo");
SZCODE  szWindowHandle[] = TEXT("window handle %u");
SZCODE  szStatusPalette[] = TEXT("status palette handle");
SZCODE  szConfigureTest[] = TEXT("configure test");
SZCODE  szConfigure[] = TEXT("configure");
SZCODE  szSetSpeed1000Test[] = TEXT("set speed 1000 test");
SZCODE  szSetSpeed500Test[] = TEXT("set speed 500 test");
SZCODE  szSetSpeedTest[] = TEXT("set speed %d test");
SZCODE  szSetVolume0Test[] = TEXT("setaudio volume to 0 test");
SZCODE  szSetVolumeTest[] = TEXT("setaudio volume to %d test");
SZCODE  szStatusMode[] = TEXT("status mode");
SZCODEA  szStatusModeA[] = "status mode";
SZCODE  szPlay[] = TEXT("play %s");
SZCODE  szPlayReverse[] = TEXT("play reverse %s");
SZCODE  szPlayFrom[] = TEXT("play from %ld");
SZCODE  szPlayTo[] = TEXT("play to %ld");
SZCODE  szRepeat[] = TEXT("repeat");
SZCODE  szSetDoorOpen[] = TEXT("set door open");
SZCODE  szStep[] = TEXT("step by %ld");
SZCODE  szSeek[] = TEXT("seek to %ld");
SZCODE  szClose[] = TEXT("close");
SZCODE  szStatusPosition[] = TEXT("status position");
SZCODEA  szStatusPositionA[] = "status position";
SZCODE  szStatusStart[] = TEXT("status start position");
SZCODE  szPlayFullscreenReverse[] = TEXT("play fullscreen reverse %s");
SZCODE  szPlayFullscreen[] = TEXT("play fullscreen %s");
SZCODE  szSmallFonts[] = TEXT("small fonts");
SZCODE  szStatusForward[] = TEXT("status forward");
SZCODE	szInterface[] = TEXT("AVIVideo!@%ld");

static SZCODEA  szDebug[] = "debug";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd\tracki.h ===
/*
	TrackBar
	
	All the useful information for a trackbar.
*/

typedef struct {
        HWND    hwnd;           // our window handle
        HDC     hdc;            // current DC

        LONG    lLogMin;        // Logical minimum
        LONG    lLogMax;        // Logical maximum
        LONG    lLogPos;        // Logical position

        LONG    lSelStart;      // Logical selection start
        LONG    lSelEnd;        // Logical selection end

        UINT    wThumbWidth;    // Width of the thumb
        UINT    wThumbHeight;   // Height of the thumb

        int     iSizePhys;      // Size of where thumb lives
        RECT    rc;             // track bar rect.

        RECT    Thumb;          // Rectangle we current thumb
        DWORD   dwDragPos;      // Logical position of mouse while dragging.

        UINT    Flags;          // Flags for our window
        int     Timer;          // Our timer.
        UINT    Cmd;            // The command we're repeating.

        int     nTics;          // number of ticks.
        PDWORD  pTics;          // the tick marks.

} TrackBar, *PTrackBar;

// Trackbar flags

#define TBF_NOTHUMB     0x0001  // No thumb because not wide enough.
#define TBF_SELECTION   0x0002  // a selection has been established (draw the range)

/*
	useful constants.
*/

#define REPEATTIME      500     // mouse auto repeat 1/2 of a second
#define TIMER_ID        1

#define	GWW_TRACKMEM		0 /* handle to track bar memory */
#define EXTRA_TB_BYTES          sizeof(PTrackBar) /* Total extra bytes.         */

/*
	Useful defines.
*/

#ifdef WIN32
#define TrackBarCreate(hwnd)    SetWindowLong(hwnd,GWW_TRACKMEM,(LONG)LocalAlloc(LPTR,sizeof(TrackBar)))
#define TrackBarDestroy(hwnd)   LocalFree((HLOCAL)GetWindowLong(hwnd,GWW_TRACKMEM))
#define TrackBarLock(hwnd)      (PTrackBar)GetWindowLong(hwnd,GWW_TRACKMEM)
#else
#define TrackBarCreate(hwnd)    SetWindowWord(hwnd,GWW_TRACKMEM,(WORD)LocalAlloc(LPTR,sizeof(TrackBar)))
#define TrackBarDestroy(hwnd)   LocalFree((HLOCAL)GetWindowWord(hwnd,GWW_TRACKMEM))
#define TrackBarLock(hwnd)      (PTrackBar)GetWindowWord(hwnd,GWW_TRACKMEM)
#endif

/*
	Function Prototypes
*/

static void   NEAR PASCAL DoTrack(PTrackBar, int, DWORD);
static WORD   NEAR PASCAL WTrackType(PTrackBar, LONG);
static void   NEAR PASCAL TBTrackInit(PTrackBar, LONG);
static void   NEAR PASCAL TBTrackEnd(PTrackBar, LONG);
static void   NEAR PASCAL TBTrack(PTrackBar, LONG);
static void   NEAR PASCAL DrawThumb(PTrackBar);
static HBRUSH NEAR PASCAL SelectColorObjects(PTrackBar, BOOL);
static void   NEAR PASCAL SetTBCaretPos(PTrackBar);

extern DWORD FAR PASCAL lMulDiv32(DWORD, DWORD, DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd.16\commctrl.h ===
/* commctrl.h : Interfaces for the Windows Common Controls.
 * Copyright (C) Microsoft 1991-1992
 */

/*REVIEW: this stuff needs Windows style in many places; find all REVIEWs. */

#ifndef _INC_COMMCTRL
#define _INC_COMMCTRL

#ifdef __cplusplus
extern "C" {
#endif

/* Users of this header may define any number of these constants to avoid
 * the definitions of each functional group.
 *    NOTOOLBAR    Customizable bitmap-button toolbar control.
 *    NOUPDOWN     Up and Down arrow increment/decrement control.
 *    NOSTATUSBAR  Status bar and header bar controls.
 *    NOMENUHELP   APIs to help manage menus, especially with a status bar.
 *    NOTRACKBAR   Customizable column-width tracking control.
 *    NOBTNLIST    A control which is a list of bitmap buttons.
 *    NODRAGLIST   APIs to make a listbox source and sink drag&drop actions.
 *    NOPROGRESS   Progress gas gauge.
 */

/*/////////////////////////////////////////////////////////////////////////*/

/* InitCommonControls:
 * Any application requiring the use of any common control should call this
 * API upon application startup.  There is no required shutdown.
 */
void WINAPI InitCommonControls();

/*/////////////////////////////////////////////////////////////////////////*/

#ifndef NOTOOLBAR

#define TOOLBARCLASSNAME "MCIWndToolbar"


/* Note that LOWORD(dwData) is at the same offset as idsHelp in the old
** structure, since it was never used anyway.
*/
typedef struct tagTBBUTTON
{
/*REVIEW: index, command, flag words, resource ids should be UINT */
    int iBitmap;	/* index into bitmap of this button's picture */
    int idCommand;	/* WM_COMMAND menu ID that this button sends */
    BYTE fsState;	/* button's state */
    BYTE fsStyle;	/* button's style */
    DWORD dwData;	/* app defined data */
    int iString;	/* index into string list */
} TBBUTTON;
typedef TBBUTTON NEAR* PTBBUTTON;
typedef TBBUTTON FAR* LPTBBUTTON;
typedef const TBBUTTON FAR* LPCTBBUTTON;


/*REVIEW: is this internal? if not, call it TBADJUSTINFO, prefix tba */
typedef struct tagADJUSTINFO
{
    TBBUTTON tbButton;
    char szDescription[1];
} ADJUSTINFO;
typedef ADJUSTINFO NEAR* PADJUSTINFO;
typedef ADJUSTINFO FAR* LPADJUSTINFO;


/*REVIEW: is this internal? if not, call it TBCOLORMAP, prefix tbc */
typedef struct tagCOLORMAP
{
    COLORREF from;
    COLORREF to;
} COLORMAP;
typedef COLORMAP NEAR* PCOLORMAP;
typedef COLORMAP FAR* LPCOLORMAP;


/* This is likely to change several times in the near future. */
HWND WINAPI CreateToolbarEx(HWND hwnd, DWORD ws, WORD wID, int nBitmaps,
			HINSTANCE hBMInst, WORD wBMID, LPCTBBUTTON lpButtons, 
			int iNumButtons, int dxButton, int dyButton, 
			int dxBitmap, int dyBitmap, UINT uStructSize);

/*REVIEW: idBitmap, iNumMaps should be UINT */
HBITMAP WINAPI CreateMappedBitmap(HINSTANCE hInstance, int idBitmap,
                                  WORD wFlags, LPCOLORMAP lpColorMap,
				  int iNumMaps);

#define CMB_DISCARDABLE	0x01	/* create bitmap as discardable */
#define CMB_MASKED	0x02	/* create image/mask pair in bitmap */

/*REVIEW: TBSTATE_* should be TBF_* (for Flags) */
#define TBSTATE_CHECKED		0x01	/* radio button is checked */
#define TBSTATE_PRESSED		0x02	/* button is being depressed (any style) */
#define TBSTATE_ENABLED		0x04	/* button is enabled */
#define TBSTATE_HIDDEN		0x08	/* button is hidden */
#define TBSTATE_INDETERMINATE	0x10	/* button is indeterminate */
                                        /*  (needs to be endabled, too) */

/*REVIEW: TBSTYLE_* should be TBS_* (for Style) */
#define TBSTYLE_BUTTON		0x00	/* this entry is button */
#define TBSTYLE_SEP		0x01	/* this entry is a separator */
#define TBSTYLE_CHECK		0x02	/* this is a check button (it stays down) */
#define TBSTYLE_GROUP		0x04	/* this is a check button (it stays down) */
#define TBSTYLE_CHECKGROUP	(TBSTYLE_GROUP | TBSTYLE_CHECK)	/* this group is a member of a group radio group */

/*REVIEW: ifdef _INC_WINDOWSX, should we provide message crackers? */

#define TB_ENABLEBUTTON	(WM_USER + 1)
	/* wParam: UINT, button ID
	** lParam: BOOL LOWORD, enable if nonzero; HIWORD not used, 0
	** return: not used
	*/

#define TB_CHECKBUTTON	(WM_USER + 2)
	/* wParam: UINT, button ID
	** lParam: BOOL LOWORD, check if nonzero; HIWORD not used, 0
	** return: not used
	*/

#define TB_PRESSBUTTON	(WM_USER + 3)
	/* wParam: UINT, button ID
	** lParam: BOOL LOWORD, press if nonzero; HIWORD not used, 0
	** return: not used
	*/

#define TB_HIDEBUTTON	(WM_USER + 4)
	/* wParam: UINT, button ID
	** lParam: BOOL LOWORD, hide if nonzero; HIWORD not used, 0
	** return: not used
	*/
#define TB_INDETERMINATE	(WM_USER + 5)
	/* wParam: UINT, button ID
	** lParam: BOOL LOWORD, make indeterminate if nonzero; HIWORD not used, 0
	** return: not used
	*/

/*REVIEW: Messages up to WM_USER+8 are reserved until we define more state bits */

#define TB_ISBUTTONENABLED	(WM_USER + 9)
	/* wParam: UINT, button ID
	** lParam: not used, 0
	** return: BOOL LOWORD, enabled if nonzero; HIWORD not used
	*/

#define TB_ISBUTTONCHECKED	(WM_USER + 10)	
	/* wParam: UINT, button ID
	** lParam: not used, 0
	** return: BOOL LOWORD, checked if nonzero; HIWORD not used
	*/

#define TB_ISBUTTONPRESSED	(WM_USER + 11)	
	/* wParam: UINT, button ID
	** lParam: not used, 0
	** return: BOOL LOWORD, pressed if nonzero; HIWORD not used
	*/

#define TB_ISBUTTONHIDDEN	(WM_USER + 12)	
	/* wParam: UINT, button ID
	** lParam: not used, 0
	** return: BOOL LOWORD, hidden if nonzero; HIWORD not used
	*/

#define TB_ISBUTTONINDETERMINATE	(WM_USER + 13)	
	/* wParam: UINT, button ID
	** lParam: not used, 0
	** return: BOOL LOWORD, indeterminate if nonzero; HIWORD not used
	*/

/*REVIEW: Messages up to WM_USER+16 are reserved until we define more state bits */

#define TB_SETSTATE             (WM_USER + 17)
	/* wParam: UINT, button ID
	** lParam: UINT LOWORD, state bits; HIWORD not used, 0
	** return: not used
	*/

#define TB_GETSTATE             (WM_USER + 18)
	/* wParam: UINT, button ID
	** lParam: not used, 0
	** return: UINT LOWORD, state bits; HIWORD not used
	*/

#define TB_ADDBITMAP		(WM_USER + 19)
	/* wParam: UINT, number of button graphics in bitmap
	** lParam: one of:
	**         HINSTANCE LOWORD, module handle; UINT HIWORD, resource id
	**         HINSTANCE LOWORD, NULL; HBITMAP HIWORD, bitmap handle
	** return: one of:
	**         int LOWORD, index for first new button; HIWORD not used
	**         int LOWORD, -1 indicating error; HIWORD not used
	*/

#define TB_ADDBUTTONS		(WM_USER + 20)
	/* wParam: UINT, number of buttons to add
	** lParam: LPTBBUTTON, pointer to array of TBBUTTON structures
	** return: not used
	*/

#define TB_INSERTBUTTON		(WM_USER + 21)
	/* wParam: UINT, index for insertion (appended if index doesn't exist)
	** lParam: LPTBBUTTON, pointer to one TBBUTTON structure
	** return: not used
	*/

#define TB_DELETEBUTTON		(WM_USER + 22)
	/* wParam: UINT, index of button to delete
	** lParam: not used, 0
	** return: not used
	*/

#define TB_GETBUTTON		(WM_USER + 23)
	/* wParam: UINT, index of button to get
	** lParam: LPTBBUTTON, pointer to TBBUTTON buffer to receive button
	** return: not used
	*/

#define TB_BUTTONCOUNT		(WM_USER + 24)
	/* wParam: not used, 0
	** lParam: not used, 0
	** return: UINT LOWORD, number of buttons; HIWORD not used
	*/

#define TB_COMMANDTOINDEX	(WM_USER + 25)
	/* wParam: UINT, command id
	** lParam: not used, 0
	** return: UINT LOWORD, index of button (-1 if command not found);
	**         HIWORD not used
	**/

#define TB_SAVERESTORE		(WM_USER + 26)
	/* wParam: BOOL, save state if nonzero (otherwise restore)
	** lParam: LPSTR FAR*, pointer to two LPSTRs:
	**         (LPSTR FAR*)(lParam)[0]: ini section name
	**         (LPSTR FAR*)(lParam)[1]: ini file name or NULL for WIN.INI
	** return: not used
	*/

#define TB_CUSTOMIZE            (WM_USER + 27)
	/* wParam: not used, 0
	** lParam: not used, 0
	** return: not used
	*/

#define TB_ADDSTRING		(WM_USER + 28)
	/* wParam: UINT, 0 if no resource; HINSTANCE, module handle
	** lParam: LPSTR, null-terminated strings with double-null at end
	**         UINT LOWORD, resource id
	** return: one of:
	**         int LOWORD, index for first new string; HIWORD not used
	**         int LOWORD, -1 indicating error; HIWORD not used
	*/

#define TB_GETITEMRECT		(WM_USER + 29)
	/* wParam: UINT, index of toolbar item whose rect to retrieve
	** lParam: LPRECT, pointer to a RECT struct to fill
	** return: Non-zero, if the RECT is successfully filled
	**         Zero, otherwise (item did not exist or was hidden)
	*/

#define TB_BUTTONSTRUCTSIZE	(WM_USER + 30)
	/* wParam: UINT, size of the TBBUTTON structure.  This is used
	**         as a version check.
	** lParam: not used
	** return: not used
	**
	** This is required before any buttons are added to the toolbar if
	** the toolbar is created using CreateWindow, but is implied when
	** using CreateToolbar and is a parameter to CreateToolbarEx.
	*/

#define TB_SETBUTTONSIZE	(WM_USER + 31)
	/* wParam: not used, 0
	** lParam: UINT LOWORD, button width
	**         UINT HIWORD, button height
	** return: not used
	**
	** The button size can only be set before any buttons are
	** added.  A default size of 24x22 is assumed if the size
	** is not set explicitly.
	*/

#define TB_SETBITMAPSIZE	(WM_USER + 32)
	/* wParam: not used, 0
	** lParam: UINT LOWORD, bitmap width
	**         UINT HIWORD, bitmap height
	** return: not used
	**
	** The bitmap size can only be set before any bitmaps are
	** added.  A default size of 16x15 is assumed if the size
	** is not set explicitly.
	*/

#define TB_AUTOSIZE		(WM_USER + 33)
	/* wParam: not used, 0
	** lParam: not used, 0
	** return: not used
	**
	** Application should call this after causing the toolbar size
	** to change by either setting the button or bitmap size or
	** by adding strings for the first time.
	*/

#define TB_SETBUTTONTYPE	(WM_USER + 34)
	/* wParam: WORD, frame control style of button (DFC_*)
	** lParam: not used, 0
	** return: not used
	*/

#endif /* NOTOOLBAR */

/*/////////////////////////////////////////////////////////////////////////*/

#ifndef NOSTATUSBAR

/*REVIEW: Here exists the only known documentation for status bars. */

/* DrawStatusText:
 * This is used if the app wants to draw status in its client rect,
 * instead of just creating a window.  Note that this same function is
 * used internally in the status bar window's WM_PAINT message.
 * hDC is the DC to draw to.  The font that is selected into hDC will
 * be used.  The RECT lprc is the only portion of hDC that will be drawn
 * to: the outer edge of lprc will have the highlights (the area outside
 * of the highlights will not be drawn in the BUTTONFACE color: the app
 * must handle that).  The area inside the highlights will be erased
 * properly when drawing the text.
 */
/*REVIEW: szText should be LPCSTR */
void WINAPI DrawStatusText(HDC hDC, LPRECT lprc, LPSTR szText, UINT uFlags);

/* CreateStatusWindow:
 * CreateHeaderWindow:
 * These create a "default" status or header window.  This will have the
 * default borders around the text, the default font, and only one pane.
 * It may also automatically resize and move itself (depending on the SBS_*
 * flags).
 *
 * The style should contain WS_CHILD, and can contain WS_BORDER and
 * WS_VISIBLE, plus any of the SBS_* styles described below.  I don't know
 * about other WS_* styles.
 *
 * The lpszText is the initial text for the first pane.
 * hwndParent is the window the status bar exists in, and should not be NULL.
 * wID is the child window ID of the window.
 * hInstance is the instance handle of the application using this.
 * Note that the app can also just call CreateWindow with
 * STATUSCLASSNAME/HEADERCLASSNAME to create a window of a specific size.
 *
 * Note the user can change the font used by setting win.ini [Desktop]:
 *   StatusBarFaceName=Arial
 *   StatusBarFaceHeight=10
 */
/*REVIEW: style should be DWORD, lpszText should be LPCSTR */
HWND WINAPI CreateStatusWindow(LONG style, LPSTR lpszText,
      HWND hwndParent, WORD wID);
HWND WINAPI CreateHeaderWindow(LONG style, LPSTR lpszText,
      HWND hwndParent, WORD wID);

/*REVIEW: should be STATUSBAR_CLASS, HEADERBAR_CLASS */
#define STATUSCLASSNAME "msctls_statusbar"
/* This is the name of the status bar class (it will probably change later
 * so use the #define here).
 */
#define HEADERCLASSNAME "msctls_headerbar"
/* This is the name of the status bar class (it will probably change later
 * so use the #define here).
 */


#define SB_SETTEXT		(WM_USER+1)
#define SB_GETTEXT		(WM_USER+2)
#define SB_GETTEXTLENGTH	(WM_USER+3)
/* Just like WM_?ETTEXT*, with wParam specifying the pane that is referenced
 * (at most 255).
 * Note that you can use the WM_* versions to reference the 0th pane (this
 * is useful if you want to treat a "default" status bar like a static text
 * control).
 * For SETTEXT, wParam is the pane or'ed with SBT_* style bits (defined below).
 * If the text is "normal" (not OWNERDRAW), then a single pane may have left,
 * center, and right justified text by separating the parts with a single tab,
 * plus if lParam is NULL, then the pane has no text.  The pane will be
 * invalidated, but not draw until the next PAINT message.
 * For GETTEXT and GETTEXTLENGTH, the LOWORD of the return will be the length,
 * and the HIWORD will be the SBT_* style bits.
 */
#define SB_SETPARTS		(WM_USER+4)
/* wParam is the number of panes, and lParam points to an array of points
 * specifying the right hand side of each pane.  A right hand side of -1 means
 * it goes all the way to the right side of the control minus the X border
 */
#define SB_SETBORDERS		(WM_USER+5)
/* lParam points to an array of 3 integers: X border, Y border, between pane
 * border.  If any is less than 0, the default will be used for that one.
 */
#define SB_GETPARTS		(WM_USER+6)
/* lParam is a pointer to an array of integers that will get filled in with
 * the right hand side of each pane and wParam is the size (in integers)
 * of the lParam array (so we do not go off the end of it).
 * Returns the number of panes.
 */
#define SB_GETBORDERS		(WM_USER+7)
/* lParam is a pointer to an array of 3 integers that will get filled in with
 * the X border, the Y border, and the between pane border.
 */
#define SB_SETMINHEIGHT		(WM_USER+8)
/* wParam is the minimum height of the status bar "drawing" area.  This is
 * the area inside the highlights.  This is most useful if a pane is used
 * for an OWNERDRAW item, and is ignored if the SBS_NORESIZE flag is set.
 * Note that WM_SIZE (wParam=0, lParam=0L) must be sent to the control for
 * any size changes to take effect.
 */
#define SB_SIMPLE		(WM_USER+9)
/* wParam specifies whether to set (non-zero) or unset (zero) the "simple"
 * mode of the status bar.  In simple mode, only one pane is displayed, and
 * its text is set with LOWORD(wParam)==255 in the SETTEXT message.
 * OWNERDRAW is not allowed, but other styles are.
 * The pane gets invalidated, but not painted until the next PAINT message,
 * so you can set new text without flicker (I hope).
 * This can be used with the WM_INITMENU and WM_MENUSELECT messages to
 * implement help text when scrolling through a menu.
 */


#define HB_SAVERESTORE		(WM_USER+256)
/* This gets a header bar to read or write its state to or from an ini file.
 * wParam is 0 for reading, non-zero for writing.  lParam is a pointer to
 * an array of two LPSTR's: the section and file respectively.
 * Note that the correct number of partitions must be set before calling this.
 */
#define HB_ADJUST		(WM_USER+257)
/* This puts the header bar into "adjust" mode, for changing column widths
 * with the keyboard.
 */
#define HB_SETWIDTHS		SB_SETPARTS
/* Set the widths of the header columns.  Note that "springy" columns only
 * have a minumum width, and negative width are assumed to be hidden columns.
 * This works just like SB_SETPARTS.
 */
#define HB_GETWIDTHS		SB_GETPARTS
/* Get the widths of the header columns.  Note that "springy" columns only
 * have a minumum width.  This works just like SB_GETPARTS.
 */
#define HB_GETPARTS		(WM_USER+258)
/* Get a list of the right-hand sides of the columns, for use when drawing the
 * actual columns for which this is a header.  
 * lParam is a pointer to an array of integers that will get filled in with
 * the right hand side of each pane and wParam is the size (in integers)
 * of the lParam array (so we do not go off the end of it).
 * Returns the number of panes.
 */
#define HB_SHOWTOGGLE		(WM_USER+259)
/* Toggle the hidden state of a column.  wParam is the 0-based index of the
 * column to toggle.
 */


#define SBT_OWNERDRAW	0x1000
/* The lParam of the SB_SETTEXT message will be returned in the DRAWITEMSTRUCT
 * of the WM_DRAWITEM message.  Note that the fields CtlType, itemAction, and
 * itemState of the DRAWITEMSTRUCT are undefined for a status bar.
 * The return value for GETTEXT will be the itemData.
 */
#define SBT_NOBORDERS	0x0100
/* No borders will be drawn for the pane.
 */
#define SBT_POPOUT	0x0200
/* The text pops out instead of in
 */
#define HBT_SPRING	0x0400
/* this means that the item is "springy", meaning that it has a minimum
 * width, but will grow if there is extra room in the window.  Note that
 * multiple springs are allowed, and the extra room will be distributed
 * among them.
 */

/* Here's a simple dialog function that uses a default status bar to display
 * the mouse position in the given window.
 *
 * extern HINSTANCE hInst;
 *
 * BOOL CALLBACK MyWndProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
 * {
 *   switch (msg)
 *     {
 *       case WM_INITDIALOG:
 *         CreateStatusWindow(WS_CHILD|WS_BORDER|WS_VISIBLE, "", hDlg,
 *               IDC_STATUS, hInst);
 *         break;
 *
 *       case WM_SIZE:  //REVIEW: simulating fake WM_SIZE may not be wise
 *         SendDlgItemMessage(hDlg, IDC_STATUS, WM_SIZE, 0, 0L);
 *         break;
 *
 *       case WM_MOUSEMOVE:
 *         wsprintf(szBuf, "%d,%d", LOWORD(lParam), HIWORD(lParam));
 *         SendDlgItemMessage(hDlg, IDC_STATUS, SB_SETTEXT, 0,
 *               (LPARAM)(LPSTR)szBuf);
 *         break;
 *
 *       default:
 *         break;
 *     }
 *   return(FALSE);
 * }
 */

#endif /* NOSTATUSBAR */

/*/////////////////////////////////////////////////////////////////////////*/

#ifndef NOMENUHELP

/*REVIEW: iMessage should be UINT */
void WINAPI MenuHelp(WORD iMessage, WPARAM wParam, LPARAM lParam,
      HMENU hMainMenu, HINSTANCE hInst, HWND hwndStatus, LPWORD lpwIDs);

BOOL WINAPI ShowHideMenuCtl(HWND hWnd, UINT uFlags, LPINT lpInfo);

void WINAPI GetEffectiveClientRect(HWND hWnd, LPRECT lprc, LPINT lpInfo);

/*REVIEW: is this internal? */
#define MINSYSCOMMAND	SC_SIZE

#endif /* NOMENUHELP */

/*/////////////////////////////////////////////////////////////////////////*/

#ifndef NOBTNLIST
/*
 *  BUTTON LISTBOX CONTROL
 *
 *  The Button Listbox control creates an array of buttons that behaves
 *  similar to both a button and a listbox: the array may be scrollable
 *  like a listbox and each listbox item is behaves like a pushbutton
 *  control
 *
 *
 *  SPECIFYING A BUTTONLISTBOX IN THE DIALOG TEMPLATE
 *
 *  The CONTROL statement in the dialog template specifies the
 *  dimensions of each individual button in the x, y, width and height
 *  parameters. The low order byte in the style field specifies the
 *  number of buttons that will be displayed; the actual size of the
 *  displayed control is determined by the number of buttons specified.
 *
 *  For a standard control--no other style bits set--the width of the
 *  control in dialog base units will be
 *      CX = cx * (n + 2/3) + 2
 *  where cx is the width of the button and n is number of buttons
 *  specified. (The 2/3 is for displaying partially visible buttons for
 *  scrolling plus 2 for the control borders.) The control will also be
 *  augmented in the cy direction by the height of the horizontal scroll
 *  bar.
 *
 *  If the BLS_NOSCROLL style is set, no scroll bar will appear and the
 *  button listbox will be limited to displaying the number of buttons
 *  specified and no more. In this case, the width of the control will
 *  be
 *      CX = cx * n + 2
 *
 *  If the BLS_VERTICAL style is set, the entire control goes vertical
 *  and cy should be substituted in the above calculations to determine
 *  CY, the actual height of the displayed control.
 *
 *  The statement
 *
 *  CONTROL  "", IDD_BUTTONLIST, "buttonlistbox", 0x0005 | WS_TABSTOP,
 *           4, 128, 34, 24
 *
 *  creates a scrollable horizontal list of 5 buttons at the position
 *  (4,128) with each button having dimensions (34,24). The entire control
 *  has the tabstop style.
 *
 *
 *  ADDING BUTTONS TO A BUTTONLISTBOX CONTROL
 *
 *  Buttons are added to the listbox in the same manner that items are
 *  added to a standard listbox; however, the messages BL_ADDBUTTON and
 *  BL_INSERTBUTTON must be passed a pointer to a CREATELISTBUTTON
 *  structure in the lParam.
 *
 *  Example:
 *
 *  {
 *      CREATELISTBUTTON clb;
 *      const int numColors = 1;
 *      COLORMAP colorMap;
 *
 *      colorMap.from = BUTTON_MAP_COLOR;   // your background color
 *      colorMap.to   = GetSysColor(COLOR_BTNFACE);
 *
 *      clb.cbSize = sizeof(clb);
 *      clb.dwItemData = BUTTON_1;
 *      clb.hBitmap = CreateMappedBitmap(hInst,BMP_BUTTON,FALSE,
 *                      &colorMap,numColors);
 *      clb.lpszText = "Button 1";
 *      SendMessage(GetDlgItem(hDlg,IDD_BUTTONLIST),
 *                  BL_ADDBUTTON, 0,
 *                  (LPARAM)(CREATELISTBUTTON FAR*)&clb);
 *      DeleteObject(clb.hBitmap);
 *  }
 *
 *  Note that the caller must delete any memory for objects passed in
 *  the CREATELISTBUTTON structure. Also, the CreateMappedBitmap API is
 *  useful for mapping the background color of the button bitmap to the
 *  system color COLOR_BTNFACE for a cleaner visual appearance.
 *
 *  The BL_ADDBUTTON message causes the listbox to be sorted by the
 *  button text whereas the BL_INSERTBUTTON does not cause the list to
 *  be sorted.
 *
 *  The button listbox sends a WM_DELETEITEM message to the control parent
 *  when a button is deleted so that any item data can be cleaned up.
 *
 */

/*REVIEW: should be BUTTONLIST_CLASS */
#define BUTTONLISTBOX           "ButtonListBox"

/* Button List Box Styles */
#define BLS_NUMBUTTONS      0x00FF
#define BLS_VERTICAL        0x0100
#define BLS_NOSCROLL        0x0200

/* Button List Box Messages */
#define BL_ADDBUTTON        (WM_USER+1)
#define BL_DELETEBUTTON     (WM_USER+2)
#define BL_GETCARETINDEX    (WM_USER+3)
#define BL_GETCOUNT         (WM_USER+4)
#define BL_GETCURSEL        (WM_USER+5)
#define BL_GETITEMDATA      (WM_USER+6)
#define BL_GETITEMRECT      (WM_USER+7)
#define BL_GETTEXT          (WM_USER+8)
#define BL_GETTEXTLEN       (WM_USER+9)
#define BL_GETTOPINDEX      (WM_USER+10)
#define BL_INSERTBUTTON     (WM_USER+11)
#define BL_RESETCONTENT     (WM_USER+12)
#define BL_SETCARETINDEX    (WM_USER+13)
#define BL_SETCURSEL        (WM_USER+14)
#define BL_SETITEMDATA      (WM_USER+15)
#define BL_SETTOPINDEX      (WM_USER+16)
#define BL_MSGMAX           (WM_USER+17) /* ;Internal */

/* Button listbox notification codes send in WM_COMMAND */
#define BLN_ERRSPACE        (-2)
#define BLN_SELCHANGE       1
#define BLN_CLICKED         2
#define BLN_SELCANCEL       3
#define BLN_SETFOCUS        4
#define BLN_KILLFOCUS       5

/* Message return values */
#define BL_OKAY             0
#define BL_ERR              (-1)
#define BL_ERRSPACE         (-2)

/* Create structure for
 * BL_ADDBUTTON and
 * BL_INSERTBUTTON
 *   lpCLB = (LPCREATELISTBUTTON)lParam
 */
typedef struct tagCREATELISTBUTTON
{
    UINT        cbSize;     /* size of structure */
    DWORD       dwItemData; /* user defined item data */
                            /* for LB_GETITEMDATA and LB_SETITEMDATA */
    HBITMAP     hBitmap;    /* button bitmap */
    LPCSTR      lpszText;   /* button text */

} CREATELISTBUTTON;
typedef CREATELISTBUTTON FAR* LPCREATELISTBUTTON;

#endif /* NOBTNLIST */

/*/////////////////////////////////////////////////////////////////////////*/

#ifndef NOTRACKBAR
/*
    This control keeps its ranges in LONGs.  but for
    convienence and symetry with scrollbars
    WORD parameters are are used for some messages.
    if you need a range in LONGs don't use any messages 
    that pack values into loword/hiword pairs

    The trackbar messages:
    message         wParam  lParam  return

    TBM_GETPOS      ------  ------  Current logical position of trackbar.
    TBM_GETRANGEMIN ------  ------  Current logical minimum position allowed.
    TBM_GETRANGEMAX ------  ------  Current logical maximum position allowed.
    TBM_SETTIC
    TBM_SETPOS
    TBM_SETRANGEMIN
    TBM_SETRANGEMAX
*/

#define TRACKBAR_CLASS          "MCIWndTrackbar"

/* Trackbar styles */

/* add ticks automatically on TBM_SETRANGE message */
#define TBS_AUTOTICKS           0x0001L


/* Trackbar messages */

/* returns current position (LONG) */
#define TBM_GETPOS              (WM_USER)

/* set the min of the range to LPARAM */
#define TBM_GETRANGEMIN         (WM_USER+1)

/* set the max of the range to LPARAM */
#define TBM_GETRANGEMAX         (WM_USER+2)

/* wParam is index of tick to get (ticks are in the range of min - max) */
#define TBM_GETTIC              (WM_USER+3)

/* wParam is index of tick to set */
#define TBM_SETTIC              (WM_USER+4)

/* set the position to the value of lParam (wParam is the redraw flag) */
#define TBM_SETPOS              (WM_USER+5)

/* LOWORD(lParam) = min, HIWORD(lParam) = max, wParam == fRepaint */
#define TBM_SETRANGE            (WM_USER+6)

/* lParam is range min (use this to keep LONG precision on range) */
#define TBM_SETRANGEMIN         (WM_USER+7)

/* lParam is range max (use this to keep LONG precision on range) */
#define TBM_SETRANGEMAX         (WM_USER+8)

/* remove the ticks */
#define TBM_CLEARTICS           (WM_USER+9)

/* select a range LOWORD(lParam) min, HIWORD(lParam) max */
#define TBM_SETSEL              (WM_USER+10)

/* set selection rang (LONG form) */
#define TBM_SETSELSTART         (WM_USER+11)
#define TBM_SETSELEND           (WM_USER+12)

// #define TBM_SETTICTOK           (WM_USER+13)

/* return a pointer to the list of tics (DWORDS) */
#define TBM_GETPTICS            (WM_USER+14)

/* get the pixel position of a given tick */
#define TBM_GETTICPOS           (WM_USER+15)
/* get the number of tics */
#define TBM_GETNUMTICS          (WM_USER+16)

/* get the selection range */
#define TBM_GETSELSTART         (WM_USER+17)
#define TBM_GETSELEND  	        (WM_USER+18)

/* clear the selection */
#define TBM_CLEARSEL  	        (WM_USER+19)

/*REVIEW: these match the SB_ (scroll bar messages); define them that way? */

#define TB_LINEUP		0
#define TB_LINEDOWN		1
#define TB_PAGEUP		2
#define TB_PAGEDOWN		3
#define TB_THUMBPOSITION	4
#define TB_THUMBTRACK		5
#define TB_TOP			6
#define TB_BOTTOM		7
#define TB_ENDTRACK             8
#endif

/*/////////////////////////////////////////////////////////////////////////*/

#ifndef NODRAGLIST

typedef struct
  {
    UINT uNotification;
    HWND hWnd;
    POINT ptCursor;
  } DRAGLISTINFO, FAR *LPDRAGLISTINFO;

#define DL_BEGINDRAG	(LB_MSGMAX+100)
#define DL_DRAGGING	(LB_MSGMAX+101)
#define DL_DROPPED	(LB_MSGMAX+102)
#define DL_CANCELDRAG	(LB_MSGMAX+103)

#define DL_CURSORSET	0
#define DL_STOPCURSOR	1
#define DL_COPYCURSOR	2
#define DL_MOVECURSOR	3

#define DRAGLISTMSGSTRING "commctrl_DragListMsg"

BOOL WINAPI MakeDragList(HWND hLB);
int WINAPI LBItemFromPt(HWND hLB, POINT pt, BOOL bAutoScroll);
void WINAPI DrawInsert(HWND handParent, HWND hLB, int nItem);

#endif /* NODRAGLIST */

/*/////////////////////////////////////////////////////////////////////////*/

#ifndef NOUPDOWN

/*
// OVERVIEW:
//
// The UpDown control is a simple pair of buttons which increment or
// decrement an integer value.  The operation is similar to a vertical
// scrollbar; except that the control only has line-up and line-down
// functionality, and changes the current position automatically.
//
// The control also can be linked with a companion control, usually an
// "edit" control, to simplify dialog-box management.  This companion is
// termed a "buddy" in this documentation.  Any sibling HWND may be
// assigned as the control's buddy, or the control may be allowed to
// choose one automatically.  Once chosen, the UpDown can size itself to
// match the buddy's right or left border, and/or automatically set the
// text of the buddy control to make the current position visible.
//
// ADDITIONAL NOTES:
//
// The "upper" and "lower" limits must not cover a range larger than 32,767
// positions.  It is acceptable to have the range inverted, i.e., to have
// (lower > upper).  The upper button always moves the current position
// towards the "upper" number, and the lower button always moves towards the
// "lower" number.  If the range is zero (lower == upper), or the control
// is disabled (EnableWindow(hCtrl, FALSE)), the control draws grayed
// arrows in both buttons.  The UDS_WRAP style makes the range cyclic; that
// is, the numbers will wrap once one end of the range is reached.
//
// The buddy window must have the same parent as the UpDown control.
//
// If the buddy window resizes, and the UDS_ALIGN* styles are used, it
// is necessary to send the UDM_SETBUDDY message to re-anchor the UpDown
// control on the appropriate border of the buddy window.
//
// The UDS_AUTOBUDDY style uses GetWindow(hCtrl, GW_HWNDPREV) to pick
// the best buddy window.  In the case of a DIALOG resource, this will
// choose the previous control listed in the resource script.  If the
// windows will change in Z-order, sending UDM_SETBUDDY with a NULL handle
// will pick a new buddy; otherwise the original auto-buddy choice is
// maintained.
//
// The UDS_SETBUDDYINT style uses its own SetDlgItemInt-style
// functionality to set the caption text of the buddy.  All WIN.INI [Intl]
// values are honored by this routine.
//
// The UDS_ARROWKEYS style will subclass the buddy window, in order to steal
// the VK_UP and VK_DOWN arrow key messages.
*/

/*/////////////////////////////////////////////////////////////////////////*/

/* Structures */

typedef struct tagUDACCEL
{
	UINT nSec;
	UINT nInc;
} UDACCEL, FAR *LPUDACCEL;

#define UD_MAXVAL	0x7fff
#define UD_MINVAL	(-UD_MAXVAL)


/* STYLE BITS */

#define UDS_WRAP		0x0001
#define UDS_SETBUDDYINT		0x0002
#define UDS_ALIGNRIGHT		0x0004
#define UDS_ALIGNLEFT		0x0008
#define UDS_AUTOBUDDY		0x0010
#define UDS_ARROWKEYS		0x0020


/* MESSAGES */

#define UDM_SETRANGE		(WM_USER+101)
	/* wParam: not used, 0
	// lParam: short LOWORD, new upper; short HIWORD, new lower limit
	// return: not used
	*/

#define UDM_GETRANGE		(WM_USER+102)
	/* wParam: not used, 0
	// lParam: not used, 0
	// return: short LOWORD, upper; short HIWORD, lower limit
	*/

#define UDM_SETPOS		(WM_USER+103)
	/* wParam: not used, 0
	// lParam: short LOWORD, new pos; HIWORD not used, 0
	// return: short LOWORD, old pos; HIWORD not used
	*/

#define UDM_GETPOS		(WM_USER+104)
	/* wParam: not used, 0
	// lParam: not used, 0
	// return: short LOWORD, current pos; HIWORD not used
	*/

#define UDM_SETBUDDY		(WM_USER+105)
	/* wParam: HWND, new buddy
	// lParam: not used, 0
	// return: HWND LOWORD, old buddy; HIWORD not used
	*/

#define UDM_GETBUDDY		(WM_USER+106)
	/* wParam: not used, 0
	// lParam: not used, 0
	// return: HWND LOWORD, current buddy; HIWORD not used
	*/

#define UDM_SETACCEL		(WM_USER+107)
	/* wParam: UINT, number of acceleration steps
	// lParam: LPUDACCEL, pointer to array of UDACCEL elements
	//         Elements should be sorted in increasing nSec order.
	// return: BOOL LOWORD, nonzero if successful; HIWORD not used
	*/

#define UDM_GETACCEL		(WM_USER+108)
	/* wParam: UINT, number of elements in the UDACCEL array
	// lParam: LPUDACCEL, pointer to UDACCEL buffer to receive array
	// return: UINT LOWORD, number of elements returned in buffer
	*/

#define UDM_SETBASE		(WM_USER+109)
	/* wParam: UINT, new radix base (10 for decimal, 16 for hex, etc.)
	// lParam: not used, 0
	// return: not used
	*/
#define UDM_GETBASE		(WM_USER+110)
	/* wParam: not used, 0
	// lParam: not used, 0
	// return: UINT LOWORD, current radix base; HIWORD not used
	*/

/* NOTIFICATIONS */

/* WM_VSCROLL
// Note that unlike a scrollbar, the position is automatically changed by
// the control, and the LOWORD(lParam) is always the new position.  Only
// SB_THUMBTRACK and SB_THUMBPOSITION scroll codes are sent in the wParam.
*/

/* HELPER APIs */

#define UPDOWN_CLASS "msctls_updown"
HWND WINAPI CreateUpDownControl(DWORD dwStyle, int x, int y, int cx, int cy,
                                HWND hParent, int nID, HINSTANCE hInst,
                                HWND hBuddy,
				int nUpper, int nLower, int nPos);
	/* Does the CreateWindow call followed by setting the various
	// state information:
	//	hBuddy	The companion control (usually an "edit").
	//	nUpper	The range limit corresponding to the upper button.
	//	nLower	The range limit corresponding to the lower button.
	//	nPos	The initial position.
	// Returns the handle to the control or NULL on failure.
	*/

#endif /* NOUPDOWN */

/*/////////////////////////////////////////////////////////////////////////*/

#ifndef NOPROGRESS

/*
// OVERVIEW:
//
// The progress bar control is a "gas gauge" that can be used to show the
// progress of a lengthy operation.
//
// The application sets the range and current position (similar to a
// scrollbar) and has the ability to advance the current position in
// a variety of ways.
//
// Text can be displayed in the progress bar as either a percentage
// of the entire range (using the PBS_SHOWPERCENT style) or as the 
// value of the current position (using the PBS_SHOWPOS style).  If
// neither bit is set, no text is shown in the bar.
//
// When PBM_STEPIT is used to advance the current position, the gauge
// will wrap when it reaches the end and start again at the start.
// The position is clamped at either end in other cases.
//
*/

/*/////////////////////////////////////////////////////////////////////////*/

/* STYLE BITS */

#define PBS_SHOWPERCENT		0x01
#define PBS_SHOWPOS		0x02

/* MESSAGES */

#define PBM_SETRANGE         (WM_USER+1)
	/* wParam: not used, 0
	// lParam: int LOWORD, bottom of range; int HIWORD top of range
	// return: int LOWORD, previous bottom; int HIWORD old top
	*/
#define PBM_SETPOS           (WM_USER+2)
	/* wParam: int new position
	// lParam: not used, 0
	// return: int LOWORD, previous position; HIWORD not used
	*/
#define PBM_DELTAPOS         (WM_USER+3)
	/* wParam: int amount to advance current position
	// lParam: not used, 0
	// return: int LOWORD, previous position; HIWORD not used
	*/
#define PBM_SETSTEP          (WM_USER+4)
	/* wParam: int new step
	// lParam: not used, 0
	// return: int LOWORD, previous step; HIWORD not used
	*/
#define PBM_STEPIT	     (WM_USER+5)
        /* advance current position by current step
	// wParam: not used 0
	// lParam: not used, 0
	// return: int LOWORD, previous position; HIWORD not used
	*/

#define PROGRESS_CLASS "msctls_progress"

#endif /* NOPROGRESS */

/*/////////////////////////////////////////////////////////////////////////*/

/*REVIEW: move these to their appropriate control sections. */

/* Note that the set of HBN_* and TBN_* defines must be a disjoint set so
 * that MenuHelp can tell them apart.
 */

/* These are in the HIWORD of lParam in WM_COMMAND messages sent from a
 * header bar when the user adjusts the headers with the mouse or keyboard.
 */
#define HBN_BEGINDRAG	0x0101
#define HBN_DRAGGING	0x0102
#define HBN_ENDDRAG	0x0103

/* These are in the HIWORD of lParam in WM_COMMAND messages sent from a
 * header bar when the user adjusts the headers with the keyboard.
 */
#define HBN_BEGINADJUST	0x0111
#define HBN_ENDADJUST	0x0112

/* These are in the HIWORD of lParam in WM_COMMAND messages sent from a
 * tool bar.  If the left button is pressed and then released in a single
 * "button" of a tool bar, then a WM_COMMAND message will be sent with wParam
 * being the id of the button.
 */
#define TBN_BEGINDRAG	0x0201
#define TBN_ENDDRAG	0x0203

/* These are in the HIWORD of lParam in WM_COMMAND messages sent from a
 * tool bar.  The TBN_BEGINADJUST message is sent before the "insert"
 * dialog appears.  The app must return a handle (which will
 * NOT be freed by the toolbar) to an ADJUSTINFO struct for the TBN_ADJUSTINFO
 * message; the LOWORD of lParam is the index of the button whose info should
 * be retrieved.  The app can clean up in the TBN_ENDADJUST message.
 * The app should reset the toolbar on the TBN_RESET message.
 */
#define TBN_BEGINADJUST	0x0204
#define TBN_ADJUSTINFO	0x0205
#define TBN_ENDADJUST	0x0206
#define TBN_RESET	0x0207

/* These are in the HIWORD of lParam in WM_COMMAND messages sent from a
 * tool bar.  The LOWORD is the index where the button is or will be.
 * If the app returns FALSE from either of these during a button move, then
 * the button will not be moved.  If the app returns FALSE to the INSERT
 * when the toolbar tries to add buttons, then the insert dialog will not
 * come up.  TBN_TOOLBARCHANGE is sent whenever any button is added, moved,
 * or deleted from the toolbar by the user, so the app can do stuff.
 */
#define TBN_QUERYINSERT	0x0208
#define TBN_QUERYDELETE	0x0209
#define TBN_TOOLBARCHANGE	0x020a

/* This is in the HIWORD of lParam in a WM_COMMAND message.  It notifies the
 * parent of a toolbar that the HELP button was pressed in the toolbar
 * customize dialog.  The dialog window handle is in the LOWORD of lParam.
 */
#define TBN_CUSTHELP	0x020b

/* Note that the following flags are checked every time the window gets a
 * WM_SIZE message, so the style of the window can be changed "on-the-fly".
 * If NORESIZE is set, then the app is responsible for all control placement
 * and sizing.  If NOPARENTALIGN is set, then the app is responsible for
 * placement.  If neither is set, the app just needs to send a WM_SIZE
 * message for the window to be positioned and sized correctly whenever the
 * parent window size changes.
 * Note that for STATUS bars, CCS_BOTTOM is the default, for HEADER bars,
 * CCS_NOMOVEY is the default, and for TOOL bars, CCS_TOP is the default.
 */
#define CCS_TOP			0x00000001L
/* This flag means the status bar should be "top" aligned.  If the
 * NOPARENTALIGN flag is set, then the control keeps the same top, left, and
 * width measurements, but the height is adjusted to the default, otherwise
 * the status bar is positioned at the top of the parent window such that
 * its client area is as wide as the parent window and its client origin is
 * the same as its parent.
 * Similarly, if this flag is not set, the control is bottom-aligned, either
 * with its original rect or its parent rect, depending on the NOPARENTALIGN
 * flag.
 */
#define CCS_NOMOVEY		0x00000002L
/* This flag means the control may be resized and moved horizontally (if the
 * CCS_NORESIZE flag is not set), but it will not move vertically when a
 * WM_SIZE message comes through.
 */
#define CCS_BOTTOM		0x00000003L
/* Same as CCS_TOP, only on the bottom.
 */
#define CCS_NORESIZE		0x00000004L
/* This flag means that the size given when creating or resizing is exact,
 * and the control should not resize itself to the default height or width
 */
#define CCS_NOPARENTALIGN	0x00000008L
/* This flag means that the control should not "snap" to the top or bottom
 * or the parent window, but should keep the same placement it was given
 */
#define CCS_NOHILITE		0x00000010L
/* Don't draw the one pixel highlight at the top of the control
 */
#define CCS_ADJUSTABLE		0x00000020L
/* This allows a toolbar (header bar?) to be configured by the user.
 */
#define CCS_NODIVIDER		0x00000040L
/* Don't draw the 2 pixel highlight at top of control (toolbar)
 */

/*/////////////////////////////////////////////////////////////////////////*/

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif

#endif /* _INC_COMMCTRL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd\toolbar.c ===
/*
**
** Toolbar.c
**
** This is it, the incredibly famous toolbar control.  Most of
** the customization stuff is in another file.
**
*/
#include "ctlspriv.h"
#include <windowsx.h>

#define Reference(x) ((x)=(x))

#ifndef _WIN32
// we need both ansi and unicode constant strings
#define SZCODE static char _based(_segname("_CODE"))
#define SZCODEA static char _based(_segname("_CODE"))
#endif

TCHAR aszToolbarClassName[] = TOOLBARCLASSNAME;

SZCODE szUSER[] = TEXT("USER.EXE");
SZCODEA szDrawFrameControl[] = "DrawFrameControl";
SZCODE szKernel[] = TEXT("KERNEL.EXE");
SZCODEA szWriteProfileStruct[] = "WritePrivateProfileStruct";

// these values are defined by the UI gods...
#define DEFAULTBITMAPX 16
#define DEFAULTBITMAPY 15

#define DEFAULTBUTTONX 24
#define DEFAULTBUTTONY 22

// horizontal/vertical space taken up by button chisel, sides,
// and a 1 pixel margin.  used in GrowToolbar.
#define XSLOP 7
#define YSLOP 6

#define SLOPTOP 1
#define SLOPBOT 1
#define SLOPLFT 8

static int dxButtonSep = 8;
static int xFirstButton = SLOPLFT;  //!!! was 8

static int iInitCount = 0;

static int nSelectedBM = -1;
static HDC hdcGlyphs = NULL;           // globals for fast drawing
static HDC hdcMono = NULL;
static HBITMAP hbmMono = NULL;
static HBITMAP hbmDefault = NULL;

static HDC hdcButton = NULL;           // contains hbmFace (when it exists)
static HBITMAP hbmFace = NULL;
static int dxFace, dyFace;             // current dimensions of hbmFace (2*dxFace)

static HDC hdcFaceCache = NULL;        // used for button cache

static HFONT hIconFont = NULL;         // font used for strings in buttons
static int yIconFont;                  // height of the font

static BOOL g_bUseDFC = FALSE;         // use DrawFrameControl, if available
static BOOL g_bProfStruct = FALSE;     // use PrivateProfileStruct routines
static WORD g_dxOverlap = 1;           // overlap between buttons

static WORD wStateMasks[] = {
    TBSTATE_ENABLED,
    TBSTATE_CHECKED,
    TBSTATE_PRESSED,
    TBSTATE_HIDDEN,
    TBSTATE_INDETERMINATE
};

LRESULT CALLBACK _loadds ToolbarWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);

#define HeightWithString(h) (h + yIconFont + 1)

static BOOL NEAR PASCAL InitGlobalObjects(void)
{
    LOGFONT lf;
    TEXTMETRIC tm;
    HFONT hOldFont;

    iInitCount++;

    if (iInitCount != 1)
        return TRUE;

    hdcGlyphs = CreateCompatibleDC(NULL);
    if (!hdcGlyphs)
        return FALSE;
    hdcMono = CreateCompatibleDC(NULL);
    if (!hdcMono)
        return FALSE;

    hbmMono = CreateBitmap(DEFAULTBUTTONX, DEFAULTBUTTONY, 1, 1, NULL);
    if (!hbmMono)
        return FALSE;

    hbmDefault = SelectObject(hdcMono, hbmMono);

    hdcButton = CreateCompatibleDC(NULL);
    if (!hdcButton)
        return FALSE;
    hdcFaceCache = CreateCompatibleDC(NULL);
    if (!hdcFaceCache)
        return FALSE;

    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0);
    hIconFont = CreateFontIndirect(&lf);
    if (!hIconFont)
	return FALSE;

    hOldFont = SelectObject(hdcMono, hIconFont);
    GetTextMetrics(hdcMono, &tm);
    yIconFont = tm.tmHeight;
    if (hOldFont)
	SelectObject(hdcMono, hOldFont);

#if WINVER >= 0x0400
    // set a global flag to see if USER will draw for us
    if (GetProcAddress(LoadLibrary(szUSER), szDrawFrameControl))
    {
	g_bUseDFC = TRUE;
	g_dxOverlap = 0;	// buttons do NOT overlap with new look
    }
    // set a global flag to see if KERNEL does profile structs
    if (GetProcAddress(LoadLibrary(szKernel), szWriteProfileStruct))
        g_bProfStruct = TRUE;
#endif

    return TRUE;
}


static BOOL NEAR PASCAL FreeGlobalObjects(void)
{
    iInitCount--;

    if (iInitCount != 0)
        return TRUE;

    if (hdcMono) {
	if (hbmDefault)
	    SelectObject(hdcMono, hbmDefault);
	DeleteDC(hdcMono);		// toast the DCs
    }
    hdcMono = NULL;

    if (hdcGlyphs)
	DeleteDC(hdcGlyphs);
    hdcGlyphs = NULL;
    if (hdcFaceCache)
	DeleteDC(hdcFaceCache);
    hdcFaceCache = NULL;

    if (hdcButton) {
	if (hbmDefault)
	    SelectObject(hdcButton, hbmDefault);
	DeleteDC(hdcButton);
    }
    hdcButton = NULL;

    if (hbmFace)
	DeleteObject(hbmFace);
    hbmFace = NULL;

    if (hbmMono)
	DeleteObject(hbmMono);
    hbmMono = NULL;

    if (hIconFont)
	DeleteObject(hIconFont);
    hIconFont = NULL;
}

HWND WINAPI CreateToolbarEx(HWND hwnd, DWORD ws, UINT wID, int nBitmaps,
			HINSTANCE hBMInst, UINT wBMID, LPCTBBUTTON lpButtons,
			int iNumButtons, int dxButton, int dyButton,
			int dxBitmap, int dyBitmap, UINT uStructSize)
{

    HWND hwndToolbar;

    hwndToolbar = CreateWindow(aszToolbarClassName, NULL, WS_CHILD | ws,
	      0, 0, 100, 30, hwnd, (HMENU)wID,
	      GetWindowInstance(hwnd),NULL);
    if (!hwndToolbar)
	goto Error1;

    SendMessage(hwndToolbar, TB_BUTTONSTRUCTSIZE, uStructSize, 0L);

    if (dxBitmap && dyBitmap)
	if (!SendMessage(hwndToolbar, TB_SETBITMAPSIZE, 0, MAKELONG(dxBitmap, dyBitmap)))
	{
	    //!!!! do we actually need to deal with this?
	    DestroyWindow(hwndToolbar);
	    hwndToolbar = NULL;
	    goto Error1;
	}

    if (dxButton && dyButton)
	if (!SendMessage(hwndToolbar, TB_SETBUTTONSIZE, 0, MAKELONG(dxButton, dyButton)))
	{
	    //!!!! do we actually need to deal with this?
	    DestroyWindow(hwndToolbar);
	    hwndToolbar = NULL;
	    goto Error1;
	}
#ifdef _WIN32
    {
	TB_ADDBITMAPINFO tbai;

	tbai.idResource = wBMID;
	tbai.hBitmap = hBMInst;

	SendMessage(hwndToolbar, TB_ADDBITMAP, nBitmaps, (LPARAM) &tbai);
    }
#else
    SendMessage(hwndToolbar, TB_ADDBITMAP, nBitmaps, MAKELONG(hBMInst, wBMID));
#endif
    SendMessage(hwndToolbar, TB_ADDBUTTONS, iNumButtons, (LPARAM)lpButtons);

Error1:
    return hwndToolbar;
}



BOOL FAR PASCAL InitToolbarClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    if (!GetClassInfo(hInstance, aszToolbarClassName, &wc)) {

	wc.lpszClassName = aszToolbarClassName;
	wc.style	 = CS_GLOBALCLASS | CS_DBLCLKS;
	wc.lpfnWndProc	 = (WNDPROC)ToolbarWndProc;
	wc.cbClsExtra	 = 0;
	wc.cbWndExtra	 = sizeof(PTBSTATE);
	wc.hInstance	 = hInstance;
	wc.hIcon	 = NULL;
	wc.hCursor	 = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
	wc.lpszMenuName	 = NULL;

	if (!RegisterClass(&wc))
	    return FALSE;
    }

    return TRUE;
}



#define BEVEL   2
#define FRAME   1

static void NEAR PASCAL PatB(HDC hdc,int x,int y,int dx,int dy, DWORD rgb)
{
    RECT    rc;

    SetBkColor(hdc,rgb);
    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}

static void NEAR PASCAL DrawString(HDC hdc, int x, int y, int dx, PTSTR pszString)
{
    int oldMode;
    DWORD oldTextColor;
    HFONT oldhFont;
    DWORD dwExt;
    int len;

    oldMode = SetBkMode(hdc, TRANSPARENT);
    oldTextColor = SetTextColor(hdc, 0L);
    oldhFont = SelectObject(hdc, hIconFont);

    len = lstrlen(pszString);
#ifdef _WIN32
    {
        SIZE size;
        GetTextExtentPoint(hdc, (LPTSTR)pszString, len, &size);
        dwExt = LOWORD(size.cx) | (LOWORD(size.cy) >> 8);
    }
#else
    dwExt = GetTextExtent(hdc, (LPTSTR)pszString, len);
#endif
    // center the string horizontally
    x += (dx - LOWORD(dwExt) - 1)/2;

    TextOut(hdc, x, y, (LPTSTR)pszString, len);

    if (oldhFont)
	SelectObject(hdc, oldhFont);
    SetTextColor(hdc, oldTextColor);
    SetBkMode(hdc, oldMode);
}

// create a mono bitmap mask:
//   1's where color == COLOR_BTNFACE || COLOR_HILIGHT
//   0's everywhere else

static void NEAR PASCAL CreateMask(PTBSTATE pTBState, PTBBUTTON pTBButton, int xoffset, int yoffset, int dx, int dy)
{
    PTSTR pFoo;

    // initalize whole area with 1's
    PatBlt(hdcMono, 0, 0, dx, dy, WHITENESS);

    // create mask based on color bitmap
    // convert this to 1's
    SetBkColor(hdcGlyphs, rgbFace);
    BitBlt(hdcMono, xoffset, yoffset, pTBState->iDxBitmap, pTBState->iDyBitmap,
    	hdcGlyphs, pTBButton->iBitmap * pTBState->iDxBitmap, 0, SRCCOPY);
    // convert this to 1's
    SetBkColor(hdcGlyphs, rgbHilight);
    // OR in the new 1's
    BitBlt(hdcMono, xoffset, yoffset, pTBState->iDxBitmap, pTBState->iDyBitmap,
    	hdcGlyphs, pTBButton->iBitmap * pTBState->iDxBitmap, 0, SRCPAINT);

    if (pTBButton->iString != -1 && (pTBButton->iString < pTBState->nStrings))
    {
	pFoo = pTBState->pStrings[pTBButton->iString];
	DrawString(hdcMono, 1, yoffset + pTBState->iDyBitmap + 1, dx, pFoo);
    }
}


/* Given a button number, the corresponding bitmap is loaded and selected in,
 * and the Window origin set.
 * Returns NULL on Error, 1 if the necessary bitmap is already selected,
 * or the old bitmap otherwise.
 */
static HBITMAP FAR PASCAL SelectBM(HDC hDC, PTBSTATE pTBState, int nButton)
{
  PTBBMINFO pTemp;
  HBITMAP hRet;
  int nBitmap, nTot;

  for (pTemp=pTBState->pBitmaps, nBitmap=0, nTot=0; ; ++pTemp, ++nBitmap)
    {
      if (nBitmap >= pTBState->nBitmaps)
	  return(NULL);

      if (nButton < nTot+pTemp->nButtons)
	  break;

      nTot += pTemp->nButtons;
    }

  /* Special case when the required bitmap is already selected
   */
  if (nBitmap == nSelectedBM)
      return((HBITMAP)1);

  if (!pTemp->hbm || (hRet=SelectObject(hDC, pTemp->hbm))==NULL)
    {
      if (pTemp->hbm)
	  DeleteObject(pTemp->hbm);

      if (pTemp->hInst)
	  pTemp->hbm = CreateMappedBitmap(pTemp->hInst, pTemp->wID,
		TRUE, NULL, 0);
      else
	  pTemp->hbm = (HBITMAP)pTemp->wID;

      if (!pTemp->hbm || (hRet=SelectObject(hDC, pTemp->hbm))==NULL)
	  return(NULL);
    }

  nSelectedBM = nBitmap;
#ifdef _WIN32
  SetWindowOrgEx(hDC, nTot * pTBState->iDxBitmap, 0, NULL);
#else // _WIN32
  SetWindowOrg(hDC, nTot * pTBState->iDxBitmap, 0);
#endif

  return(hRet);
}

static void FAR PASCAL DrawBlankButton(HDC hdc, int x, int y, int dx, int dy, WORD state, WORD wButtType)
{
#if WINVER >= 0x0400
    RECT r1;
#endif

    // face color
    PatB(hdc, x, y, dx, dy, rgbFace);

#if WINVER >= 0x0400
    if (g_bUseDFC)
    {
	r1.left = x;
	r1.top = y;
	r1.right = x + dx;
	r1.bottom = y + dy;

	DrawFrameControl(hdc, &r1, wButtType,
		(state & TBSTATE_PRESSED) ? DFCS_PUSHED : 0);
    }
    else
#endif
    {
	if (state & TBSTATE_PRESSED) {
	    PatB(hdc, x + 1, y, dx - 2, 1, rgbFrame);
	    PatB(hdc, x + 1, y + dy - 1, dx - 2, 1, rgbFrame);
	    PatB(hdc, x, y + 1, 1, dy - 2, rgbFrame);
	    PatB(hdc, x + dx - 1, y +1, 1, dy - 2, rgbFrame);
	    PatB(hdc, x + 1, y + 1, 1, dy-2, rgbShadow);
	    PatB(hdc, x + 1, y + 1, dx-2, 1, rgbShadow);
	}
	else {
	    PatB(hdc, x + 1, y, dx - 2, 1, rgbFrame);
	    PatB(hdc, x + 1, y + dy - 1, dx - 2, 1, rgbFrame);
	    PatB(hdc, x, y + 1, 1, dy - 2, rgbFrame);
	    PatB(hdc, x + dx - 1, y + 1, 1, dy - 2, rgbFrame);
	    dx -= 2;
	    dy -= 2;
	    PatB(hdc, x + 1, y + 1, 1, dy - 1, rgbHilight);
	    PatB(hdc, x + 1, y + 1, dx - 1, 1, rgbHilight);
	    PatB(hdc, x + dx, y + 1, 1, dy, rgbShadow);
	    PatB(hdc, x + 1, y + dy, dx, 1,   rgbShadow);
	    PatB(hdc, x + dx - 1, y + 2, 1, dy - 2, rgbShadow);
	    PatB(hdc, x + 2, y + dy - 1, dx - 2, 1,   rgbShadow);
	}
    }
}

#define DSPDxax	 0x00E20746
#define PSDPxax  0x00B8074A

#define FillBkColor(hdc, prc) ExtTextOut(hdc,0,0,ETO_OPAQUE,prc,NULL,0,NULL)

static void NEAR PASCAL DrawFace(PTBSTATE pTBState, PTBBUTTON ptButton, HDC hdc, int x, int y,
			int offx, int offy, int dx)
{
    PTSTR pFoo;

    BitBlt(hdc, x + offx, y + offy, pTBState->iDxBitmap, pTBState->iDyBitmap,
	    hdcGlyphs, ptButton->iBitmap * pTBState->iDxBitmap, 0, SRCCOPY);

    if (ptButton->iString != -1 && (ptButton->iString < pTBState->nStrings))
    {
	pFoo = pTBState->pStrings[ptButton->iString];
	DrawString(hdc, x + 1, y + offy + pTBState->iDyBitmap + 1, dx, pFoo);
    }
}

static void FAR PASCAL DrawButton(HDC hdc, int x, int y, int dx, int dy, PTBSTATE pTBState, PTBBUTTON ptButton, BOOL bFaceCache)
{
    int yOffset;
    HBRUSH hbrOld, hbr;
    BOOL bMaskCreated = FALSE;
    BYTE state;
    int xButton = 0;		// assume button is down
    int dxFace, dyFace;
    int xCenterOffset;

    dxFace = dx - 4;
    dyFace = dy - 4;

    // make local copy of state and do proper overriding
    state = ptButton->fsState;
    if (state & TBSTATE_INDETERMINATE) {
	if (state & TBSTATE_PRESSED)
	    state &= ~TBSTATE_INDETERMINATE;
	else if (state & TBSTATE_ENABLED)
	    state = TBSTATE_INDETERMINATE;
	else
	    state &= ~TBSTATE_INDETERMINATE;
    }

    // get the proper button look-- up or down.
    if (!(state & (TBSTATE_PRESSED | TBSTATE_CHECKED))) {
	xButton = dx;	// use 'up' version of button
    }
    if (bFaceCache)
	BitBlt(hdc, x, y, dx, dy, hdcButton, xButton, 0, SRCCOPY);
    else
	DrawBlankButton(hdc, x, y, dx, dy, state, pTBState->wButtonType);


    // move coordinates inside border and away from upper left highlight.
    // the extents change accordingly.
    x += 2;
    y += 2;

    if (!SelectBM(hdcGlyphs, pTBState, ptButton->iBitmap))
	return;

    // calculate offset of face from (x,y).  y is always from the top,
    // so the offset is easy.  x needs to be centered in face.
    yOffset = 1;
    xCenterOffset = (dxFace - pTBState->iDxBitmap)/2;
    if (state & (TBSTATE_PRESSED | TBSTATE_CHECKED))
    {
	// pressed state moves down and to the right
	xCenterOffset++;
        yOffset++;
    }

    // now put on the face
    if (state & TBSTATE_ENABLED) {
        // regular version
	DrawFace(pTBState, ptButton, hdc, x, y, xCenterOffset, yOffset, dxFace);
    } else {
        // disabled version (or indeterminate)
	bMaskCreated = TRUE;
	CreateMask(pTBState, ptButton, xCenterOffset, yOffset, dxFace, dyFace);

	SetTextColor(hdc, 0L);	 // 0's in mono -> 0 (for ROP)
	SetBkColor(hdc, 0x00FFFFFF); // 1's in mono -> 1

	// draw glyph's white understrike
	if (!(state & TBSTATE_INDETERMINATE)) {
	    hbr = CreateSolidBrush(rgbHilight);
	    if (hbr) {
	        hbrOld = SelectObject(hdc, hbr);
	        if (hbrOld) {
	            // draw hilight color where we have 0's in the mask
                    BitBlt(hdc, x + 1, y + 1, dxFace, dyFace, hdcMono, 0, 0, PSDPxax);
	            SelectObject(hdc, hbrOld);
	        }
	        DeleteObject(hbr);
	    }
	}

	// gray out glyph
	hbr = CreateSolidBrush(rgbShadow);
	if (hbr) {
	    hbrOld = SelectObject(hdc, hbr);
	    if (hbrOld) {
	        // draw the shadow color where we have 0's in the mask
                BitBlt(hdc, x, y, dxFace, dyFace, hdcMono, 0, 0, PSDPxax);
	        SelectObject(hdc, hbrOld);
	    }
	    DeleteObject(hbr);
	}

	if (state & TBSTATE_CHECKED) {
	    BitBlt(hdcMono, 1, 1, dxFace - 1, dyFace - 1, hdcMono, 0, 0, SRCAND);
	}
    }

    if (state & (TBSTATE_CHECKED | TBSTATE_INDETERMINATE)) {

        hbrOld = SelectObject(hdc, hbrDither);
	if (hbrOld) {

	    if (!bMaskCreated)
	        CreateMask(pTBState, ptButton, xCenterOffset, yOffset, dxFace, dyFace);

	    SetTextColor(hdc, 0L);		// 0 -> 0
	    SetBkColor(hdc, 0x00FFFFFF);	// 1 -> 1

	    // only draw the dither brush where the mask is 1's
            BitBlt(hdc, x, y, dxFace, dyFace, hdcMono, 0, 0, DSPDxax);
	
	    SelectObject(hdc, hbrOld);
	}
    }
}

static void NEAR PASCAL FlushButtonCache(PTBSTATE pTBState)
{
    if (pTBState->hbmCache) {
	DeleteObject(pTBState->hbmCache);
	pTBState->hbmCache = 0;
    }
}

// make sure that hbmMono is big enough to do masks for this
// size of button.  if not, fail.
static BOOL NEAR PASCAL CheckMonoMask(int width, int height)
{
    BITMAP bm;
    HBITMAP hbmTemp;

    GetObject(hbmMono, sizeof(BITMAP), &bm);
    if (width > bm.bmWidth || height > bm.bmHeight) {
	hbmTemp = CreateBitmap(width, height, 1, 1, NULL);
	if (!hbmTemp)
	    return FALSE;
	SelectObject(hdcMono, hbmTemp);
	DeleteObject(hbmMono);
	hbmMono = hbmTemp;
    }
    return TRUE;
}

/*
** GrowToolbar
**
** Attempt to grow the button size.
**
** The calling function can either specify a new internal measurement
** or a new external measurement.
*/
static BOOL NEAR PASCAL GrowToolbar(PTBSTATE pTBState, int newButWidth, int newButHeight, BOOL bInside)
{
    // if growing based on inside measurement, get full size
    if (bInside) {
	newButHeight += YSLOP;
	newButWidth += XSLOP;
	
	// if toolbar already has strings, don't shrink width it because it
	// might clip room for the string
	if ((newButWidth < pTBState->iButWidth) && pTBState->nStrings)
	    newButWidth = pTBState->iButWidth;
    }
    else {
    	if (newButHeight < pTBState->iButHeight)
	    newButHeight = pTBState->iButHeight;
    	if (newButWidth < pTBState->iButWidth)
	    newButWidth = pTBState->iButWidth;
    }

    // if the size of the toolbar is actually growing, see if shadow
    // bitmaps can be made sufficiently large.
    if ((newButWidth > pTBState->iButWidth) || (newButHeight > pTBState->iButHeight)) {
	if (!CheckMonoMask(newButWidth, newButHeight))
	    return(FALSE);
    }

    pTBState->iButWidth = newButWidth;
    pTBState->iButHeight = newButHeight;

//!!!ACK ACK ACK ACK
#if 0
    // bar height has 2 pixels above, 3 below
    pTBState->iBarHeight = pTBState->iButHeight + 5;
    pTBState->iYPos = 2;
#else
    pTBState->iBarHeight = pTBState->iButHeight + SLOPTOP+SLOPBOT;
    pTBState->iYPos = SLOPTOP;
#endif

    return TRUE;
}

static BOOL NEAR PASCAL SetBitmapSize(PTBSTATE pTBState, int width, int height)
{
    int realh = height;

    if (pTBState->nStrings)
	realh = HeightWithString(height);

    if (GrowToolbar(pTBState, width, realh, TRUE)) {
	pTBState->iDxBitmap = width;
	pTBState->iDyBitmap = height;
	return TRUE;
    }
    return FALSE;
}

static void NEAR PASCAL UpdateTBState(PTBSTATE pTBState)
{
	int i;
	PTBBMINFO pBitmap;

	if (pTBState->nSysColorChanges!=nSysColorChanges)
	{
		/* Reset all of the bitmaps if the sys colors have changed
		 * since the last time the bitmaps were created.
		 */
		for (i=pTBState->nBitmaps-1, pBitmap=pTBState->pBitmaps; i>=0;
			--i, ++pBitmap)
		{
			if (pBitmap->hInst && pBitmap->hbm)
			{
				DeleteObject(pBitmap->hbm);
				pBitmap->hbm = NULL;
			}
		}

		FlushButtonCache(pTBState);

		// now we're updated to latest color scheme
		pTBState->nSysColorChanges = nSysColorChanges;
	}
}

#define CACHE 0x01
#define BUILD 0x02

static void NEAR PASCAL ToolbarPaint(HWND hWnd, PTBSTATE pTBState)
{
    RECT rc;
    HDC hdc;
    PAINTSTRUCT ps;
    int iButton, xButton, yButton;
    int cButtons = pTBState->iNumButtons;
    PTBBUTTON pAllButtons = pTBState->Buttons;
    HBITMAP hbmOldGlyphs;
    int xCache = 0;
    WORD wFlags = 0;
    int iCacheWidth = 0;
    HBITMAP hbmTemp;
    BOOL bFaceCache = TRUE;		// assume face cache exists
    int dx,dy;

    CheckSysColors();
    UpdateTBState(pTBState);

    hdc = BeginPaint(hWnd, &ps);

    GetClientRect(hWnd, &rc);
    if (!rc.right)
	goto Error1;

    dx = pTBState->iButWidth;
    dy = pTBState->iButHeight;

    // setup global stuff for fast painting

    /* We need to kick-start the bitmap selection process.
     */
    nSelectedBM = -1;
    hbmOldGlyphs = SelectBM(hdcGlyphs, pTBState, 0);
    if (!hbmOldGlyphs)
	goto Error1;

    yButton = pTBState->iYPos;
    rc.top = yButton;
    rc.bottom = yButton + dy;

    if (!(pTBState->hbmCache)) {
	// calculate the width of the cache.
	for (iButton = 0; iButton < cButtons; iButton++) {
	    if (!(pAllButtons[iButton].fsState & TBSTATE_HIDDEN) &&
			!(pAllButtons[iButton].fsStyle & TBSTYLE_SEP))
		iCacheWidth += pTBState->iButWidth;
	}
	pTBState->hbmCache = CreateCompatibleBitmap(hdcGlyphs, iCacheWidth, dy);
	wFlags |= BUILD;

	// if needed, create or enlarge bitmap for pre-building button states
	if (!(hbmFace && (dx <= dxFace) && (dy <= dyFace))) {
	    hbmTemp = CreateCompatibleBitmap(hdcGlyphs, 2*dx, dy);
	    if (hbmTemp) {
		SelectObject(hdcButton, hbmTemp);
		if (hbmFace)
		    DeleteObject(hbmFace);
		hbmFace = hbmTemp;
		dxFace = dx;
		dyFace = dy;
	    }
	    else
		bFaceCache = FALSE;
	}
    }
    if (pTBState->hbmCache) {
        SelectObject(hdcFaceCache,pTBState->hbmCache);
	wFlags |= CACHE;
    }
    else
        wFlags = 0;

    if (bFaceCache) {
	DrawBlankButton(hdcButton, 0, 0, dx, dy, TBSTATE_PRESSED, pTBState->wButtonType);
	DrawBlankButton(hdcButton, dx, 0, dx, dy, 0, pTBState->wButtonType);
    }

    for (iButton = 0, xButton = xFirstButton;
	iButton < cButtons;
	iButton++) {

        PTBBUTTON ptbButton = &pAllButtons[iButton];

	if (ptbButton->fsState & TBSTATE_HIDDEN) {
	    /* Do nothing */ ;
        } else if (ptbButton->fsStyle & TBSTYLE_SEP) {
	    xButton += ptbButton->iBitmap;
        } else {
	    if (wFlags & BUILD)
	        DrawButton(hdcFaceCache, xCache, 0, dx, dy, pTBState, ptbButton, bFaceCache);

            rc.left = xButton;
            rc.right = xButton + dx;
	    if (RectVisible(hdc, &rc)) {
		if ((wFlags & CACHE) && !(ptbButton->fsState & TBSTATE_PRESSED))
		    BitBlt(hdc, xButton, yButton, dx, dy,
				hdcFaceCache, xCache, 0, SRCCOPY);
		else
		    DrawButton(hdc, xButton, yButton, dx, dy, pTBState, ptbButton, bFaceCache);
	    }
	    // advance the "pointer" in the cache
	    xCache += dx;

	    xButton += (dx - g_dxOverlap);
        }
    }

    if (wFlags & CACHE)
	SelectObject(hdcFaceCache, hbmDefault);
    SelectObject(hdcGlyphs, hbmOldGlyphs);

Error1:
    EndPaint(hWnd, &ps);
}


static BOOL NEAR PASCAL GetItemRect(PTBSTATE pTBState, UINT uButton, LPRECT lpRect)
{
	UINT iButton, xPos;
	PTBBUTTON pButton;

	if (uButton>=(UINT)pTBState->iNumButtons
		|| (pTBState->Buttons[uButton].fsState&TBSTATE_HIDDEN))
	{
		return(FALSE);
	}

	xPos = xFirstButton;

	for (iButton=0, pButton=pTBState->Buttons; iButton<uButton;
		++iButton, ++pButton)
	{
		if (pButton->fsState & TBSTATE_HIDDEN)
		{
			/* Do nothing */ ;
		}
		else if (pButton->fsStyle & TBSTYLE_SEP)
		{
			xPos += pButton->iBitmap;
		}
		else
		{
			xPos += (pTBState->iButWidth - g_dxOverlap);
		}
	}

	/* pButton should now point at the required button, and xPos should be
	 * its left edge.  Note that we already checked if the button was
	 * hidden above.
	 */
	lpRect->left   = xPos;
	lpRect->right  = xPos + (pButton->fsStyle&TBSTYLE_SEP
		? pButton->iBitmap : pTBState->iButWidth);
	lpRect->top    = pTBState->iYPos;
	lpRect->bottom = lpRect->top + pTBState->iButHeight;

	return(TRUE);
}


static void NEAR PASCAL InvalidateButton(HWND hwnd, PTBSTATE pTBState, PTBBUTTON pButtonToPaint)
{
	RECT rc;

	if (GetItemRect(pTBState, pButtonToPaint-pTBState->Buttons, &rc))
	{
		InvalidateRect(hwnd, &rc, FALSE);
	}
}


static int FAR PASCAL TBHitTest(PTBSTATE pTBState, int xPos, int yPos)
{
  int iButton;
  int cButtons = pTBState->iNumButtons;
  PTBBUTTON pButton;

  xPos -= xFirstButton;
  if (xPos < 0)
      return(-1);
  yPos -= pTBState->iYPos;

  for (iButton=0, pButton=pTBState->Buttons; iButton<cButtons;
	++iButton, ++pButton)
    {
      if (pButton->fsState & TBSTATE_HIDDEN)
	  /* Do nothing */ ;
      else if (pButton->fsStyle & TBSTYLE_SEP)
	  xPos -= pButton->iBitmap;
      else
	  xPos -= (pTBState->iButWidth - g_dxOverlap);

      if (xPos < 0)
	{
	  if (pButton->fsStyle&TBSTYLE_SEP
		|| (UINT)yPos>=(UINT)pTBState->iButHeight)
	      break;

	  return(iButton);
	}
    }

  return(-1 - iButton);
}


static int FAR PASCAL PositionFromID(PTBSTATE pTBState, int id)
{
    int i;
    int cButtons = pTBState->iNumButtons;
    PTBBUTTON pAllButtons = pTBState->Buttons;

    for (i = 0; i < cButtons; i++)
        if (pAllButtons[i].idCommand == id)
	    return i;		// position found

    return -1;		// ID not found!
}

// check a radio button by button index.
// the button matching idCommand was just pressed down.  this forces
// up all other buttons in the group.
// this does not work with buttons that are forced up with

static void NEAR PASCAL MakeGroupConsistant(HWND hWnd, PTBSTATE pTBState, int idCommand)
{
    int i, iFirst, iLast, iButton;
    int cButtons = pTBState->iNumButtons;
    PTBBUTTON pAllButtons = pTBState->Buttons;

    iButton = PositionFromID(pTBState, idCommand);

    if (iButton < 0)
        return;

    // assertion

//    if (!(pAllButtons[iButton].fsStyle & TBSTYLE_CHECK))
//	return;

    // did the pressed button just go down?
    if (!(pAllButtons[iButton].fsState & TBSTATE_CHECKED))
        return;         // no, can't do anything

    // find the limits of this radio group

    for (iFirst = iButton; (iFirst > 0) && (pAllButtons[iFirst].fsStyle & TBSTYLE_GROUP); iFirst--)
    if (!(pAllButtons[iFirst].fsStyle & TBSTYLE_GROUP))
        iFirst++;

    cButtons--;
    for (iLast = iButton; (iLast < cButtons) && (pAllButtons[iLast].fsStyle & TBSTYLE_GROUP); iLast++);
    if (!(pAllButtons[iLast].fsStyle & TBSTYLE_GROUP))
        iLast--;

    // search for the currently down button and pop it up
    for (i = iFirst; i <= iLast; i++) {
        if (i != iButton) {
            // is this button down?
            if (pAllButtons[i].fsState & TBSTATE_CHECKED) {
	        pAllButtons[i].fsState &= ~TBSTATE_CHECKED;     // pop it up
                InvalidateButton(hWnd, pTBState, &pAllButtons[i]);
                break;          // only one button is down right?
            }
        }
    }
}

static void NEAR PASCAL DestroyStrings(PTBSTATE pTBState)
{
    PTSTR *p;
    PTSTR end = 0, start = 0;
    int i;

    p = pTBState->pStrings;
    for (i = 0; i < pTBState->nStrings; i++) {
	if (!(*p < end) && (*p > start)) {
	    start = (*p);
	    end = start + LocalSize((HANDLE)*p);
	    LocalFree((HANDLE)*p);
	}
	p++;
	i++;
    }

    LocalFree((HANDLE)pTBState->pStrings);
}


/* Adds a new bitmap to the list of BMs available for this toolbar.
 * Returns the index of the first button in the bitmap or -1 if there
 * was an error.
 */
static int NEAR PASCAL AddBitmap(PTBSTATE pTBState, int nButtons,
      HINSTANCE hBMInst, UINT wBMID)
{
  PTBBMINFO pTemp;
  int nBM, nIndex;

  if (pTBState->pBitmaps)
    {
      /* Check if the bitmap has already been added
       */
      for (nBM=pTBState->nBitmaps, pTemp=pTBState->pBitmaps, nIndex=0;
	    nBM>0; --nBM, ++pTemp)
	{
	  if (pTemp->hInst==hBMInst && pTemp->wID==wBMID)
	    {
	      /* We already have this bitmap, but have we "registered" all
	       * the buttons in it?
	       */
	      if (pTemp->nButtons >= nButtons)
		  return(nIndex);
	      if (nBM == 1)
		{
		  /* If this is the last bitmap, we can easily increase the
		   * number of buttons without messing anything up.
		   */
		  pTemp->nButtons = nButtons;
		  return(nIndex);
		}
	    }

	  nIndex += pTemp->nButtons;
	}

      pTemp = (PTBBMINFO)LocalReAlloc(pTBState->pBitmaps,
	    (pTBState->nBitmaps+1)*sizeof(TBBMINFO), LMEM_MOVEABLE);
      if (!pTemp)
	  return(-1);
      pTBState->pBitmaps = pTemp;
    }
  else
    {
      pTBState->pBitmaps = (PTBBMINFO)LocalAlloc(LPTR, sizeof(TBBMINFO));
      if (!pTBState->pBitmaps)
	  return(-1);
    }

  pTemp = pTBState->pBitmaps + pTBState->nBitmaps;

  pTemp->hInst = hBMInst;
  pTemp->wID = wBMID;
  pTemp->nButtons = nButtons;
  pTemp->hbm = NULL;

  ++pTBState->nBitmaps;

  for (nButtons=0, --pTemp; pTemp>=pTBState->pBitmaps; --pTemp)
      nButtons += pTemp->nButtons;

  return(nButtons);
}


static BOOL NEAR PASCAL InsertButtons(HWND hWnd, PTBSTATE pTBState,
      UINT uWhere, UINT uButtons, LPTBBUTTON lpButtons)
{
  PTBBUTTON pIn, pOut;

  if (!pTBState || !pTBState->uStructSize)
      return(FALSE);

  pTBState = (PTBSTATE)LocalReAlloc(pTBState, sizeof(TBSTATE)-sizeof(TBBUTTON)
	+ (pTBState->iNumButtons+uButtons)*sizeof(TBBUTTON), LMEM_MOVEABLE);
  if (!pTBState)
      return(FALSE);

  SETWINDOWPOINTER(hWnd, PTBSTATE, pTBState);

  if (uWhere > (UINT)pTBState->iNumButtons)
      uWhere = pTBState->iNumButtons;

  for (pIn=pTBState->Buttons+pTBState->iNumButtons-1, pOut=pIn+uButtons,
	uWhere=(UINT)pTBState->iNumButtons-uWhere; uWhere>0;
	--pIn, --pOut, --uWhere)
      *pOut = *pIn;

  for (lpButtons=(LPTBBUTTON)((LPBYTE)lpButtons+pTBState->uStructSize*(uButtons-1)), pTBState->iNumButtons+=(int)uButtons; uButtons>0;
	--pOut, lpButtons=(LPTBBUTTON)((LPBYTE)lpButtons-pTBState->uStructSize), --uButtons)
    {
      TBInputStruct(pTBState, pOut, lpButtons);

      if ((pOut->fsStyle&TBSTYLE_SEP) && pOut->iBitmap<=0)
	  pOut->iBitmap = dxButtonSep;
    }
	
  // flush the cache
  FlushButtonCache(pTBState);

  /* We need to completely redraw the toolbar at this point.
   */
  InvalidateRect(hWnd, NULL, TRUE);

  return(TRUE);
}


/* Notice that the state structure is not realloc'ed smaller at this
 * point.  This is a time optimization, and the fact that the structure
 * will not move is used in other places.
 */
static BOOL NEAR PASCAL DeleteButton(HWND hWnd, PTBSTATE pTBState, UINT uIndex)
{
  PTBBUTTON pIn, pOut;

  if (uIndex >= (UINT)pTBState->iNumButtons)
      return(FALSE);

  --pTBState->iNumButtons;
  for (pOut=pTBState->Buttons+uIndex, pIn=pOut+1;
	uIndex<(UINT)pTBState->iNumButtons; ++uIndex, ++pIn, ++pOut)
      *pOut = *pIn;

  // flush the cache
  FlushButtonCache(pTBState);

  /* We need to completely redraw the toolbar at this point.
   */
  InvalidateRect(hWnd, NULL, TRUE);

  return(TRUE);
}


static void FAR PASCAL TBInputStruct(PTBSTATE pTBState, LPTBBUTTON pButtonInt, LPTBBUTTON pButtonExt)
{
	if (pTBState->uStructSize >= sizeof(TBBUTTON))
	{
		*pButtonInt = *pButtonExt;
	}
	else
	/* It is assumed the only other possibility is the OLDBUTTON struct */
	{
		*(LPOLDTBBUTTON)pButtonInt = *(LPOLDTBBUTTON)pButtonExt;
		/* We don't care about dwData */
		pButtonInt->iString = -1;
	}
}


static void FAR PASCAL TBOutputStruct(PTBSTATE pTBState, LPTBBUTTON pButtonInt, LPTBBUTTON pButtonExt)
{
	if (pTBState->uStructSize >= sizeof(TBBUTTON))
	{
		LPBYTE pOut;
		int i;

		/* Fill the part we know about and fill the rest with 0's
		*/
		*pButtonExt = *pButtonInt;
		for (i=pTBState->uStructSize-sizeof(TBBUTTON), pOut=(LPBYTE)(pButtonExt+1);
			i>0; --i, ++pOut)
		{
			*pOut = 0;
		}
	}
	else
	/* It is assumed the only other possibility is the OLDBUTTON struct */
	{
		*(LPOLDTBBUTTON)pButtonExt = *(LPOLDTBBUTTON)pButtonInt;
	}
}


LRESULT CALLBACK _loadds ToolbarWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fSameButton;
    PTBBUTTON ptbButton;
    PTBSTATE pTBState;
    int iPos;
    BYTE fsState;
#if WINVER >= 0x0400
    DWORD dw;
#endif

    pTBState = GETWINDOWPOINTER(hWnd, PTBSTATE);

    switch (wMsg) {
    case WM_CREATE:

	#define lpcs ((LPCREATESTRUCT)lParam)

        if (!CreateDitherBrush(FALSE))
            return -1;

	if (!InitGlobalObjects()) {
            FreeGlobalObjects();
	    return -1;
        }

	/* create the state data for this toolbar */

	pTBState = ALLOCWINDOWPOINTER(PTBSTATE, sizeof(TBSTATE)-sizeof(TBBUTTON));
	if (!pTBState)
	    return -1;

	/* The struct is initialized to all NULL when created.
	 */
	pTBState->hwndCommand = lpcs->hwndParent;

	pTBState->uStructSize = 0;

	// grow the button size to the appropriate girth
	if (!SetBitmapSize(pTBState, DEFAULTBITMAPX, DEFAULTBITMAPX))
	    return -1;

	SETWINDOWPOINTER(hWnd, PTBSTATE, pTBState);

	if (!(lpcs->style&(CCS_TOP|CCS_NOMOVEY|CCS_BOTTOM)))
	  {
	    lpcs->style |= CCS_TOP;
	    SetWindowLong(hWnd, GWL_STYLE, lpcs->style);
	  }
	break;

    case WM_DESTROY:
	if (pTBState)
	  {
	    PTBBMINFO pTemp;
	    int i;

	    /* Free all the bitmaps before exiting
	     */
	    for (pTemp=pTBState->pBitmaps, i=pTBState->nBitmaps-1; i>=0;
		  ++pTemp, --i)
	      {
		if (pTemp->hInst && pTemp->hbm)
		    DeleteObject(pTemp->hbm);
	      }
	    FlushButtonCache(pTBState);
	    if (pTBState->nStrings > 0)
		DestroyStrings(pTBState);

	    FREEWINDOWPOINTER(pTBState);
	    SETWINDOWPOINTER(hWnd, PTBSTATE, 0);
	  }
	FreeGlobalObjects();
        FreeDitherBrush();
	break;

    case WM_NCCALCSIZE:
#if WINVER >= 0x0400
         /*
          * This is sent when the window manager wants to find out
          * how big our client area is to be.  If we have a mini-caption
          * then we trap this message and calculate the cleint area rect,
          * which is the client area rect calculated by DefWindowProc()
          * minus the width/height of the mini-caption bar
          */
         // let defwindowproc handle the standard borders etc...

	dw = DefWindowProc(hWnd, wMsg, wParam, lParam ) ;

	if (!(GetWindowLong(hWnd, GWL_STYLE) & CCS_NODIVIDER))
	{
	    NCCALCSIZE_PARAMS FAR *lpNCP;
	    lpNCP = (NCCALCSIZE_PARAMS FAR *)lParam;
	    lpNCP->rgrc[0].top += 2;
	}

        return dw;
#endif
	break;

    case WM_NCACTIVATE:
    case WM_NCPAINT:

#if WINVER >= 0x0400
	// old-style toolbars are forced to be without dividers above
	if (!(GetWindowLong(hWnd, GWL_STYLE) & CCS_NODIVIDER))
	{
	    HDC hdc;
	    RECT rc;

	    hdc = GetWindowDC(hWnd);
	    GetWindowRect(hWnd, &rc);
	    ScreenToClient(hWnd, (LPPOINT)&(rc.left));
	    ScreenToClient(hWnd, (LPPOINT)&(rc.right));
	    rc.bottom = (-rc.top);	// bottom of NC area
	    rc.top = rc.bottom - (2 * GetSystemMetrics(SM_CYBORDER));

	    DrawBorder(hdc, &rc, BDR_SUNKENOUTER, BF_TOP | BF_BOTTOM);
	    ReleaseDC(hWnd, hdc);
	}
	else
            goto DoDefault;
#endif
	break;

    case WM_PAINT:
	ToolbarPaint(hWnd, pTBState);
	break;


    case WM_HSCROLL:  //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    case WM_COMMAND:
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
    case WM_VKEYTOITEM:
    case WM_CHARTOITEM:
	SendMessage(pTBState->hwndCommand, wMsg, wParam, lParam);
        break;

#ifdef _WIN32
    case WM_CTLCOLORBTN:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLOREDIT:
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORMSGBOX:
    case WM_CTLCOLORSCROLLBAR:
    case WM_CTLCOLORSTATIC:
#else
    case WM_CTLCOLOR:
#endif
        //!!!!! ack use COLOR_BTNFACE
        return (LRESULT)(UINT)GetStockObject(LTGRAY_BRUSH);


    case WM_LBUTTONDOWN:

        iPos = TBHitTest(pTBState, LOWORD(lParam), HIWORD(lParam));
#if 0
	if ((wParam&MK_SHIFT) &&(GetWindowLong(hWnd, GWL_STYLE)&CCS_ADJUSTABLE))
	  {
	    MoveButton(hWnd, pTBState, iPos);
	  } else
#endif
	if (iPos >= 0)
	  {
	    ptbButton = pTBState->Buttons + iPos;

	    pTBState->pCaptureButton = ptbButton;
	    SetCapture(hWnd);

	    if (ptbButton->fsState & TBSTATE_ENABLED)
	      {
		ptbButton->fsState |= TBSTATE_PRESSED;
		InvalidateButton(hWnd, pTBState, ptbButton);
		UpdateWindow(hWnd);         // imedeate feedback
	      }

#ifdef _WIN32
	    SendMessage(pTBState->hwndCommand, WM_COMMAND,  (UINT)GetWindowLong(hWnd, GWL_ID), MAKELONG(pTBState->pCaptureButton->idCommand, TBN_BEGINDRAG));
#else
	    SendMessage(pTBState->hwndCommand, WM_COMMAND, GETWINDOWID(hWnd), MAKELONG(pTBState->pCaptureButton->idCommand, TBN_BEGINDRAG));
#endif
	  }
	break;

    case WM_MOUSEMOVE:
	// if the toolbar has lost the capture for some reason, stop
	if ((hWnd != GetCapture()) && (pTBState->pCaptureButton != NULL)) {
#ifdef _WIN32
	    SendMessage(pTBState->hwndCommand, WM_COMMAND, (UINT)GetWindowLong(hWnd, GWL_ID),
	    		MAKELONG(pTBState->pCaptureButton->idCommand, TBN_ENDDRAG));
#else
	    SendMessage(pTBState->hwndCommand, WM_COMMAND, GETWINDOWID(hWnd),
	    		MAKELONG(pTBState->pCaptureButton->idCommand, TBN_ENDDRAG));
#endif
	    // if the button is still pressed, unpress it.
	    if (pTBState->pCaptureButton->fsState & TBSTATE_PRESSED)
	        SendMessage(hWnd, TB_PRESSBUTTON, pTBState->pCaptureButton->idCommand, 0L);
	    pTBState->pCaptureButton = NULL;
	}
	else if (pTBState->pCaptureButton!=NULL
	      && (pTBState->pCaptureButton->fsState & TBSTATE_ENABLED)) {

	    iPos = TBHitTest(pTBState, LOWORD(lParam), HIWORD(lParam));
	    fSameButton = (iPos>=0
		  && pTBState->pCaptureButton==pTBState->Buttons+iPos);
	    if (fSameButton == !(pTBState->pCaptureButton->fsState & TBSTATE_PRESSED)) {
		pTBState->pCaptureButton->fsState ^= TBSTATE_PRESSED;
		InvalidateButton(hWnd, pTBState, pTBState->pCaptureButton);
	    }
	}
	break;

    case WM_LBUTTONUP:
	if (pTBState->pCaptureButton != NULL) {

	    int idCommand;

	    idCommand = pTBState->pCaptureButton->idCommand;

	    ReleaseCapture();

#ifdef _WIN32
	    SendMessage(pTBState->hwndCommand, WM_COMMAND, (UINT)GetWindowLong(hWnd, GWL_ID), MAKELONG(idCommand, TBN_ENDDRAG));
#else
	    SendMessage(pTBState->hwndCommand, WM_COMMAND, GETWINDOWID(hWnd), MAKELONG(idCommand, TBN_ENDDRAG));
#endif

	    iPos = TBHitTest(pTBState, LOWORD(lParam), HIWORD(lParam));
	    if ((pTBState->pCaptureButton->fsState&TBSTATE_ENABLED) && iPos>=0
		  && (pTBState->pCaptureButton==pTBState->Buttons+iPos)) {
		pTBState->pCaptureButton->fsState &= ~TBSTATE_PRESSED;

		if (pTBState->pCaptureButton->fsStyle & TBSTYLE_CHECK) {
		    if (pTBState->pCaptureButton->fsStyle & TBSTYLE_GROUP) {

			// group buttons already checked can't be force
			// up by the user.

		        if (pTBState->pCaptureButton->fsState & TBSTATE_CHECKED) {
			    pTBState->pCaptureButton = NULL;
			    break;	// bail!
			}

			pTBState->pCaptureButton->fsState |= TBSTATE_CHECKED;
		        MakeGroupConsistant(hWnd, pTBState, idCommand);
		    } else {
			pTBState->pCaptureButton->fsState ^= TBSTATE_CHECKED; // toggle
		    }
		    // if we change a button's state, we need to flush the
		    // cache
		    FlushButtonCache(pTBState);
		}
		InvalidateButton(hWnd, pTBState, pTBState->pCaptureButton);
		pTBState->pCaptureButton = NULL;
		SendMessage(pTBState->hwndCommand, WM_COMMAND, idCommand, 0L);
	    }
	    else {
		pTBState->pCaptureButton = NULL;
	    }
	}
	break;

    case TB_SETSTATE:
	iPos = PositionFromID(pTBState, (int)wParam);
	if (iPos < 0)
	    return(FALSE);
	ptbButton = pTBState->Buttons + iPos;

	fsState = (BYTE)(LOWORD(lParam) ^ ptbButton->fsState);
        ptbButton->fsState = (BYTE)LOWORD(lParam);

	if (fsState)
	    // flush the button cache
	    //!!!! this could be much more intelligent
	    FlushButtonCache(pTBState);

	if (fsState & TBSTATE_HIDDEN)
	    InvalidateRect(hWnd, NULL, TRUE);
	else if (fsState)
	    InvalidateButton(hWnd, pTBState, ptbButton);
        return(TRUE);

    case TB_GETSTATE:
	iPos = PositionFromID(pTBState, (int)wParam);
	if (iPos < 0)
	    return(-1L);
        return(pTBState->Buttons[iPos].fsState);

    case TB_ENABLEBUTTON:
    case TB_CHECKBUTTON:
    case TB_PRESSBUTTON:
    case TB_HIDEBUTTON:
    case TB_INDETERMINATE:

        iPos = PositionFromID(pTBState, (int)wParam);
	if (iPos < 0)
	    return(FALSE);
        ptbButton = &pTBState->Buttons[iPos];
        fsState = ptbButton->fsState;

        if (LOWORD(lParam))
            ptbButton->fsState |= wStateMasks[wMsg - TB_ENABLEBUTTON];
	else
            ptbButton->fsState &= ~wStateMasks[wMsg - TB_ENABLEBUTTON];

        // did this actually change the state?
        if (fsState != ptbButton->fsState) {
            // is this button a member of a group?
	    if ((wMsg == TB_CHECKBUTTON) && (ptbButton->fsStyle & TBSTYLE_GROUP))
	        MakeGroupConsistant(hWnd, pTBState, (int)wParam);

	    // flush the button cache
	    //!!!! this could be much more intelligent
	    FlushButtonCache(pTBState);

	    if (wMsg == TB_HIDEBUTTON)
		InvalidateRect(hWnd, NULL, TRUE);
	    else
		InvalidateButton(hWnd, pTBState, ptbButton);
        }
        return(TRUE);

    case TB_ISBUTTONENABLED:
    case TB_ISBUTTONCHECKED:
    case TB_ISBUTTONPRESSED:
    case TB_ISBUTTONHIDDEN:
    case TB_ISBUTTONINDETERMINATE:
        iPos = PositionFromID(pTBState, (int)wParam);
	if (iPos < 0)
	    return(-1L);
        return (LRESULT)pTBState->Buttons[iPos].fsState
	      & wStateMasks[wMsg - TB_ISBUTTONENABLED];

    case TB_ADDBITMAP:
#ifdef _WIN32
    {	
	TB_ADDBITMAPINFO * ptbai;

	ptbai = (TB_ADDBITMAPINFO *)lParam;

	return AddBitmap(pTBState, wParam, ptbai->hBitmap, ptbai->idResource);
    }
#else
	return(AddBitmap(pTBState, wParam,
	      (HINSTANCE)LOWORD(lParam), HIWORD(lParam)));
#endif


    case TB_ADDBUTTONS:
	return(InsertButtons(hWnd, pTBState, (UINT)-1, wParam,
	      (LPTBBUTTON)lParam));

    case TB_INSERTBUTTON:
	return(InsertButtons(hWnd, pTBState, wParam, 1, (LPTBBUTTON)lParam));

    case TB_DELETEBUTTON:
	return(DeleteButton(hWnd, pTBState, wParam));

    case TB_GETBUTTON:
	if (wParam >= (UINT)pTBState->iNumButtons)
	    return(FALSE);

	TBOutputStruct(pTBState, pTBState->Buttons+wParam, (LPTBBUTTON)lParam);
	return(TRUE);

    case TB_BUTTONCOUNT:
	return(pTBState->iNumButtons);

    case TB_COMMANDTOINDEX:
        return(PositionFromID(pTBState, (int)wParam));


    case TB_GETITEMRECT:
	return(MAKELRESULT(GetItemRect(pTBState, wParam, (LPRECT)lParam), 0));
	break;

    case TB_BUTTONSTRUCTSIZE:
	/* You are not allowed to change this after adding buttons.
	*/
	if (!pTBState || pTBState->iNumButtons)
	{
		break;
	}
	pTBState->uStructSize = wParam;
	break;

    case TB_SETBUTTONSIZE:
	if (!LOWORD(lParam))
	    lParam = MAKELONG(DEFAULTBUTTONX, HIWORD(lParam));
	if (!HIWORD(lParam))
	    lParam = MAKELONG(LOWORD(lParam), DEFAULTBUTTONY);
	return(GrowToolbar(pTBState, LOWORD(lParam), HIWORD(lParam), FALSE));

    case TB_SETBITMAPSIZE:
	return(SetBitmapSize(pTBState, LOWORD(lParam), HIWORD(lParam)));

    case TB_SETBUTTONTYPE:
	pTBState->wButtonType = wParam;
	break;

    default:
#if WINVER >= 0x0400
DoDefault:
#endif
	return DefWindowProc(hWnd, wMsg, wParam, lParam);
    }

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd\trackbar.c ===
//----------------------------------------------------------
//
// BUGBUG: make sure this stuff really works with the DWORD
//	   ranges
//
//----------------------------------------------------------

#include "ctlspriv.h"
#include "tracki.h"
#ifndef _WIN32
#include "muldiv32.h"
#else
#define MulDiv32	MulDiv
#endif

#define THUMBSLOP  2
#define TICKHEIGHT 2

#define ABS(X)  (X >= 0) ? X : -X
#define BOUND(x,low,high)   max(min(x, high),low)
#define LONG2POINT(l, pt)  ((pt).x = (SHORT)LOWORD(l), (pt).y = (SHORT)HIWORD(l))

TCHAR aszTrackbarClassName[] = TRACKBAR_CLASS;

LPARAM FAR CALLBACK _loadds TrackBarWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

//
//  convert a logical scroll-bar position to a physical pixel position
//
static int NEAR PASCAL TBLogToPhys(PTrackBar tb, DWORD dwPos)
{
    if (tb->lLogMax == tb->lLogMin)
	return tb->rc.left;

    return (UINT)MulDiv32(dwPos - tb->lLogMin, tb->iSizePhys - 1,
	tb->lLogMax - tb->lLogMin) + tb->rc.left;
}

static LONG NEAR PASCAL TBPhysToLog(PTrackBar tb, int iPos)
{
    if (tb->iSizePhys <= 1)
	return tb->lLogMin;

    if (iPos <= tb->rc.left)
	return tb->lLogMin;

    if (iPos >= tb->rc.right)
	return tb->lLogMax;

    return MulDiv32(iPos - tb->rc.left, tb->lLogMax - tb->lLogMin,
		    tb->iSizePhys - 1) + tb->lLogMin;
}



/*
	Initialize the trackbar code.
*/

BOOL FAR PASCAL InitTrackBar(HINSTANCE hInstance)
{
    WNDCLASS wc;

    if (!GetClassInfo(hInstance, aszTrackbarClassName, &wc)) {
	// See if we must register a window class
	
	wc.lpszClassName = aszTrackbarClassName;
	wc.lpfnWndProc = (WNDPROC)TrackBarWndProc;
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hIcon = NULL;
	wc.lpszMenuName = NULL;
	wc.hbrBackground = (HBRUSH)(NULL);
	wc.hInstance = hInstance;
	wc.style = CS_GLOBALCLASS | CS_DBLCLKS;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = EXTRA_TB_BYTES;
	
	if (!RegisterClass(&wc))
		return FALSE;
    }
    return TRUE;
}


static void NEAR PASCAL PatRect(HDC hdc,int x,int y,int dx,int dy)
{
    RECT    rc;

    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}

static void NEAR PASCAL DrawTic(PTrackBar tb, int x, int yTic)
{
    SetBkColor(tb->hdc, GetSysColor(COLOR_BTNTEXT));
    PatRect(tb->hdc,(x),yTic,1,TICKHEIGHT);
    SetBkColor(tb->hdc, GetSysColor(COLOR_BTNHIGHLIGHT));
    PatRect(tb->hdc,(x)+1,yTic,1,TICKHEIGHT);
}

/* DrawTics() */
/* There is always a tick at the beginning and end of the bar, but you can */
/* add some more of your own with a TBM_SETTIC message.  This draws them.  */
/* They are kept in an array whose handle is a window word.  The first     */
/* element is the number of extra ticks, and then the positions.           */

static void NEAR PASCAL DrawTics(PTrackBar tb)
{
    PDWORD pTics;
    int    iPos;
    int    yTic;
    int    i;

    yTic = tb->rc.bottom + THUMBSLOP + 1;

// !!! Not for MCIWnd
//    DrawTic(tb, tb->rc.left, yTic);               // first
//    DrawTic(tb, tb->rc.right-1, yTic);            // last

    // those inbetween
    pTics = tb->pTics;
    if (pTics) {
	for (i = 0; i < tb->nTics; ++i) {
	    iPos = TBLogToPhys(tb,pTics[i]);
	    DrawTic(tb, iPos, yTic);
	}
    }

    // draw the selection range (triangles)

    if ((tb->Flags & TBF_SELECTION) &&
        (tb->lSelStart <= tb->lSelEnd) && (tb->lSelEnd >= tb->lLogMin)) {

	SetBkColor(tb->hdc, GetSysColor(COLOR_BTNTEXT));

	iPos = TBLogToPhys(tb,tb->lSelStart);

	for (i=0; i < TICKHEIGHT; i++)
	    PatRect(tb->hdc,iPos-i,yTic+i,1,TICKHEIGHT-i);

	iPos = TBLogToPhys(tb,tb->lSelEnd);

	for (i=0; i < TICKHEIGHT; i++)
	    PatRect(tb->hdc,iPos+i,yTic+i,1,TICKHEIGHT-i);
    }

// !!! Not for MCIWnd
//    line across the bottom
//    SetBkColor(tb->hdc, GetSysColor(COLOR_BTNTEXT));
//    PatRect(tb->hdc, tb->rc.left, yTic+TICKHEIGHT,tb->iSizePhys,1);
//
//    SetBkColor(tb->hdc, GetSysColor(COLOR_BTNHIGHLIGHT));
//    PatRect(tb->hdc, tb->rc.left, yTic+TICKHEIGHT+1,tb->iSizePhys,1);

}

/* This draws the track bar itself */

static void NEAR PASCAL DrawChannel(PTrackBar tb)
{
    HBRUSH hbrTemp;

    // draw the frame around the window
    SetBkColor(tb->hdc, GetSysColor(COLOR_WINDOWFRAME));

    PatRect(tb->hdc, tb->rc.left, tb->rc.top,      tb->iSizePhys, 1);
    PatRect(tb->hdc, tb->rc.left, tb->rc.bottom-2, tb->iSizePhys, 1);
    PatRect(tb->hdc, tb->rc.left, tb->rc.top,      1, tb->rc.bottom-tb->rc.top-1);
    PatRect(tb->hdc, tb->rc.right-1, tb->rc.top, 1, tb->rc.bottom-tb->rc.top-1);

    SetBkColor(tb->hdc, GetSysColor(COLOR_BTNHIGHLIGHT));
    PatRect(tb->hdc, tb->rc.left, tb->rc.bottom-1, tb->iSizePhys, 1);

    SetBkColor(tb->hdc, GetSysColor(COLOR_BTNSHADOW));
    PatRect(tb->hdc, tb->rc.left+1, tb->rc.top + 1, tb->iSizePhys-2,1);

    // draw the background in dither gray
    hbrTemp = SelectObject(tb->hdc, hbrDither);
    if (hbrTemp) {
        PatBlt(tb->hdc, tb->rc.left+1, tb->rc.top + 2,
            tb->iSizePhys-2, tb->rc.bottom-tb->rc.top-4, PATCOPY);
        SelectObject(tb->hdc, hbrTemp);
    }

    // now highlight the selection range
    if ((tb->Flags & TBF_SELECTION) &&
        (tb->lSelStart <= tb->lSelEnd) && (tb->lSelEnd > tb->lLogMin)) {
	int iStart, iEnd;

	iStart = TBLogToPhys(tb,tb->lSelStart);
	iEnd   = TBLogToPhys(tb,tb->lSelEnd);

        SetBkColor(tb->hdc, GetSysColor(COLOR_BTNTEXT));
	PatRect(tb->hdc, iStart,tb->rc.top+1,1,tb->rc.bottom-tb->rc.top-2);
	PatRect(tb->hdc, iEnd,  tb->rc.top+1,1,tb->rc.bottom-tb->rc.top-2);

	if (iStart + 2 <= iEnd) {
            SetBkColor(tb->hdc, GetSysColor(COLOR_BTNHIGHLIGHT));
	    PatRect(tb->hdc, iStart+1, tb->rc.top+1, iEnd-iStart-1, tb->rc.bottom-tb->rc.top-3);
	}
    }
}

static void NEAR PASCAL MoveThumb(PTrackBar tb, LONG lPos)
{
	InvalidateRect(tb->hwnd, &tb->Thumb, TRUE);

	tb->lLogPos  = BOUND(lPos,tb->lLogMin,tb->lLogMax);

	tb->Thumb.left   = TBLogToPhys(tb, tb->lLogPos) - tb->wThumbWidth/2;
	tb->Thumb.right  = tb->Thumb.left + tb->wThumbWidth;
	tb->Thumb.top    = tb->rc.top - THUMBSLOP;
	tb->Thumb.bottom = tb->rc.bottom + THUMBSLOP;

	InvalidateRect(tb->hwnd, &tb->Thumb, TRUE);
	UpdateWindow(tb->hwnd);
}


static void NEAR PASCAL DrawThumb(PTrackBar tb)
{
	HBITMAP hbmT;
	HDC     hdcT;
	int     x;

	hdcT = CreateCompatibleDC(tb->hdc);

	if( (tb->Cmd == TB_THUMBTRACK) || !IsWindowEnabled(tb->hwnd) )
	    x = tb->wThumbWidth;
	else
	    x = 0;

	hbmT = SelectObject(hdcT, hbmThumb);
        if (hbmT) {
	    BitBlt(tb->hdc,tb->Thumb.left, tb->rc.top-THUMBSLOP,
		tb->wThumbWidth, tb->wThumbHeight, hdcT, x + 2*tb->wThumbWidth, 0, SRCAND);
	    BitBlt(tb->hdc,tb->Thumb.left, tb->rc.top-THUMBSLOP,
		tb->wThumbWidth, tb->wThumbHeight, hdcT, x, 0, SRCPAINT);
        }

	SelectObject(hdcT, hbmT);
	DeleteDC(hdcT);
}

/* SetTBCaretPos() */
/* Make the caret flash in the middle of the thumb when it has the focus */

static void NEAR PASCAL SetTBCaretPos(PTrackBar tb)
{
	// We only get the caret if we have the focus.
	if (tb->hwnd == GetFocus())
		SetCaretPos(tb->Thumb.left + tb->wThumbWidth / 2,
			tb->Thumb.top + THUMBSLOP);
}

static void NEAR PASCAL DoAutoTics(PTrackBar tb)
{
    LONG NEAR *pl;
    LONG l;

    if (!(GetWindowLong(tb->hwnd, GWL_STYLE) & TBS_AUTOTICKS))
        return;

    tb->nTics = (int)(tb->lLogMax - tb->lLogMin - 1);

    // If our length is zero, we'll blow!
    if (tb->nTics <= 0) {
	tb ->nTics = 0;
	return;
    }

    if (tb->pTics)
        LocalFree((HANDLE)tb->pTics);

    tb->pTics = (DWORD NEAR *)LocalAlloc(LPTR, sizeof(DWORD) * tb->nTics);
    if (!tb->pTics) {
        tb->nTics = 0;
        return;
    }

    for (pl = (LONG NEAR *)tb->pTics, l = tb->lLogMin + 1; l < tb->lLogMax; l++)
        *pl++ = l;
}


LPARAM FAR CALLBACK _loadds TrackBarWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	PTrackBar       tb;
	PAINTSTRUCT     ps;
	BITMAP          bm;
	HANDLE          h;
	HDC		hdc;
	HBRUSH		hbr;
	RECT		rc;

	tb = TrackBarLock(hwnd);

	switch (message) {
		case WM_CREATE:
			if (!CreateDitherBrush(FALSE))
				return -1;
			// Get us our window structure.
			TrackBarCreate(hwnd);
			tb = TrackBarLock(hwnd);

			tb->hwnd = hwnd;
			tb->Cmd = (UINT)-1;

			/* load the 2 thumb bitmaps (pressed and released) */
			CreateThumb(FALSE);

			GetObject(hbmThumb, sizeof(bm), &bm);

			// bitmap has up and down thumb and up&down masks
			tb->wThumbWidth  = (UINT)(bm.bmWidth/4);
			tb->wThumbHeight = (UINT)bm.bmHeight;
                        // all lLog fields are zero inited by
                        // the LocalAlloc();

			// fall through to WM_SIZE

		case WM_SIZE:
			GetClientRect(hwnd, &tb->rc);

			tb->rc.bottom  = tb->rc.top + tb->wThumbHeight - THUMBSLOP;
			tb->rc.top    += THUMBSLOP;
			tb->rc.left   += tb->wThumbWidth/2;
			tb->rc.right  -= tb->wThumbWidth/2;

			// Figure out how much room we have to move the thumb in
			//!!! -2
			tb->iSizePhys = tb->rc.right - tb->rc.left;
	
			// Elevator isn't there if there's no room.
			if (tb->iSizePhys == 0) {
				// Lost our thumb.
				tb->Flags |= TBF_NOTHUMB;
				tb->iSizePhys = 1;
			} else {
				// Ah. We have a thumb.
				tb->Flags &= ~TBF_NOTHUMB;
			}
			InvalidateRect(hwnd, NULL, TRUE);
			MoveThumb(tb, tb->lLogPos);
			break;
			
		case WM_DESTROY:
			TrackBarDestroy(hwnd);
			FreeDitherBrush();
			DestroyThumb();
			break;
	
		case WM_SETFOCUS:
			// We gots the focus. We need a caret.
	
			CreateCaret(hwnd, (HBITMAP)1,
				3, tb->wThumbHeight - 2 * THUMBSLOP);
			SetTBCaretPos(tb);
			ShowCaret(hwnd);
			break;
	
		case WM_KILLFOCUS:
			DestroyCaret();
			break;

		case WM_ERASEBKGND:
			hdc = (HDC) wParam;
#ifdef _WIN32
			hbr = (HBRUSH)(UINT)SendMessage(GetParent(hwnd),
				WM_CTLCOLORSTATIC, (WPARAM) hdc, (LPARAM)hwnd);
#else
			hbr = (HBRUSH)(UINT)SendMessage(GetParent(hwnd),
				WM_CTLCOLOR, (WPARAM) hdc,
				MAKELONG(hwnd, CTLCOLOR_STATIC);
#endif

			if (hbr) {
			    GetClientRect(hwnd, &rc);
			    FillRect(hdc, &rc, hbr);
			    return(FALSE);
			}
			return(TRUE);
			break;

		case WM_ENABLE:
			InvalidateRect(hwnd, NULL, FALSE);
			break;

		case WM_PAINT:
			if (wParam == 0)
			    tb->hdc = BeginPaint(hwnd, &ps);
			else
			    tb->hdc = (HDC)wParam;

			// Update the dither brush if necessary.
			CheckSysColors();

			DrawTics(tb);
			DrawThumb(tb);
			ExcludeClipRect(tb->hdc, tb->Thumb.left, tb->Thumb.top,
			    tb->Thumb.right, tb->Thumb.bottom);
			DrawChannel(tb);
			SetTBCaretPos(tb);
	
			if (wParam == 0)
				EndPaint(hwnd, &ps);

			tb->hdc = NULL;
			break;

		case WM_GETDLGCODE:
			return DLGC_WANTARROWS;
			break;
	
		case WM_LBUTTONDOWN:
			/* Give ourselves focus */
			// !!! MCIWnd wants to keep focus
			// SetFocus(hwnd);
			TBTrackInit(tb, lParam);
			break;
	
		case WM_LBUTTONUP:
			// We're through doing whatever we were doing with the
			// button down.
			TBTrackEnd(tb, lParam);
			break;
	
		case WM_TIMER:
			// The only way we get a timer message is if we're
			// autotracking.
			lParam = GetMessagePos();
			ScreenToClient(tb->hwnd, (LPPOINT)&lParam);

			// fall through to WM_MOUSEMOVE
	
		case WM_MOUSEMOVE:
			// We only care that the mouse is moving if we're
			// tracking the bloody thing.
			if (tb->Cmd != (UINT)-1) {
				if (GetCapture() != tb->hwnd) {
				    TBTrackEnd(tb, lParam);
				    return 0L;
				}
				TBTrack(tb, lParam);
			}
			return 0L;
			
		case WM_KEYUP:
			// If key was any of the keyboard accelerators, send end
			// track message when user up clicks on keyboard
			switch (wParam) {
				case VK_HOME:
				case VK_END:
				case VK_PRIOR:
				case VK_NEXT:
				case VK_LEFT:
				case VK_UP:
				case VK_RIGHT:
				case VK_DOWN:
					DoTrack(tb, TB_ENDTRACK, 0);
					break;
				default:
					break;
			}
			break;
	
		case WM_KEYDOWN:
			switch (wParam) {
				case VK_HOME:
					wParam = TB_TOP;
					goto KeyTrack;
	
				case VK_END:
					wParam = TB_BOTTOM;
					goto KeyTrack;
	
				case VK_PRIOR:
					wParam = TB_PAGEUP;
					goto KeyTrack;
	
				case VK_NEXT:
					wParam = TB_PAGEDOWN;
					goto KeyTrack;
	
				case VK_LEFT:
				case VK_UP:
					wParam = TB_LINEUP;
					goto KeyTrack;
	
				case VK_RIGHT:
				case VK_DOWN:
					wParam = TB_LINEDOWN;
KeyTrack:
					DoTrack(tb, wParam, 0);
					break;
	
				default:
					break;
			}
			break;

		case TBM_GETPOS:
			return tb->lLogPos;
	
		case TBM_GETSELSTART:
			return tb->lSelStart;

		case TBM_GETSELEND:
			return tb->lSelEnd;

		case TBM_GETRANGEMIN:
			return tb->lLogMin;

		case TBM_GETRANGEMAX:
			return tb->lLogMax;
	
		case TBM_GETPTICS:
			return (LONG)(LPVOID)tb->pTics;
	
		case TBM_CLEARSEL:
                        tb->Flags &= ~TBF_SELECTION;
			tb->lSelStart = -1;
			tb->lSelEnd   = -1;
			goto RedrawTB;

		case TBM_CLEARTICS:
			if (tb->pTics)
			    LocalFree((HLOCAL)tb->pTics);

			tb->nTics = 0;
			tb->pTics = NULL;
			goto RedrawTB;

		case TBM_GETTIC:

			if (tb->pTics == NULL || (int)wParam >= tb->nTics)
			    return -1L;

			return tb->pTics[wParam];

		case TBM_GETTICPOS:

			if (tb->pTics == NULL || (int)wParam >= tb->nTics)
			    return -1L;

			return TBLogToPhys(tb,tb->pTics[wParam]);

		case TBM_GETNUMTICS:
			return tb->nTics;

		case TBM_SETTIC:
			/* not a valid position */
			if (lParam < 0)
			    break;

			if (tb->pTics)
				h = LocalReAlloc((HLOCAL)tb->pTics,
				    sizeof(DWORD) * (UINT)(tb->nTics + 1),
				    LMEM_MOVEABLE | LMEM_ZEROINIT);
			else
				h = LocalAlloc(LPTR, sizeof(DWORD));

			if (h)
				tb->pTics = (PDWORD)h;
			else
				return (LONG)FALSE;

			tb->pTics[tb->nTics++] = (DWORD)lParam;

			InvalidateRect(hwnd, NULL, TRUE);
			return (LONG)TRUE;
			break;
	
		case TBM_SETPOS:
			/* Only redraw if it will physically move */
			if (wParam && TBLogToPhys(tb, lParam) !=
						TBLogToPhys(tb, tb->lLogPos))
			    MoveThumb(tb, lParam);
			else
			    tb->lLogPos = BOUND(lParam,tb->lLogMin,tb->lLogMax);
			break;

		case TBM_SETSEL:
                        tb->Flags |= TBF_SELECTION;
			tb->lSelStart = LOWORD(lParam);
			tb->lSelEnd   = HIWORD(lParam);
			if (tb->lSelEnd < tb->lSelStart)
			    tb->lSelEnd = tb->lSelStart;
			goto RedrawTB;
	
		case TBM_SETSELSTART:
                        tb->Flags |= TBF_SELECTION;
			tb->lSelStart = lParam;
			if (tb->lSelEnd < tb->lSelStart || tb->lSelEnd == -1)
			    tb->lSelEnd = tb->lSelStart;
			goto RedrawTB;
	
		case TBM_SETSELEND:
                        tb->Flags |= TBF_SELECTION;
			tb->lSelEnd   = lParam;
			if (tb->lSelStart > tb->lSelEnd || tb->lSelStart == -1)
			    tb->lSelStart = tb->lSelEnd;
			goto RedrawTB;
	
		case TBM_SETRANGE:
			tb->lLogMin = LOWORD(lParam);
			tb->lLogMax = HIWORD(lParam);
                        DoAutoTics(tb);
			goto RedrawTB;

		case TBM_SETRANGEMIN:
			tb->lLogMin = (DWORD)lParam;
			goto RedrawTB;

		case TBM_SETRANGEMAX:
			tb->lLogMax = (DWORD)lParam;
	RedrawTB:
			tb->lLogPos = BOUND(tb->lLogPos, tb->lLogMin,tb->lLogMax);
			/* Only redraw if flag says so */
			if (wParam) {
			    InvalidateRect(hwnd, NULL, TRUE);
			    MoveThumb(tb, tb->lLogPos);
			}
			break;
	}
	return DefWindowProc(hwnd, message, wParam, lParam);
}

/* DoTrack() */

static void NEAR PASCAL DoTrack(PTrackBar tb, int cmd, DWORD dwPos)
{
	// note: we only send back a WORD worth of the position.
#ifdef _WIN32
	SendMessage(GetParent(tb->hwnd), WM_HSCROLL,
	    MAKELONG(cmd, LOWORD(dwPos)), (LPARAM)tb->hwnd);
#else
	SendMessage(GetParent(tb->hwnd), WM_HSCROLL, cmd,
	    MAKELONG(LOWORD(dwPos), tb->hwnd));
#endif
}

/* WTrackType() */

static WORD NEAR PASCAL WTrackType(PTrackBar tb, LONG lParam)
{
	POINT pt;
#ifdef _WIN32
	LONG2POINT(lParam, pt);
#else
	pt = MAKEPOINT(lParam);
#endif

	if (tb->Flags & TBF_NOTHUMB)            // If no thumb, just leave.
	    return 0;

	if (PtInRect(&tb->Thumb, pt))
	    return TB_THUMBTRACK;

	if (!PtInRect(&tb->rc, pt))
	    return 0;

	if (pt.x >= tb->Thumb.left)
	    return TB_PAGEDOWN;
	else
	    return TB_PAGEUP;
}

/* TBTrackInit() */

static void NEAR PASCAL TBTrackInit(PTrackBar tb, LONG lParam)
{
	UINT wCmd;

	if (tb->Flags & TBF_NOTHUMB)         // No thumb:  just leave.
	    return;

        wCmd = WTrackType(tb, lParam);
	if (!wCmd)
	    return;

	HideCaret(tb->hwnd);
	SetCapture(tb->hwnd);

	tb->Cmd = wCmd;
	tb->dwDragPos = (DWORD)-1;

	// Set up for auto-track (if needed).
	if (wCmd != TB_THUMBTRACK) {
		// Set our timer up
		tb->Timer = (UINT)SetTimer(tb->hwnd, TIMER_ID, REPEATTIME, NULL);
	}

	TBTrack(tb, lParam);
}

/* EndTrack() */

static void near PASCAL TBTrackEnd(PTrackBar tb, long lParam)
{
	lParam = lParam; // Just reference this variable

// 	If we lose mouse capture we need to call this
//	if (GetCapture() != tb->hwnd)
//	    return;

	// Let the mouse go.
	ReleaseCapture();

	// Decide how we're ending this thing.
	if (tb->Cmd == TB_THUMBTRACK)
		DoTrack(tb, TB_THUMBPOSITION, tb->dwDragPos);

	if (tb->Timer)
		KillTimer(tb->hwnd, TIMER_ID);

	tb->Timer = 0;

	// Always send TB_ENDTRACK message.
	DoTrack(tb, TB_ENDTRACK, 0);

	// Give the caret back.
	ShowCaret(tb->hwnd);

	// Nothing going on.
	tb->Cmd = (UINT)-1;

	MoveThumb(tb, tb->lLogPos);
}

static void NEAR PASCAL TBTrack(PTrackBar tb, LONG lParam)
{
	DWORD dwPos;

	// See if we're tracking the thumb
	if (tb->Cmd == TB_THUMBTRACK) {
		dwPos = TBPhysToLog(tb, LOWORD(lParam));

		// Tentative position changed -- notify the guy.
		if (dwPos != tb->dwDragPos) {
			tb->dwDragPos = dwPos;
			MoveThumb(tb, dwPos);
			DoTrack(tb, TB_THUMBTRACK, dwPos);
		}
	}
	else {
		if (tb->Cmd != WTrackType(tb, lParam))
		    return;

		DoTrack(tb, tb->Cmd, 0);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd.16\ctlspriv.h ===
//#define WINVER 0x400
#define _3DSTUFF

#define BUILDDLL

#ifndef STRICT
#define STRICT
#endif

/* disable "non-standard extension" warnings in our code
 */
#ifndef RC_INVOKED
#if 0
#pragma warning(disable:4001)
#endif
#endif

#include <windows.h>

#ifdef WIN32
#include <port1632.h>
#else // WIN32
#define GETWINDOWID(hwnd)		GetWindowWord(hwnd, GWW_ID)
#endif

#define NOUPDOWN
#define NOSTATUSBAR
#define NOMENUHELP
#define NOBTNLIST
#define NODRAGLIST
#define NOPROGRESS
#include "commctrl.h"

#ifdef WIN32
#define SETWINDOWPOINTER(hwnd, name, p)	SetWindowLong(hwnd, 0, (LONG)p)
#define GETWINDOWPOINTER(hwnd, name)	((name)GetWindowLong(hwnd, 0))
#else // WIN32
#define SETWINDOWPOINTER(hwnd, name, p)	SetWindowWord(hwnd, 0, (WORD)p)
#define GETWINDOWPOINTER(hwnd, name)	((name)GetWindowWord(hwnd, 0))
#endif
#define ALLOCWINDOWPOINTER(name, size)	((name)LocalAlloc(LPTR, size))
#define FREEWINDOWPOINTER(p)		LocalFree((HLOCAL)p)

BOOL    WINAPI MyGetPrivateProfileStruct(LPCSTR, LPCSTR, LPVOID, UINT, LPCSTR);
BOOL    WINAPI MyWritePrivateProfileStruct(LPCSTR, LPCSTR, LPVOID, UINT, LPCSTR);


extern HINSTANCE hInst;

BOOL FAR PASCAL InitToolbarClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitStatusClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitHeaderClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitButtonListBoxClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitTrackBar(HINSTANCE hInstance);
BOOL FAR PASCAL InitUpDownClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitProgressClass(HINSTANCE hInstance);

void FAR PASCAL NewSize(HWND hWnd, int nClientHeight, LONG style,
      int left, int top, int width, int height);

#define IDS_SPACE	0x0400

/* System MenuHelp
 */
#define MH_SYSMENU	(0x8000 - MINSYSCOMMAND)
#define IDS_SYSMENU	(MH_SYSMENU-16)
#define IDS_HEADER	(MH_SYSMENU-15)
#define IDS_HEADERADJ	(MH_SYSMENU-14)
#define IDS_TOOLBARADJ	(MH_SYSMENU-13)

/* Cursor ID's
 */
#define IDC_SPLIT	100
#define IDC_MOVEBUTTON	102

#define IDC_STOP	103
#define IDC_COPY	104
#define IDC_MOVE	105

/* Icon ID's
 */
#define IDI_INSERT	150

/* AdjustDlgProc stuff
 */
#define ADJUSTDLG	200
#define IDC_BUTTONLIST	201
#define IDC_RESET	202
#define IDC_CURRENT	203
#define IDC_REMOVE	204
#define IDC_HELP	205
#define IDC_MOVEUP	206
#define IDC_MOVEDOWN	207

/* bitmap IDs
 */

#define IDB_THUMB       300

/* These are the internal structures used for a status bar.  The header
 * bar code needs this also
 */
typedef struct tagSTRINGINFO
  {
    DWORD dwString;
    UINT uType;
    int right;
  } STRINGINFO, *PSTRINGINFO;

typedef struct tagSTATUSINFO
  {
    HFONT hStatFont;
    BOOL bDefFont;

    int nFontHeight;
    int nMinHeight;
    int nBorderX, nBorderY, nBorderPart;

    STRINGINFO sSimple;

    int nParts;
    STRINGINFO sInfo[1];
  } STATUSINFO, *PSTATUSINFO;

#define SBT_NOSIMPLE	0x00ff	/* Flags to indicate normal status bar */

/* This is the default status bar face name
 */
extern char szSansSerif[];

/* Note that window procedures in protect mode only DLL's may be called
 * directly.
 */
void FAR PASCAL PaintStatusWnd(HWND hWnd, PSTATUSINFO pStatusInfo,
      PSTRINGINFO pStringInfo, int nParts, int nBorderX, BOOL bHeader);
LRESULT CALLBACK StatusWndProc(HWND hWnd, UINT uMessage, WPARAM wParam,
      LPARAM lParam);

/* toolbar.c */

typedef struct tagTBBMINFO {		/* info for recreating the bitmaps */
    int nButtons;
    HINSTANCE hInst;
    WORD wID;
    HBITMAP hbm;
} TBBMINFO, NEAR *PTBBMINFO;

typedef struct tagTBSTATE {		/* instance data for toolbar window */
    PTBBUTTON pCaptureButton;
    HWND hdlgCust;
    HWND hwndCommand;
    int nBitmaps;
    PTBBMINFO pBitmaps;
    HBITMAP hbmCache;
    PSTR *pStrings;
    int nStrings;
    UINT uStructSize;
    int iDxBitmap;
    int iDyBitmap;
    int iButWidth;
    int iButHeight;
    int iYPos;
    int iBarHeight;
    int iNumButtons;
    int nSysColorChanges;
    WORD wButtonType;
    TBBUTTON Buttons[1];
} TBSTATE, NEAR *PTBSTATE;

typedef struct tagOLDTBBUTTON
{
/*REVIEW: index, command, flag words, resource ids should be UINT */
    int iBitmap;	/* index into bitmap of this button's picture */
    int idCommand;	/* WM_COMMAND menu ID that this button sends */
    BYTE fsState;	/* button's state */
    BYTE fsStyle;	/* button's style */
    int idsHelp;	/* string ID for button's status bar help */
} OLDTBBUTTON;
typedef OLDTBBUTTON FAR* LPOLDTBBUTTON;

static HBITMAP FAR PASCAL SelectBM(HDC hDC, PTBSTATE pTBState, int nButton);
static void FAR PASCAL DrawButton(HDC hdc, int x, int y, int dx, int dy,PTBSTATE pTBState, PTBBUTTON ptButton, BOOL bCache);
static int  FAR PASCAL TBHitTest(PTBSTATE pTBState, int xPos, int yPos);
static int  FAR PASCAL PositionFromID(PTBSTATE pTBState, int id);
static void FAR PASCAL BuildButtonTemplates(void);
static void FAR PASCAL TBInputStruct(PTBSTATE pTBState, LPTBBUTTON pButtonInt, LPTBBUTTON pButtonExt);
static void FAR PASCAL TBOutputStruct(PTBSTATE pTBState, LPTBBUTTON pButtonInt, LPTBBUTTON pButtonExt);

/* tbcust.c */
extern BOOL FAR PASCAL SaveRestore(HWND hWnd, PTBSTATE pTBState, BOOL bWrite,
      LPSTR FAR *lpNames);
extern void FAR PASCAL CustomizeTB(HWND hWnd, PTBSTATE pTBState, int iPos);
extern void FAR PASCAL MoveButton(HWND hwndToolbar, PTBSTATE pTBState,
      int nSource);

/* cutils.c */
void FAR PASCAL NewSize(HWND hWnd, int nHeight, LONG style, int left, int top, int width, int height);
BOOL FAR PASCAL CreateDitherBrush(BOOL bIgnoreCount);	/* creates hbrDither */
BOOL FAR PASCAL FreeDitherBrush(void);
void FAR PASCAL CreateThumb(BOOL bIgnoreCount);
void FAR PASCAL DestroyThumb(void);
void FAR PASCAL CheckSysColors(void);

extern HBRUSH hbrDither;
extern HBITMAP hbmThumb;
extern int nSysColorChanges;
extern DWORD rgbFace;			// globals used a lot
extern DWORD rgbShadow;
extern DWORD rgbHilight;
extern DWORD rgbFrame;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd.16\bmpload.c ===
#include "ctlspriv.h"

//
//  include HEX forms of some standard bitmaps
//
#include "toolbar.hex"
#include "thumb.hex"

// these are the default colors used to map the dib colors
// to the current system colors

#define RGB_BUTTONTEXT      (RGB(000,000,000))  // black
#define RGB_BUTTONSHADOW    (RGB(128,128,128))  // dark grey
#define RGB_BUTTONFACE      (RGB(192,192,192))  // bright grey
#define RGB_BUTTONHILIGHT   (RGB(255,255,255))  // white
#define RGB_BACKGROUNDSEL   (RGB(000,000,255))  // blue
#define RGB_BACKGROUND      (RGB(255,000,255))  // magenta
#define FlipColor(rgb)      (RGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb)))

#define MAX_COLOR_MAPS      16

HBITMAP WINAPI CreateMappedDib(LPBITMAPINFOHEADER lpBitmapInfo,
      WORD wFlags, LPCOLORMAP lpColorMap, int iNumMaps)
{
  HDC			hdc, hdcMem = NULL;
  DWORD FAR		*p;
  DWORD FAR		*lpTable;
  LPBYTE                lpBits;
  HBITMAP		hbm = NULL, hbmOld;
  int numcolors, i;
  int wid, hgt;
  DWORD			rgbMaskTable[16];
  DWORD                 rgbSave[16];
  DWORD			rgbBackground;
  static const COLORMAP SysColorMap[] = {
    {RGB_BUTTONTEXT,    COLOR_BTNTEXT},     // black
    {RGB_BUTTONSHADOW,  COLOR_BTNSHADOW},   // dark grey
    {RGB_BUTTONFACE,    COLOR_BTNFACE},     // bright grey
    {RGB_BUTTONHILIGHT, COLOR_BTNHIGHLIGHT},// white
    {RGB_BACKGROUNDSEL, COLOR_HIGHLIGHT},   // blue
    {RGB_BACKGROUND,    COLOR_WINDOW}       // magenta
  };
  #define NUM_DEFAULT_MAPS (sizeof(SysColorMap)/sizeof(COLORMAP))
  COLORMAP DefaultColorMap[NUM_DEFAULT_MAPS];
  COLORMAP DIBColorMap[MAX_COLOR_MAPS];

  if (!lpBitmapInfo)
    return NULL;

  hmemcpy(rgbSave, lpBitmapInfo+1, 16 * sizeof(RGBQUAD));

  /* Get system colors for the default color map */
  if (!lpColorMap) {
    lpColorMap = DefaultColorMap;
    iNumMaps = NUM_DEFAULT_MAPS;
    for (i=0; i < iNumMaps; i++) {
      lpColorMap[i].from = SysColorMap[i].from;
      lpColorMap[i].to = GetSysColor((int)SysColorMap[i].to);
    }
  }

  /* Transform RGB color map to a BGR DIB format color map */
  if (iNumMaps > MAX_COLOR_MAPS)
    iNumMaps = MAX_COLOR_MAPS;
  for (i=0; i < iNumMaps; i++) {
    DIBColorMap[i].to = FlipColor(lpColorMap[i].to);
    DIBColorMap[i].from = FlipColor(lpColorMap[i].from);
  }

  lpTable = p = (DWORD FAR *)((LPBYTE)lpBitmapInfo + (int)lpBitmapInfo->biSize);

  /* Replace button-face and button-shadow colors with the current values
   */
  numcolors = 16;

  // if we are creating a mask, build a color table with white
  // marking the transparent section (where it used to be background)
  // and black marking the opaque section (everything else).  this
  // table is used below to build the mask using the original DIB bits.
  if (wFlags & CMB_MASKED) {
      rgbBackground = FlipColor(RGB_BACKGROUND);
      for (i = 0; i < 16; i++) {
          if (p[i] == rgbBackground)
              rgbMaskTable[i] = 0xFFFFFF;	// transparent section
          else
              rgbMaskTable[i] = 0x000000;	// opaque section
      }
  }

  while (numcolors-- > 0) {
      for (i = 0; i < iNumMaps; i++) {
          if (*p == DIBColorMap[i].from) {
              *p = DIBColorMap[i].to;
              break;
          }
      }
      p++;
  }

  /* First skip over the header structure */
  lpBits = (LPVOID)((LPBYTE)lpBitmapInfo + (int)lpBitmapInfo->biSize);

  /* Skip the color table entries, if any */
  lpBits += (1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD);

  /* Create a color bitmap compatible with the display device */
  i = wid = (int)lpBitmapInfo->biWidth;
  hgt = (int)lpBitmapInfo->biHeight;
  hdc = GetDC(NULL);
  hdcMem = CreateCompatibleDC(hdc);
  if (!hdcMem)
      goto cleanup;
      
  // if creating a mask, the bitmap needs to be twice as wide.
  if (wFlags & CMB_MASKED)
      i = wid*2;

  if (wFlags & CMB_DISCARDABLE)
      hbm = CreateDiscardableBitmap(hdc, i, hgt);
  else
      hbm = CreateCompatibleBitmap(hdc, i, hgt);
  if (hbm) {
      hbmOld = SelectObject(hdcMem, hbm);

      // set the main image
      StretchDIBits(hdcMem, 0, 0, wid, hgt, 0, 0, wid, hgt, lpBits, 
                 (LPBITMAPINFO)lpBitmapInfo, DIB_RGB_COLORS, SRCCOPY);

      // if building a mask, replace the DIB's color table with the
      // mask's black/white table and set the bits.  in order to 
      // complete the masked effect, the actual image needs to be
      // modified so that it has the color black in all sections
      // that are to be transparent.
      if (wFlags & CMB_MASKED) {
          hmemcpy(lpTable, (DWORD FAR *)rgbMaskTable, 16 * sizeof(RGBQUAD));
          StretchDIBits(hdcMem, wid, 0, wid, hgt, 0, 0, wid, hgt, lpBits, 
                 (LPBITMAPINFO)lpBitmapInfo, DIB_RGB_COLORS, SRCCOPY);
          BitBlt(hdcMem, 0, 0, wid, hgt, hdcMem, wid, 0, 0x00220326);   // DSna
      }
      SelectObject(hdcMem, hbmOld);
  }

cleanup:
  if (hdcMem)
      DeleteObject(hdcMem);
  ReleaseDC(NULL, hdc);

  hmemcpy(lpBitmapInfo+1, rgbSave, 16 * sizeof(RGBQUAD));
  return hbm;
}

HBITMAP WINAPI CreateMappedBitmap(HINSTANCE hInstance, int idBitmap,
      WORD wFlags, LPCOLORMAP lpColorMap, int iNumMaps)
{
  HANDLE    h;
  HANDLE    hRes;
  HBITMAP   hbm;
  LPBITMAPINFOHEADER lpbi;

  h = FindResource(hInstance, MAKEINTRESOURCE(idBitmap), RT_BITMAP);

  if (!h)
  {
      if (idBitmap == IDB_THUMB)
        lpbi = (LPVOID)Bitmap_Thumb;
      else
        lpbi = (LPVOID)Bitmap_Toolbar;

      return CreateMappedDib(lpbi, wFlags, lpColorMap, iNumMaps);
  }

  hRes = LoadResource(hInstance, h);

  /* Lock the bitmap and get a pointer to the color table. */
  lpbi = (LPBITMAPINFOHEADER)LockResource(hRes);
  if (!lpbi)
    return NULL;

  hbm = CreateMappedDib(lpbi, wFlags, lpColorMap, iNumMaps);

  UnlockResource(hRes);
  FreeResource(hRes);

  return hbm;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd.16\movplay.h ===
/* dialogs */
#define ABOUTBOX        1

/* Menu Items */

#define MENU_ABOUT	1000
#define MENU_EXIT	1001
#define MENU_NEW	1002
#define MENU_CLOSE	1003
#define MENU_CLOSEALL	1004
#define MENU_OPEN	1005

/* Movie menu */
#define IDM_STOP        9
#define IDM_PLAY	10
#define IDM_HOME	11
#define IDM_END 	12
#define IDM_STEP	13
#define IDM_RSTEP	14
#define IDM_RPLAY	15
#define IDM_PAUSE       16

#define IDM_SAutosizeWindow	17
#define IDM_SAutosizeMovie	18
#define IDM_SPlaybar		19
#define IDM_SMenu		20
#define IDM_SShowName		21
#define IDM_SShowMode		22
#define IDM_SShowPos		23
#define IDM_SNotifyMedia	24
#define IDM_SNotifyMode		25
#define IDM_SNotifyPos		26
#define IDM_SNotifySize		27
#define IDM_SRecord		28
#define IDM_SErrorDlg		29
#define IDM_SRepeat		30
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd.16\mciwndi.h ===
/*----------------------------------------------------------------------------*\
 *
 *  MCIWnd
 *
 *    MCIWnd window class *internal* header file.
 *
 *----------------------------------------------------------------------------*/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <digitalv.h>
#include <commdlg.h>
#include <shellapi.h>
#include "preview.h"

#define NOUPDOWN
#define NOSTATUSBAR
#define NOMENUHELP
#define NOBTNLIST
#define NODRAGLIST
#define NOPROGRESS

#include "strings.rc"
#include "commctrl.h"
#include "mciwnd.h"

/**************************************************************************
***************************************************************************/

#define GetWS(hwnd)     GetWindowLong(hwnd, GWL_STYLE)
#define PutWS(hwnd, f)  SetWindowLong(hwnd, GWL_STYLE, f)
#define TestWS(hwnd,f)  (GetWS(hwnd) & f)
#define SetWS(hwnd, f)  ((PutWS(hwnd, GetWS(hwnd) | f) & (f)) != (f))
#define ClrWS(hwnd, f)  ((PutWS(hwnd, GetWS(hwnd) & ~(f)) & (f)) != 0)

/******************************************************************************
 *****************************************************************************/

#ifdef DEBUG
    #define MODNAME "MCIWnd"
    static void cdecl dprintf(PSTR sz, ...);
    #define DPF     dprintf
#else
    #define DPF     ; / ## /
#endif

#define ABS(x)  ((int)(x) > 0) ? (x) : (-(x))

// the place we load internationalizable strings into
static char szString[128];
#define LoadSz(ID) (LoadString(hInst, ID, szString, sizeof(szString)), szString)

/******************************************************************************
 *****************************************************************************/

// !!! Ack!  A global in a library!  But the Common Control code needs
// !!! to know the instance that registered the class.  I think.
HINSTANCE hInst;

char aszMCIWndClassName[] = MCIWND_WINDOW_CLASS;

// A brush to draw our OwnerDraw menus with
extern BOOL FAR PASCAL CreateDitherBrush(BOOL bIgnoreCount);
extern BOOL FAR PASCAL FreeDitherBrush(void);
extern HBRUSH hbrDither;

/******************************************************************************
 *****************************************************************************/

// icky constants
#define TIMER1  	1
#define TIMER2  	2
#define ACTIVE_TIMER	500
#define INACTIVE_TIMER	2000

#define IDBMP_TOOLBAR   959
#define ID_TOOLBAR	747
#define TB_HEIGHT       21 //23         // toolbar windows are this high
#define STANDARD_WIDTH  300		// width of non-windowed toolbar
#define SMALLEST_WIDTH  60		// smallest width allowed

#define IDM_MCIZOOM	 11000
#define IDM_MCIVOLUME	 12000
#define VOLUME_MAX	 200
#define IDM_MCISPEED	 13000
#define SPEED_MAX    	 200

#define IDM_MCINEW	103
#define IDM_MCIOPEN	104
#define IDM_MCICLOSE	105
#define IDM_MCIREWIND   106
#define IDM_MENU        107	// menu button and menu id
#define IDM_MCIEJECT    108	// eject button id
#define TOOLBAR_END     109	// last item in toolbar
#define IDM_MCICONFIG   110     // bring up a configure box
#define IDM_MCICOMMAND	111
#define IDM_COPY	112

/******************************************************************************
 *****************************************************************************/

typedef struct {
    HWND    hwnd;
    HWND    hwndOwner;	// who gets notification
    UINT    alias;
    UINT    wDeviceID;
    UINT    wDeviceType;
    DWORD   dwError;
    DWORD   dwStyle;
    BOOL    fHasTracks;
    int	    iNumTracks;
    int	    iFirstTrack;
    LONG    *pTrackStart;
    BOOL    fRepeat;
    BOOL    fCanWindow;
    BOOL    fHasPalette;
    BOOL    fCanRecord;
    BOOL    fCanPlay;
    BOOL    fCanSave;
    BOOL    fCanEject;
    BOOL    fCanConfig;
    BOOL    fUsesFiles;
    BOOL    fVideo;
    BOOL    fAudio;
    BOOL    fMdiWindow;
    BOOL    fScrolling;
    BOOL    fTracking;
  //BOOL    fSeekExact;
    BOOL    fVolume;
    WORD    wMaxVol;
    BOOL    fSpeed;
    BOOL    fPlayAfterSeek;
    BOOL    fActive;            // Is this window active right now?
    BOOL    fMediaValid;        // have dwMediaStart and dwMediaLen been set?
    RECT    rcNormal;
    HMENU   hmenu;
    HMENU   hmenuVolume;
    HMENU   hmenuSpeed;
    HFONT   hfont;
    HWND    hwndToolbar;
    HWND    hwndTrackbar;
    DWORD   dwMediaStart;
    DWORD   dwMediaLen;
    WORD    wTimer;
    DWORD   dwMode;
    DWORD   dwPos;
    UINT    iZoom;
    UINT    iActiveTimerRate;
    UINT    iInactiveTimerRate;
    char    achFileName[128]; // to store open filename
    char    achReturn[128];   // to store result of the last SendString
    OPENFILENAME ofn;   // Remember current extension, etc. for opening files
    UINT    uiHack;	// For OwnerDraw hack
    HMENU   hmenuHack;	// For OwnerDraw hack
    HICON   hicon;
} MCIWND, NEAR * PMCIWND;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd.16\mciwnd.c ===
/*----------------------------------------------------------------------------*\
 *
 *  MCIWnd
 *
 *----------------------------------------------------------------------------*/

#include "mciwndi.h"

LONG FAR PASCAL _loadds MCIWndProc(HWND hwnd, unsigned msg, WORD wParam, LONG lParam);

static LONG OwnerDraw(PMCIWND p, UINT msg, WORD wParam, LONG lParam);
static BOOL NEAR PASCAL mciDialog(HWND hwnd);
static void NEAR PASCAL MCIWndCopy(PMCIWND p);

BOOL FAR _loadds MCIWndRegisterClass(void)
{
    WNDCLASS cls;

    // !!! We need to register a global class with the hinstance of the DLL
    // !!! because it's the DLL that has the code for the window class.
    // !!! Otherwise, the class goes away on us and things start to blow!
    // !!! HACK HACK HACK The hInstance is the current DS which is the high
    // !!! word of the address of all global variables --- sorry NT
#ifndef WIN32
    HINSTANCE hInstance = (HINSTANCE)HIWORD((LPVOID)&hInst); // random global
#else
    HINSTANCE hInstance = GetModuleHandle(NULL);
#endif

    // If we're already registered, we're OK
    if (GetClassInfo(hInstance, aszMCIWndClassName, &cls))
	return TRUE;

    // !!! Save the instance that created the class in a global for cutils.c
    // !!! which may need to know this.  I know, it's ugly.
    hInst = hInstance;

    cls.lpszClassName   = aszMCIWndClassName;
    cls.lpfnWndProc     = (WNDPROC)MCIWndProc;
    cls.style           = CS_GLOBALCLASS | CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS | CS_OWNDC;
    cls.hCursor         = LoadCursor(NULL,IDC_ARROW);
    cls.hIcon           = NULL;
    cls.lpszMenuName    = NULL;
    cls.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1);
    cls.hInstance	= hInstance;
    cls.cbClsExtra      = 0;
    cls.cbWndExtra      = sizeof(LPVOID); // big enough for far pointer

    if (RegisterClass(&cls)) {

	extern BOOL FAR PASCAL InitToolbarClass(HINSTANCE hInstance);
	extern BOOL FAR PASCAL InitTrackBar(HINSTANCE hInstance);

        if (!InitToolbarClass(hInstance))
	    return FALSE;
        if (!InitTrackBar(hInstance))
	    return FALSE;

        // !!! Other one-time initialization

	return TRUE;
    }

    return FALSE;
}

HWND FAR _loadds MCIWndCreate(HWND hwndParent, HINSTANCE hInstance,
		      DWORD dwStyle, LPSTR szFile)
{
    HWND hwnd;
    int x,y,dx,dy;

#ifdef WIN32
    #define GetCurrentInstance()    GetModuleHandle(NULL);
#else
    #define GetCurrentInstance()    SELECTOROF(((LPVOID)&hwndParent))
#endif

    if (hInstance == NULL)
        hInstance = GetCurrentInstance();

    if (!MCIWndRegisterClass())
	return NULL;

    if (HIWORD(dwStyle) == 0)
    {
	if (hwndParent)
	    dwStyle |= WS_CHILD | WS_BORDER | WS_VISIBLE;
	else
	    dwStyle |= WS_OVERLAPPEDWINDOW | WS_VISIBLE;
    }

    // !!! Do we really want to do this?
    dwStyle |= WS_CLIPCHILDREN | WS_CLIPSIBLINGS;

    x = y = dy = 0;
    dx = STANDARD_WIDTH;

    // If we're making a top level window, pick some reasonable position
    if (hwndParent == NULL && !(dwStyle & WS_POPUP)) {
        x = CW_USEDEFAULT;
	// Visible overlapped windows treat y as a ShowWindow flag
	if (dwStyle & WS_VISIBLE)
	    y = SW_SHOW;
    }
    
    // Our preview open dialog rips if we don't provide a non-zero ID for a
    // child window.

    hwnd =
#ifdef BIDI
	CreateWindowEx(WS_EX_BIDI_SCROLL |  WS_EX_BIDI_MENU |WS_EX_BIDI_NOICON,
#else
	CreateWindow (
#endif
			aszMCIWndClassName, szNULL, dwStyle,
                        x, y, dx, dy,
			hwndParent,
			(HMENU)((dwStyle & WS_CHILD) ? 0x42 : NULL),
			hInstance, (LPVOID)szFile);

    return hwnd;
}

//
// Give a notification of something interesting to the proper authorites.
//
static LRESULT NotifyOwner(PMCIWND p, unsigned msg, WPARAM wParam, LPARAM lParam)
{
    if (p->hwndOwner)
	return SendMessage(p->hwndOwner, msg, wParam, lParam);
    else
	return 0;
}

//
// If an error occured, set our error code and maybe bring up a dialog
// Clears the error code if command was successful.
//
static void MCIWndiHandleError(PMCIWND p, DWORD dw)
{
    char	ach[128];

    // Set/Clear our error code
    p->dwError = dw;

    if (dw) {

	// We want to bring up a dialog on errors, so do so.
	// Don't bring up a dialog while we're moving the thumb around because
	// that'll REALLY confuse the mouse capture
	if (!(p->dwStyle & MCIWNDF_NOERRORDLG) && !p->fScrolling &&
							!p->fTracking) {
	    mciGetErrorString(p->dwError, ach, sizeof(ach));
	    MessageBox(p->hwnd, ach, LoadSz(IDS_MCIERROR),
#ifdef BIDI
		       MB_RTL_READING |
#endif
		       MB_ICONEXCLAMATION | MB_OK);
	}

	// The "owner" wants to know the error.  We tell him after we
	// bring up the dialog, because otherwise, our VBX never gets this
	// event.  (Wierd...)
	if (p->dwStyle & MCIWNDF_NOTIFYERROR) {
	    NotifyOwner(p, MCIWNDM_NOTIFYERROR, p->hwnd, p->dwError);
	}

    }
}

//
// Send an MCI GetDevCaps command and return whether or not it's supported
// This will not set our error code
//
static BOOL MCIWndDevCaps(PMCIWND p, DWORD item)
{
    MCI_GETDEVCAPS_PARMS   mciDevCaps;
    DWORD               dw;

    if (p->wDeviceID == NULL)
        return FALSE;

    mciDevCaps.dwItem = (DWORD)item;

    dw = mciSendCommand(p->wDeviceID, MCI_GETDEVCAPS, MCI_GETDEVCAPS_ITEM,
			(DWORD)(LPVOID)&mciDevCaps);

    if (dw == 0)
	return (BOOL)mciDevCaps.dwReturn;
    else
	return FALSE;
}

//
// Send an MCI Status command.
// This will not set our error code
//
static DWORD MCIWndStatus(PMCIWND p, DWORD item, DWORD err)
{
    MCI_STATUS_PARMS    mciStatus;
    DWORD               dw;

    if (p->wDeviceID == NULL)
	return err;

    mciStatus.dwItem = (DWORD)item;

    dw = mciSendCommand(p->wDeviceID, MCI_STATUS, MCI_STATUS_ITEM,
			(DWORD)(LPVOID)&mciStatus);

    if (dw == 0)
	return mciStatus.dwReturn;
    else
	return err;
}

//
// Send an MCI String command
// Optionally set our error code.  Never clears it.
//
static DWORD MCIWndString(PMCIWND p, BOOL fSetErr, LPSTR sz, ...)
{
    char    ach[256];
    int     i;
    DWORD   dw;

    if (p->wDeviceID == NULL)
	return 0;

    for (i=0; *sz && *sz != ' '; )
	ach[i++] = *sz++;

    i += wsprintf(&ach[i], " %d ", (UINT)p->alias);
    i += wvsprintf(&ach[i], sz, &sz + 1);  //!!! use varargs

    dw = mciSendString(ach, NULL, 0, NULL);

    DPF("MCIWndString('%s'): %ld",(LPSTR)ach, dw);

    if (fSetErr)
	MCIWndiHandleError(p, dw);

    return dw;
}


static long atol(LPSTR sz)
{
    long l;

    //!!! check for (-) sign?
    for (l=0; *sz >= '0' && *sz <= '9'; sz++)
        l = l*10 + (*sz - '0');

    return l;
}

#define SLASH(c)     ((c) == '/' || (c) == '\\')

/*--------------------------------------------------------------+
| FileName  - return a pointer to the filename part of szPath   |
|             with no preceding path.                           |
+--------------------------------------------------------------*/
LPSTR FAR FileName(LPSTR szPath)
{
    LPCSTR   sz;

    sz = &szPath[lstrlen(szPath)];
    for (; sz>szPath && !SLASH(*sz) && *sz!=':';)
        sz = AnsiPrev(szPath, sz);
    return (sz>szPath ? (LPSTR)++sz : (LPSTR)sz);
}

//
// Sends an MCI String command and converts the return string to an integer
// Optionally sets our error code.  Never clears it.
//
static DWORD MCIWndGetValue(PMCIWND p, BOOL fSetErr, LPSTR sz, DWORD err, ...)
{
    char    achRet[20];
    char    ach[256];
    DWORD   dw;
    int     i;

    for (i=0; *sz && *sz != ' '; )
	ach[i++] = *sz++;

    if (p->wDeviceID)
	i += wsprintf(&ach[i], " %d ", (UINT)p->alias);
    i += wvsprintf(&ach[i], sz, &err + 1);  //!!!use varargs

    dw = mciSendString(ach, achRet, sizeof(achRet), NULL);

    DPF("MCIWndGetValue('%s'): %ld",(LPSTR)ach, dw);

    if (fSetErr)
        MCIWndiHandleError(p, dw);

    if (dw == 0) {
        DPF("GetValue('%s'): %ld",(LPSTR)ach, atol(achRet));
        return atol(achRet);
    } else {
        DPF("MCIGetValue('%s'): error=%ld",(LPSTR)ach, dw);
	return err;
    }
}

//
// Send an MCI command and get the return string back
// This never sets our error code.
//
// Note: szRet can be the same string as sz
//
static DWORD MCIWndGet(PMCIWND p, LPSTR sz, LPSTR szRet, int len, ...)
{
    char    ach[256];
    int     i;
    DWORD   dw;

    if (!p->wDeviceID) {
	szRet[0] = 0;
	return 0L;
    }
    
    for (i=0; *sz && *sz != ' '; )
	ach[i++] = *sz++;

    i += wsprintf(&ach[i], " %d ", (UINT)p->alias);
    i += wvsprintf(&ach[i], sz, &len + 1);  //!!!use varargs

    // initialize to NULL return string
    szRet[0] = 0;

    dw = mciSendString(ach, szRet, len, p->hwnd);

    DPF("MCIWndGet('%s'): '%s'",(LPSTR)ach, (LPSTR)szRet);

    return dw;
}

//
// Gets the source or destination rect from the MCI device
// Does NOT set our error code since this is an internal function
//
static void MCIWndRect(PMCIWND p, LPRECT prc, BOOL fSource)
{
    MCI_DGV_RECT_PARMS      mciRect;
    DWORD dw=0;

    SetRectEmpty(prc);

    if (p->wDeviceID)
        dw = mciSendCommand(p->wDeviceID, MCI_WHERE,
            (DWORD)fSource ? MCI_DGV_WHERE_SOURCE : MCI_DGV_WHERE_DESTINATION,
            (DWORD)(LPVOID)&mciRect);

    if (dw == 0)
        *prc = mciRect.rc;

    prc->right  += prc->left;
    prc->bottom += prc->top;
}


static VOID MCIWndiSizePlaybar(PMCIWND p)
{
    RECT rc;
    WORD w, h;

    // No playbar!!
    if (p->dwStyle & MCIWNDF_NOPLAYBAR)
	return;

    #define SLOP 7      // Left outdent of toolbar

    // How big a window are we putting a toolbar on?
    GetClientRect(p->hwnd, &rc);
    w = rc.right;
    h = rc.bottom;

    // Trackbar is a child of Toolbar
    SetWindowPos(p->hwndToolbar, NULL,
		-SLOP, h - TB_HEIGHT, w + SLOP, TB_HEIGHT,
		SWP_NOZORDER);

    // Make sure it's visible now
    ShowWindow(p->hwndToolbar, SW_SHOW);

    // Figure out where the toolbar ends and the trackbar begins
    SendMessage(p->hwndToolbar, TB_GETITEMRECT,
	(int)SendMessage(p->hwndToolbar, TB_COMMANDTOINDEX,
		TOOLBAR_END, 0),
	(LPARAM)(LPVOID)&rc);

    // Place the trackbar next to the end of the toolbar
    SetWindowPos(p->hwndTrackbar, NULL,
		rc.right, 3, w - rc.right + 5, TB_HEIGHT,	// !!!
		SWP_NOZORDER);

    //!!! Maybe put menu button on right side of trackbar?  So
    //!!! make sep the right size (size of the track bar!)
}

// Resize the window by the given percentage
// 0 means use DESTINATION rect and size it automatically
static VOID MCIWndiSize(PMCIWND p, int iSize)
{
    RECT rc, rcT;
    int  dx, dy;

    // If we're given a percentage, we take it from the SOURCE size.
    // For default, (zero), we use the destination size
    if (iSize)
        rc = p->rcNormal; /* get the original "normal size" rect */
    else {
	if (p->wDeviceID)
            MCIWndRect(p, &rc, FALSE);/* get the current (destination) size */
	else
	    SetRect(&rc, 0, 0, 0, 0);
	iSize = 100;
    }

    rc.bottom = MulDiv(rc.bottom, iSize, 100);
    rc.right = MulDiv(rc.right, iSize, 100);

    // Now set the movie to play in the new rect
    if (!IsRectEmpty(&rc))
        MCIWndString(p, FALSE, szPutDest,
	    0, 0, rc.right - rc.left, rc.bottom - rc.top);
	
    // If we're not supposed to resize our window to this new rect, at least
    // we'll fix up the toolbar before we leave (the buttons may have changed)
    if (p->dwStyle & MCIWNDF_NOAUTOSIZEWINDOW) {
	MCIWndiSizePlaybar(p);
	return;
    }

    // We're not a windowed device, or we're closed - don't touch our width
    if (IsRectEmpty(&rc)) {
        GetClientRect(p->hwnd, &rcT);
        rc.right = rcT.right;
    }

    // If we will have a playbar, grow the window by its height
    if (!(p->dwStyle & MCIWNDF_NOPLAYBAR))
        rc.bottom += TB_HEIGHT;

    // Now get the size for our window by growing it by its non-client size
    AdjustWindowRect(&rc, GetWindowLong(p->hwnd, GWL_STYLE), FALSE);

    // Now we have the new size for our MCIWND.  If it's not changing size,
    // the SetWindowPos will not generate a WM_SIZE and it won't call our
    // SizePlaybar to fix the toolbar.  So we better call it ourselves.
    // Sometimes we're off by one pixel and it STILL won't generate a WM_SIZE.
    GetWindowRect(p->hwnd, &rcT);
    dx = ABS((rcT.right - rcT.left) - (rc.right - rc.left));
    dy = ABS((rcT.bottom - rcT.top) - (rc.bottom - rc.top));
    if (dx < 2 && dy < 2)
	MCIWndiSizePlaybar(p);

    SetWindowPos(p->hwnd, NULL, 0, 0, rc.right - rc.left,
                    rc.bottom - rc.top,
                    SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE);

    // We need to notify the "owner" that our size changed
    if (p->dwStyle & MCIWNDF_NOTIFYSIZE)
	NotifyOwner(p, MCIWNDM_NOTIFYSIZE, p->hwnd, NULL);
}


//
// Figure out the position in ms of the beginning of the track we're on
//
static DWORD MCIWndiPrevTrack(PMCIWND p)
{
    DWORD	dw;
    int		iTrack;

    if (!p->fHasTracks)
	return 0;

    MCIWndString(p, FALSE, szSetFormatTMSF);
    dw = MCIWndStatus(p, MCI_STATUS_POSITION, 0); // return value is 0xFFSSMMTT
    iTrack = LOWORD(dw) & 0xFF;
    // If we're less than 1 second into the track, choose the previous track
    if ((iTrack > p->iFirstTrack) && (!(LOWORD(dw) & 0xFF00)) &&
			((HIWORD(dw) & 0xFF) == 0))
	iTrack--;
    dw = p->pTrackStart[iTrack - p->iFirstTrack];
    MCIWndString(p, FALSE, szSetFormatMS);
    return dw;
}

//
// Figure out the position in ms of the beginning of the next track
//
static DWORD MCIWndiNextTrack(PMCIWND p)
{
    DWORD	dw;
    int		iTrack;

    if (!p->fHasTracks)
	return 0;

    MCIWndString(p, FALSE, szSetFormatTMSF);
    dw = MCIWndStatus(p, MCI_STATUS_POSITION, 0); // return value is 0xTTMMSSFF
    iTrack = (LOWORD(dw) & 0xFF) + 1;
    if (iTrack >= p->iNumTracks + p->iFirstTrack)
	iTrack--;
    dw = p->pTrackStart[iTrack - p->iFirstTrack];
    MCIWndString(p, FALSE, szSetFormatMS);
    return dw;
}


//
// Figure out where the tracks begin for making tics
//
static void MCIWndiCalcTracks(PMCIWND p)
{
    int		i;

    if (!p->fHasTracks)
	return;

    p->iNumTracks = (int)MCIWndGetValue(p, FALSE, szStatusNumTracks, 0);
    p->iFirstTrack = MCIWndGetValue(p, FALSE, szStatusPosTrack, 0, 0) == 0
		? 1 : 0;

    if (p->pTrackStart)
	LocalFree((HANDLE)p->pTrackStart);

    if (p->iNumTracks) {
	p->pTrackStart = (LONG *)LocalAlloc(LPTR,
						p->iNumTracks * sizeof(LONG));
	if (p->pTrackStart == NULL) {
	    p->iNumTracks = 0;
	    p->fHasTracks = FALSE;
	}
	for (i = 0; i < p->iNumTracks; i++) {
	    p->pTrackStart[i] =
		MCIWndGetValue(p, FALSE, szStatusPosTrack, 0, 
		    p->iFirstTrack + i);
	}
    }
}


//
// Mark tics on the trackbar for the beginning of tracks
//
static void MCIWndiMarkTics(PMCIWND p)
{
    int		i;

    if (!p->fHasTracks)
	return;

    SendMessage(p->hwndTrackbar, TBM_SETTIC, 0, p->dwMediaStart);
    for (i = 0; i < p->iNumTracks; i++) {
	SendMessage(p->hwndTrackbar, TBM_SETTIC, 0, p->pTrackStart[i]);
    }
    SendMessage(p->hwndTrackbar, TBM_SETTIC,0, p->dwMediaStart + p->dwMediaLen);
}

static VOID MCIWndiValidateMedia(PMCIWND p)
{
    DWORD dw;

    if (!p->wDeviceID) {
	p->fMediaValid = FALSE;
	return;
    }

    dw = p->dwMediaLen;
    p->fMediaValid = TRUE;
    p->dwMediaStart = MCIWndGetStart(p->hwnd);
    p->dwMediaLen = MCIWndGetLength(p->hwnd);
    // !!! do something special if len=0?

    // We have a playbar, so set the ranges of the trackbar if we've changed
    if (dw != p->dwMediaLen && !(p->dwStyle & MCIWNDF_NOPLAYBAR)) {
	// must set position first or zero length range won't move thumb
        SendMessage(p->hwndTrackbar, TBM_CLEARTICS, TRUE, 0);
        SendMessage(p->hwndTrackbar, TBM_SETPOS, TRUE, p->dwMediaStart);
	SendMessage(p->hwndTrackbar, TBM_SETRANGEMIN, 0, p->dwMediaStart);
	SendMessage(p->hwndTrackbar, TBM_SETRANGEMAX, 0,
		p->dwMediaStart + p->dwMediaLen);

        MCIWndiCalcTracks(p);
        MCIWndiMarkTics(p);
    }
}

//
// Create the filter for the open dialog.  Caution: Don't overflow pchD !!!
//
static void MCIWndiBuildMeAFilter(LPSTR pchD)
{
    LPSTR	pchS;
    char	ach[128];

    // Our filter will look like:  "MCI Files\0*.avi;*.wav\0All Files\0*.*\0"
    // The actual extensions for the MCI files will come from the list in
    // the "mci extensions" section of win.ini

    lstrcpy(pchD, LoadSz(IDS_MCIFILES));

    // Creates a list like: "avi\0wav\0mid\0"
    GetProfileString(szMCIExtensions, NULL, szNULL, ach, sizeof(ach));
	
    for (pchD += lstrlen(pchD)+1, pchS = ach; *pchS;
		pchD += lstrlen(pchS)+3, pchS += lstrlen(pchS)+1) {
	lstrcpy(pchD, "*.");
	lstrcpy(pchD + 2, pchS);
	lstrcpy(pchD + 2 + lstrlen(pchS), ";");
    }
    if (pchS != ach)
	--pchD;		// erase the last ;
    *pchD = '\0';
    lstrcpy(++pchD, LoadSz(IDS_ALLFILES));
    pchD += lstrlen(pchD) + 1;
    lstrcpy(pchD, "*.*\0");
}

//
// Create the playbar windows we'll need later
//
static void MCIWndiMakeMeAPlaybar(PMCIWND p)
{
    TBBUTTON            tb[7];

    extern char aszTrackbarClassName[];

    // They don't want a playbar
    if (p->dwStyle & MCIWNDF_NOPLAYBAR)
	return;

    tb[0].iBitmap = 0;
    tb[0].idCommand = MCI_PLAY;
    tb[0].fsState = TBSTATE_ENABLED | TBSTATE_HIDDEN;
    tb[0].fsStyle = TBSTYLE_BUTTON;
    tb[0].iString = -1;

    tb[1].iBitmap = 2;
    tb[1].idCommand = MCI_STOP;
    tb[1].fsState = TBSTATE_ENABLED | TBSTATE_HIDDEN;
    tb[1].fsStyle = TBSTYLE_BUTTON;
    tb[1].iString = -1;

    tb[2].iBitmap = 4;
    tb[2].idCommand = MCI_RECORD;
    tb[2].fsState = TBSTATE_ENABLED | TBSTATE_HIDDEN;
    tb[2].fsStyle = TBSTYLE_BUTTON;
    tb[2].iString = -1;

    tb[3].iBitmap = 5;
    tb[3].idCommand = IDM_MCIEJECT;
    tb[3].fsState = TBSTATE_ENABLED | TBSTATE_HIDDEN;
    tb[3].fsStyle = TBSTYLE_BUTTON;
    tb[3].iString = -1;

#define MENUSEP 2
    tb[4].iBitmap = MENUSEP;
    tb[4].idCommand = -1;
    tb[4].fsState = 0;
    tb[4].fsStyle = TBSTYLE_SEP;
    tb[4].iString = -1;

    tb[5].iBitmap = 3;
    tb[5].idCommand = IDM_MENU;
    tb[5].fsState = TBSTATE_ENABLED;
    tb[5].fsStyle = TBSTYLE_BUTTON;
    tb[5].iString = -1;

    tb[6].iBitmap = 4;
    tb[6].idCommand = TOOLBAR_END;
    tb[6].fsState = 0;
    tb[6].fsStyle = TBSTYLE_SEP;
    tb[6].iString = -1;

    // Create invisible for now so it doesn't flash
    p->hwndToolbar = CreateToolbarEx(p->hwnd,
        WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
            CCS_NOPARENTALIGN | CCS_NORESIZE,
        ID_TOOLBAR, 7, GetWindowInstance(p->hwnd),
	IDBMP_TOOLBAR, (LPTBBUTTON)&tb[0], 7,
        13, 13, 13, 13, sizeof(TBBUTTON));	// buttons are 13x13

    p->hwndTrackbar =
#ifdef BIDI
	CreateWindowEx(WS_EX_BIDI_SCROLL |  WS_EX_BIDI_MENU |WS_EX_BIDI_NOICON,
#else
	CreateWindow (
#endif
	aszTrackbarClassName, NULL,
        WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
        0, 0, 0, 0, p->hwndToolbar, NULL, GetWindowInstance(p->hwnd), NULL);

    // Force ValidateMedia to actually update
    p->dwMediaStart = p->dwMediaLen = 0;

    // Set the proper range for the scrollbar
    MCIWndiValidateMedia(p);
}


//
// Gray/ungray toolbar buttons as necessary
//
static void MCIWndiPlaybarGraying(PMCIWND p)
{
    DWORD	dwMode;

    if (!(p->dwStyle & MCIWNDF_NOPLAYBAR)) {
	dwMode = MCIWndGetMode(p->hwnd, NULL, 0);

	if (dwMode == MCI_MODE_PLAY) {
	    // Hide PLAY Show STOP
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		MCI_PLAY, TRUE);
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		MCI_STOP, FALSE);
	    SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		MCI_STOP, TRUE);
	    if (p->fCanRecord)
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    MCI_RECORD, FALSE);	// !!! can't record ???
	    if (p->fCanEject)
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    IDM_MCIEJECT, TRUE);

	// Treat PAUSE mode like STOP mode
	} else if (dwMode == MCI_MODE_PAUSE ||
		   dwMode == MCI_MODE_STOP) {
	    // Hide STOP Show PLAY
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		MCI_STOP, TRUE);
	    if (p->fCanPlay) {
		SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		    MCI_PLAY, FALSE);
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    MCI_PLAY, TRUE);
	    }
	    if (p->fCanRecord)
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    MCI_RECORD, TRUE);
	    if (p->fCanEject)
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    IDM_MCIEJECT, TRUE);

	} else if (dwMode == MCI_MODE_RECORD) {
	    // Hide PLAY Show STOP
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		MCI_PLAY, TRUE);
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		MCI_STOP, FALSE);
	    SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		MCI_STOP, TRUE);
	    SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		MCI_RECORD, FALSE);
	    if (p->fCanEject)
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    IDM_MCIEJECT, TRUE);	// !!! safe ???

	    // recording can change the length
	    p->fMediaValid = FALSE;

	} else if (dwMode == MCI_MODE_SEEK) {
	    // Hide PLAY Show STOP
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		MCI_PLAY, TRUE);
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		MCI_STOP, FALSE);
	    SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		MCI_STOP, TRUE);
	    if (p->fCanRecord)
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    MCI_RECORD, FALSE);
	    if (p->fCanEject)
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    IDM_MCIEJECT, FALSE);
	} else {
	    // OPEN, NOT_READY, etc. etc.
	    // Disable everything
	    if (p->fCanPlay) {
		SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		    MCI_PLAY, FALSE);
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    MCI_PLAY, FALSE);
	    }
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON,
		MCI_STOP, TRUE);
	    if (p->fCanRecord)
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    MCI_RECORD, FALSE);
	    if (p->fCanEject)
		SendMessage(p->hwndToolbar, TB_ENABLEBUTTON,
		    IDM_MCIEJECT, FALSE);

	    // Clear all tics
	    SendMessage(p->hwndTrackbar, TBM_CLEARTICS,1,0);

	    // Clean out the trackbar
	    // Make a note to re-query start, length later
	    SendMessage(p->hwndTrackbar, TBM_SETPOS,
				TRUE, 0); // set b4 range
	    SendMessage(p->hwndTrackbar, TBM_SETRANGE,
				0, 0);
	    p->fMediaValid = FALSE;
	}
    }
}


//
// Set up the toolbar to have the right buttons
//
static void MCIWndiFixMyPlaybar(PMCIWND p)
{
    if (p->dwStyle & MCIWNDF_NOPLAYBAR)
	return;

    if (!p->wDeviceID) {
	//
        // gray the toolbar, go to some default buttons, and set zero len track
        //
        if (!(p->dwStyle & MCIWNDF_NOPLAYBAR)) {
            SendMessage(p->hwndToolbar, TB_HIDEBUTTON,   MCI_PLAY,    FALSE);
            SendMessage(p->hwndToolbar, TB_ENABLEBUTTON, MCI_PLAY,    FALSE);
            SendMessage(p->hwndToolbar, TB_HIDEBUTTON,   MCI_STOP,    TRUE );
            SendMessage(p->hwndToolbar, TB_HIDEBUTTON,   MCI_RECORD,  TRUE );
            SendMessage(p->hwndToolbar, TB_HIDEBUTTON,   IDM_MCIEJECT,TRUE );
            SendMessage(p->hwndToolbar, TB_HIDEBUTTON,   IDM_MENU,
		p->dwStyle & MCIWNDF_NOMENU);

            SendMessage(p->hwndTrackbar, TBM_SETPOS, TRUE, 0); // set b4 range
            SendMessage(p->hwndTrackbar, TBM_SETRANGE, 0, 0);
	}
    }

    if (p->wDeviceID) {
	//
	// Use the appropriate buttons
	//
        if (p->fCanPlay)
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON, MCI_PLAY, FALSE);
        else
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON, MCI_PLAY, TRUE);
        if (p->fCanRecord && (p->dwStyle & MCIWNDF_RECORD))
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON, MCI_RECORD, FALSE);
        else
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON, MCI_RECORD, TRUE);
        if (p->fCanEject)
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON, IDM_MCIEJECT, FALSE);
        else
	    SendMessage(p->hwndToolbar, TB_HIDEBUTTON, IDM_MCIEJECT, TRUE);

        SendMessage(p->hwndToolbar, TB_HIDEBUTTON, IDM_MENU,
		p->dwStyle & MCIWNDF_NOMENU);

	// COMMCTRL toolbar bug ... re-arranging buttons screws up the state
	// of the existing buttons, so we better re-gray things
	MCIWndiPlaybarGraying(p);
    }
}

// 
// Make an appropriate menu
//
static void MCIWndiMakeMeAMenu(PMCIWND p)
{
    HMENU hmenu, hmenuWindow = NULL, hmenuVolume = NULL, hmenuSpeed = NULL;
    int	  i;
    WORD  j;

    //
    // Create the floating popup menu BY HAND since we have no resource file
    //

    // Destroy the old menu
    if (p->hmenu) {
	DestroyMenu(p->hmenu);
        FreeDitherBrush();
    }
    p->hmenu = NULL;

    // We don't want a menu!
    if (p->dwStyle & MCIWNDF_NOMENU)
	return;

    //
    // If we don't want an open command, and nothing's open, don't make
    // a menu.
    //
    if (!p->wDeviceID && (p->dwStyle & MCIWNDF_NOOPEN))
	return;
    
    //
    // Create the WINDOW sub-popup
    // !!! Do we want to have this menu if an AUTOSIZE flag is off?
    //
    if (p->wDeviceID && p->fCanWindow) {
	hmenuWindow = CreatePopupMenu();
	if (hmenuWindow) {
            AppendMenu(hmenuWindow, MF_ENABLED, IDM_MCIZOOM+50,
			LoadSz(IDS_HALFSIZE));
	    AppendMenu(hmenuWindow, MF_ENABLED, IDM_MCIZOOM+100,
			LoadSz(IDS_NORMALSIZE));
	    AppendMenu(hmenuWindow, MF_ENABLED, IDM_MCIZOOM+200,
			LoadSz(IDS_DOUBLESIZE));
	}
    }

    //
    // Create the VOLUME sub-popup
    //
    if (p->wDeviceID && p->fVolume) {
	hmenuVolume = CreatePopupMenu();
        if (hmenuVolume) {

	    // !!! Hack from Hell
	    // Put a bogus menu item at the top.  When WINDOWS tries to select
	    // it after we bring up the menu, we won't let it.  We want the
	    // thumb to stay on the current value.
            AppendMenu(hmenuVolume, MF_ENABLED | MF_OWNERDRAW,
			IDM_MCIVOLUME + VOLUME_MAX + 1, NULL);

	    // Create all the Real menu items.  Make the menu VOLUME_MAX items
	    // tall even though the number of unique entries may be less
            for (i=IDM_MCIVOLUME + p->wMaxVol; i>=IDM_MCIVOLUME; i-=5)
		for (j=0; j < VOLUME_MAX / p->wMaxVol; j++)
                    AppendMenu(hmenuVolume, MF_ENABLED | MF_OWNERDRAW, i, NULL);

	    // Now put a filler item at the bottom so every REAL item falls
 	    // inside the channel and there's a unique thumb position for each
	    // item.
            AppendMenu(hmenuVolume, MF_ENABLED | MF_OWNERDRAW,
			IDM_MCIVOLUME + VOLUME_MAX + 2, NULL);

	    // Now CHECK the current volume so the thumb can draw there
	    // round to nearest 5 so it matches a menu item identifier
            i = ((int)MCIWndGetValue(p, FALSE, szStatusVolume, 1000) / 50) * 5;
            CheckMenuItem(hmenuVolume, IDM_MCIVOLUME + i, MF_CHECKED);
        }
    }

    //
    // Create the SPEED sub-popup
    //
    if (p->wDeviceID && p->fSpeed) {
	hmenuSpeed = CreatePopupMenu();
	if (hmenuSpeed) {

	    // !!! Hack from Hell
	    // Put a bogus menu item at the top.  When WINDOWS tries to select
	    // it after we bring up the menu, we won't let it.  We want the
	    // thumb to stay on the current value.
            AppendMenu(hmenuSpeed, MF_ENABLED | MF_OWNERDRAW,
			IDM_MCISPEED + SPEED_MAX + 1, NULL);

	    // Create all the Real menu items
            for (i=IDM_MCISPEED + SPEED_MAX; i>=IDM_MCISPEED; i-=5)
                AppendMenu(hmenuSpeed, MF_ENABLED | MF_OWNERDRAW, i, NULL);

	    // Now put a filler item at the bottom so every REAL item falls
 	    // inside the channel and there's a unique thumb position for each
	    // item.
            AppendMenu(hmenuSpeed, MF_ENABLED | MF_OWNERDRAW,
			IDM_MCISPEED + SPEED_MAX + 2, NULL);

	    // Now CHECK the current speed so the thumb can draw there
	    // round to nearest 5 so it matches a menu item identifier
            i = ((int)MCIWndGetValue(p, FALSE, szStatusSpeed, 1000) / 50) * 5;
            CheckMenuItem(hmenuSpeed, IDM_MCISPEED + i, MF_CHECKED);
        }
    }

    hmenu = CreatePopupMenu();

    if (hmenu) {

	if (p->wDeviceID && p->dwStyle & MCIWNDF_NOPLAYBAR) {
	    if (p->fCanPlay) {
	    	AppendMenu(hmenu, MF_ENABLED, MCI_PLAY, LoadSz(IDS_PLAY));
	    	AppendMenu(hmenu, MF_ENABLED, MCI_STOP, LoadSz(IDS_STOP));
	    }
	    if (p->fCanRecord && (p->dwStyle & MCIWNDF_RECORD))
	        AppendMenu(hmenu, MF_ENABLED, MCI_RECORD, LoadSz(IDS_RECORD));
	    if (p->fCanEject)
	    	AppendMenu(hmenu, MF_ENABLED, IDM_MCIEJECT, LoadSz(IDS_EJECT));
	    if (p->fCanPlay ||
			(p->fCanRecord && (p->dwStyle & MCIWNDF_RECORD)) ||
			p->fCanEject)
	        AppendMenu(hmenu, MF_SEPARATOR, NULL, NULL);
	
	}

	if (hmenuWindow)
            AppendMenu(hmenu, MF_ENABLED|MF_POPUP, (UINT)hmenuWindow,
		LoadSz(IDS_VIEW));
	if (hmenuVolume)
	    AppendMenu(hmenu, MF_ENABLED|MF_POPUP, (UINT)hmenuVolume,
		LoadSz(IDS_VOLUME));
	if (hmenuSpeed)
            AppendMenu(hmenu, MF_ENABLED|MF_POPUP, (UINT)hmenuSpeed,
		LoadSz(IDS_SPEED));

	if (hmenuWindow || hmenuVolume || hmenuSpeed)
            AppendMenu(hmenu, MF_SEPARATOR, NULL, NULL);

        if (p->wDeviceID && p->fCanRecord && (p->dwStyle & MCIWNDF_RECORD))
            AppendMenu(hmenu, MF_ENABLED, IDM_MCINEW, LoadSz(IDS_NEW));

	if (!(p->dwStyle & MCIWNDF_NOOPEN))
	    AppendMenu(hmenu, MF_ENABLED, IDM_MCIOPEN,  LoadSz(IDS_OPEN));

        if (p->wDeviceID && p->fCanSave && (p->dwStyle & MCIWNDF_RECORD))
            AppendMenu(hmenu, MF_ENABLED, MCI_SAVE, LoadSz(IDS_SAVE));

	if (p->wDeviceID) {
	    if (!(p->dwStyle & MCIWNDF_NOOPEN)) {
		AppendMenu(hmenu, MF_ENABLED, IDM_MCICLOSE, LoadSz(IDS_CLOSE));
	    
		AppendMenu(hmenu, MF_SEPARATOR, NULL, NULL);
	    }

	    AppendMenu(hmenu, MF_ENABLED, IDM_COPY, LoadSz(IDS_COPY));
	    
	    if (p->fCanConfig)
                AppendMenu(hmenu, MF_ENABLED, IDM_MCICONFIG,
			LoadSz(IDS_CONFIGURE));

	    // !!! Should we only show this in debug, or if a flag is set?
            AppendMenu(hmenu, MF_ENABLED, IDM_MCICOMMAND, LoadSz(IDS_COMMAND));
	}

	p->hmenu = hmenu;
	p->hmenuVolume = hmenuVolume;
	p->hmenuSpeed = hmenuSpeed;

 	CreateDitherBrush(FALSE);	// we'll need this to paint OwnerDraw
    }
}

//
// Set up everything for an empty window
//
static LONG MCIWndiClose(PMCIWND p, BOOL fRedraw)
{
    MCI_GENERIC_PARMS   mciGeneric;

    // Oh no!  The MCI device (probably MMP) has hooked our window proc and if
    // we close the device, it will go away, and the hook will DIE!  We need to
    // do everything BUT the closing of the device.  We'll delay that.
    if (GetWindowLong(p->hwnd, GWL_WNDPROC) != (LONG)MCIWndProc &&
    		p->wDeviceID && p->fCanWindow) {
        MCIWndString(p, FALSE, szWindowHandle, NULL);	// GO AWAY, DEVICE!
	PostMessage(p->hwnd, MCI_CLOSE, 0, p->wDeviceID);
    } else if (p->wDeviceID)
	// buggy drivers crash if we pass a null parms address
        mciSendCommand(p->wDeviceID, MCI_CLOSE, 0, (DWORD)(LPVOID)&mciGeneric);

    //
    // if the device had a palette, we need to send palette changes to
    // every window because we just deleted the palette that was realized.
    //
    if (p->fHasPalette) {
	// If we're dying this won't go through unless we SEND
	SendMessage(p->hwnd, MCIWNDM_PALETTEKICK, 0, 0);
    }

    // execute this function even if there's no deviceID since we may want
    // to gray things

    // The next timer will kill itself since wDeviceID is NULL
    p->wDeviceID = 0;
    p->achFileName[0] = 0;	// kill the filename
    p->dwMediaLen = 0;		// so next open will invalidate media

    // We don't want to redraw cuz we're opening a new file right away
    if (!fRedraw)
	return 0;

    // One of the show bits is on... clear the caption
    if (p->dwStyle & MCIWNDF_SHOWALL)
        SetWindowText(p->hwnd, LoadSz(IDS_NODEVICE));

    // Gray all the stuff on the playbar
    MCIWndiFixMyPlaybar(p);

    // Make an appropriate menu for our null device
    MCIWndiMakeMeAMenu(p);

    // Possibly snap ourselves to a small size since there's no device loaded
    // Also reposition the toolbar after it's been fixed up
    MCIWndiSize(p, 0);

    // We need to notify our "owner" that we've closed
    if (p->dwStyle & MCIWNDF_NOTIFYMEDIA)
        NotifyOwner(p, MCIWNDM_NOTIFYMEDIA, p->hwnd, (LPARAM)(LPVOID)szNULL);

    InvalidateRect(p->hwnd, NULL, TRUE);
    return 0;
}

//
// This is the WM_CREATE msg of our WndProc
//
static BOOL MCIWndiCreate(HWND hwnd, LONG lParam)
{
    PMCIWND             p;
    DWORD		dw;
    char                ach[20];
    HWND                hwndP;

    p = (PMCIWND)LocalAlloc(LPTR, sizeof(MCIWND));

    if (!p)
        return FALSE;

    SetWindowLong(hwnd, 0, (LONG)(UINT)p);

    p->hwnd = hwnd;
    p->hwndOwner = GetParent(hwnd);	// we'll send notifications here
    p->alias = (UINT)hwnd;
    p->dwStyle = GetWindowLong(hwnd, GWL_STYLE);

    DragAcceptFiles(p->hwnd, (p->dwStyle & (MCIWNDF_NOMENU | MCIWNDF_NOOPEN)) == 0);
    
    if (!(p->dwStyle & WS_CAPTION))
          p->dwStyle &= ~MCIWNDF_SHOWALL;

    dw = (DWORD)((LPCREATESTRUCT)lParam)->lpCreateParams;

    //
    // see if we are in a MDIClient
    //
    if ((p->dwStyle & WS_CHILD) && (hwndP = GetParent(hwnd))) {
        GetClassName(hwndP, ach, sizeof(ach));
        p->fMdiWindow = lstrcmpi(ach, szMDIClient) == 0;

        if (p->fMdiWindow)
            dw = ((LPMDICREATESTRUCT)dw)->lParam;
    }

    MCIWndiMakeMeAPlaybar(p);

//  if (szOpenFilter[0] == 0)
//      MCIWndiBuildMeAFilter(szOpenFilter);

    // Set the default timer frequencies
    p->iActiveTimerRate = ACTIVE_TIMER;
    p->iInactiveTimerRate = INACTIVE_TIMER;

    // initialize the OFN structure we'll use to open files
    p->achFileName[0] = '\0';
    p->ofn.lStructSize = sizeof(OPENFILENAME);
    p->ofn.hwndOwner = hwnd;
    p->ofn.hInstance = NULL;
//  p->ofn.lpstrFilter = szOpenFilter;
    p->ofn.lpstrCustomFilter = NULL;
    p->ofn.nMaxCustFilter = 0;
    p->ofn.nFilterIndex = 0;
;   p->ofn.lpstrFile = p->achFileName;
;   p->ofn.nMaxFile = sizeof(p->achFileName);
    p->ofn.lpstrFileTitle = NULL;
    p->ofn.nMaxFileTitle = 0;
    p->ofn.lpstrInitialDir = NULL;
    p->ofn.lpstrTitle = NULL; // "Open Device";
    p->ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    p->ofn.nFileOffset = 0;
    p->ofn.nFileExtension = 0;
    p->ofn.lpstrDefExt = NULL;
    p->ofn.lCustData = 0;
    p->ofn.lpfnHook = NULL;
    p->ofn.lpTemplateName = NULL;

    p->hicon = LoadIcon(hInst, MAKEINTRESOURCE(MPLAYERICON));
    
    // Gray stuff; disable things that aren't applicable with no device loaded
    MCIWndClose(hwnd);

    if (dw && *(LPSTR)dw)     // treat extra parm as a filename
        MCIWndOpen(hwnd, (LPSTR)dw, 0);

    return TRUE;
}

//
// Brings up an OpenDialog or a SaveDialog for the application and returns the
// filename.  Returns TRUE if a file name was chosen, FALSE on error or CANCEL.
//
static BOOL MCIWndOpenDlg(PMCIWND p, BOOL fSave, LPSTR szFile, int len)
{
    BOOL f;

    // !!! Maybe this is a device name and our GetOpenFileName will fail.
    // !!! Find someway of bringing up an initial filename anyway?
    szFile[0] = 0;

    p->ofn.lpstrFile = szFile;
    p->ofn.nMaxFile = len;
    if (fSave)
        p->ofn.Flags = OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
    else
        p->ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;

    //
    // use achReturn to hold the MCI Filter.
    //
    MCIWndiBuildMeAFilter(p->achReturn);
    p->ofn.lpstrFilter = p->achReturn;

    /* prompt user for file to open or save */
    if (fSave)
        f = GetSaveFileNamePreview(&(p->ofn));
    else
        f = GetOpenFileNamePreview(&(p->ofn));

    return f;
}

// Set our timer, if it's needed
static void MCIWndiSetTimer(PMCIWND p)
{
    // We need a TIMER to notify the "owner" when things change
    if (!(p->dwStyle & MCIWNDF_NOPLAYBAR) ||
         (p->dwStyle & MCIWNDF_NOTIFYMODE) ||
         (p->dwStyle & MCIWNDF_SHOWMODE) ||
         (p->dwStyle & MCIWNDF_SHOWPOS) ||
	 (p->dwStyle & MCIWNDF_NOTIFYPOS)) {
	p->wTimer = SetTimer(p->hwnd, TIMER1,
		p->fActive? p->iActiveTimerRate : p->iInactiveTimerRate,
		NULL);
    }
}

//
// Save a file.  Returns 0 for success
//
static LONG MCIWndiSave(PMCIWND p, WORD wFlags, LPSTR szFile)
{
    char                ach[128];

    //
    // If we don't have a filename to save, then get one from a dialog
    //
    if (szFile == (LPVOID)-1L) {
	lstrcpy(ach, p->achFileName);
        if (!MCIWndOpenDlg(p, TRUE, ach, sizeof(ach)))
            return -1;
        szFile = ach;
    }

    // !!! All good little boys should be saving to background... don't wait
    return MCIWndString(p, TRUE, szSave, szFile);
}

//
// Actually open a file and set up the window.  Returns 0 for success
//
static LONG MCIWndiOpen(PMCIWND p, WORD wFlags, LPSTR szFile)
{
    DWORD               dw = 0;
    HCURSOR             hcurPrev;
    char                ach[128];
    UINT                wDeviceID;
    BOOL 		fNew = wFlags & MCIWNDOPENF_NEW;

    //
    // We're opening an existing file, szFile is that filename
    // If we don't have a filename to open, then get one from a dialog
    //
    if (!fNew && szFile == (LPVOID)-1L) {
	lstrcpy(ach, p->achFileName);
        if (!MCIWndOpenDlg(p, FALSE, ach, sizeof(ach)))
            return -1;
        szFile = ach;
    }

    //
    // We want to open a new file, szFile is the device to open
    // If it's NULL, we use the current device
    //
    if (fNew && (szFile == NULL || *szFile == 0)) {
	// There is no device, so we can't do anything
	if (!p->wDeviceID)
	    return 42;	// !!! failure
	MCIWndGetDevice(p->hwnd, ach, sizeof(ach));
	szFile = ach;
    }

    // save the current device ID so we can put it back in case open fails.
    wDeviceID = p->wDeviceID;
    KillTimer(p->hwnd, TIMER1);	// setting the deviceID to 0 will mess up timer
    p->wDeviceID = 0;		// and if open fails, we don't want that
    p->alias++;			// use a new alias

    /*
     * Show the hourglass cursor -- who knows how long this stuff
     * will take
     */
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // Open a NEW file
    if (fNew) {
	dw = MCIWndGetValue(p, TRUE, szNew, 0,
		szFile, (UINT)p->alias);

    // open an existing file
    } else {

 	// first, try to open it shareable
        // don't show or update errors since we try to open it twice
        //
        // dont try shareable for "file" devices
        // hack to check for entension.
        //
        if (lstrlen(szFile) > 4 && szFile[lstrlen(szFile)-4] == '.')
            dw = 0;
        else
            dw = MCIWndGetValue(p, FALSE, szOpenShareable, 0,
                (LPSTR)szFile, (UINT)p->alias);

        // Error! Try again, not shareable.
        if (dw == 0) {
            dw = MCIWndGetValue(p, FALSE, szOpen, 0,
		(LPSTR)szFile, (UINT)p->alias);
	    // Last ditch attempt! Try AVI. It'll open anything.  This time,
	    // show, set errors.
	    if (dw == 0) {
                dw = MCIWndGetValue(p, TRUE, szOpenAVI, 0,
		    (LPSTR)szFile, (UINT)p->alias);
	    }
	}
    }

    if (hcurPrev)
	SetCursor(hcurPrev);

    //
    // Ack! No deviceID... we failed to open
    //
    if (dw == 0)
    {
        p->wDeviceID = wDeviceID;
        MCIWndiSetTimer(p);	// Put the timer back now that DeviceID is back
//	p->achFileName[0] = 0;	// don't hurt the old filename!
	p->alias--;		// back to old alias
	// in case error box or open box wiped us out and we didn't paint
	// because our p->wDeviceID was null because of our open hack
	InvalidateRect(p->hwnd, NULL, TRUE);
        return p->dwError;
    }

    //
    // it worked, now close the old device and open the new.
    //
    if (wDeviceID)
    {
	p->wDeviceID = wDeviceID;
	p->alias--;	// back to old alias so the close might actually work
	MCIWndiClose(p, FALSE);	// don't redraw
	p->alias++;	// new alias again (ACK!)
    }

    p->wDeviceID = (UINT)dw;
    p->dwMode = (DWORD)~0L;	// first mode set will be detected as a change
    p->dwPos = (DWORD)~0L;	// first pos set will be detected as a change
    
    // Copy the file or device name into our filename spot
    lstrcpy(p->achFileName, szFile);

    // !!! p->wDeviceType = QueryDeviceTypeMCI(p->wDeviceID);

    // Now set the playback window to be our MCI window
    p->fCanWindow = MCIWndString(p, FALSE, szWindowHandle, (UINT)p->hwnd) == 0;

    if (p->fCanWindow)
        MCIWndGetDest(p->hwnd, &p->rcNormal);
    else
	SetRect(&p->rcNormal, 0, 0, 0, 0);

    // Find out if the device supports palettes.
    p->fHasPalette = MCIWndString(p, FALSE, szStatusPalette) == 0;

    //
    // Now find out the capabilities of this device
    //

// !!! What about these ???
// MCI_GETDEVCAPS_DEVICE_TYPE      0x00000004L
// MCI_GETDEVCAPS_COMPOUND_DEVICE  0x00000006L

    // Find out if the device can record
    p->fCanRecord = MCIWndDevCaps(p, MCI_GETDEVCAPS_CAN_RECORD);

    // Find out if the device can play
    p->fCanPlay = MCIWndDevCaps(p, MCI_GETDEVCAPS_CAN_PLAY);

    // Find out if the device can save
    p->fCanSave = MCIWndDevCaps(p, MCI_GETDEVCAPS_CAN_SAVE);

    // Find out if the device can eject
    p->fCanEject = MCIWndDevCaps(p, MCI_GETDEVCAPS_CAN_EJECT);

    // Find out if the device is file based
    p->fUsesFiles = MCIWndDevCaps(p, MCI_GETDEVCAPS_USES_FILES);

    // Find out if the device has video
    p->fVideo = MCIWndDevCaps(p, MCI_GETDEVCAPS_HAS_VIDEO);

    // Find out if the device has video
    p->fAudio = MCIWndDevCaps(p, MCI_GETDEVCAPS_HAS_AUDIO);

    // Find out if the device can configure
    p->fCanConfig = (MCIWndString(p, FALSE, szConfigureTest) == 0);
#ifdef DEBUG
    // !!! MCIAVI says no the driver...
    p->fCanConfig = p->fCanWindow;
#endif

    //
    //
    //

    // Now see if we support speed - try normal, half, and max
    p->fSpeed = MCIWndString(p, FALSE, szSetSpeed1000Test) == 0 &&
                MCIWndString(p, FALSE, szSetSpeed500Test) == 0 &&
                MCIWndString(p, FALSE, szSetSpeedTest, SPEED_MAX * 10) == 0;

    // Now see if we support volume - try normal, mute, and max
    p->fVolume = MCIWndString(p, FALSE, szSetVolumeTest, VOLUME_MAX * 5) ==0 &&
                 MCIWndString(p, FALSE, szSetVolume0Test) == 0;
    p->wMaxVol = 100;
    // If someone happens to support double volume, let's give it to them.
    if (MCIWndString(p, FALSE, szSetVolumeTest, VOLUME_MAX * 10) == 0)
	p->wMaxVol = 200;

    // See if the device would support tmsf mode.  If so, use milliseconds mode
    // and later on we'll fake knowing where tracks begin and end
    p->fHasTracks = (MCIWndString(p, FALSE, szSetFormatTMSF) == 0);
    if (p->fHasTracks) {
        dw = MCIWndString(p, FALSE, szSetFormatMS);
 	if (dw != 0)
	    p->fHasTracks = FALSE;
    }

    if (!p->fHasTracks) {
        // Force us into a reasonable time format
        dw = MCIWndString(p, FALSE, szSetFormatFrames);
        if (dw != 0)
	    dw = MCIWndString(p, FALSE, szSetFormatMS);
        if (dw != 0)
	    ;		// !!! What to do? Don't turn playbar off without
    }	 		// !!! destroying it...

    // Set the media length and trackbar range
    MCIWndiValidateMedia(p);

    // set window text
    if (p->dwStyle & MCIWNDF_SHOWNAME)
        SetWindowText(p->hwnd, FileName(szFile));

    // Fix the toolbar buttons for the new device
    MCIWndiFixMyPlaybar(p);

    // Make an appropriate menu for this device
    MCIWndiMakeMeAMenu(p);

    // We need a TIMER to notify the "owner" when things change
    MCIWndiSetTimer(p);

    // Set the size of the movie (and maybe the window) and re-draw new toolbar
    MCIWndiSize(p, p->iZoom);

#if 0 // We need the focus on our main window to get key accelerators
    // Bring focus to the thumb so caret will flash
    // I know the WM_SETFOCUS msg does this, but it seems to need to happen here
    // too.
    if (p->hwndTrackbar && GetFocus() == p->hwnd)
	SetFocus(p->hwndTrackbar);
#endif

    // We need to notify our "owner" that we've opened a new file
    if (p->dwStyle & MCIWNDF_NOTIFYMEDIA)
        NotifyOwner(p, MCIWNDM_NOTIFYMEDIA, p->hwnd, (LPARAM)szFile);

    // Make sure the newly opened movie paints in the window now
    InvalidateRect(p->hwnd, NULL, TRUE);

    return 0;	// success
}

//
// Set the caption based on what they want to see... Name? Pos? Mode?
//
static VOID MCIWndiSetCaption(PMCIWND p)
{
    char	ach[200], achMode[40], achT[40], achPos[40];

    // Don't touch their window text if they don't want us to
    if (!(p->dwStyle & MCIWNDF_SHOWALL))
	return;

    ach[0] = 0;

    if (p->wDeviceID == NULL)
	return;

    if (p->dwStyle & MCIWNDF_SHOWNAME)
	wsprintf(ach, "%s", FileName(p->achFileName));

    if (p->dwStyle & (MCIWNDF_SHOWPOS | MCIWNDF_SHOWMODE))
	lstrcat(ach, " (");

    if (p->dwStyle & MCIWNDF_SHOWPOS) {

	// Get the pretty version of the position as a string
	MCIWndGetPositionString(p->hwnd, achPos, sizeof(achPos));

        if (p->dwStyle & MCIWNDF_SHOWMODE)
	    wsprintf(achT, "%s - ", (LPSTR)achPos);
	else
	    wsprintf(achT, "%s", (LPSTR)achPos);
	lstrcat(ach, achT);
    }

    if (p->dwStyle & MCIWNDF_SHOWMODE) {
	MCIWndGet(p, szStatusMode, achMode, sizeof(achMode));
	lstrcat(ach, achMode);
    }

    if (p->dwStyle & (MCIWNDF_SHOWPOS | MCIWNDF_SHOWMODE))
	lstrcat(ach, ")");

    SetWindowText(p->hwnd, ach);
}

// We never use this any more
#if 0
static BOOL MCIWndSeekExact(PMCIWND p, BOOL fExact)
{
    DWORD dw;
    BOOL  fWasExact;

    if (p->wDeviceID == NULL)
        return FALSE;

    // see if the device even has this feature
    dw = MCIWndString(p, FALSE, szStatusSeekExactly);
    if (dw != 0)
        return FALSE;

    // get current value.
    dw = MCIWndStatus(p, MCI_DGV_STATUS_SEEK_EXACTLY, MCI_OFF);
    fWasExact = (dw != MCI_OFF) ? TRUE : FALSE;

    if (fExact)
	dw = MCIWndString(p, FALSE, szSetSeekExactOn);
    else
	dw = MCIWndString(p, FALSE, szSetSeekExactOff);

    return fWasExact;
}
#endif

static LONG MCIWndiChangeStyles(PMCIWND p, UINT mask, UINT value)
{
    DWORD	dwOldStyle = p->dwStyle;
    DWORD	dwMaskOff, dwValue, dwChanged;

    //
    // Using the mask, change the appropriate bits in the style
    //
    dwMaskOff = dwOldStyle & (~(DWORD)mask);
    dwValue   = (DWORD)mask & (DWORD)value;
    p->dwStyle = dwMaskOff | dwValue;

    //
    // Which bits changed?
    //
    dwChanged = (dwOldStyle & (DWORD)mask) ^ (dwValue & (DWORD)mask);

    //
    // We changed whether or not we want a menu button or a record button
    // on the playbar
    //
    if (dwChanged & (MCIWNDF_NOMENU | MCIWNDF_NOOPEN | MCIWNDF_RECORD)) {
	MCIWndiMakeMeAMenu(p);	// add/remove record from the menu
	// We have a playbar, so fix it
	if (!(p->dwStyle & MCIWNDF_NOPLAYBAR)) {
	    MCIWndiFixMyPlaybar(p);
	    MCIWndiSize(p, 0);
	}
    }

    //
    // We changed the show/don't show playbar flag!
    //
    if (dwChanged & MCIWNDF_NOPLAYBAR) {

 	// Remove the playbar
	if (p->dwStyle & MCIWNDF_NOPLAYBAR) {
	    DestroyWindow(p->hwndToolbar);
	    p->hwndToolbar = NULL;
	    p->hwndTrackbar = NULL;	// child destroyed automatically
	    MCIWndiMakeMeAMenu(p);	// since toolbar's gone, menus change

	    if (!(p->dwStyle & MCIWNDF_NOAUTOSIZEWINDOW)) {
	        // Now resize the window smaller to account for the missing
		// playbar.  Don't touch the movie size.
		MCIWndiSize(p, 0);

	    // If the window isn't being resized, we may still need to grow
	    // the movie size a bit to take up the extra space where the toolbar
	    // vanished. (happens automatically in the previous case)
	    } else if (!(p->dwStyle & MCIWNDF_NOAUTOSIZEMOVIE)) {
		PostMessage(p->hwnd, WM_SIZE, 0, 0L);
	    }	

	// Add a playbar
	} else {
	    MCIWndiMakeMeAPlaybar(p);
	    MCIWndiFixMyPlaybar(p);
	    MCIWndiMakeMeAMenu(p);	// since toolbar's used, menus change

	    if (!(p->dwStyle & MCIWNDF_NOAUTOSIZEWINDOW)) {
	        // Now resize the window a little bigger to account for the new
		// playbar.  Don't touch the movie size.
		MCIWndiSize(p, 0);

	    // If the window isn't being resized, we may still need to shrink
	    // the movie size because the toolbar covers up some extra space.
	    // (happens automatically in the previous case)
	    } else if (!(p->dwStyle & MCIWNDF_NOAUTOSIZEMOVIE)) {
		PostMessage(p->hwnd, WM_SIZE, 0, 0L);

	    // Irregardless, we need to fix the toolbar
	    } else
		// Put the toolbar in a reasonable spot
		MCIWndiSizePlaybar(p);
	}
    }

    //
    // We changed a SHOW flag and need to reset the caption
    //
    if (dwChanged & MCIWNDF_SHOWALL)
	MCIWndiSetCaption(p);

    //
    // We turned the AUTOSIZEMOVIE flag on and need to resize the device.
    // This happens before AUTOSIZEWINDOW so if both flags are turned on
    // the movie will snap to the window not vice versa.
    // !!! Should we even snap it right now?
    //
    if (dwChanged & MCIWNDF_NOAUTOSIZEMOVIE &&
				!(p->dwStyle & MCIWNDF_NOAUTOSIZEMOVIE))
	PostMessage(p->hwnd, WM_SIZE, 0, 0);

    //
    // We turned the AUTOSIZEWINDOW flag on
    // Snap our window to the current movie size.
    //
    if (dwChanged & MCIWNDF_NOAUTOSIZEWINDOW &&
				!(p->dwStyle & MCIWNDF_NOAUTOSIZEWINDOW))
	MCIWndiSize(p, 0);
    
    DragAcceptFiles(p->hwnd, (p->dwStyle & MCIWNDF_NOMENU | MCIWNDF_NOOPEN) == 0);

    return 0;	// !!! success ?
}


//
// We're about to play.  We might want to seek to the beginning first if we're
// at the end, or seek to the end first if we're at the beginning and playing
// backwards.
//
static void MCIWndiPlaySeek(PMCIWND p, BOOL fBackwards)
{

    // Playing backwards? If we're at the beginning, seek to the end

    if (fBackwards) {
	if (MCIWndGetPosition(p->hwnd) <= MCIWndGetStart(p->hwnd))
	    MCIWndSeek(p->hwnd, MCIWND_END);
	return;
    }

    // Playing forwards.
    // If we're near the end, rewind before playing
    // Some devices are broken so we can't just test being at the end

    // Frames mode ... last or second to last frame
    if (MCIWndGetTimeFormat(p->hwnd, NULL, 0) == MCI_FORMAT_FRAMES) {
	if (MCIWndGetPosition(p->hwnd) >= MCIWndGetEnd(p->hwnd) - 1)
	    MCIWndSeek(p->hwnd, MCIWND_START);

    // Millisecond mode ... within last 1/4 second
    } else if (MCIWndGetTimeFormat(p->hwnd, NULL, 0) ==
					MCI_FORMAT_MILLISECONDS) {
	if (MCIWndGetEnd(p->hwnd) - MCIWndGetPosition(p->hwnd) < 250)
	    MCIWndSeek(p->hwnd, MCIWND_START);

    // something else ... no hack
    } else {
	if (MCIWndGetPosition(p->hwnd) == MCIWndGetEnd(p->hwnd))
	    MCIWndSeek(p->hwnd, MCIWND_START);
    }
}


//
// Handle our WM_TIMER
//
static void MCIWndiTimerStuff(PMCIWND p)
{
    DWORD	dwMode;
    DWORD	dwPos;

    //
    // Someone's interested in knowing the mode of the device
    //
    if ((p->dwStyle & MCIWNDF_NOTIFYMODE) ||
		!(p->dwStyle & MCIWNDF_NOPLAYBAR) ||
		(p->dwStyle & MCIWNDF_SHOWMODE)) {

	dwMode = MCIWndGetMode(p->hwnd, NULL, 0);

	//
	// If we haven't set the trackbar range or media length yet
	// because we weren't ready, maybe we can do it now!
	// Also, don't update media until you're done recording.
	//
	if (dwMode != MCI_MODE_NOT_READY && dwMode != MCI_MODE_OPEN &&
		dwMode != MCI_MODE_RECORD && p->fMediaValid == FALSE)
	    MCIWndiValidateMedia(p);

	//
	// No device loaded?  Time to kill our timer
	//
	if (p->wDeviceID == NULL)
	    KillTimer(p->hwnd, TIMER1);

	//
	// The mode has changed!
	//
	if (dwMode != p->dwMode) {

	    p->dwMode = dwMode;

	    //
	    // Notify the "owner" of the mode change
	    //
	    if ((p->dwStyle & MCIWNDF_NOTIFYMODE))
		NotifyOwner(p, MCIWNDM_NOTIFYMODE, p->hwnd, dwMode);

	    //
	    // Set the Window Caption to include the new mode
	    //
	    if ((p->dwStyle & MCIWNDF_SHOWMODE))
		MCIWndiSetCaption(p);

	    //
	    // Fix up the toolbar bitmaps if the mode has changed
	    //
	    MCIWndiPlaybarGraying(p);
	}
    }

    //
    // Someone's interested in knowing the new position
    //
    if (!(p->dwStyle & MCIWNDF_NOPLAYBAR) ||
	 (p->dwStyle & MCIWNDF_NOTIFYPOS) ||
	 (p->dwStyle & MCIWNDF_SHOWPOS)) {

	dwPos = MCIWndGetPosition(p->hwnd);

	//
	// The position has changed!
	//
	if (dwPos != p->dwPos) {

	    //
	    // Make sure start and length haven't changed too (format change) ?
	    //
	    MCIWndiValidateMedia(p);

	    p->dwPos = dwPos;

	    //
	    // Notify the "owner" of the position change
	    //
	    if ((p->dwStyle & MCIWNDF_NOTIFYPOS))
		NotifyOwner(p, MCIWNDM_NOTIFYPOS, p->hwnd, dwPos);

	    //
	    // Set the Window Caption to include the new position
	    //
	    if ((p->dwStyle & MCIWNDF_SHOWPOS))
		MCIWndiSetCaption(p);

	    //
	    // Update the trackbar to the new position but not while
	    // we're dragging the thumb
	    //
	    if (!(p->dwStyle & MCIWNDF_NOPLAYBAR) && !p->fScrolling)
		SendMessage(p->hwndTrackbar, TBM_SETPOS, TRUE, dwPos);
	}
    }
}


static void MCIWndiDrop(HWND hwnd, WPARAM wParam)
{
    char	szPath[256];
    UINT	nDropped;

    // Get number of files dropped
    nDropped = DragQueryFile((HANDLE)wParam,0xFFFF,NULL,0);
    
    if (nDropped) { 
	SetActiveWindow(hwnd);

	// Get the file that was dropped....
	DragQueryFile((HANDLE)wParam, 0, szPath, sizeof(szPath));

	MCIWndOpen(hwnd, szPath, 0);
    }
    DragFinish((HANDLE)wParam);     /* Delete structure alocated */
}

/*--------------------------------------------------------------+
| MCIWndProc - MCI window's window proc                         |
|                                                               |
+--------------------------------------------------------------*/
LONG FAR PASCAL _loadds MCIWndProc(HWND hwnd, unsigned msg, WORD wParam, LONG lParam)
{
    PMCIWND             p;
    DWORD	    	dw;
    HDC		    	hdc;
    PAINTSTRUCT	    	ps;
    DWORD               dwPos;
    POINT		pt;
    MINMAXINFO FAR 	*lpmmi;
    RECT		rc;
    BOOL                f;
    char		ach[80];
    MCI_GENERIC_PARMS   mciGeneric;
    LPRECT              prc;
    int			i;
    HWND		hwndD;

    p = (PMCIWND)(UINT)GetWindowLong(hwnd, 0);

    switch(msg){
        case WM_CREATE:
            if (!MCIWndiCreate(hwnd, lParam))
                return -1;

            break;

        // Make the trackbar background LTGRAY like the toolbar
        case WM_CTLCOLOR:
            if ((HWND)LOWORD(lParam) == p->hwndTrackbar)
		return (LRESULT)(UINT)GetStockObject(LTGRAY_BRUSH);
            break;

	case MCI_SAVE:
	    // wParam presently unused and not given by the macro
	    return MCIWndiSave(p, wParam, (LPSTR)lParam);

	case MCI_OPEN:
	    return MCIWndiOpen(p, wParam, (LPSTR)lParam);
	    
	case MCIWNDM_NEW:
	    return MCIWndiOpen(p, MCIWNDOPENF_NEW, (LPSTR)lParam);
	
        case MCI_PLAY:

	    if (!p->wDeviceID)
		return 0;
	    // Seek to the beginning if we're near the end
	    MCIWndiPlaySeek(p, FALSE);

	case MCI_STOP:
	case MCI_PAUSE:
	case MCI_RESUME:
	case MCI_RECORD:

	    dw = 0;
	    // Report/Show errors for this
	    if (p->wDeviceID) {
		// buggy drivers crash if we pass a null parms address
	        dw = mciSendCommand(p->wDeviceID, msg, 0,
			(DWORD)(LPVOID)&mciGeneric);
		MCIWndiHandleError(p, dw);
		// kick ourselves to show new Mode
		MCIWndiTimerStuff(p);
	    }
	    return dw;

	case MCIWNDM_PLAYREVERSE:

	    if (!p->wDeviceID)
		return 0;
	    // Seek to the end if we're near the beginning
	    MCIWndiPlaySeek(p, TRUE);
	    dw = MCIWndString(p, TRUE, szPlayReverse, (LPSTR)szNULL);
	    // kick ourselves to show new Mode
	    MCIWndiTimerStuff(p);
	    return dw;

        case MCI_CLOSE:
	    if (lParam)
		// We delayed the closing of the MCI device because the MCI
		// device may have hooked our window proc and be on our stack
		// and killing it before would have destroyed the universe.
		// buggy drivers crash if we pass a null parms address
        	return mciSendCommand((UINT)lParam, MCI_CLOSE, 0,
			(DWORD)(LPVOID)&mciGeneric);
		
	    else
	        // Do all the stuff for closing
	        return MCIWndiClose(p, TRUE);

	case MCIWNDM_EJECT:
	    return MCIWndString(p, TRUE, szSetDoorOpen);

	case MCIWNDM_PLAYFROM:
	    if (lParam == MCIWND_START)
	        dw = MCIWndString(p, TRUE, szPlayFrom, MCIWndGetStart(hwnd));
	    else
	        dw = MCIWndString(p, TRUE, szPlayFrom, (LONG)lParam);
	    MCIWndiTimerStuff(p);	// kick ourselves to see mode change
	    return dw;

	case MCIWNDM_PLAYTO:
	    if (lParam == MCIWND_END)
	        dw = MCIWndString(p, TRUE, szPlayTo, MCIWndGetEnd(hwnd));
	    else if (lParam == MCIWND_START)
	        dw = MCIWndString(p, TRUE, szPlayTo, MCIWndGetStart(hwnd));
	    else
	        dw = MCIWndString(p, TRUE, szPlayTo, (LONG)lParam);
	    MCIWndiTimerStuff(p);	// kick ourselves to see mode change
	    return dw;

	case MCI_STEP:
            return MCIWndString(p, TRUE, szStep, (LONG)lParam);

	case MCI_SEEK:
	    if (lParam == MCIWND_START)
                return MCIWndString(p, TRUE, szSeek, MCIWndGetStart(hwnd));
	    else if (lParam == MCIWND_END)
                return MCIWndString(p, TRUE, szSeek, MCIWndGetEnd(hwnd));
	    else
                return MCIWndString(p, TRUE, szSeek, (LONG)lParam);

	case MCIWNDM_SETREPEAT:
	    p->fRepeat = (BOOL)lParam;
	    return 0;

	case MCIWNDM_GETREPEAT:
	    return p->fRepeat;

	case MCIWNDM_GETDEVICEID:
	    return p->wDeviceID;

	case MCIWNDM_GETALIAS:
	    return p->alias;

	case MCIWNDM_GETMODE:
            if (lParam)
		MCIWndGet(p, szStatusMode, (LPSTR)lParam, (UINT)wParam);
	    return MCIWndStatus(p, MCI_STATUS_MODE, MCI_MODE_NOT_READY);

	// Return the position as a string if they give us a buffer
	case MCIWNDM_GETPOSITION:
            if (lParam) {
		// If we can do tracks, let's give them a pretty string
		if (p->fHasTracks)
        	    MCIWndString(p, FALSE, szSetFormatTMSF);
		MCIWndGet(p, szStatusPosition, (LPSTR)lParam,(UINT)wParam);
		if (p->fHasTracks)
        	    MCIWndString(p, FALSE, szSetFormatMS);
	    }
	    return MCIWndStatus(p, MCI_STATUS_POSITION, 0);
	     
	case MCIWNDM_GETSTART:
	    // Start is a command that works differently
            return MCIWndGetValue(p, FALSE, szStatusStart, 0);

	case MCIWNDM_GETLENGTH:
	    return MCIWndStatus(p, MCI_STATUS_LENGTH, 0);

	case MCIWNDM_GETEND:
	    return MCIWndGetStart(hwnd) + MCIWndGetLength(hwnd);

        case MCIWNDM_SETZOOM:
            p->iZoom = (int)lParam;
	    MCIWndiSize(p, (int)lParam);
            return 0;

        case MCIWNDM_GETZOOM:
            return p->iZoom ? p->iZoom : 100;

        case MCIWNDM_GETPALETTE:
            return MCIWndGetValue(p, FALSE, szStatusPalette, NULL);

        case MCIWNDM_SETPALETTE:
            return MCIWndString(p, TRUE, szSetPalette, (HPALETTE)wParam);

	//
	// Returns our error code
	//
	case MCIWNDM_GETERROR:
	    if (lParam) {
		mciGetErrorString(p->dwError, (LPSTR)lParam, (UINT)wParam);
	    }
	    dw = p->dwError;
	//    p->dwError = 0L;	// we never clear the error
	    return dw;

	case MCIWNDM_GETFILENAME:
	    if (lParam)
	        lstrcpyn((LPSTR)lParam, p->achFileName, (UINT)wParam);
	    return (lParam == NULL);	// !!!

	case MCIWNDM_GETDEVICE:
	    if (lParam)
	        return MCIWndGet(p, szSysInfo, (LPSTR)lParam,
		    (UINT)wParam);
	    return 42;	// !!!

	case MCIWNDM_SETVOLUME:
	    // Uncheck the current volume, and check the new one.
	    // Round to nearest 5 so it matches a menu item identifier
            i = ((int)MCIWndGetValue(p, FALSE, szStatusVolume, 1000) / 50) * 5;
	    if (p->hmenuVolume)
                CheckMenuItem(p->hmenuVolume, IDM_MCIVOLUME + i, MF_UNCHECKED);
            dw = MCIWndString(p, TRUE, szSetVolume, (int)lParam);
            i = ((int)lParam / 50) * 5;
	    if (p->hmenuVolume)
                CheckMenuItem(p->hmenuVolume, IDM_MCIVOLUME + i, MF_CHECKED);
	    return dw;

	case MCIWNDM_GETVOLUME:
	    return MCIWndGetValue(p, FALSE, szStatusVolume, 1000);

	case MCIWNDM_SETSPEED:
	    // Uncheck the current speed, and check the new one.
	    // Round to nearest 5 so it matches a menu item identifier
            i = ((int)MCIWndGetValue(p, FALSE, szStatusSpeed, 1000) / 50) * 5;
	    if (p->hmenuSpeed)
                CheckMenuItem(p->hmenuSpeed, IDM_MCISPEED + i, MF_UNCHECKED);
            dw = MCIWndString(p, TRUE, szSetSpeed, (int)lParam);
            i = ((int)lParam / 50) * 5;
	    if (p->hmenuSpeed)
                CheckMenuItem(p->hmenuSpeed, IDM_MCISPEED + i, MF_CHECKED);
	    return dw;

	case MCIWNDM_GETSPEED:
            return MCIWndGetValue(p, FALSE, szStatusSpeed, 1000);

	case MCIWNDM_SETTIMEFORMAT:
	    dw = MCIWndString(p, TRUE, szSetFormat, (LPSTR)lParam);
	    MCIWndiValidateMedia(p);
	    return dw;

	case MCIWNDM_GETTIMEFORMAT:
	    if (lParam)
		MCIWndGet(p, szStatusFormat, (LPSTR)lParam, (UINT)wParam);
	    return MCIWndStatus(p, MCI_STATUS_TIME_FORMAT, 0);	// !!!

	case MCIWNDM_VALIDATEMEDIA:
	    MCIWndiValidateMedia(p);
	    break;

 	case MCIWNDM_GETSTYLES:
	    return (UINT)(p->dwStyle & 0xFFFF);

 	case MCIWNDM_CHANGESTYLES:
	    return MCIWndiChangeStyles(p, (UINT)wParam, (UINT)lParam);

        case MCIWNDM_SETACTIVETIMER:
	    if (wParam)
	        p->iActiveTimerRate = (unsigned)wParam;
	
	    if (p->fActive) {
                KillTimer(hwnd, TIMER1);
                MCIWndiSetTimer(p);
	    }
	    break;

        case MCIWNDM_SETINACTIVETIMER:
	    if (wParam)
	        p->iInactiveTimerRate = (unsigned)wParam;
	
	    if (!p->fActive) {
                KillTimer(hwnd, TIMER1);
                MCIWndiSetTimer(p);
	    }
	    break;

        case MCIWNDM_SETTIMERS:
	    if (wParam)
	        p->iActiveTimerRate = (unsigned)wParam;
	    if (lParam)
                p->iInactiveTimerRate = (unsigned)lParam;

            KillTimer(hwnd, TIMER1);
            MCIWndiSetTimer(p);

	    break;

	case MCIWNDM_GETACTIVETIMER:
	    return p->iActiveTimerRate;

	case MCIWNDM_GETINACTIVETIMER:
	    return p->iInactiveTimerRate;

        case MCIWNDM_SENDSTRING:
	    //
	    // App wants to send a string command.

	    // special case the CLOSE command to do our clean up
	    if (lstrcmpi((LPSTR)lParam, szClose) == 0)
		return MCIWndClose(hwnd);

	    // Always sets/clears our error code
            dw = MCIWndGet(p, (LPSTR)lParam, p->achReturn,sizeof(p->achReturn));
	    MCIWndiHandleError(p, dw);
	    // kick ourselves in case mode changed from this command
	    MCIWndiTimerStuff(p);
            return dw;

	// Gets the return string from the most recent MCIWndSendString()
        case MCIWNDM_RETURNSTRING:
	    if (lParam)
	        lstrcpyn((LPSTR)lParam, p->achReturn, wParam);
	    return (lParam == NULL);	// !!!

        case MCIWNDM_REALIZE:
	    // buggy drivers crash if we pass a null parms address
            dw = mciSendCommand(p->wDeviceID, MCI_REALIZE,
                (BOOL)wParam ? MCI_ANIM_REALIZE_BKGD : MCI_ANIM_REALIZE_NORM,
		(DWORD)(LPVOID)&mciGeneric);
            break;

        case MCIWNDM_GET_SOURCE:
	    MCIWndRect(p, (LPRECT)lParam, TRUE);
	    return 0L;

	case MCIWNDM_GET_DEST:
	    MCIWndRect(p, (LPRECT)lParam, FALSE);
	    return 0L;

        case MCIWNDM_PUT_SOURCE:
            prc = (LPRECT)lParam;

            return MCIWndString(p, FALSE, szPutSource,
		  prc->left, prc->top,
		  prc->right - prc->left,
                  prc->bottom - prc->top);

	case MCIWNDM_PUT_DEST:
	    prc = (LPRECT)lParam;

	    return MCIWndString(p, FALSE, szPutDest,
		  prc->left, prc->top,
		  prc->right - prc->left,
                  prc->bottom - prc->top);

        case MCIWNDM_CAN_PLAY:   return p->fCanPlay;
        case MCIWNDM_CAN_WINDOW: return p->fCanWindow;
        case MCIWNDM_CAN_RECORD: return p->fCanRecord;
        case MCIWNDM_CAN_SAVE:   return p->fCanSave;
        case MCIWNDM_CAN_EJECT:  return p->fCanEject;
        case MCIWNDM_CAN_CONFIG: return p->fCanConfig;

	case WM_TIMER:

	    // This timer means we've moved the mouse off of the menu and need
	    // to snap the thumb back to the original value
	    if (wParam == TIMER2) {
		KillTimer(hwnd, TIMER2);

		// If only this would cause OwnerDraw to execute, we could see
		// the thumb bounce back to it's default place.  Alas, no can do
		//CheckMenuItem(p->hmenuHack, p->uiHack, MF_UNCHECKED);
		//CheckMenuItem(p->hmenuHack, p->uiHack, MF_CHECKED);

		// This code will at least set the parameter back even though
		// the thumb won't physically move.
		if (p->hmenuHack == p->hmenuVolume)
		    MCIWndSetVolume(hwnd, (p->uiHack - IDM_MCIVOLUME) * 10);
		else
		    MCIWndSetSpeed(hwnd, (p->uiHack - IDM_MCISPEED) * 10);
	    }

	    //
	    // This is not our timer. Bail.
	    //
	    if (wParam != TIMER1)
		break;

	    MCIWndiTimerStuff(p);

	    break;

	case WM_GETMINMAXINFO:

	    // We don't want anybody messing with the window size
	    if (p->dwStyle & MCIWNDF_NOAUTOSIZEWINDOW)
		break;

	    // do we have a playbar?
	    f = !(p->dwStyle & MCIWNDF_NOPLAYBAR);

            lpmmi = (MINMAXINFO FAR *)(lParam);
            SetRect(&rc, 0, 0, SMALLEST_WIDTH, f ? TB_HEIGHT : 0);
            AdjustWindowRect(&rc, GetWindowLong(hwnd, GWL_STYLE), FALSE);
            lpmmi->ptMinTrackSize.y = rc.bottom - rc.top;
            lpmmi->ptMinTrackSize.x = rc.right - rc.left;

            if (!(p->wDeviceID) || !(p->fCanWindow))
                    lpmmi->ptMaxTrackSize.y = lpmmi->ptMinTrackSize.y;
            break;

        case WM_SIZE:

	    GetClientRect(hwnd, &rc);

	    if (!IsIconic(hwnd)) {
		// if we have a playbar, fix it up to the new size
                f = !(p->dwStyle & MCIWNDF_NOPLAYBAR);

                if (f) {
                    MCIWndiSizePlaybar(p);
                    rc.bottom -= TB_HEIGHT;
                }

                if (!(p->dwStyle & MCIWNDF_NOAUTOSIZEMOVIE))
                    MCIWndString(p, FALSE, szPutDest, 0,0, rc.right, rc.bottom);

	    } else {
                if (!(p->dwStyle & MCIWNDF_NOAUTOSIZEMOVIE))
                    MCIWndString(p, FALSE, szPutDest, 0,0, rc.right, rc.bottom);
	    }
	    break;

        case WM_RBUTTONDOWN:
        case WM_NCRBUTTONDOWN:
        case WM_PARENTNOTIFY:

	    // If we haven't got a menu, or we don't want it, bail
            if (!p->hmenu || p->dwStyle & MCIWNDF_NOMENU)
                break;

	    // If this is not a right button down, bail
            if (msg == WM_PARENTNOTIFY && wParam != WM_RBUTTONDOWN)
                break;

	    GetCursorPos(&pt);

	    // Don't allow error dlgs to come up while we're tracking.  That
	    // would cause windows to enter the twilight zone.
	    p->fTracking = TRUE;
	    TrackPopupMenu(p->hmenu,
		TPM_RIGHTBUTTON, pt.x, pt.y, 0, hwnd, NULL);
	    p->fTracking = FALSE;

            return 0;

        case WM_PALETTECHANGED:
	    if ((HWND)wParam != hwnd && p->fHasPalette)
		InvalidateRect(hwnd, NULL, FALSE);
	    break;

	case WM_QUERYNEWPALETTE:
	    if (p->fHasPalette)
		MCIWndRealize(hwnd, FALSE);
            break;

	// Send a WM_PALETTECHANGED to everyone in the system.  We need to do
	// this manually sometimes because of GDI.
	case MCIWNDM_PALETTEKICK:

	    hwndD = GetDesktopWindow();	// tell everyone DESKTOP changed it
            PostMessage((HWND)-1, WM_PALETTECHANGED, (WPARAM)hwndD, 0);

	    // DESKTOP won't repaint if we give it it's own HWND, so pick a
	    // random window and PRAY it'll stay valid.
	    hwndD = GetActiveWindow();
	    hwndD = GetWindow(hwndD, GW_HWNDLAST);
            PostMessage(GetDesktopWindow(), WM_PALETTECHANGED, (WPARAM)hwndD,0);
	    return 0;

	case MCIWNDM_OPENINTERFACE:
	    wsprintf(ach, szInterface, lParam);
	    return MCIWndiOpen(p, 0, (LPSTR)ach);

	case MCIWNDM_SETOWNER:
	    p->hwndOwner = (HWND)wParam;
	    return 0;

        case WM_ERASEBKGND:
            if (p->fCanWindow) {
                MCIWndRect(p, &rc, FALSE);
                SaveDC((HDC)wParam);
                ExcludeClipRect((HDC)wParam, rc.left, rc.top, rc.right,
                    rc.bottom);
                DefWindowProc(hwnd, msg, wParam, lParam);
                RestoreDC((HDC)wParam, -1);
                return 0;
            }
            break;

        case WM_PAINT:
	    hdc = BeginPaint(hwnd, &ps);
            if (p->wDeviceID && p->fCanWindow)
            {
                MCI_ANIM_UPDATE_PARMS mciUpdate;
		
                mciUpdate.hDC = hdc;

                dw = mciSendCommand(p->wDeviceID, MCI_UPDATE,
                            MCI_ANIM_UPDATE_HDC | MCI_WAIT |
                            MCI_DGV_UPDATE_PAINT,
                            (DWORD)(LPVOID)&mciUpdate);

                if (dw != 0) /* if the update fails then erase */
                    DefWindowProc(hwnd, WM_ERASEBKGND, (WPARAM)hdc, 0);
	    } else if (IsIconic(hwnd)) {
		DefWindowProc(hwnd, WM_ICONERASEBKGND, (WPARAM)hdc, 0);
		DrawIcon(ps.hdc, 0, 0, p->hicon);
	    }
	    EndPaint(hwnd, &ps);
	    break;
	    
	case WM_KEYDOWN:
		switch(wParam) {
		    case VK_LEFT:
			SendMessage(hwnd, WM_HSCROLL, TB_LINEUP, 0); break;
		    case VK_RIGHT:
			SendMessage(hwnd, WM_HSCROLL, TB_LINEDOWN, 0); break;
		    case VK_PRIOR:
			SendMessage(hwnd, WM_HSCROLL, TB_PAGEUP, 0); break;
		    case VK_NEXT:
			SendMessage(hwnd, WM_HSCROLL, TB_PAGEDOWN, 0); break;
		    case VK_HOME:
			SendMessage(hwnd, WM_HSCROLL, TB_TOP, 0); break;
		    case VK_END:
			SendMessage(hwnd, WM_HSCROLL, TB_BOTTOM, 0); break;

		    case VK_UP:
		    case VK_DOWN:
			dw = MCIWndGetValue(p, FALSE, szStatusVolume, 1000);
			if (wParam == VK_UP)
			    i = min((int)p->wMaxVol * 10, (int) dw + 100);
			else
			    i = max(0, (int) dw - 100);
			
			MCIWndSetVolume(p->hwnd, i);
			break;
		    default:
			break;
		}
	    break;


	case WM_KEYUP:
	    switch(wParam) {
		case VK_LEFT:
		case VK_RIGHT:
		case VK_PRIOR:
		case VK_NEXT:
		case VK_HOME:
		case VK_END:
		    if (p->fScrolling)
		        SendMessage(hwnd, WM_HSCROLL, TB_ENDTRACK, 0);
		    break;
                case VK_ESCAPE:
                    MCIWndStop(hwnd);
                    break;
		default:
		    break;
	    }
			
    	    if (GetKeyState(VK_CONTROL) & 0x8000) {
		switch(wParam) {
		    case '1':
		    case '2':
		    case '3':
		    case '4':
			if (!(p->dwStyle & MCIWNDF_NOAUTOSIZEWINDOW))
			    MCIWndSetZoom(hwnd, 100 * (wParam - '0'));
			break;
		    case 'P':
			MCIWndPlay(hwnd); break;
		    case 'S':
			MCIWndStop(hwnd); break;
		    case 'D':
			PostMessage(hwnd, WM_COMMAND, IDM_MCICONFIG, 0); break;
		    case 'C':
			PostMessage(hwnd, WM_COMMAND, IDM_COPY, 0); break;
		    case VK_F5:
			PostMessage(hwnd, WM_COMMAND, IDM_MCICOMMAND, 0); break;
		    case 'F':
		    case 'O':
			if (!(p->dwStyle & MCIWNDF_NOOPEN))
			    MCIWndOpenDialog(hwnd);
			break;
		    case 'M':
			PostMessage(hwnd, WM_COMMAND, ID_TOOLBAR,
				MAKELONG(IDM_MENU, TBN_BEGINDRAG)); break;
		    default:
			break;
		}
	    }
	    break;

	case WM_SYSCHAR:
	    switch(wParam) {
	        case '1':
	        case '2':
	        case '3':
	        case '4':
		    if (!(p->dwStyle & MCIWNDF_NOAUTOSIZEWINDOW))
			MCIWndSetZoom(hwnd, 100 / ((UINT) wParam - '0'));
		    return 0;	// break will ding
	        default:
		    break;
	    }
	    break;

	case WM_HSCROLL:

#define FORWARD	 1
#define BACKWARD 2

            dwPos = SendMessage(p->hwndTrackbar, TBM_GETPOS, 0, 0);

	    // nothing to do - spurious END without BEGIN
	    if (!p->fScrolling && wParam == TB_ENDTRACK)
		break;

	    // Turn seek exactly off while scrolling and remember what it was
	    // Also, remember if we were playing just before we seeked so we
	    // can continue playing after the seek (so moving the thumb doesn't
	    // stop the play).
            if (!p->fScrolling) {
                p->fScrolling = TRUE;
		// Wierd artifacts happen if you turn seek exactly off while
		// seeking. You see the key frame and then the actual frame.
		// Nobody can remember why this was ever a good idea.
		//p->fSeekExact = MCIWndSeekExact(p, FALSE);
		// if we're still seeking from last time, don't change this
		if (p->dwMode != MCI_MODE_SEEK)
                    p->fPlayAfterSeek = (p->dwMode == MCI_MODE_PLAY);
		// Now which direction was it playing in?
		if (p->fPlayAfterSeek) {
		    MCIWndGet(p, szStatusForward, ach, sizeof(ach));
		    if (ach[0] == 'F' || ach[0] == 'f')
			p->fPlayAfterSeek = BACKWARD;
		    else	// by default, choose forward. Some devices
				// don't understand this command and fail.
			p->fPlayAfterSeek = FORWARD;
		}
            }

	    switch(wParam)
	    {
		case TB_LINEUP:
		    dwPos--; break;
		case TB_LINEDOWN:
		    dwPos++; break;
		case TB_PAGEUP:
		    if (p->fHasTracks) {
			dwPos = MCIWndiPrevTrack(p); break;
		    } else {
                        dwPos -= p->dwMediaLen / 16; break;
		    }
		case TB_PAGEDOWN:
		    if (p->fHasTracks) {
			dwPos = MCIWndiNextTrack(p); break;
		    } else {
                        dwPos += p->dwMediaLen / 16; break;
		    }
		case TB_TOP:
		    dwPos = p->dwMediaStart; break;
		case TB_BOTTOM:
		    dwPos = p->dwMediaStart + p->dwMediaLen; break;
		case TB_THUMBTRACK:
		case TB_THUMBPOSITION:
		    break;
		case TB_ENDTRACK:
		    // All done.  Put seek exact back to what it used to be
		    p->fScrolling = FALSE;
		    // Don't do this anymore (see above)
		    //MCIWndSeekExact(p, p->fSeekExact);
		    break;

		default:
		    break;

	    }

	    // If we're windowed, update the position as we scroll.  That would
	    // be annoying for CD or wave, though.  Also, update as soon as we
	    // let go of the thumb.  Also, never seek around while we're open
	    // or not ready.
	    if ((p->fCanWindow || !p->fScrolling) && p->dwMode != MCI_MODE_OPEN
					&& p->dwMode != MCI_MODE_NOT_READY) {
	        MCIWndSeek(hwnd, dwPos);
		MCIWndiTimerStuff(p);	// kick ourselves to update mode
	    }

	    // After we're done, if we were playing before, go back to playing
	    if (!p->fScrolling && p->fPlayAfterSeek) {
		if (p->fPlayAfterSeek == FORWARD)
                    MCIWndPlay(hwnd);
		else
                    MCIWndPlayReverse(hwnd);
		MCIWndiTimerStuff(p);	// kick ourselves to update mode
	    }

	    // Set the trackbar to the (possibly) new position
	    SendMessage(p->hwndTrackbar, TBM_SETPOS, TRUE, dwPos);
            break;

        case WM_MENUSELECT:
            break;

	// Sent from a toolbar button being pressed
	case WM_COMMAND:
	    // Check for ZOOM commands
	    if (wParam >= IDM_MCIZOOM && wParam < IDM_MCIZOOM + 1000)
		MCIWndSetZoom(hwnd, wParam - IDM_MCIZOOM);

	    // !!! Hack from Hell
	    // If our bogus top menu item is selected, turn it into the REAL
	    // menu item closest to it.
	    if (wParam == IDM_MCIVOLUME + VOLUME_MAX + 1)
		wParam = IDM_MCIVOLUME + p->wMaxVol;
	    if (wParam == IDM_MCIVOLUME + VOLUME_MAX + 2)
		wParam = IDM_MCIVOLUME;

	    // VOLUME command? Uncheck old one, reset volume, and check new one
	    // Round to the nearest 5 to match a menu identifier
	    if (wParam >=IDM_MCIVOLUME && wParam <=IDM_MCIVOLUME + p->wMaxVol) {
		if (MCIWndSetVolume(hwnd, (wParam - IDM_MCIVOLUME) * 10) == 0
					&& lParam != 42) {
	            CheckMenuItem(p->hmenuVolume, p->uiHack, MF_UNCHECKED);
		    // change state only for a real command, not while dragging
		    CheckMenuItem(p->hmenuVolume, wParam, MF_CHECKED);
		}
	    }

	    // !!! Hack from Hell
	    // If our bogus top menu item is selected, turn it into the REAL
	    // menu item closest to it.
	    if (wParam == IDM_MCISPEED + SPEED_MAX + 1)
		wParam = IDM_MCISPEED + SPEED_MAX;
	    if (wParam == IDM_MCISPEED + SPEED_MAX + 2)
		wParam = IDM_MCISPEED;

	    // SPEED command? Uncheck old one, reset speed, and check new one
	    // Round to the nearest 5 to match a menu identifier
	    if (wParam >=IDM_MCISPEED && wParam <= IDM_MCISPEED + SPEED_MAX) {
		if (MCIWndSetSpeed(hwnd, (wParam - IDM_MCISPEED) * 10) == 0
					&& lParam != 42) {
		    // change state only for a real command, not while dragging
	            CheckMenuItem(p->hmenuSpeed, p->uiHack, MF_UNCHECKED);
		    CheckMenuItem(p->hmenuSpeed, wParam, MF_CHECKED);
		}
	    }

	    switch(wParam)
	    {
		MSG msgT;
		RECT rcT;

                case MCI_RECORD:
                    if (GetKeyState(VK_SHIFT) < 0)
                    {
                        //!!! toggle?
                        //MCIWndRecordPreview(hwnd);
                    }
                    else
                    {
                        MCIWndRecord(hwnd);
                    }
                    break;

                //            PLAY = normal play
                //      SHIFT+PLAY = play backward
                //       CTRL+PLAY = play fullscreen
                // SHIFT+CTRL+PLAY = play fullscreen backward
                //
                case MCI_PLAY:

	#define MaybeRepeat (p->fRepeat ? (LPSTR)szRepeat : (LPSTR)szNULL)

		    // NOTE: We never set errors for the repeat play, because 
		    // lots of device don't support it and would fail.

                    if (GetKeyState(VK_SHIFT) < 0)
		        // If we're at the beginning, seek to the end.
			MCIWndiPlaySeek(p, TRUE);
		    else
		        // If we're at the end, seek to the beginning.
			MCIWndiPlaySeek(p, FALSE);

                    if (GetKeyState(VK_CONTROL) < 0)
                    {
                        if (GetKeyState(VK_SHIFT) < 0) {
                            if (MCIWndString(p, FALSE, szPlayFullscreenReverse,
								MaybeRepeat))
                                MCIWndString(p, TRUE, szPlayFullscreenReverse,
								(LPSTR)szNULL);
                        } else {
                            if (MCIWndString(p, FALSE, szPlayFullscreen,
								MaybeRepeat))
                            	MCIWndString(p, TRUE, szPlayFullscreen,
								(LPSTR)szNULL);
			}
                    } else if (GetKeyState(VK_SHIFT) < 0) {
                        if (MCIWndString(p, FALSE, szPlayReverse, MaybeRepeat))
                            MCIWndString(p, TRUE, szPlayReverse, (LPSTR)szNULL);
                    } else {
                        if (MCIWndString(p, FALSE, szPlay, MaybeRepeat))
                    	    MCIWndString(p, TRUE, szPlay, (LPSTR)szNULL);
                    }

		    // Kick ourselves to fix up toolbar since mode changed
		    MCIWndiTimerStuff(p);

                    break;

                case MCI_STOP:
                    return MCIWndStop(hwnd);

                case MCI_PAUSE:
                    return MCIWndPause(hwnd);

	 	case IDM_MCINEW:
		    return MCIWndNew(hwnd, NULL);

                case IDM_MCIOPEN:
                    return MCIWndOpenDialog(hwnd);

                case MCI_SAVE:
                  return MCIWndSaveDialog(hwnd);

		case IDM_MCICLOSE:
		    return MCIWndClose(hwnd);

		case IDM_MCICONFIG:
		    MCIWndString(p, TRUE, szConfigure);

		    // AVI's configure box might change the size (zoom by 2)
		    // so we better call our size routine.
		    MCIWndiSize(p, 0);

		    // Taking ZOOM X 2 off might leave the outside not painted
		    InvalidateRect(hwnd, NULL, TRUE);
		    break;

		case IDM_MCICOMMAND:
		    mciDialog(hwnd);

		    // call mciwndisize?
		    break;

		case IDM_COPY:
		    MCIWndCopy(p);
		    break;

		case IDM_MCIREWIND:
                    return MCIWndSeek(hwnd, MCIWND_START);

		case IDM_MCIEJECT:
		    return MCIWndEject(hwnd);

                case ID_TOOLBAR:
                    if (HIWORD(lParam) != TBN_BEGINDRAG ||
                        LOWORD(lParam) != IDM_MENU ||
			!SendMessage(p->hwndToolbar, TB_ISBUTTONENABLED,
				IDM_MENU, 0) ||
			!p->hmenu)
                    break;

		    SendMessage(p->hwndToolbar, TB_GETITEMRECT,
			(int)SendMessage(p->hwndToolbar, TB_COMMANDTOINDEX,
				IDM_MENU, 0),
			(LPARAM)(LPVOID)&rc);
		    rcT = rc;
		    ClientToScreen(p->hwndToolbar, (LPPOINT)&rc);
		    ClientToScreen(p->hwndToolbar, (LPPOINT)&rc + 1);

		    // Push the button down (accelerator won't have done this)
		    SendMessage(p->hwndToolbar, TB_PRESSBUTTON, IDM_MENU,
			TRUE);

	    	    // Don't allow error dlgs to come up while we're tracking.
	    	    // That would cause windows to shatter and send shrapnel
		    // flying.
		    p->fTracking = TRUE;
                    TrackPopupMenu(p->hmenu, 0, rc.left, rc.bottom - 1, 0,
				hwnd, &rc);  // don't dismiss menu inside button
		    p->fTracking = FALSE;

		    // Bring the button back up.
		    SendMessage(p->hwndToolbar, TB_PRESSBUTTON, IDM_MENU,
		    	FALSE);

		    // What if we press the menu button to make the menu go
		    // away?  It's just going to bring the menu back up again!
		    // So we need to pull the click out of the queue.
		    // There are bugs in the toolbar code to prevent me from
		    // doing this any other way (like disabling the button)
		    if (PeekMessage(&msgT, p->hwndToolbar, WM_LBUTTONDOWN,
					WM_LBUTTONDOWN, PM_NOREMOVE)) {
		        if (PtInRect(&rcT, MAKEPOINT(msgT.lParam)))
			    PeekMessage(&msgT, p->hwndToolbar, WM_LBUTTONDOWN,
				        WM_LBUTTONDOWN, PM_REMOVE);
		    }

                    break;

                default:
		    break;
	    }
            break;

        case WM_DESTROY:
	    // !!! MMP CLOSE will be deferred till AFTER the DESTROY

	    // Don't palette kick when we're going down.  Not necessary 
	    // 
	    p->fHasPalette = FALSE;
            MCIWndiClose(p, FALSE);  //don't leave us playing into a random DC

	    if (p->hmenu) {
                DestroyMenu(p->hmenu);
		FreeDitherBrush();
	    }

 	    if (p->pTrackStart)
		LocalFree((HANDLE)p->pTrackStart);

	    if (p->hfont) {
		// !!! Someone else may have to go and create it again, but oh
		// !!! well.
		DeleteObject(p->hfont);
		p->hfont = NULL;
	    }

	    if (p->hicon)
		DestroyIcon(p->hicon);
	    
	    // We can't destroy our pointer and then fall through and use it
	    f = p->fMdiWindow;
	    LocalFree((HLOCAL) p);
	    SetWindowLong(hwnd, 0, NULL);	// our p
	    if (f)
		return DefMDIChildProc(hwnd, msg, wParam, lParam);
	    else
		return DefWindowProc(hwnd, msg, wParam, lParam);

	// Use a different rate for the timer depending on if we're active
	// or not.
        case WM_NCACTIVATE:
	    // MDI windows need to realize their palette here
	    if (p->wDeviceID && p->fMdiWindow && p->fHasPalette)
		MCIWndRealize(hwnd, wParam == FALSE);
#if 0
	case WM_ACTIVATE:
	    p->fActive = wParam;
	    KillTimer(hwnd, TIMER1);
	    MCIWndiSetTimer(p);
#endif
	    break;
	    
	case WM_SETFOCUS:
	    p->fActive = TRUE;
	    KillTimer(hwnd, TIMER1);
	    MCIWndiSetTimer(p);
	    break;

	case WM_KILLFOCUS:
	    p->fActive = FALSE;
	    KillTimer(hwnd, TIMER1);
	    MCIWndiSetTimer(p);
	    break;

	// If the user uses MCINOTIFY we pass the notify on to the "owner"
	case MM_MCINOTIFY:
	    // Kick ourselves to update toolbar/titles since getting a notify
	    // means that stuff might have changed.
	    MCIWndiTimerStuff(p);
	    return NotifyOwner(p, msg, wParam, lParam);
	
        case WM_DRAWITEM:
        case WM_MEASUREITEM:
        case WM_DELETEITEM:
            OwnerDraw(p, msg, wParam, lParam);
            return TRUE;        // !!!

        case WM_SYSCOMMAND:
            switch (wParam & ~0xF) {
                case SC_MINIMIZE:
		    // Minimizing from MAXIMIZED state better do the same thing
		    // as restore or windows will always think it's maximized
		    // and start wierding out on us (Chico bug 19541).
		    if (IsZoomed(hwnd)) {
			wParam = SC_RESTORE | (wParam & 0xF);
			break;	// MUST let DefWndProc run
		    }
                    if (p->wDeviceID && p->fCanWindow) {
                        RECT rc;
                        MCIWndGetDest(hwnd, &rc);
                        if (rc.right  > p->rcNormal.right &&
                            rc.bottom > p->rcNormal.bottom) {

			    // We pressed buttons on the title bar... we really
			    // better autosize window.
			    dw = p->dwStyle;
			    p->dwStyle &= ~MCIWNDF_NOAUTOSIZEWINDOW;
                            MCIWndSetZoom(hwnd, 100);
			    p->dwStyle = dw;
                            return 0;
                        }
                    }
                    break;

                case SC_MAXIMIZE:
                    if (p->fCanWindow && !IsIconic(hwnd)) {
                        RECT rc;
                        MCIWndGetDest(hwnd, &rc);
                        if (rc.right  < p->rcNormal.right &&
                            rc.bottom < p->rcNormal.bottom) {

			    // We pressed buttons on the title bar... we really
			    // better autosize window.
			    dw = p->dwStyle;
			    p->dwStyle &= ~MCIWNDF_NOAUTOSIZEWINDOW;
                            MCIWndSetZoom(hwnd, 100);
			    p->dwStyle = dw;
                            return 0;
                        }
                        if (rc.right  >= p->rcNormal.right &&
                            rc.right  <  p->rcNormal.right*2 &&
                            rc.bottom >= p->rcNormal.bottom &&
                            rc.bottom <  p->rcNormal.bottom*2) {

			    // We pressed buttons on the title bar... we really
			    // better autosize window.
			    dw = p->dwStyle;
			    p->dwStyle &= ~MCIWNDF_NOAUTOSIZEWINDOW;
                            MCIWndSetZoom(hwnd, 200);
			    p->dwStyle = dw;
                            return 0;
                        }
                    }
                    break;
            }
            break;

	case WM_DROPFILES:
	    MCIWndiDrop(hwnd, wParam);
	    break;

	case WM_QUERYDRAGICON:
	    return (LONG)(UINT)p->hicon;
    }

    if (p && p->fMdiWindow)
        return DefMDIChildProc(hwnd, msg, wParam, lParam);
    else
        return DefWindowProc(hwnd, msg, wParam, lParam);
}

static void NEAR PASCAL PatRect(HDC hdc,int x,int y,int dx,int dy)
{
    RECT    rc;

    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}

#define FillRC(hdc, prc)    PatRect(hdc, (prc)->left, (prc)->top, (prc)->right - (prc)->left, (prc)->bottom-(prc)->top)

//
// Draw the channel for the volume and speed menu controls
//
static void NEAR PASCAL DrawChannel(HDC hdc, LPRECT prc)
{
    HBRUSH hbrTemp;

    int iWidth = prc->right - prc->left;

    // draw the frame around the window
    SetBkColor(hdc, GetSysColor(COLOR_WINDOWFRAME));

    PatRect(hdc, prc->left, prc->top,      iWidth, 1);
    PatRect(hdc, prc->left, prc->bottom-2, iWidth, 1);
    PatRect(hdc, prc->left, prc->top,      1, prc->bottom-prc->top-1);
    PatRect(hdc, prc->right-1, prc->top, 1, prc->bottom-prc->top-1);

    SetBkColor(hdc, GetSysColor(COLOR_BTNHIGHLIGHT));
    PatRect(hdc, prc->left, prc->bottom-1, iWidth, 1);

    SetBkColor(hdc, GetSysColor(COLOR_BTNSHADOW));
    PatRect(hdc, prc->left+1, prc->top + 1, iWidth-2,1);

    // draw the background in dither gray
    hbrTemp = SelectObject(hdc, hbrDither);

    if (hbrTemp) {
        PatBlt(hdc, prc->left+1, prc->top + 2,
            iWidth-2, prc->bottom-prc->top-4, PATCOPY);
        SelectObject(hdc, hbrTemp);
    }
}

static LONG OwnerDraw(PMCIWND p, UINT msg, WORD wParam, LONG lParam)
{
    RECT        rc, rcMenu, rcChannel, rcThumb;
    HDC         hdc;
    int         i,dx,dy,len;
    char        ach[10];
    DWORD       dw;
    HWND	hwnd = p->hwnd;

    #define lpMIS  ((LPMEASUREITEMSTRUCT)lParam)
    #define lpDIS  ((LPDRAWITEMSTRUCT)lParam)

    #define WIDTH_FROM_THIN_AIR 14
    #define CHANNEL_INDENT	6	// for VOLUME and SPEED menu trackbar
    #define MENU_WIDTH          10
    #define THUMB               5
    #define MENU_ITEM_HEIGHT	2

    switch (msg)
    {
        case WM_MEASUREITEM:

            if (p->hfont == NULL)
                p->hfont = CreateFont (8, 0, 0, 0,
		                FW_NORMAL,FALSE,FALSE,FALSE,
		                ANSI_CHARSET,OUT_DEFAULT_PRECIS,
                                CLIP_DEFAULT_PRECIS,PROOF_QUALITY,
		                VARIABLE_PITCH | FF_DONTCARE,
                                szSmallFonts);

	    //
	    // The first and last menu items are the spaces above and below
	    // the channel, so they need to be taller.
	    //
	    if (lpMIS->itemID == IDM_MCIVOLUME + VOLUME_MAX + 1
		|| lpMIS->itemID == IDM_MCISPEED + SPEED_MAX + 1
	    	|| lpMIS->itemID == IDM_MCIVOLUME + VOLUME_MAX + 2
		|| lpMIS->itemID == IDM_MCISPEED + SPEED_MAX + 2) {

                lpMIS->itemHeight = CHANNEL_INDENT;
                lpMIS->itemWidth  = MENU_WIDTH;
	    } else {
                lpMIS->itemHeight = MENU_ITEM_HEIGHT;
                lpMIS->itemWidth  = MENU_WIDTH;
	    }
	    return TRUE;

        case WM_DRAWITEM:
            rc  = lpDIS->rcItem;
            hdc = lpDIS->hDC;

	    //
	    // Something has been deselected.  If we don't see a new selection
	    // soon, it means we've dragged the cursor off the menu, and we
	    // should pop the thumb back to its original spot.
	    //
	    if ((lpDIS->itemAction & ODA_SELECT) &&
				!(lpDIS->itemState & ODS_SELECTED))
		SetTimer(p->hwnd, TIMER2, 500, NULL);
		
            //
	    // When asked to draw the selected or checked menu item, we will
	    // draw the entire menu.  Otherwise, we don't do a thing
            //
	    if (lpDIS->itemState & (ODS_SELECTED | ODS_CHECKED)) {

		// This is the item that is checked, or the original spot for
		// the thumb.  Remember it so when we drag off the menu, we
		// can bounce the thumb back here.
		if (lpDIS->itemState & ODS_CHECKED) {
		    p->uiHack = lpDIS->itemID;
	            if (p->uiHack >= IDM_MCISPEED &&
	            		p->uiHack <= IDM_MCISPEED + SPEED_MAX)
			p->hmenuHack = p->hmenuSpeed;
		    else
			p->hmenuHack = p->hmenuVolume;
		}

		// Something is being selected.  Obviously the mouse is still
		// on the menu.  Scrap our timer that was waiting to see if
		// we've dragged off the menu.
		if (lpDIS->itemState & ODS_SELECTED)
		    KillTimer(p->hwnd, TIMER2);

		// !!! Hack  !!!
	        // If we try to highlight the bogus menu items, bail!
	        if (lpDIS->itemID == IDM_MCIVOLUME + VOLUME_MAX + 1)
		    break;
	        if (lpDIS->itemID == IDM_MCIVOLUME + VOLUME_MAX + 2)
		    break;
	        if (lpDIS->itemID == IDM_MCISPEED + SPEED_MAX + 1)
		    break;
	        if (lpDIS->itemID == IDM_MCISPEED + SPEED_MAX + 2)
		    break;

		// Actually set the parameter to the value we're dragging so
		// we can hear it change as we move the slider.
		// 42 means DON'T CHECK it (remember which item was originally
		// checked).
		SendMessage(hwnd, WM_COMMAND, lpDIS->itemID, 42);

		//
		// Get the rect of our menu window.  GetClipBox is
		// not quite right, so we'll adjust for the border.  Our lpDIS
		// contains the proper width of the client area, so we'll use
		// that.
		//

                GetClipBox(hdc, &rc);
                rc.top++;	//!!! top border width
                rc.bottom -= 2;	//!!! bottom border width
                rc.left = lpDIS->rcItem.left;
                rc.right = lpDIS->rcItem.right;
	 	rcMenu = rc;	// This is the rect of the whole menu

		// !!!
		// Deflate the rect to the area we want the channel to be
		// drawn in.  Use HACKY constants.
		// !!!
                i = (rc.right - rc.left - WIDTH_FROM_THIN_AIR) / 2;
                rc.top    += CHANNEL_INDENT;
                rc.bottom -= CHANNEL_INDENT;
                rc.left   += i;
                rc.right  -= i;
		rcChannel = rc;	// This is the rect of the channel

		//
		// See where the thumb belongs
		//
                rc = lpDIS->rcItem;
		rc.bottom = rc.top + 2;		// Ouch! Make sure size is 2
		
		//
		// Don't draw the thumb higher than the top of the channel
		//
		if (rc.top < rcChannel.top) {
		    rc.top = rcChannel.top;
		    rc.bottom = rc.top + 2;	// itemHeight
		}

		//
		// Don't draw the thumb below the bottom of the channel
		//
		if (rc.top > rcChannel.bottom - 2) {	// where border is
		    rc.top = rcChannel.bottom - 2;
		    rc.bottom = rc.top + 2;
		}

		//
		// Munge the rect in a bit and draw the thumb there
		//
                rc.left  += 2;
                rc.right -= 2;
                rc.bottom+= THUMB;
                rc.top   -= THUMB;

#if 0
		// Make the thumb a little bigger on the checked value
	        if (lpDIS->itemState & ODS_CHECKED) {
		    rc.top -= 1;
		    rc.bottom += 1;
		}
#endif

		rcThumb = rc;	// This is the rect of the thumb

                dx = rc.right  - rc.left;
                dy = rc.bottom - rc.top;

                SetBkColor(hdc, GetSysColor(COLOR_WINDOWFRAME));
                PatRect(hdc, rc.left+1, rc.top, dx-2,1        );
                PatRect(hdc, rc.left+1, rc.bottom-1,dx-2,1    );
                PatRect(hdc, rc.left, rc.top+1, 1,dy-2        );
                PatRect(hdc, rc.right-1,  rc.top+1, 1,dy-2    );

                InflateRect(&rc,-1,-1);
                dx = rc.right  - rc.left;
                dy = rc.bottom - rc.top;

//              SetBkColor(hdc, GetSysColor(COLOR_BTNHILIGHT));
                SetBkColor(hdc, RGB(255,255,255));
                PatRect(hdc, rc.left,   rc.top,   1,dy);
                PatRect(hdc, rc.left,   rc.top,   dx,1);

                SetBkColor(hdc, GetSysColor(COLOR_BTNSHADOW));
                PatRect(hdc, rc.right-1,rc.top+1, 1,dy-1);
                PatRect(hdc, rc.left+1, rc.bottom-1, dx-1,1);

                InflateRect(&rc,-1,-1);

                SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));
                SelectObject(hdc, p->hfont);
                len = wsprintf(ach, "%d", lpMIS->itemID % 1000);
                dw = GetTextExtent(hdc, ach, len);
                ExtTextOut(hdc,
                    (rc.right  + rc.left - LOWORD(dw))/2,
                    (rc.bottom + rc.top - HIWORD(dw))/2,
                    ETO_OPAQUE,&rc,ach,len,NULL);
//              FillRC(hdc, &rc);

		//
		// Exclude the ClipRect that all that garbage drew into
		//
                ExcludeClipRect(hdc, rcThumb.left, rcThumb.top,
                        rcThumb.right, rcThumb.bottom);
#if 0   // why?
		ExcludeClipRect(hdc, rcThumb.left+1, rcThumb.top,
			rcThumb.right-1, rcThumb.bottom);
		ExcludeClipRect(hdc, rcThumb.left, rcThumb.top+1,
			rcThumb.left+1, rcThumb.bottom-1);
		ExcludeClipRect(hdc, rcThumb.right-1, rcThumb.top+1,
			rcThumb.right, rcThumb.bottom-1);
#endif
		//
		// Next, draw the channel
		//
                DrawChannel(hdc, &rcChannel);
		ExcludeClipRect(hdc, rcChannel.left, rcChannel.top,
                        rcChannel.right, rcChannel.bottom);

		//
		// Lastly, fill the entire menu rect with the menu colour
		//
                SetBkColor(hdc, GetSysColor(COLOR_MENU));
                FillRC(hdc, &rcMenu);
            }

            return TRUE;

	case WM_DELETEITEM:
	    return TRUE;
    }
    return TRUE;
}


//
// Code to implement the MCI command dialog box
//

void PositionWindowNearParent(HWND hwnd)
{
    RECT    rc;
    RECT    rcParent;

    GetWindowRect(hwnd, &rc);
    rc.bottom -= rc.top;
    rc.right -= rc.left;
    GetWindowRect(GetParent(hwnd), &rcParent);

    if (rcParent.bottom + rc.bottom <
				GetSystemMetrics(SM_CYSCREEN)) {
	SetWindowPos(hwnd, NULL,
		     min(rc.left, GetSystemMetrics(SM_CXSCREEN) - rc.right),
		     rcParent.bottom,
		     0, 0,
		     SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
    } else if (rc.bottom < rcParent.top) {
	SetWindowPos(hwnd, NULL,
		     min(rc.left, GetSystemMetrics(SM_CXSCREEN) - rc.right),
		     rcParent.top - rc.bottom,
		     0, 0,
		     SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
    }
}

/*--------------------------------------------------------------+
| mciDialog - bring up the dialog for MCI Send Command          |
|                                                               |
+--------------------------------------------------------------*/
BOOL FAR PASCAL _loadds mciDlgProc(HWND hwnd, unsigned msg, WPARAM wParam, LPARAM lParam)
{
    char    ach[255];
    UINT    w;
    DWORD   dw;
    PMCIWND p;
    HWND    hwndP;

    switch (msg)
    {
        case WM_INITDIALOG:
	    // Remember our actually true parent
	    SetWindowLong(hwnd, DWL_USER, lParam);
	    PositionWindowNearParent(hwnd);
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
#ifdef WIN32
                    SendDlgItemMessage(hwnd, IDC_MCICOMMAND, EM_SETSEL, 0, (LPARAM)-1);
#else
                    SendDlgItemMessage(hwnd, IDC_MCICOMMAND, EM_SETSEL, 0, MAKELONG(0, -1));
#endif
                    w = GetDlgItemText(hwnd, IDC_MCICOMMAND, ach, sizeof(ach));

		    hwndP = (HWND)GetWindowLong(hwnd, DWL_USER);
		    p = (PMCIWND)(UINT)GetWindowLong(hwndP, 0);

		    // special case the CLOSE command to do our clean up
		    if (lstrcmpi((LPSTR)ach, szClose) == 0) {
			MCIWndClose(hwndP);
			break;
		    }

                    dw = MCIWndGet(p, ach, ach, sizeof(ach));

                    if (dw != 0)
                        mciGetErrorString(dw, ach, sizeof(ach));

                    SetDlgItemText(hwnd, IDC_RESULT, ach);

	    	    // kick ourselves in case mode changed from this command
	    	    MCIWndiTimerStuff(p);
                    break;

                case IDCANCEL:
                    EndDialog(hwnd, FALSE);
                    break;
            }
            break;
    }

    return FALSE;
}

static BOOL NEAR PASCAL mciDialog(HWND hwnd)
{
    DialogBoxParam(hInst, MAKEINTATOM(DLG_MCICOMMAND), hwnd,
		(DLGPROC)mciDlgProc, hwnd);
    return TRUE; 
}


//
// Code to implement the Copy command:
//
//
// MCIWnd tries to copy the same things to the clipboard that VfW MPlayer
// would have.
// 

#define SLASH(c)     ((c) == '/' || (c) == '\\')
/**************************************************************************

    convert a file name to a fully qualifed path name, if the file
    exists on a net drive the UNC name is returned.

***************************************************************************/

static BOOL NetParseFile(LPSTR szFile, LPSTR szPath)
{
    char        achDrive[4];
    char        achRemote[128];
    int         cbRemote = sizeof(achRemote);
    OFSTRUCT    of;

    if (szPath == NULL)
        szPath = szFile;
    else
        szPath[0] = 0;

    //
    // Fully qualify the file name
    //
    if (OpenFile(szFile, &of, OF_PARSE) == -1)
        return FALSE;

    lstrcpy(szPath, of.szPathName);

    //
    // if the file is not drive based (probably UNC)
    //
    if (szPath[1] != ':')
        return TRUE;

    achDrive[0] = szPath[0];
    achDrive[1] = ':';
    achDrive[2] = '\0';

    if (WNetGetConnection(achDrive, achRemote, &cbRemote) != WN_SUCCESS)
        return FALSE;

    if (!SLASH(achRemote[0]) || !SLASH(achRemote[1]))
	return TRUE;

    lstrcat(achRemote, szPath+2);
    lstrcpy(szPath, achRemote);

    return TRUE;
}



SZCODE aszMPlayerName[]           = "MPlayer";
HANDLE GetMPlayerData(PMCIWND p)
{
    char        szFileName[128];
    char	ach[40];
    char        szDevice[40];
    HANDLE      h;
    LPSTR       psz;
    int         len;
    LPSTR	lpszCaption = szFileName;
    UINT	wOptions;
    RECT	rc;
    BOOL	fCompound, fFile;
    DWORD	dw;
    MCI_GETDEVCAPS_PARMS    mciDevCaps; /* for the MCI_GETDEVCAPS command */

    //
    // Get the Device Name
    //
    MCIWndGet(p, "sysinfo installname", szDevice, sizeof(szDevice));
    
    //
    // determine if the device is simple or compound
    //
    mciDevCaps.dwItem = MCI_GETDEVCAPS_COMPOUND_DEVICE;
    dw = mciSendCommand(p->wDeviceID, MCI_GETDEVCAPS,
        MCI_GETDEVCAPS_ITEM, (DWORD)(LPSTR)&mciDevCaps);
    fCompound = (dw == 0 && mciDevCaps.dwReturn != 0);

    //
    // determine if the device handles files
    //
    if (fCompound) {
        mciDevCaps.dwItem = MCI_GETDEVCAPS_USES_FILES;
        dw = mciSendCommand(p->wDeviceID, MCI_GETDEVCAPS,
            MCI_GETDEVCAPS_ITEM, (DWORD)(LPSTR)&mciDevCaps);
        fFile = (dw == 0 && mciDevCaps.dwReturn != 0);
    }

    //
    // Compound devices that support files have an associated filename
    //
    if (fCompound && fFile) {
        lstrcpy(szFileName, p->achFileName);

	//
	// Sometimes the filename is really "device!filename" so we have to peel
	// the real filename out of it
	//
	lstrcpyn(ach, szFileName, lstrlen(szDevice) + 1);
	if ((lstrcmpi(szDevice, ach) == 0) &&
			(szFileName[lstrlen(szDevice)] == '!')) {
	    lstrcpy(szFileName, &(p->achFileName[lstrlen(szDevice) + 1]));
	}

        NetParseFile(szFileName, (LPSTR)NULL);
        OemToAnsi(szFileName,szFileName);	// Map extended chars.
    } else {
	szFileName[0] = 0;
    }

#ifdef DEBUG
    DPF("  GetLink: %s|%s!%s\n",
        (LPSTR)aszMPlayerName,
        (LPSTR)szFileName,
        (LPSTR)szDevice);
#endif

    /* How much data will we be writing? */
    len = 9 +                    // all the delimeters
          lstrlen(aszMPlayerName) +
          lstrlen(szFileName) +
          lstrlen(szDevice) +
          5 + 10 + 10 + 10 +     // max length of int and long strings
          lstrlen(lpszCaption);

    h = GlobalAlloc(GMEM_DDESHARE|GMEM_ZEROINIT, len);
    if (!h)
        return NULL;
    psz = GlobalLock(h);

    wOptions = 0x0030; // !!!! OPT_PLAY|OPT_BAR

    switch (MCIWndStatus(p, MCI_STATUS_TIME_FORMAT, 0)) {
	case MCI_FORMAT_FRAMES:
	    wOptions |= 1;	// frame mode
	    break;
	    
	case MCI_FORMAT_MILLISECONDS:
	    wOptions |= 2;	// time mode
	    break;
    }
	    
    MCIWndRect(p, &rc, FALSE);
    
    wsprintf(psz, "%s%c%s%c%s%c%d%c%ld%c%ld%c%ld%c%d%c%s%c",
        (LPSTR)aszMPlayerName, 0,
        (LPSTR)szFileName, 0,
        (LPSTR)szDevice, ',',
	wOptions, ',',
	0L, ',', // !!! sel start
	0L, ',', // !!! sel length
	p->dwPos, ',',
	rc.bottom - rc.top, ',',
        lpszCaption, 0);

    return h;
}

HBITMAP FAR PASCAL BitmapMCI(PMCIWND p)
{
    HDC         hdc, hdcMem;
    HBITMAP     hbm, hbmT;
    HBRUSH      hbrOld;
    DWORD       dw;
    RECT        rc;
    HBRUSH hbrWindowColour;

    /* Minimum size of bitmap is icon size */
    int ICON_MINX = GetSystemMetrics(SM_CXICON);
    int ICON_MINY = GetSystemMetrics(SM_CYICON);

    /* Get size of a frame or an icon that we'll be drawing */
    MCIWndRect(p, &rc, FALSE);

    SetRect(&rc, 0, 0,
	    max(ICON_MINX, rc.right - rc.left),
	    max(ICON_MINX, rc.bottom - rc.top));

    hdc = GetDC(NULL);
    if (hdc == NULL)
        return NULL;
    hdcMem = CreateCompatibleDC(NULL);
    if (hdcMem == NULL) {
        ReleaseDC(NULL, hdc);
        return NULL;
    }

    /* Big enough to hold text caption too, if necessary */
    hbm = CreateCompatibleBitmap(hdc, rc.right, rc.bottom);
    ReleaseDC(NULL, hdc);
    if (hbm == NULL) {
        DeleteDC(hdcMem);
        return NULL;
    }

    hbmT = SelectObject(hdcMem, hbm);

    hbrWindowColour     = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
    hbrOld = SelectObject(hdcMem, hbrWindowColour);
    PatBlt(hdcMem, 0,0, rc.right, rc.bottom, PATCOPY);
    SelectObject(hdcMem, hbrOld);
    DeleteObject(hbrWindowColour);

    if (p->wDeviceID && p->fCanWindow)
    {
	MCI_ANIM_UPDATE_PARMS mciUpdate;

	mciUpdate.hDC = hdcMem;

	dw = mciSendCommand(p->wDeviceID, MCI_UPDATE,
		    MCI_ANIM_UPDATE_HDC | MCI_WAIT,
		    (DWORD)(LPVOID)&mciUpdate);
    } else {
	DrawIcon(hdcMem, rc.left, rc.top, p->hicon);
    }

    if (hbmT)
        SelectObject(hdcMem, hbmT);
    DeleteDC(hdcMem);

    return hbm;
}

HPALETTE CopyPalette(HPALETTE hpal)
{
    PLOGPALETTE ppal;
    int         nNumEntries;
    int         i;

    if (!hpal)
        return NULL;

    GetObject(hpal,sizeof(int),(LPSTR)&nNumEntries);

    if (nNumEntries == 0)
        return NULL;

    ppal = (PLOGPALETTE)LocalAlloc(LPTR,sizeof(LOGPALETTE) +
                nNumEntries * sizeof(PALETTEENTRY));

    if (!ppal)
        return NULL;

    ppal->palVersion    = 0x300;
    ppal->palNumEntries = nNumEntries;

    GetPaletteEntries(hpal,0,nNumEntries,ppal->palPalEntry);

    for (i=0; i<nNumEntries; i++)
        ppal->palPalEntry[i].peFlags = 0;

    hpal = CreatePalette(ppal);

    LocalFree((HANDLE)ppal);
    return hpal;
}

HANDLE FAR PASCAL PictureFromDib(HANDLE hdib, HPALETTE hpal)
{
    LPMETAFILEPICT      pmfp;
    HANDLE              hmfp;
    HANDLE              hmf;
    HANDLE              hdc;
    LPBITMAPINFOHEADER  lpbi;

    if (!hdib)
        return NULL;

    lpbi = (LPVOID)GlobalLock(hdib);
    if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
        lpbi->biClrUsed = 1 << lpbi->biBitCount;

    hdc = CreateMetaFile(NULL);
    if (!hdc)
        return NULL;

    SetWindowOrgEx(hdc, 0, 0, NULL);
    SetWindowExtEx(hdc, (int)lpbi->biWidth, (int)lpbi->biHeight, NULL);

    if (hpal)
    {
        SelectPalette(hdc,hpal,FALSE);
        RealizePalette(hdc);
    }

    SetStretchBltMode(hdc, COLORONCOLOR);

    StretchDIBits(hdc,
        0,0,(int)lpbi->biWidth, (int)lpbi->biHeight,
        0,0,(int)lpbi->biWidth, (int)lpbi->biHeight,
        (LPBYTE)lpbi + (int)lpbi->biSize + (int)lpbi->biClrUsed * sizeof(RGBQUAD),
        (LPBITMAPINFO)lpbi,
        DIB_RGB_COLORS,
        SRCCOPY);

    if (hpal)
        SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);

    hmf = CloseMetaFile(hdc);

    if (hmfp = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE, sizeof(METAFILEPICT)))
    {
        pmfp = (LPMETAFILEPICT)GlobalLock(hmfp);

        hdc = GetDC(NULL);
#if 1
        pmfp->mm   = MM_ANISOTROPIC;
        pmfp->hMF  = hmf;
        pmfp->xExt = MulDiv((int)lpbi->biWidth ,2540,GetDeviceCaps(hdc, LOGPIXELSX));
        pmfp->yExt = MulDiv((int)lpbi->biHeight,2540,GetDeviceCaps(hdc, LOGPIXELSX));
#else
        pmfp->mm   = MM_TEXT;
        pmfp->hMF  = hmf;
        pmfp->xExt = (int)lpbi->biWidth;
        pmfp->yExt = (int)lpbi->biHeight;
#endif
        ReleaseDC(NULL, hdc);
    }
    else
    {
        DeleteMetaFile(hmf);
    }

    return hmfp;
}

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */

/*
 *  DibFromBitmap()
 *
 *  Will create a global memory block in DIB format that represents the DDB
 *  passed in
 *
 */
HANDLE FAR PASCAL DibFromBitmap(HBITMAP hbm, HPALETTE hpal)
{
    BITMAP               bm;
    BITMAPINFOHEADER     bi;
    BITMAPINFOHEADER FAR *lpbi;
    DWORD                dw;
    HANDLE               hdib;
    HDC                  hdc;
    HPALETTE             hpalT;

    if (!hbm)
        return NULL;

    GetObject(hbm,sizeof(bm),(LPSTR)&bm);

    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = (bm.bmPlanes * bm.bmBitsPixel) > 8 ? 24 : 8;
    bi.biCompression        = BI_RGB;
    bi.biSizeImage          = (DWORD)WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = bi.biBitCount == 8 ? 256 : 0;
    bi.biClrImportant       = 0;

    dw  = bi.biSize + bi.biClrUsed * sizeof(RGBQUAD) + bi.biSizeImage;

    hdib = GlobalAlloc(GHND | GMEM_DDESHARE, dw);

    if (!hdib)
        return NULL;

    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hdib);
    *lpbi = bi;

    hdc = CreateCompatibleDC(NULL);

    if (hpal)
    {
        hpalT = SelectPalette(hdc,hpal,FALSE);
        RealizePalette(hdc);
    }

    GetDIBits(hdc, hbm, 0, (UINT)bi.biHeight,
        (LPSTR)lpbi + (int)lpbi->biSize + (int)lpbi->biClrUsed * sizeof(RGBQUAD),
        (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

    if (hpal)
        SelectPalette(hdc,hpalT,FALSE);

    DeleteDC(hdc);

    return hdib;
}

SZCODE aszNative[]            = "Native";
SZCODE aszOwnerLink[]         = "OwnerLink";

// Pretend to be MPlayer copying to the clipboard
static void NEAR PASCAL MCIWndCopy(PMCIWND p)
{
    UINT	cfNative;
    UINT	cfOwnerLink;
    HBITMAP	hbm;
    HPALETTE	hpal;
    HANDLE	hdib;
    HANDLE	hmfp;
    
    cfNative    = RegisterClipboardFormat(aszNative);
    cfOwnerLink = RegisterClipboardFormat(aszOwnerLink);

    if (p->wDeviceID) {
	OpenClipboard(p->hwnd);
	
        EmptyClipboard();

        SetClipboardData(cfNative, GetMPlayerData(p));
        SetClipboardData(cfOwnerLink, GetMPlayerData(p));

	hbm  = BitmapMCI(p);
	hpal = MCIWndGetPalette(p->hwnd);
	hpal = CopyPalette(hpal);

	if (hbm) {
	    hdib = DibFromBitmap(hbm, hpal);

	    hmfp = PictureFromDib(hdib, hpal);

	    if (hmfp)
		SetClipboardData(CF_METAFILEPICT, hmfp);

	    if (hdib)
		SetClipboardData(CF_DIB, hdib);

	    DeleteObject(hbm);
	}

	if (hpal)
	    SetClipboardData(CF_PALETTE, hpal);

        CloseClipboard();
    }
}

/*****************************************************************************
 ****************************************************************************/

#ifdef DEBUG

static void cdecl dprintf(PSTR szFormat, ...)
{
    char ach[128];

    static BOOL fDebug = -1;

    if (fDebug == -1)
        fDebug = GetProfileInt(szDebug, MODNAME, FALSE);

    if (!fDebug)
        return;

    lstrcpy(ach, MODNAME ": ");
    wvsprintf(ach+lstrlen(ach),szFormat,(LPSTR)(&szFormat+1));
    lstrcat(ach, "\r\n");

    OutputDebugString(ach);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd.16\cutils.c ===
/*
**  CUTILS.C
**
**  Common utilities for common controls
**
*/

#include "ctlspriv.h"

int iDitherCount = 0;
HBRUSH hbrDither = NULL;

int nSysColorChanges = 0;
DWORD rgbFace;			// globals used a lot
DWORD rgbShadow;  
DWORD rgbHilight; 
DWORD rgbFrame;   

int iThumbCount = 0;
HBITMAP hbmThumb = NULL;     // the thumb bitmap

#define CCS_ALIGN (CCS_TOP|CCS_NOMOVEY|CCS_BOTTOM)

#if 0
/* Note that the default alignment is CCS_BOTTOM
 */
void FAR PASCAL NewSize(HWND hWnd, int nHeight, LONG style, int left, int top, int width, int height)
{
  RECT rc, rcWindow, rcBorder;

  /* Resize the window unless the user said not to
   */
  if (!(style & CCS_NORESIZE))
    {
      /* Calculate the borders around the client area of the status bar
       */
      GetWindowRect(hWnd, &rcWindow);
      rcWindow.right -= rcWindow.left;
      rcWindow.bottom -= rcWindow.top;

      GetClientRect(hWnd, &rc);
      ClientToScreen(hWnd, (LPPOINT)&rc);

      rcBorder.left = rc.left - rcWindow.left;
      rcBorder.top  = rc.top  - rcWindow.top ;
      rcBorder.right  = rcWindow.right  - rc.right  - rcBorder.left;
      rcBorder.bottom = rcWindow.bottom - rc.bottom - rcBorder.top ;

      nHeight += rcBorder.top + rcBorder.bottom;

      /* Check whether to align to the parent window
       */
      if (style & CCS_NOPARENTALIGN)
	{
	  /* Check out whether this bar is top aligned or bottom aligned
	   */
	  switch ((style&CCS_ALIGN))
	    {
	      case CCS_TOP:
	      case CCS_NOMOVEY:
		break;

	      default:
		top = top + height - nHeight;
	    }
	}
      else
	{
	  /* It is assumed there is a parent by default
	   */
	  GetClientRect(GetParent(hWnd), &rc);

	  /* Don't forget to account for the borders
	   */
	  left = -rcBorder.left;
	  width = rc.right + rcBorder.left + rcBorder.right;

	  if ((style&CCS_ALIGN) == CCS_TOP)
	      top = -rcBorder.top;
	  else if ((style&CCS_ALIGN) != CCS_NOMOVEY)
	      top = rc.bottom - nHeight + rcBorder.bottom;
	}
      if (!(GetWindowLong(hWnd, GWL_STYLE) & CCS_NODIVIDER))
        {
	  // make room for divider
	  top += 2 * GetSystemMetrics(SM_CYBORDER);
	}

      SetWindowPos(hWnd, NULL, left, top, width, nHeight, SWP_NOZORDER);
    }
}

#endif

static HBITMAP NEAR PASCAL CreateDitherBitmap()
{
    PBITMAPINFO pbmi;
    HBITMAP hbm;
    HDC hdc;
    int i;
    long patGray[8];
    DWORD rgb;

    pbmi = (PBITMAPINFO)LocalAlloc(LPTR, sizeof(BITMAPINFOHEADER) + (sizeof(RGBQUAD) * 16));
    if (!pbmi)
        return NULL;

    pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth = 8;
    pbmi->bmiHeader.biHeight = 8;
    pbmi->bmiHeader.biPlanes = 1;
    pbmi->bmiHeader.biBitCount = 1;
    pbmi->bmiHeader.biCompression = BI_RGB;

    rgb = GetSysColor(COLOR_BTNFACE);
    pbmi->bmiColors[0].rgbBlue  = GetBValue(rgb);
    pbmi->bmiColors[0].rgbGreen = GetGValue(rgb);
    pbmi->bmiColors[0].rgbRed   = GetRValue(rgb);
    pbmi->bmiColors[0].rgbReserved = 0;

    rgb = GetSysColor(COLOR_BTNHIGHLIGHT);
    pbmi->bmiColors[1].rgbBlue  = GetBValue(rgb);
    pbmi->bmiColors[1].rgbGreen = GetGValue(rgb);
    pbmi->bmiColors[1].rgbRed   = GetRValue(rgb);
    pbmi->bmiColors[1].rgbReserved = 0;


    /* initialize the brushes */

    for (i = 0; i < 8; i++)
       if (i & 1)
           patGray[i] = 0xAAAA5555L;   //  0x11114444L; // lighter gray
       else
           patGray[i] = 0x5555AAAAL;   //  0x11114444L; // lighter gray

    hdc = GetDC(NULL);

    hbm = CreateDIBitmap(hdc, &pbmi->bmiHeader, CBM_INIT, patGray, pbmi, DIB_RGB_COLORS);

    ReleaseDC(NULL, hdc);

    LocalFree(pbmi);

    return hbm;
}

/*---------------------------------------------------------------------------
   MySetObjectOwner
   Purpose:  Call SetObjectOwner in GDI, eliminating "<Object> not released"
             error messages when an app terminates.
   Returns:  Yep
  ---------------------------------------------------------------------------*/
static void MySetObjectOwner(HANDLE hObject)
{
	VOID (FAR PASCAL *lpSetObjOwner)(HANDLE, HANDLE);
	HMODULE hMod;

	hMod = GetModuleHandle("GDI");
	if (hMod)
	{
		(FARPROC)lpSetObjOwner = GetProcAddress(hMod, MAKEINTRESOURCE(461));
		if (lpSetObjOwner)
		{
			(lpSetObjOwner)(hObject, hInst);
		}
	}
}

// initialize the hbrDither global brush
// Call this with bIgnoreCount == TRUE if you just want to update the
// current dither brush.

BOOL FAR PASCAL CreateDitherBrush(BOOL bIgnoreCount)
{
	HBITMAP hbmGray;
	HBRUSH hbrSave;

	if (bIgnoreCount && !iDitherCount)
	{
		return TRUE;
	}

	if (iDitherCount>0 && !bIgnoreCount)
	{
		iDitherCount++;
		return TRUE;
	}

	hbmGray = CreateDitherBitmap();
	if (hbmGray)
	{
		hbrSave = hbrDither;
		hbrDither = CreatePatternBrush(hbmGray);
		DeleteObject(hbmGray);
		if (hbrDither)
		{
                        MySetObjectOwner(hbrDither);
			if (hbrSave)
			{
				DeleteObject(hbrSave);
			}
			if (!bIgnoreCount)
			{
				iDitherCount = 1;
			}
			return TRUE;
		}
		else
		{
			hbrDither = hbrSave;
		}
	}

	return FALSE;
}

BOOL FAR PASCAL FreeDitherBrush(void)
{
    iDitherCount--;

    if (iDitherCount > 0)
        return FALSE;

    if (hbrDither)
        DeleteObject(hbrDither);
    hbrDither = NULL;

    return TRUE;
}


// initialize the hbmThumb global bitmap
// Call this with bIgnoreCount == TRUE if you just want to update the
// current bitmap.

void FAR PASCAL CreateThumb(BOOL bIgnoreCount)
{
	HBITMAP hbmSave;

	if (bIgnoreCount && !iThumbCount)
	{
		return;
	}

	if (iThumbCount && !bIgnoreCount)
	{
		++iThumbCount;
		return;
	}

	hbmSave = hbmThumb;

	hbmThumb = CreateMappedBitmap(hInst, IDB_THUMB, CMB_MASKED, NULL, 0);

	if (hbmThumb)
	{
		if (hbmSave)
		{
			DeleteObject(hbmSave);
		}
		if (!bIgnoreCount)
		{
			iThumbCount = 1;
		}
	}
	else
	{
		hbmThumb = hbmSave;
	}
}

void FAR PASCAL DestroyThumb(void)
{
	iThumbCount--;

	if (iThumbCount <= 0)
	{
		if (hbmThumb)
		{
			DeleteObject(hbmThumb);
		}
		hbmThumb = NULL;
		iThumbCount = 0;
	}
}

// Note that the trackbar will pass in NULL for pTBState, because it
// just wants the dither brush to be updated.

void FAR PASCAL CheckSysColors(void)
{
	static COLORREF rgbSaveFace    = 0xffffffffL,
	                rgbSaveShadow  = 0xffffffffL,
	                rgbSaveHilight = 0xffffffffL,
	                rgbSaveFrame   = 0xffffffffL;

	rgbFace    = GetSysColor(COLOR_BTNFACE);
	rgbShadow  = GetSysColor(COLOR_BTNSHADOW);
	rgbHilight = GetSysColor(COLOR_BTNHIGHLIGHT);
	rgbFrame   = GetSysColor(COLOR_WINDOWFRAME);

	if (rgbSaveFace!=rgbFace || rgbSaveShadow!=rgbShadow
		|| rgbSaveHilight!=rgbHilight || rgbSaveFrame!=rgbFrame)
	{
		++nSysColorChanges;
		// Update the brush for pushed-in buttons
		CreateDitherBrush(TRUE);
		CreateThumb(TRUE);

		rgbSaveFace    = rgbFace;
		rgbSaveShadow  = rgbShadow;
		rgbSaveHilight = rgbHilight;
		rgbSaveFrame   = rgbFrame;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd.16\movplay.c ===
/*--------------------------------------------------------------------------*\
|   qmci.c - Quick MDI App                                                  |
|                                                                           |
|   Usage:                                                                  |
|	To make a quick MDI windows application, modify this source	    |
|                                                                           |
|   History:                                                                |
|	12/15/87 toddla     Created					    |
|                                                                           |
\*-------------------------------------------------------------------------*/

#include <windows.h>
#include <commdlg.h>
#include "movplay.h"

#include "mciwnd.h"
#include "preview.h"    //!!! in mciwnd.h???

typedef LONG (FAR PASCAL *LPWNDPROC)(); // pointer to a window procedure

/*-------------------------------------------------------------------------*\
|                                                                          |
|   g l o b a l   v a r i a b l e s                                        |
|                                                                          |
\*------------------------------------------------------------------------*/

// We have our own copy of the MCIWND.LIB so we better make our own class
// names or we'll conflict and blow up!
extern char	aszMCIWndClassName[];
extern char	aszToolbarClassName[];
extern char	aszTrackbarClassName[];

char    szAppName[]  = "MovPlay";   /* change this to your app's name */

char    szOpenFilter[] = "Video Files\0*.avi\0"
                         "Wave Files\0*.wav\0"
                         "Midi Files\0*.mid; *.rmi\0"
                         "All Files\0*.*\0";

HANDLE  hInstApp;                   /* Instance handle */
HACCEL  hAccelApp;
HWND    hwndApp;                    /* Handle to parent window */
HWND    hwndMdi;                    /* Handle to MCI client window */

OFSTRUCT     of;
OPENFILENAME ofn;
char         achFileName[128];

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

long FAR PASCAL _export AppWndProc(HWND, UINT, WPARAM, LPARAM);
long FAR PASCAL _export mdiDocWndProc(HWND, unsigned, WORD, LONG);
int ErrMsg (LPSTR sz,...);

HWND mdiCreateDoc(LPSTR szClass, LPSTR szTitle, LPARAM l);

/*----------------------------------------------------------------------------*\
|   AppAbout( hDlg, msg, wParam, lParam )                                      |
|                                                                              |
|   Description:                                                               |
|       This function handles messages belonging to the "About" dialog box.    |
|       The only message that it looks for is WM_COMMAND, indicating the use   |
|       has pressed the "OK" button.  When this happens, it takes down         |
|       the dialog box.                                                        |
|                                                                              |
|   Arguments:                                                                 |
|       hDlg            window handle of about dialog window                   |
|       msg             message number                                         |
|       wParam          message-dependent                                      |
|       lParam          message-dependent                                      |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if message has been processed, else FALSE                         |
|                                                                              |
\*----------------------------------------------------------------------------*/
BOOL FAR PASCAL _export AppAbout(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) {
        case WM_COMMAND:
            EndDialog(hwnd,TRUE);
            return TRUE;

        case WM_INITDIALOG:
	    return TRUE;
    }
    return FALSE;
}

/*----------------------------------------------------------------------------*\
|   AppInit ( hInstance, hPrevInstance )				       |
|                                                                              |
|   Description:                                                               |
|       This is called when the application is first loaded into               |
|       memory.  It performs all initialization that doesn't need to be done   |
|       once per instance.                                                     |
|                                                                              |
|   Arguments:                                                                 |
|	hPrevInstance	instance handle of previous instance		       |
|       hInstance       instance handle of current instance                    |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if successful, FALSE if not                                       |
|                                                                              |
\*----------------------------------------------------------------------------*/
BOOL AppInit(HANDLE hInst, HANDLE hPrev, LPSTR szCmd, int sw)
{
    WNDCLASS    cls;

    /* Save instance handle for DialogBox */
    hInstApp = hInst;

    hAccelApp = LoadAccelerators(hInstApp, "AppAccel");

    if (!hPrev) {
        cls.hCursor        = LoadCursor(NULL,IDC_ARROW);
        cls.hIcon          = LoadIcon(hInst,"AppIcon");
        cls.lpszMenuName   = "AppMenu";
        cls.lpszClassName  = szAppName;
        cls.hbrBackground  = (HBRUSH)COLOR_APPWORKSPACE+1;
        cls.hInstance      = hInst;
        cls.style          = 0;
        cls.lpfnWndProc    = (WNDPROC)AppWndProc;
        cls.cbClsExtra     = 0;
	cls.cbWndExtra	   = 0;

        if (!RegisterClass(&cls))
            return FALSE;
    }

    // This app has its own copy of the MCIWnd stuff, and doesn't use
    // the copy found in MSVIDEO.DLL  We better also have different
    // class names or else we'll conflict and blow up.
    // !!! Warning - The variable is not too long!
    lstrcpy(aszMCIWndClassName, "MCIWndMov");
    lstrcpy(aszTrackbarClassName, "TrackMov");
    lstrcpy(aszToolbarClassName, "ToolMov");

    MCIWndRegisterClass();

    hwndApp =
#ifdef BIDI
	CreateWindowEx(WS_EX_BIDI_SCROLL |  WS_EX_BIDI_MENU |WS_EX_BIDI_NOICON,
#else
	CreateWindow (
#endif
	       szAppName,szAppName,
	       WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
	       CW_USEDEFAULT,0,
	       CW_USEDEFAULT,0,
	       (HWND)NULL,	  /* no parent */
	       (HMENU)NULL,	  /* use class menu */
               (HANDLE)hInst,     /* handle to window instance */
	       (LPSTR)NULL	  /* no params to pass on */
	     );

    /* Make window visible according to the way the app is activated */
    ShowWindow(hwndApp,sw);

    if (szCmd && szCmd[0])
        mdiCreateDoc(aszMCIWndClassName, 0, (LPARAM)(LPSTR)szCmd);

    return TRUE;
}

/*----------------------------------------------------------------------------*\
|   WinMain( hInstance, hPrevInstance, lpszCmdLine, cmdShow )                  |
|                                                                              |
|   Description:                                                               |
|       The main procedure for the App.  After initializing, it just goes      |
|       into a message-processing loop until it gets a WM_QUIT message         |
|       (meaning the app was closed).                                          |
|                                                                              |
|   Arguments:                                                                 |
|       hInstance       instance handle of this instance of the app            |
|       hPrevInstance   instance handle of previous instance, NULL if first    |
|       lpszCmdLine     ->null-terminated command line                         |
|       cmdShow         specifies how the window is initially displayed        |
|                                                                              |
|   Returns:                                                                   |
|       The exit code as specified in the WM_QUIT message.                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR szCmdLine, int sw)
{
    MSG     msg;

    if (!AppInit(hInstance,hPrevInstance,szCmdLine,sw))
       return FALSE;

    /*
     * Polling messages from event queue
     */
    for (;;)
    {
        if (PeekMessage(&msg, NULL, 0, 0,PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
                break;

            if (hAccelApp && hwndApp &&
			TranslateAccelerator(hwndApp, hAccelApp, &msg))
                continue;

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        else
        {
            // idle time here, DONT BE A PIG!
            WaitMessage();
        }
    }

    return msg.wParam;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

BOOL fDialog(HWND hwnd,int id,FARPROC fpfn)
{
    BOOL	f;
    HANDLE	hInst;

    hInst = (HINSTANCE)GetWindowWord(hwnd,GWW_HINSTANCE);
    fpfn  = MakeProcInstance(fpfn,hInst);
    f = DialogBox(hInst,MAKEINTRESOURCE(id),hwnd,(DLGPROC)fpfn);
    FreeProcInstance (fpfn);
    return f;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

#define mdiGetCreateParam(lParam) \
    (((LPMDICREATESTRUCT)(((LPCREATESTRUCT)lParam)->lpCreateParams))->lParam)

/*----------------------------------------------------------------------------*\
|   mdiCreateChild()							       |
|									       |
|   Description:                                                               |
|                                                                              |
|   Arguments:                                                                 |
|                                                                              |
|   Returns:                                                                   |
|	HWND if successful, NULL otherwise				       |
|									       |
\*----------------------------------------------------------------------------*/

HWND mdiCreateChild(
    HWND  hwndMdi,
    LPSTR szClass,
    LPSTR szTitle,
    DWORD dwStyle,
    int   x,
    int   y,
    int   dx,
    int   dy,
    WORD  sw,
    HMENU hmenu,
    LPARAM l)
{
    MDICREATESTRUCT mdics;

    mdics.szClass   = szClass;
    mdics.szTitle   = szTitle;
    mdics.hOwner    = (HINSTANCE)GetWindowWord(hwndMdi, GWW_HINSTANCE);
    mdics.x         = x;
    mdics.y         = y;
    mdics.cx        = dx;
    mdics.cy        = dy;
    mdics.style     = dwStyle;
    mdics.lParam    = l;

    return (HWND)SendMessage(hwndMdi,WM_MDICREATE,0,(LONG)(LPVOID)&mdics);
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

HWND mdiCreateDoc(LPSTR szClass, LPSTR szTitle, LPARAM l)
{
    return mdiCreateChild(hwndMdi,szClass,szTitle,
	WS_CLIPCHILDREN | WS_CLIPSIBLINGS | MCIWNDF_SHOWALL,
        CW_USEDEFAULT,0,CW_USEDEFAULT,0,SW_NORMAL,NULL,l);
}

/*----------------------------------------------------------------------------*\
|   mdiCreateClient()                                                           |
|									       |
|   Description:                                                               |
|                                                                              |
|   Arguments:                                                                 |
|                                                                              |
|   Returns:                                                                   |
|	HWND if successful, NULL otherwise				       |
|									       |
\*----------------------------------------------------------------------------*/
HWND FAR PASCAL mdiCreateClient(HWND hwndP, HMENU hmenuWindow)
{
    CLIENTCREATESTRUCT ccs;

    ccs.hWindowMenu = hmenuWindow;
    ccs.idFirstChild = 100;

    return
#ifdef BIDI
	CreateWindowEx(WS_EX_BIDI_SCROLL |  WS_EX_BIDI_MENU |WS_EX_BIDI_NOICON,
#else
	CreateWindow (
#endif
		"MDICLIENT",NULL,
                WS_CHILD | WS_CLIPCHILDREN | WS_VISIBLE,
                0,0,0,0,
                hwndP, 0, (HINSTANCE)GetWindowWord(hwndP,GWW_HINSTANCE),
                (LPVOID)&ccs);
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

#define mdiActiveDoc() \
    (HWND)SendMessage(hwndMdi,WM_MDIGETACTIVE,0,0L)

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

LONG NEAR PASCAL mdiSendMessage(HWND hwndMdi, HWND hwnd, unsigned msg, WORD wParam, LONG lParam)
{
    if (hwnd == (HWND)-1)
    {
        for (hwnd = GetWindow(hwndMdi, GW_CHILD); hwnd; hwnd = GetWindow(hwnd, GW_HWNDNEXT))
            SendMessage(hwnd, msg, wParam, lParam);

        return 0L;
    }
    else
    {
        if (hwnd == NULL)
            hwnd = (HWND)SendMessage(hwndMdi,WM_MDIGETACTIVE,0,0L);

        if (hwnd)
            return SendMessage(hwnd, msg, wParam, lParam);
    }
}

/*----------------------------------------------------------------------------*\
|   AppWndProc( hwnd, msg, wParam, lParam )                                    |
|                                                                              |
|   Description:                                                               |
|       The window proc for the app's main (tiled) window.  This processes all |
|       of the parent window's messages.                                       |
|									       |
|   Arguments:                                                                 |
|       hwnd            window handle for the parent window                    |
|       msg             message number                                         |
|       wParam          message-dependent                                      |
|       lParam          message-dependent                                      |
|                                                                              |
|   Returns:                                                                   |
|       0 if processed, nonzero if ignored                                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
long FAR PASCAL _export AppWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    UINT            f;
    PAINTSTRUCT     ps;
    HDC             hdc;
    HMENU           hmenu;
    HWND            hwndMovie;

    switch (msg) {
        case WM_COMMAND:
            hwndMovie = mdiActiveDoc();

	    switch(wParam) {
		case MENU_ABOUT:
                    fDialog(hwnd,ABOUTBOX,(FARPROC)AppAbout);
		    break;

		case MENU_EXIT:
                    PostMessage(hwnd,WM_CLOSE,0,0L);
                    break;

                case MENU_CLOSE:
                    //PostMessage(hwndMdi, WM_MDIDESTROY, (WPARAM)hwndMovie, 0);
                    PostMessage(hwndMovie, WM_CLOSE, 0, 0L);
                    break;

                case MENU_CLOSEALL:
                    mdiSendMessage(hwndMdi,(HWND)-1,WM_CLOSE,0,0);
                    break;

                case MENU_NEW:
                    mdiCreateDoc(aszMCIWndClassName, "Untitled", 0);
                    break;

                case MENU_OPEN:
                    /* prompt user for file to open */
                    ofn.lStructSize = sizeof(OPENFILENAME);
                    ofn.hwndOwner = hwnd;
                    ofn.hInstance = NULL;
                    ofn.lpstrFilter = szOpenFilter;
                    ofn.lpstrCustomFilter = NULL;
                    ofn.nMaxCustFilter = 0;
                    ofn.nFilterIndex = 0;
                    ofn.lpstrFile = achFileName;
                    ofn.nMaxFile = sizeof(achFileName);
                    ofn.lpstrFileTitle = NULL;
                    ofn.nMaxFileTitle = 0;
                    ofn.lpstrInitialDir = NULL;
                    ofn.lpstrTitle = "Open";
		    ofn.Flags =
#ifdef BIDI
		OFN_BIDIDIALOG |
#endif
		    OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
                    ofn.nFileOffset = 0;
                    ofn.nFileExtension = 0;
                    ofn.lpstrDefExt = NULL;
                    ofn.lCustData = 0;
                    ofn.lpfnHook = NULL;
                    ofn.lpTemplateName = NULL;

                    if (GetOpenFileNamePreview(&ofn))
                    {
                        mdiCreateDoc(aszMCIWndClassName, 0,
				(LPARAM)(LPSTR)achFileName);
                    }
                    break;

                case WM_MDITILE:
                case WM_MDICASCADE:
                case WM_MDIICONARRANGE:
                    SendMessage(hwndMdi, (UINT)wParam, 0, 0);
                    break;

                /* Movie Menu */
                case IDM_PLAY:
                    MCIWndPlay(hwndMovie);
                    break;
                case IDM_RPLAY:
                    MCIWndPlayReverse(hwndMovie);
                    break;
                case IDM_STOP:
                    MCIWndStop(hwndMovie);
                    break;
                case IDM_HOME:
                    MCIWndHome(hwndMovie);
                    break;
                case IDM_END:
                    MCIWndEnd(hwndMovie);
                    break;
                case IDM_STEP:
                    MCIWndStep(hwndMovie, 1);
                    break;
                case IDM_RSTEP:
                    MCIWndStep(hwndMovie, -1);
                    break;

		/* Styles POPUP */

#define ISCHECKED() (BOOL)(GetMenuState(GetMenu(hwnd), wParam, 0) & MF_CHECKED)

		case IDM_SRepeat:
		    MCIWndSetRepeat(hwndMovie, !ISCHECKED());
		    break;

		case IDM_SAutosizeWindow:
		    MCIWndChangeStyles(hwndMovie, MCIWNDF_NOAUTOSIZEWINDOW,
			    ISCHECKED() ? MCIWNDF_NOAUTOSIZEWINDOW : 0);
		    break;

		case IDM_SAutosizeMovie:
		    MCIWndChangeStyles(hwndMovie, MCIWNDF_NOAUTOSIZEMOVIE,
			    ISCHECKED() ? MCIWNDF_NOAUTOSIZEMOVIE : 0);
		    break;

		case IDM_SPlaybar:
		    MCIWndChangeStyles(hwndMovie, MCIWNDF_NOPLAYBAR,
			    ISCHECKED() ? MCIWNDF_NOPLAYBAR : 0);
		    break;

		case IDM_SRecord:
		    MCIWndChangeStyles(hwndMovie, MCIWNDF_RECORD,
			    ISCHECKED() ? 0 : MCIWNDF_RECORD);
		    break;

		case IDM_SMenu:
		    MCIWndChangeStyles(hwndMovie, MCIWNDF_NOMENU,
			    ISCHECKED() ? MCIWNDF_NOMENU : 0);
		    break;

		case IDM_SErrorDlg:
		    MCIWndChangeStyles(hwndMovie, MCIWNDF_NOERRORDLG,
			    ISCHECKED() ? MCIWNDF_NOERRORDLG : 0);
		    break;

		case IDM_SShowName:
		    MCIWndChangeStyles(hwndMovie, MCIWNDF_SHOWNAME,
			    ISCHECKED() ? 0 : MCIWNDF_SHOWNAME);
		    break;

		case IDM_SShowMode:
		    MCIWndChangeStyles(hwndMovie, MCIWNDF_SHOWMODE,
			    ISCHECKED() ? 0 : MCIWNDF_SHOWMODE);
		    break;

		case IDM_SShowPos:
		    MCIWndChangeStyles(hwndMovie, MCIWNDF_SHOWPOS,
			    ISCHECKED() ? 0 : MCIWNDF_SHOWPOS);
		    break;

		case IDM_SNotifyMedia:
		    MCIWndChangeStyles(hwndMovie, MCIWNDF_NOTIFYMEDIA,
			    ISCHECKED() ? 0 : MCIWNDF_NOTIFYMEDIA);
		    break;

		case IDM_SNotifyMode:
		    MCIWndChangeStyles(hwndMovie, MCIWNDF_NOTIFYMODE,
			    ISCHECKED() ? 0 : MCIWNDF_NOTIFYMODE);
		    break;

		case IDM_SNotifyPos:
		    MCIWndChangeStyles(hwndMovie, MCIWNDF_NOTIFYPOS,
			    ISCHECKED() ? 0 : MCIWNDF_NOTIFYPOS);
		    break;

		case IDM_SNotifySize:
		    MCIWndChangeStyles(hwndMovie, MCIWNDF_NOTIFYSIZE,
			    ISCHECKED() ? 0 : MCIWNDF_NOTIFYSIZE);
		    break;

                default:
                    mdiSendMessage(hwndMdi,NULL,msg,wParam,lParam);
                    break;
	    }
            break;

        case WM_PALETTECHANGED:
            mdiSendMessage(hwndMdi, (HWND)-1, msg, wParam, lParam);
            break;

        case WM_QUERYNEWPALETTE:
            return mdiSendMessage(hwndMdi, NULL, msg, wParam, lParam);

        case WM_INITMENUPOPUP:
            hwndMovie = mdiActiveDoc();

	    //
	    // Check the styles properly when styles is chosen
	    // !!! Make sure position constants don't change!
	    //
  	    hmenu = GetSubMenu(GetSubMenu(GetMenu(hwnd), 1), 10);
	    if (((HMENU)wParam == hmenu) && hwndMovie) {
		WORD  wStyles = MCIWndGetStyles(hwndMovie);

		CheckMenuItem(hmenu, IDM_SRepeat,
		    MCIWndGetRepeat(hwndMovie) ? MF_CHECKED : MF_UNCHECKED);
		CheckMenuItem(hmenu, IDM_SAutosizeWindow,
		    (wStyles & MCIWNDF_NOAUTOSIZEWINDOW) ? MF_UNCHECKED :
			MF_CHECKED);
		CheckMenuItem(hmenu, IDM_SAutosizeMovie,
		    (wStyles & MCIWNDF_NOAUTOSIZEMOVIE) ? MF_UNCHECKED :
			MF_CHECKED);
		CheckMenuItem(hmenu, IDM_SPlaybar,
		    (wStyles & MCIWNDF_NOPLAYBAR) ? MF_UNCHECKED : MF_CHECKED);
		CheckMenuItem(hmenu, IDM_SRecord,
		    (wStyles & MCIWNDF_RECORD) ? MF_CHECKED :MF_UNCHECKED);
		CheckMenuItem(hmenu, IDM_SMenu,
		    (wStyles & MCIWNDF_NOMENU) ? MF_UNCHECKED :MF_CHECKED);
		CheckMenuItem(hmenu, IDM_SErrorDlg,
		    (wStyles & MCIWNDF_NOERRORDLG) ? MF_UNCHECKED :MF_CHECKED);
		CheckMenuItem(hmenu, IDM_SShowName,
		    (wStyles & MCIWNDF_SHOWNAME) ? MF_CHECKED :MF_UNCHECKED);
		CheckMenuItem(hmenu, IDM_SShowMode,
		    (wStyles & MCIWNDF_SHOWMODE) ? MF_CHECKED :MF_UNCHECKED);
		CheckMenuItem(hmenu, IDM_SShowPos,
		    (wStyles & MCIWNDF_SHOWPOS) ? MF_CHECKED :MF_UNCHECKED);
		CheckMenuItem(hmenu, IDM_SNotifyMedia,
		    (wStyles & MCIWNDF_NOTIFYMEDIA) ? MF_CHECKED :MF_UNCHECKED);
		CheckMenuItem(hmenu, IDM_SNotifyMode,
		    (wStyles & MCIWNDF_NOTIFYMODE) ? MF_CHECKED :MF_UNCHECKED);
		CheckMenuItem(hmenu, IDM_SNotifyPos,
		    (wStyles & MCIWNDF_NOTIFYPOS) ? MF_CHECKED :MF_UNCHECKED);
		CheckMenuItem(hmenu, IDM_SNotifySize,
		    (wStyles & MCIWNDF_NOTIFYSIZE) ? MF_CHECKED :MF_UNCHECKED);
	    }

	    //
	    // Enable/Disable the stuff under the MOVIE popup
	    // !!! Make sure position constants don't change!
	    //
	    if ((HMENU)wParam == GetSubMenu(GetMenu(hwnd), 1)) {

                EnableMenuItem((HMENU)wParam, 10,
		    MF_BYPOSITION | (hwndMovie ? MF_ENABLED : MF_GRAYED));
		
                if (!hwndMovie || MCIWndGetMode(hwndMovie, NULL, 0) ==
		    	    MCI_MODE_NOT_READY) {
		    f = hwndMovie ? MF_ENABLED : MF_GRAYED;
                    EnableMenuItem((HMENU)wParam, MENU_CLOSE, f);
                    EnableMenuItem((HMENU)wParam, MENU_CLOSEALL, f);

                    EnableMenuItem((HMENU)wParam, IDM_STOP, MF_GRAYED);
                    EnableMenuItem((HMENU)wParam, IDM_PLAY, MF_GRAYED);
                    EnableMenuItem((HMENU)wParam, IDM_RPLAY, MF_GRAYED);
                    EnableMenuItem((HMENU)wParam, IDM_HOME, MF_GRAYED);
                    EnableMenuItem((HMENU)wParam, IDM_END, MF_GRAYED);
                    EnableMenuItem((HMENU)wParam, IDM_STEP, MF_GRAYED);
                    EnableMenuItem((HMENU)wParam, IDM_RSTEP, MF_GRAYED);
                } else {
                   EnableMenuItem((HMENU)wParam, MENU_CLOSE, MF_ENABLED);
                   EnableMenuItem((HMENU)wParam, MENU_CLOSEALL, MF_ENABLED);
   
                   f = MCIWndGetMode(hwndMovie, NULL, 0) != MCI_MODE_STOP;
                   EnableMenuItem((HMENU)wParam, IDM_PLAY,
				!f ? MF_ENABLED : MF_GRAYED);
                   EnableMenuItem((HMENU)wParam, IDM_RPLAY,
				!f ? MF_ENABLED : MF_GRAYED);
                   EnableMenuItem((HMENU)wParam, IDM_STOP,
				 f ? MF_ENABLED : MF_GRAYED);
                   EnableMenuItem((HMENU)wParam, IDM_HOME, MF_ENABLED);
                   EnableMenuItem((HMENU)wParam, IDM_END,  MF_ENABLED);
                   EnableMenuItem((HMENU)wParam, IDM_STEP, MF_ENABLED);
                   EnableMenuItem((HMENU)wParam, IDM_RSTEP,MF_ENABLED);
               }
	    }

            return mdiSendMessage(hwndMdi, NULL, msg, wParam, lParam);
            break;

       case WM_CREATE:
            hmenu = GetMenu(hwnd);
            hwndMdi = mdiCreateClient(hwnd, GetSubMenu(hmenu, GetMenuItemCount(hmenu)-1));
            break;

       case WM_SIZE:
            MoveWindow(hwndMdi,0,0,LOWORD(lParam),HIWORD(lParam),TRUE);
            break;

       case WM_DESTROY:
	    hwndApp = NULL;
	    PostQuitMessage(0);
	    break;

       case WM_PAINT:
            hdc = BeginPaint(hwnd, &ps);
            EndPaint(hwnd, &ps);
            return 0;
    }
    return DefFrameProc(hwnd,hwndMdi,msg,wParam,lParam);
}

/*----------------------------------------------------------------------------*\
|   ErrMsg - Opens a Message box with a error message in it.  The user can     |
|	     select the OK button to continue or the CANCEL button to kill     |
|	     the parent application.					       |
\*----------------------------------------------------------------------------*/
int ErrMsg (LPSTR sz,...)
{
    char ach[128];
    wvsprintf(ach,sz,(LPSTR)(&sz+1));   /* Format the string */
    MessageBox (NULL,ach,NULL,
#ifdef BIDI
		MB_RTL_READING |
#endif
    MB_OK|MB_ICONEXCLAMATION);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd.16\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description: math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//  Description:
//
//  History:
//       9/21/93    cjp     [curtisp] 
//       9/23/93    stl     [toddla]
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32

#ifdef __cplusplus
extern "C"
{
#endif

extern LONG  FAR PASCAL MulDiv32(LONG  a,LONG  b,LONG  c);
extern DWORD FAR PASCAL MulDivRN(DWORD a,DWORD b,DWORD c);
extern DWORD FAR PASCAL MulDivRD(DWORD a,DWORD b,DWORD c);
extern DWORD FAR PASCAL MulDivRU(DWORD a,DWORD b,DWORD c);

#if defined(WIN32) || defined(_WIN32)
    // GDI32s MulDiv is the same as MulDivRN
    #define MulDivRN(a,b,c)   (DWORD)MulDiv((LONG)(a),(LONG)(b),(LONG)(c))
#endif

//
//  some code references these by other names.
//
#define muldiv32    MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#ifdef __cplusplus
}
#endif
#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd.16\mciwnd.h ===
/*----------------------------------------------------------------------------*\
 *
 *  MCIWnd
 *
 *    MCIWnd window class header file.
 *
 *    the MCIWnd window class is a window class for controling MCI devices
 *    MCI devices include, wave files, midi files, AVI Video, cd audio,
 *    vcr, video disc, and others..
 *
 *    to learn more about MCI and mci command sets see the
 *    "Microsoft Multimedia Programmers's guide" in the Win31 SDK
 *
 *    the easiest use of the MCIWnd class is like so:
 *
 *          hwnd = MCIWndCreate(hwndParent, hInstance, 0, "chimes.wav");
 *          ...
 *          MCIWndPlay(hwnd);
 *          MCIWndStop(hwnd);
 *          MCIWndPause(hwnd);
 *          ....
 *          MCIWndDestroy(hwnd);
 *
 *    this will create a window with a play/pause, stop and a playbar
 *    and start the wave file playing.
 *
 *    mciwnd.h defines macros for all the most common MCI commands, but
 *    any string command can be used if needed.
 *
 *    Note: unlike the mciSendString() API, no alias or file name needs
 *    to be specifed, since the device to use is implied by the window handle.
 *
 *          MCIWndSendString(hwnd, "setaudio stream to 2");
 *
 *    (C) Copyright Microsoft Corp. 1991, 1992, 1993.  All rights reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files.
 *
 *    If you did not get this from Microsoft Sources, then it may not be the
 *    most current version.  This sample code in particular will be updated
 *    and include more documentation.
 *
 *    Sources are:
 *       CompuServe: WINSDK forum, MDK section.
 *       Anonymous FTP from ftp.uu.net vendor\microsoft\multimedia
 *
 *----------------------------------------------------------------------------*/

#ifndef INC_MCIWND
#define INC_MCIWND

#ifdef __cplusplus
// MFC Redefines SendMessage, so make sure we get the global one....
#define MCIWndSM ::SendMessage  /* SendMessage in C++*/
#else
#define MCIWndSM SendMessage    /* SendMessage in C */
#endif  /* __cplusplus */

#ifdef __cplusplus
extern "C" {
#endif

#define MCIWND_WINDOW_CLASS "MCIWndClass"

HWND FAR _cdecl _loadds MCIWndCreate(HWND hwndParent, HINSTANCE hInstance,
		      DWORD dwStyle,LPSTR szFile);
BOOL FAR _cdecl _loadds MCIWndRegisterClass();

// Flags for the MCIWndOpen command
#define MCIWNDOPENF_NEW	            0x0001  // open a new file

// window styles
#define MCIWNDF_NOAUTOSIZEWINDOW    0x0001  // when movie size changes
#define MCIWNDF_NOPLAYBAR           0x0002  // no toolbar
#define MCIWNDF_NOAUTOSIZEMOVIE     0x0004  // when window size changes
#define MCIWNDF_NOMENU              0x0008  // no popup menu from RBUTTONDOWN
#define MCIWNDF_SHOWNAME            0x0010  // show name in caption
#define MCIWNDF_SHOWPOS             0x0020  // show position in caption
#define MCIWNDF_SHOWMODE            0x0040  // show mode in caption
#define MCIWNDF_SHOWALL             0x0070  // show all

#define MCIWNDF_NOTIFYMODE          0x0100  // tell parent of mode change
#define MCIWNDF_NOTIFYPOS           0x0200  // tell parent of pos change
#define MCIWNDF_NOTIFYSIZE          0x0400  // tell parent of size change
#define MCIWNDF_NOTIFYMEDIA         0x0800  // tell parent of media change
#define MCIWNDF_NOTIFYERROR         0x1000  // tell parent of an error
#define MCIWNDF_NOTIFYALL           0x1F00  // tell all

#define MCIWNDF_RECORD              0x2000  // Give a record button
#define MCIWNDF_NOERRORDLG          0x4000  // Show Error Dlgs for MCI cmds?
#define MCIWNDF_NOOPEN		    0x8000  // Don't allow user to open things

// can macros
#define MCIWndCanPlay(hwnd)         (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_PLAY,0,0)
#define MCIWndCanRecord(hwnd)       (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_RECORD,0,0)
#define MCIWndCanSave(hwnd)         (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_SAVE,0,0)
#define MCIWndCanWindow(hwnd)       (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_WINDOW,0,0)
#define MCIWndCanEject(hwnd)        (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_EJECT,0,0)
#define MCIWndCanConfig(hwnd)       (BOOL)MCIWndSM(hwnd,MCIWNDM_CAN_CONFIG,0,0)
#define MCIWndPaletteKick(hwnd)     (BOOL)MCIWndSM(hwnd,MCIWNDM_PALETTEKICK,0,0)

#define MCIWndSave(hwnd, szFile)    (LONG)MCIWndSM(hwnd, MCI_SAVE, 0, (LPARAM)(LPVOID)(szFile))
#define MCIWndSaveDialog(hwnd)      MCIWndSave(hwnd, -1)

// if you dont give a device it will use the current device....
#define MCIWndNew(hwnd, lp)         (LONG)MCIWndSM(hwnd, MCIWNDM_NEW, 0, (LPARAM)(LPVOID)(lp))

#define MCIWndRecord(hwnd)          (LONG)MCIWndSM(hwnd, MCI_RECORD, 0, 0)
#define MCIWndOpen(hwnd, sz, f)     (LONG)MCIWndSM(hwnd, MCI_OPEN, (WPARAM)(UINT)(f),(LPARAM)(LPVOID)(sz))
#define MCIWndOpenDialog(hwnd)      MCIWndOpen(hwnd, -1, 0)
#define MCIWndClose(hwnd)           (LONG)MCIWndSM(hwnd, MCI_CLOSE, 0, 0)
#define MCIWndPlay(hwnd)            (LONG)MCIWndSM(hwnd, MCI_PLAY, 0, 0)
#define MCIWndStop(hwnd)            (LONG)MCIWndSM(hwnd, MCI_STOP, 0, 0)
#define MCIWndPause(hwnd)           (LONG)MCIWndSM(hwnd, MCI_PAUSE, 0, 0)
#define MCIWndResume(hwnd)          (LONG)MCIWndSM(hwnd, MCI_RESUME, 0, 0)
#define MCIWndSeek(hwnd, lPos)      (LONG)MCIWndSM(hwnd, MCI_SEEK, 0, (LPARAM)(LONG)(lPos))
#define MCIWndEject(hwnd)           (LONG)MCIWndSM(hwnd, MCIWNDM_EJECT, 0, 0)

#define MCIWndHome(hwnd)            MCIWndSeek(hwnd, MCIWND_START)
#define MCIWndEnd(hwnd)             MCIWndSeek(hwnd, MCIWND_END)

#define MCIWndGetSource(hwnd, prc)  (LONG)MCIWndSM(hwnd, MCIWNDM_GET_SOURCE, 0, (LPARAM)(LPRECT)(prc))
#define MCIWndPutSource(hwnd, prc)  (LONG)MCIWndSM(hwnd, MCIWNDM_PUT_SOURCE, 0, (LPARAM)(LPRECT)(prc))

#define MCIWndGetDest(hwnd, prc)    (LONG)MCIWndSM(hwnd, MCIWNDM_GET_DEST, 0, (LPARAM)(LPRECT)(prc))
#define MCIWndPutDest(hwnd, prc)    (LONG)MCIWndSM(hwnd, MCIWNDM_PUT_DEST, 0, (LPARAM)(LPRECT)(prc))

#define MCIWndPlayReverse(hwnd)     (LONG)MCIWndSM(hwnd, MCIWNDM_PLAYREVERSE, 0, 0)
#define MCIWndPlayFrom(hwnd, lPos)  (LONG)MCIWndSM(hwnd, MCIWNDM_PLAYFROM, 0, (LPARAM)(LONG)(lPos))
#define MCIWndPlayTo(hwnd, lPos)    (LONG)MCIWndSM(hwnd, MCIWNDM_PLAYTO,   0, (LPARAM)(LONG)(lPos))
#define MCIWndPlayFromTo(hwnd, lStart, lEnd) (MCIWndSeek(hwnd, lStart), MCIWndPlayTo(hwnd, lEnd))

#define MCIWndGetDeviceID(hwnd)     (UINT)MCIWndSM(hwnd, MCIWNDM_GETDEVICEID, 0, 0)
#define MCIWndGetAlias(hwnd)        (UINT)MCIWndSM(hwnd, MCIWNDM_GETALIAS, 0, 0)
#define MCIWndGetMode(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETMODE, (WPARAM)(UINT)(len), (LPARAM)(LPSTR)(lp))
#define MCIWndGetPosition(hwnd)     (LONG)MCIWndSM(hwnd, MCIWNDM_GETPOSITION, 0, 0)
#define MCIWndGetPositionString(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETPOSITION, (WPARAM)(UINT)(len), (LPARAM)(LPSTR)(lp))
#define MCIWndGetStart(hwnd)        (LONG)MCIWndSM(hwnd, MCIWNDM_GETSTART, 0, 0)
#define MCIWndGetLength(hwnd)       (LONG)MCIWndSM(hwnd, MCIWNDM_GETLENGTH, 0, 0)
#define MCIWndGetEnd(hwnd)          (LONG)MCIWndSM(hwnd, MCIWNDM_GETEND, 0, 0)

#define MCIWndStep(hwnd, n)         (LONG)MCIWndSM(hwnd, MCI_STEP, 0,(LPARAM)(long)(n))

#define MCIWndDestroy(hwnd)         (VOID)MCIWndSM(hwnd, WM_CLOSE, 0, 0)
#define MCIWndSetZoom(hwnd,iZoom)   (VOID)MCIWndSM(hwnd, MCIWNDM_SETZOOM, 0, (LPARAM)(UINT)(iZoom))
#define MCIWndGetZoom(hwnd)         (UINT)MCIWndSM(hwnd, MCIWNDM_GETZOOM, 0, 0)
#define MCIWndSetVolume(hwnd,iVol)  (LONG)MCIWndSM(hwnd, MCIWNDM_SETVOLUME, 0, (LPARAM)(UINT)(iVol))
#define MCIWndGetVolume(hwnd)       (LONG)MCIWndSM(hwnd, MCIWNDM_GETVOLUME, 0, 0)
#define MCIWndSetSpeed(hwnd,iSpeed) (LONG)MCIWndSM(hwnd, MCIWNDM_SETSPEED, 0, (LPARAM)(UINT)(iSpeed))
#define MCIWndGetSpeed(hwnd)        (LONG)MCIWndSM(hwnd, MCIWNDM_GETSPEED, 0, 0)
#define MCIWndSetTimeFormat(hwnd, lp) (LONG)MCIWndSM(hwnd, MCIWNDM_SETTIMEFORMAT, 0, (LPARAM)(LPSTR)(lp))
#define MCIWndGetTimeFormat(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETTIMEFORMAT, (WPARAM)(UINT)(len), (LPARAM)(LPSTR)(lp))
#define MCIWndValidateMedia(hwnd)   (VOID)MCIWndSM(hwnd, MCIWNDM_VALIDATEMEDIA, 0, 0)

#define MCIWndSetRepeat(hwnd,f)     (void)MCIWndSM(hwnd, MCIWNDM_SETREPEAT, 0, (LPARAM)(BOOL)(f))
#define MCIWndGetRepeat(hwnd)       (BOOL)MCIWndSM(hwnd, MCIWNDM_GETREPEAT, 0, 0)

#define MCIWndUseFrames(hwnd)       MCIWndSetTimeFormat(hwnd, "frames")
#define MCIWndUseTime(hwnd)         MCIWndSetTimeFormat(hwnd, "ms")

#define MCIWndSetActiveTimer(hwnd, active)				\
	(VOID)MCIWndSM(hwnd, MCIWNDM_SETACTIVETIMER,			\
	(WPARAM)(UINT)(active), 0L)
#define MCIWndSetInactiveTimer(hwnd, inactive)				\
	(VOID)MCIWndSM(hwnd, MCIWNDM_SETINACTIVETIMER,		\
	(WPARAM)(UINT)(inactive), 0L)
#define MCIWndSetTimers(hwnd, active, inactive)				      \
	    (VOID)MCIWndSM(hwnd, MCIWNDM_SETTIMERS,(WPARAM)(UINT)(active), \
	    (LPARAM)(UINT)(inactive))
#define MCIWndGetActiveTimer(hwnd)					\
	(UINT)MCIWndSM(hwnd, MCIWNDM_GETACTIVETIMER,	0, 0L);
#define MCIWndGetInactiveTimer(hwnd)					\
	(UINT)MCIWndSM(hwnd, MCIWNDM_GETINACTIVETIMER, 0, 0L);

#define MCIWndRealize(hwnd, fBkgnd) (LONG)MCIWndSM(hwnd, MCIWNDM_REALIZE,(WPARAM)(BOOL)(fBkgnd),0)

#define MCIWndSendString(hwnd, sz)  (LONG)MCIWndSM(hwnd, MCIWNDM_SENDSTRING, 0, (LPARAM)(LPSTR)(sz))
#define MCIWndReturnString(hwnd, lp, len)  (LONG)MCIWndSM(hwnd, MCIWNDM_RETURNSTRING, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))
#define MCIWndGetError(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETERROR, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))

//#define MCIWndActivate(hwnd, f)     (void)MCIWndSM(hwnd, WM_ACTIVATE, (WPARAM)(BOOL)(f), 0)

#define MCIWndGetPalette(hwnd)      (HPALETTE)MCIWndSM(hwnd, MCIWNDM_GETPALETTE, 0, 0)
#define MCIWndSetPalette(hwnd, hpal) (LONG)MCIWndSM(hwnd, MCIWNDM_SETPALETTE, (WPARAM)(HPALETTE)(hpal), 0)

#define MCIWndGetFileName(hwnd, lp, len) (LONG)MCIWndSM(hwnd, MCIWNDM_GETFILENAME, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))
#define MCIWndGetDevice(hwnd, lp, len)   (LONG)MCIWndSM(hwnd, MCIWNDM_GETDEVICE, (WPARAM)(UINT)(len), (LPARAM)(LPVOID)(lp))

#define MCIWndGetStyles(hwnd) (UINT)MCIWndSM(hwnd, MCIWNDM_GETSTYLES, 0, 0L)
#define MCIWndChangeStyles(hwnd, mask, value) (LONG)MCIWndSM(hwnd, MCIWNDM_CHANGESTYLES, (WPARAM)(UINT)(mask), (LPARAM)(LONG)(value))

#define MCIWndOpenInterface(hwnd, pUnk)  (LONG)MCIWndSM(hwnd, MCIWNDM_OPENINTERFACE, 0, (LPARAM)(LPUNKNOWN)(pUnk))

#define MCIWndSetOwner(hwnd, hwndP)  (LONG)MCIWndSM(hwnd, MCIWNDM_SETOWNER, (WPARAM)(hwndP), 0)

// Messages an app will send to MCIWND

#define MCIWNDM_GETDEVICEID	(WM_USER + 100)
#define MCIWNDM_SENDSTRING	(WM_USER + 101)
#define MCIWNDM_GETPOSITION	(WM_USER + 102)
#define MCIWNDM_GETSTART	(WM_USER + 103)
#define MCIWNDM_GETLENGTH	(WM_USER + 104)
#define MCIWNDM_GETEND		(WM_USER + 105)
#define MCIWNDM_GETMODE		(WM_USER + 106)
#define MCIWNDM_EJECT		(WM_USER + 107)
#define MCIWNDM_SETZOOM		(WM_USER + 108)
#define MCIWNDM_GETZOOM         (WM_USER + 109)
#define MCIWNDM_SETVOLUME	(WM_USER + 110)
#define MCIWNDM_GETVOLUME	(WM_USER + 111)
#define MCIWNDM_SETSPEED	(WM_USER + 112)
#define MCIWNDM_GETSPEED	(WM_USER + 113)
#define MCIWNDM_SETREPEAT	(WM_USER + 114)
#define MCIWNDM_GETREPEAT	(WM_USER + 115)
#define MCIWNDM_REALIZE         (WM_USER + 118)
#define MCIWNDM_SETTIMEFORMAT   (WM_USER + 119)
#define MCIWNDM_GETTIMEFORMAT   (WM_USER + 120)
#define MCIWNDM_VALIDATEMEDIA   (WM_USER + 121)
#define MCIWNDM_PLAYFROM	(WM_USER + 122)
#define MCIWNDM_PLAYTO          (WM_USER + 123)
#define MCIWNDM_GETFILENAME     (WM_USER + 124)
#define MCIWNDM_GETDEVICE       (WM_USER + 125)
#define MCIWNDM_GETPALETTE      (WM_USER + 126)
#define MCIWNDM_SETPALETTE      (WM_USER + 127)
#define MCIWNDM_GETERROR        (WM_USER + 128)
#define MCIWNDM_SETTIMERS	(WM_USER + 129)
#define MCIWNDM_SETACTIVETIMER	(WM_USER + 130)
#define MCIWNDM_SETINACTIVETIMER (WM_USER + 131)
#define MCIWNDM_GETACTIVETIMER	(WM_USER + 132)
#define MCIWNDM_GETINACTIVETIMER (WM_USER + 133)
#define MCIWNDM_NEW		(WM_USER + 134)
#define MCIWNDM_CHANGESTYLES	(WM_USER + 135)
#define MCIWNDM_GETSTYLES	(WM_USER + 136)
#define MCIWNDM_GETALIAS	(WM_USER + 137)
#define MCIWNDM_RETURNSTRING	(WM_USER + 138)
#define MCIWNDM_PLAYREVERSE	(WM_USER + 139)
#define MCIWNDM_GET_SOURCE      (WM_USER + 140)
#define MCIWNDM_PUT_SOURCE      (WM_USER + 141)
#define MCIWNDM_GET_DEST        (WM_USER + 142)
#define MCIWNDM_PUT_DEST        (WM_USER + 143)
#define MCIWNDM_CAN_PLAY        (WM_USER + 144)
#define MCIWNDM_CAN_WINDOW      (WM_USER + 145)
#define MCIWNDM_CAN_RECORD      (WM_USER + 146)
#define MCIWNDM_CAN_SAVE        (WM_USER + 147)
#define MCIWNDM_CAN_EJECT       (WM_USER + 148)
#define MCIWNDM_CAN_CONFIG      (WM_USER + 149)
#define MCIWNDM_PALETTEKICK     (WM_USER + 150)
#define MCIWNDM_OPENINTERFACE	(WM_USER + 151)
#define MCIWNDM_SETOWNER	(WM_USER + 152)

// Messages MCIWND will send to an app
// !!! Use less messages and use a code instead to indicate the type of notify?
#define MCIWNDM_NOTIFYMODE      (WM_USER + 200)  // wp = hwnd, lp = mode
#define MCIWNDM_NOTIFYPOS	(WM_USER + 201)  // wp = hwnd, lp = pos
#define MCIWNDM_NOTIFYSIZE	(WM_USER + 202)  // wp = hwnd
#define MCIWNDM_NOTIFYMEDIA     (WM_USER + 203)  // wp = hwnd, lp = fn
#define MCIWNDM_NOTIFYERROR     (WM_USER + 205)  // wp = hwnd, lp = error

// special seek values for START and END
#define MCIWND_START                -1
#define MCIWND_END                  -2

#ifndef MCI_PLAY
    /* MCI command message identifiers */
    #define MCI_OPEN                        0x0803
    #define MCI_CLOSE                       0x0804
    #define MCI_PLAY                        0x0806
    #define MCI_SEEK                        0x0807
    #define MCI_STOP                        0x0808
    #define MCI_PAUSE                       0x0809
    #define MCI_STEP                        0x080E
    #define MCI_RECORD                      0x080F
    #define MCI_SAVE                        0x0813
    #define MCI_CUT                         0x0851
    #define MCI_COPY                        0x0852
    #define MCI_PASTE                       0x0853
    #define MCI_RESUME                      0x0855
    #define MCI_DELETE                      0x0856
#endif

#ifndef MCI_MODE_NOT_READY
    /* return values for 'status mode' command */
    #define MCI_MODE_NOT_READY      (524)
    #define MCI_MODE_STOP           (525)
    #define MCI_MODE_PLAY           (526)
    #define MCI_MODE_RECORD         (527)
    #define MCI_MODE_SEEK           (528)
    #define MCI_MODE_PAUSE          (529)
    #define MCI_MODE_OPEN           (530)
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd.16\muldiv32.asm ===
page    ,132
;---------------------------Module-Header-------------------------------;
; Module Name: MATH.ASM
;
; Contains FIXED point math routines.
;
; Created:  Sun 30-Aug-1987 19:28:30
; Author: Charles Whitmer [chuckwh]
;
; Copyright (c) 1987  Microsoft Corporation
;-----------------------------------------------------------------------;

?WIN	= 0
?PLM	= 1
?NODATA = 0

        .286

        .xlist
        include cmacros.inc
        include windows.inc
        .list

        externA __WinFlags

UQUAD   struc
uq0     dw      ?
uq1     dw      ?
uq2     dw      ?
uq3     dw      ?
UQUAD	ends

;       The following two equates are just used as shorthand
;       for the "word ptr" and "byte ptr" overrides.

wptr    equ     word ptr
bptr    equ     byte ptr

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

EAXtoDXAX   macro
        shld    edx,eax,16      ; move HIWORD(eax) to dx
        endm

DXAXtoEAX   macro
        ror     eax,16          ; xchg HIWORD(eax) and LOWORD(eax)
        shrd    eax,edx,16      ; move LOWORD(edx) to HIWORD(eax)
        endm

neg32       macro hi, lo
        neg lo
        adc hi,0                ; carry set unless lo zero
        neg hi
        endm

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes cs,CodeSeg
	assumes ds,nothing
        assumes es,nothing

;---------------------------Public-Routine------------------------------;
; long muldiv32(long, long, long)
;
; multiples two 32 bit values and then divides the result by a third
; 32 bit value with full 64 bit presision
;
; lResult = (lNumber * lNumerator) / lDenominator with correct rounding
;
; Entry:
;       lNumber = number to multiply by nNumerator
;       lNumerator = number to multiply by nNumber
;       lDenominator = number to divide the multiplication result by.
;   
; Returns:
;       DX:AX = result of multiplication and division.
;
; Error Returns:
;       none
; Registers Preserved:
;       DS,ES,SI,DI
; History:
;   Fri 05-Oct-1990 -by- Rob Williams [Robwi] 
;   Behavior consistent with MulDiv16 routine (signed, no int 0 on overflow)
;   Stole muldiv16 psuedocode
;
;   Wed 14-June-1990 -by-  Todd Laney [ToddLa]
;   converted it to 386/286 code. (by checking __WinFlags)
;
;   Tue 08-May-1990 -by-  Rob Williams [Robwi]
;   Wrote it.
;
;----------------------------Pseudo-Code--------------------------------;
; long FAR PASCAL muldiv32(long, long, long)
; long l;
; long Numer;
; long Denom;
; {
;
;   Sign = sign of Denom;   // Sign will keep track of final sign //
;
;
;   if (Denom < 0)
;   {
;	negate Denom;	// make sure Denom is positive //
;   }
;
;   if (l < 0)
;   {
;	negate l;	// make sure l is positive //
;   }
;
;   make Sign reflect any sign change;
;
;
;   if (Numer < 0)
;   {
;	negate Numer;	// make sure Numer is positive //
;   }
;
;   make Sign reflect any sign change;
;
;   Numer *= l;
;   Numer += (Denom/2); // adjust for rounding //
;
;   if (overflow)   // check for overflow, and handle divide by zero //
;   {
;	jump to md5;
;   }
;
;   result = Numer/Denom;
;
;   if (overflow)   // check again to see if overflow occured //
;   {
;	jump to md5;
;   }
;
;   if (Sign is negative)   // put sign on the result //
;   {
;	negate result;
;   }
;
;md6:
;   return(result);
;
;md5:
;   DX = 7FFF;	    // indicate overflow by //
;   AX = 0xFFFF     // return largest integer //
;   if (Sign is negative)
;   {
;	DX = 0x8000;	// with correct sign //
;	AX = 0x0000;	
;   }
;
;   jump to md6;
; }
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   muldiv32,<PUBLIC,FAR,NODATA,NONWIN>,<>
;       ParmD  lNumber
;       ParmD  lNumerator
;       ParmD  lDenominator
cBegin	<nogen>
	mov	ax,__WinFlags
        test    ax,WF_CPU286+WF_CPU086+WF_CPU186
        jz      md32_1
        jmp     NEAR PTR muldiv32_286
md32_1:
        errn$   muldiv32_386
cEnd    <nogen>

cProc   muldiv32_386,<PUBLIC,FAR,NODATA,NONWIN>,<>
        ParmD   lNumber
        ParmD   lNumerator
        ParmD   lDenominator
cBegin
        .386


        mov     ebx,lDenominator    ; get the demoninator
        mov     ecx,ebx	            ; ECX holds the final sign in hiword
        or      ebx,ebx             ; ensure the denominator is positive
        jns     md386_1
        neg     ebx

md386_1:
        mov     eax,lNumber         ; get the long we are multiplying
        xor     ecx,eax	            ; make ECX reflect any sign change
        or      eax,eax             ; ensure the long is positive
        jns     md386_2
        neg     eax

md386_2:
        mov     edx,lNumerator      ; get the numerator
        xor     ecx,edx	            ; make ECX reflect any sign change
        or      edx,edx             ; ensure the numerator is positive
        jns     md386_3
        neg     edx

md386_3:
        mul     edx                 ; multiply
        mov     cx,bx               ; get half of the demoninator to adjust for rounding
        sar     ebx,1               
        add     eax,ebx             ; adjust for possible rounding error
        adc     edx,0               ; this is really a long addition
        sal     ebx,1               ; restore the demoninator
        or      bx,cx               ; fix bottom bit
        cmp     edx,ebx             ; check for overflow
        jae     md386_5                 ; (ae handles /0 case)
        div     ebx                 ; divide
        or      eax,eax             ; If sign is set, then overflow occured
        js      md386_5                 ; Overflow.
        or      ecx,ecx             ; put the sign on the result
        jns     md386_6
        neg     eax

md386_6:
        EAXtoDXAX                   ; convert eax to dx:ax for 16 bit programs

        .286
cEnd 
        .386

md386_5:
        mov     eax,7FFFFFFFh       ; return the largest integer
        or      ecx,ecx             ; with the correct sign
        jns     md386_6
        not     eax
        jmp     md386_6

        .286

cProc   muldiv32_286,<PUBLIC,FAR,NODATA,NONWIN>,<di,si>
        ParmD  lNumber             
        ParmD  lNumerator
        ParmD  lDenominator
        LocalW wSign

cBegin

        mov     dx,lDenominator.hi      ; get the demoninator
        mov     si,dx	                ; SI holds the final sign 
        or      dx,dx                   ; ensure the denominator is positive
        jns     md286_1
        neg32   dx, lDenominator.lo
        mov     lDenominator.hi, dx


md286_1:
        mov     ax,lNumber.lo           ; get the long we are multiplying
        mov     dx,lNumber.hi           
        xor     si,dx	                ; make ECX reflect any sign change
        or      dx,dx                   ; ensure the long is positive
        jns     md286_2
        neg32   dx, ax

md286_2:
        mov     bx,lNumerator.lo        ; get the numerator
        mov     cx,lNumerator.hi        ; get the numerator
        xor     si,cx	                ; make ECX reflect any sign change
        or      cx,cx                   ; ensure the numerator is positive
        jns     md286_3
        neg32   cx, bx

md286_3:
        mov     wSign, si               ; save sign
        call    dmul                    ; multiply (result in dx:cx:bx:ax)
        mov     si, lDenominator.hi
        mov     di, lDenominator.lo
        sar     si, 1                   ; get half of the demoninator 
        rcr     di, 1                   ; to adjust for rounding
        add     ax, di                  ; adjust for possible rounding error
        adc     bx, si
        adc     cx, 0
        adc     dx, 0                   ; this is really a long addition

        sal     di, 1                   ; restore the demoninator
        rcl     si, 1

        or      di, lDenominator.lo     ; fix bottom bit

        cmp     dx, si                  ; begin overflow check (unsigned for div 0 check)
        ja      md286_5                 ; overflow
        jb      md286_7                 ; no overflow
        cmp     cx, di       
        jae     md286_5                 ; overflow

md286_7:
        call    qdiv                    ; DX:AX is quotient     
        or      dx,dx                   ; If sign is set, then overflow occured
        js      md286_5                 ; Overflow.
        mov     cx, wSign
        or      cx,cx                   ; put the sign on the result
        jns     md286_6
        neg32   dx,ax

md286_6:

cEnd

md286_5:
        mov     cx, wSign
        mov     ax, 0FFFFh              ; return the largest integer
        mov     dx, 7FFFh
        or      cx, cx                  ; with the correct sign
        jns     md286_6
        not     dx
        not     ax
        jmp     md286_6

cProc   muldivru32,<PUBLIC,FAR,NODATA,NONWIN>,<>
;       ParmD  lNumber
;       ParmD  lNumerator
;       ParmD  lDenominator
cBegin	<nogen>
	mov	ax,__WinFlags
        test    ax,WF_CPU286+WF_CPU086+WF_CPU186
        jz      mdru32_1
        jmp     NEAR PTR muldivru32_286
mdru32_1:
        errn$   muldivru32_386
cEnd    <nogen>

cProc   muldivru32_386,<PUBLIC,FAR,NODATA,NONWIN>,<>
        ParmD   lNumber
        ParmD   lNumerator
        ParmD   lDenominator
cBegin
        .386


        mov     ebx,lDenominator    ; get the demoninator
        mov     ecx,ebx	            ; ECX holds the final sign in hiword
        or      ebx,ebx             ; ensure the denominator is positive
        jns     mdru386_1
        neg     ebx

mdru386_1:
        mov     eax,lNumber         ; get the long we are multiplying
        xor     ecx,eax	            ; make ECX reflect any sign change
        or      eax,eax             ; ensure the long is positive
        jns     mdru386_2
        neg     eax

mdru386_2:
        mov     edx,lNumerator      ; get the numerator
        xor     ecx,edx	            ; make ECX reflect any sign change
        or      edx,edx             ; ensure the numerator is positive
        jns     mdru386_3
        neg     edx

mdru386_3:
        mul     edx                 ; multiply
        mov     cx,bx               ; get demoninator - 1 to adjust for rounding
        sub     ebx,1               
        add     eax,ebx             ; adjust for possible rounding error
        adc     edx,0               ; this is really a long addition
        add     ebx,1               ; restore the demoninator
        cmp     edx,ebx             ; check for overflow
        jae     mdru386_5                 ; (ae handles /0 case)
        div     ebx                 ; divide
        or      eax,eax             ; If sign is set, then overflow occured
        js      mdru386_5                 ; Overflow.
        or      ecx,ecx             ; put the sign on the result
        jns     mdru386_6
        neg     eax

mdru386_6:
        EAXtoDXAX                   ; convert eax to dx:ax for 16 bit programs

        .286
cEnd 
        .386

mdru386_5:
        mov     eax,7FFFFFFFh       ; return the largest integer
        or      ecx,ecx             ; with the correct sign
        jns     mdru386_6
        not     eax
        jmp     mdru386_6

        .286

cProc   muldivru32_286,<PUBLIC,FAR,NODATA,NONWIN>,<di,si>
        ParmD  lNumber             
        ParmD  lNumerator
        ParmD  lDenominator
        LocalW wSign

cBegin

        mov     dx,lDenominator.hi      ; get the demoninator
        mov     si,dx	                ; SI holds the final sign 
        or      dx,dx                   ; ensure the denominator is positive
        jns     mdru286_1
        neg32   dx, lDenominator.lo
        mov     lDenominator.hi, dx


mdru286_1:
        mov     ax,lNumber.lo           ; get the long we are multiplying
        mov     dx,lNumber.hi           
        xor     si,dx	                ; make ECX reflect any sign change
        or      dx,dx                   ; ensure the long is positive
        jns     mdru286_2
        neg32   dx, ax

mdru286_2:
        mov     bx,lNumerator.lo        ; get the numerator
        mov     cx,lNumerator.hi        ; get the numerator
        xor     si,cx	                ; make ECX reflect any sign change
        or      cx,cx                   ; ensure the numerator is positive
        jns     mdru286_3
        neg32   cx, bx

mdru286_3:
        mov     wSign, si               ; save sign
        call    dmul                    ; multiply (result in dx:cx:bx:ax)
        mov     si, lDenominator.hi
        mov     di, lDenominator.lo
        sub     di, 1                   ; get demoninator - 1 
        sbb     si, 0                   ; to adjust for rounding
        add     ax, di                  ; adjust for possible rounding error
        adc     bx, si
        adc     cx, 0
        adc     dx, 0                   ; this is really a long addition

        add	di, 1                   ; restore the demoninator
        adc     si, 0

        cmp     dx, si                  ; begin overflow check (unsigned for div 0 check)
        ja      mdru286_5                 ; overflow
        jb      mdru286_7                 ; no overflow
        cmp     cx, di       
        jae     mdru286_5                 ; overflow

mdru286_7:
        call    qdiv                    ; DX:AX is quotient     
        or      dx,dx                   ; If sign is set, then overflow occured
        js      mdru286_5                 ; Overflow.
        mov     cx, wSign
        or      cx,cx                   ; put the sign on the result
        jns     mdru286_6
        neg32   dx,ax

mdru286_6:

cEnd

mdru286_5:
        mov     cx, wSign
        mov     ax, 0FFFFh              ; return the largest integer
        mov     dx, 7FFFh
        or      cx, cx                  ; with the correct sign
        jns     mdru286_6
        not     dx
        not     ax
        jmp     mdru286_6

cProc   muldivrd32,<PUBLIC,FAR,NODATA,NONWIN>,<>
;       ParmD  lNumber
;       ParmD  lNumerator
;       ParmD  lDenominator
cBegin	<nogen>
	mov	ax,__WinFlags
        test    ax,WF_CPU286+WF_CPU086+WF_CPU186
        jz      mdrd32_1
        jmp     NEAR PTR muldivrd32_286
mdrd32_1:
        errn$   muldivrd32_386
cEnd    <nogen>

cProc   muldivrd32_386,<PUBLIC,FAR,NODATA,NONWIN>,<>
        ParmD   lNumber
        ParmD   lNumerator
        ParmD   lDenominator
cBegin
        .386


        mov     ebx,lDenominator    ; get the demoninator
        mov     ecx,ebx	            ; ECX holds the final sign in hiword
        or      ebx,ebx             ; ensure the denominator is positive
        jns     mdrd386_1
        neg     ebx

mdrd386_1:
        mov     eax,lNumber         ; get the long we are multiplying
        xor     ecx,eax	            ; make ECX reflect any sign change
        or      eax,eax             ; ensure the long is positive
        jns     mdrd386_2
        neg     eax

mdrd386_2:
        mov     edx,lNumerator      ; get the numerator
        xor     ecx,edx	            ; make ECX reflect any sign change
        or      edx,edx             ; ensure the numerator is positive
        jns     mdrd386_3
        neg     edx

mdrd386_3:
        mul     edx                 ; multiply

        div     ebx                 ; divide
        or      eax,eax             ; If sign is set, then overflow occured
        js      mdrd386_5                 ; Overflow.
        or      ecx,ecx             ; put the sign on the result
        jns     mdrd386_6
        neg     eax

mdrd386_6:
        EAXtoDXAX                   ; convert eax to dx:ax for 16 bit programs

        .286
cEnd 
        .386

mdrd386_5:
        mov     eax,7FFFFFFFh       ; return the largest integer
        or      ecx,ecx             ; with the correct sign
        jns     mdrd386_6
        not     eax
        jmp     mdrd386_6

        .286

cProc   muldivrd32_286,<PUBLIC,FAR,NODATA,NONWIN>,<di,si>
        ParmD  lNumber             
        ParmD  lNumerator
        ParmD  lDenominator
        LocalW wSign

cBegin

        mov     dx,lDenominator.hi      ; get the demoninator
        mov     si,dx	                ; SI holds the final sign 
        or      dx,dx                   ; ensure the denominator is positive
        jns     mdrd286_1
        neg32   dx, lDenominator.lo
        mov     lDenominator.hi, dx


mdrd286_1:
        mov     ax,lNumber.lo           ; get the long we are multiplying
        mov     dx,lNumber.hi           
        xor     si,dx	                ; make ECX reflect any sign change
        or      dx,dx                   ; ensure the long is positive
        jns     mdrd286_2
        neg32   dx, ax

mdrd286_2:
        mov     bx,lNumerator.lo        ; get the numerator
        mov     cx,lNumerator.hi        ; get the numerator
        xor     si,cx	                ; make ECX reflect any sign change
        or      cx,cx                   ; ensure the numerator is positive
        jns     mdrd286_3
        neg32   cx, bx

mdrd286_3:
        mov     wSign, si               ; save sign
        call    dmul                    ; multiply (result in dx:cx:bx:ax)
        mov     si, lDenominator.hi
        mov     di, lDenominator.lo

        cmp     dx, si                  ; begin overflow check (unsigned for div 0 check)
        ja      mdrd286_5                 ; overflow
        jb      mdrd286_7                 ; no overflow
        cmp     cx, di       
        jae     mdrd286_5                 ; overflow

mdrd286_7:
        call    qdiv                    ; DX:AX is quotient     
        or      dx,dx                   ; If sign is set, then overflow occured
        js      mdrd286_5                 ; Overflow.
        mov     cx, wSign
        or      cx,cx                   ; put the sign on the result
        jns     mdrd286_6
        neg32   dx,ax

mdrd286_6:

cEnd

mdrd286_5:
        mov     cx, wSign
        mov     ax, 0FFFFh              ; return the largest integer
        mov     dx, 7FFFh
        or      cx, cx                  ; with the correct sign
        jns     mdrd286_6
        not     dx
        not     ax
        jmp     mdrd286_6


;---------------------------Public-Routine------------------------------;
; idmul
;
; This is an extended precision multiply routine, intended to emulate
; 80386 imul instruction.
;
; Entry:
;       DX:AX = LONG
;       CX:BX = LONG
; Returns:
;       DX:CX:BX:AX = QUAD product
; Registers Destroyed:
;       none
; History:
;  Tue 26-Jan-1988 23:47:02  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   idmul,<PUBLIC,NEAR>,<si,di>
        localQ  qTemp
cBegin

; put one argument in safe registers

        mov     si,dx
        mov     di,ax

; do the low order unsigned product

        mul     bx
        mov     qTemp.uq0,ax
        mov     qTemp.uq1,dx

; do the high order signed product

        mov     ax,si
        imul    cx
        mov     qTemp.uq2,ax
        mov     qTemp.uq3,dx

; do a mixed product

        mov     ax,si
        cwd
        and     dx,bx
        sub     qTemp.uq2,dx            ; adjust for sign bit
        sbb     qTemp.uq3,0
        mul     bx
        add     qTemp.uq1,ax
        adc     qTemp.uq2,dx
        adc     qTemp.uq3,0

; do the other mixed product

        mov     ax,cx
        cwd
	and	dx,di
        sub     qTemp.uq2,dx
        sbb     qTemp.uq3,0
        mul     di

; pick up the answer

        mov     bx,ax
        mov     cx,dx
        xor     dx,dx

        mov     ax,qTemp.uq0
        add     bx,qTemp.uq1
        adc     cx,qTemp.uq2
        adc     dx,qTemp.uq3
cEnd

;---------------------------Public-Routine------------------------------;
; dmul
;
; This is an extended precision multiply routine, intended to emulate
; 80386 mul instruction.
;
; Entry:
;       DX:AX = LONG
;       CX:BX = LONG
; Returns:
;       DX:CX:BX:AX = QUAD product
; Registers Destroyed:
;       none
; History:
;  Tue 02-Feb-1988 10:50:44  -by-  Charles Whitmer [chuckwh]
; Copied from idmul and modified.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   dmul,<PUBLIC,NEAR>,<si,di>
        localQ  qTemp
cBegin

; put one argument in safe registers

        mov     si,dx
        mov     di,ax

; do the low order product

        mul     bx
        mov     qTemp.uq0,ax
        mov     qTemp.uq1,dx

; do the high order product

        mov     ax,si
        mul     cx
        mov     qTemp.uq2,ax
        mov     qTemp.uq3,dx

; do a mixed product

        mov     ax,si
        mul     bx
        add     qTemp.uq1,ax
        adc     qTemp.uq2,dx
        adc     qTemp.uq3,0

; do the other mixed product

        mov     ax,cx
        mul     di

; pick up the answer

        mov     bx,ax
        mov     cx,dx
        xor     dx,dx
        mov     ax,qTemp.uq0
        add     bx,qTemp.uq1
        adc     cx,qTemp.uq2
        adc     dx,qTemp.uq3
cEnd

;---------------------------Public-Routine------------------------------;
; iqdiv
;
; This is an extended precision divide routine which is intended to
; emulate the 80386 64 bit/32 bit IDIV instruction.  We don't have the
; 32 bit registers to work with, but we pack the arguments and results
; into what registers we do have.  We will divide two signed numbers
; and return the quotient and remainder.  We will do INT 0 for overflow,
; just like the 80386 microcode.  This should ease conversion later.
;
; This routine just keeps track of the signs and calls qdiv to do the
; real work.
;
; Entry:
;       DX:CX:BX:AX = QUAD Numerator
;       SI:DI       = LONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder
; Registers Destroyed:
;       DI,SI
; History:
;  Tue 26-Jan-1988 02:49:19  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;

WIMP    equ     1

IQDIV_RESULT_SIGN       equ     1
IQDIV_REM_SIGN          equ     2

        assumes ds,nothing
        assumes es,nothing

cProc   iqdiv,<PUBLIC,NEAR>
        localB  flags
cBegin
        mov     flags,0

; take the absolute value of the denominator

        or      si,si
        jns     denominator_is_cool
        xor     flags,IQDIV_RESULT_SIGN
        neg     di
        adc     si,0
        neg     si
denominator_is_cool:

; take the absolute value of the denominator

        or      dx,dx
        jns     numerator_is_cool
        xor     flags,IQDIV_RESULT_SIGN + IQDIV_REM_SIGN
        not     ax
        not     bx
        not     cx
        not     dx
        add     ax,1
        adc     bx,0
        adc     cx,0
        adc     dx,0
numerator_is_cool:

; do the unsigned division

        call    qdiv
ifdef WIMP
        jo      iqdiv_exit
endif

; check for overflow

        or      dx,dx
        jns     have_a_bit_to_spare
ifdef WIMP
        mov     ax,8000h
        dec     ah
        jmp     short iqdiv_exit
else
        int     0                       ; You're toast, Jack!
endif
have_a_bit_to_spare:

; negate the result, if required

        test    flags,IQDIV_RESULT_SIGN
        jz      result_is_done
        neg     ax
        adc     dx,0
        neg     dx
result_is_done:

; negate the remainder, if required

        test    flags,IQDIV_REM_SIGN
        jz      remainder_is_done
        neg     bx
        adc     cx,0
        neg     cx
remainder_is_done:
iqdiv_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; qdiv
;
; This is an extended precision divide routine which is intended to
; emulate the 80386 64 bit/32 bit DIV instruction.  We don't have the
; 32 bit registers to work with, but we pack the arguments and results
; into what registers we do have.  We will divide two unsigned numbers
; and return the quotient and remainder.  We will do INT 0 for overflow,
; just like the 80386 microcode.  This should ease conversion later.
;
; Entry:
;       DX:CX:BX:AX = UQUAD Numerator
;       SI:DI       = ULONG Denominator
; Returns:
;       DX:AX = quotient
;       CX:BX = remainder
; Registers Destroyed:
;       none
; History:
;  Tue 26-Jan-1988 00:02:09  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   qdiv,<PUBLIC,NEAR>,<si,di>
        localQ  uqNumerator
        localD  ulDenominator
        localD  ulQuotient
        localW  cShift
cBegin

; stuff the quad word into local memory

        mov     uqNumerator.uq0,ax
        mov     uqNumerator.uq1,bx
        mov     uqNumerator.uq2,cx
        mov     uqNumerator.uq3,dx


; check for overflow

qdiv_restart:
        cmp     si,dx
        ja      qdiv_no_overflow
        jb      qdiv_overflow
        cmp     di,cx
        ja      qdiv_no_overflow
qdiv_overflow:
ifdef WIMP
        mov     ax,8000h
        dec     ah
        jmp     qdiv_exit
else
        int     0                       ; You're toast, Jack!
        jmp     qdiv_restart
endif
qdiv_no_overflow:

; check for a zero Numerator

        or      ax,bx
        or      ax,cx
        or      ax,dx
        jz      qdiv_exit_relay         ; quotient = remainder = 0

; handle the special case when the denominator lives in the low word

        or      si,si
        jnz     not_that_special

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=0):DI

        cmp     di,1                    ; separate out the trivial case
        jz      div_by_one
        xchg    dx,cx                   ; CX = remainder.hi = 0
        mov     ax,bx
        div     di
        mov     bx,ax                   ; BX = quotient.hi
        mov     ax,uqNumerator.uq0
        div     di                      ; AX = quotient.lo
        xchg    bx,dx                   ; DX = quotient.hi, BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit_relay:
        jmp     qdiv_exit

; calculate (DX=0):(CX=0):BX:uqNumerator.uq0 / (SI=0):(DI=1)

div_by_one:
        xchg    dx,bx                   ; DX = quotient.hi, BX = remainder.lo = 0
        mov     ax,uqNumerator.uq0      ; AX = quotient.lo
        jmp     qdiv_exit
not_that_special:

; handle the special case when the denominator lives in the high word

        or      di,di
        jnz     not_this_special_either

; calculate DX:CX:BX:uqNumerator.uq0 / SI:(DI=0)

        cmp     si,1                    ; separate out the trivial case
        jz      div_by_10000h
        mov     ax,cx
        div     si
        mov     cx,ax                   ; CX = quotient.hi
        mov     ax,bx
        div     si                      ; AX = quotient.lo
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
ifdef WIMP
        or      ax,ax           ; clear OF
endif
        jmp     qdiv_exit

; calculate (DX=0):CX:BX:uqNumerator.uq0 / (SI=1):(DI=0)

div_by_10000h:
        xchg    cx,dx                   ; DX = quotient.hi, CX = remainder.hi = 0
        mov     ax,bx                   ; AX = quotient.lo
        mov     bx,uqNumerator.uq0      ; BX = remainder.lo
        jmp     qdiv_exit
not_this_special_either:

; normalize the denominator

        mov     dx,si
        mov     ax,di
        call    ulNormalize             ; DX:AX = normalized denominator
        mov     cShift,cx               ; CX < 16
        mov     ulDenominator.lo,ax
        mov     ulDenominator.hi,dx


; shift the Numerator by the same amount

        jcxz    numerator_is_shifted
        mov     si,-1
        shl     si,cl
        not     si                      ; SI = mask
        mov     bx,uqNumerator.uq3
        shl     bx,cl
        mov     ax,uqNumerator.uq2
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq3,bx
        xor     ax,di
        mov     bx,uqNumerator.uq1
        rol     bx,cl
        mov     di,si
        and     di,bx
        or      ax,di
        mov     uqNumerator.uq2,ax
        xor     bx,di
        mov     ax,uqNumerator.uq0
        rol     ax,cl
        mov     di,si
        and     di,ax
        or      bx,di
        mov     uqNumerator.uq1,bx
        xor     ax,di
        mov     uqNumerator.uq0,ax
numerator_is_shifted:

; set up registers for division

        mov     dx,uqNumerator.uq3
        mov     ax,uqNumerator.uq2
        mov     di,uqNumerator.uq1
        mov     cx,ulDenominator.hi
        mov     bx,ulDenominator.lo

; check for case when Denominator has only 16 bits

        or      bx,bx
        jnz     must_do_long_division
        div     cx
        mov     si,ax
        mov     ax,uqNumerator.uq1
        div     cx
        xchg    si,dx                   ; DX:AX = quotient
        mov     di,uqNumerator.uq0      ; SI:DI = remainder (shifted)
        jmp     short unshift_remainder
must_do_long_division:

; do the long division, part IZ@NL@%

        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      first_division_is_safe
        mov     ulQuotient.hi,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short first_adjuster
first_division_is_safe:
        div     cx
        mov     ulQuotient.hi,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     first_adjuster_done     ; The remainder is UNSIGNED!  We have
first_adjuster:                         ; to use the carry flag to keep track
        dec     ulQuotient.hi           ; of the sign.  The adjuster loop
        add     di,bx                   ; watches for a change to the carry
        adc     si,cx                   ; flag which would indicate a sign
        jnc     first_adjuster          ; change IF we had more bits to keep
first_adjuster_done:                    ; a sign in.

; do the long division, part II

        mov     dx,si
        mov     ax,di
        mov     di,uqNumerator.uq0
        cmp     dx,cx                   ; we only know that DX:AX < CX:BX!
        jb      second_division_is_safe
        mov     ulQuotient.lo,0         ; i.e. 10000h, our guess is too big
        mov     si,ax
        sub     si,bx                   ; ... remainder is negative
        jmp     short second_adjuster
second_division_is_safe:
        div     cx
        mov     ulQuotient.lo,ax
        mov     si,dx
        mul     bx                      ; fix remainder for low order term
        sub     di,ax
        sbb     si,dx
        jnc     second_adjuster_done
second_adjuster:
        dec     ulQuotient.lo
        add     di,bx
        adc     si,cx
        jnc     second_adjuster
second_adjuster_done:
        mov     ax,ulQuotient.lo
        mov     dx,ulQuotient.hi

; unshift the remainder in SI:DI

unshift_remainder:
        mov     cx,cShift
        jcxz    remainder_unshifted
        mov     bx,-1
        shr     bx,cl
        not     bx
        shr     di,cl
        ror     si,cl
        and     bx,si
        or      di,bx
        xor     si,bx
remainder_unshifted:
        mov     cx,si
        mov     bx,di
ifdef WIMP
        or      ax,ax           ; clear OF
endif
qdiv_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; ulNormalize
;
; Normalizes a ULONG so that the highest order bit is 1.  Returns the
; number of shifts done.  Also returns ZF=1 if the ULONG was zero.
;
; Entry:
;       DX:AX = ULONG
; Returns:
;       DX:AX = normalized ULONG
;       CX    = shift count
;       ZF    = 1 if the ULONG is zero, 0 otherwise
; Registers Destroyed:
;       none
; History:
;  Mon 25-Jan-1988 22:07:03  -by-  Charles Whitmer [chuckwh]
; Wrote it.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   ulNormalize,<PUBLIC,NEAR>
cBegin

; shift by words

        xor     cx,cx
        or      dx,dx
        js      ulNormalize_exit
        jnz     top_word_ok
        xchg    ax,dx
        or      dx,dx
        jz      ulNormalize_exit        ; the zero exit
        mov     cl,16
        js      ulNormalize_exit
top_word_ok:

; shift by bytes

        or      dh,dh
        jnz     top_byte_ok
        xchg    dh,dl
        xchg    dl,ah
        xchg    ah,al
        add     cl,8
        or      dh,dh
        js      ulNormalize_exit
top_byte_ok:

; do the rest by bits

        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
        js      ulNormalize_exit
        inc     cx
        add     ax,ax
        adc     dx,dx
ulNormalize_exit:
cEnd

sEnd   CodeSeg

       end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd.16\preview.h ===
/****************************************************************************
 *
 *  MODULE  : PREVIEW.H
 *
 ****************************************************************************/

#ifdef OFN_READONLY
    BOOL  FAR PASCAL _loadds GetOpenFileNamePreview(LPOPENFILENAME lpofn);
    BOOL  FAR PASCAL _loadds GetSaveFileNamePreview(LPOPENFILENAME lpofn);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd.16\muldiv32.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1993, 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  muldiv32.c
//
//  Description: math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//  History:
//       9/21/93    cjp     [curtisp] 
//       9/23/93    stl     [toddla]
//
//==========================================================================;

#include <windows.h>
#include "muldiv32.h"

#if !defined(WIN32) && !defined(_WIN32)

#pragma warning(disable:4035 4704)

#define ASM66 _asm _emit 0x66 _asm
#define DB    _asm _emit

#define EAX_TO_DXAX \
    DB      0x66    \
    DB      0x0F    \
    DB      0xA4    \
    DB      0xC2    \
    DB      0x10

//--------------------------------------------------------------------------;
//  
//  LONG MulDiv32(a,b,c)    = (a * b) / c
//  
//--------------------------------------------------------------------------;

LONG FAR PASCAL MulDiv32(LONG a,LONG b,LONG c)
{
    ASM66   mov     ax,word ptr a   //  mov  eax, a
    ASM66   mov     bx,word ptr b   //  mov  ebx, b
    ASM66   mov     cx,word ptr c   //  mov  ecx, c
    ASM66   imul    bx              //  imul ebx
    ASM66   idiv    cx              //  idiv ecx
    EAX_TO_DXAX

} // MulDiv32()

//--------------------------------------------------------------------------;
//  
//  DWORD MulDivRN(a,b,c)   = (a * b + c/2) / c
//  
//--------------------------------------------------------------------------;

DWORD FAR PASCAL MulDivRN(DWORD a,DWORD b,DWORD c)
{
    ASM66   mov     ax,word ptr a   //  mov  eax, a
    ASM66   mov     bx,word ptr b   //  mov  ebx, b
    ASM66   mov     cx,word ptr c   //  mov  ecx, c
    ASM66   mul     bx              //  mul  ebx
    ASM66   mov     bx,cx           //  mov  ebx,ecx
    ASM66   shr     bx,1            //  sar  ebx,1
    ASM66   add     ax,bx           //  add  eax,ebx
    ASM66   adc     dx,0            //  adc  edx,0
    ASM66   div     cx              //  div  ecx
    EAX_TO_DXAX

} // MulDiv32()

//--------------------------------------------------------------------------;
//  
//  DWORD MulDivRU(a,b,c)   = (a * b + c-1) / c
//  
//--------------------------------------------------------------------------;

DWORD FAR PASCAL MulDivRU(DWORD a,DWORD b,DWORD c)
{
    ASM66   mov     ax,word ptr a   //  mov  eax, a
    ASM66   mov     bx,word ptr b   //  mov  ebx, b
    ASM66   mov     cx,word ptr c   //  mov  ecx, c
    ASM66   mul     bx              //  mul  ebx
    ASM66   mov     bx,cx           //  mov  ebx,ecx
    ASM66   dec     bx              //  dec  ebx
    ASM66   add     ax,bx           //  add  eax,ebx
    ASM66   adc     dx,0            //  adc  edx,0
    ASM66   div     cx              //  div  ecx
    EAX_TO_DXAX

} // MulDivRU32()

//--------------------------------------------------------------------------;
//  
//  DWORD MulDivRD(a,b,c)   = (a * b) / c
//  
//--------------------------------------------------------------------------;

DWORD FAR PASCAL MulDivRD(DWORD a,DWORD b,DWORD c)
{
    ASM66   mov     ax,word ptr a   //  mov  eax, a
    ASM66   mov     bx,word ptr b   //  mov  ebx, b
    ASM66   mov     cx,word ptr c   //  mov  ecx, c
    ASM66   mul     bx              //  mul  ebx
    ASM66   div     cx              //  div  ecx
    EAX_TO_DXAX

} // MulDivRD32()

#pragma warning(default:4035 4704)

#else   // WIN32

#include <largeint.h>

//--------------------------------------------------------------------------;
//  
//  LONG MulDiv32(a,b,c)    = (a * b) / c
//  
//--------------------------------------------------------------------------;

LONG FAR PASCAL MulDiv32(LONG a,LONG b,LONG c)
{
    LARGE_INTEGER lRemain;

    return LargeIntegerDivide(
        EnlargedIntegerMultiply(a,b),
        ConvertLongToLargeInteger(c),
        &lRemain).LowPart;

} // MulDiv32()

//--------------------------------------------------------------------------;
//  
//  DWORD MulDivRD(a,b,c)   = (a * b) / c
//  
//--------------------------------------------------------------------------;

DWORD FAR PASCAL MulDivRD(DWORD a,DWORD b,DWORD c)
{
    return ExtendedLargeIntegerDivide(
        EnlargedUnsignedMultiply(a,b), c, &a).LowPart;

} // MulDivRD()

//--------------------------------------------------------------------------;
//  
//  DWORD MulDivRU(a,b,c)   = (a * b + c-1) / c
//  
//--------------------------------------------------------------------------;

DWORD FAR PASCAL MulDivRU(DWORD a,DWORD b,DWORD c)
{
    return ExtendedLargeIntegerDivide(
        LargeIntegerAdd(
            EnlargedUnsignedMultiply(a,b),
            ConvertUlongToLargeInteger(c-1)),
        c,&a).LowPart;

} // MulDivRU()

#if 0 // we use Win32 GDI MulDiv function, not this.
//--------------------------------------------------------------------------;
//  
//  DWORD MulDivRN(a,b,c)   = (a * b + c/2) / c
//  
//--------------------------------------------------------------------------;

DWORD FAR PASCAL MulDivRN(DWORD a,DWORD b,DWORD c)
{
    return ExtendedLargeIntegerDivide(
        LargeIntegerAdd(
            EnlargedUnsignedMultiply(a,b),
            ConvertUlongToLargeInteger(c/2)),
        c,&a).LowPart;

} // MulDivRN()

#endif

#endif  // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd.16\preview.c ===
/****************************************************************************
 *
 *  MODULE  : PREVIEW.C
 *
 ****************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <commdlg.h>
#include "preview.h"
#include "mciwnd.h"

typedef struct {
    HWND        hwnd;               // common dialog handle.
    LPOPENFILENAME pofn;

    LPARAM      lCustData;          // hold old value
    DWORD       Flags;
    UINT        (CALLBACK *lpfnHook)(HWND, UINT, WPARAM, LPARAM);

    RECT        rcPreview;
    RECT        rcImage;
    RECT        rcText;
    HWND        hwndMci;
    HFONT       hfont;
    HPALETTE    hpal;
    HANDLE      hdib;
    char        Title[128];

}   PreviewStuff, FAR *PPreviewStuff;

#define PREVIEW_PROP    "PreviewStuff"

#ifdef WIN32
    #define SetPreviewStuff(hwnd, p) SetProp(hwnd,PREVIEW_PROP,(LPVOID)(p))
    #define GetPreviewStuff(hwnd) (PPreviewStuff)(LPVOID)GetProp(hwnd, PREVIEW_PROP)
    #define RemovePreviewStuff(hwnd) RemoveProp(hwnd,PREVIEW_PROP)
#else
    #define SetPreviewStuff(hwnd, p) SetProp(hwnd,PREVIEW_PROP,HIWORD(p))
    #define GetPreviewStuff(hwnd) (PPreviewStuff)MAKELONG(0, GetProp(hwnd, PREVIEW_PROP))
    #define RemovePreviewStuff(hwnd) RemoveProp(hwnd,PREVIEW_PROP)
#endif

/***************************************************************************
 *
 ****************************************************************************/

static BOOL   PreviewOpen (HWND hwnd, LPOPENFILENAME pofn);
static BOOL   PreviewFile (PPreviewStuff p, LPSTR szFile);
static BOOL   PreviewPaint(PPreviewStuff p);
static BOOL   PreviewSize (PPreviewStuff p);
static BOOL   PreviewClose(PPreviewStuff p);

static HANDLE GetRiffDisp(LPSTR lpszFile, LPSTR szText, int iLen);

/***************************************************************************
 *
 ****************************************************************************/

static BOOL PreviewOpen(HWND hwnd, LPOPENFILENAME pofn)
{
    LOGFONT lf;
    PPreviewStuff p;
    RECT rc;

    p = (LPVOID)pofn->lCustData;
    pofn->lCustData = p->lCustData;

    SetPreviewStuff(hwnd, p);

    p->hwnd = hwnd;
    p->pofn = pofn;

    //
    // create a MCI window for preview.
    //
    p->hwndMci = MCIWndCreate(p->hwnd, NULL,
//          MCIWNDF_NOAUTOSIZEWINDOW    |
//          MCIWNDF_NOPLAYBAR           |
//          MCIWNDF_NOAUTOSIZEMOVIE     |
            MCIWNDF_NOMENU              |
//          MCIWNDF_SHOWNAME            |
//          MCIWNDF_SHOWPOS             |
//          MCIWNDF_SHOWMODE            |
//          MCIWNDF_RECORD              |
            MCIWNDF_NOERRORDLG          |
            WS_CHILD | WS_BORDER,
            NULL);

    //
    // locate the preview in the lower corner of the dialog (below the
    // cancel button)
    //
    GetClientRect(hwnd, &p->rcPreview);
    GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rc);
    ScreenToClient(hwnd, (LPPOINT)&rc);
    ScreenToClient(hwnd, (LPPOINT)&rc+1);

// The open space we're allowed to use in the dialog is different in NT and on
// Win31.  Under NT there is a network button at the bottom of the dialog on
// the right hand side, so we use the area from just under the CANCEL button to
// a little more than 1 button height from the bottom of the dialog.
// Under Win31, the network button is under CANCEL, so we use the area a little
// over one button height under CANCEL, to just about the bottom of the dialog.
#ifdef WIN32
    if (1)
#else
    if (GetWinFlags() & WF_WINNT)
#endif
    {
	p->rcPreview.top   = rc.bottom + 4;
	p->rcPreview.left  = rc.left;
	p->rcPreview.right = rc.right;
	p->rcPreview.bottom -= (rc.bottom - rc.top) + 12;
    } else {
	p->rcPreview.top   = rc.bottom + (rc.bottom - rc.top) + 12;
	p->rcPreview.left  = rc.left;
	p->rcPreview.right = rc.right;
	p->rcPreview.bottom -= 4;          // leave a little room at the bottom
    }

    //
    // create a font to use.
    //
    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), (LPVOID)&lf, 0);
    p->hfont = CreateFontIndirect(&lf);

    return TRUE;
}

/***************************************************************************
 *
 ****************************************************************************/

static BOOL PreviewClose(PPreviewStuff p)
{
    if (p == NULL)
        return FALSE;

    PreviewFile(p, NULL);

    RemovePreviewStuff(p->hwnd);

    if (p->hfont)
        DeleteObject(p->hfont);

    if (p->hwndMci)
        MCIWndDestroy(p->hwndMci);
}

/***************************************************************************
 *
 ****************************************************************************/

#define SLASH(c)     ((c) == '/' || (c) == '\\')

static LPSTR NiceName(LPSTR szPath)
{
    LPSTR   sz;
    LPSTR   lpsztmp;

    for (sz=szPath; *sz; sz++)
        ;
    for (; sz>szPath && !SLASH(*sz) && *sz!=':'; sz =AnsiPrev(szPath, sz))
        ;
    if(sz>szPath) sz = AnsiNext(sz) ;

    for(lpsztmp = sz; *lpsztmp	&& *lpsztmp != '.'; lpsztmp = AnsiNext(lpsztmp))
	;
    *lpsztmp = '\0';

    AnsiLower(sz);
    AnsiUpperBuff(sz, 1);

    return sz;
}

/***************************************************************************
 *
 ****************************************************************************/

static BOOL PreviewFile(PPreviewStuff p, LPSTR szFile)
{
    if (p == NULL || !p->hwndMci)
        return FALSE;

    p->Title[0] = 0;

    ShowWindow(p->hwndMci, SW_HIDE);
    MCIWndClose(p->hwndMci);

    if (p->hdib)
        GlobalFree(p->hdib);

    if (p->hpal)
        DeleteObject(p->hpal);

    p->hdib = NULL;
    p->hpal = NULL;

    PreviewPaint(p);

    if (szFile == NULL)
        return TRUE;

    if (MCIWndOpen(p->hwndMci, szFile, 0) == 0)
    {
        lstrcpy(p->Title, NiceName(szFile));

        if (MCIWndUseTime(p->hwndMci) == 0)
        {
            LONG len;
            UINT min,sec;

            len = MCIWndGetLength(p->hwndMci);

            if (len > 0)
            {
                #define ONE_HOUR    (60ul*60ul*1000ul)
                #define ONE_MINUTE  (60ul*1000ul)
                #define ONE_SECOND  (1000ul)

                min  = (UINT)(len / ONE_MINUTE) % 60;
                sec  = (UINT)(len / ONE_SECOND) % 60;

                wsprintf(p->Title + lstrlen(p->Title), " (%02d:%02d)", min, sec);
            }
        }
    }

    PreviewSize(p);
    PreviewPaint(p);
    return TRUE;
}

/***************************************************************************
 *
 ****************************************************************************/

static BOOL PreviewSize(PPreviewStuff p)
{
    RECT    rc;
    RECT    rcImage;
    RECT    rcText;
    RECT    rcPreview;
    HDC     hdc;
    int     dx;
    int     dy;
    int     dyPlayBar;

    SetRectEmpty(&p->rcText);
    SetRectEmpty(&p->rcImage);

    //
    // if nothing to do clear it.
    //
    if (p->Title[0] == 0 && p->hdib == NULL)
        return FALSE;

    rcPreview = p->rcPreview;

    //
    // compute the text rect, using DrawText
    //
    hdc = GetDC(p->hwnd);
    SelectObject(hdc, p->hfont);

    rcText = rcPreview;
    rcText.bottom = rcText.top;

    DrawText(hdc, p->Title, -1, &rcText, DT_CALCRECT|DT_LEFT|DT_WORDBREAK);
    ReleaseDC(p->hwnd, hdc);

    //
    // compute the image size
    //
    MCIWndChangeStyles(p->hwndMci, MCIWNDF_NOPLAYBAR, MCIWNDF_NOPLAYBAR);
    GetWindowRect(p->hwndMci, &rc);
    dx = rc.right - rc.left;
    dy = rc.bottom - rc.top;
    MCIWndChangeStyles(p->hwndMci, MCIWNDF_NOPLAYBAR, 0);
    GetWindowRect(p->hwndMci, &rc);
    dyPlayBar = rc.bottom - rc.top - dy;

    rcImage = rcPreview;
    rcImage.bottom -= dyPlayBar;

    //
    //  if wider than preview area scale to fit
    //
    if (dx > rcImage.right - rcImage.left)
    {
        rcImage.bottom = rcImage.top + MulDiv(dy,rcImage.right-rcImage.left,dx);
    }
    //
    //  if x2 will fit then use it
    //
    else if (dx * 2 < rcImage.right - rcImage.left)
    {
        rcImage.right  = rcImage.left + dx*2;
        rcImage.bottom = rcImage.top + dy*2;
    }
    //
    //  else center the image in the preview area
    //
    else
    {
        rcImage.right  = rcImage.left + dx;
        rcImage.bottom = rcImage.top + dy;
    }

    if (rcImage.bottom > rcPreview.bottom - (rcText.bottom - rcText.top) - dyPlayBar)
    {
        rcImage.bottom = rcPreview.bottom - (rcText.bottom - rcText.top) - dyPlayBar;
        rcImage.right  = rcPreview.left + MulDiv(dx,rcImage.bottom-rcImage.top,dy);
        rcImage.left   = rcPreview.left;
    }

    rcImage.bottom += dyPlayBar;

    //
    //  now center
    //
    dx = ((rcPreview.right - rcPreview.left) - (rcText.right - rcText.left))/2;
    OffsetRect(&rcText, dx, 0);

    dx = ((rcPreview.right - rcPreview.left) - (rcImage.right - rcImage.left))/2;
    OffsetRect(&rcImage, dx, 0);

    dy  = rcPreview.bottom - rcPreview.top;
    dy -= rcImage.bottom - rcImage.top;
    dy -= rcText.bottom - rcText.top;

    if (dy < 0)
        dy = 0;
    else
        dy = dy / 2;

    OffsetRect(&rcImage, 0, dy);
    OffsetRect(&rcText, 0, dy + rcImage.bottom - rcImage.top + 2);

    //
    // store RECTs
    //
    p->rcImage = rcImage;
    p->rcText = rcText;

    //
    // position window.
    //
    SetWindowPos(p->hwndMci, NULL, rcImage.left, rcImage.top,
        rcImage.right - rcImage.left, rcImage.bottom - rcImage.top,
        SWP_NOZORDER | SWP_NOACTIVATE);

    ShowWindow(p->hwndMci, SW_SHOW);

    return TRUE;
}


/***************************************************************************
 *
 ****************************************************************************/

static BOOL PreviewPaint(PPreviewStuff p)
{
    HDC     hdc;
    HBRUSH  hbr;
    HWND    hwnd = p->hwnd;

    if (p == NULL)
        return TRUE;

    hdc = GetDC(hwnd);
    hbr = (HBRUSH)DefWindowProc(hwnd, WM_CTLCOLOR, (WPARAM)hdc, MAKELONG(hwnd, CTLCOLOR_DLG));
////FillRect(hdc, &p->rcPreview, hbr);
    FillRect(hdc, &p->rcText, hbr);

    SelectObject(hdc, p->hfont);
    DrawText(hdc, p->Title, -1, &p->rcText, DT_LEFT|DT_WORDBREAK);

    ReleaseDC(hwnd, hdc);
    return TRUE;
}

/***************************************************************************
 *
 ****************************************************************************/

    /* Combo boxes */
#define cmb1        0x0470
#define cmb2        0x0471
    /* Listboxes */
#define lst1        0x0460
#define lst2        0x0461
    /* Edit controls */
#define edt1        0x0480

#define ID_TIMER    1234
#define PREVIEWWAIT 1000

WORD FAR PASCAL _loadds GetFileNamePreviewHook(HWND hwnd, unsigned msg, WORD wParam, LONG lParam)
{
    int i;
    char ach[80];

    PPreviewStuff p;

    p = GetPreviewStuff(hwnd);

    switch (msg) {
        case WM_COMMAND:
            switch (wParam)
            {
                case lst1:
                    if (HIWORD(lParam) == LBN_SELCHANGE)
                    {
                        KillTimer(hwnd, ID_TIMER);
                        SetTimer(hwnd, ID_TIMER, PREVIEWWAIT, NULL);
                    }
                    break;

                case IDOK:
                case IDCANCEL:
                    KillTimer(hwnd, ID_TIMER);
                    PreviewFile(p, NULL);
                    break;

                case cmb1:
                case cmb2:
                case lst2:
                    if (HIWORD(lParam) == LBN_SELCHANGE)
                    {
                        KillTimer(hwnd, ID_TIMER);
                        PreviewFile(p, NULL);
                    }
                    break;
            }
            break;

        case WM_TIMER:
            if (wParam == ID_TIMER)
            {
                KillTimer(hwnd, ID_TIMER);

                ach[0] = 0;
                i = (int)SendDlgItemMessage(hwnd, lst1, LB_GETCURSEL, 0, 0L);
                SendDlgItemMessage(hwnd, lst1, LB_GETTEXT, i, (LONG)(LPSTR)ach);
                PreviewFile(p, ach);
                return TRUE;
            }
            break;

        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            if (p && p->hwndMci)
                SendMessage(p->hwndMci, msg, wParam, lParam);
	    break;

        case WM_PAINT:
            PreviewPaint(p);
            break;

        case WM_INITDIALOG:
            PreviewOpen(hwnd, (LPOPENFILENAME)lParam);

            p = GetPreviewStuff(hwnd);

            if (!(p->Flags & OFN_ENABLEHOOK))
                return TRUE;

            break;

        case WM_DESTROY:
            PreviewClose(p);
            break;
    }

    if (p && (p->Flags & OFN_ENABLEHOOK))
        return p->lpfnHook(hwnd, msg, wParam, lParam);
    else
        return FALSE;
}

/***************************************************************************
 *
 ****************************************************************************/

static BOOL GetFileNamePreview(LPOPENFILENAME lpofn, BOOL fSave)
{
    BOOL f;
    PPreviewStuff p;

//////// Link to COMMDLG
    HINSTANCE h;
    BOOL (WINAPI *GetFileNameProc)(OPENFILENAME FAR*) = NULL;

    if ((h = LoadLibrary("COMMDLG.DLL")) >= HINSTANCE_ERROR)
        (FARPROC)GetFileNameProc = GetProcAddress(h,
		fSave ? "GetSaveFileName" : "GetOpenFileName");

    if (GetFileNameProc == NULL)
        return FALSE;      //!!! what's the right error here?
////////////////

#ifndef OFN_NONETWORKBUTTON
#define OFN_NONETWORKBUTTON 0x00020000
#endif

    // If we have a READ ONLY checkbox, or both HELP and NETWORK, then it's in
    // our way, so get rid of it. (keep NETWORK, lose HELP)

    if (!(lpofn->Flags & OFN_HIDEREADONLY))
	lpofn->Flags |= OFN_HIDEREADONLY;
    if ((lpofn->Flags & OFN_SHOWHELP) && !(lpofn->Flags & OFN_NONETWORKBUTTON))
	lpofn->Flags &= ~OFN_SHOWHELP;

    p = (LPVOID)GlobalAllocPtr(GHND, sizeof(PreviewStuff));

    if (p == NULL)
    {
        f = GetFileNameProc(lpofn);
    }
    else
    {
        p->lpfnHook  = lpofn->lpfnHook;
        p->Flags     = lpofn->Flags;
        p->lCustData = lpofn->lCustData;

        lpofn->lpfnHook = GetFileNamePreviewHook;
        lpofn->Flags |= OFN_ENABLEHOOK;
        lpofn->lCustData = (LPARAM)p;

        f = GetFileNameProc(lpofn);

        lpofn->lpfnHook  = p->lpfnHook;
        lpofn->Flags     = p->Flags;

        GlobalFreePtr(p);
    }

    FreeLibrary(h);     //!!! should we free DLL?
    return f;
}

/**************************************************************************
* @doc EXTERNAL
*
* @api BOOL | GetOpenFileNamePreview | This is just like <f GetOpenFileName>
*   in COMMDLG, but with a preview window so people can see what movie
*   they're opening.
*
* @parm LPOPENFILENAME | lpofn | See the documentation for <f GetOpenFileName>.
*
* @rdesc Returns true if a file was opened.
*
* @xref GetOpenFileName
*
*************************************************************************/
BOOL FAR PASCAL _loadds GetOpenFileNamePreview(LPOPENFILENAME lpofn)
{
    return GetFileNamePreview(lpofn, FALSE);
}

/**************************************************************************
* @doc EXTERNAL
*
* @api BOOL | GetSaveFileNamePreview | This is just like <f GetSaveFileName>
*   in COMMDLG, but with a preview window so people can see what movie
*   they're saving over.
*
* @parm LPOPENFILENAME | lpofn | See the documentation for <f GetSaveFileName>.
*
* @rdesc Returns true if a file was opened.
*
* @xref GetSaveFileName
*
*************************************************************************/
BOOL FAR PASCAL _loadds GetSaveFileNamePreview(LPOPENFILENAME lpofn)
{
    return GetFileNamePreview(lpofn, TRUE);
}

#if 0   ///////////////////// DONT NEED THIS

/****************************************************************************
 *
 ****************************************************************************/

//#define FOURCC_RIFF mmioFOURCC('R','I','F','F')
#define FOURCC_INFO mmioFOURCC('I','N','F','O')
#define FOURCC_DISP mmioFOURCC('D','I','S','P')
#define FOURCC_INAM mmioFOURCC('I','N','A','M')
#define FOURCC_ISBJ mmioFOURCC('I','S','B','J')

#define DibSizeImage(lpbi) (\
    (DWORD)(UINT)((((int)lpbi->biBitCount*(int)lpbi->biWidth+31)&~31)>>3) * \
    (DWORD)(UINT)lpbi->biHeight)

#define DibSize(lpbi) \
    (lpbi->biSize + ((int)lpbi->biClrUsed * sizeof(RGBQUAD)) + lpbi->biSizeImage)

#define DibNumColors(lpbi) \
    (lpbi->biBitCount <= 8 ? (1 << (int)lpbi->biBitCount) : 0)

/****************************************************************************
 *
 *  get both the DISP(CF_DIB) and the DISP(CF_TEXT) info in one pass, this is
 *  much faster than doing multiple passes over the file.
 *
 ****************************************************************************/

static HANDLE GetRiffDisp(LPSTR lpszFile, LPSTR szText, int iLen)
{
    HMMIO       hmmio;
    MMCKINFO    ck;
    MMCKINFO    ckINFO;
    MMCKINFO    ckRIFF;
    HANDLE	h = NULL;
    LONG        lSize;
    DWORD       dw;
    HCURSOR     hcur = NULL;

    if (szText)
        szText[0] = 0;

    /* Open the file */
    hmmio = mmioOpen(lpszFile, NULL, MMIO_ALLOCBUF | MMIO_READ);

    if (hmmio == NULL)
        return NULL;

    mmioSeek(hmmio, 0, SEEK_SET);

    /* descend the input file into the RIFF chunk */
    if (mmioDescend(hmmio, &ckRIFF, NULL, 0) != 0)
        goto error;

    if (ckRIFF.ckid != FOURCC_RIFF)
        goto error;

    while (!mmioDescend(hmmio, &ck, &ckRIFF, 0))
    {
        if (ck.ckid == FOURCC_DISP)
        {
            if (hcur == NULL)
                hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

            /* Read dword into dw, break if read unsuccessful */
            if (mmioRead(hmmio, (LPVOID)&dw, sizeof(dw)) != sizeof(dw))
                goto error;

            /* Find out how much memory to allocate */
            lSize = ck.cksize - sizeof(dw);

            if ((int)dw == CF_DIB && h == NULL)
            {
                /* get a handle to memory to hold the description and lock it down */
                if ((h = GlobalAlloc(GHND, lSize+4)) == NULL)
                    goto error;

                if (mmioRead(hmmio, GlobalLock(h), lSize) != lSize)
                    goto error;
            }
            else if ((int)dw == CF_TEXT && szText[0] == 0)
            {
                if (lSize > iLen-1)
                    lSize = iLen-1;

                szText[lSize] = 0;

                if (mmioRead(hmmio, szText, lSize) != lSize)
                    goto error;
            }
        }
        else if (ck.ckid    == FOURCC_LIST &&
                 ck.fccType == FOURCC_INFO &&
                 szText[0]  == 0)
        {
            while (!mmioDescend(hmmio, &ckINFO, &ck, 0))
            {
                switch (ckINFO.ckid)
                {
                    case FOURCC_INAM:
//                  case FOURCC_ISBJ:

                        lSize = ck.cksize;

                        if (lSize > iLen-1)
                            lSize = iLen-1;

                        szText[lSize] = 0;

                        if (mmioRead(hmmio, szText, lSize) != lSize)
                            goto error;

                        break;
                }

                if (mmioAscend(hmmio, &ckINFO, 0))
                    break;
            }
        }

        //
        // if we have both a picture and a title, then exit.
        //
        if (h != NULL && szText[0] != 0)
            break;

        /* Ascend so that we can descend into next chunk
         */
        if (mmioAscend(hmmio, &ck, 0))
            break;
    }

    goto exit;

error:
    if (h)
        GlobalFree(h);

    h = NULL;
    ckRIFF.fccType = 0;

exit:
    mmioClose(hmmio, 0);

    //
    // verify and correct the DIB
    //
    if (h)
    {
        LPBITMAPINFOHEADER lpbi;

        lpbi = (LPVOID)GlobalLock(h);

        if (lpbi->biSize < sizeof(BITMAPINFOHEADER))
            goto error;

        if (lpbi->biClrUsed == 0)
            lpbi->biClrUsed = DibNumColors(lpbi);

        if (lpbi->biSizeImage == 0)
            lpbi->biSizeImage = DibSizeImage(lpbi);

        if (DibSize(lpbi) > GlobalSize(h))
            goto error;
    }

    if (hcur)
        SetCursor(hcur);

    return h;
}

#endif ///////////////////// DONT NEED THIS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd.16\trackbar.c ===
//----------------------------------------------------------
//
// BUGBUG: make sure this stuff really works with the DWORD
//	   ranges
//
//----------------------------------------------------------

#include "ctlspriv.h"
#include "tracki.h"
#include "muldiv32.h"

#define THUMBSLOP  2
#define TICKHEIGHT 2

#define ABS(X)  (X >= 0) ? X : -X
#define BOUND(x,low,high)   max(min(x, high),low)

char aszTrackbarClassName[] = TRACKBAR_CLASS;

LPARAM FAR CALLBACK _loadds TrackBarWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

//
//  convert a logical scroll-bar position to a physical pixel position
//
static int NEAR PASCAL TBLogToPhys(PTrackBar tb, DWORD dwPos)
{
    if (tb->lLogMax == tb->lLogMin)
	return tb->rc.left;

    return (WORD)MulDiv32(dwPos - tb->lLogMin, tb->iSizePhys - 1,
	tb->lLogMax - tb->lLogMin) + tb->rc.left;
}

static LONG NEAR PASCAL TBPhysToLog(PTrackBar tb, int iPos)
{
    if (tb->iSizePhys <= 1)
	return tb->lLogMin;

    if (iPos <= tb->rc.left)
	return tb->lLogMin;

    if (iPos >= tb->rc.right)
	return tb->lLogMax;

    return MulDiv32(iPos - tb->rc.left, tb->lLogMax - tb->lLogMin,
		    tb->iSizePhys - 1) + tb->lLogMin;
}



/*
	Initialize the trackbar code.
*/

BOOL FAR PASCAL InitTrackBar(HINSTANCE hInstance)
{
    WNDCLASS wc;

    if (!GetClassInfo(hInstance, aszTrackbarClassName, &wc)) {
	// See if we must register a window class
	
	wc.lpszClassName = aszTrackbarClassName;
	wc.lpfnWndProc = (WNDPROC)TrackBarWndProc;
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hIcon = NULL;
	wc.lpszMenuName = NULL;
	wc.hbrBackground = (HBRUSH)(NULL);
	wc.hInstance = hInstance;
	wc.style = CS_GLOBALCLASS | CS_DBLCLKS;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = EXTRA_TB_BYTES;
	
	if (!RegisterClass(&wc))
		return FALSE;
    }
    return TRUE;
}


static void NEAR PASCAL PatRect(HDC hdc,int x,int y,int dx,int dy)
{
    RECT    rc;

    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}

static void NEAR PASCAL DrawTic(PTrackBar tb, int x, int yTic)
{
    SetBkColor(tb->hdc, GetSysColor(COLOR_BTNTEXT));
    PatRect(tb->hdc,(x),yTic,1,TICKHEIGHT);
    SetBkColor(tb->hdc, GetSysColor(COLOR_BTNHIGHLIGHT));
    PatRect(tb->hdc,(x)+1,yTic,1,TICKHEIGHT);
}

/* DrawTics() */
/* There is always a tick at the beginning and end of the bar, but you can */
/* add some more of your own with a TBM_SETTIC message.  This draws them.  */
/* They are kept in an array whose handle is a window word.  The first     */
/* element is the number of extra ticks, and then the positions.           */

static void NEAR PASCAL DrawTics(PTrackBar tb)
{
    PDWORD pTics;
    int    iPos;
    int    yTic;
    int    i;

    yTic = tb->rc.bottom + THUMBSLOP + 1;

// !!! Not for MCIWnd
//    DrawTic(tb, tb->rc.left, yTic);               // first
//    DrawTic(tb, tb->rc.right-1, yTic);            // last

    // those inbetween
    pTics = tb->pTics;
    if (pTics) {
	for (i = 0; i < tb->nTics; ++i) {
	    iPos = TBLogToPhys(tb,pTics[i]);
	    DrawTic(tb, iPos, yTic);
	}
    }

    // draw the selection range (triangles)

    if ((tb->Flags & TBF_SELECTION) && 
        (tb->lSelStart <= tb->lSelEnd) && (tb->lSelEnd >= tb->lLogMin)) {

	SetBkColor(tb->hdc, GetSysColor(COLOR_BTNTEXT));

	iPos = TBLogToPhys(tb,tb->lSelStart);

	for (i=0; i < TICKHEIGHT; i++)
	    PatRect(tb->hdc,iPos-i,yTic+i,1,TICKHEIGHT-i);

	iPos = TBLogToPhys(tb,tb->lSelEnd);

	for (i=0; i < TICKHEIGHT; i++)
	    PatRect(tb->hdc,iPos+i,yTic+i,1,TICKHEIGHT-i);
    }

// !!! Not for MCIWnd
//    line across the bottom
//    SetBkColor(tb->hdc, GetSysColor(COLOR_BTNTEXT));
//    PatRect(tb->hdc, tb->rc.left, yTic+TICKHEIGHT,tb->iSizePhys,1);
//
//    SetBkColor(tb->hdc, GetSysColor(COLOR_BTNHIGHLIGHT));
//    PatRect(tb->hdc, tb->rc.left, yTic+TICKHEIGHT+1,tb->iSizePhys,1);

}

/* This draws the track bar itself */

static void NEAR PASCAL DrawChannel(PTrackBar tb)
{
    HBRUSH hbrTemp;

    // draw the frame around the window
    SetBkColor(tb->hdc, GetSysColor(COLOR_WINDOWFRAME));

    PatRect(tb->hdc, tb->rc.left, tb->rc.top,      tb->iSizePhys, 1);
    PatRect(tb->hdc, tb->rc.left, tb->rc.bottom-2, tb->iSizePhys, 1);
    PatRect(tb->hdc, tb->rc.left, tb->rc.top,      1, tb->rc.bottom-tb->rc.top-1);
    PatRect(tb->hdc, tb->rc.right-1, tb->rc.top, 1, tb->rc.bottom-tb->rc.top-1);

    SetBkColor(tb->hdc, GetSysColor(COLOR_BTNHIGHLIGHT));
    PatRect(tb->hdc, tb->rc.left, tb->rc.bottom-1, tb->iSizePhys, 1);

    SetBkColor(tb->hdc, GetSysColor(COLOR_BTNSHADOW));
    PatRect(tb->hdc, tb->rc.left+1, tb->rc.top + 1, tb->iSizePhys-2,1);

    // draw the background in dither gray
    hbrTemp = SelectObject(tb->hdc, hbrDither);
    if (hbrTemp) {
        PatBlt(tb->hdc, tb->rc.left+1, tb->rc.top + 2, 
            tb->iSizePhys-2, tb->rc.bottom-tb->rc.top-4, PATCOPY);
        SelectObject(tb->hdc, hbrTemp);   
    }

    // now highlight the selection range
    if ((tb->Flags & TBF_SELECTION) && 
        (tb->lSelStart <= tb->lSelEnd) && (tb->lSelEnd > tb->lLogMin)) {
	int iStart, iEnd;

	iStart = TBLogToPhys(tb,tb->lSelStart);
	iEnd   = TBLogToPhys(tb,tb->lSelEnd);

        SetBkColor(tb->hdc, GetSysColor(COLOR_BTNTEXT));
	PatRect(tb->hdc, iStart,tb->rc.top+1,1,tb->rc.bottom-tb->rc.top-2);
	PatRect(tb->hdc, iEnd,  tb->rc.top+1,1,tb->rc.bottom-tb->rc.top-2);

	if (iStart + 2 <= iEnd) {
            SetBkColor(tb->hdc, GetSysColor(COLOR_BTNHIGHLIGHT));
	    PatRect(tb->hdc, iStart+1, tb->rc.top+1, iEnd-iStart-1, tb->rc.bottom-tb->rc.top-3);
	}
    }
}

static void NEAR PASCAL MoveThumb(PTrackBar tb, LONG lPos)
{
	InvalidateRect(tb->hwnd, &tb->Thumb, TRUE);

	tb->lLogPos  = BOUND(lPos,tb->lLogMin,tb->lLogMax);

	tb->Thumb.left   = TBLogToPhys(tb, tb->lLogPos) - tb->wThumbWidth/2;
	tb->Thumb.right  = tb->Thumb.left + tb->wThumbWidth;
	tb->Thumb.top    = tb->rc.top - THUMBSLOP;
	tb->Thumb.bottom = tb->rc.bottom + THUMBSLOP;

	InvalidateRect(tb->hwnd, &tb->Thumb, TRUE);
	UpdateWindow(tb->hwnd);
}


static void NEAR PASCAL DrawThumb(PTrackBar tb)
{
	HBITMAP hbmT;
	HDC     hdcT;
	int     x;

	hdcT = CreateCompatibleDC(tb->hdc);

	if( (tb->Cmd == TB_THUMBTRACK) || !IsWindowEnabled(tb->hwnd) )
	    x = tb->wThumbWidth;
	else
	    x = 0;

	hbmT = SelectObject(hdcT, hbmThumb);
        if (hbmT) {
	    BitBlt(tb->hdc,tb->Thumb.left, tb->rc.top-THUMBSLOP,
		tb->wThumbWidth, tb->wThumbHeight, hdcT, x + 2*tb->wThumbWidth, 0, SRCAND);
	    BitBlt(tb->hdc,tb->Thumb.left, tb->rc.top-THUMBSLOP,
		tb->wThumbWidth, tb->wThumbHeight, hdcT, x, 0, SRCPAINT);
        }

	SelectObject(hdcT, hbmT);
	DeleteDC(hdcT);
}

/* SetTBCaretPos() */
/* Make the caret flash in the middle of the thumb when it has the focus */

static void NEAR PASCAL SetTBCaretPos(PTrackBar tb)
{
	// We only get the caret if we have the focus. 
	if (tb->hwnd == GetFocus())
		SetCaretPos(tb->Thumb.left + tb->wThumbWidth / 2,
			tb->Thumb.top + THUMBSLOP);
}

static void NEAR PASCAL DoAutoTics(PTrackBar tb)
{
    LONG NEAR *pl;
    LONG l;

    if (!(GetWindowLong(tb->hwnd, GWL_STYLE) & TBS_AUTOTICKS))
        return;

    tb->nTics = (int)(tb->lLogMax - tb->lLogMin - 1);

    // If our length is zero, we'll blow!
    if (tb->nTics <= 0) {
	tb ->nTics = 0;
	return;
    }

    if (tb->pTics)
        LocalFree((HANDLE)tb->pTics);

    tb->pTics = (DWORD NEAR *)LocalAlloc(LPTR, sizeof(DWORD) * tb->nTics);
    if (!tb->pTics) {
        tb->nTics = 0;
        return;
    }

    for (pl = (LONG NEAR *)tb->pTics, l = tb->lLogMin + 1; l < tb->lLogMax; l++)
        *pl++ = l;
}


LPARAM FAR CALLBACK _loadds TrackBarWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	PTrackBar       tb;
	PAINTSTRUCT     ps;
	BITMAP          bm;
	HANDLE          h;
	HDC		hdc;
	HBRUSH		hbr;
	RECT		rc;

	tb = TrackBarLock(hwnd);

	switch (message) {
		case WM_CREATE:
			if (!CreateDitherBrush(FALSE))
				return -1;
			// Get us our window structure.
			TrackBarCreate(hwnd);
			tb = TrackBarLock(hwnd);

			tb->hwnd = hwnd;
			tb->Cmd = (WORD)-1;

			/* load the 2 thumb bitmaps (pressed and released) */
			CreateThumb(FALSE);

			GetObject(hbmThumb, sizeof(bm), &bm);

			// bitmap has up and down thumb and up&down masks
			tb->wThumbWidth  = (WORD)(bm.bmWidth/4);
			tb->wThumbHeight = (WORD)bm.bmHeight;
                        // all lLog fields are zero inited by
                        // the LocalAlloc();

			// fall through to WM_SIZE

		case WM_SIZE:
			GetClientRect(hwnd, &tb->rc);

			tb->rc.bottom  = tb->rc.top + tb->wThumbHeight - THUMBSLOP;
			tb->rc.top    += THUMBSLOP;
			tb->rc.left   += tb->wThumbWidth/2;
			tb->rc.right  -= tb->wThumbWidth/2;

			// Figure out how much room we have to move the thumb in
			//!!! -2
			tb->iSizePhys = tb->rc.right - tb->rc.left;
	
			// Elevator isn't there if there's no room.
			if (tb->iSizePhys == 0) {
				// Lost our thumb.
				tb->Flags |= TBF_NOTHUMB;
				tb->iSizePhys = 1;
			} else {
				// Ah. We have a thumb.
				tb->Flags &= ~TBF_NOTHUMB;
			}
			InvalidateRect(hwnd, NULL, TRUE);
			MoveThumb(tb, tb->lLogPos);
			break;                           
			
		case WM_DESTROY:
			TrackBarDestroy(hwnd);
			FreeDitherBrush();
			DestroyThumb();
			break;
	
		case WM_SETFOCUS:
			// We gots the focus. We need a caret.
	
			CreateCaret(hwnd, (HBITMAP)1,
				3, tb->wThumbHeight - 2 * THUMBSLOP);
			SetTBCaretPos(tb);
			ShowCaret(hwnd);
			break;
	
		case WM_KILLFOCUS:
			DestroyCaret();
			break;

		case WM_ERASEBKGND:
			hdc = (HDC) wParam;
			hbr = (HBRUSH)(WORD)SendMessage(GetParent(hwnd),
				WM_CTLCOLOR, (WORD) hdc,
				MAKELONG(hwnd, CTLCOLOR_STATIC));

			if (hbr) {
			    GetClientRect(hwnd, &rc);
			    FillRect(hdc, &rc, hbr);
			    return(FALSE);
			}
			return(TRUE);
			break;

		case WM_ENABLE:
			InvalidateRect(hwnd, NULL, FALSE);
			break;

		case WM_PAINT:
			if (wParam == NULL)
			    tb->hdc = BeginPaint(hwnd, &ps);
			else
			    tb->hdc = (HDC)wParam;

			// Update the dither brush if necessary.
			CheckSysColors();

			DrawTics(tb);
			DrawThumb(tb);
			ExcludeClipRect(tb->hdc, tb->Thumb.left, tb->Thumb.top,
			    tb->Thumb.right, tb->Thumb.bottom);
			DrawChannel(tb);
			SetTBCaretPos(tb);
	
			if (wParam == NULL)
				EndPaint(hwnd, &ps);

			tb->hdc = NULL;
			break;

		case WM_GETDLGCODE:
			return DLGC_WANTARROWS;
			break;
	
		case WM_LBUTTONDOWN:
			/* Give ourselves focus */
			// !!! MCIWnd wants to keep focus
			// SetFocus(hwnd);
			TBTrackInit(tb, lParam);
			break;
	
		case WM_LBUTTONUP:
			// We're through doing whatever we were doing with the
			// button down.
			TBTrackEnd(tb, lParam);
			break;
	
		case WM_TIMER:
			// The only way we get a timer message is if we're
			// autotracking.
			lParam = GetMessagePos();
			ScreenToClient(tb->hwnd, (LPPOINT)&lParam);

			// fall through to WM_MOUSEMOVE
	
		case WM_MOUSEMOVE:
			// We only care that the mouse is moving if we're
			// tracking the bloody thing.
			if (tb->Cmd != (WORD)-1) {
				if (GetCapture() != tb->hwnd) {
				    TBTrackEnd(tb, lParam);
				    return 0L;
				}
				TBTrack(tb, lParam);
			}
			return 0L;
			
		case WM_KEYUP:
			// If key was any of the keyboard accelerators, send end
			// track message when user up clicks on keyboard
			switch (wParam) {
				case VK_HOME:
				case VK_END:
				case VK_PRIOR:
				case VK_NEXT:
				case VK_LEFT:
				case VK_UP:
				case VK_RIGHT:
				case VK_DOWN:
					DoTrack(tb, TB_ENDTRACK, 0);
					break;
				default:
					break;
			}
			break;
	
		case WM_KEYDOWN:
			switch (wParam) {
				case VK_HOME:
					wParam = TB_TOP;
					goto KeyTrack;
	
				case VK_END:
					wParam = TB_BOTTOM;
					goto KeyTrack;
	
				case VK_PRIOR:
					wParam = TB_PAGEUP;
					goto KeyTrack;
	
				case VK_NEXT:
					wParam = TB_PAGEDOWN;
					goto KeyTrack;
	
				case VK_LEFT:
				case VK_UP:
					wParam = TB_LINEUP;
					goto KeyTrack;
	
				case VK_RIGHT:
				case VK_DOWN:
					wParam = TB_LINEDOWN;
KeyTrack:
					DoTrack(tb, wParam, 0);
					break;
	
				default:
					break;
			}
			break;

		case TBM_GETPOS:
			return tb->lLogPos;
	
		case TBM_GETSELSTART:
			return tb->lSelStart;

		case TBM_GETSELEND:
			return tb->lSelEnd;

		case TBM_GETRANGEMIN:
			return tb->lLogMin;

		case TBM_GETRANGEMAX:
			return tb->lLogMax;
	
		case TBM_GETPTICS:
			return (LONG)(LPVOID)tb->pTics;
	
		case TBM_CLEARSEL:
                        tb->Flags &= ~TBF_SELECTION;
			tb->lSelStart = -1;
			tb->lSelEnd   = -1;
			goto RedrawTB;

		case TBM_CLEARTICS:
			if (tb->pTics)
			    LocalFree((HLOCAL)tb->pTics);

			tb->nTics = 0;
			tb->pTics = NULL;
			goto RedrawTB;

		case TBM_GETTIC:

			if (tb->pTics == NULL || (int)wParam >= tb->nTics)
			    return -1L;

			return tb->pTics[wParam];

		case TBM_GETTICPOS:

			if (tb->pTics == NULL || (int)wParam >= tb->nTics)
			    return -1L;

			return TBLogToPhys(tb,tb->pTics[wParam]);

		case TBM_GETNUMTICS:
			return tb->nTics;

		case TBM_SETTIC:
			/* not a valid position */
			if (lParam < 0)
			    break;

			if (tb->pTics)
				h = LocalReAlloc((HLOCAL)tb->pTics,
				    sizeof(DWORD) * (WORD)(tb->nTics + 1),
				    LMEM_MOVEABLE | LMEM_ZEROINIT);
			else
				h = LocalAlloc(LPTR, sizeof(DWORD));

			if (h)
				tb->pTics = (PDWORD)h;
			else
				return (LONG)FALSE;

			tb->pTics[tb->nTics++] = (DWORD)lParam;

			InvalidateRect(hwnd, NULL, TRUE);
			return (LONG)TRUE;
			break;
	
		case TBM_SETPOS:
			/* Only redraw if it will physically move */
			if (wParam && TBLogToPhys(tb, lParam) !=
						TBLogToPhys(tb, tb->lLogPos))
			    MoveThumb(tb, lParam);
			else
			    tb->lLogPos = BOUND(lParam,tb->lLogMin,tb->lLogMax);
			break;

		case TBM_SETSEL:
                        tb->Flags |= TBF_SELECTION;
			tb->lSelStart = LOWORD(lParam);
			tb->lSelEnd   = HIWORD(lParam);
			if (tb->lSelEnd < tb->lSelStart)
			    tb->lSelEnd = tb->lSelStart;
			goto RedrawTB;
	
		case TBM_SETSELSTART:
                        tb->Flags |= TBF_SELECTION;
			tb->lSelStart = lParam;
			if (tb->lSelEnd < tb->lSelStart || tb->lSelEnd == -1)
			    tb->lSelEnd = tb->lSelStart;
			goto RedrawTB;
	
		case TBM_SETSELEND:
                        tb->Flags |= TBF_SELECTION;
			tb->lSelEnd   = lParam;
			if (tb->lSelStart > tb->lSelEnd || tb->lSelStart == -1)
			    tb->lSelStart = tb->lSelEnd;
			goto RedrawTB;
	
		case TBM_SETRANGE:
			tb->lLogMin = LOWORD(lParam);
			tb->lLogMax = HIWORD(lParam);
                        DoAutoTics(tb);
			goto RedrawTB;

		case TBM_SETRANGEMIN:
			tb->lLogMin = (DWORD)lParam;
			goto RedrawTB;

		case TBM_SETRANGEMAX:
			tb->lLogMax = (DWORD)lParam;
	RedrawTB:
			tb->lLogPos = BOUND(tb->lLogPos, tb->lLogMin,tb->lLogMax);
			/* Only redraw if flag says so */
			if (wParam) {
			    InvalidateRect(hwnd, NULL, TRUE);
			    MoveThumb(tb, tb->lLogPos);
			}
			break;
	}
	return DefWindowProc(hwnd, message, wParam, lParam);
}

/* DoTrack() */

static void NEAR PASCAL DoTrack(PTrackBar tb, int cmd, DWORD dwPos)
{
	// note: we only send back a WORD worth of the position.
	SendMessage(GetParent(tb->hwnd), WM_HSCROLL, cmd,
	    MAKELONG(LOWORD(dwPos), tb->hwnd));
}

/* WTrackType() */

static WORD NEAR PASCAL WTrackType(PTrackBar tb, LONG lParam)
{
	POINT pt;
#ifdef WIN32
	LONG2POINT(lParam, pt);
#else
	pt = MAKEPOINT(lParam);
#endif

	if (tb->Flags & TBF_NOTHUMB)            // If no thumb, just leave.
	    return 0;

	if (PtInRect(&tb->Thumb, pt))
	    return TB_THUMBTRACK;

	if (!PtInRect(&tb->rc, pt))
	    return 0;

	if (pt.x >= tb->Thumb.left)
	    return TB_PAGEDOWN;
	else
	    return TB_PAGEUP;
}

/* TBTrackInit() */

static void NEAR PASCAL TBTrackInit(PTrackBar tb, LONG lParam)
{
	WORD wCmd;

	if (tb->Flags & TBF_NOTHUMB)         // No thumb:  just leave.
	    return;

        wCmd = WTrackType(tb, lParam);
	if (!wCmd)
	    return;

	HideCaret(tb->hwnd);
	SetCapture(tb->hwnd);

	tb->Cmd = wCmd;
	tb->dwDragPos = (DWORD)-1;

	// Set up for auto-track (if needed).
	if (wCmd != TB_THUMBTRACK) {
		// Set our timer up
		tb->Timer = (UINT)SetTimer(tb->hwnd, TIMER_ID, REPEATTIME, NULL);
	}

	TBTrack(tb, lParam);
}

/* EndTrack() */

static void near PASCAL TBTrackEnd(PTrackBar tb, long lParam)
{
	lParam = lParam; // Just reference this variable

// 	If we lose mouse capture we need to call this
//	if (GetCapture() != tb->hwnd)
//	    return;

	// Let the mouse go.
	ReleaseCapture();

	// Decide how we're ending this thing.
	if (tb->Cmd == TB_THUMBTRACK)
		DoTrack(tb, TB_THUMBPOSITION, tb->dwDragPos);

	if (tb->Timer)
		KillTimer(tb->hwnd, TIMER_ID);

	tb->Timer = 0;

	// Always send TB_ENDTRACK message.
	DoTrack(tb, TB_ENDTRACK, 0);

	// Give the caret back.
	ShowCaret(tb->hwnd);

	// Nothing going on.
	tb->Cmd = (WORD)-1;

	MoveThumb(tb, tb->lLogPos);
}

static void NEAR PASCAL TBTrack(PTrackBar tb, LONG lParam)
{
	DWORD dwPos;

	// See if we're tracking the thumb
	if (tb->Cmd == TB_THUMBTRACK) {
		dwPos = TBPhysToLog(tb, LOWORD(lParam));

		// Tentative position changed -- notify the guy.
		if (dwPos != tb->dwDragPos) {
			tb->dwDragPos = dwPos;
			MoveThumb(tb, dwPos);
			DoTrack(tb, TB_THUMBTRACK, dwPos);
		}
	}
	else {
		if (tb->Cmd != WTrackType(tb, lParam))
		    return;

		DoTrack(tb, tb->Cmd, 0);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd.16\toolbar.c ===
/*
**
** Toolbar.c
**
** This is it, the incredibly famous toolbar control.  Most of 
** the customization stuff is in another file.
**
*/
#include "ctlspriv.h"

#define Reference(x) ((x)=(x))

#define SZCODE static char _based(_segname("_CODE"))

char aszToolbarClassName[] = TOOLBARCLASSNAME;

SZCODE szUSER[] = "USER.EXE";
SZCODE szDrawFrameControl[] = "DrawFrameControl";
SZCODE szKernel[] = "KERNEL.EXE";
SZCODE szWriteProfileStruct[] = "WritePrivateProfileStruct";

// these values are defined by the UI gods...
#define DEFAULTBITMAPX 16
#define DEFAULTBITMAPY 15

#define DEFAULTBUTTONX 24
#define DEFAULTBUTTONY 22

// horizontal/vertical space taken up by button chisel, sides, 
// and a 1 pixel margin.  used in GrowToolbar.
#define XSLOP 7
#define YSLOP 6

#define SLOPTOP 1
#define SLOPBOT 1
#define SLOPLFT 8

static int dxButtonSep = 8;
static int xFirstButton = SLOPLFT;  //!!! was 8

static int iInitCount = 0;

static int nSelectedBM = -1;
static HDC hdcGlyphs = NULL;           // globals for fast drawing
static HDC hdcMono = NULL;
static HBITMAP hbmMono = NULL;
static HBITMAP hbmDefault = NULL;

static HDC hdcButton = NULL;           // contains hbmFace (when it exists)
static HBITMAP hbmFace = NULL;
static int dxFace, dyFace;             // current dimensions of hbmFace (2*dxFace)

static HDC hdcFaceCache = NULL;        // used for button cache

static HFONT hIconFont = NULL;         // font used for strings in buttons
static int yIconFont;                  // height of the font

static BOOL g_bUseDFC = FALSE;         // use DrawFrameControl, if available
static BOOL g_bProfStruct = FALSE;     // use PrivateProfileStruct routines
static WORD g_dxOverlap = 1;           // overlap between buttons

static WORD wStateMasks[] = {
    TBSTATE_ENABLED,
    TBSTATE_CHECKED,
    TBSTATE_PRESSED,
    TBSTATE_HIDDEN,
    TBSTATE_INDETERMINATE
};

LRESULT CALLBACK _loadds ToolbarWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);

#define HeightWithString(h) (h + yIconFont + 1)

static BOOL NEAR PASCAL InitGlobalObjects(void)
{
    LOGFONT lf;
    TEXTMETRIC tm;
    HFONT hOldFont;

    iInitCount++;

    if (iInitCount != 1)
        return TRUE;

    hdcGlyphs = CreateCompatibleDC(NULL);
    if (!hdcGlyphs)
        return FALSE;
    hdcMono = CreateCompatibleDC(NULL);
    if (!hdcMono)
        return FALSE;

    hbmMono = CreateBitmap(DEFAULTBUTTONX, DEFAULTBUTTONY, 1, 1, NULL);
    if (!hbmMono)
        return FALSE;

    hbmDefault = SelectObject(hdcMono, hbmMono);

    hdcButton = CreateCompatibleDC(NULL);
    if (!hdcButton)
        return FALSE;
    hdcFaceCache = CreateCompatibleDC(NULL);
    if (!hdcFaceCache)
        return FALSE;

    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0);
    hIconFont = CreateFontIndirect(&lf);
    if (!hIconFont)
	return FALSE;

    hOldFont = SelectObject(hdcMono, hIconFont);
    GetTextMetrics(hdcMono, &tm);
    yIconFont = tm.tmHeight;
    if (hOldFont)
	SelectObject(hdcMono, hOldFont);

#if WINVER >= 0x0400
    // set a global flag to see if USER will draw for us
    if (GetProcAddress(LoadLibrary(szUSER), szDrawFrameControl))
    {
	g_bUseDFC = TRUE;
	g_dxOverlap = 0;	// buttons do NOT overlap with new look
    }
    // set a global flag to see if KERNEL does profile structs
    if (GetProcAddress(LoadLibrary(szKernel), szWriteProfileStruct))
        g_bProfStruct = TRUE;
#endif

    return TRUE;
}


static BOOL NEAR PASCAL FreeGlobalObjects(void)
{
    iInitCount--;

    if (iInitCount != 0)
        return TRUE;

    if (hdcMono) {
	if (hbmDefault)
	    SelectObject(hdcMono, hbmDefault);
	DeleteDC(hdcMono);		// toast the DCs
    }
    hdcMono = NULL;

    if (hdcGlyphs)
	DeleteDC(hdcGlyphs);
    hdcGlyphs = NULL;
    if (hdcFaceCache)
	DeleteDC(hdcFaceCache);
    hdcFaceCache = NULL;

    if (hdcButton) {
	if (hbmDefault)
	    SelectObject(hdcButton, hbmDefault);
	DeleteDC(hdcButton);
    }
    hdcButton = NULL;

    if (hbmFace)
	DeleteObject(hbmFace);
    hbmFace = NULL;

    if (hbmMono)
	DeleteObject(hbmMono);
    hbmMono = NULL;

    if (hIconFont)
	DeleteObject(hIconFont);
    hIconFont = NULL;
}

HWND WINAPI CreateToolbarEx(HWND hwnd, DWORD ws, WORD wID, int nBitmaps,
			HINSTANCE hBMInst, WORD wBMID, LPCTBBUTTON lpButtons, 
			int iNumButtons, int dxButton, int dyButton, 
			int dxBitmap, int dyBitmap, UINT uStructSize)
{

    HWND hwndToolbar;

    hwndToolbar = CreateWindow(aszToolbarClassName, NULL, WS_CHILD | ws,
	      0, 0, 100, 30, hwnd, (HMENU)wID,
	      (HINSTANCE)GetWindowWord(hwnd, GWW_HINSTANCE), NULL);
    if (!hwndToolbar)
	goto Error1;

    SendMessage(hwndToolbar, TB_BUTTONSTRUCTSIZE, uStructSize, 0L);

    if (dxBitmap && dyBitmap)
	if (!SendMessage(hwndToolbar, TB_SETBITMAPSIZE, 0, MAKELONG(dxBitmap, dyBitmap)))
	{
	    //!!!! do we actually need to deal with this?
	    DestroyWindow(hwndToolbar);
	    hwndToolbar = NULL;
	    goto Error1;
	}

    if (dxButton && dyButton)
	if (!SendMessage(hwndToolbar, TB_SETBUTTONSIZE, 0, MAKELONG(dxButton, dyButton)))
	{
	    //!!!! do we actually need to deal with this?
	    DestroyWindow(hwndToolbar);
	    hwndToolbar = NULL;
	    goto Error1;
	}

    SendMessage(hwndToolbar, TB_ADDBITMAP, nBitmaps, MAKELONG(hBMInst, wBMID));
    SendMessage(hwndToolbar, TB_ADDBUTTONS, iNumButtons, (LPARAM)lpButtons);

Error1:
    return hwndToolbar;
}


#if 0
/* This is no longer declared in COMMCTRL.H.  It only exists for compatibility
** with existing apps; new apps must use CreateToolbarEx.
*/
HWND WINAPI CreateToolbar(HWND hwnd, DWORD ws, WORD wID, int nBitmaps, HINSTANCE hBMInst, WORD wBMID, LPCTBBUTTON lpButtons, int iNumButtons)
{
    // old-style toolbar, so no divider.
    ws |= CCS_NODIVIDER;
    return (CreateToolbarEx(hwnd, ws, wID, nBitmaps, hBMInst, wBMID, 
    		lpButtons, iNumButtons, 0, 0, 0, 0, sizeof(OLDTBBUTTON)));
}
#endif

BOOL FAR PASCAL InitToolbarClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    if (!GetClassInfo(hInstance, aszToolbarClassName, &wc)) {

	wc.lpszClassName = aszToolbarClassName;
	wc.style	 = CS_GLOBALCLASS | CS_DBLCLKS;
	wc.lpfnWndProc	 = (WNDPROC)ToolbarWndProc;
	wc.cbClsExtra	 = 0;
	wc.cbWndExtra	 = sizeof(PTBSTATE);
	wc.hInstance	 = hInstance;
	wc.hIcon	 = NULL;
	wc.hCursor	 = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
	wc.lpszMenuName	 = NULL;

	if (!RegisterClass(&wc))
	    return FALSE;
    }

    return TRUE;
}



#define BEVEL   2
#define FRAME   1

static void NEAR PASCAL PatB(HDC hdc,int x,int y,int dx,int dy, DWORD rgb)
{
    RECT    rc;

    SetBkColor(hdc,rgb);
    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}

static void NEAR PASCAL DrawString(HDC hdc, int x, int y, int dx, PSTR pszString)
{
    int oldMode;
    DWORD oldTextColor;
    HFONT oldhFont;
    DWORD dwExt;
    int len;

    oldMode = SetBkMode(hdc, TRANSPARENT);
    oldTextColor = SetTextColor(hdc, 0L);
    oldhFont = SelectObject(hdc, hIconFont);

    len = lstrlen(pszString);
    dwExt = GetTextExtent(hdc, (LPSTR)pszString, len);
    // center the string horizontally
    x += (dx - LOWORD(dwExt) - 1)/2;

    TextOut(hdc, x, y, (LPSTR)pszString, len);

    if (oldhFont)
	SelectObject(hdc, oldhFont);
    SetTextColor(hdc, oldTextColor);
    SetBkMode(hdc, oldMode);
}

// create a mono bitmap mask:
//   1's where color == COLOR_BTNFACE || COLOR_HILIGHT
//   0's everywhere else

static void NEAR PASCAL CreateMask(PTBSTATE pTBState, PTBBUTTON pTBButton, int xoffset, int yoffset, int dx, int dy)
{
    PSTR pFoo;

    // initalize whole area with 1's
    PatBlt(hdcMono, 0, 0, dx, dy, WHITENESS);

    // create mask based on color bitmap
    // convert this to 1's
    SetBkColor(hdcGlyphs, rgbFace);
    BitBlt(hdcMono, xoffset, yoffset, pTBState->iDxBitmap, pTBState->iDyBitmap, 
    	hdcGlyphs, pTBButton->iBitmap * pTBState->iDxBitmap, 0, SRCCOPY);
    // convert this to 1's
    SetBkColor(hdcGlyphs, rgbHilight);
    // OR in the new 1's
    BitBlt(hdcMono, xoffset, yoffset, pTBState->iDxBitmap, pTBState->iDyBitmap, 
    	hdcGlyphs, pTBButton->iBitmap * pTBState->iDxBitmap, 0, SRCPAINT);

    if (pTBButton->iString != -1 && (pTBButton->iString < pTBState->nStrings))
    {
	pFoo = pTBState->pStrings[pTBButton->iString];
	DrawString(hdcMono, 1, yoffset + pTBState->iDyBitmap + 1, dx, pFoo);
    }
}


/* Given a button number, the corresponding bitmap is loaded and selected in,
 * and the Window origin set.
 * Returns NULL on Error, 1 if the necessary bitmap is already selected,
 * or the old bitmap otherwise.
 */
static HBITMAP FAR PASCAL SelectBM(HDC hDC, PTBSTATE pTBState, int nButton)
{
  PTBBMINFO pTemp;
  HBITMAP hRet;
  int nBitmap, nTot;

  for (pTemp=pTBState->pBitmaps, nBitmap=0, nTot=0; ; ++pTemp, ++nBitmap)
    {
      if (nBitmap >= pTBState->nBitmaps)
	  return(NULL);

      if (nButton < nTot+pTemp->nButtons)
	  break;

      nTot += pTemp->nButtons;
    }

  /* Special case when the required bitmap is already selected
   */
  if (nBitmap == nSelectedBM)
      return((HBITMAP)1);

  if (!pTemp->hbm || (hRet=SelectObject(hDC, pTemp->hbm))==NULL)
    {
      if (pTemp->hbm)
	  DeleteObject(pTemp->hbm);

      if (pTemp->hInst)
	  pTemp->hbm = CreateMappedBitmap(pTemp->hInst, pTemp->wID,
		TRUE, NULL, 0);
      else
	  pTemp->hbm = (HBITMAP)pTemp->wID;

      if (!pTemp->hbm || (hRet=SelectObject(hDC, pTemp->hbm))==NULL)
	  return(NULL);
    }

  nSelectedBM = nBitmap;
#ifdef WIN32
  SetWindowOrgEx(hDC, nTot * pTBState->iDxBitmap, 0, NULL);
#else // WIN32
  SetWindowOrg(hDC, nTot * pTBState->iDxBitmap, 0);
#endif

  return(hRet);
}

static void FAR PASCAL DrawBlankButton(HDC hdc, int x, int y, int dx, int dy, WORD state, WORD wButtType)
{
#if WINVER >= 0x0400
    RECT r1;
#endif

    // face color
    PatB(hdc, x, y, dx, dy, rgbFace);

#if WINVER >= 0x0400
    if (g_bUseDFC)
    {
	r1.left = x;
	r1.top = y;
	r1.right = x + dx;
	r1.bottom = y + dy;

	DrawFrameControl(hdc, &r1, wButtType, 
		(state & TBSTATE_PRESSED) ? DFCS_PUSHED : 0);
    }
    else
#endif
    {
	if (state & TBSTATE_PRESSED) {
	    PatB(hdc, x + 1, y, dx - 2, 1, rgbFrame);
	    PatB(hdc, x + 1, y + dy - 1, dx - 2, 1, rgbFrame);
	    PatB(hdc, x, y + 1, 1, dy - 2, rgbFrame);
	    PatB(hdc, x + dx - 1, y +1, 1, dy - 2, rgbFrame);
	    PatB(hdc, x + 1, y + 1, 1, dy-2, rgbShadow);
	    PatB(hdc, x + 1, y + 1, dx-2, 1, rgbShadow);
	}
	else {
	    PatB(hdc, x + 1, y, dx - 2, 1, rgbFrame);
	    PatB(hdc, x + 1, y + dy - 1, dx - 2, 1, rgbFrame);
	    PatB(hdc, x, y + 1, 1, dy - 2, rgbFrame);
	    PatB(hdc, x + dx - 1, y + 1, 1, dy - 2, rgbFrame);
	    dx -= 2;
	    dy -= 2;
	    PatB(hdc, x + 1, y + 1, 1, dy - 1, rgbHilight);
	    PatB(hdc, x + 1, y + 1, dx - 1, 1, rgbHilight);
	    PatB(hdc, x + dx, y + 1, 1, dy, rgbShadow);
	    PatB(hdc, x + 1, y + dy, dx, 1,   rgbShadow);
	    PatB(hdc, x + dx - 1, y + 2, 1, dy - 2, rgbShadow);
	    PatB(hdc, x + 2, y + dy - 1, dx - 2, 1,   rgbShadow);
	}
    }
}

#define DSPDxax	 0x00E20746
#define PSDPxax  0x00B8074A

#define FillBkColor(hdc, prc) ExtTextOut(hdc,0,0,ETO_OPAQUE,prc,NULL,0,NULL)

static void NEAR PASCAL DrawFace(PTBSTATE pTBState, PTBBUTTON ptButton, HDC hdc, int x, int y,
			int offx, int offy, int dx)
{
    PSTR pFoo;

    BitBlt(hdc, x + offx, y + offy, pTBState->iDxBitmap, pTBState->iDyBitmap, 
	    hdcGlyphs, ptButton->iBitmap * pTBState->iDxBitmap, 0, SRCCOPY);

    if (ptButton->iString != -1 && (ptButton->iString < pTBState->nStrings))
    {
	pFoo = pTBState->pStrings[ptButton->iString];
	DrawString(hdc, x + 1, y + offy + pTBState->iDyBitmap + 1, dx, pFoo);
    }
}

static void FAR PASCAL DrawButton(HDC hdc, int x, int y, int dx, int dy, PTBSTATE pTBState, PTBBUTTON ptButton, BOOL bFaceCache)
{
    int yOffset;
    HBRUSH hbrOld, hbr;
    BOOL bMaskCreated = FALSE;
    BYTE state;
    int xButton = 0;		// assume button is down
    int dxFace, dyFace;
    int xCenterOffset;

    dxFace = dx - 4;
    dyFace = dy - 4;

    // make local copy of state and do proper overriding
    state = ptButton->fsState;
    if (state & TBSTATE_INDETERMINATE) {
	if (state & TBSTATE_PRESSED)
	    state &= ~TBSTATE_INDETERMINATE;
	else if (state & TBSTATE_ENABLED)
	    state = TBSTATE_INDETERMINATE;
	else
	    state &= ~TBSTATE_INDETERMINATE;
    }

    // get the proper button look-- up or down.
    if (!(state & (TBSTATE_PRESSED | TBSTATE_CHECKED))) {
	xButton = dx;	// use 'up' version of button
    }
    if (bFaceCache)
	BitBlt(hdc, x, y, dx, dy, hdcButton, xButton, 0, SRCCOPY);
    else
	DrawBlankButton(hdc, x, y, dx, dy, state, pTBState->wButtonType);


    // move coordinates inside border and away from upper left highlight.
    // the extents change accordingly.
    x += 2;
    y += 2;

    if (!SelectBM(hdcGlyphs, pTBState, ptButton->iBitmap))
	return;

    // calculate offset of face from (x,y).  y is always from the top,
    // so the offset is easy.  x needs to be centered in face.
    yOffset = 1;
    xCenterOffset = (dxFace - pTBState->iDxBitmap)/2;
    if (state & (TBSTATE_PRESSED | TBSTATE_CHECKED))
    {
	// pressed state moves down and to the right
	xCenterOffset++;
        yOffset++;
    }

    // now put on the face
    if (state & TBSTATE_ENABLED) {
        // regular version
	DrawFace(pTBState, ptButton, hdc, x, y, xCenterOffset, yOffset, dxFace);
    } else {
        // disabled version (or indeterminate)
	bMaskCreated = TRUE;
	CreateMask(pTBState, ptButton, xCenterOffset, yOffset, dxFace, dyFace);

	SetTextColor(hdc, 0L);	 // 0's in mono -> 0 (for ROP)
	SetBkColor(hdc, 0x00FFFFFF); // 1's in mono -> 1

	// draw glyph's white understrike
	if (!(state & TBSTATE_INDETERMINATE)) {
	    hbr = CreateSolidBrush(rgbHilight);
	    if (hbr) {
	        hbrOld = SelectObject(hdc, hbr);
	        if (hbrOld) {
	            // draw hilight color where we have 0's in the mask
                    BitBlt(hdc, x + 1, y + 1, dxFace, dyFace, hdcMono, 0, 0, PSDPxax);
	            SelectObject(hdc, hbrOld);
	        }
	        DeleteObject(hbr);
	    }
	}

	// gray out glyph
	hbr = CreateSolidBrush(rgbShadow);
	if (hbr) {
	    hbrOld = SelectObject(hdc, hbr);
	    if (hbrOld) {
	        // draw the shadow color where we have 0's in the mask
                BitBlt(hdc, x, y, dxFace, dyFace, hdcMono, 0, 0, PSDPxax);
	        SelectObject(hdc, hbrOld);
	    }
	    DeleteObject(hbr);
	}

	if (state & TBSTATE_CHECKED) {
	    BitBlt(hdcMono, 1, 1, dxFace - 1, dyFace - 1, hdcMono, 0, 0, SRCAND);
	}
    }

    if (state & (TBSTATE_CHECKED | TBSTATE_INDETERMINATE)) {

        hbrOld = SelectObject(hdc, hbrDither);
	if (hbrOld) {

	    if (!bMaskCreated)
	        CreateMask(pTBState, ptButton, xCenterOffset, yOffset, dxFace, dyFace);

	    SetTextColor(hdc, 0L);		// 0 -> 0
	    SetBkColor(hdc, 0x00FFFFFF);	// 1 -> 1

	    // only draw the dither brush where the mask is 1's
            BitBlt(hdc, x, y, dxFace, dyFace, hdcMono, 0, 0, DSPDxax);
	    
	    SelectObject(hdc, hbrOld);
	}
    }
}

static void NEAR PASCAL FlushButtonCache(PTBSTATE pTBState)
{
    if (pTBState->hbmCache) {
	DeleteObject(pTBState->hbmCache);
	pTBState->hbmCache = 0;
    }
}

// make sure that hbmMono is big enough to do masks for this
// size of button.  if not, fail.
static BOOL NEAR PASCAL CheckMonoMask(int width, int height)
{
    BITMAP bm;
    HBITMAP hbmTemp;

    GetObject(hbmMono, sizeof(BITMAP), &bm);
    if (width > bm.bmWidth || height > bm.bmHeight) {
	hbmTemp = CreateBitmap(width, height, 1, 1, NULL);
	if (!hbmTemp)
	    return FALSE;
	SelectObject(hdcMono, hbmTemp);
	DeleteObject(hbmMono);
	hbmMono = hbmTemp;
    }
    return TRUE;
}

/*
** GrowToolbar
**
** Attempt to grow the button size.  
**
** The calling function can either specify a new internal measurement
** or a new external measurement.
*/
static BOOL NEAR PASCAL GrowToolbar(PTBSTATE pTBState, int newButWidth, int newButHeight, BOOL bInside)
{
    // if growing based on inside measurement, get full size
    if (bInside) {
	newButHeight += YSLOP;
	newButWidth += XSLOP;
	
	// if toolbar already has strings, don't shrink width it because it
	// might clip room for the string
	if ((newButWidth < pTBState->iButWidth) && pTBState->nStrings)
	    newButWidth = pTBState->iButWidth;
    }
    else {
    	if (newButHeight < pTBState->iButHeight)
	    newButHeight = pTBState->iButHeight;
    	if (newButWidth < pTBState->iButWidth)
	    newButWidth = pTBState->iButWidth;
    }

    // if the size of the toolbar is actually growing, see if shadow
    // bitmaps can be made sufficiently large.
    if ((newButWidth > pTBState->iButWidth) || (newButHeight > pTBState->iButHeight)) {
	if (!CheckMonoMask(newButWidth, newButHeight))
	    return(FALSE);
    }

    pTBState->iButWidth = newButWidth;
    pTBState->iButHeight = newButHeight;

//!!!ACK ACK ACK ACK
#if 0
    // bar height has 2 pixels above, 3 below
    pTBState->iBarHeight = pTBState->iButHeight + 5;
    pTBState->iYPos = 2;
#else
    pTBState->iBarHeight = pTBState->iButHeight + SLOPTOP+SLOPBOT;
    pTBState->iYPos = SLOPTOP;
#endif

    return TRUE;
}

static BOOL NEAR PASCAL SetBitmapSize(PTBSTATE pTBState, int width, int height)
{
    int realh = height;

    if (pTBState->nStrings)
	realh = HeightWithString(height);

    if (GrowToolbar(pTBState, width, realh, TRUE)) {
	pTBState->iDxBitmap = width;
	pTBState->iDyBitmap = height;
	return TRUE;
    }
    return FALSE;
}

static void NEAR PASCAL UpdateTBState(PTBSTATE pTBState)
{
	int i;
	PTBBMINFO pBitmap;

	if (pTBState->nSysColorChanges!=nSysColorChanges)
	{
		/* Reset all of the bitmaps if the sys colors have changed
		 * since the last time the bitmaps were created.
		 */
		for (i=pTBState->nBitmaps-1, pBitmap=pTBState->pBitmaps; i>=0;
			--i, ++pBitmap)
		{
			if (pBitmap->hInst && pBitmap->hbm)
			{
				DeleteObject(pBitmap->hbm);
				pBitmap->hbm = NULL;
			}
		}

		FlushButtonCache(pTBState);

		// now we're updated to latest color scheme
		pTBState->nSysColorChanges = nSysColorChanges;
	}
}

#define CACHE 0x01
#define BUILD 0x02

static void NEAR PASCAL ToolbarPaint(HWND hWnd, PTBSTATE pTBState)
{
    RECT rc;
    HDC hdc;
    PAINTSTRUCT ps;
    int iButton, xButton, yButton;
    int cButtons = pTBState->iNumButtons;
    PTBBUTTON pAllButtons = pTBState->Buttons;
    HBITMAP hbmOldGlyphs;
    int xCache = 0;
    WORD wFlags = 0;
    int iCacheWidth = 0;
    HBITMAP hbmTemp;
    BOOL bFaceCache = TRUE;		// assume face cache exists
    int dx,dy;

    CheckSysColors();
    UpdateTBState(pTBState);

    hdc = BeginPaint(hWnd, &ps);

    GetClientRect(hWnd, &rc);
    if (!rc.right)
	goto Error1;

    dx = pTBState->iButWidth;
    dy = pTBState->iButHeight;

    // setup global stuff for fast painting

    /* We need to kick-start the bitmap selection process.
     */
    nSelectedBM = -1;
    hbmOldGlyphs = SelectBM(hdcGlyphs, pTBState, 0);
    if (!hbmOldGlyphs)
	goto Error1;

    yButton = pTBState->iYPos;
    rc.top = yButton;
    rc.bottom = yButton + dy;

    if (!(pTBState->hbmCache)) {
	// calculate the width of the cache.
	for (iButton = 0; iButton < cButtons; iButton++) {
	    if (!(pAllButtons[iButton].fsState & TBSTATE_HIDDEN) &&
			!(pAllButtons[iButton].fsStyle & TBSTYLE_SEP))
		iCacheWidth += pTBState->iButWidth;
	}
	pTBState->hbmCache = CreateCompatibleBitmap(hdcGlyphs, iCacheWidth, dy);
	wFlags |= BUILD;

	// if needed, create or enlarge bitmap for pre-building button states
	if (!(hbmFace && (dx <= dxFace) && (dy <= dyFace))) {
	    hbmTemp = CreateCompatibleBitmap(hdcGlyphs, 2*dx, dy);
	    if (hbmTemp) {
		SelectObject(hdcButton, hbmTemp);
		if (hbmFace)
		    DeleteObject(hbmFace);
		hbmFace = hbmTemp;
		dxFace = dx;
		dyFace = dy;
	    }
	    else 
		bFaceCache = FALSE;
	}
    }
    if (pTBState->hbmCache) {
        SelectObject(hdcFaceCache,pTBState->hbmCache);
	wFlags |= CACHE;
    }
    else
        wFlags = 0;

    if (bFaceCache) {
	DrawBlankButton(hdcButton, 0, 0, dx, dy, TBSTATE_PRESSED, pTBState->wButtonType);
	DrawBlankButton(hdcButton, dx, 0, dx, dy, 0, pTBState->wButtonType);
    }

    for (iButton = 0, xButton = xFirstButton;
	iButton < cButtons;
	iButton++) {

        PTBBUTTON ptbButton = &pAllButtons[iButton];

	if (ptbButton->fsState & TBSTATE_HIDDEN) {
	    /* Do nothing */ ;
        } else if (ptbButton->fsStyle & TBSTYLE_SEP) {
	    xButton += ptbButton->iBitmap;
        } else {
	    if (wFlags & BUILD)
	        DrawButton(hdcFaceCache, xCache, 0, dx, dy, pTBState, ptbButton, bFaceCache);

            rc.left = xButton;
            rc.right = xButton + dx;
	    if (RectVisible(hdc, &rc)) {
		if ((wFlags & CACHE) && !(ptbButton->fsState & TBSTATE_PRESSED))
		    BitBlt(hdc, xButton, yButton, dx, dy, 
				hdcFaceCache, xCache, 0, SRCCOPY);
		else
		    DrawButton(hdc, xButton, yButton, dx, dy, pTBState, ptbButton, bFaceCache);
	    }
	    // advance the "pointer" in the cache
	    xCache += dx;

	    xButton += (dx - g_dxOverlap);
        }
    }

    if (wFlags & CACHE)
	SelectObject(hdcFaceCache, hbmDefault);
    SelectObject(hdcGlyphs, hbmOldGlyphs);

Error1:
    EndPaint(hWnd, &ps);
}


static BOOL NEAR PASCAL GetItemRect(PTBSTATE pTBState, UINT uButton, LPRECT lpRect)
{
	UINT iButton, xPos;
	PTBBUTTON pButton;

	if (uButton>=(UINT)pTBState->iNumButtons
		|| (pTBState->Buttons[uButton].fsState&TBSTATE_HIDDEN))
	{
		return(FALSE);
	}

	xPos = xFirstButton;

	for (iButton=0, pButton=pTBState->Buttons; iButton<uButton;
		++iButton, ++pButton)
	{
		if (pButton->fsState & TBSTATE_HIDDEN)
		{
			/* Do nothing */ ;
		}
		else if (pButton->fsStyle & TBSTYLE_SEP)
		{
			xPos += pButton->iBitmap;
		}
		else
		{
			xPos += (pTBState->iButWidth - g_dxOverlap);
		}
	}

	/* pButton should now point at the required button, and xPos should be
	 * its left edge.  Note that we already checked if the button was
	 * hidden above.
	 */
	lpRect->left   = xPos;
	lpRect->right  = xPos + (pButton->fsStyle&TBSTYLE_SEP
		? pButton->iBitmap : pTBState->iButWidth);
	lpRect->top    = pTBState->iYPos;
	lpRect->bottom = lpRect->top + pTBState->iButHeight;

	return(TRUE);
}


static void NEAR PASCAL InvalidateButton(HWND hwnd, PTBSTATE pTBState, PTBBUTTON pButtonToPaint)
{
	RECT rc;

	if (GetItemRect(pTBState, pButtonToPaint-pTBState->Buttons, &rc))
	{
		InvalidateRect(hwnd, &rc, FALSE);
	}
}


static int FAR PASCAL TBHitTest(PTBSTATE pTBState, int xPos, int yPos)
{
  int iButton;
  int cButtons = pTBState->iNumButtons;
  PTBBUTTON pButton;

  xPos -= xFirstButton;
  if (xPos < 0)
      return(-1);
  yPos -= pTBState->iYPos;

  for (iButton=0, pButton=pTBState->Buttons; iButton<cButtons;
	++iButton, ++pButton)
    {
      if (pButton->fsState & TBSTATE_HIDDEN)
	  /* Do nothing */ ;
      else if (pButton->fsStyle & TBSTYLE_SEP)
	  xPos -= pButton->iBitmap;
      else
	  xPos -= (pTBState->iButWidth - g_dxOverlap);

      if (xPos < 0)
	{
	  if (pButton->fsStyle&TBSTYLE_SEP
		|| (UINT)yPos>=(UINT)pTBState->iButHeight)
	      break;

	  return(iButton);
	}
    }

  return(-1 - iButton);
}


static int FAR PASCAL PositionFromID(PTBSTATE pTBState, int id)
{
    int i;
    int cButtons = pTBState->iNumButtons;
    PTBBUTTON pAllButtons = pTBState->Buttons;

    for (i = 0; i < cButtons; i++)
        if (pAllButtons[i].idCommand == id)
	    return i;		// position found

    return -1;		// ID not found!
}

// check a radio button by button index.
// the button matching idCommand was just pressed down.  this forces
// up all other buttons in the group.
// this does not work with buttons that are forced up with

static void NEAR PASCAL MakeGroupConsistant(HWND hWnd, PTBSTATE pTBState, int idCommand)
{
    int i, iFirst, iLast, iButton;
    int cButtons = pTBState->iNumButtons;
    PTBBUTTON pAllButtons = pTBState->Buttons;

    iButton = PositionFromID(pTBState, idCommand);

    if (iButton < 0)
        return;

    // assertion

//    if (!(pAllButtons[iButton].fsStyle & TBSTYLE_CHECK))
//	return;

    // did the pressed button just go down?
    if (!(pAllButtons[iButton].fsState & TBSTATE_CHECKED))
        return;         // no, can't do anything

    // find the limits of this radio group

    for (iFirst = iButton; (iFirst > 0) && (pAllButtons[iFirst].fsStyle & TBSTYLE_GROUP); iFirst--)
    if (!(pAllButtons[iFirst].fsStyle & TBSTYLE_GROUP))
        iFirst++;

    cButtons--;
    for (iLast = iButton; (iLast < cButtons) && (pAllButtons[iLast].fsStyle & TBSTYLE_GROUP); iLast++);
    if (!(pAllButtons[iLast].fsStyle & TBSTYLE_GROUP))
        iLast--;

    // search for the currently down button and pop it up
    for (i = iFirst; i <= iLast; i++) {
        if (i != iButton) {
            // is this button down?
            if (pAllButtons[i].fsState & TBSTATE_CHECKED) {
	        pAllButtons[i].fsState &= ~TBSTATE_CHECKED;     // pop it up
                InvalidateButton(hWnd, pTBState, &pAllButtons[i]);
                break;          // only one button is down right?
            }
        }
    }
}

static void NEAR PASCAL DestroyStrings(PTBSTATE pTBState)
{
    PSTR *p;
    PSTR end = 0, start = 0;
    int i;

    p = pTBState->pStrings;
    for (i = 0; i < pTBState->nStrings; i++) {
	if (!(*p < end) && (*p > start)) {
	    start = (*p);
	    end = start + LocalSize((HANDLE)*p);
	    LocalFree((HANDLE)*p);
	}
	p++;
	i++;
    }

    LocalFree((HANDLE)pTBState->pStrings);
}

// not needed for MCIWnd
#if 0
#define MAXSTRINGSIZE 1024
static int NEAR PASCAL AddStrings(PTBSTATE pTBState, WPARAM wParam, LPARAM lParam)
{
    int i;
    DWORD dwExt;
    HFONT hOldFont;
    LPSTR lpsz;
    PSTR  pString, psz, ptmp;
    int numstr;
    PSTR *pFoo;
    PSTR *pOffset;
    char cSeparator;
    int len;
    int newWidth;

    // read the string as a resource
    if (wParam != 0) {
	pString = (PSTR)LocalAlloc(LPTR, MAXSTRINGSIZE);
	if (!pString)
	    return -1;
	i = LoadString((HINSTANCE)wParam, LOWORD(lParam), (LPSTR)pString, MAXSTRINGSIZE);
	if (!i) {
	    LocalFree(pString);
	    return -1;
	}
	// realloc string buffer to actual needed size
	LocalReAlloc(pString, i, LMEM_MOVEABLE);

	// convert separators to '\0' and count number of strings
	cSeparator = *pString;
	ptmp = pString;
	pString += 1;
	for (numstr = 0, psz = pString; i >= psz-pString; *psz ? psz = (PSTR)AnsiNext((LPSTR)psz) : psz++) {
	    if (*psz == cSeparator) {
		numstr++;
		*psz = 0;	// terminate with 0
	    }

	}
    }
    // read explicit string.  copy it into local memory, too.
    else {
	// find total length and number of strings
	for (i = 0, numstr = 0, lpsz = (LPSTR)lParam;;) {
	    i++;
	    if (*lpsz == 0) {
		numstr++;
		if (*(lpsz+1) == 0)
		    break;
	    }
	    lpsz++;
	}
	pString = (PSTR)LocalAlloc(LPTR, i);
	ptmp = pString;
	if (!pString)
	    return -1;
	hmemcpy(pString, (void FAR *)lParam, i);
    }

    // make room for increased string pointer table
    if (pTBState->pStrings)
	pFoo = (PSTR *)LocalReAlloc(pTBState->pStrings, 
		(pTBState->nStrings + numstr) * sizeof(PSTR), LMEM_MOVEABLE);
    else
	pFoo = (PSTR *)LocalAlloc(LPTR, numstr * sizeof(PSTR));
    if (!pFoo) {
	LocalFree(ptmp);
	return -1;
    }

    pTBState->pStrings = pFoo;
    // pointer to next open slot in string index table.
    pOffset = pTBState->pStrings + pTBState->nStrings;

    hOldFont = SelectObject(hdcMono, hIconFont);
    // fix up string pointer table to deal with the new strings.
    // check if any string is big enough to necessitate a wider button.
    newWidth = pTBState->iDxBitmap;
    for (i = 0; i < numstr; i++, pOffset++) {
	*pOffset = pString;

	len = lstrlen(pString);
	dwExt = GetTextExtent(hdcMono, pString, len);
	if ((int)(LOWORD(dwExt)) > newWidth)
	    newWidth = LOWORD(dwExt);
	pString += len + 1;
    }
    if (hOldFont)
	SelectObject(hdcMono, hOldFont);

    // is the world big enough to handle the larger buttons?
    if (!GrowToolbar(pTBState, newWidth, HeightWithString(pTBState->iDyBitmap), TRUE))
    {
	// back out changes.
	if (pTBState->nStrings == 0) {
	    LocalFree(pTBState->pStrings);
	    pTBState->pStrings = 0;
	}
	else
	    pTBState->pStrings = (PSTR *)LocalReAlloc(pTBState->pStrings, 
	    		pTBState->nStrings * sizeof(PSTR), LMEM_MOVEABLE);
	LocalFree(ptmp);
	return -1;
    }

    i = pTBState->nStrings;
    pTBState->nStrings += numstr;
    return i;				// index of first added string
}
#endif

/* Adds a new bitmap to the list of BMs available for this toolbar.
 * Returns the index of the first button in the bitmap or -1 if there
 * was an error.
 */
static int NEAR PASCAL AddBitmap(PTBSTATE pTBState, int nButtons,
      HINSTANCE hBMInst, WORD wBMID)
{
  PTBBMINFO pTemp;
  int nBM, nIndex;

  if (pTBState->pBitmaps)
    {
      /* Check if the bitmap has already been added
       */
      for (nBM=pTBState->nBitmaps, pTemp=pTBState->pBitmaps, nIndex=0;
	    nBM>0; --nBM, ++pTemp)
	{
	  if (pTemp->hInst==hBMInst && pTemp->wID==wBMID)
	    {
	      /* We already have this bitmap, but have we "registered" all
	       * the buttons in it?
	       */
	      if (pTemp->nButtons >= nButtons)
		  return(nIndex);
	      if (nBM == 1)
		{
		  /* If this is the last bitmap, we can easily increase the
		   * number of buttons without messing anything up.
		   */
		  pTemp->nButtons = nButtons;
		  return(nIndex);
		}
	    }

	  nIndex += pTemp->nButtons;
	}

      pTemp = (PTBBMINFO)LocalReAlloc(pTBState->pBitmaps,
	    (pTBState->nBitmaps+1)*sizeof(TBBMINFO), LMEM_MOVEABLE);
      if (!pTemp)
	  return(-1);
      pTBState->pBitmaps = pTemp;
    }
  else
    {
      pTBState->pBitmaps = (PTBBMINFO)LocalAlloc(LPTR, sizeof(TBBMINFO));
      if (!pTBState->pBitmaps)
	  return(-1);
    }

  pTemp = pTBState->pBitmaps + pTBState->nBitmaps;

  pTemp->hInst = hBMInst;
  pTemp->wID = wBMID;
  pTemp->nButtons = nButtons;
  pTemp->hbm = NULL;

  ++pTBState->nBitmaps;

  for (nButtons=0, --pTemp; pTemp>=pTBState->pBitmaps; --pTemp)
      nButtons += pTemp->nButtons;

  return(nButtons);
}


static BOOL NEAR PASCAL InsertButtons(HWND hWnd, PTBSTATE pTBState,
      UINT uWhere, UINT uButtons, LPTBBUTTON lpButtons)
{
  PTBBUTTON pIn, pOut;

  if (!pTBState || !pTBState->uStructSize)
      return(FALSE);

  pTBState = (PTBSTATE)LocalReAlloc(pTBState, sizeof(TBSTATE)-sizeof(TBBUTTON)
	+ (pTBState->iNumButtons+uButtons)*sizeof(TBBUTTON), LMEM_MOVEABLE);
  if (!pTBState)
      return(FALSE);

  SETWINDOWPOINTER(hWnd, PTBSTATE, pTBState);

  if (uWhere > (UINT)pTBState->iNumButtons)
      uWhere = pTBState->iNumButtons;

  for (pIn=pTBState->Buttons+pTBState->iNumButtons-1, pOut=pIn+uButtons,
	uWhere=(UINT)pTBState->iNumButtons-uWhere; uWhere>0;
	--pIn, --pOut, --uWhere)
      *pOut = *pIn;

  for (lpButtons=(LPTBBUTTON)((LPSTR)lpButtons+pTBState->uStructSize*(uButtons-1)), pTBState->iNumButtons+=(int)uButtons; uButtons>0;
	--pOut, lpButtons=(LPTBBUTTON)((LPSTR)lpButtons-pTBState->uStructSize), --uButtons)
    {
      TBInputStruct(pTBState, pOut, lpButtons);

      if ((pOut->fsStyle&TBSTYLE_SEP) && pOut->iBitmap<=0)
	  pOut->iBitmap = dxButtonSep;
    }
	      
  // flush the cache
  FlushButtonCache(pTBState);

  /* We need to completely redraw the toolbar at this point.
   */
  InvalidateRect(hWnd, NULL, TRUE);

  return(TRUE);
}


/* Notice that the state structure is not realloc'ed smaller at this
 * point.  This is a time optimization, and the fact that the structure
 * will not move is used in other places.
 */
static BOOL NEAR PASCAL DeleteButton(HWND hWnd, PTBSTATE pTBState, UINT uIndex)
{
  PTBBUTTON pIn, pOut;

  if (uIndex >= (UINT)pTBState->iNumButtons)
      return(FALSE);

  --pTBState->iNumButtons;
  for (pOut=pTBState->Buttons+uIndex, pIn=pOut+1;
	uIndex<(UINT)pTBState->iNumButtons; ++uIndex, ++pIn, ++pOut)
      *pOut = *pIn;

  // flush the cache
  FlushButtonCache(pTBState);

  /* We need to completely redraw the toolbar at this point.
   */
  InvalidateRect(hWnd, NULL, TRUE);

  return(TRUE);
}


static void FAR PASCAL TBInputStruct(PTBSTATE pTBState, LPTBBUTTON pButtonInt, LPTBBUTTON pButtonExt)
{
	if (pTBState->uStructSize >= sizeof(TBBUTTON))
	{
		*pButtonInt = *pButtonExt;
	}
	else
	/* It is assumed the only other possibility is the OLDBUTTON struct */
	{
		*(LPOLDTBBUTTON)pButtonInt = *(LPOLDTBBUTTON)pButtonExt;
		/* We don't care about dwData */
		pButtonInt->iString = -1;
	}
}


static void FAR PASCAL TBOutputStruct(PTBSTATE pTBState, LPTBBUTTON pButtonInt, LPTBBUTTON pButtonExt)
{
	if (pTBState->uStructSize >= sizeof(TBBUTTON))
	{
		LPSTR pOut;
		int i;

		/* Fill the part we know about and fill the rest with 0's
		*/
		*pButtonExt = *pButtonInt;
		for (i=pTBState->uStructSize-sizeof(TBBUTTON), pOut=(LPSTR)(pButtonExt+1);
			i>0; --i, ++pOut)
		{
			*pOut = 0;
		}
	}
	else
	/* It is assumed the only other possibility is the OLDBUTTON struct */
	{
		*(LPOLDTBBUTTON)pButtonExt = *(LPOLDTBBUTTON)pButtonInt;
	}
}


LRESULT CALLBACK _loadds ToolbarWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fSameButton;
    PTBBUTTON ptbButton;
    PTBSTATE pTBState;
    int iPos;
    BYTE fsState;
#if WINVER >= 0x0400
    DWORD dw;
#endif

    pTBState = GETWINDOWPOINTER(hWnd, PTBSTATE);

    switch (wMsg) {
    case WM_CREATE:

	#define lpcs ((LPCREATESTRUCT)lParam)

        if (!CreateDitherBrush(FALSE))
            return -1;

	if (!InitGlobalObjects()) {
            FreeGlobalObjects();
	    return -1;
        }

	/* create the state data for this toolbar */

	pTBState = ALLOCWINDOWPOINTER(PTBSTATE, sizeof(TBSTATE)-sizeof(TBBUTTON));
	if (!pTBState)
	    return -1;

	/* The struct is initialized to all NULL when created.
	 */
	pTBState->hwndCommand = lpcs->hwndParent;

	pTBState->uStructSize = 0;

	// grow the button size to the appropriate girth
	if (!SetBitmapSize(pTBState, DEFAULTBITMAPX, DEFAULTBITMAPX))
	    return -1;

	SETWINDOWPOINTER(hWnd, PTBSTATE, pTBState);

	if (!(lpcs->style&(CCS_TOP|CCS_NOMOVEY|CCS_BOTTOM)))
	  {
	    lpcs->style |= CCS_TOP;
	    SetWindowLong(hWnd, GWL_STYLE, lpcs->style);
	  }
	break;

    case WM_DESTROY:
	if (pTBState)
	  {
	    PTBBMINFO pTemp;
	    int i;

	    /* Free all the bitmaps before exiting
	     */
	    for (pTemp=pTBState->pBitmaps, i=pTBState->nBitmaps-1; i>=0;
		  ++pTemp, --i)
	      {
		if (pTemp->hInst && pTemp->hbm)
		    DeleteObject(pTemp->hbm);
	      }
	    FlushButtonCache(pTBState);
	    if (pTBState->nStrings > 0)
		DestroyStrings(pTBState);

	    FREEWINDOWPOINTER(pTBState);
	    SETWINDOWPOINTER(hWnd, PTBSTATE, 0);
	  }
	FreeGlobalObjects();
        FreeDitherBrush();
	break;

    case WM_NCCALCSIZE:
#if WINVER >= 0x0400
         /* 
          * This is sent when the window manager wants to find out
          * how big our client area is to be.  If we have a mini-caption
          * then we trap this message and calculate the cleint area rect,
          * which is the client area rect calculated by DefWindowProc()
          * minus the width/height of the mini-caption bar
          */
         // let defwindowproc handle the standard borders etc...

	dw = DefWindowProc(hWnd, wMsg, wParam, lParam ) ;

	if (!(GetWindowLong(hWnd, GWL_STYLE) & CCS_NODIVIDER))
	{
	    NCCALCSIZE_PARAMS FAR *lpNCP;
	    lpNCP = (NCCALCSIZE_PARAMS FAR *)lParam;
	    lpNCP->rgrc[0].top += 2;
	}

        return dw;
#endif
	break;

    case WM_NCACTIVATE:
    case WM_NCPAINT:

#if WINVER >= 0x0400
	// old-style toolbars are forced to be without dividers above
	if (!(GetWindowLong(hWnd, GWL_STYLE) & CCS_NODIVIDER))
	{
	    HDC hdc;
	    RECT rc;

	    hdc = GetWindowDC(hWnd);
	    GetWindowRect(hWnd, &rc);
	    ScreenToClient(hWnd, (LPPOINT)&(rc.left));
	    ScreenToClient(hWnd, (LPPOINT)&(rc.right));
	    rc.bottom = (-rc.top);	// bottom of NC area
	    rc.top = rc.bottom - (2 * GetSystemMetrics(SM_CYBORDER));

	    DrawBorder(hdc, &rc, BDR_SUNKENOUTER, BF_TOP | BF_BOTTOM);
	    ReleaseDC(hWnd, hdc);
	}
	else
            goto DoDefault;
#endif
	break;

    case WM_PAINT:
	ToolbarPaint(hWnd, pTBState);
	break;

#if 0
    case TB_AUTOSIZE:
    case WM_SIZE:
      {
	RECT rc;
	HWND hwndParent;

	GetWindowRect(hWnd, &rc);
	rc.right -= rc.left;
	rc.bottom -= rc.top;

	/* If there is no parent, then this is a top level window
	 */
	hwndParent = GetParent(hWnd);
	if (hwndParent)
	    ScreenToClient(hwndParent, (LPPOINT)&rc);

	NewSize(hWnd, pTBState->iBarHeight, GetWindowLong(hWnd, GWL_STYLE),
              rc.left, rc.top, rc.right, rc.bottom);
	break;
      }
#endif

    case WM_HSCROLL:  //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    case WM_COMMAND:
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
    case WM_VKEYTOITEM:
    case WM_CHARTOITEM:
	SendMessage(pTBState->hwndCommand, wMsg, wParam, lParam);
        break;

    case WM_CTLCOLOR:
        //!!!!! ack use COLOR_BTNFACE
        return (LRESULT)(UINT)GetStockObject(LTGRAY_BRUSH);

#if 0
    case WM_LBUTTONDBLCLK:
        iPos = TBHitTest(pTBState, LOWORD(lParam), HIWORD(lParam));
	if (iPos<0 && (GetWindowLong(hWnd, GWL_STYLE)&CCS_ADJUSTABLE))
	  {
	    iPos = -1 - iPos;
	    CustomizeTB(hWnd, pTBState, iPos);
	  }
	break;
#endif

    case WM_LBUTTONDOWN:

        iPos = TBHitTest(pTBState, LOWORD(lParam), HIWORD(lParam));
#if 0
	if ((wParam&MK_SHIFT) &&(GetWindowLong(hWnd, GWL_STYLE)&CCS_ADJUSTABLE))
	  {
	    MoveButton(hWnd, pTBState, iPos);
	  } else
#endif
	if (iPos >= 0)
	  {
	    ptbButton = pTBState->Buttons + iPos;

	    pTBState->pCaptureButton = ptbButton;
	    SetCapture(hWnd);

	    if (ptbButton->fsState & TBSTATE_ENABLED)
	      {
		ptbButton->fsState |= TBSTATE_PRESSED;
		InvalidateButton(hWnd, pTBState, ptbButton);
		UpdateWindow(hWnd);         // imedeate feedback
	      }

	    SendMessage(pTBState->hwndCommand, WM_COMMAND, GETWINDOWID(hWnd), MAKELONG(pTBState->pCaptureButton->idCommand, TBN_BEGINDRAG));
	  }
	break;

    case WM_MOUSEMOVE:
	// if the toolbar has lost the capture for some reason, stop
	if (hWnd != GetCapture()) {
	    SendMessage(pTBState->hwndCommand, WM_COMMAND, GETWINDOWID(hWnd), 
	    		MAKELONG(pTBState->pCaptureButton->idCommand, TBN_ENDDRAG));
	    // if the button is still pressed, unpress it.
	    if (pTBState->pCaptureButton->fsState & TBSTATE_PRESSED)
	        SendMessage(hWnd, TB_PRESSBUTTON, pTBState->pCaptureButton->idCommand, 0L);
	    pTBState->pCaptureButton = NULL;
	}
	else if (pTBState->pCaptureButton!=NULL
	      && (pTBState->pCaptureButton->fsState & TBSTATE_ENABLED)) {

	    iPos = TBHitTest(pTBState, LOWORD(lParam), HIWORD(lParam));
	    fSameButton = (iPos>=0
		  && pTBState->pCaptureButton==pTBState->Buttons+iPos);
	    if (fSameButton == !(pTBState->pCaptureButton->fsState & TBSTATE_PRESSED)) {
		pTBState->pCaptureButton->fsState ^= TBSTATE_PRESSED;
		InvalidateButton(hWnd, pTBState, pTBState->pCaptureButton);
	    }
	}
	break;

    case WM_LBUTTONUP:
	if (pTBState->pCaptureButton != NULL) {

	    int idCommand;

	    idCommand = pTBState->pCaptureButton->idCommand;

	    ReleaseCapture();

	    SendMessage(pTBState->hwndCommand, WM_COMMAND, GETWINDOWID(hWnd), MAKELONG(idCommand, TBN_ENDDRAG));

	    iPos = TBHitTest(pTBState, LOWORD(lParam), HIWORD(lParam));
	    if ((pTBState->pCaptureButton->fsState&TBSTATE_ENABLED) && iPos>=0
		  && (pTBState->pCaptureButton==pTBState->Buttons+iPos)) {
		pTBState->pCaptureButton->fsState &= ~TBSTATE_PRESSED;

		if (pTBState->pCaptureButton->fsStyle & TBSTYLE_CHECK) {
		    if (pTBState->pCaptureButton->fsStyle & TBSTYLE_GROUP) {

			// group buttons already checked can't be force
			// up by the user.

		        if (pTBState->pCaptureButton->fsState & TBSTATE_CHECKED) {
			    pTBState->pCaptureButton = NULL;
			    break;	// bail!
			}

			pTBState->pCaptureButton->fsState |= TBSTATE_CHECKED;
		        MakeGroupConsistant(hWnd, pTBState, idCommand);
		    } else {
			pTBState->pCaptureButton->fsState ^= TBSTATE_CHECKED; // toggle
		    }
		    // if we change a button's state, we need to flush the
		    // cache
		    FlushButtonCache(pTBState);
		}
		InvalidateButton(hWnd, pTBState, pTBState->pCaptureButton);
		pTBState->pCaptureButton = NULL;
		SendMessage(pTBState->hwndCommand, WM_COMMAND, idCommand, 0L);
	    }
	    else {
		pTBState->pCaptureButton = NULL;
	    }
	}
	break;

    case TB_SETSTATE:
	iPos = PositionFromID(pTBState, (int)wParam);
	if (iPos < 0)
	    return(FALSE);
	ptbButton = pTBState->Buttons + iPos;

	fsState = (BYTE)(LOWORD(lParam) ^ ptbButton->fsState);
        ptbButton->fsState = (BYTE)LOWORD(lParam);

	if (fsState)
	    // flush the button cache
	    //!!!! this could be much more intelligent
	    FlushButtonCache(pTBState);

	if (fsState & TBSTATE_HIDDEN)
	    InvalidateRect(hWnd, NULL, TRUE);
	else if (fsState)
	    InvalidateButton(hWnd, pTBState, ptbButton);
        return(TRUE);

    case TB_GETSTATE:
	iPos = PositionFromID(pTBState, (int)wParam);
	if (iPos < 0)
	    return(-1L);
        return(pTBState->Buttons[iPos].fsState);

    case TB_ENABLEBUTTON:
    case TB_CHECKBUTTON:
    case TB_PRESSBUTTON:
    case TB_HIDEBUTTON:
    case TB_INDETERMINATE:

        iPos = PositionFromID(pTBState, (int)wParam);
	if (iPos < 0)
	    return(FALSE);
        ptbButton = &pTBState->Buttons[iPos];
        fsState = ptbButton->fsState;

        if (LOWORD(lParam))
            ptbButton->fsState |= wStateMasks[wMsg - TB_ENABLEBUTTON];
	else
            ptbButton->fsState &= ~wStateMasks[wMsg - TB_ENABLEBUTTON];

        // did this actually change the state?
        if (fsState != ptbButton->fsState) {
            // is this button a member of a group?
	    if ((wMsg == TB_CHECKBUTTON) && (ptbButton->fsStyle & TBSTYLE_GROUP))
	        MakeGroupConsistant(hWnd, pTBState, (int)wParam);

	    // flush the button cache
	    //!!!! this could be much more intelligent
	    FlushButtonCache(pTBState);

	    if (wMsg == TB_HIDEBUTTON)
		InvalidateRect(hWnd, NULL, TRUE);
	    else
		InvalidateButton(hWnd, pTBState, ptbButton);
        }
        return(TRUE);

    case TB_ISBUTTONENABLED:
    case TB_ISBUTTONCHECKED:
    case TB_ISBUTTONPRESSED:
    case TB_ISBUTTONHIDDEN:
    case TB_ISBUTTONINDETERMINATE:
        iPos = PositionFromID(pTBState, (int)wParam);
	if (iPos < 0)
	    return(-1L);
        return (LRESULT)pTBState->Buttons[iPos].fsState
	      & wStateMasks[wMsg - TB_ISBUTTONENABLED];

    case TB_ADDBITMAP:
	return(AddBitmap(pTBState, wParam,
	      (HINSTANCE)LOWORD(lParam), HIWORD(lParam)));

#if 0	// not needed for MCIWnd
    case TB_ADDSTRING:
	return(AddStrings(pTBState, wParam, lParam));
#endif

    case TB_ADDBUTTONS:
	return(InsertButtons(hWnd, pTBState, (UINT)-1, wParam,
	      (LPTBBUTTON)lParam));

    case TB_INSERTBUTTON:
	return(InsertButtons(hWnd, pTBState, wParam, 1, (LPTBBUTTON)lParam));

    case TB_DELETEBUTTON:
	return(DeleteButton(hWnd, pTBState, wParam));

    case TB_GETBUTTON:
	if (wParam >= (UINT)pTBState->iNumButtons)
	    return(FALSE);

	TBOutputStruct(pTBState, pTBState->Buttons+wParam, (LPTBBUTTON)lParam);
	return(TRUE);

    case TB_BUTTONCOUNT:
	return(pTBState->iNumButtons);

    case TB_COMMANDTOINDEX:
        return(PositionFromID(pTBState, (int)wParam));

#if 0
    case TB_SAVERESTORE:
	return(SaveRestore(hWnd, pTBState, wParam, (LPSTR FAR *)lParam));

    case TB_CUSTOMIZE:
	CustomizeTB(hWnd, pTBState, pTBState->iNumButtons);
	break;
#endif

    case TB_GETITEMRECT:
	return(MAKELRESULT(GetItemRect(pTBState, wParam, (LPRECT)lParam), 0));
	break;

    case TB_BUTTONSTRUCTSIZE:
	/* You are not allowed to change this after adding buttons.
	*/
	if (!pTBState || pTBState->iNumButtons)
	{
		break;
	}
	pTBState->uStructSize = wParam;
	break;

    case TB_SETBUTTONSIZE:
	if (!LOWORD(lParam))
	    lParam = MAKELONG(DEFAULTBUTTONX, HIWORD(lParam));
	if (!HIWORD(lParam))
	    lParam = MAKELONG(LOWORD(lParam), DEFAULTBUTTONY);
	return(GrowToolbar(pTBState, LOWORD(lParam), HIWORD(lParam), FALSE));

    case TB_SETBITMAPSIZE:
	return(SetBitmapSize(pTBState, LOWORD(lParam), HIWORD(lParam)));

    case TB_SETBUTTONTYPE:
	pTBState->wButtonType = wParam;
	break;

    default:
#if WINVER >= 0x0400
DoDefault:
#endif
	return DefWindowProc(hWnd, wMsg, wParam, lParam);
    }

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\mciwnd.16\tracki.h ===
/*
	TrackBar
	
	All the useful information for a trackbar.
*/

typedef struct {
        HWND    hwnd;           // our window handle
        HDC     hdc;            // current DC

        LONG    lLogMin;        // Logical minimum
        LONG    lLogMax;        // Logical maximum
        LONG    lLogPos;        // Logical position

        LONG    lSelStart;      // Logical selection start
        LONG    lSelEnd;        // Logical selection end

        WORD    wThumbWidth;    // Width of the thumb
        WORD    wThumbHeight;   // Height of the thumb

        int     iSizePhys;      // Size of where thumb lives
        RECT    rc;             // track bar rect.

        RECT    Thumb;          // Rectangle we current thumb
        DWORD   dwDragPos;      // Logical position of mouse while dragging.

        WORD    Flags;          // Flags for our window
        int     Timer;          // Our timer.
        WORD    Cmd;            // The command we're repeating.

        int     nTics;          // number of ticks.
        PDWORD  pTics;          // the tick marks.

} TrackBar, *PTrackBar;

// Trackbar flags

#define TBF_NOTHUMB     0x0001  // No thumb because not wide enough.
#define TBF_SELECTION   0x0002  // a selection has been established (draw the range)

/*
	useful constants.
*/

#define REPEATTIME      500     // mouse auto repeat 1/2 of a second
#define TIMER_ID        1

#define	GWW_TRACKMEM		0 /* handle to track bar memory */
#define EXTRA_TB_BYTES          sizeof(PTrackBar) /* Total extra bytes.         */

/*
	Useful defines.
*/

#define TrackBarCreate(hwnd)    SetWindowWord(hwnd,GWW_TRACKMEM,(WORD)LocalAlloc(LPTR,sizeof(TrackBar)))
#define TrackBarDestroy(hwnd)   LocalFree((HLOCAL)GetWindowWord(hwnd,GWW_TRACKMEM))
#define TrackBarLock(hwnd)      (PTrackBar)GetWindowWord(hwnd,GWW_TRACKMEM)

/*
	Function Prototypes
*/

static void   NEAR PASCAL DoTrack(PTrackBar, int, DWORD);
static WORD   NEAR PASCAL WTrackType(PTrackBar, LONG);
static void   NEAR PASCAL TBTrackInit(PTrackBar, LONG);
static void   NEAR PASCAL TBTrackEnd(PTrackBar, LONG);
static void   NEAR PASCAL TBTrack(PTrackBar, LONG);
static void   NEAR PASCAL DrawThumb(PTrackBar);
static HBRUSH NEAR PASCAL SelectColorObjects(PTrackBar, BOOL);
static void   NEAR PASCAL SetTBCaretPos(PTrackBar);

extern DWORD FAR PASCAL lMulDiv32(DWORD, DWORD, DWORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msrle\profile.h ===
/*
 * AVICAP32:
 *
 * utility functions to read and write values to the profile,
 * using win.ini for Win16/Win95 or current
 * the registry for Win32 NT.  (Trivial to change to registry for Win95)
 *
 * The only routine that AVICAP32 uses is GetProfileIntA
 */

#if defined(_WIN32) && defined(UNICODE)

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
UINT mmGetProfileIntA(LPCSTR appname, LPCSTR valuename, INT uDefault);

// Now map all instances of GetProfileIntA to mmGetProfileIntA
#define GetProfileIntA mmGetProfileIntA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msrle\drvproc.c ===
/****************************************************************************
 *
 *   drvproc.c
 *
 ***************************************************************************/
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1991 - 1995 Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>

#ifndef _INC_COMPDDK
#define _INC_COMPDDK    50      /* version number */
#endif

#include <vfw.h>
#include "msrle.h"

HMODULE ghModule;

/***************************************************************************
 * @doc INTERNAL
 *
 * @api LRESULT | DriverProc | The entry point for an installable driver.
 *
 * @parm DWORD | dwDriverId | For most messages, <p dwDriverId> is the DWORD
 *     value that the driver returns in response to a <m DRV_OPEN> message.
 *     Each time that the driver is opened, through the <f DrvOpen> API,
 *     the driver receives a <m DRV_OPEN> message and can return an
 *     arbitrary, non-zero value. The installable driver interface
 *     saves this value and returns a unique driver handle to the
 *     application. Whenever the application sends a message to the
 *     driver using the driver handle, the interface routes the message
 *     to this entry point and passes the corresponding <p dwDriverId>.
 *     This mechanism allows the driver to use the same or different
 *     identifiers for multiple opens but ensures that driver handles
 *     are unique at the application interface layer.
 *
 *     The following messages are not related to a particular open
 *     instance of the driver. For these messages, the dwDriverId
 *     will always be zero.
 *
 *         DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
 *
 * @parm HDRVR | hDriver | This is the handle returned to the
 *     application by the driver interface.
 *
 * @parm UINT | uiMessage | The requested action to be performed. Message
 *     values below <m DRV_RESERVED> are used for globally defined messages.
 *     Message values from <m DRV_RESERVED> to <m DRV_USER> are used for
 *     defined driver protocols. Messages above <m DRV_USER> are used
 *     for driver specific messages.
 *
 * @parm LPARAM | lParam1 | Data for this message.  Defined separately for
 *     each message
 *
 * @parm LPARAM | lParam2 | Data for this message.  Defined separately for
 *     each message
 *
 * @rdesc Defined separately for each message.
 ***************************************************************************/

LRESULT FAR PASCAL _loadds DriverProc(DWORD_PTR dwDriverID, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2)
{
    PRLEINST pri = dwDriverID != -1 ? (PRLEINST)dwDriverID : NULL;

    switch (uiMessage)
    {
        case DRV_LOAD:
#ifdef _WIN32
            if (ghModule) {
                // AVI explicitly loads us as well, but does not pass the
                // correct (as known by WINMM) driver handle.
            } else {
                ghModule = (HANDLE) GetDriverModuleHandle(hDriver);
            }
#endif
            RleLoad();
	    return (LRESULT)1L;

	case DRV_FREE:
            RleFree();
	    return (LRESULT)1L;

	case DRV_OPEN:
	    // if being opened with no open struct, then return a non-zero
            // value without actually opening

	    if (lParam2 == 0L)
                return -1l;

            return (LRESULT)(DWORD_PTR)(UINT_PTR)RleOpen();

	case DRV_CLOSE:
            if (pri)
                RleClose(pri);

	    return (LRESULT)1L;

	/*********************************************************************

	    state messages

	*********************************************************************/

	case ICM_GETSTATE:
            return RleGetState(pri, (LPVOID)lParam1, (DWORD)lParam2);

	case ICM_SETSTATE:
            return RleSetState(pri, (LPVOID)lParam1, (DWORD)lParam2);

	case ICM_GETINFO:
            return RleGetInfo(pri, (ICINFO FAR *)lParam1, (DWORD)lParam2);

        case ICM_GETDEFAULTQUALITY:
            if (lParam1)
            {
                *((LPDWORD)lParam1) = QUALITY_DEFAULT;
                return ICERR_OK;
            }
            break;
	
	/*********************************************************************

	    compression messages

	*********************************************************************/

	case ICM_COMPRESS_QUERY:
            return RleCompressQuery(pri,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_COMPRESS_BEGIN:
            return RleCompressBegin(pri,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_COMPRESS_GET_FORMAT:
            return RleCompressGetFormat(pri,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_COMPRESS_GET_SIZE:
            return RleCompressGetSize(pri,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);
	
	case ICM_COMPRESS:
            return RleCompress(pri,
			    (ICCOMPRESS FAR *)lParam1, (DWORD)lParam2);

	case ICM_COMPRESS_END:
            return RleCompressEnd(pri);
	
	/*********************************************************************

	    decompress messages

	*********************************************************************/

	case ICM_DECOMPRESS_QUERY:
            return RleDecompressQuery(pri,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_DECOMPRESS_BEGIN:
            return RleDecompressBegin(pri,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_DECOMPRESS_GET_FORMAT:
            return RleDecompressGetFormat(pri,
			 (LPBITMAPINFOHEADER)lParam1,
                         (LPBITMAPINFOHEADER)lParam2);

	case ICM_DECOMPRESS:
            return RleDecompress(pri,
			 (ICDECOMPRESS FAR *)lParam1, (DWORD)lParam2);

	case ICM_DECOMPRESS_END:
            return RleDecompressEnd(pri);

	/*********************************************************************

	    standard driver messages

	*********************************************************************/

	case DRV_DISABLE:
	case DRV_ENABLE:
	    return (LRESULT)1L;

	case DRV_INSTALL:
	case DRV_REMOVE:
	    return (LRESULT)DRV_OK;
    }

    if (uiMessage < DRV_USER)
        return DefDriverProc(dwDriverID, hDriver, uiMessage,lParam1,lParam2);
    else
	return ICERR_UNSUPPORTED;
}

/****************************************************************************
 * @doc INTERNAL
 *
 * @api int | LibMain | Library initialization code.
 *
 * @parm HANDLE | hModule | Our module handle.
 *
 * @parm WORD | wHeapSize | The heap size from the .def file.
 *
 * @parm LPSTR | lpCmdLine | The command line.
 *
 * @rdesc Returns 1 if the initialization was successful and 0 otherwise.
 ***************************************************************************/
#ifndef _WIN32
int NEAR PASCAL LibMain(HMODULE hModule, WORD wHeapSize, LPSTR lpCmdLine)
{
    ghModule = hModule;

    return 1;
}
#endif

#if 0 // NO DLL load proc needed
    // NOTE: ghModule Will be set up on DRV_LOAD call
#ifdef _WIN32

BOOL WINAPI DLLEntryPoint(HINSTANCE hModule, ULONG Reason, LPVOID pv)
{
    switch (Reason)
    {
        case DLL_PROCESS_ATTACH:
	    ghModule = hModule;
            DisableThreadLibraryCalls(hModule);
            break;

        case DLL_PROCESS_DETACH:
            break;
    }
    return TRUE;
}

#endif
#endif  // if 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msrle\msrle.h ===
/*--------------------------------------------------------------------------*\
|									     |
|   MSRLE.H								     |
\*--------------------------------------------------------------------------*/

 /**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1991 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/

#ifdef _WIN32
#define huge

// NT and WIN95 use different debug switches.
// NT defines DBG to be 0 or 1
// Win95 defines DEBUG, or does not define it
// Map one methodology to the other

#ifndef DBG
#ifdef DEBUG
    #define DBG 1
#else
    #define DBG 0
#endif
#endif

#undef DEBUG

#if DBG
    #define DEBUG
    #define STATICFN
    #define STATICDT
#else
    #define STATICFN static
    #define STATICDT static
#endif
#endif

//
// compressor state info
//
typedef struct {
    long	lMinFrameSize;
    long        lMaxFrameSize;
    long        tolTemporal;
    long        tolSpatial;
    long        tolMax;
    int         iMaxRunLen;
} RLESTATE, FAR *LPRLESTATE, *PRLESTATE;

typedef struct {
    LPVOID	lpbiPrev;
    int         iStart;
    long        lLastParm;
    long	lFrames;
    RLESTATE    RleState;
    BOOL        fCompressBegin;
    BOOL        fDecompressBegin;
} RLEINST, *PRLEINST;

#define BI_DIBX     0x78626964l     // 'dibx'
#define BI_DIBC     0x63626964l     // 'dibc'

#define QUALITY_DEFAULT     8500

#define IDS_DESCRIPTION 42
#define IDS_NAME        43

extern HMODULE ghModule;

/****************************************************************************
 ***************************************************************************/

#ifdef _INC_COMPDDK

void       NEAR PASCAL RleLoad(void);
void       NEAR PASCAL RleFree(void);
PRLEINST   NEAR PASCAL RleOpen(void);
DWORD      NEAR PASCAL RleClose(PRLEINST pri);
DWORD      NEAR PASCAL RleGetState(PRLEINST pri, LPVOID pv, DWORD dwSize);
DWORD      NEAR PASCAL RleSetState(PRLEINST pri, LPVOID pv, DWORD dwSize);

DWORD      NEAR PASCAL RleGetInfo(PRLEINST pri, ICINFO FAR *icinfo, DWORD dwSize);

DWORD      NEAR PASCAL RleCompressBegin(PRLEINST pri, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD      NEAR PASCAL RleCompressQuery(PRLEINST pri, LPBITMAPINFOHEADER lpbiIn,LPBITMAPINFOHEADER lpbiOut);
DWORD      NEAR PASCAL RleCompressGetFormat(PRLEINST pri, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD      NEAR PASCAL RleCompress(PRLEINST pri,ICCOMPRESS FAR *icinfo, DWORD dwSize);
DWORD      NEAR PASCAL RleCompressGetSize(PRLEINST pri, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD      NEAR PASCAL RleCompressEnd(PRLEINST lpri);

DWORD      NEAR PASCAL RleDecompressBegin(PRLEINST pri, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD      NEAR PASCAL RleDecompressQuery(PRLEINST pri, LPBITMAPINFOHEADER lpbiIn,LPBITMAPINFOHEADER lpbiOut);
DWORD      NEAR PASCAL RleDecompressGetFormat(PRLEINST pri, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
DWORD      NEAR PASCAL RleDecompress(PRLEINST pri,ICDECOMPRESS FAR *icinfo, DWORD dwSize);
DWORD      NEAR PASCAL RleDecompressEnd(PRLEINST pri);

#endif

/****************************************************************************
 ***************************************************************************/

BOOL FAR PASCAL CrunchDib(PRLEINST pri,
                            LPBITMAPINFOHEADER lpbiRle, LPVOID lpRle,
                            LPBITMAPINFOHEADER lpbiPrev,LPVOID lpPrev,
                            LPBITMAPINFOHEADER lpbiDib, LPVOID lpDib);

BOOL FAR PASCAL SplitDib (PRLEINST pri,
                            LPBITMAPINFOHEADER lpbiRle, LPVOID lpRle,
                            LPBITMAPINFOHEADER lpbiPrev,LPVOID lpPrev,
                            LPBITMAPINFOHEADER lpbiDib, LPVOID lpDib);

//#define MAXSUMSQUARES               195075L
#define MAXTOL                      0x00FFFFFFL
#define ADAPTIVE                    -1
#define NO_LIMIT                    -1

/****************************************************************************
 ***************************************************************************/

/* RgbTol Table structure */

typedef struct {
        int             ClrUsed;
        RGBQUAD         argbq[256];
	DWORD huge	*hpTable;
} RGBTOL;

extern RGBTOL gRgbTol;

/* Public functions anyone can call */

BOOL FAR PASCAL RleDeltaFrame(
        LPBITMAPINFOHEADER  lpbiRle,    LPBYTE pbRle,
        LPBITMAPINFOHEADER  lpbiPrev,   LPBYTE pbPrev,
        LPBITMAPINFOHEADER  lpbiDib,    LPBYTE pbDib,
        int         iStart,
        int         iLen,
        long        tolTemporal,
        long        tolSpatial,
        int         maxRun,
        int         minJump);

BOOL NEAR PASCAL MakeRgbTable(LPBITMAPINFOHEADER lpbi);

void NEAR PASCAL DecodeRle(LPBITMAPINFOHEADER lpbi, LPVOID pb, LPVOID prle, DWORD dwSize);
#ifndef _WIN32
void NEAR PASCAL DecodeRle386(LPBITMAPINFOHEADER lpbi, LPVOID pb, LPVOID prle);
void NEAR PASCAL DecodeRle286(LPBITMAPINFOHEADER lpbi, LPVOID pb, LPVOID prle);
#endif

// in DF.ASM

#ifndef _WIN32
extern void FAR PASCAL DeltaFrame386(
    LPBITMAPINFOHEADER  lpbi,
    LPVOID              pbPrev,
    LPVOID              pbDib,
    LPVOID		pbRle,
    WORD		MaxRunLength,
    WORD		MinJumpLength,
    LPVOID              TolTable,
    DWORD               tolTemporal,
    DWORD               tolSpatial);
#else
extern void DeltaFrameC(
    LPBITMAPINFOHEADER  lpbi,
    LPBYTE              pbPrev,
    LPBYTE              pbDib,
    LPBYTE		pbRle,
    UINT		MaxRunLength,
    UINT		MinJumpLength,
    LPDWORD             TolTable,
    DWORD               tolTemporal,
    DWORD               tolSpatial);
#endif

/****************************************************************************
 DIB macros.
 ***************************************************************************/

#define WIDTHBYTES(i)           ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */

#define DibWidthBytesN(lpbi, n) (UINT)WIDTHBYTES((UINT)(lpbi)->biWidth * (UINT)(n))
#define DibWidthBytes(lpbi)     DibWidthBytesN(lpbi, (lpbi)->biBitCount)

#define DibSizeImage(lpbi)      ((lpbi)->biSizeImage == 0 \
                                    ? ((DWORD)(UINT)DibWidthBytes(lpbi) * (DWORD)(UINT)(lpbi)->biHeight) \
                                    : (lpbi)->biSizeImage)

// Use when biSizeImage is known to be correct (e.g. after FixBitmapInfo)
#define DibSizeImageX(lpbi)     ((lpbi)->biSizeImage)

#define DibSize(lpbi)           ((lpbi)->biSize + (lpbi)->biSizeImage + (int)(lpbi)->biClrUsed * sizeof(RGBQUAD))
#define DibPaletteSize(lpbi)    (DibNumColors(lpbi) * sizeof(RGBQUAD))

#define DibPtr(lpbi)            (LPVOID)(DibColors(lpbi) + (UINT)(lpbi)->biClrUsed)
#define DibColors(lpbi)         ((LPRGBQUAD)((LPBYTE)(lpbi) + (int)(lpbi)->biSize))

#define DibNumColors(lpbi)      ((lpbi)->biClrUsed == 0 && (lpbi)->biBitCount <= 8 \
                                    ? (int)(1 << (int)(lpbi)->biBitCount)          \
                                    : (int)(lpbi)->biClrUsed)

#define DibXYN(lpbi,pb,x,y,n)   (LPVOID)(                                     \
                                (LPBYTE)(pb) +                                 \
                                (UINT)((UINT)(x) * (UINT)(n) / 8u) +          \
                                ((DWORD)DibWidthBytesN(lpbi,n) * (DWORD)(UINT)(y)))

#define DibXY(lpbi,x,y)         DibXYN(lpbi,DibPtr(lpbi),x,y,(lpbi)->biBitCount)


#define FixBitmapInfo(lpbi)     if ((lpbi)->biSizeImage == 0)                 \
                                    (lpbi)->biSizeImage = DibSizeImage(lpbi); \
                                if ((lpbi)->biClrUsed == 0)                   \
                                    (lpbi)->biClrUsed = DibNumColors(lpbi);



/****************************************************************************
 ***************************************************************************/

#ifdef DEBUG
    extern void FAR CDECL dprintf(LPSTR, ...);
    #define DPF(_x_) dprintf _x_
#else
    #define DPF ; / ## /
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msrle\msrle.c ===
/*--------------------------------------------------------------------------*\
|   RLECIF.C - Interface to RLE Comressor                                    |
|//@@BEGIN_MSINTERNAL									      |
|   History:                                                                 |
|   01/01/88 toddla     Created                                              |
|   10/30/90 davidmay   Reorganized, rewritten somewhat.                     |
|   07/11/91 dannymi    Un-hacked                                            |
|   09/15/91 ToddLa     Re-hacked                                            |
|   09/18/91 DavidMay	Separated from RLEC.C				     |
|   06/01/92 ToddLa     Moved into a installable compressor                  |
|//@@END_MSINTERNAL									      |
|                                                                            |
\*--------------------------------------------------------------------------*/
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1991 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/

//@@BEGIN_MSINTERNAL									      |
#ifndef _WIN32
#include <win32.h>
#endif
//@@END_MSINTERNAL									      |
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>

#ifndef _INC_COMPDDK
#define _INC_COMPDDK    50      /* version number */
#endif

#include <vfw.h>
#include "msrle.h"
#include <stdarg.h>

//@@BEGIN_MSINTERNAL									      |
#ifdef UNICODE
#include "profile.h"   // map to registry for NT
#endif
//@@END_MSINTERNAL									      |

RLESTATE DefaultRleState = {0, 0, -1, 187, 1500, 4};

#define FOURCC_DIB      mmioFOURCC('D','I','B',' ')
#define FOURCC_RLE      mmioFOURCC('M','R','L','E') //mmioFOURCC('R','L','E',' ')
			
#define TWOCC_DIB       aviTWOCC('d','b')
#define TWOCC_RLE       aviTWOCC('d','c')
#define TWOCC_DIBX      aviTWOCC('d','x')

/****************************************************************************
****************************************************************************/

#pragma optimize("", off)

static BOOL NEAR PASCAL IsApp(LPTSTR szApp)
{
    TCHAR ach[128];
    int  i;
    HINSTANCE hInstance;

#ifdef _WIN32
    hInstance = GetModuleHandle(NULL);
#else
    _asm mov hInstance,ss
#endif

    GetModuleFileName(hInstance, ach, sizeof(ach) / sizeof(ach[0]));

    for (i = lstrlen(ach);
        i > 0 && ach[i-1] != '\\' && ach[i-1] != '/' && ach[i] != ':';
        i--)
        ;

    return lstrcmpi(ach + i, szApp) == 0;
}
#pragma optimize("", on)

/*****************************************************************************
 ****************************************************************************/
//
//  RleLoad()
//
void NEAR PASCAL RleLoad()
{
}

/*****************************************************************************
 ****************************************************************************/
//
//  RleFree()
//
void NEAR PASCAL RleFree()
{
    if (gRgbTol.hpTable)
        GlobalFreePtr(gRgbTol.hpTable);

    gRgbTol.hpTable = NULL;
}

/*****************************************************************************
 ****************************************************************************/

//
//  RleOpen()   - open a instance of the rle compressor
//
PRLEINST NEAR PASCAL RleOpen()
{
    PRLEINST pri;

    //
    //  VIDEDIT Hack
    //
    //  we dont want to see two "Microsoft RLE" compressors.
    //  so lie to VidEdit and fail to open.
    //

    if (GetModuleHandle(TEXT("MEDDIBS")) && IsApp(TEXT("VIDEDIT.EXE")))
        return NULL;

    pri = (PRLEINST)LocalAlloc(LPTR, sizeof(RLEINST));

    if (pri)
    {
        RleSetState(pri, NULL, 0);
    }
    return pri;
}

/*****************************************************************************
 ****************************************************************************/
//
//  RleClose()   - close a instance of the rle compressor
//
DWORD NEAR PASCAL RleClose(PRLEINST pri)
{
    if (!pri)
        return FALSE;

    if (pri->lpbiPrev) {
        GlobalFreePtr(pri->lpbiPrev);
	pri->lpbiPrev = NULL;
    }

    LocalFree((LOCALHANDLE)pri);
    return TRUE;
}

/*****************************************************************************
 ****************************************************************************/
//
//  RleGetState()   - get the current state of the rle compressor
//
//  will copy current state into passed buffer.
//  returns the size in bytes required to store the entire state.
//
DWORD NEAR PASCAL RleGetState(PRLEINST pri, LPVOID pv, DWORD dwSize)
{
    if (pv == NULL || dwSize == 0)
        return sizeof(RLESTATE);

    if (pri == NULL || dwSize < sizeof(RLESTATE))
        return 0;

    *(LPRLESTATE)pv = pri->RleState;
    return sizeof(RLESTATE);
}

/*****************************************************************************
 ****************************************************************************/
//
//  RleSetState()   - sets the current state of the rle compressor
//
DWORD NEAR PASCAL RleSetState(PRLEINST pri, LPVOID pv, DWORD dwSize)
{
    if (pv == NULL || dwSize == 0)
    {
        pv = &DefaultRleState;
        dwSize = sizeof(RLESTATE);
    }

    if (pri == NULL || dwSize < sizeof(RLESTATE))
        return 0;

    pri->RleState = *(LPRLESTATE)pv;
    return sizeof(RLESTATE);
}

#if !defined NUMELMS
 #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

#if defined _WIN32 && !defined UNICODE

int LoadUnicodeString(HINSTANCE hinst, UINT wID, LPWSTR lpBuffer, int cchBuffer)
{
    char    ach[128];
    int	    i;

    i = LoadString(hinst, wID, ach, sizeof(ach));

    if (i > 0)
	MultiByteToWideChar(CP_ACP, 0, ach, -1, lpBuffer, cchBuffer);

    return i;
}

#else
#define LoadUnicodeString   LoadString
#endif


/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL RleGetInfo(PRLEINST pri, ICINFO FAR *icinfo, DWORD dwSize)
{
    if (icinfo == NULL)
        return sizeof(ICINFO);

    if (dwSize < sizeof(ICINFO))
        return 0;

    icinfo->dwSize      = sizeof(ICINFO);
    icinfo->fccType     = ICTYPE_VIDEO;
    icinfo->fccHandler  = FOURCC_RLE;
    icinfo->dwFlags     = VIDCF_QUALITY   |  // supports quality
                          VIDCF_TEMPORAL  |  // supports inter-frame
                          VIDCF_CRUNCH;      // can crunch to a data rate
    icinfo->dwVersion   = ICVERSION;

    LoadUnicodeString(ghModule, IDS_DESCRIPTION, icinfo->szDescription, NUMELMS(icinfo->szDescription));
    LoadUnicodeString(ghModule, IDS_NAME, icinfo->szName, NUMELMS(icinfo->szName));

    return sizeof(ICINFO);
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL RleCompressQuery(PRLEINST pri, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    //
    // determine if the input DIB data is in a format we like.
    //
    if (lpbiIn == NULL ||
        lpbiIn->biBitCount != 8 ||
        lpbiIn->biCompression != BI_RGB)
        return (DWORD)ICERR_BADFORMAT;

    //
    //  are we being asked to query just the input format?
    //
    if (lpbiOut == NULL)
        return ICERR_OK;

    //
    // make sure we can handle the format to compress to also.
    //
    if (lpbiOut->biCompression != BI_RLE8 ||        // must be rle format
        lpbiOut->biBitCount != 8 ||                 // must be 8bpp
        lpbiOut->biWidth  != lpbiIn->biWidth ||     // must be 1:1 (no stretch)
        lpbiOut->biHeight != lpbiIn->biHeight)
        return (DWORD)ICERR_BADFORMAT;

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL RleCompressGetFormat(PRLEINST pri, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    DWORD dw;
    DWORD dwClrUsed;

    if (dw = RleCompressQuery(pri, lpbiIn, NULL))
        return dw;

    dwClrUsed = lpbiIn->biClrUsed;
    if (dwClrUsed == 0) {
        dwClrUsed = 256;
    }
    dw = lpbiIn->biSize + (int)dwClrUsed * sizeof(RGBQUAD);

    //
    // if lpbiOut == NULL then, return the size required to hold a output
    // format
    //
    if (lpbiOut == NULL)
        return dw;

    hmemcpy(lpbiOut, lpbiIn, dw);

    lpbiOut->biBitCount    = 8;
    lpbiOut->biCompression = BI_RLE8;
    lpbiOut->biSizeImage   = RleCompressGetSize(pri, lpbiIn, lpbiOut);

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL RleCompressBegin(PRLEINST pri, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    DWORD dw;

    if (dw = RleCompressQuery(pri, lpbiIn, lpbiOut))
        return dw;

    if (pri->lpbiPrev) {
        GlobalFreePtr(pri->lpbiPrev);
	pri->lpbiPrev = NULL;
    }

    pri->iStart = 0;
    pri->lLastParm = 0L;

    pri->fCompressBegin = TRUE;

    MakeRgbTable(lpbiIn);

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL RleCompressGetSize(PRLEINST pri, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    int dx,dy;

    //
    // we assume RLE data will never be twice the size of a full frame.
    //
    dx = (int)lpbiIn->biWidth;
    dy = (int)lpbiIn->biHeight;

    return (DWORD)(UINT)dx * (DWORD)(UINT)dy * 2;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL RleCompress(PRLEINST pri, ICCOMPRESS FAR *icinfo, DWORD dwSize)
{
    DWORD dw;
    BOOL  fFrameHalvingOccurred = FALSE;

    LPBITMAPINFOHEADER lpbi;

    if (!pri->fCompressBegin)
    {
        if (dw = RleCompressBegin(pri, icinfo->lpbiInput, icinfo->lpbiOutput))
            return dw;

        pri->fCompressBegin = FALSE;
    }

    //
    //  we can compress in one of two ways:
    //
    //      if a frame size is given (>0) then call CrunchDib using the passed
    //      quality as the "frame half" setting.
    //
    //      if a frame size is not given (==0) then use the passed quality
    //      as the tolerance and do a normal RleDeltaFrame()
    //

    if (icinfo->dwQuality == ICQUALITY_DEFAULT)
        icinfo->dwQuality = QUALITY_DEFAULT;

    if (icinfo->dwFrameSize > 0)
    {
        dw = ICQUALITY_HIGH - icinfo->dwQuality;

        pri->RleState.lMaxFrameSize = icinfo->dwFrameSize;
        pri->RleState.lMinFrameSize = icinfo->dwFrameSize - 500;
        pri->RleState.tolMax        = dw;
        pri->RleState.tolSpatial    = dw / 8;
        pri->RleState.tolTemporal   = ADAPTIVE;

// SplitDib makes really ugly artifacts by splitting the frame into who knows
// how many pieces which will be pieced together like a bad jigsaw puzzle where
// each piece is from a different picture.  I decided never to use this method
// of compression.
#if 0
        if (dw == 0)
        {
            pri->RleState.tolSpatial  = 0;
            pri->RleState.tolTemporal = 0;

            SplitDib(pri,
                icinfo->lpbiOutput, icinfo->lpOutput,
                icinfo->lpbiPrev,   icinfo->lpPrev,
                icinfo->lpbiInput,  icinfo->lpInput);
        }
        else
#endif
        {
            CrunchDib(pri,
                icinfo->lpbiOutput, icinfo->lpOutput,
                icinfo->lpbiPrev,   icinfo->lpPrev,
                icinfo->lpbiInput,  icinfo->lpInput);
        }

        lpbi = icinfo->lpbiOutput;

        if (lpbi->biCompression == BI_DIBX)
            fFrameHalvingOccurred = TRUE;

        if (icinfo->lpckid)
        {
            if (fFrameHalvingOccurred)
                *icinfo->lpckid = TWOCC_DIBX;
            else
                *icinfo->lpckid = TWOCC_RLE;
        }

        lpbi->biCompression = BI_RLE8;      // biSizeImage is filled in
    }
    else
    {
        dw = ICQUALITY_HIGH - icinfo->dwQuality;

        pri->RleState.tolSpatial    = dw;
        pri->RleState.tolTemporal   = dw / 8;

        RleDeltaFrame(
            icinfo->lpbiOutput, icinfo->lpOutput,
            icinfo->lpbiPrev,   icinfo->lpPrev,
            icinfo->lpbiInput,  icinfo->lpInput,
            0,-1,
	    pri->RleState.tolTemporal,
	    pri->RleState.tolSpatial,
	    pri->RleState.iMaxRunLen,4);

        if (icinfo->lpckid)
            *icinfo->lpckid = TWOCC_RLE;
    }

    //
    // set the AVI index flags,
    //
    //    make it a keyframe, if no previous frame
    //
    if (icinfo->lpdwFlags) {
        if (icinfo->lpbiPrev == NULL && !fFrameHalvingOccurred)
            *icinfo->lpdwFlags |= AVIIF_TWOCC | AVIIF_KEYFRAME;
        else
            *icinfo->lpdwFlags |= AVIIF_TWOCC;
    }

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL RleCompressEnd(PRLEINST pri)
{
    pri->fCompressBegin = FALSE;
    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL RleDecompressQuery(RLEINST * pri, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    //
    // determine if the input DIB data is in a format we like.
    // We like all RGB.  We like 8bit RLE.
    //
    if (lpbiIn == NULL ||
	  (lpbiIn->biBitCount != 8 && lpbiIn->biCompression == BI_RLE8) ||
          (lpbiIn->biCompression != BI_RGB && lpbiIn->biCompression != BI_RLE8))
	return (DWORD)ICERR_BADFORMAT;

    //
    //  are we being asked to query just the input format?
    //
    if (lpbiOut == NULL)
	return ICERR_OK;

    //
    // make sure we can handle the format to decompress too.
    //
    if (lpbiOut->biCompression != BI_RGB ||         // must be full dib
	lpbiOut->biBitCount != lpbiIn->biBitCount ||// must match
	lpbiOut->biWidth  != lpbiIn->biWidth ||     // must be 1:1 (no stretch)
	lpbiOut->biHeight != lpbiIn->biHeight)
	return (DWORD)ICERR_BADFORMAT;

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL RleDecompressGetFormat(RLEINST * pri, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    DWORD dw;

    if (dw = RleDecompressQuery(pri, lpbiIn, NULL))
        return dw;

    dw = lpbiIn->biSize + (int)lpbiIn->biClrUsed * sizeof(RGBQUAD);

    //
    // if lpbiOut == NULL then, return the size required to hold a output
    // format
    //
    if (lpbiOut == NULL)
        return dw;

    hmemcpy(lpbiOut, lpbiIn, dw);

    lpbiOut->biBitCount    = lpbiIn->biBitCount;
    lpbiOut->biCompression = BI_RGB;
    lpbiOut->biSizeImage   = lpbiIn->biHeight * DibWidthBytes(lpbiIn);

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL RleDecompressBegin(RLEINST * pri, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    DWORD dw;

    if (dw = RleDecompressQuery(pri, lpbiIn, lpbiOut))
        return dw;

    pri->fDecompressBegin = TRUE;

    // Make sure we know the size of an uncompressed DIB
    if (lpbiOut->biSizeImage == 0)
	lpbiOut->biSizeImage = lpbiOut->biHeight * DibWidthBytes(lpbiOut);

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL RleDecompress(RLEINST * pri, ICDECOMPRESS FAR *icinfo, DWORD dwSize)
{
    DWORD dw;

    if (!pri->fDecompressBegin)
    {
        if (dw = RleDecompressBegin(pri, icinfo->lpbiInput, icinfo->lpbiOutput))
            return dw;

        pri->fDecompressBegin = FALSE;
    }

    //
    //  handle a decompress of 'DIB ' (ie full frame) data.  Just return it.
    //  It may be disguised an an RLE.  We can tell by how big it is
    //
    if (icinfo->lpbiInput->biCompression == BI_RGB ||
	icinfo->lpbiInput->biSizeImage == icinfo->lpbiOutput->biSizeImage)
    {
        hmemcpy(icinfo->lpOutput, icinfo->lpInput,
			icinfo->lpbiInput->biSizeImage);
        return ICERR_OK;
    }

    DecodeRle(icinfo->lpbiOutput, icinfo->lpOutput, icinfo->lpInput, icinfo->lpbiInput->biSizeImage);

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
DWORD NEAR PASCAL RleDecompressEnd(RLEINST * pri)
{
    pri->fDecompressBegin = FALSE;
    return ICERR_OK;
}

/***************************************************************************

  DecodeRle   - 'C' version

  Play back a RLE buffer into a DIB buffer

  returns
      none

 ***************************************************************************/

void NEAR PASCAL DecodeRle(LPBITMAPINFOHEADER lpbi, LPVOID lp, LPVOID lpRle, DWORD dwInSize)
{
    UINT    cnt;
    BYTE    b;
    UINT    x;		
    UINT    dx,dy;
    UINT    wWidthBytes;
    DWORD   dwOutSize;
    DWORD   dwJump;

    #define RLE_ESCAPE  0
    #define RLE_EOL     0
    #define RLE_EOF     1
    #define RLE_JMP     2
    #define RLE_RUN     3

#ifndef _WIN32
    extern FAR PASCAL __WinFlags;
    #define WinFlags (UINT)(&__WinFlags)
    //
    // this uses ASM code found in RLEA.ASM
    //
    if (!(WinFlags & WF_CPU286))
        DecodeRle386(lpbi, lp, lpRle);
    else if (lpbi->biSizeImage < 65536l)
	DecodeRle286(lpbi, lp, lpRle);
    else
#endif
    {
        BYTE _huge *pb   = lp;
        BYTE _huge *prle = lpRle;

#define EatOutput(_x_) \
    {                            \
        if (dwOutSize < (_x_)) { \
            return;              \
        }                        \
        dwOutSize -= (_x_);      \
    }
#define EatInput(_x_) \
    {                            \
        if (dwInSize < (_x_)) {  \
            return;              \
        }                        \
        dwInSize -= (_x_);       \
    }

    if (lpbi->biHeight <= 0) {
        return;
    }
        wWidthBytes = (UINT)lpbi->biWidth+3 & ~3;
        dwOutSize = wWidthBytes * (DWORD)lpbi->biHeight;

	x = 0;

	for (;;)
	{
            EatInput(2);
	    cnt = (UINT)*prle++;
	    b   = *prle++;

	    if (cnt == RLE_ESCAPE)
	    {
		switch (b)
		{
		    case RLE_EOF:
			return;

                    case RLE_EOL:
                        EatOutput(wWidthBytes - x);
			pb += wWidthBytes - x;
			x = 0;
			break;

                    case RLE_JMP:
                        EatInput(2);
			dx = (UINT)*prle++;
			dy = (UINT)*prle++;

                        dwJump = (DWORD)wWidthBytes * dy + dx;
                        EatOutput(dwJump);
			pb += dwJump;
			x  += dx;

			break;

		    default:
			cnt = b;
                        EatOutput(cnt);
                        EatInput(cnt);
			x  += cnt;
        		// If the count was sufficiently large it would be worthwhile
        		// using an inline memcpy function.  The code could
        		// be faster.  Even doing this as a series of word
        		// moves would be quicker.  However, RLE is not the highest
        		// priority.
			while (cnt-- > 0)
			    *pb++ = *prle++;   // copy

			if (b & 1) {
                            EatInput(1);
			    prle++;
                        }

			break;
		}
	    }
	    else
	    {
		x += cnt;

		// If the count was sufficiently large it would be worthwhile
		// using an inline memset function.  The code could
		// be faster.  Even doing this as a series of word
		// moves would be quicker.  However, RLE is not the highest
		// priority.
#if 1
		// at least on the x86... this way persuades the compiler
		// to use registers more effectively through the whole of
		// the decode routine
                EatOutput(cnt);
		while (cnt-- > 0) {
		    *pb++ = b;  // set
		}

#else // the alternative
		memset(pb, b, cnt);
		pb += cnt;
#endif
	    }
	}
    }
}

#ifdef DEBUG

void FAR cdecl dprintf(LPSTR szFormat, ...)
{
    char ach[256];
    va_list va;

    static BOOL fDebug = -1;

    if (fDebug == -1)
        fDebug = GetProfileIntA("Debug", "MSRLE", FALSE);

    if (!fDebug)
        return;

    lstrcpyA(ach, "MSRLE: ");
    va_start(va, szFormat);
    wvsprintfA(ach+7, szFormat, va);
    va_end(va);
    lstrcatA(ach, "\r\n");

    OutputDebugStringA(ach);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msrle\profile.c ===
/*
 * MSRLE32:
 *
 * profile.c
 *
 * win32/win16 utility functions to read and write profile items
 * for VFW
 *
 * ONLY mmGetProfileIntA is supported here
 *
 */

#if defined(_WIN32) && defined(UNICODE)
// This whole file is only used for 32 bit code.  It is the implementation
// that allows Win GetProfilexxx calls to use the registry.

#include <windows.h>
#include <windowsx.h>

#include <profile.key>
#include <win32.h>
#include <stdlib.h>  // for atoi

#include "msrle.h"
#ifdef DEBUG
#include "profile.h"

static HKEY GetKeyA(LPCSTR appname, BOOL fCreate)
{
    HKEY key = 0;
    char achName[MAX_PATH];

    lstrcpyA(achName, KEYNAMEA);
    lstrcatA(achName, appname);

    if ((!fCreate && RegOpenKeyA(ROOTKEY, achName, &key) == ERROR_SUCCESS)
        || (fCreate && RegCreateKeyA(ROOTKEY, achName, &key) == ERROR_SUCCESS)) {
    }

    return(key);
}

#define GetKey GetKeyA

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
UINT
mmGetProfileIntA(LPCSTR appname, LPCSTR valuename, INT uDefault)
{
    DWORD dwType;
    INT value = uDefault;
    DWORD dwData;
    int cbData;

    HKEY key = GetKeyA(appname, FALSE);

    if (key) {

        cbData = sizeof(dwData);
        if (RegQueryValueExA(
            key,
            (LPSTR)valuename,
            NULL,
            &dwType,
            (PBYTE) &dwData,
            &cbData) == ERROR_SUCCESS) {
            if (dwType == REG_DWORD || dwType == REG_BINARY) {
                value = (INT)dwData;
            } else if (dwType == REG_SZ) {
		value = atoi((LPSTR) &dwData);
	    }
	}

        RegCloseKey(key);
    }

    return((UINT)value);
}

#endif // DEBUG
#endif // defined(_WIN32) && defined(UNICODE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msrle\rlec.c ===
/*--------------------------------------------------------------------------*\
|   RLEC.C - MS-CRUNCH                                                       |
|//@@BEGIN_MSINTERNAL									      |
|   History:                                                                 |
|   01/01/88 toddla     Created                                              |
|   10/30/90 davidmay   Reorganized, rewritten somewhat.                     |
|   07/11/91 dannymi    Un-hacked                                            |
|   09/15/91 ToddLa     Re-hacked                                            |
|//@@END_MSINTERNAL									      |
|                                                                            |
\*--------------------------------------------------------------------------*/
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1991 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include "msrle.h"

#ifdef _WIN32
#define _huge
#endif

//
//	make a copy of a DIB that is not packed.
//
__inline static LPVOID CopyDib(LPBITMAPINFOHEADER lpbi, LPVOID lpS)
{
    LPVOID lpD;
    BYTE _huge *s;
    BYTE _huge *d;
    long lImageHeader, lImageData, lImageSize;

    if (!lpbi || !lpS)
	return NULL;

    FixBitmapInfo(lpbi);

    lpD = GlobalAllocPtr(GHND, lImageSize = DibSize(lpbi));

    if (lpD)
    {
	// Copy the bitmapinfoheader and colours
	s = (LPVOID)lpbi;
	d = (LPVOID)lpD;
	lImageData = DibSizeImageX(lpbi);  // grab the number of data bytes
	lImageHeader = lImageSize - lImageData;	 // save header+colortable size
#if 0
        while (lImageHeader-- > 0)
            *d++ = *s++;
#else
    	memcpy(d, s, lImageHeader);	   // copy the header+colortable to new Dib
	d += lImageHeader;		   // step pointer to Data piece
#endif

	// Copy the image
	s = (LPVOID)lpS;
#if 0
        while (lImageData-- > 0)
            *d++ = *s++;
#else
    	memcpy(d, s, lImageData);	   // copy data bytes to new Dib
#endif
    }

    return lpD;
}

//
// CrunchDib() - make a DIB fit into a specific size.
//
BOOL FAR PASCAL CrunchDib(PRLEINST pri,
    LPBITMAPINFOHEADER  lpbiRle, LPBYTE lpRle,
    LPBITMAPINFOHEADER  lpbiFrom,LPBYTE lpFrom,
    LPBITMAPINFOHEADER  lpbiTo,  LPBYTE lpTo)
{
    long dwSize = 0L, dwLastSize = 0L;
    long lCurParm = 0L;
    long lTempMax;             // highest value before halving
    long tolMax;
    long lTempMin = 0L;
    BOOL fInterlaceNow = FALSE; // time to try interlacing?
    long lBumpUp = 2048L;       // bump the parameter up by this amount
    int iStart, iLen;

    BOOL fSpatialAdaptive;
    BOOL fTemporalAdaptive;
    long tolTemporal;
    long tolSpatial;
    int  minJump;
    int  maxRun;

    int FIRSTTRY = 1024;        // use this parameter value as a first guess
    int CWND = 250;             // Give up searching for the perfect parameter
				// when the window is smaller than this

    lTempMax = pri->RleState.tolMax;       // highest value before halving
	
    // No Previous DIB -- we want a full frame, so no interlacing allowed
    // (infinite tolerance allowed before frame halving)
    if (lpbiFrom == NULL)
	lTempMax = MAXTOL;

    // In case we were passed a bogus value -- don't allow frame halving at all
    if (lTempMax < 0)
	lTempMax = MAXTOL;

    tolMax = lTempMax;

    tolTemporal = pri->RleState.tolTemporal;
    tolSpatial  = pri->RleState.tolSpatial;
    fSpatialAdaptive = (pri->RleState.tolSpatial == ADAPTIVE);
    fTemporalAdaptive = (pri->RleState.tolTemporal == ADAPTIVE);
    maxRun      = pri->RleState.iMaxRunLen;
    minJump     = 4;

    // No Previous DIB - we should do a full frame, so no interlacing and
    // allow spatial compression to be adaptive to do the compression since
    // we can't do temporal compression.
    if (lpbiFrom == NULL) {
	pri->iStart = 0;
	fSpatialAdaptive = TRUE;
    }

    iStart = pri->iStart;
    iLen   = -1;

    if (!lpbiTo) {
        DPF(("Crunch Error - Invalid DIB or HPAL"));
	goto return_failure;
    }

    //
    // In the previous frame, we did the bottom only,
    // so now we need to do the top
    //
    // If lpbiFrom is NULL, we don't want to do this--we want to make
    // a full frame, even though the last one was a first half.
    //
    if (iStart > 0 && pri->lpbiPrev) {
	fInterlaceNow = TRUE;	// Only do half of the frame.
        lpbiTo = pri->lpbiPrev;
        lpTo   = DibPtr(lpbiTo); // This will be a packed DIB

	lTempMin = 0L;
	lTempMax = MAXTOL;      // no limit to how fuzzy you can get before
	tolMax   = MAXTOL;	// interlacing since we already are doing it

        DPF(("SECOND HALF OF INTERLACE"));

	//
	//  copy over the color table from the last DIB to the empty RLE
	//  to delay any palette change....
	//
        hmemcpy(lpbiRle,lpbiTo,lpbiTo->biSize+(int)lpbiTo->biClrUsed*sizeof(RGBQUAD));
    } else {
	iStart = 0;
    }

// OK. Here's where we work on getting the frame down in size!

// First, try an EXACT RLE with no fuzziness.  If that works, no need to degrade
// the image quality at all!

    if (!RleDeltaFrame(lpbiRle,lpRle,lpbiFrom,lpFrom,lpbiTo,lpTo,iStart,iLen,0L,0L,0,0)) {
        DPF(("Crunch Error - Lossless RleDeltaFrame failed"));
	goto return_failure;
    }
	
    dwSize = lpbiRle->biSizeImage;

    DPF(("tolTemporal = 0, tolSpatial = 0, Size = %ld", dwSize));

    // Exact RLE worked!
    if (dwSize < pri->RleState.lMaxFrameSize) {

	if (fInterlaceNow)
	    pri->iStart = 0;	// we did 2nd half, so next time do full dib

	goto return_success;
    }

    if (pri->lLastParm)		// this value worked last time, so try it now!
				// unless of course, it's too big.
	lCurParm = min(pri->lLastParm, lTempMax);
    else if (lTempMax == MAXTOL) // no limit to what parameter can be
	lCurParm = FIRSTTRY;	// so make the 1st value reasonable
    else
	lCurParm = lTempMax;    // There is a limit on how big the parm can be.
				// Start as big as possible, so that if that
				// doesn't fit, we can give up right away

    goto skip_if;               // skip the big IF

noskip_if:

// This first condition tests to see if the current attempt yielded a frame
// that was still too big, and we have just tried the largest parameter
// possible.  It looks like we will never get the frame small enough!
// Our only hope is to interlace the frames, if we're allowed to.

	if (dwSize > pri->RleState.lMaxFrameSize && lCurParm > tolMax-1)
	{

	// It looks like either we're a keyframe and can't interlace, or
	// we've been trying interlacing and we're STILL not small enough.
	// There is nothing else we can do.  Give up.
	// NOTE: this shouldn't happen if the parameter is allowed to grow
	// arbitrarily!

	    if (fInterlaceNow || !lpbiFrom) {


		if (!lpbiFrom)
		    goto return_success;

		if (iStart > 0) {       // This was 2nd frame of a pair (top)
		    pri->iStart = 0;
		    lCurParm = 0L;      // don't remember this value because
					// this frame halving value won't help
					// us next frame when we aren't using
					// frame halving any more.
		} else {        // This was the first frame of a pair (bottom).
				// Remember to do the 2nd frame next time
		    pri->iStart += iLen;
		}
		goto return_success;

	// We are allowed to interlace, so we can prepare to.
	// Gee, I hope this isn't the last frame in the movie
	// (there will be no frame to do the 2nd half of!! )

	    } else {
                fInterlaceNow = TRUE;

                DPF(("FIRST HALF OF INTERLACE"));

		iStart   = 0;
                iLen     = (int)lpbiTo->biHeight/2;
		lCurParm = 0L;                  // start with no fuzziness
		lTempMin = 0L;
		lTempMax = MAXTOL;       // no limit to fuzziness
		tolMax   = MAXTOL;
	    }

// This condition tests to see if the size is still too big after this attempt,
// and the window of parameter values that we can try is still large enough
// to try some more values.  If so, we shrink the window a bit (the new lowest
// value worth trying is the current value, and we bump the current value up by
// half of the window size, but not TOO much.  You see, if our parameter is too
// high, then we binary search smaller values between 0 and this value.  But if
// the parameter is too small, how do we binary search through here and
// infinity? (actually 195,075)  So, we just increase the parameter by 2048.
// Next time we need to increase it, we will increase by 4096, 8192, etc.
// This way, we will quickly get to the limit of 195,075.  Perhaps the frame
// cannot possibly be crunched as small as it needs to be.  The program
// shouldn't take forever to realize this and get to 195,075.  But we shouldn't
// binary search between 0 and 195,075 because it will waste time getting down
// to the small values like 1000 that most movies will need.  This is the
// best compromise.  Hope that wasn't too long winded!  :-)

	} else if ((dwSize > pri->RleState.lMaxFrameSize) &&
	    ((lTempMax - lTempMin) > CWND))
	{
	    lTempMin = lCurParm;
	    if (lTempMax == MAXTOL){ // upper limit is still unbounded so
					    // leap way higher to our next try
		if (MAXTOL - lCurParm < lBumpUp)
		    lCurParm = MAXTOL;
		else
		    lCurParm += lBumpUp;
		lBumpUp *= 2;
	    } else
                lCurParm += (lTempMax - lCurParm) >> 1;

// For this condition, we are still too big, but the window is getting so small
// that we fear we will never find a value that works!  Let's say we know that
// 200 gives a frame that is too big, and 210 gives a frame that is too small.
// Should we bother searching any more?  NO!!!  That would waste time.  Let's
// just give up and take the 210 value (too small is better than too large)
// and continue.  The next time through this loop, it will give up when it sees
// that the window is too small and the current attempt produced a frame that
// was small enough, even though it was a little smaller than we wanted.

	} else if (dwSize > pri->RleState.lMaxFrameSize) {
	    lCurParm = lTempMax;

// This condtion says that the size is too small to accept, and the window
// of values to try is still large enough to warrant trying again.  So, we
// close the window a bit by setting the new highest value worth trying to
// the current value, and dropping the current value by half.

	} else if ((dwSize < pri->RleState.lMinFrameSize) && ((lTempMax - lTempMin) > CWND)) {
	    lTempMax = lCurParm;
            lCurParm -= (lCurParm - lTempMin) >> 1;

// Here is the catch all last else of the if.  If it gets here, then the frame
// is either just the perfect size and we can quit, or it's too small, but
// we've determined that we can't be bothered to search any more, so we're going
// to quit anyway.

	} else {
	    if (fInterlaceNow) {        // we were interlacing
		if (iStart > 0) {       // this was 2nd half of a pair (top)
		    pri->iStart = 0;
		    lCurParm = 0L;      // don't remember this value because
					// this frame halving value won't help
					// us next frame when we aren't using
					// frame halving any more.
		} else {                // This was 1st half of a pair (bottom)
		    pri->iStart = iLen; // next time, do 2nd half
		}
	    }
	    goto return_success;
	}

skip_if:

// We know that the previous attempt to RLE didn't work, so try again with
// the new values.

	Yield();

	// Set the TEMPORAL and SPATIAL values.
        // NOTE: if we are only working with a single DIB, (no lpbiFrom),
	// TEMPORAL compression won't work, so we enabled SPATIAL adaptive.
	// The TEMPORAL value will be ignored in that case.

	if (fSpatialAdaptive && fTemporalAdaptive) {
            tolSpatial = lCurParm>>3; // lCurParm/8;
	    tolTemporal = lCurParm;
	} else if (fTemporalAdaptive)
	    tolTemporal = lCurParm;
	else if (fSpatialAdaptive)
	    tolSpatial = lCurParm;

        if (!RleDeltaFrame(lpbiRle,lpRle,lpbiFrom,lpFrom,lpbiTo,lpTo,iStart,iLen,tolTemporal,tolSpatial,maxRun,minJump)) {
            DPF(("Crunch Error - Rle Delta Frame failed"));
	    goto return_failure;
	}

	// Remember the size of the last attempt, and take size of this attempt

	dwLastSize = dwSize;

        dwSize = lpbiRle->biSizeImage;

        DPF(("tolTemporal=%ld, tolSpatial=%ld, Size=%ld", tolTemporal, tolSpatial, dwSize));

    goto noskip_if;     // Go back and see how we did!

return_failure:
	pri->lLastParm = 0L;
        return FALSE;

return_success:
//	if (lCurParm)	// putting this line in won't let frame halving
			// threshold value get tried first.  But it will
			// avoid trashing old values that worked.  If you
			// understand this comment, you probably didn't need
			// to read it!!
	    pri->lLastParm = lCurParm;

        if (pri->lpbiPrev)
	{
            GlobalFreePtr(pri->lpbiPrev);
            pri->lpbiPrev = NULL;
	}

        if (lpbiRle)
	{
	    if (pri->iStart)
	    {
                lpbiRle->biCompression = BI_DIBX;     // 1st part of DIB. Not
                pri->lpbiPrev = CopyDib(lpbiTo, lpTo);// complete until next
            }                                         // BI_RLE8 is seen.
	    else
	    {
                lpbiRle->biCompression = BI_RLE8;
	    }
	}

        return TRUE;
}

BOOL FAR PASCAL SplitDib(PRLEINST pri,
    LPBITMAPINFOHEADER  lpbiRle, LPBYTE pbRle,
    LPBITMAPINFOHEADER  lpbiPrev,LPBYTE pbPrev,
    LPBITMAPINFOHEADER  lpbiDib, LPBYTE pbDib)
{
    int iStart, iLen, iMin, iMax;
    DWORD dwSize;
    BOOL f;

    iStart = iMin = 0;
    iLen   = iMax = (int)lpbiDib->biHeight - iStart;

    for(;;)
    {
        f = RleDeltaFrame(
                lpbiRle, pbRle,
                lpbiPrev,pbPrev,
                lpbiDib, pbDib,
                iStart,iLen,
		pri->RleState.tolTemporal,
		pri->RleState.tolSpatial,
		pri->RleState.iMaxRunLen,4);

        if (!f)
            return FALSE;

        dwSize = lpbiRle->biSizeImage;

        DPF(("iStart=%d, iLen=%d, Size=%ld, Max=%ld", iStart, iLen, dwSize, pri->RleState.lMaxFrameSize));

	if (dwSize < (DWORD)pri->RleState.lMaxFrameSize)
	{
            iMin = iLen;

	    if (iMax-iMin <= 1)
	    {
		pri->iStart += iLen;

		if (pri->iStart >= (int)lpbiDib->biHeight)
		    pri->iStart = 0;

                return TRUE;
	    }
	}
	else
	    iMax = iLen - 1;

	if (iStart != pri->iStart)
	{
	    iStart = pri->iStart;
	    iLen = iMax = (int)lpbiDib->biHeight - iStart;
	}
	else
	{
	    iLen = (iMin + iMax) / 2;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msrle\rle.c ===
/*--------------------------------------------------------------------------*\
|   RLE.C - RLE Delta frame code                                             |
|@@BEGIN_MSINTERNAL									      |
|                                                                            |
|   History:                                                                 |
|   01/01/88 toddla     Created                                              |
|   10/30/90 davidmay   Reorganized, rewritten somewhat.                     |
|   07/11/91 dannymi    Un-hacked                                            |
|   09/15/91 ToddLa     Re-hacked                                            |
|@@END_MSINTERNAL									      |
\*--------------------------------------------------------------------------*/
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1991 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <memory.h>     // for _fmemcmp()
#include "msrle.h"

#define RLE_ESCAPE  0
#define RLE_EOL     0
#define RLE_EOF     1
#define RLE_JMP     2
#define RLE_RUN     3

typedef BYTE huge * HPRLE;
typedef BYTE far  * LPRLE;

RGBTOL    gRgbTol = {0, 0};


//
//  RleDeltaFrame
//
//  Calculate the RLE bits to go from hdib1 to hdib2
//
//      hdibPrev    - Previous DIB
//      hdib        - DIB to RLE
//
//  returns
//
//      handle to a RLE DIB
//
BOOL FAR PASCAL RleDeltaFrame(
    LPBITMAPINFOHEADER  lpbiRle,    LPBYTE pbRle,
    LPBITMAPINFOHEADER  lpbiPrev,   LPBYTE pbPrev,
    LPBITMAPINFOHEADER  lpbiDib,    LPBYTE pbDib,
    int         iStart,
    int         iLen,
    long        tolTemporal,
    long        tolSpatial,
    int         maxRun,
    int         minJump)
{
    LPBITMAPINFOHEADER  lpbi;

    int    biHeight;
    UINT   cbJump=0;
    int    dy;

    if (!lpbiDib)
        return FALSE;

    if (maxRun == 0)
        maxRun = -1;

    if (minJump == 0)
        minJump = 4;

    //
    //  Get info on the source and dest dibs
    //
    lpbi = lpbiDib;
    biHeight = (int)lpbi->biHeight;

    if (iLen <= 0)
        iLen = biHeight;

    iLen = min(biHeight-iStart, iLen);

    //
    //  Hey! we only work with 8bpp DIBs if we get otherwise barf.
    //
    if (lpbi->biBitCount != 8 || lpbi->biCompression != BI_RGB)
        return FALSE;

#if 0 // CompressBegin does this..
    //
    // Set up the table for quick sum of squares calculation (see rle.h)
    //
    if (!MakeRgbTable(lpbi))
        return FALSE;
#endif

    //
    //  lock all the buffers, and start the delta framin'
    //
    lpbi  = lpbiRle;

    if (iStart > 0)
        pbDib = DibXYN(lpbiDib, pbDib,0,iStart,8);

    if (iStart > 0 && lpbiPrev)
        pbPrev = DibXYN(lpbiPrev,pbPrev,0,iStart,8);

    if (lpbiPrev == NULL)
        pbPrev = NULL;

    while(iStart > 0)
    {
	dy = min(iStart,255);
	*pbRle++ = RLE_ESCAPE;
	*pbRle++ = RLE_JMP;
	*pbRle++ = 0;
	*pbRle++ = (BYTE)dy;
        iStart  -= dy;
        cbJump  += 4;
    }

    lpbi->biHeight = iLen;


#ifdef _WIN32
    DeltaFrameC(
#else
    DeltaFrame386(
#endif
	lpbi, pbPrev, pbDib, pbRle, maxRun, minJump,
	gRgbTol.hpTable, tolTemporal, tolSpatial);


    lpbi->biHeight = biHeight;
    lpbi->biSizeImage += cbJump;  // adjust size to include JUMP!

    return TRUE;
}

/* Next is a table that, for each pair of palette entries, helps determine
   if two colours are close enough to be merged to a single colour

   Let's say the first pixel of a frame is black, and the same pixel in the
   next frame is gray.  Should you bother painting that gray pixel or let it
   stay black because it's close enough?  With this table, you have 2 palettes
   (one for each of the two frames you are comparing, or possibly two identical
   palettes if you are filtering a single DIB) and a table associated with
   those palettes.  You can index into the table with the colour number of the
   pixel in the first frame and the colour number of the pixel in the second
   frame.  The table value will be a number representing how different those
   two colours are.

   |Red1 - Red2|^2 + |Green1 - Green2|^2 + |Blue1 - Blue2|^2

   is that value (sum of squares of differences).  As soon as you start
   using this table with a pair of palettes, those hpals are put in this
   structure so that you know what pair of palettes the table is built with.
   If you change a palette, you need to recompute the table.  BUT:  you don't
   build the table at the beginning, you do it on demand.  Initially, the
   table is filled with a value of UNCOMPUTED, and as the values are needed,
   they are put into the table, so a second call to the CloseEnough routine
   with the same colours will exit extremely quickly with no calculations!

   Prepare the table for looking up quickly the sum of squares of colours
   of two palette entries (possibly in different palettes)              */


DWORD NEAR _fastcall RgbCompare(RGBQUAD rgb1, RGBQUAD rgb2)
{
    DWORD sum=0;

    //
    //  lets do some magic so the compiler generates "good" code.
    //
#define SUMSQ(a,b)                          \
    if (a > b)                              \
        sum += (WORD)(a-b) * (WORD)(a-b);   \
    else                                    \
        sum += (WORD)(b-a) * (WORD)(b-a);

    SUMSQ(rgb1.rgbRed,   rgb2.rgbRed);
    SUMSQ(rgb1.rgbGreen, rgb2.rgbGreen);
    SUMSQ(rgb1.rgbBlue,  rgb2.rgbBlue);

    return sum;
}

BOOL NEAR PASCAL MakeRgbTable(LPBITMAPINFOHEADER lpbi)
{
    UINT i, j;
    int  n=0;
    DWORD tol;

    if (!lpbi)
        return FALSE;

    if (lpbi->biClrUsed == 0)
        lpbi->biClrUsed = 1 << lpbi->biBitCount;

    /* If the palette passed in has a different number of colours than */
    /* the one in the table, we obviously need a new table */

    if (gRgbTol.hpTable == NULL ||
        (int)lpbi->biClrUsed != gRgbTol.ClrUsed ||
        _fmemcmp(lpbi+1, gRgbTol.argbq, gRgbTol.ClrUsed * sizeof(RGBQUAD)))
    {
        if (gRgbTol.hpTable == NULL)
        {
            gRgbTol.hpTable = (LPVOID)GlobalAllocPtr(GHND|GMEM_SHARE, 256L * 256L * sizeof(DWORD));

            if (gRgbTol.hpTable == NULL)
                return FALSE;
        }

        gRgbTol.ClrUsed = (int)lpbi->biClrUsed;          // get the actual colours

        for (i = 0; i < (UINT)gRgbTol.ClrUsed; i++)
            gRgbTol.argbq[i] = ((LPRGBQUAD)(lpbi + 1))[i];

        for (i = 0; i < (UINT)gRgbTol.ClrUsed; i++)
        {
            for (j = 0; j <= i; j++)
            {
                tol = RgbCompare(gRgbTol.argbq[i], gRgbTol.argbq[j]);

                gRgbTol.hpTable[256 * i + j] = tol;
                gRgbTol.hpTable[256 * j + i] = tol;
            }
        }
    }

    return TRUE;
}

#ifdef _WIN32

// ---- DeltaFrameC --------------------------------------------------------

#define TolLookUp(p, a, b)	( ((LPDWORD)p)[a * 256 + b] )

LPBYTE EncodeFragment(LPBYTE pIn, int len, LPBYTE pOut, LPDWORD pTol, DWORD tolerance, UINT maxrun);
LPBYTE EncodeAbsolute(LPBYTE pbDib, int len, LPBYTE pbRle);
int FindFragmentLength(LPBYTE pIn, LPBYTE pPrev, int len, UINT maxjmp, LPDWORD pTol, DWORD tol, PDWORD prunlen);

// rle format:
// byte 1: 0 - escape
//		byte 2: 0 - eol
//		byte 2: 1 - eof
//		byte 2: 2 - jump x, y (bytes 3, 4)
//		byte 2: >2 - absolute run of pixels - byte 2 is length
// byte 1: >0 - repeat solid colour - byte 1 is length
//		byte 2 is solid pixel to repeat
	
	


// compression - in df.asm for Win16
extern void DeltaFrameC(
    LPBITMAPINFOHEADER  lpbi,
    LPBYTE              pbPrev,
    LPBYTE              pbDib,
    LPBYTE		pbRle,
    UINT		MaxRunLength,
    UINT		MinJumpLength,
    LPDWORD             TolTable,
    DWORD               tolTemporal,
    DWORD               tolSpatial)
{
    int WidthBytes = (lpbi->biWidth+3) & (~3);
    int x, y;
    LPBYTE pbRle_Orig = pbRle;

    if ((MaxRunLength == 0) || (MaxRunLength > 255)) {
	MaxRunLength = 255;
    }

    if (pbPrev == NULL) {

	// no previous frame, just encode each line spatially

	for (y = lpbi->biHeight; y > 0; y--) {

	    pbRle = EncodeFragment(
			pbDib,
			lpbi->biWidth,
			pbRle,
			TolTable,
			tolSpatial,
			MaxRunLength);

	    // don't bother to insert an EOL if we are about to insert EOF
	    if (y > 0) {
		* (WORD FAR *)pbRle = RLE_ESCAPE | (RLE_EOL << 8);
		pbRle += sizeof(WORD);
	    }

    	    pbDib += WidthBytes;
	}
    } else {
	int jumpX = 0;
	int jumpY = 0;
	int frag, runlen;

	
	for (y = 0; y < lpbi->biHeight; y++) {

	    x = 0;		

	    while (x < lpbi->biWidth) {

		// see how much is not the same as the previous frame,
		// followed by how much is the same. frag is the length of
		// the not-similar fragment; runlen is the length of the
		// similar fragment.

    		frag = FindFragmentLength(
			    pbDib,
			    pbPrev,
			    lpbi->biWidth - x,
			    MinJumpLength,
			    TolTable,
			    tolTemporal,
			    &runlen
		);

		if (frag == 0) {

		    // no fragment, just a jump over the similar pixels.
		    //add up jumps until we need to output them
		    jumpX += runlen;
		    x += runlen;
		    pbPrev += runlen;
		    pbDib += runlen;
		} else {

		    // output any saved jumps
		    if (jumpX < 0) {

			// don't jump backwards - eol and jump forwards
			*(WORD FAR *)pbRle = RLE_ESCAPE | (RLE_EOL << 8);
			pbRle += sizeof(WORD);

			// jump is now across to current position,
			// and one fewer lines.
			jumpX = x;
			jumpY--;
		    }

		    while (jumpX + jumpY) {
			int delta;


			* (WORD FAR *)pbRle = RLE_ESCAPE | (RLE_JMP << 8);
			pbRle += sizeof(WORD);

			// max jump size is 255

			delta = min(255, jumpX);
			*pbRle++ = (BYTE) delta;
			jumpX -= delta;

			delta = min(255, jumpY);
			*pbRle++ = (BYTE) delta;
			jumpY -= delta;

		    }

		    // output the different fragment as a combination
		    // of solid runs and absolute pixels
		    pbRle = EncodeFragment(
				pbDib,
				frag,
				pbRle,
				TolTable,
				tolSpatial,
				MaxRunLength);
		    x += frag;
		    pbDib += frag;
		    pbPrev += frag;
		}
	    }

	    // end-of-line
	    jumpY++;

	    // advance past DWORD-rounding bytes
	    pbPrev += (WidthBytes - lpbi->biWidth);
	    pbDib += (WidthBytes - lpbi->biWidth);

	    //adjust jumpX
	    jumpX -= x;

	}
    }

    // end-of-frame
    * (WORD FAR *)pbRle = RLE_ESCAPE | (RLE_EOF << 8);
    pbRle += sizeof(WORD);

    // update lpbi to correct size and format
    lpbi->biSizeImage = (DWORD) (pbRle - pbRle_Orig);
    lpbi->biCompression = BI_RLE8;
}


//
// encode a sequence of pixels as a mixture of solid runs and absolute
// pixels. write the rle data to pbRle and return pointer to the next
// available rle buffer.
LPBYTE
EncodeFragment(
    LPBYTE pbDib,
    int width,
    LPBYTE pbRle,
    LPDWORD TolTable,
    DWORD tolerance,
    UINT MaxRunLength
)
{
    int maxrun, run;
    BYTE px;

    while (width > 0) {

	maxrun = min(255, width);
	MaxRunLength = min((int)MaxRunLength, maxrun);

	px = *pbDib;

	for (run = 0; run < maxrun; run++, pbDib++) {

	    // the same or similar ? - use tolerance table to compare pixel
	    // rgb values
	    // We're allowed a run of 255 if they're exact, but only a run of
	    // MaxRunLength if they're not exact, only close
	    if (px == *pbDib)
		continue;
	    if (TolLookUp(TolTable,px,*pbDib) <= tolerance &&
							run < (int)MaxRunLength)
		continue;

	    // not close enough - end run
	    break;
	}

	// we have found the end of a run of identical pixels
	
	// if the run is one pixel, then we switch into absolute mode.
	// however, we cannot encode absolute runs of less than RLE_RUN
	// pixels (the runlength code is an escape code and must not coincide
	// with RLE_JMP, RLE_EOL and RLE_EOF.

	if ((run > 1) || (width < RLE_RUN)) {

    	    // write out run length and colour
	    * (WORD FAR *)pbRle = run | (px << 8);
	    pbRle += sizeof(WORD);

	    width -= run;

	} else {

	    // we have a 'run' of one pixel - back up to point at this.
	    pbDib--;

	    // write out an absolute run. now we are in abs mode, we need
	    // a solid run of at least 4 pixels for it to be worth leaving
	    // and re-entering abs mode

	    for (run = 0; run < maxrun; run++) {

		// at the end of the fragment ?
		if ((maxrun - run) < 4) {
		    // yes - so no point in looking for a solid run -
		    // just dump all the remainder as an absolute block
		    pbRle = EncodeAbsolute(pbDib, maxrun, pbRle);
		    pbDib += maxrun;
		    width -= maxrun;
		    break;
		}

		px = pbDib[run];
		if ( (TolLookUp(TolTable,px,pbDib[run + 1]) <= tolerance) &&
		     (TolLookUp(TolTable,px,pbDib[run + 2]) <= tolerance) &&
		     (TolLookUp(TolTable,px,pbDib[run + 3]) <= tolerance)) {

			 // we have run bytes to encode followed by four
			 // similar pixels

			 pbRle = EncodeAbsolute(pbDib, run, pbRle);
			 pbDib += run;
			 width -= run;
			 break;
		}
	    }
	}
    }

    return pbRle;
}

LPBYTE
EncodeAbsolute(LPBYTE pbDib, int runlen, LPBYTE pbRle)
{
    if (runlen < RLE_RUN) {

	// cannot encode absolute runs of less than RLE_RUN as it
	// conflicts with other rle escapes - so encode each pixel
	// as a run of 1 of that pixel
	int i;
	for (i = 0; i < runlen; i++) {

	    * (WORD FAR *) pbRle = 1 | ((*pbDib++) << 8);
	    pbRle += sizeof(WORD);
	}
	return pbRle;

    }

    // absolute run of > RLE_RUN

    * (WORD FAR *)pbRle = RLE_ESCAPE | (runlen << 8);
    pbRle += sizeof(WORD);

    while (runlen >= 2) {
	* (WORD FAR *) pbRle = * (WORD UNALIGNED FAR *)pbDib;
	pbRle += sizeof(WORD);
	pbDib += sizeof(WORD);
	runlen -= 2;
    }

    // remember to keep word alignment
    if (runlen) {
	*pbRle++ = *pbDib++;
	*pbRle++ = 0;
    }

    return pbRle;
}

// count how many pixels are not the same as the previous frame, and how
// long is the run of similar pixels after it. We must find at least minjump
// similar pixels before we stop.
int
FindFragmentLength(
    LPBYTE pIn,
    LPBYTE pPrev,
    int len,
    UINT minjump,
    LPDWORD pTol,
    DWORD tol,
    PDWORD prunlen
)
{
    int x;
    int run = 0;

    for (x = 0; x < len; x++) {


	if ((*pIn == *pPrev) || (TolLookUp(pTol, *pIn, *pPrev) <= tol)) {
	    run++;
	} else {

	    // have we accumulated a run long enough to be worth
	    // returning ?

	    if (run >= (int)minjump) {

		*prunlen = run;
		return x - run;
	    } else {
		run = 0;
	    }
	}
	pIn++;
	pPrev++;
    }

    // end of line - did we find a run ?
    if (run < (int) minjump) {
	*prunlen = 0;
	return len;
    } else {
	*prunlen = run;
	return x - run;
    }
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvidc\compress.c ===
/*----------------------------------------------------------------------+
| compress.c - Microsoft Video 1 Compressor - compress code		|
|									|
|									|
| Copyright (c) 1990-1994 Microsoft Corporation.			|
| Portions Copyright Media Vision Inc.					|
| All Rights Reserved.							|
|									|
| You have a non-exclusive, worldwide, royalty-free, and perpetual	|
| license to use this source code in developing hardware, software	|
| (limited to drivers and other software required for hardware		|
| functionality), and firmware for video display and/or processing	|
| boards.   Microsoft makes no warranties, express or implied, with	|
| respect to the Video 1 codec, including without limitation warranties	|
| of merchantability or fitness for a particular purpose.  Microsoft	|
| shall not be liable for any damages whatsoever, including without	|
| limitation consequential damages arising from your use of the Video 1	|
| codec.								|
|									|
|									|
+----------------------------------------------------------------------*/
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>       // for timeGetTime()
#include <win32.h>
#include "msvidc.h"

#include <memory.h>         // for _fmemcmp

//#include <limits.h>
//#include <aviffmt.h>

DWORD   numberOfBlocks;
DWORD   numberOfSolids;
DWORD   numberOfSolid4;
DWORD   numberOfSolid2;
DWORD   numberOfEdges;
DWORD   numberOfSkips;
DWORD   numberOfExtraSkips;
DWORD   numberOfSkipCodes;
DWORD   numberOfEvilRed;

/*******************************************************************
*******************************************************************/

#define SWAP(x,y) ( (x)^=(y), (y)^=(x), (x)^=(y) )

#define SWAPRGB(x,y)( SWAP((x).rgbRed,   (y).rgbRed),  \
                      SWAP((x).rgbGreen, (y).rgbGreen),\
                      SWAP((x).rgbBlue,  (y).rgbBlue) )

// Take an RGB quad value and figure out it's lumanence
// Y = 0.3*R + 0.59*G + 0.11*B
#define RgbToY(rgb) ((((WORD)((rgb).rgbRed)  * 30) + \
                      ((WORD)((rgb).rgbGreen)* 59) + \
                      ((WORD)((rgb).rgbBlue) * 11))/100)

#define RGB16(r,g,b)   ((((WORD)(r) >> 3) << 10) | \
                        (((WORD)(g) >> 3) << 5)  | \
                        (((WORD)(b) >> 3) << 0) )

#define RGBQ16(rgb)    RGB16((rgb).rgbRed,(rgb).rgbGreen,(rgb).rgbBlue)

// this array is used to associate each of the 16 luminance values
// with one of the sum values
BYTE meanIndex[16] = { 0, 0, 1, 1,
                       0, 0, 1, 1,
                       2, 2, 3, 3,
                       2, 2, 3, 3 };


/*****************************************************************************
 ****************************************************************************/



//
// map Quality into our threshold
//
//  Quality goes from ICQUALITY_LOW-ICQUALITY_HIGH (bad to good)
//
//  threshold = (Quality/ICQUALITY_HIGH)^THRESHOLD_POW * THRESHOLD_HIGH
//
DWORD FAR QualityToThreshold(DWORD dwQuality)
{
    #define THRESHOLD_HIGH ((256*256l)/2)
    #define THRESHOLD_POW  4
    double dw1;

    dw1 = (double)(dwQuality) / ICQUALITY_HIGH;

    // unbelievably enough, pow() doesn't work on alpha or mips!
    // also I can't believe this will be less efficient than pow(x, 4)
    dw1 = (dw1 * dw1 * dw1 * dw1);

    return (DWORD) (dw1 * THRESHOLD_HIGH);

    //return (DWORD)(pow((double)(dwQuality)/ICQUALITY_HIGH,THRESHOLD_POW) * THRESHOLD_HIGH);
}

/*******************************************************************
*******************************************************************/

//
// table to map a 5bit index (0-31) to a 8 bit value (0-255)
//
static BYTE aw5to8[32] = {(BYTE)-1};

//
// inverse table to map a RGB16 to a 8bit pixel
//
#define MAPRGB16(rgb16) lpITable[(rgb16)]
#define MAPRGB(rgb)     lpITable[RGBQ16(rgb)]


/*******************************************************************
*******************************************************************/

DWORD FAR CompressFrameBegin(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut,
			     LPBYTE *lplpITable, RGBQUAD *prgbqOut)
{
    int i;

    //
    // init the 5bit to 8bit conversion table.
    //
    if (aw5to8[0] != 0)
        for (i=0; i<32; i++)
            aw5to8[i] = (BYTE)(i * 255 / 31);

    //
    // copy the color table to local storage
    //
    if (lpbiIn->biBitCount == 8)
    {
        if (lpbiIn->biClrUsed == 0)
            lpbiIn->biClrUsed = 256;
    }

    //
    //  if we are compressing to 8bit, then build a inverse table
    //
    if (lpbiOut->biBitCount == 8)
    {
        if (lpbiOut->biClrUsed == 0)
            lpbiOut->biClrUsed = 256;

        if (_fmemcmp((LPVOID)prgbqOut, (LPVOID)(lpbiOut+1),
            (int)lpbiOut->biClrUsed * sizeof(RGBQUAD)))
        {
            for (i=0; i<(int)lpbiOut->biClrUsed; i++)
                prgbqOut[i] = ((LPRGBQUAD)(lpbiOut+1))[i];

            if (*lplpITable)
                GlobalFreePtr(*lplpITable);

            *lplpITable = NULL;
        }

        if (*lplpITable == NULL)
        {
	    // !!! Need a critical section around this code!
            DPF(("Building ITable.... (%d colors)", (int)lpbiOut->biClrUsed));
            *lplpITable = MakeITable(prgbqOut, (int)lpbiOut->biClrUsed);
	    // !!! Critical section can end here....
        }

        if (*lplpITable == NULL)
            return (DWORD)ICERR_MEMORY;
    }

    return ICERR_OK;
}

/*******************************************************************
*******************************************************************/

DWORD FAR CompressFrameEnd(LPBYTE *lplpITable)
{
    if (*lplpITable)
        GlobalFreePtr(*lplpITable);

    *lplpITable = NULL;

    return ICERR_OK;
}

/*******************************************************************
*******************************************************************/

void FAR CompressFrameFree(void)
{
}

/*******************************************************************

GetCell - get a 4x4 cell from a image.

returns pointer to next cell.

*******************************************************************/

static LPVOID _FASTCALL
GetCell(LPBITMAPINFOHEADER lpbi, LPVOID lpBits, PCELL pCell)
{
    UINT WidthBytes;
    int  bits;
    int  i;
    int  x;
    int  y;
    BYTE b;
    HPBYTE pb;
    RGBQUAD FAR *prgbqIn;

    RGB555 rgb555;

    pb = lpBits;

    bits       = (int)lpbi->biBitCount;
    WidthBytes = DIBWIDTHBYTES(*lpbi);
    WidthBytes-= (WIDTH_CBLOCK * bits/8);

    ((HPBYTE)lpBits) += (WIDTH_CBLOCK * bits/8);       // "next" cell

    i = 0;

    switch (bits)
    {
        case 8:
	    prgbqIn = (RGBQUAD FAR *) (lpbi + 1);
            for( y = 0; y < HEIGHT_CBLOCK; y++ )
            {
                for( x = 0; x < WIDTH_CBLOCK; x++ )
                {
                    b = *pb++;
                    pCell[i++] = prgbqIn[b];
                }
                pb += WidthBytes; // next row in this block
            }
            break;

        case 16:
            for( y = 0; y < HEIGHT_CBLOCK; y++ )
            {
                for( x = 0; x < WIDTH_CBLOCK; x++ )
                {
                    rgb555 = *((HPRGB555)pb)++;
                    pCell[i].rgbRed   = aw5to8[(rgb555 >> 10) & 0x1F];
                    pCell[i].rgbGreen = aw5to8[(rgb555 >>  5) & 0x1F];
                    pCell[i].rgbBlue  = aw5to8[(rgb555 >>  0) & 0x1F];
                    i++;
                }
                pb += WidthBytes; // next row in this block
            }
            break;

        case 24:
            for( y = 0; y < HEIGHT_CBLOCK; y++ )
            {
                for( x = 0; x < WIDTH_CBLOCK; x++ )
                {
                    pCell[i].rgbBlue  = *pb++;
                    pCell[i].rgbGreen = *pb++;
                    pCell[i].rgbRed   = *pb++;
                    i++;
                }
                pb += WidthBytes; // next row in this block
            }
            break;

        case 32:
            for( y = 0; y < HEIGHT_CBLOCK; y++ )
            {
                for( x = 0; x < WIDTH_CBLOCK; x++ )
                {
                    pCell[i].rgbBlue  = *pb++;
                    pCell[i].rgbGreen = *pb++;
                    pCell[i].rgbRed   = *pb++;
                    pb++;
                    i++;
                }
                pb += WidthBytes; // next row in this block
            }
            break;
    }

    //
    //  return the pointer to the "next" cell
    //
    return lpBits;
}

/*******************************************************************

CmpCell - compares two 4x4 cells and returns an error value.

the error value is a sum of squares error.

the error value ranges from

    0           = exact
    3*256^2     = way off

*******************************************************************/

static DWORD _FASTCALL
CmpCell(PCELL cellA, PCELL cellB)
{
#if 0
    int   i;
    long  l;
    int   dr,dg,db;

    for (l=0,i=0; i < HEIGHT_CBLOCK*WIDTH_CBLOCK; i++)
    {
        dr = (int)cellA[i].rgbRed   - (int)cellB[i].rgbRed;
        dg = (int)cellA[i].rgbGreen - (int)cellB[i].rgbGreen;
        db = (int)cellA[i].rgbBlue  - (int)cellB[i].rgbBlue;

        l += ((long)dr * dr) + ((long)dg * dg) + ((long)db * db);
    }

    return l / (HEIGHT_CBLOCK*WIDTH_CBLOCK);
#else
    int   i;
    DWORD dw;

    //
    //
#define SUMSQ(a,b)                          \
    if (a > b)                              \
        dw += (UINT)(a-b) * (UINT)(a-b);    \
    else                                    \
        dw += (UINT)(b-a) * (UINT)(b-a);

    for (dw=0,i=0; i < HEIGHT_CBLOCK*WIDTH_CBLOCK; i++)
    {
        SUMSQ(cellA[i].rgbRed,   cellB[i].rgbRed);
        SUMSQ(cellA[i].rgbGreen, cellB[i].rgbGreen);
        SUMSQ(cellA[i].rgbBlue,  cellB[i].rgbBlue);
    }

    return dw / (HEIGHT_CBLOCK*WIDTH_CBLOCK);
#endif
}

#if 0  // This routine is unused
/*******************************************************************

MapCell - map a CELL full of 24bit values down to thier nearest
          colors in the 8bit palette

*******************************************************************/

static void _FASTCALL
MapCell(PCELL pCell)
{
    int i;
    int n;

    for (i=0; i < HEIGHT_CBLOCK*WIDTH_CBLOCK; i++)
    {
        n = MAPRGB(pCell[i]);       // map to nearest palette index
        pCell[i] = prgbqOut[n];      // ...and map back to a RGB
    }
}
#endif


//////////////////////////////////////////////////////////////////////////
//
//  take care of any outstanding skips
//
//////////////////////////////////////////////////////////////////////////

#define FlushSkips()                        \
                                            \
    while (SkipCount > 0)                   \
    {                                       \
        WORD w;                             \
                                            \
        w = min(SkipCount, SKIP_MAX);       \
        SkipCount -= w;                     \
        w |= SKIP_MAGIC;                    \
        *dst++ = w;                         \
        numberOfSkipCodes++;                \
        actualSize += 2;                    \
    }


/*******************************************************************
routine: CompressFrame16
purp:    compress a frame, outputing 16 bit compressed data.
returns: number of bytes in compressed buffer
*******************************************************************/

DWORD FAR CompressFrame16(LPBITMAPINFOHEADER  lpbi,           // DIB header to compress
                      LPVOID              lpBits,         // DIB bits to compress
                      LPVOID              lpData,         // put compressed data here
                      DWORD               threshold,      // edge threshold
                      DWORD               thresholdInter, // inter-frame threshold
                      LPBITMAPINFOHEADER  lpbiPrev,       // previous frame
                      LPVOID              lpPrev,         // previous frame
		      LONG (CALLBACK *Status) (LPARAM lParam, UINT message, LONG l),
		      LPARAM		  lParam,
                      PCELLS              pCells)
{
UINT            bix;
UINT            biy;
UINT            WidthBytes;
UINT            WidthBytesPrev;

WORD            SkipCount;

WORD            luminance[16], luminanceMean[4];
DWORD           luminanceSum;
WORD            sumR,sumG,sumB;
WORD            sumR0[4],sumG0[4],sumB0[4];
WORD            sumR1[4],sumG1[4],sumB1[4];
WORD            meanR0[4],meanG0[4],meanB0[4];
WORD            meanR1[4],meanG1[4],meanB1[4];
WORD            zeros[4], ones[4];
UINT            x,y;
WORD            mask;
HPBYTE          srcPtr;
HPBYTE          prvPtr;
DWORD           actualSize;
UINT            i;
UINT            mi;
HPWORD          dst;
RGBQUAD         rgb;
int		iStatusEvery;

#ifdef DEBUG
DWORD           time = timeGetTime();
#endif

    WidthBytes = DIBWIDTHBYTES(*lpbi);

    if (lpbiPrev)
        WidthBytesPrev = DIBWIDTHBYTES(*lpbiPrev);

    bix = (int)lpbi->biWidth/WIDTH_CBLOCK;
    biy = (int)lpbi->biHeight/HEIGHT_CBLOCK;

    if (bix < 100)
	iStatusEvery = 4;
    else if (bix < 200)
	iStatusEvery = 2;
    else
	iStatusEvery = 1;

    actualSize = 0;
    numberOfSkipCodes   = 0;
    numberOfSkips       = 0;
    numberOfExtraSkips  = 0;
    numberOfEdges       = 0;
    numberOfBlocks      = 0;
    numberOfSolids      = 0;
    numberOfSolid4      = 0;
    numberOfSolid2      = 0;
    numberOfEvilRed     = 0;

    dst = (HPWORD)lpData;
    SkipCount = 0;

    for( y = 0; y < biy; y++ )
    {
	if (Status && ((y % iStatusEvery) == 0)) {
	    if (Status(lParam, ICSTATUS_STATUS, (y * 100) / biy) != 0)
		return (DWORD) -1;
	}

        srcPtr = lpBits;
        prvPtr = lpPrev;

        for( x = 0; x < bix; x++ )
        {
//////////////////////////////////////////////////////////////////////////
//
// get the cell to compress from the image.
//
//////////////////////////////////////////////////////////////////////////
            srcPtr = GetCell(lpbi, srcPtr, pCells->cell);

//////////////////////////////////////////////////////////////////////////
//
//  see if it matches the cell in the previous frame.
//
//////////////////////////////////////////////////////////////////////////
            if (lpbiPrev)
            {
                prvPtr = GetCell(lpbiPrev, prvPtr, pCells->cellPrev);

                if (CmpCell(pCells->cell, pCells->cellPrev) <= thresholdInter)
                {
skip_cell:
                    numberOfSkips++;
                    SkipCount++;
                    continue;
                }
            }

//////////////////////////////////////////////////////////////////////////
// compute luminance of each pixel in the compression block
// sum the total luminance in the block
// find the pixels with the largest and smallest luminance
//////////////////////////////////////////////////////////////////////////

            luminanceSum = 0;
            sumR = 0;
            sumG = 0;
            sumB = 0;

            for (i = 0; i < HEIGHT_CBLOCK*WIDTH_CBLOCK; i++)
            {
                sumR += pCells->cell[i].rgbRed;
                sumG += pCells->cell[i].rgbGreen;
                sumB += pCells->cell[i].rgbBlue;

                luminance[i] = RgbToY(pCells->cell[i]);
                luminanceSum += luminance[i];
            }

//////////////////////////////////////////////////////////////////////////
//
// see if we make the cell a single color, and get away with it
//
//////////////////////////////////////////////////////////////////////////
            sumR /= HEIGHT_CBLOCK*WIDTH_CBLOCK;
            sumG /= HEIGHT_CBLOCK*WIDTH_CBLOCK;
            sumB /= HEIGHT_CBLOCK*WIDTH_CBLOCK;

            rgb.rgbRed   = (BYTE)sumR;
            rgb.rgbGreen = (BYTE)sumG;
            rgb.rgbBlue  = (BYTE)sumB;

            for (i=0; i < HEIGHT_CBLOCK*WIDTH_CBLOCK; i++)
                pCells->cellT[i] = rgb;

            if (CmpCell(pCells->cell, pCells->cellT) <= threshold)
            {
                if (lpbiPrev && CmpCell(pCells->cellT, pCells->cellPrev) <= thresholdInter)
                {
                    numberOfExtraSkips++;
                    goto skip_cell;
                }

                FlushSkips();

                // single color!!
solid_color:
                mask = RGB16(sumR, sumG, sumB) | 0x8000;

                if ((mask & ~SKIP_MASK) == SKIP_MAGIC)
                {
                    numberOfEvilRed++;
                    mask ^= SKIP_MAGIC;
                    mask |= 0x8000;
                }

                *dst++ = mask;
                numberOfSolids++;
                actualSize += 2;
                continue;
            }

//////////////////////////////////////////////////////////////////////////
//
//  make a 4x4 block
//
//////////////////////////////////////////////////////////////////////////

            luminanceMean[0] = (WORD)(luminanceSum >> 4);

            // zero summing arrays
            zeros[0]=0;
            ones[0] =0;
            sumR0[0]=0;
            sumR1[0]=0;
            sumG0[0]=0;
            sumG1[0]=0;
            sumB0[0]=0;
            sumB1[0]=0;

            // define which of the two colors to choose
            // for each pixel by creating the mask
            mask = 0;
            for( i=0; i < HEIGHT_CBLOCK*WIDTH_CBLOCK; i++ )
            {
                if( luminance[i] < luminanceMean[0] )
                {
                    // mask &= ~(1 << i);     // already clear
                    zeros[0]++;
                    sumR0[0] += pCells->cell[i].rgbRed;
                    sumG0[0] += pCells->cell[i].rgbGreen;
                    sumB0[0] += pCells->cell[i].rgbBlue;
                }
                else
                {
                    mask |= (1 << i);
                    ones[0]++;
                    sumR1[0] += pCells->cell[i].rgbRed;
                    sumG1[0] += pCells->cell[i].rgbGreen;
                    sumB1[0] += pCells->cell[i].rgbBlue;
                }
            }

            // define the "one" color as the mean of each element
            if( ones[0] != 0 )
            {
                meanR1[0] = sumR1[0] / ones[0];
                meanG1[0] = sumG1[0] / ones[0];
                meanB1[0] = sumB1[0] / ones[0];
            }
            else
            {
                meanR1[0] = meanG1[0] = meanB1[0] = 0;
            }

            if( zeros[0] != 0 )
            {
                meanR0[0] = sumR0[0] / zeros[0];
                meanG0[0] = sumG0[0] / zeros[0];
                meanB0[0] = sumB0[0] / zeros[0];
            }
            else
            {
                meanR0[0] = meanG0[0] = meanB0[0] = 0;
            }

            //
            // build the block and make sure, it is within error.
            //
            for( i=0; i < HEIGHT_CBLOCK*WIDTH_CBLOCK; i++ )
            {
                if( luminance[i] < luminanceMean[0] )
                {
                    pCells->cellT[i].rgbRed   = (BYTE)meanR0[0];
                    pCells->cellT[i].rgbGreen = (BYTE)meanG0[0];
                    pCells->cellT[i].rgbBlue  = (BYTE)meanB0[0];
                }
                else
                {
                    pCells->cellT[i].rgbRed   = (BYTE)meanR1[0];
                    pCells->cellT[i].rgbGreen = (BYTE)meanG1[0];
                    pCells->cellT[i].rgbBlue  = (BYTE)meanB1[0];
                }
            }

            if (CmpCell(pCells->cell, pCells->cellT) <= threshold)
            {
                if (lpbiPrev && CmpCell(pCells->cellT, pCells->cellPrev) <= thresholdInter)
                {
                    numberOfExtraSkips++;
                    goto skip_cell;
                }

                //
                // handle any outstanding skip codes
                //
                FlushSkips();

                //
                // we should never, ever generate a mask of all ones or
                // zeros!
                //
                if (mask == 0x0000)
                {
                    DPF(("4x4 generated a zero mask!"));
                    sumR = meanR0[0]; sumG = meanG0[0]; sumB = meanB0[0];
                    goto solid_color;
                }

                if (mask == 0xFFFF)
                {
                    DPF(("4x4 generated a FFFF mask!"));
                    sumR = meanR1[0]; sumG = meanG1[0]; sumB = meanB1[0];
                    goto solid_color;
                }


                //
                // remember the high bit of the mask is used to mark
                // a skip or solid color, so make sure the high bit
                // is zero.
                //
                if (mask & 0x8000)
                {
                    *dst++ = ~mask;
                    *dst++ = RGB16(meanR0[0],meanG0[0],meanB0[0]);
                    *dst++ = RGB16(meanR1[0],meanG1[0],meanB1[0]);
                }
                else
                {
                    *dst++ = mask;
                    *dst++ = RGB16(meanR1[0],meanG1[0],meanB1[0]);
                    *dst++ = RGB16(meanR0[0],meanG0[0],meanB0[0]);
                }
                actualSize += 6;
                numberOfBlocks++;

                continue;
            }

//////////////////////////////////////////////////////////////////////////
//
// see if we make the cell four solid colorls, and get away with it
//
//  C D E F
//  8 9 A C
//  4 5 6 7
//  0 1 2 3
//
//////////////////////////////////////////////////////////////////////////

#ifdef DEBUG
            for (i=0; i <= 10; i == 2 ? (i += 6) : (i += 2))
            {
                pCells->cellT[i].rgbRed   = (BYTE)(((WORD)pCells->cell[i].rgbRed
                                            + pCells->cell[i+1].rgbRed
                                            + pCells->cell[i+4].rgbRed
                                            + pCells->cell[i+5].rgbRed ) / 4);
                pCells->cellT[i].rgbGreen = (BYTE)(((WORD)pCells->cell[i].rgbGreen
                                            + pCells->cell[i+1].rgbGreen
                                            + pCells->cell[i+4].rgbGreen
                                            + pCells->cell[i+5].rgbGreen ) / 4);
                pCells->cellT[i].rgbBlue  = (BYTE)(((WORD)pCells->cell[i].rgbBlue
                                            + pCells->cell[i+1].rgbBlue
                                            + pCells->cell[i+4].rgbBlue
                                            + pCells->cell[i+5].rgbBlue ) / 4);
                pCells->cellT[i+1] = pCells->cellT[i+4]
                                   = pCells->cellT[i+5]
                                   = pCells->cellT[i];
            }

            if (CmpCell(pCells->cell, pCells->cellT) <= threshold)
            {
                // four colors
                numberOfSolid4++;
            }
#endif

//////////////////////////////////////////////////////////////////////////
//
//  make a 2x2 block
//
//////////////////////////////////////////////////////////////////////////

            FlushSkips();

            numberOfEdges++;

            luminanceMean[0] = (luminance[0]  + luminance[1]  + luminance[4]  + luminance[5])  / 4;
            luminanceMean[1] = (luminance[2]  + luminance[3]  + luminance[6]  + luminance[7])  / 4;
            luminanceMean[2] = (luminance[8]  + luminance[9]  + luminance[12] + luminance[13]) / 4;
            luminanceMean[3] = (luminance[10] + luminance[11] + luminance[14] + luminance[15]) / 4;

            // zero summing arrays
            zeros[0]=zeros[1]=zeros[2]=zeros[3]=0;
            ones[0]=ones[1]=ones[2]=ones[3]=0;
            sumR0[0]=sumR0[1]=sumR0[2]=sumR0[3]=0;
            sumR1[0]=sumR1[1]=sumR1[2]=sumR1[3]=0;
            sumG0[0]=sumG0[1]=sumG0[2]=sumG0[3]=0;
            sumG1[0]=sumG1[1]=sumG1[2]=sumG1[3]=0;
            sumB0[0]=sumB0[1]=sumB0[2]=sumB0[3]=0;
            sumB1[0]=sumB1[1]=sumB1[2]=sumB1[3]=0;

            // define which of the two colors to choose
            // for each pixel by creating the mask
            mask = 0;
            for( i=0; i < HEIGHT_CBLOCK*WIDTH_CBLOCK; i++ )
            {
                mi = meanIndex[i];
                if( luminance[i] < luminanceMean[mi] )
                {
                    // mask &= ~(1 << i);     // already clear
                    zeros[mi]++;
                    sumR0[mi] += pCells->cell[i].rgbRed;
                    sumG0[mi] += pCells->cell[i].rgbGreen;
                    sumB0[mi] += pCells->cell[i].rgbBlue;
                }
                else
                {
                    mask |= (1 << i);
                    ones[mi]++;
                    sumR1[mi] += pCells->cell[i].rgbRed;
                    sumG1[mi] += pCells->cell[i].rgbGreen;
                    sumB1[mi] += pCells->cell[i].rgbBlue;
                }
            }

            // store the mask

            if (mask & 0x8000)
                *dst++ = ~mask;
            else
                *dst++ = mask;

            actualSize += 2;

            // make the colors
            for( i=0; i < 4; i++ )
            {
                // define the "one" color as the mean of each element
                if( ones[i] != 0 )
                {
                    meanR1[i] = sumR1[i] / ones[i];
                    meanG1[i] = sumG1[i] / ones[i];
                    meanB1[i] = sumB1[i] / ones[i];
                }
                else
                {
                    meanR1[i] = meanG1[i] = meanB1[i] = 0;
                }

                if( zeros[i] != 0 )
                {
                    meanR0[i] = sumR0[i] / zeros[i];
                    meanG0[i] = sumG0[i] / zeros[i];
                    meanB0[i] = sumB0[i] / zeros[i];
                }
                else
                {
                    meanR0[i] = meanG0[i] = meanB0[i] = 0;
                }

                // convert to 555 and set bit 15 if this is an edge and
                // this is the first color

                if (mask & 0x8000)
                {
                    *dst++ = RGB16(meanR0[i],meanG0[i],meanB0[i]) | (i==0 ? 0x8000 : 0);
                    *dst++ = RGB16(meanR1[i],meanG1[i],meanB1[i]);
                }
                else
                {
                    *dst++ = RGB16(meanR1[i],meanG1[i],meanB1[i]) | (i==0 ? 0x8000 : 0);
                    *dst++ = RGB16(meanR0[i],meanG0[i],meanB0[i]);
                }
                actualSize += 4;
            }
        }

//////////////////////////////////////////////////////////////////////////
//
//  next scan.
//
//////////////////////////////////////////////////////////////////////////

        ((HPBYTE)lpBits) += WidthBytes * HEIGHT_CBLOCK;

        if (lpPrev)
            ((HPBYTE)lpPrev) += WidthBytesPrev * HEIGHT_CBLOCK;
    }

//////////////////////////////////////////////////////////////////////////
//
//  take care of any outstanding skips, !!! note we dont need this if we
//  assume a EOF!
//
//////////////////////////////////////////////////////////////////////////

    FlushSkips();

//////////////////////////////////////////////////////////////////////////
//
//  all done generate a EOF zero mask
//
//////////////////////////////////////////////////////////////////////////

    *dst++ = 0;
    actualSize += 2;

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

    DPF(("CompressFrame16:"));
    DPF(("           time: %ld", timeGetTime() - time));
    DPF(("            tol: %ld/%ld", threshold, thresholdInter));
    DPF(("           Size: %ld", actualSize));
    DPF(("          Skips: %ld (%ld)", numberOfSkips, numberOfSkipCodes));
    DPF(("    Extra Skips: %ld", numberOfExtraSkips));
    DPF(("          Solid: %ld", numberOfSolids));
    DPF(("            4x4: %ld", numberOfBlocks));
    DPF(("            2x2: %ld", numberOfEdges));
    DPF(("        EvilRed: %ld", numberOfEvilRed));
    DPF(("         4Solid: %ld", numberOfSolid4));

    return( actualSize );
}


/*******************************************************************
routine: CompressFrame8
purp:    compress a frame, outputing 8 bit compressed data.
returns: number of bytes in compressed buffer

!!! this is almost a 1:1 copy of the above routine help!
*******************************************************************/

DWORD FAR CompressFrame8(LPBITMAPINFOHEADER  lpbi,           // DIB header to compress
                     LPVOID              lpBits,         // DIB bits to compress
                     LPVOID              lpData,         // put compressed data here
                     DWORD               threshold,      // edge threshold
                     DWORD               thresholdInter, // inter-frame threshold
                     LPBITMAPINFOHEADER  lpbiPrev,       // previous frame
                     LPVOID              lpPrev,         // previous frame
		     LONG (CALLBACK *Status) (LPARAM lParam, UINT message, LONG l),
		     LPARAM		 lParam,
                     PCELLS              pCells,
		     LPBYTE		 lpITable,
		     RGBQUAD *		 prgbqOut)

{
UINT            bix;
UINT            biy;
UINT            WidthBytes;
UINT            WidthBytesPrev;

WORD            SkipCount;

WORD            luminance[16], luminanceMean[4];
DWORD           luminanceSum;
WORD            sumR,sumG,sumB;
WORD            sumR0[4],sumG0[4],sumB0[4];
WORD            sumR1[4],sumG1[4],sumB1[4];
WORD            meanR0[4],meanG0[4],meanB0[4];
WORD            meanR1[4],meanG1[4],meanB1[4];
WORD            zeros[4], ones[4];
UINT            x,y;
WORD            mask;
HPBYTE          srcPtr;
HPBYTE          prvPtr;
DWORD           actualSize;
UINT            i;
WORD            mi;
HPWORD          dst;
RGBQUAD         rgb,rgb0,rgb1;
BYTE            b, b0, b1;
WORD            w;
int		iStatusEvery;

#ifdef DEBUG
DWORD           time = timeGetTime();
#endif

    WidthBytes = DIBWIDTHBYTES(*lpbi);

    if (lpbiPrev)
        WidthBytesPrev = DIBWIDTHBYTES(*lpbiPrev);

    bix = (int)lpbi->biWidth/WIDTH_CBLOCK;
    biy = (int)lpbi->biHeight/HEIGHT_CBLOCK;

    if (bix < 100)
	iStatusEvery = 4;
    else if (bix < 200)
	iStatusEvery = 2;
    else
	iStatusEvery = 1;

    actualSize = 0;
    numberOfSkipCodes   = 0;
    numberOfSkips       = 0;
    numberOfExtraSkips  = 0;
    numberOfEdges       = 0;
    numberOfBlocks      = 0;
    numberOfSolids      = 0;
    numberOfSolid4      = 0;
    numberOfSolid2      = 0;
    numberOfEvilRed     = 0;

    dst = (HPWORD)lpData;
    SkipCount = 0;

    if (lpITable == NULL)
    {
        DPF(("ICM_COMPRESS_BEGIN not recieved!"));
        return 0;
    }

    for( y = 0; y < biy; y++ )
    {
        srcPtr = lpBits;
        prvPtr = lpPrev;

	if (Status && ((y % iStatusEvery) == 0)) {
	    if (Status(lParam, ICSTATUS_STATUS, (y * 100) / biy) != 0)
		return (DWORD) -1;
	}

        for( x = 0; x < bix; x++ )
        {
//////////////////////////////////////////////////////////////////////////
//
// get the cell to compress from the image.
//
//////////////////////////////////////////////////////////////////////////
            srcPtr = GetCell(lpbi, srcPtr, pCells->cell);

//////////////////////////////////////////////////////////////////////////
//
//  see if it matches the cell in the previous frame.
//
//////////////////////////////////////////////////////////////////////////
            if (lpbiPrev)
            {
                prvPtr = GetCell(lpbiPrev, prvPtr, pCells->cellPrev);

                if (CmpCell(pCells->cell, pCells->cellPrev) <= thresholdInter)
                {
skip_cell:
                    numberOfSkips++;
                    SkipCount++;
                    continue;
                }
            }

//////////////////////////////////////////////////////////////////////////
// compute luminance of each pixel in the compression block
// sum the total luminance in the block
// find the pixels with the largest and smallest luminance
//////////////////////////////////////////////////////////////////////////

            luminanceSum = 0;
            sumR = 0;
            sumG = 0;
            sumB = 0;

            for (i = 0; i < HEIGHT_CBLOCK*WIDTH_CBLOCK; i++)
            {
                sumR += pCells->cell[i].rgbRed;
                sumG += pCells->cell[i].rgbGreen;
                sumB += pCells->cell[i].rgbBlue;

                luminance[i] = RgbToY(pCells->cell[i]);
                luminanceSum += luminance[i];
            }

//////////////////////////////////////////////////////////////////////////
//
// see if we make the cell a single color, and get away with it
//
//////////////////////////////////////////////////////////////////////////
            sumR /= HEIGHT_CBLOCK*WIDTH_CBLOCK;
            sumG /= HEIGHT_CBLOCK*WIDTH_CBLOCK;
            sumB /= HEIGHT_CBLOCK*WIDTH_CBLOCK;

            rgb.rgbRed   = (BYTE)sumR;
            rgb.rgbGreen = (BYTE)sumG;
            rgb.rgbBlue  = (BYTE)sumB;

            b = MAPRGB(rgb);            // map color to 8bit
            rgb = prgbqOut[b];

            for (i=0; i < HEIGHT_CBLOCK*WIDTH_CBLOCK; i++)
                pCells->cellT[i] = rgb;

            if (CmpCell(pCells->cell, pCells->cellT) <= threshold)
            {
                if (lpbiPrev && CmpCell(pCells->cellT, pCells->cellPrev) <= thresholdInter)
                {
                    numberOfExtraSkips++;
                    goto skip_cell;
                }

                FlushSkips();

solid_color:
                // single color!!
                mask = SOLID_MAGIC | b;

                *dst++ = mask;
                numberOfSolids++;
                actualSize += 2;
                continue;
            }

//////////////////////////////////////////////////////////////////////////
//
//  make a 4x4 block
//
//////////////////////////////////////////////////////////////////////////

            luminanceMean[0] = (WORD)(luminanceSum >> 4);

            // zero summing arrays
            zeros[0]=0;
            ones[0] =0;
            sumR0[0]=0;
            sumR1[0]=0;
            sumG0[0]=0;
            sumG1[0]=0;
            sumB0[0]=0;
            sumB1[0]=0;

            // define which of the two colors to choose
            // for each pixel by creating the mask
            mask = 0;
            for( i=0; i < HEIGHT_CBLOCK*WIDTH_CBLOCK; i++ )
            {
                if( luminance[i] < luminanceMean[0] )
                {
                    // mask &= ~(1 << i);     // already clear
                    zeros[0]++;
                    sumR0[0] += pCells->cell[i].rgbRed;
                    sumG0[0] += pCells->cell[i].rgbGreen;
                    sumB0[0] += pCells->cell[i].rgbBlue;
                }
                else
                {
                    mask |= (1 << i);
                    ones[0]++;
                    sumR1[0] += pCells->cell[i].rgbRed;
                    sumG1[0] += pCells->cell[i].rgbGreen;
                    sumB1[0] += pCells->cell[i].rgbBlue;
                }
            }

            // define the "one" color as the mean of each element
            if( ones[0] != 0 )
            {
                meanR1[0] = sumR1[0] / ones[0];
                meanG1[0] = sumG1[0] / ones[0];
                meanB1[0] = sumB1[0] / ones[0];
            }
            else
            {
                meanR1[0] = meanG1[0] = meanB1[0] = 0;
            }

            if( zeros[0] != 0 )
            {
                meanR0[0] = sumR0[0] / zeros[0];
                meanG0[0] = sumG0[0] / zeros[0];
                meanB0[0] = sumB0[0] / zeros[0];
            }
            else
            {
                meanR0[0] = meanG0[0] = meanB0[0] = 0;
            }

            //
            // map colors to 8-bit
            //
            rgb0.rgbRed   = (BYTE)meanR0[0];
            rgb0.rgbGreen = (BYTE)meanG0[0];
            rgb0.rgbBlue  = (BYTE)meanB0[0];
            b0 = MAPRGB(rgb0);
            rgb0 = prgbqOut[b0];

            rgb1.rgbRed   = (BYTE)meanR1[0];
            rgb1.rgbGreen = (BYTE)meanG1[0];
            rgb1.rgbBlue  = (BYTE)meanB1[0];
            b1 = MAPRGB(rgb1);
            rgb1 = prgbqOut[b1];

            //
            // build the block and make sure, it is within error.
            //
            for( i=0; i < HEIGHT_CBLOCK*WIDTH_CBLOCK; i++ )
            {
                if( luminance[i] < luminanceMean[0] )
                    pCells->cellT[i] = rgb0;
                else
                    pCells->cellT[i] = rgb1;
            }

            if (CmpCell(pCells->cell, pCells->cellT) <= threshold)
            {
                if (lpbiPrev && CmpCell(pCells->cellT, pCells->cellPrev) <= thresholdInter)
                {
                    numberOfExtraSkips++;
                    goto skip_cell;
                }

                FlushSkips();

                // store the mask

                //
                // we should never, ever generate a mask of all ones or
                // zeros!
                //
                if (mask == 0x0000)
                {
                    DPF(("4x4 generated a zero mask!"));
                    b = b0;
                    goto solid_color;
                }

                if (mask == 0xFFFF)
                {
                    DPF(("4x4 generated a FFFF mask!"));
                    b = b1;
                    goto solid_color;
                }

                if (b0 == b1)
                {
                    DPF(("4x4 generated two colors the same!"));
                    b = b1;
                    goto solid_color;
                }

                //
                // remember the high bit of the mask is used to mark
                // a skip or solid color, so make sure the high bit
                // is zero.
                //
                if (mask & 0x8000)
                {
                    mask = ~mask;
                    SWAP(b0,b1);
                }

                *dst++ = mask;
                *dst++ = (WORD)b1 | ((WORD)b0 << 8);

                actualSize += 4;
                numberOfBlocks++;

                continue;
            }

//////////////////////////////////////////////////////////////////////////
//
//  make a 2x2 block
//
//////////////////////////////////////////////////////////////////////////

            FlushSkips();

            numberOfEdges++;

            luminanceMean[0] = (luminance[0]  + luminance[1]  + luminance[4]  + luminance[5])  / 4;
            luminanceMean[1] = (luminance[2]  + luminance[3]  + luminance[6]  + luminance[7])  / 4;
            luminanceMean[2] = (luminance[8]  + luminance[9]  + luminance[12] + luminance[13]) / 4;
            luminanceMean[3] = (luminance[10] + luminance[11] + luminance[14] + luminance[15]) / 4;

            // zero summing arrays
            zeros[0]=zeros[1]=zeros[2]=zeros[3]=0;
            ones[0]=ones[1]=ones[2]=ones[3]=0;
            sumR0[0]=sumR0[1]=sumR0[2]=sumR0[3]=0;
            sumR1[0]=sumR1[1]=sumR1[2]=sumR1[3]=0;
            sumG0[0]=sumG0[1]=sumG0[2]=sumG0[3]=0;
            sumG1[0]=sumG1[1]=sumG1[2]=sumG1[3]=0;
            sumB0[0]=sumB0[1]=sumB0[2]=sumB0[3]=0;
            sumB1[0]=sumB1[1]=sumB1[2]=sumB1[3]=0;

            // define which of the two colors to choose
            // for each pixel by creating the mask
            mask = 0;
            for( i=0; i < HEIGHT_CBLOCK*WIDTH_CBLOCK; i++ )
            {
                mi = meanIndex[i];
                if( luminance[i] < luminanceMean[mi] )
                {
                    // mask &= ~(1 << i);     // already clear
                    zeros[mi]++;
                    sumR0[mi] += pCells->cell[i].rgbRed;
                    sumG0[mi] += pCells->cell[i].rgbGreen;
                    sumB0[mi] += pCells->cell[i].rgbBlue;
                }
                else
                {
                    mask |= (1 << i);
                    ones[mi]++;
                    sumR1[mi] += pCells->cell[i].rgbRed;
                    sumG1[mi] += pCells->cell[i].rgbGreen;
                    sumB1[mi] += pCells->cell[i].rgbBlue;
                }
            }

            // store the mask
            //
            //  in the 8-bit case the mask must have the following form:
            //
            //      1X1XXXXXXXXXXXXX
            //
            //  these bits can be forces high by exchanging the colors for
            //  the top two cells.
            //

            w = mask;

            if (!(mask & 0x8000))
                w ^= 0xCC00;

            if (!(mask & 0x2000))
                w ^= 0x3300;

            *dst++ = w;
            actualSize += 2;

            // make the colors
            for( i=0; i < 4; i++ )
            {
                // define the "one" color as the mean of each element
                if( ones[i] != 0 )
                {
                    meanR1[i] = sumR1[i] / ones[i];
                    meanG1[i] = sumG1[i] / ones[i];
                    meanB1[i] = sumB1[i] / ones[i];
                }
                else
                {
                    meanR1[i] = meanG1[i] = meanB1[i] = 0;
                }

                if( zeros[i] != 0 )
                {
                    meanR0[i] = sumR0[i] / zeros[i];
                    meanG0[i] = sumG0[i] / zeros[i];
                    meanB0[i] = sumB0[i] / zeros[i];
                }
                else
                {
                    meanR0[i] = meanG0[i] = meanB0[i] = 0;
                }

                // convert to the 8bit palette, and write out the colors
                // make sure to exchange the colors if we hade to invert
                // the mask to normalize it.

                rgb0.rgbRed   = (BYTE)meanR0[i];
                rgb0.rgbGreen = (BYTE)meanG0[i];
                rgb0.rgbBlue  = (BYTE)meanB0[i];
                b0 = MAPRGB(rgb0);

                rgb1.rgbRed   = (BYTE)meanR1[i];
                rgb1.rgbGreen = (BYTE)meanG1[i];
                rgb1.rgbBlue  = (BYTE)meanB1[i];
                b1 = MAPRGB(rgb1);

                if (i==3 && !(mask & 0x8000))
                    SWAP(b0,b1);

                if (i==2 && !(mask & 0x2000))
                    SWAP(b0,b1);

                if (b0 == b0)
                {
                    numberOfSolid2++;
                }

                *dst++ = (WORD)b1 | ((WORD)b0 << 8);
                actualSize += 2;
            }
        }

//////////////////////////////////////////////////////////////////////////
//
//  next scan.
//
//////////////////////////////////////////////////////////////////////////

        ((HPBYTE)lpBits) += WidthBytes * HEIGHT_CBLOCK;

        if (lpPrev)
            ((HPBYTE)lpPrev) += WidthBytesPrev * HEIGHT_CBLOCK;
    }

//////////////////////////////////////////////////////////////////////////
//
//  take care of any outstanding skips, !!! note we dont need this if we
//  assume a EOF!
//
//////////////////////////////////////////////////////////////////////////

    FlushSkips();

//////////////////////////////////////////////////////////////////////////
//
//  all done generate a EOF zero mask
//
//////////////////////////////////////////////////////////////////////////

    *dst++ = 0;
    actualSize += 2;

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

    DPF(("CompressFrame8:"));
    DPF(("          time: %ld", timeGetTime() - time));
    DPF(("           tol: %ld/%ld", threshold, thresholdInter));
    DPF(("          Size: %ld", actualSize));
    DPF(("         Skips: %ld (%ld)", numberOfSkips, numberOfSkipCodes));
    DPF(("   Extra Skips: %ld", numberOfExtraSkips));
    DPF(("         Solid: %ld", numberOfSolids));
    DPF(("           4x4: %ld", numberOfBlocks));
    DPF(("           2x2: %ld", numberOfEdges));

    return( actualSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvidc\compress.h ===
/*----------------------------------------------------------------------+
| compress.h - Microsoft Video 1 Compressor - compress header file	|
|									|
| Copyright (c) 1990-1994 Microsoft Corporation.			|
| Portions Copyright Media Vision Inc.					|
| All Rights Reserved.							|
|									|
| You have a non-exclusive, worldwide, royalty-free, and perpetual	|
| license to use this source code in developing hardware, software	|
| (limited to drivers and other software required for hardware		|
| functionality), and firmware for video display and/or processing	|
| boards.   Microsoft makes no warranties, express or implied, with	|
| respect to the Video 1 codec, including without limitation warranties	|
| of merchantability or fitness for a particular purpose.  Microsoft	|
| shall not be liable for any damages whatsoever, including without	|
| limitation consequential damages arising from your use of the Video 1	|
| codec.								|
|									|
|									|
+----------------------------------------------------------------------*/

/*******************************************************************

    encoding a skip - if the mask (first word) has the high bit set
    then it is either a skip cell code, or a solid color code.

    you can't encode a r=01 solid color, this is how we tell a skip
    from a solid (not a big loss)

*******************************************************************/
#define SKIP_MAX    SKIP_MASK
#define SKIP_MASK   ((WORD) (((1<<10)-1)))
#define MAGIC_MASK  ~SKIP_MASK
#define SKIP_MAGIC  0x8400          // r=01
#define SOLID_MAGIC 0x8000
#define MASK_MAGIC  0xA000

/*******************************************************************
*******************************************************************/

extern DWORD   numberOfBlocks;
extern DWORD   numberOfSolids;
extern DWORD   numberOfSolid4;
extern DWORD   numberOfEdges;
extern DWORD   numberOfSkips;
extern DWORD   numberOfSkipCodes;

/*******************************************************************
*******************************************************************/

//
//  this is a CELL (4x4) array of RGBQUADs
//
typedef RGBQUAD CELL[HEIGHT_CBLOCK * WIDTH_CBLOCK];
typedef RGBQUAD *PCELL;

typedef struct _CELLS {
    CELL cell;
    CELL cellT;
    CELL cellPrev;
} CELLS;
typedef CELLS * PCELLS;

/*******************************************************************
routine: CompressFrame
purp:   compress a frame
returns: number of bytes in compressed buffer
*******************************************************************/

DWORD FAR CompressFrame16(LPBITMAPINFOHEADER  lpbi,           // DIB header to compress
                          LPVOID              lpBits,         // DIB bits to compress
                          LPVOID              lpData,         // put compressed data here
                          DWORD               threshold,      // edge threshold
                          DWORD               thresholdInter, // inter-frame threshold
                          LPBITMAPINFOHEADER  lpbiPrev,       // previous frame
                          LPVOID              lpPrev,         // previous frame
			  LONG (CALLBACK *Status) (LPARAM lParam, UINT message, LONG l),
 			  LPARAM lParam,
                          PCELLS pCells);

DWORD FAR CompressFrame8(LPBITMAPINFOHEADER  lpbi,           // DIB header to compress
                         LPVOID              lpBits,         // DIB bits to compress
                         LPVOID              lpData,         // put compressed data here
                         DWORD               threshold,      // edge threshold
                         DWORD               thresholdInter, // inter-frame threshold
                         LPBITMAPINFOHEADER  lpbiPrev,       // previous frame
                         LPVOID              lpPrev,         // previous frame
			 LONG (CALLBACK *Status) (LPARAM lParam, UINT message, LONG l),
			 LPARAM lParam,
                         PCELLS pCells,
			 LPBYTE lpITable,
			 RGBQUAD *prgbqOut);


DWORD FAR CompressFrameBegin(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut,
			     LPBYTE *lplpITable, RGBQUAD *prgbIn);
DWORD FAR CompressFrameEnd(LPBYTE *lplpITable);

void FAR CompressFrameFree(void);

DWORD FAR QualityToThreshold(DWORD dwQuality);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvidc\debug.c ===
/* Debug.c
 *
 * Debug functions for compression manager
 */


#include <windows.h>
#include <stdarg.h>
#include <win32.h>

#ifdef DEBUG  // See comments in NTAVI.H about DEBUG

#ifdef _WIN32
#include <profile.key>

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
UINT mmGetProfileIntA(LPSTR appname, LPSTR valuename, INT uDefault)
{
    CHAR achName[MAX_PATH];
    HKEY hkey;
    DWORD dwType;
    INT value = uDefault;
    DWORD dwData;
    int cbData;

    lstrcpyA(achName, KEYNAMEA);
    lstrcatA(achName, appname);
    if (RegOpenKeyA(ROOTKEY, achName, &hkey) == ERROR_SUCCESS) {

        cbData = sizeof(dwData);
        if (RegQueryValueExA(
            hkey,
            valuename,
            NULL,
            &dwType,
            (PBYTE) &dwData,
            &cbData) == ERROR_SUCCESS) {

            if (dwType == REG_DWORD || dwType == REG_BINARY) {
                value = (INT)dwData;
#ifdef USESTRINGSALSO
            } else if (dwType == REG_SZ) {
	        value = atoi((LPSTR) &dwData);
#endif
    	    }
        }

        RegCloseKey(hkey);
    }

    return((UINT)value);
}
#endif

/* _Assert(fExpr, szFile, iLine)
 *
 * If <fExpr> is TRUE, then do nothing.  If <fExpr> is FALSE, then display
 * an "assertion failed" message box allowing the user to abort the program,
 * enter the debugger (the "Retry" button), or igore the error.
 *
 * <szFile> is the name of the source file; <iLine> is the line number
 * containing the _Assert() call.
 */
#pragma optimize("", off)
BOOL FAR PASCAL
_Assert(BOOL fExpr, LPSTR szFile, int iLine)
{
#ifdef _WIN32
	char	ach[300];	
#else
	static char	ach[300];	// debug output (avoid stack overflow)
#endif
	int		id;
	int		iExitCode;
	void FAR PASCAL DebugBreak(void);

	/* check if assertion failed */
	if (fExpr)
		return fExpr;

	/* display error message */
	wsprintfA(ach, "File %s, line %d", (LPSTR) szFile, iLine);
	MessageBeep(MB_ICONHAND);
	id = MessageBoxA(NULL, ach, "Assertion Failed",
		MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE);

	/* abort, debug, or ignore */
	switch (id)
	{

	case IDABORT:

		/* kill this application */
		iExitCode = 0;
#ifndef _WIN32
		_asm
		{
			mov	ah, 4Ch
			mov	al, BYTE PTR iExitCode
			int     21h
		}
#endif // WIN16
		break;

	case IDRETRY:

		/* break into the debugger */
		DebugBreak();
		break;

	case IDIGNORE:

		/* ignore the assertion failure */
		break;

	}
	
	return FALSE;
}
#pragma optimize("", on)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvidc\decmprss.h ===
/*----------------------------------------------------------------------+
| decmprss.h - Microsoft Video 1 Compressor - decompress header file	|
|									|
| Copyright (c) 1990-1994 Microsoft Corporation.			|
| Portions Copyright Media Vision Inc.					|
| All Rights Reserved.							|
|									|
| You have a non-exclusive, worldwide, royalty-free, and perpetual	|
| license to use this source code in developing hardware, software	|
| (limited to drivers and other software required for hardware		|
| functionality), and firmware for video display and/or processing	|
| boards.   Microsoft makes no warranties, express or implied, with	|
| respect to the Video 1 codec, including without limitation warranties	|
| of merchantability or fitness for a particular purpose.  Microsoft	|
| shall not be liable for any damages whatsoever, including without	|
| limitation consequential damages arising from your use of the Video 1	|
| codec.								|
|									|
|									|
+----------------------------------------------------------------------*/

// width and height of a compression blocks
#define WIDTH_CBLOCK 4
#define HEIGHT_CBLOCK 4

#define EDGE_HEIGHT_CBLOCK 2
#define EDGE_WIDTH_CBLOCK 2
#define EDGE_SUBBLOCKS ((HEIGHT_CBLOCK * WIDTH_CBLOCK) / (EDGE_HEIGHT_CBLOCK * EDGE_WIDTH_CBLOCK))

#define NEXT_BLOCK( row, bpr, height ) (((HPBYTE)row) + (bpr*height))
#define NEXT_BYTE_ROW( row, bpr ) (((HPBYTE)row) + bpr)
#define NEXT_RGBT_PIXEL_ROW( row, bpr ) ((HPRGBTRIPLE)(((HPBYTE)row) + bpr))
#define NEXT_BLOCK_ROW( row, bpr, height ) ((HPRGBTRIPLE)NEXT_BLOCK( row, bpr, height ))

typedef DWORD (FAR PASCAL *DECOMPPROC)(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                       LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y);

// in decmprss.c
DWORD FAR PASCAL DecompressFrame24(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                        LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y);

// in decmprss.c
DWORD FAR PASCAL DecompressFrame8(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                       LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y);

#ifndef _WIN32

// in decram8.asm
DWORD FAR PASCAL DecompressCram8(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                       LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y);

// in decram8.asm
DWORD FAR PASCAL DecompressCram8x2(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                       LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y);

// in decram16.asm
DWORD FAR PASCAL DecompressCram16(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                       LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y);

DWORD FAR PASCAL DecompressCram16x2(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                       LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y);

// in dcram168.asm
DWORD FAR PASCAL DecompressCram168(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                       LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y);

// in decram32.asm
DWORD FAR PASCAL DecompressCram32(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                       LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y);

DWORD FAR PASCAL DecompressCram32x2(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                       LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y);

// in dcram286.asm
DWORD FAR PASCAL DecompressCram8_286(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                       LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y);

// in dcram286.asm
DWORD FAR PASCAL DecompressCram16_286(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                       LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y);
#else
// in decmprss.c
DWORD FAR PASCAL DecompressFrame8X2C(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                       LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y);

// in decmprss.c
DWORD FAR PASCAL DecompressFrame16To8C(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                                  LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y);

// in decmprss.c
DWORD FAR PASCAL DecompressFrame16To555C(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                        LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y);

DWORD FAR PASCAL DecompressFrame16To565C(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                        LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y);

// in decmprss.c
DWORD FAR PASCAL DecompressFrame16To8X2C(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                        LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvidc\drvproc.c ===
/*----------------------------------------------------------------------+
|									|
| drvproc.c - driver procedure						|
|									|
| Copyright (c) 1990-1994 Microsoft Corporation.			|
| Portions Copyright Media Vision Inc.					|
| All Rights Reserved.							|
|									|
| You have a non-exclusive, worldwide, royalty-free, and perpetual	|
| license to use this source code in developing hardware, software	|
| (limited to drivers and other software required for hardware		|
| functionality), and firmware for video display and/or processing	|
| boards.   Microsoft makes no warranties, express or implied, with	|
| respect to the Video 1 codec, including without limitation warranties	|
| of merchantability or fitness for a particular purpose.  Microsoft	|
| shall not be liable for any damages whatsoever, including without	|
| limitation consequential damages arising from your use of the Video 1	|
| codec.								|
|									|
+----------------------------------------------------------------------*/
#include <windows.h>
#include <win32.h>
#include <mmsystem.h>

#ifndef _INC_COMPDDK
#define _INC_COMPDDK    50      /* version number */
#endif

#include <vfw.h>
#include "msvidc.h"
#ifdef _WIN32
//#include <mmddk.h>
//LONG   FAR PASCAL DefDriverProc(DWORD dwDriverIdentifier, HANDLE driverID, UINT message, LONG lParam1, LONG lParam2);
#endif

HMODULE ghModule = NULL;

/***************************************************************************
 * DriverProc  -  The entry point for an installable driver.
 *
 * PARAMETERS
 * dwDriverId:  For most messages, <dwDriverId> is the DWORD
 *     value that the driver returns in response to a <DRV_OPEN> message.
 *     Each time that the driver is opened, through the <DrvOpen> API,
 *     the driver receives a <DRV_OPEN> message and can return an
 *     arbitrary, non-zero value. The installable driver interface
 *     saves this value and returns a unique driver handle to the
 *     application. Whenever the application sends a message to the
 *     driver using the driver handle, the interface routes the message
 *     to this entry point and passes the corresponding <dwDriverId>.
 *     This mechanism allows the driver to use the same or different
 *     identifiers for multiple opens but ensures that driver handles
 *     are unique at the application interface layer.
 *
 *     The following messages are not related to a particular open
 *     instance of the driver. For these messages, the dwDriverId
 *     will always be zero.
 *
 *         DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
 *
 * hDriver: This is the handle returned to the application by the
 *    driver interface.
 *
 * uiMessage: The requested action to be performed. Message
 *     values below <DRV_RESERVED> are used for globally defined messages.
 *     Message values from <DRV_RESERVED> to <DRV_USER> are used for
 *     defined driver protocols. Messages above <DRV_USER> are used
 *     for driver specific messages.
 *
 * lParam1: Data for this message.  Defined separately for
 *     each message
 *
 * lParam2: Data for this message.  Defined separately for
 *     each message
 *
 * RETURNS
 *   Defined separately for each message.
 *
 ***************************************************************************/

#ifdef _WIN32
// rely on whoever is loading us to synchronize load/free
UINT LoadCount = 0;
#endif


LRESULT FAR PASCAL _LOADDS DriverProc(DWORD_PTR dwDriverID, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2)
{
    INSTINFO *pi = (INSTINFO *)dwDriverID;

    LPBITMAPINFOHEADER lpbiIn;
    LPBITMAPINFOHEADER lpbiOut;
    ICDECOMPRESSEX FAR *px;
#ifdef _WIN32
    LRESULT lres;
#endif
    
    switch (uiMessage)
    {
        case DRV_LOAD:
#ifdef _WIN32
            if (ghModule) {
                // AVI explicitly loads us as well, but does not pass the
                // correct (as known by WINMM) driver handle.
            } else {
                ghModule = (HANDLE) GetDriverModuleHandle(hDriver);
            }
	    lres = VideoLoad();
            if (lres) {
                ++LoadCount;
            }
	    return lres;
#else
	    return (LRESULT) VideoLoad();
#endif

	case DRV_FREE:
	    VideoFree();
#ifdef _WIN32
            if (--LoadCount) {
            } else {
                ghModule = NULL;
            }
#endif
	    return (LRESULT)1L;

        case DRV_OPEN:
	    // if being opened with no open struct, then return a non-zero
	    // value without actually opening
	    if (lParam2 == 0L)
                return 0xFFFF0000;

	    return (LRESULT)(DWORD_PTR)(UINT_PTR)VideoOpen((ICOPEN FAR *) lParam2);

	case DRV_CLOSE:
#ifdef _WIN32
	    if (dwDriverID != 0xFFFF0000)
#else
	    if (pi)
#endif
		VideoClose(pi);

	    return (LRESULT)1L;

	/*********************************************************************

	    state messages

	*********************************************************************/

        case DRV_QUERYCONFIGURE:    // configuration from drivers applet
            return (LRESULT)0L;

        case DRV_CONFIGURE:
            return DRV_OK;

        case ICM_CONFIGURE:
            //
            //  return ICERR_OK if you will do a configure box, error otherwise
            //
            if (lParam1 == -1)
		return QueryConfigure(pi) ? ICERR_OK : ICERR_UNSUPPORTED;
	    else
		return Configure(pi, (HWND)lParam1);

        case ICM_ABOUT:
            //
            //  return ICERR_OK if you will do a about box, error otherwise
            //
            if (lParam1 == -1)
		return QueryAbout(pi) ? ICERR_OK : ICERR_UNSUPPORTED;
	    else
		return About(pi, (HWND)lParam1);

	case ICM_GETSTATE:
	    return GetState(pi, (LPVOID)lParam1, (DWORD)lParam2);

	case ICM_SETSTATE:
	    return SetState(pi, (LPVOID)lParam1, (DWORD)lParam2);

	case ICM_GETINFO:
            return GetInfo(pi, (ICINFO FAR *)lParam1, (DWORD)lParam2);

        case ICM_GETDEFAULTQUALITY:
            if (lParam1)
            {
                *((LPDWORD)lParam1) = 7500;
                return ICERR_OK;
            }
            break;

	/*********************************************************************

            get/set messages

	*********************************************************************/

        case ICM_GET:
            break;
	
	/*********************************************************************

	    compression messages

	*********************************************************************/

	case ICM_COMPRESS_QUERY:
	    return CompressQuery(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_COMPRESS_BEGIN:
	    return CompressBegin(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_COMPRESS_GET_FORMAT:
	    return CompressGetFormat(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

	case ICM_COMPRESS_GET_SIZE:
	    return CompressGetSize(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);
	
	case ICM_COMPRESS:
	    return Compress(pi,
			    (ICCOMPRESS FAR *)lParam1, (DWORD)lParam2);

	case ICM_COMPRESS_END:
	    return CompressEnd(pi);

	case ICM_SET_STATUS_PROC:
	    // DPF(("ICM_SET_STATUS_PROC\n"));
	    pi->Status = ((ICSETSTATUSPROC FAR *) lParam1)->Status;
	    pi->lParam = ((ICSETSTATUSPROC FAR *) lParam1)->lParam;
	    return 0;
	
        /*********************************************************************

            decompress format query messages

        *********************************************************************/

        case ICM_DECOMPRESS_GET_FORMAT:
	    return DecompressGetFormat(pi,
                         (LPBITMAPINFOHEADER)lParam1,
                         (LPBITMAPINFOHEADER)lParam2);

        case ICM_DECOMPRESS_GET_PALETTE:
            return DecompressGetPalette(pi,
			 (LPBITMAPINFOHEADER)lParam1,
			 (LPBITMAPINFOHEADER)lParam2);

        /*********************************************************************

            decompress (old) messages, map these to the new (ex) messages

        *********************************************************************/

        case ICM_DECOMPRESS_QUERY:
            lpbiIn  = (LPBITMAPINFOHEADER)lParam1;
            lpbiOut = (LPBITMAPINFOHEADER)lParam2;

            return DecompressQuery(pi,0,
                    lpbiIn,NULL,
                    0,0,-1,-1,
                    lpbiOut,NULL,
                    0,0,-1,-1);

        case ICM_DECOMPRESS_BEGIN:
            lpbiIn  = (LPBITMAPINFOHEADER)lParam1;
            lpbiOut = (LPBITMAPINFOHEADER)lParam2;

            return DecompressBegin(pi,0,
                    lpbiIn,NULL,
                    0,0,-1,-1,
                    lpbiOut,NULL,
                    0,0,-1,-1);

        case ICM_DECOMPRESS:
            px = (ICDECOMPRESSEX FAR *)lParam1;

            return Decompress(pi,0,
                    px->lpbiSrc,px->lpSrc,
                    0, 0, -1, -1,
                    px->lpbiDst,px->lpDst,
                    0, 0, -1, -1);

	case ICM_DECOMPRESS_END:
            return DecompressEnd(pi);

        /*********************************************************************

            decompress (ex) messages

        *********************************************************************/

        case ICM_DECOMPRESSEX_QUERY:
            px = (ICDECOMPRESSEX FAR *)lParam1;

            return DecompressQuery(pi,
                    px->dwFlags,
                    px->lpbiSrc,px->lpSrc,
                    px->xSrc,px->ySrc,px->dxSrc,px->dySrc,
                    px->lpbiDst,px->lpDst,
                    px->xDst,px->yDst,px->dxDst,px->dyDst);

        case ICM_DECOMPRESSEX_BEGIN:
            px = (ICDECOMPRESSEX FAR *)lParam1;

            return DecompressBegin(pi,
                    px->dwFlags,
                    px->lpbiSrc,px->lpSrc,
                    px->xSrc,px->ySrc,px->dxSrc,px->dySrc,
                    px->lpbiDst,px->lpDst,
                    px->xDst,px->yDst,px->dxDst,px->dyDst);

        case ICM_DECOMPRESSEX:
            px = (ICDECOMPRESSEX FAR *)lParam1;

            return Decompress(pi,
                    px->dwFlags,
                    px->lpbiSrc,px->lpSrc,
                    px->xSrc,px->ySrc,px->dxSrc,px->dySrc,
                    px->lpbiDst,px->lpDst,
                    px->xDst,px->yDst,px->dxDst,px->dyDst);

        case ICM_DECOMPRESSEX_END:
	    return DecompressEnd(pi);

	/*********************************************************************

	    draw messages

	*********************************************************************/

	case ICM_DRAW_BEGIN:
            return DrawBegin(pi,(ICDRAWBEGIN FAR *)lParam1, (DWORD)lParam2);

	case ICM_DRAW:
            return Draw(pi,(ICDRAW FAR *)lParam1, (DWORD)lParam2);

	case ICM_DRAW_END:
	    return DrawEnd(pi);
	
	/*********************************************************************

	    standard driver messages

	*********************************************************************/

	case DRV_DISABLE:
	    return (LRESULT)1L;
	case DRV_ENABLE:
	    return (LRESULT)1L;

	case DRV_INSTALL:
	    return (LRESULT)DRV_OK;
	case DRV_REMOVE:
	    return (LRESULT)DRV_OK;
    }

    if (uiMessage < DRV_USER)
        return DefDriverProc(dwDriverID, hDriver, uiMessage,lParam1,lParam2);
    else
	return ICERR_UNSUPPORTED;
}

#ifdef _WIN32

#if 0
BOOL DllInstanceInit(PVOID hModule, ULONG Reason, PCONTEXT pContext)
{
    if (Reason == DLL_PROCESS_ATTACH) {
        ghModule = (HANDLE) hModule;
    }
    return TRUE;
}
#endif

#else

/****************************************************************************
 * LibMain - Library initialization code.
 *
 * PARAMETERS
 * hModule: Our module handle.
 *
 * wHeapSize: The heap size from the .def file.
 *
 * lpCmdLine: The command line.
 *
 * Returns 1 if the initialization was successful and 0 otherwise.
 ***************************************************************************/
int NEAR PASCAL LibMain(HMODULE hModule, WORD wHeapSize, LPSTR lpCmdLine)
{
    ghModule = hModule;

    return 1;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvidc\invcmap.c ===
/*----------------------------------------------------------------------+
| invcmap.c - Microsoft Video 1 Compressor - Inverse Color Map.		|
|									|
| Copyright (c) 1990-1994 Microsoft Corporation.			|
| Portions Copyright Media Vision Inc.					|
| All Rights Reserved.							|
|									|
| You have a non-exclusive, worldwide, royalty-free, and perpetual	|
| license to use this source code in developing hardware, software	|
| (limited to drivers and other software required for hardware		|
| functionality), and firmware for video display and/or processing	|
| boards.   Microsoft makes no warranties, express or implied, with	|
| respect to the Video 1 codec, including without limitation warranties	|
| of merchantability or fitness for a particular purpose.  Microsoft	|
| shall not be liable for any damages whatsoever, including without	|
| limitation consequential damages arising from your use of the Video 1	|
| codec.								|
|									|
|									|
+----------------------------------------------------------------------*/
#include <math.h>
#include <windows.h>
#include <windowsx.h>

#include <win32.h>

//#pragma optimize("", off)

int redloop(void);
int greenloop( int restart );
int blueloop( int restart );

#ifdef _WIN32
#define maxfill(pbuffer, side)  \
    memset(pbuffer, -1, colormax*colormax*colormax*sizeof(LONG))
#else
void maxfill( DWORD _huge *buffer, long side);
#endif

void inv_cmap_2( int colors, BYTE colormap[3][256], int bits,
        DWORD _huge *dist_buf, LPBYTE rgbmap );

void inv_cmap_1( int colors, BYTE colormap[3][256], int bits,
        DWORD _huge *dist_buf, LPBYTE rgbmap );

/* Track minimum and maximum in inv_cmap_2. */
#define MINMAX_TRACK

BYTE  NewMap[3][256];

LPVOID FAR PASCAL MakeITable(LPRGBQUAD lprgbq, int nColors)
{
    LPVOID  lpDistBuf;
    LPBYTE  lpITable;
    int i;

    lpITable = GlobalAllocPtr(GHND|GMEM_SHARE,32768l);

    if (lpITable == NULL)
        return NULL;       // error no memory

    lpDistBuf = (LPVOID)GlobalAllocPtr(GHND,32768l * sizeof(DWORD));

    if (lpDistBuf == NULL) {
        GlobalFreePtr(lpITable);
        return NULL;       // error no memory
    }

    for (i = 0; i < nColors; i++) {
        NewMap[0][i] = lprgbq[i].rgbRed;
        NewMap[1][i] = lprgbq[i].rgbGreen;
        NewMap[2][i] = lprgbq[i].rgbBlue;
    }

    inv_cmap_2(nColors,NewMap,5,lpDistBuf,lpITable);
	
    GlobalFreePtr(lpDistBuf);
    return lpITable;
}

static int bcenter, gcenter, rcenter;
static long gdist, rdist, cdist;
static long cbinc, cginc, crinc;
static DWORD _huge *gdp;
static DWORD _huge *rdp;
static DWORD _huge *cdp;
static LPBYTE grgbp;
static LPBYTE rrgbp;
static LPBYTE crgbp;
static int gstride, rstride;
static long x, xsqr, colormax;
static int cindex;

/*****************************************************************
 * TAG( inv_cmap_2 )
 *
 * Compute an inverse colormap efficiently.
 * Inputs:
 * 	colors:		Number of colors in the forward colormap.
 * 	colormap:	The forward colormap.
 * 	bits:		Number of quantization bits.  The inverse
 * 			colormap will have (2^bits)^3 entries.
 * 	dist_buf:	An array of (2^bits)^3 long integers to be
 * 			used as scratch space.
 * Outputs:
 * 	rgbmap:		The output inverse colormap.  The entry
 * 			rgbmap[(r<<(2*bits)) + (g<<bits) + b]
 * 			is the colormap entry that is closest to the
 * 			(quantized) color (r,g,b).
 * Assumptions:
 * 	Quantization is performed by right shift (low order bits are
 * 	truncated).  Thus, the distance to a quantized color is
 * 	actually measured to the color at the center of the cell
 * 	(i.e., to r+.5, g+.5, b+.5, if (r,g,b) is a quantized color).
 * Algorithm:
 * 	Uses a "distance buffer" algorithm:
 * 	The distance from each representative in the forward color map
 * 	to each point in the rgb space is computed.  If it is less
 * 	than the distance currently stored in dist_buf, then the
 * 	corresponding entry in rgbmap is replaced with the current
 * 	representative (and the dist_buf entry is replaced with the
 * 	new distance).
 *
 * 	The distance computation uses an efficient incremental formulation.
 *
 * 	Distances are computed "outward" from each color.  If the
 * 	colors are evenly distributed in color space, the expected
 * 	number of cells visited for color I is N^3/I.
 * 	Thus, the complexity of the algorithm is O(log(K) N^3),
 * 	where K = colors, and N = 2^bits.
 */

/*
 * Here's the idea:  scan from the "center" of each cell "out"
 * until we hit the "edge" of the cell -- that is, the point
 * at which some other color is closer -- and stop.  In 1-D,
 * this is simple:
 * 	for i := here to max do
 * 		if closer then buffer[i] = this color
 * 		else break
 * 	repeat above loop with i := here-1 to min by -1
 *
 * In 2-D, it's trickier, because along a "scan-line", the
 * region might start "after" the "center" point.  A picture
 * might clarify:
 *		 |    ...
 *               | ...	.
 *              ...    	.
 *           ... |      .
 *          .    +     	.
 *           .          .
 *            .         .
 *             .........
 *
 * The + marks the "center" of the above region.  On the top 2
 * lines, the region "begins" to the right of the "center".
 *
 * Thus, we need a loop like this:
 * 	detect := false
 * 	for i := here to max do
 * 		if closer then
 * 			buffer[..., i] := this color
 * 			if !detect then
 * 				here = i
 * 				detect = true
 * 		else
 * 			if detect then
 * 				break
 * 				
 * Repeat the above loop with i := here-1 to min by -1.  Note that
 * the "detect" value should not be reinitialized.  If it was
 * "true", and center is not inside the cell, then none of the
 * cell lies to the left and this loop should exit
 * immediately.
 *
 * The outer loops are similar, except that the "closer" test
 * is replaced by a call to the "next in" loop; its "detect"
 * value serves as the test.  (No assignment to the buffer is
 * done, either.)
 *
 * Each time an outer loop starts, the "here", "min", and
 * "max" values of the next inner loop should be
 * re-initialized to the center of the cell, 0, and cube size,
 * respectively.  Otherwise, these values will carry over from
 * one "call" to the inner loop to the next.  This tracks the
 * edges of the cell and minimizes the number of
 * "unproductive" comparisons that must be made.
 *
 * Finally, the inner-most loop can have the "if !detect"
 * optimized out of it by splitting it into two loops: one
 * that finds the first color value on the scan line that is
 * in this cell, and a second that fills the cell until
 * another one is closer:
 *  	if !detect then	    {needed for "down" loop}
 * 	    for i := here to max do
 * 		if closer then
 * 			buffer[..., i] := this color
 * 			detect := true
 * 			break
 *	for i := i+1 to max do
 *		if closer then
 * 			buffer[..., i] := this color
 * 		else
 * 			break
 *
 * In this implementation, each level will require the
 * following variables.  Variables labelled (l) are local to each
 * procedure.  The ? should be replaced with r, g, or b:
 *  	cdist:	    	The distance at the starting point.
 * 	?center:	The value of this component of the color
 *  	c?inc:	    	The initial increment at the ?center position.
 * 	?stride:	The amount to add to the buffer
 * 			pointers (dp and rgbp) to get to the
 * 			"next row".
 * 	min(l):		The "low edge" of the cell, init to 0
 * 	max(l):		The "high edge" of the cell, init to
 * 			colormax-1
 * 	detect(l):    	True if this row has changed some
 * 	    	    	buffer entries.
 *  	i(l): 	    	The index for this row.
 *  	?xx:	    	The accumulated increment value.
 *  	
 *  	here(l):    	The starting index for this color.  The
 *  	    	    	following variables are associated with here,
 *  	    	    	in the sense that they must be updated if here
 *  	    	    	is changed.
 *  	?dist:	    	The current distance for this level.  The
 *  	    	    	value of dist from the previous level (g or r,
 *  	    	    	for level b or g) initializes dist on this
 *  	    	    	level.  Thus gdist is associated with here(b)).
 *  	?inc:	    	The initial increment for the row.

 *  	?dp:	    	Pointer into the distance buffer.  The value
 *  	    	    	from the previous level initializes this level.
 *  	?rgbp:	    	Pointer into the rgb buffer.  The value
 *  	    	    	from the previous level initializes this level.
 *
 * The blue and green levels modify 'here-associated' variables (dp,
 * rgbp, dist) on the green and red levels, respectively, when here is
 * changed.
 */

void
inv_cmap_2( int colors, BYTE colormap[3][256], int bits,
        DWORD _huge *dist_buf, LPBYTE rgbmap )
{
    int nbits = 8 - bits;

    colormax = 1 << bits;
    x = 1 << nbits;
    xsqr = 1 << (2 * nbits);

    /* Compute "strides" for accessing the arrays. */
    gstride = (int) colormax;
    rstride = (int) (colormax * colormax);

    maxfill( dist_buf, colormax );

    for ( cindex = 0; cindex < colors; cindex++ )
    {
	/*
	 * Distance formula is
	 * (red - map[0])^2 + (green - map[1])^2 + (blue - map[2])^2
	 *
	 * Because of quantization, we will measure from the center of
	 * each quantized "cube", so blue distance is
	 * 	(blue + x/2 - map[2])^2,
	 * where x = 2^(8 - bits).
	 * The step size is x, so the blue increment is
	 * 	2*x*blue - 2*x*map[2] + 2*x^2
	 *
	 * Now, b in the code below is actually blue/x, so our
	 * increment will be 2*(b*x^2 + x^2 - x*map[2]).  For
	 * efficiency, we will maintain this quantity in a separate variable
	 * that will be updated incrementally by adding 2*x^2 each time.
	 */
	/* The initial position is the cell containing the colormap
	 * entry.  We get this by quantizing the colormap values.
	 */
	rcenter = colormap[0][cindex] >> nbits;
	gcenter = colormap[1][cindex] >> nbits;
	bcenter = colormap[2][cindex] >> nbits;

	rdist = colormap[0][cindex] - (rcenter * x + x/2);
	gdist = colormap[1][cindex] - (gcenter * x + x/2);
	cdist = colormap[2][cindex] - (bcenter * x + x/2);
	cdist = rdist*rdist + gdist*gdist + cdist*cdist;

	crinc = 2 * ((rcenter + 1) * xsqr - (colormap[0][cindex] * x));
	cginc = 2 * ((gcenter + 1) * xsqr - (colormap[1][cindex] * x));
	cbinc = 2 * ((bcenter + 1) * xsqr - (colormap[2][cindex] * x));

	/* Array starting points. */
	cdp = dist_buf + rcenter * rstride + gcenter * gstride + bcenter;
	crgbp = rgbmap + rcenter * rstride + gcenter * gstride + bcenter;

	(void)redloop();
    }
}

/* redloop -- loop up and down from red center. */
int
redloop()
{
    int detect;
    int r, i = cindex;
    int first;
    long txsqr = xsqr + xsqr;
    static long rxx;

    detect = 0;

    /* Basic loop up. */
    for ( r = rcenter, rdist = cdist, rxx = crinc,
	  rdp = cdp, rrgbp = crgbp, first = 1;
	  r < (int) colormax;
	  r++, rdp += rstride, rrgbp += rstride,
	  rdist += rxx, rxx += txsqr, first = 0 )
    {
	if ( greenloop( first ) )
	    detect = 1;
	else if ( detect )
	    break;
    }

    /* Basic loop down. */
    for ( r = rcenter - 1, rxx = crinc - txsqr, rdist = cdist - rxx,
	  rdp = cdp - rstride, rrgbp = crgbp - rstride, first = 1;
	  r >= 0;
	  r--, rdp -= rstride, rrgbp -= rstride,
	  rxx -= txsqr, rdist -= rxx, first = 0 )
    {
	if ( greenloop( first ) )
	    detect = 1;
	else if ( detect )
	    break;
    }

    return detect;
}

/* greenloop -- loop up and down from green center. */
int
greenloop( int restart )
{
    int detect;
    int g, i = cindex;
    int first;
    long txsqr = xsqr + xsqr;
    static int here, min, max;
#ifdef MINMAX_TRACK
    static int prevmax, prevmin;
    int thismax, thismin;
#endif
    static long ginc, gxx, gcdist;	/* "gc" variables maintain correct */
    static DWORD _huge *gcdp;          /*  values for bcenter position, */
    static LPBYTE gcrgbp;	/*  despite modifications by blueloop */
					/*  to gdist, gdp, grgbp. */

    if ( restart )
    {
	here = gcenter;
	min = 0;
	max = (int) colormax - 1;
	ginc = cginc;
#ifdef MINMAX_TRACK
	prevmax = 0;
	prevmin = (int) colormax;
#endif
    }

#ifdef MINMAX_TRACK
    thismin = min;
    thismax = max;
#endif
    detect = 0;

    /* Basic loop up. */
    for ( g = here, gcdist = gdist = rdist, gxx = ginc,
	  gcdp = gdp = rdp, gcrgbp = grgbp = rrgbp, first = 1;
	  g <= max;
	  g++, gdp += gstride, gcdp += gstride, grgbp += gstride, gcrgbp += gstride,
	  gdist += gxx, gcdist += gxx, gxx += txsqr, first = 0 )
    {
	if ( blueloop( first ) )
	{
	    if ( !detect )
	    {
		/* Remember here and associated data! */
		if ( g > here )
		{
		    here = g;
		    rdp = gcdp;
		    rrgbp = gcrgbp;
		    rdist = gcdist;
		    ginc = gxx;
#ifdef MINMAX_TRACK
		    thismin = here;
#endif
		}
		detect = 1;
	    }
	}
	else if ( detect )
	{
#ifdef MINMAX_TRACK
	    thismax = g - 1;
#endif
	    break;
	}
    }

    /* Basic loop down. */
    for ( g = here - 1, gxx = ginc - txsqr, gcdist = gdist = rdist - gxx,
	  gcdp = gdp = rdp - gstride, gcrgbp = grgbp = rrgbp - gstride,
	  first = 1;
	  g >= min;
	  g--, gdp -= gstride, gcdp -= gstride, grgbp -= gstride, gcrgbp -= gstride,
	  gxx -= txsqr, gdist -= gxx, gcdist -= gxx, first = 0 )
    {
	if ( blueloop( first ) )
	{
	    if ( !detect )
	    {
		/* Remember here! */
		here = g;
		rdp = gcdp;
		rrgbp = gcrgbp;
		rdist = gcdist;
		ginc = gxx;
#ifdef MINMAX_TRACK
		thismax = here;
#endif
		detect = 1;
	    }
	}
	else if ( detect )
	{
#ifdef MINMAX_TRACK
	    thismin = g + 1;
#endif
	    break;
	}
    }

#ifdef MINMAX_TRACK
    /* If we saw something, update the edge trackers.  For now, only
     * tracks edges that are "shrinking" (min increasing, max
     * decreasing.
     */
    if ( detect )
    {
	if ( thismax < prevmax )
	    max = thismax;

	prevmax = thismax;

	if ( thismin > prevmin )
	    min = thismin;

	prevmin = thismin;
    }
#endif

    return detect;
}

/* blueloop -- loop up and down from blue center. */
int
blueloop( int restart )
{
    int detect;
    register DWORD _huge *dp;
    register LPBYTE rgbp;
    register long bdist, bxx;
    register int b, i = cindex;
    register long txsqr = xsqr + xsqr;
    register int lim;
    static int here, min, max;
#ifdef MINMAX_TRACK
    static int prevmin, prevmax;
    int thismin, thismax;
#endif /* MINMAX_TRACK */
    static long binc;

    if ( restart )
    {
	here = bcenter;
	min = 0;
	max = (int) colormax - 1;
	binc = cbinc;
#ifdef MINMAX_TRACK
	prevmin = (int) colormax;
	prevmax = 0;
#endif /* MINMAX_TRACK */
    }

    detect = 0;
#ifdef MINMAX_TRACK
    thismin = min;
    thismax = max;
#endif

    /* Basic loop up. */
    /* First loop just finds first applicable cell. */
    for ( b = here, bdist = gdist, bxx = binc, dp = gdp, rgbp = grgbp, lim = max;
	  b <= lim;
	  b++, dp++, rgbp++,
	  bdist += bxx, bxx += txsqr )
    {
        if ( *dp > (DWORD)bdist )
	{
	    /* Remember new 'here' and associated data! */
	    if ( b > here )
	    {
		here = b;
		gdp = dp;
		grgbp = rgbp;
		gdist = bdist;
		binc = bxx;
#ifdef MINMAX_TRACK
		thismin = here;
#endif
	    }
	    detect = 1;
	    break;
	}
    }
    /* Second loop fills in a run of closer cells. */
    for ( ;
	  b <= lim;
	  b++, dp++, rgbp++,
	  bdist += bxx, bxx += txsqr )
    {
        if ( *dp > (DWORD)bdist )
	{
	    *dp = bdist;
	    *rgbp = (BYTE) i;
	}
	else
	{
#ifdef MINMAX_TRACK
	    thismax = b - 1;
#endif
	    break;
	}
    }

    /* Basic loop down. */
    /* Do initializations here, since the 'find' loop might not get
     * executed.
     */
    lim = min;
    b = here - 1;
    bxx = binc - txsqr;
    bdist = gdist - bxx;
    dp = gdp - 1;
    rgbp = grgbp - 1;
    /* The 'find' loop is executed only if we didn't already find
     * something.
     */
    if ( !detect )
	for ( ;
	      b >= lim;
	      b--, dp--, rgbp--,
	      bxx -= txsqr, bdist -= bxx )
	{
            if ( *dp > (DWORD)bdist )
	    {
		/* Remember here! */
		/* No test for b against here necessary because b <
		 * here by definition.
		 */
		here = b;
		gdp = dp;
		grgbp = rgbp;
		gdist = bdist;
		binc = bxx;
#ifdef MINMAX_TRACK
		thismax = here;
#endif
		detect = 1;
		break;
	    }
	}
    /* The 'update' loop. */
    for ( ;
	  b >= lim;
	  b--, dp--, rgbp--,
	  bxx -= txsqr, bdist -= bxx )
    {
        if ( *dp > (DWORD)bdist )
	{
	    *dp = bdist;
	    *rgbp = (BYTE) i;
	}
	else
	{
#ifdef MINMAX_TRACK
	    thismin = b + 1;
#endif
	    break;
	}
    }


	/* If we saw something, update the edge trackers. */
#ifdef MINMAX_TRACK
    if ( detect )
    {
	/* Only tracks edges that are "shrinking" (min increasing, max
	 * decreasing.
	 */
	if ( thismax < prevmax )
	    max = thismax;

	if ( thismin > prevmin )
	    min = thismin;

	/* Remember the min and max values. */
	prevmax = thismax;
	prevmin = thismin;
    }
#endif /* MINMAX_TRACK */

    return detect;
}

#ifndef _WIN32
void maxfill( DWORD _huge *buffer, long side)
{
    register unsigned long maxv = ~0uL;
    register long i;
    register DWORD _huge *bp;

    for ( i = colormax * colormax * colormax, bp = buffer;
	  i > 0;
	  i--, bp++ )
	*bp = maxv;
}
#endif


#ifdef CMAP1


/*****************************************************************
 * TAG( inv_cmap_1 )
 *
 * Compute an inverse colormap efficiently.
 * Inputs:

 * 	colors:		Number of colors in the forward colormap.
 * 	colormap:	The forward colormap.
 * 	bits:		Number of quantization bits.  The inverse
 * 			colormap will have (2^bits)^3 entries.
 * 	dist_buf:	An array of (2^bits)^3 long integers to be
 * 			used as scratch space.
 * Outputs:
 * 	rgbmap:		The output inverse colormap.  The entry
 * 			rgbmap[(r<<(2*bits)) + (g<<bits) + b]
 * 			is the colormap entry that is closest to the
 * 			(quantized) color (r,g,b).
 * Assumptions:
 * 	Quantization is performed by right shift (low order bits are
 * 	truncated).  Thus, the distance to a quantized color is
 * 	actually measured to the color at the center of the cell
 * 	(i.e., to r+.5, g+.5, b+.5, if (r,g,b) is a quantized color).
 * Algorithm:
 * 	Uses a "distance buffer" algorithm:
 * 	The distance from each representative in the forward color map
 * 	to each point in the rgb space is computed.  If it is less
 * 	than the distance currently stored in dist_buf, then the
 * 	corresponding entry in rgbmap is replaced with the current
 * 	representative (and the dist_buf entry is replaced with the
 * 	new distance).
 *
 * 	The distance computation uses an efficient incremental formulation.
 *
 * 	Right now, distances are computed for all entries in the rgb
 * 	space.  Thus, the complexity of the algorithm is O(K N^3),
 * 	where K = colors, and N = 2^bits.
 */
void
inv_cmap_1( int colors, BYTE colormap[3][256], int bits,
        DWORD _huge *dist_buf, LPBYTE rgbmap )
{
    register DWORD _huge *dp;
    register LPBYTE rgbp;
    register long bdist, bxx;
    register int b, i;
    int nbits = 8 - bits;
    register int colormax = 1 << bits;
    register long xsqr = 1 << (2 * nbits);
    int x = 1 << nbits;
    int rinc, ginc, binc, r, g;
    long rdist, gdist, rxx, gxx;

    for ( i = 0; i < colors; i++ )
    {
	/*
	 * Distance formula is
	 * (red - map[0])^2 + (green - map[1])^2 + (blue - map[2])^2
	 *
	 * Because of quantization, we will measure from the center of
	 * each quantized "cube", so blue distance is
	 * 	(blue + x/2 - map[2])^2,
	 * where x = 2^(8 - bits).
	 * The step size is x, so the blue increment is
	 * 	2*x*blue - 2*x*map[2] + 2*x^2
	 *
	 * Now, b in the code below is actually blue/x, so our
	 * increment will be 2*x*x*b + (2*x^2 - 2*x*map[2]).  For
	 * efficiency, we will maintain this quantity in a separate variable
	 * that will be updated incrementally by adding 2*x^2 each time.
	 */
	rdist = colormap[0][i] - x/2;
	gdist = colormap[1][i] - x/2;
	bdist = colormap[2][i] - x/2;
	rdist = rdist*rdist + gdist*gdist + bdist*bdist;

	rinc = 2 * (xsqr - (colormap[0][i] << nbits));
	ginc = 2 * (xsqr - (colormap[1][i] << nbits));
	binc = 2 * (xsqr - (colormap[2][i] << nbits));
	dp = dist_buf;
	rgbp = rgbmap;
	for ( r = 0, rxx = rinc;
	      r < colormax;
	      rdist += rxx, r++, rxx += xsqr + xsqr )
	    for ( g = 0, gdist = rdist, gxx = ginc;
		  g < colormax;
		  gdist += gxx, g++, gxx += xsqr + xsqr )
		for ( b = 0, bdist = gdist, bxx = binc;
		      b < colormax;
		      bdist += bxx, b++, dp++, rgbp++,
		      bxx += xsqr + xsqr )
		{
		    if ( i == 0 || *dp > bdist )
		    {
			*dp = bdist;
			*rgbp = i;
		    }
		}
    }
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvidc\decmprss.c ===
/*----------------------------------------------------------------------+
| decmprss.c - Microsoft Video 1 Compressor - decompress code		|
|									|
|									|
| Copyright (c) 1990-1994 Microsoft Corporation.			|
| Portions Copyright Media Vision Inc.					|
| All Rights Reserved.							|
|									|
| You have a non-exclusive, worldwide, royalty-free, and perpetual	|
| license to use this source code in developing hardware, software	|
| (limited to drivers and other software required for hardware		|
| functionality), and firmware for video display and/or processing	|
| boards.   Microsoft makes no warranties, express or implied, with	|
| respect to the Video 1 codec, including without limitation warranties	|
| of merchantability or fitness for a particular purpose.  Microsoft	|
| shall not be liable for any damages whatsoever, including without	|
| limitation consequential damages arising from your use of the Video 1	|
| codec.								|
|									|
|									|
+----------------------------------------------------------------------*/
#ifdef _WIN32
//#ifdef DEBUG   DEBUG is not defined on NT until win32.h is included...
//               Always define here so that the ntrtl headers get included
#ifndef CHICAGO
#if DBG
// We only want this stuff in the debug build
#define MEASURE_PERFORMANCE
#endif
#endif
//#endif
#endif

#ifdef MEASURE_PERFORMANCE  // Displays frame decompress times on the debugger
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <win32.h>
#include "msvidc.h"

#ifdef DEBUG
    #undef INLINE   // Make debugging easier - less code movement
    #define INLINE
#else
#undef MEASURE_PERFORMANCE  // Turn it off for non debug builds
#endif

#ifdef MEASURE_PERFORMANCE

STATICDT LARGE_INTEGER PC1;    /* current counter value    */
STATICDT LARGE_INTEGER PC2;    /* current counter value    */
STATICDT LARGE_INTEGER PC3;    /* current counter value    */

STATICFN VOID StartCounting(VOID)
{
    QueryPerformanceCounter(&PC1);
    return;
}

STATICFN VOID EndCounting(LPSTR szId)
{
    QueryPerformanceCounter(&PC2);
    PC3.QuadPart = PC2.QuadPart - PC1.QuadPart;
    DPF(("%s: %d ticks", szId, PC3.LowPart));
    return;
}

#else
#define StartCounting()
#define EndCounting(x)

#endif

/*
 * dither table pointers declared and initialised in msvidc.c
 */
extern LPVOID lpDitherTable;

/*
 * these two pointers point into the lpDitherTable
 */
LPBYTE lpLookup;
LPWORD lpScale;

/*
**  Lookup table for expanding 4 bits into 4 bytes
*/
CONST DWORD ExpansionTable[16] = {
                              0x00000000,
                              0x000000FF,
                              0x0000FF00,
                              0x0000FFFF,
                              0x00FF0000,
                              0x00FF00FF,
                              0x00FFFF00,
                              0x00FFFFFF,
                              0xFF000000,
                              0xFF0000FF,
                              0xFF00FF00,
                              0xFF00FFFF,
                              0xFFFF0000,
                              0xFFFF00FF,
                              0xFFFFFF00,
                              0xFFFFFFFF
};

/*
 * Lookup table to turn a bitmask to a byte mask
 */
DWORD Bits2Bytes[13] = {0,          0xffff, 0xffff0000, 0xffffffff,
                        0xffff,     0,      0,          0,
			0xffff0000, 0,      0,          0,
			0xffffffff};

//#include <limits.h>
//#include <mmsystem.h>
//#include <aviffmt.h>

#define RGB555toRGBTRIPLE( rgbT, rgb ) rgbT.rgbtRed=(BYTE)((rgb & 0x7c00) >> 7); \
                                       rgbT.rgbtGreen=(BYTE)((rgb & 0x3e0) >>2); \
                                       rgbT.rgbtBlue=(BYTE)((rgb & 0x1f) << 3)

static WORD edgeBitMask[HEIGHT_CBLOCK*WIDTH_CBLOCK] = {
    0x0001,0x0002,0x0010,0x0020,
    0x0004,0x0008,0x0040,0x0080,
    0x0100,0x0200,0x1000,0x2000,
    0x0400,0x0800,0x4000,0x8000
};

/* make a DWORD that has four copies of the byte x */
#define MAKE4(x)        ( (x << 24) | (x << 16) | (x << 8) | x)

/* make a DWORD that has two copies of the byte x (low word) and two of y */
#define MAKE22(x, y)    ( (y << 24) | (y << 16) | (x << 8) | (x))

/**************************************************************************
compute a pointer into a DIB handling correctly "upside" down DIBs
***************************************************************************/
STATICFN LPVOID DibXY(LPBITMAPINFOHEADER lpbi, LPBYTE lpBits, LONG x, LONG y, INT FAR *pWidthBytes)
{
    int WidthBytes;

    if (x > 0)
        ((BYTE FAR *)lpBits) += ((int)x * (int)lpbi->biBitCount) >> 3;

    WidthBytes = (((((int)lpbi->biWidth * (int)lpbi->biBitCount) >> 3) + 3)&~3);

    if (lpbi->biHeight < 0)
    {
        WidthBytes = -WidthBytes;
        ((BYTE _huge *)lpBits) += lpbi->biSizeImage + WidthBytes;
    }

    if (y > 0)
        ((BYTE _huge *)lpBits) += ((long)y * WidthBytes);

    if (pWidthBytes)
        *pWidthBytes = WidthBytes;

    return lpBits;
}

/*
 * 16-bit decompression to 24-bit RGB--------------------------------------
 */

/*************************************************
purp:   decompress a 4 by 4 compression block to RGBDWORD
entry:  uncmp == address of the destination uncompressed image
        cmp == address of the compressed image
exit:   returns updated address of the compressed image
        and 16 pixels are generated
*************************************************/

// note that the skip count is now stored in the parent stack frame
// and passed as a pointer pSkipCount. This ensures that we are multithread
// safe.

STATICFN HPWORD INLINE DecompressCBlockToRGBTRIPLE(
    HPRGBTRIPLE uncmp,
    HPWORD cmp,
    INT bytesPerRow,
    LONG FAR * pSkipCount
)
{
UINT by;
UINT bx;
UINT y;
UINT x;
WORD mask;
WORD color0;
WORD color1;
WORD bitMask;
RGBTRIPLE rgbTriple0;
RGBTRIPLE rgbTriple1;
HPRGBTRIPLE row;
HPRGBTRIPLE blockRow;
HPRGBTRIPLE blockColumn;
WORD *pEdgeBitMask;


    // check for outstanding skips

    if (*pSkipCount > 0)
    {
        // NOT YET IMPLEMENTED Assert(!"Skip count should be handled by caller");
        (*pSkipCount) --;
        return cmp;
    }

    // get mask and init bit mask
    mask = *cmp++;

    // check for a skip or a solid color

    if (mask & 0x8000)
    {
        if ((mask & ~SKIP_MASK) == SKIP_MAGIC)
        {
            *pSkipCount = (mask & SKIP_MASK);

#ifdef _WIN32
            Assert(*pSkipCount != 0);  // break (on debug builds) if SkipCount == 0
#endif

            (*pSkipCount)--;
            return cmp;
        }
        else
        {
            // solid color
            RGB555toRGBTRIPLE( rgbTriple1, mask );
            for( row = uncmp,y=0; y < HEIGHT_CBLOCK; y++, row = NEXT_RGBT_PIXEL_ROW( row, bytesPerRow ) )
                for( x=0; x < WIDTH_CBLOCK; x++ )
                    row[x] = rgbTriple1;

            return cmp;
        }
    }

    bitMask = 1;
    pEdgeBitMask = edgeBitMask;
    if( (*cmp & 0x8000) != 0 )
    {   // this is an edge with 4 color pairs in four small blocks
        blockRow = uncmp;
        for( by=0; by < 2; by++, blockRow = NEXT_BLOCK_ROW( blockRow, bytesPerRow, EDGE_HEIGHT_CBLOCK ) )
        {
            blockColumn = blockRow;
            for( bx=0; bx < 2; bx++, blockColumn += EDGE_WIDTH_CBLOCK )
            {
                color1 = *cmp++;
                RGB555toRGBTRIPLE( rgbTriple1, color1 );
                color0 = *cmp++;
                RGB555toRGBTRIPLE( rgbTriple0, color0 );
                row = blockColumn;
                for( y=0; y < EDGE_HEIGHT_CBLOCK; y++, row = NEXT_RGBT_PIXEL_ROW( row, bytesPerRow ) )
                {
                    for( x=0; x < EDGE_WIDTH_CBLOCK; x++ )
                    {
                        if( (mask & *pEdgeBitMask++ ) != 0 )
                            row[x] = rgbTriple1;
                        else
                            row[x] = rgbTriple0;
                        bitMask <<= 1;
                    }
                }
            }
        }
    }
    else
    {   // not an edge with only 1 colour pair and one large block
        color1 = *cmp++;
        RGB555toRGBTRIPLE( rgbTriple1, color1 );
        color0 = *cmp++;
        RGB555toRGBTRIPLE( rgbTriple0, color0 );
        row = uncmp;
        for( y=0; y < HEIGHT_CBLOCK; y++, row = NEXT_RGBT_PIXEL_ROW( row, bytesPerRow ) )
        {
            for( x=0; x < WIDTH_CBLOCK; x++ )
            {
                if( (mask & bitMask ) != 0 )
                    row[x] = rgbTriple1;
                else
                    row[x] = rgbTriple0;
                bitMask <<= 1;
            }
        }
    }
    return( cmp );
}


/*************************************************
purp:   decompress the image to RGBTRIPLE
entry:  lpinst = pointer to instance data
        hpCompressed = pointer to compressed data
exit:   returns number of bytes in the uncompressed image
        lpinst->hDib = handle to the uncompressed image
*************************************************/

DWORD FAR PASCAL DecompressFrame24(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                    LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y)
{
HPWORD	    cmp = (HPWORD)lpIn;
int	    bix;
int	    biy;
HPRGBTRIPLE blockRow;
HPRGBTRIPLE blockColumn;
int	    bytesPerRow;
DWORD	    actualSize;
LONG	    SkipCount = 0;

    DPF(("DecompressFrame24:\n"));
    bix = (UINT)((UINT)lpbiIn->biWidth / WIDTH_CBLOCK);
    biy = (UINT)((UINT)lpbiIn->biHeight / HEIGHT_CBLOCK);

    StartCounting();
    blockRow = DibXY(lpbiOut, lpOut, x, y, &bytesPerRow);

    for( y=0; y < biy; y++, blockRow = NEXT_BLOCK_ROW( blockRow, bytesPerRow, HEIGHT_CBLOCK ) )
    {
        blockColumn = blockRow;
        for( x=0; x < bix; x++, blockColumn += WIDTH_CBLOCK )
        {
            cmp = DecompressCBlockToRGBTRIPLE( blockColumn, cmp, bytesPerRow, &SkipCount);
        }
    }

    actualSize = bytesPerRow*biy*HEIGHT_CBLOCK;
    EndCounting("Decompress frame24 took");
    return( actualSize );
}

/*************************************************
*************************************************/
/*
 * -------- 8-bit decompression ----------------------------------------
 *
 *
 * The input stream consists of four cases, handled like this:
 *
 * SKIP		lower 10 bits have skip count
 *     	Return the skip count to the caller (must be multi-thread safe).
 *	Caller will advance the source pointer past the correct number of
 * 	of skipped cells.
 *
 * SOLID	lower 8 bits is solid colour for entire cell
 *	Write the colour to each pixel, four pixels (one DWORD) at
 *	a time.
 *
 * Mask + 2 colours
 *	1s in the mask represent the first colour, 0s the second colour.
 *      Pixels are represented thus:
 *		
 *		C D E F
 *		8 9 A B
 *		4 5 6 7
 *		0 1 2 3
 *
 *      To write four pixels at once, we rely on the fact that:
 *		(a ^ b) ^ a == b
 * 	and also that a ^ 0 == a.
 *	We create a DWORD (Czero) containing four copies of the colour 0, and
 *	another DWORD (Cxor) containing four copies of (colour 0 ^ colour 1).
 *      Then we convert each bit in the mask (1 or 0) into a byte (0xff or 0),
 *      and combining four mask bytes into a DWORD. Then we can select
 *      four pixels at once (AND the mask with Czero and then XOR with Cxor).
 *
 * Mask + 8 colours.
 *	1s and 0s represent two colours as before, but the cell is divided
 *	into 4 subcells with two colours per subcell. The first pair of
 *	colours are for subcell 0145, then 2367, 89cd and abef.
 *	
 *	We use the same algorithm as for the mask+2 case except that when
 *	making the mask, we need colours from the second pair in the top
 *	two bytes of Czero and Cxor, and that we need to change colours
 *	again after two rows.
 *
 * -----------------------------------------------------------------------
 */	

/*
 * DecompressCBlockTo8
 *
 *
 * decompress one cell to 16 8-bit pixels.
 *
 * parameters:
 *   uncmp-     pointer to de-compressed buffer for this block.
 *   cmp -      pointer to compressed data for this block
 *   bytes.. -  size of one row of de-compressed data
 *   pSkipCount - place to return the skipcount if non-zero.
 *
 * returns:
 *   pointer to the next block of compressed data to use.
 */
STATICFN HPWORD INLINE DecompressCBlockTo8(
    HPBYTE uncmp,
    HPWORD cmp,
    INT bytesPerRow,
    LONG FAR * pSkipCount
    )
{
UINT    y;
WORD    mask;
BYTE    b0,b1;
HPBYTE  row;
BYTE	b2, b3;
DWORD	Czero, Cxor;
DWORD	dwBytes;


    // skip counts should be handled by caller
#ifdef _WIN32
    Assert(*pSkipCount == 0);
#endif

    /* first word is the escape word or bit mask */
    mask = *cmp++;

    /*
     * is this an escape ?
     */
    if (mask & 0x8000)
    {

	/* yes - this is either a SKIP code, a solid colour, or an edge
	 * cell (mask + 8 colours).
	 */

        if ((mask & ~SKIP_MASK) == SKIP_MAGIC)
        {
            *pSkipCount = (mask & SKIP_MASK);

#ifdef _WIN32
            Assert(*pSkipCount != 0);  // break (on debug builds) if SkipCount == 0
#endif

            (*pSkipCount)--;      // the current cell
            return cmp;
        }
        else if ((mask & ~SKIP_MASK) == SOLID_MAGIC)
        {
            // solid color
            DWORD  dw;

            //b0 = LOBYTE(mask);
            //dw = b0 | b0<<8 | b0<<16 | b0<<24;
            dw = LOBYTE(mask);
            dw = MAKE4(dw);

#ifdef _WIN32
            Assert(HEIGHT_CBLOCK == 4);    // If this ever changes...
            Assert(WIDTH_CBLOCK == 4);
#endif

            for(y = 0, row = uncmp; y < HEIGHT_CBLOCK;y++, row+= bytesPerRow) {

                // We know we will iterate 4 times (WIDTH_CBLOCK) storing
                // 4 bytes of colour b0 in 4 adjacent rows
                *(DWORD UNALIGNED HUGE *)row = dw;
            }

            return cmp;
        }
        else // this is an edge with 4 color pairs in four small blocks
        {

	    /* read 4 colours, and make AND and XOR masks */
            b0 = *((LPBYTE)cmp)++;
            b1 = *((LPBYTE)cmp)++;
            b2 = *((LPBYTE)cmp)++;
            b3 = *((LPBYTE)cmp)++;
	    Czero = MAKE22(b1, b3);
	    Cxor = Czero ^ MAKE22(b0, b2);

	    row = uncmp;

	    /* first two rows  - top two subcells */
            for (y = 0; y < 2; y++) {

                /* turn bitmask into byte mask */
                dwBytes = ExpansionTable[mask & 0x0f];

                /* select colours and write to dest */
                *( (DWORD UNALIGNED HUGE *)row) = (dwBytes & Cxor) ^ Czero;

                row += bytesPerRow;
                mask >>= 4;

            }

	    /* second two rows  - bottom two subcells */

	    /* read last four colours and make masks */
            b0 = *((LPBYTE)cmp)++;
            b1 = *((LPBYTE)cmp)++;
            b2 = *((LPBYTE)cmp)++;
            b3 = *((LPBYTE)cmp)++;
	    Czero = MAKE22(b1, b3);
	    Cxor = Czero ^ MAKE22(b0, b2);

            for (y = 0; y < 2; y++) {

                /* turn bitmask into byte mask */
                dwBytes = ExpansionTable[mask & 0x0f];

                /* select both colours and write to dest */
                *( (DWORD UNALIGNED HUGE *)row) = (dwBytes & Cxor) ^ Czero;

                row += bytesPerRow;
                mask >>= 4;

            }
        }
    }
    else // not an edge with only 1 colour pair and one large block
    {
	/* use and, xor to map several colours at once.
	 * relies on (Czero ^ Cone) ^ Czero == Cone and Czero ^ 0 == Czero.
	 */


	/* read colours */
	b1 = *((LPBYTE)cmp)++;
	b0 = *((LPBYTE)cmp)++;
	row = uncmp;

	/* make two DWORDs, one with four copies of colour 0, and one
	 * with four copies of (b0 ^ b1).
	 */
	Czero = MAKE4(b0);
	Cxor = Czero ^ MAKE4(b1);

	for (y = 0; y < 4; y++) {
	
            /* turn bitmask into byte mask */
            dwBytes = ExpansionTable[mask & 0x0f];

            /* select both colours and write to dest */
            *( (DWORD UNALIGNED HUGE *)row) = (dwBytes & Cxor) ^ Czero;

            row += bytesPerRow;
	    mask >>= 4;

	}
    }
    return( cmp );
}

/*************************************************
*************************************************/

/*
 * decompress a CRAM-8 DIB to an 8-bit DIB
 *
 * Loop calling DecompressCBlockTo8 for each cell in the input
 * stream. This writes a block of 16 pixels and returns us the
 * pointer for the next block.
 */
DWORD FAR PASCAL DecompressFrame8(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                    LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y)
{
HPWORD  cmp = (HPWORD)lpIn;
int     bix;
int     biy;
HPBYTE  blockRow;
HPBYTE  blockColumn;
LONG SkipCount8 = 0;			// multithread-safe - cannot be static

int     bytesPerRow;

    DPF(("DecompressFrame8:\n"));
    bix = (int)((UINT)lpbiIn->biWidth / WIDTH_CBLOCK);
    biy = (int)((UINT)lpbiIn->biHeight / HEIGHT_CBLOCK);

    StartCounting();
    blockRow = DibXY(lpbiOut, lpOut, x, y, &bytesPerRow);
    for( y=biy; y--; blockRow += bytesPerRow * HEIGHT_CBLOCK )
    {
        blockColumn = blockRow;
        for( x=bix; x--; blockColumn += WIDTH_CBLOCK )
        {
            cmp = DecompressCBlockTo8(blockColumn, cmp, bytesPerRow, &SkipCount8);

            // See if the SkipCount has been set.  If so we want to move to
            // the next location rather than calling DecompressCBlock every
            // time around the loop.  Keep the test simple to minimise the
            // overhead on every iteration that the Skipcount is 0.
            if (SkipCount8) {

                if ((x -= SkipCount8) <0) { // extends past this row
                    LONG SkipRows;

                    // More than just the remainder of this row to skip
                    SkipCount8 =-x;  // These bits are on the next row(s)
                    // SkipCount8 will be >0 otherwise we would have gone
                    // down the else leg.

                    // Calculate how many complete and partial rows to skip.
                    // We know we have skipped at least one row.  The plan
                    // is to restart the X loop at some point along the row.
                    // If the skipcount takes us exactly to the end of a row
                    // we drop out of the x loop, and let the outer y loop do
                    // the decrement.  This takes care of the case when the
                    // skipcount takes us to the very end of the image.

                    SkipRows = 1 + (SkipCount8-1)/bix;

                    // Decrement the row count and set new blockrow start

#ifdef _WIN32
                    if (y<SkipRows) {
                        Assert(y >= SkipRows);
                        SkipRows = y;
                    }
#endif

                    // Unless we have finished we need to reset blockRow
                    y -= SkipRows;
                    // y might be 0, but we must still complete the last row
                    blockRow += bytesPerRow*HEIGHT_CBLOCK*SkipRows;

                    // Calculate the offset into the next row we will process
                    x = SkipCount8%bix;  // This may be 0

                    if (x) {

                        // Set block column by the amount along the row
                        // this iteration is starting, making allowance for
                        // the "for x..." loop iterating blockColumn once.
                        blockColumn = blockRow + ((x-1)*WIDTH_CBLOCK);

                        x=bix-x;  // Get the counter correct
                    }

                    SkipCount8 = 0; // Skip count now exhausted (so am I)

                } else {
                    // SkipCount has been exhausted by this row
                    // Either the row has completed, or there is more data
                    // on this row.   Check...
                    if (x) {
                        // More of this row left
                        // Worry about moving blockColumn on the right amount
                        blockColumn += WIDTH_CBLOCK*SkipCount8;
                    } // else x==0 and we will drop out of the "for x..." loop
                      // blockColumn will be reset when we reenter the x loop
                    SkipCount8=0;
                }
            }
        }
    }
    EndCounting("Decompress 8bit took");

    return 0;
}


#ifdef _WIN32

/* ---- 8-bit X2 decompress - in asm for Win16 ---------------------------*/

/*
 * decompress one block, stretching by 2.
 *
 * parameters:
 *   uncmp-     pointer to de-compressed buffer for this block.
 *   cmp -      pointer to compressed data for this block
 *   bytes.. -  size of one row of de-compressed data
 *
 * returns:
 *   pointer to the next block of compressed data.
 *
 * Given same incoming data, write a block of four pixels for every
 * pixel in original compressed image. Uses same techniques as
 * unstretched routine, masking and writing four pixels (one dword)
 * at a time.
 *
 * Stretching by 2 is done by simple pixel duplication.
 * Experiments were done (x86) to only store every other line, then to use
 * memcpy to fill in the gaps.  This is slower than writing two identical
 * lines as you proceed.
 *
 * Skip counts are returned (via pSkipCount) to the caller, who will handle
 * advancing the source pointer accordingly.
 *
 */

STATICFN HPWORD INLINE DecompressCBlockTo8X2(
    HPBYTE uncmp,
    HPWORD cmp,
    INT bytesPerRow,
    LONG FAR * pSkipCount)
{
    UINT    y;
    UINT    dx, dy;
    WORD    mask;
    BYTE    b0,b1;
    HPBYTE  row;
    DWORD Czero, Cxor, dwBytes;
    DWORD Ctwo, Cxor2;

    // skip counts should be handled by caller
#ifdef _WIN32
    Assert (*pSkipCount == 0);
#endif

    // get mask and init bit mask
    mask = *cmp++;

    // check for a skip or a solid color

    if (mask & 0x8000)
    {
        if ((mask & ~SKIP_MASK) == SKIP_MAGIC)
        {
            *pSkipCount = (mask & SKIP_MASK);

#ifdef _WIN32
            Assert(*pSkipCount != 0);  // break (on debug builds) if SkipCount == 0
#endif

            (*pSkipCount)--;
            return cmp;
        }
        else if ((mask & ~SKIP_MASK) == SOLID_MAGIC)
        {
            // solid color
            DWORD  dw;

            //b0 = LOBYTE(mask);
            //dw = b0 | b0<<8 | b0<<16 | b0<<24;
            dw = LOBYTE(mask);
            dw = MAKE4(dw);

#ifdef _WIN32
            Assert(HEIGHT_CBLOCK == 4);    // If this ever changes...
            Assert(WIDTH_CBLOCK == 4);
#endif

            dx = WIDTH_CBLOCK * 2;
            dy = HEIGHT_CBLOCK * 2;
            for(row = uncmp; dy--; row+= bytesPerRow) {

                // We know we will iterate 8 times (dx) value storing
                // 4 bytes of colour b0 in eight adjacent rows
                *(DWORD UNALIGNED HUGE *)row = dw;
                *((DWORD UNALIGNED HUGE *)row+1) = dw;
            }

            return cmp;
        }
        else // this is an edge with 4 color pairs in four small blocks
        {
	    /* read 2 colours, and make AND and XOR masks for first subcell*/
            b0 = *((LPBYTE)cmp)++;
            b1 = *((LPBYTE)cmp)++;
	    Czero = MAKE4(b1);
	    Cxor = Czero ^ MAKE4(b0);

	    /* colour masks for second subcell */
            b0 = *((LPBYTE)cmp)++;
            b1 = *((LPBYTE)cmp)++;
	    Ctwo = MAKE4(b1);
	    Cxor2 = Ctwo ^ MAKE4(b0);

	    row = uncmp;

	    /* first two rows  - top two subcells */
            for (y = 0; y < 2; y++) {

                /* --- first subcell (two pixels) ----  */

                /* turn bitmask into byte mask */
#if 0
                dwBytes = ((mask & 1) ? 0xffff: 0) |
                   ((mask & 2) ? 0xffff0000 : 0);
#else
                dwBytes = Bits2Bytes[mask&3];
#endif

                /* select both colours and write to dest */
                dwBytes = (dwBytes & Cxor) ^ Czero;
                *( (DWORD UNALIGNED HUGE *)row) = dwBytes;
                *( (DWORD UNALIGNED HUGE *)(row + bytesPerRow)) = dwBytes;

                /* ---- second subcell (two pixels) --- */
                /* turn bitmask into byte mask */
#if 0
                dwBytes = ((mask & 4) ? 0xffff: 0) |
                   ((mask & 8) ? 0xffff0000 : 0);
#else
                dwBytes = Bits2Bytes[mask&0xc];
#endif

                /* select both colours and write to dest */
                dwBytes = (dwBytes & Cxor2) ^ Ctwo;
                *( (DWORD UNALIGNED HUGE *)(row + sizeof(DWORD))) = dwBytes;
                *( (DWORD UNALIGNED HUGE *)(row + sizeof(DWORD) + bytesPerRow)) = dwBytes;

                row += bytesPerRow * 2;
                mask >>= 4;

            }

	    /* second two rows  - bottom two subcells */

	    /* read 2 colours, and make AND and XOR masks for first subcell*/
            b0 = *((LPBYTE)cmp)++;
            b1 = *((LPBYTE)cmp)++;
	    Czero = MAKE4(b1);
	    Cxor = Czero ^ MAKE4(b0);

	    /* colour masks for second subcell */
            b0 = *((LPBYTE)cmp)++;
            b1 = *((LPBYTE)cmp)++;
	    Ctwo = MAKE4(b1);
	    Cxor2 = Ctwo ^ MAKE4(b0);


            for (y = 0; y < 2; y++) {

                /* --- first subcell (two pixels) ----  */

                /* turn bitmask into byte mask */
#if 0
                dwBytes = ((mask & 1) ? 0xffff: 0) |
                   ((mask & 2) ? 0xffff0000 : 0);
#else
                dwBytes = Bits2Bytes[mask&3];
#endif

                /* select both colours and write to dest */
                dwBytes = (dwBytes & Cxor) ^ Czero;
                *( (DWORD UNALIGNED HUGE *)row) = dwBytes;
                *( (DWORD UNALIGNED HUGE *)(row + bytesPerRow)) = dwBytes;

                /* ---- second subcell (two pixels) --- */
                /* turn bitmask into byte mask */
#if 0
                dwBytes = ((mask & 4) ? 0xffff: 0) |
                   ((mask & 8) ? 0xffff0000 : 0);
#else
                dwBytes = Bits2Bytes[mask&0xc];
#endif

                /* select both colours and write to dest */
                dwBytes = (dwBytes & Cxor2) ^ Ctwo;
                *( (DWORD UNALIGNED HUGE *)(row + sizeof(DWORD))) = dwBytes;
                *( (DWORD UNALIGNED HUGE *)(row + sizeof(DWORD) + bytesPerRow)) = dwBytes;

                row += bytesPerRow * 2;
                mask >>= 4;

            }
        }
    }
    else // not an edge with only 1 color pair and one large block
    {
	/* use and, xor to map several colours at once.
	 * relies on (Czero ^ Cone) ^ Czero == Cone and Czero ^ 0 == Czero.
	 */

	/* read colours */
        b1 = *((LPBYTE)cmp)++;
        b0 = *((LPBYTE)cmp)++;
	row = uncmp;

	/* make two DWORDs, one with four copies of colour 0, and one
	 * with four copies of (b0 ^ b1).
	 */
	Czero = MAKE4(b0);
	Cxor = Czero ^ MAKE4(b1);

	for (y = 0; y < 4; y++) {
	
            /* --- first two pixels in row ----  */

            /* turn bitmask into byte mask */
#if 0
            dwBytes = ((mask & 1) ? 0xffff: 0) |
                   ((mask & 2) ? 0xffff0000 : 0);
#else
            dwBytes = Bits2Bytes[mask&3];
#endif

            /* select both colours and write to dest */
	    dwBytes = (dwBytes & Cxor) ^ Czero;
            *( (DWORD UNALIGNED HUGE *)row) = dwBytes;
            *( (DWORD UNALIGNED HUGE *)(row + bytesPerRow)) = dwBytes;
	

	    /* ---- second two pixels in row ---- */
            /* turn bitmask into byte mask */
#if 0
            dwBytes = ((mask & 4) ? 0xffff: 0) |
               ((mask & 8) ? 0xffff0000 : 0);
#else
            dwBytes = Bits2Bytes[mask&0xc];
#endif

            /* select both colours and write to dest */
	    dwBytes = (dwBytes & Cxor) ^ Czero;
            *( (DWORD UNALIGNED HUGE *)(row + sizeof(DWORD))) = dwBytes;
            *( (DWORD UNALIGNED HUGE *)(row + sizeof(DWORD) + bytesPerRow)) = dwBytes;

            row += bytesPerRow * 2;
	    mask >>= 4;
	}
    }
    return( cmp );
}

/*
 * decompress one frame, stretching by 2.
 *
 * parameters:
 *   lpbiIn     pointer to compressed buffer for this frame
 *   lpIn       pointer to compressed data for this block
 *   lpbiOut    pointer to decompressed bitmap header
 *   lpOut      pointer to where to store the decompressed data
 *
 * returns:
 *   0 on success
 *
 * Uses  DecompressCBlockTo8X2 (see above) to do the decompression.
 * This also returns (via a pointer to SkipCount8X2) the count of cells
 * to skip. We can then move the source and target pointers on
 * until the SkipCount is exhausted.
 */

DWORD FAR PASCAL DecompressFrame8X2C(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                    LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y)
{
HPWORD  cmp = (HPWORD)lpIn;
int     bix;
int     biy;
HPBYTE  blockRow;
HPBYTE  blockColumn;
LONG    SkipCount8X2 = 0;
int     bytesPerRow;


    DPF(("DecompressFrame8X2C:\n"));
    bix = (int)(lpbiIn->biWidth) / (WIDTH_CBLOCK);
    biy = (int)(lpbiIn->biHeight) / (HEIGHT_CBLOCK);

    StartCounting();

    blockRow = DibXY(lpbiOut, lpOut, x, y, &bytesPerRow);

    for( y=biy; y--; blockRow += bytesPerRow * HEIGHT_CBLOCK*2 )
    {
        blockColumn = blockRow;

        for( x=bix; x--; blockColumn += WIDTH_CBLOCK*2 )
        {
            cmp = DecompressCBlockTo8X2(blockColumn, cmp, bytesPerRow, &SkipCount8X2);

            // See if the SkipCount has been set.  If so we want to move to
            // the next location rather than calling DecompressCBlock every
            // time around the loop.  Keep the test simple to minimise the
            // overhead on every iteration that the Skipcount is 0.
            if (SkipCount8X2) {

                if ((x -= SkipCount8X2) <0) { // extends past this row
                    LONG SkipRows;

                    // More than just the remainder of this row to skip
                    SkipCount8X2 =-x;  // These bits are on the next row(s)
                    // SkipCount8X2 will be >0 otherwise we would have gone
                    // down the else leg.

                    // Calculate how many complete and partial rows to skip.
                    // We know we have skipped at least one row.  The plan
                    // is to restart the X loop at some point along the row.
                    // If the skipcount takes us exactly to the end of a row
                    // we drop out of the x loop, and let the outer y loop do
                    // the decrement.  This takes care of the case when the
                    // skipcount takes us to the very end of the image.

                    SkipRows = 1 + (SkipCount8X2-1)/bix;

                    // Decrement the row count and set new blockrow start

#ifdef _WIN32
                    if (y<SkipRows) {
                        Assert(y >= SkipRows);
                        SkipRows = y;
                    }
#endif

                    // Unless we have finished we need to reset blockRow
                    y -= SkipRows;
                    // y might be 0, but we must still complete the last row
                    blockRow += bytesPerRow*HEIGHT_CBLOCK*2*SkipRows;

                    // Calculate the offset into the next row we will process
                    x = SkipCount8X2%bix;  // This may be 0

                    if (x) {

                        // Set block column by the amount along the row
                        // this iteration is starting, making allowance for
                        // the "for x..." loop iterating blockColumn once.
                        blockColumn = blockRow + ((x-1)*WIDTH_CBLOCK*2);

                        x=bix-x;  // Get the counter correct
                    }

                    SkipCount8X2 = 0; // Skip count now exhausted (so am I)

                } else {
                    // SkipCount has been exhausted by this row
                    // Either the row has completed, or there is more data
                    // on this row.   Check...
                    if (x) {
                        // More of this row left
                        // Worry about moving blockColumn on the right amount
                        blockColumn += WIDTH_CBLOCK*2*SkipCount8X2;
                    } // else x==0 and we will drop out of the "for x..." loop
                      // blockColumn will be reset when we reenter the x loop
                    SkipCount8X2=0;
                }
            }
        }
    }

    EndCounting("Decompress and stretch 8x2 took");
    return 0;
}

/*
 * -------- 16-bit decompression ----------------------------------------
 *
 *
 * CRAM-16 has 16-bit mask or escape code, together with 16-bit (RGB555)
 * colour words. We decode to 16 bits, to 24-bits (above), and to 8 bits
 * stretched 1:1 and 1:2 (this case DecompressFrame16To8X2C does
 * decompression, dithering and stretching in one pass.
 *
 * The input stream consists of four cases:
 *
 * SOLID	top bit set, lower 15 bits is solid colour for entire cell
 *      If the red element (bits 9-14) = '00001', then this is not a solid
 *	colour but a skip count.
 *	Write the colour to each pixel, two pixels (one DWORD) at
 *	a time.
 *
 * SKIP		top 6 bits = 100001xxxxxxxxxx, lower 10 bits have skip count
 *      Store the skip count via a pointer to a variable passed by the.
 *	parent - this way the skip count is maintained across calls
 *
 * Mask + 2 colours   (top bit 0, bit 15 of first colour word also 0)
 *	1s in the mask represent the first colour, 0s the second colour.
 *      Pixels are represented thus:
 *		
 *		C D E F
 *		8 9 A B
 *		4 5 6 7
 *		0 1 2 3
 *
 *
 * Mask + 8 colours.	(top bit 0, bit 15 of first colour word == 1)
 * 	
 *	1s and 0s represent two colours as before, but the cell is divided
 *	into 4 subcells with two colours per subcell. The first pair of
 *	colours are for subcell 0145, then 2367, 89cd and abef.
 *	
 *
 * Dithering:
 *
 *   we use the table method from drawdib\dith775.c, and we import the
 * same tables and palette by including their header file. We have a fixed
 * palette in which we have 7 levels of red, 7 levels of green and 5 levels of
 * blue (= 245 combinations) in a 256-colour palette. We use tables
 * to quantize the colour elements to 7 levels, combine them into an 8-bit
 * value and then lookup in a table that maps this combination to the actual
 * palette. Before quantizing, we add on small corrections (less than one
 * level) based on the x,y position of the pixel to balance the
 * colour over a 4x4 pixel area: this makes the decompression slightly more
 * awkward since we dither differently for any x, y position within the cell.
 *
 * -----------------------------------------------------------------------
 */	

/* ---- 16-bit decompress to 16 bits ----------------------------------*/


/*
 * decompress one 16bpp block to RGB555.
 *
 * parameters:
 *   uncmp-     pointer to de-compressed buffer for this block.
 *   cmp -      pointer to compressed data for this block
 *   bytes.. -  size of one row of de-compressed data
 *   pSkipCount - outstanding count of cells to skip - set here and just stored
 * 		in parent stack frame for multi-thread-safe continuity.
 *
 * returns:
 *   pointer to the next block of compressed data.
 *
 */

STATICFN HPWORD INLINE
DecompressCBlock16To555(
    HPBYTE uncmp,
    HPWORD cmp,
    INT bytesPerRow,
    LONG FAR *pSkipCount
)
{
    UINT    y;
    WORD    mask;
    WORD    col0, col1;
    HPBYTE  row;
    DWORD Czero, Cxor, Ctwo, Cxor2, dwBytes;

    // check for outstanding skips

    if (*pSkipCount > 0)
    {
        (*pSkipCount)--;
        return cmp;
    }

    // get mask and init bit mask
    mask = *cmp++;

    // check for a skip or a solid color

    if (mask & 0x8000)
        {
        if ((mask & ~SKIP_MASK) == SKIP_MAGIC)
            {
            *pSkipCount = (mask & SKIP_MASK);

#ifdef _WIN32
            Assert(*pSkipCount != 0);  // break (on debug builds) if SkipCount == 0
#endif

            (*pSkipCount)--;
            return cmp;
            }
        else /* must be solid colour */
        {

	    /* write four rows of 4 2-byte pixels of col0 */

	    /* solid colour is lower 15 bits of mask */
            col0 = mask & 0x7fff;
	    Czero = col0 | (col0 << 16);

            for(row = uncmp, y = 0; y < HEIGHT_CBLOCK; y++, row+= bytesPerRow) {


                *(DWORD UNALIGNED HUGE *)row = Czero;
		*((DWORD UNALIGNED HUGE *)row+1) = Czero;

        }

            return cmp;
    }
    }


    /* in 16-bit CRAM, both 4-pair and 1-pair cells have bit 15 of mask set
     * to zero. We distinguish between them based on bit 15 of the first
     * colour. if this is set, this is the 4-pair edge case cell.
     */
    if (*cmp & 0x8000) {
        // this is an edge with 4 colour pairs in four small blocks

	/* read 2 colours, and make AND and XOR masks for first subcell*/
	col0 = *cmp++;
	col1 = *cmp++;
	Czero = col1 | (col1 << 16);
	Cxor = Czero ^ (col0 | (col0 << 16));

	/* colour masks for second subcell */
	col0 = *cmp++;
	col1 = *cmp++;
	Ctwo = col1 | (col1 << 16);
	Cxor2 = Ctwo ^ (col0 | (col0 << 16));


	row = uncmp;

	/* first two rows  - top two subcells */
	for (y = 0; y < 2; y++) {

	    /* --- first subcell (two pixels) ----  */

	    /* turn bitmask into byte mask */
#if 0
            dwBytes = ((mask & 1) ? 0xffff: 0) |
                   ((mask & 2) ? 0xffff0000 : 0);
#else
            dwBytes = Bits2Bytes[mask&3];
#endif

	    /* select both colours and write to dest */
	    dwBytes = (dwBytes & Cxor) ^ Czero;
	    *( (DWORD UNALIGNED HUGE *)row) = dwBytes;


	    /* ---- second subcell (two pixels) --- */
	    /* turn bitmask into byte mask */
#if 0
            dwBytes = ((mask & 4) ? 0xffff: 0) |
               ((mask & 8) ? 0xffff0000 : 0);
#else
            dwBytes = Bits2Bytes[mask&0xc];
#endif

	    /* select both colours and write to dest */
	    dwBytes = (dwBytes & Cxor2) ^ Ctwo;
	    *( (DWORD UNALIGNED HUGE *)(row + sizeof(DWORD))) = dwBytes;

	    row += bytesPerRow;
	    mask >>= 4;


	}

	/* second two rows  - bottom two subcells */

	/* read 2 colours, and make AND and XOR masks for first subcell*/
	col0 = *cmp++;
	col1 = *cmp++;
	Czero = col1 | (col1 << 16);
	Cxor = Czero ^ (col0 | (col0 << 16));

	/* colour masks for second subcell */
	col0 = *cmp++;
	col1 = *cmp++;
	Ctwo = col1 | (col1 << 16);
	Cxor2 = Ctwo ^ (col0 | (col0 << 16));



	for (y = 0; y < 2; y++) {

	    /* --- first subcell (two pixels) ----  */

	    /* turn bitmask into byte mask */
#if 0
            dwBytes = ((mask & 1) ? 0xffff: 0) |
                   ((mask & 2) ? 0xffff0000 : 0);
#else
            dwBytes = Bits2Bytes[mask&3];
#endif

	    /* select both colours and write to dest */
	    dwBytes = (dwBytes & Cxor) ^ Czero;
	    *( (DWORD UNALIGNED HUGE *)row) = dwBytes;


	    /* ---- second subcell (two pixels) --- */
	    /* turn bitmask into byte mask */
#if 0
            dwBytes = ((mask & 4) ? 0xffff: 0) |
               ((mask & 8) ? 0xffff0000 : 0);
#else
            dwBytes = Bits2Bytes[mask&0xc];
#endif

	    /* select both colours and write to dest */
	    dwBytes = (dwBytes & Cxor2) ^ Ctwo;
	    *( (DWORD UNALIGNED HUGE *)(row + sizeof(DWORD))) = dwBytes;

	    row += bytesPerRow;
	    mask >>= 4;

	}

    } else {
    	// not an edge with only 1 colour pair and one large block


	/* read colours */
	col0 = *cmp++;
	col1 = *cmp++;
	Czero = col1 | (col1 << 16);
	Cxor = Czero ^ (col0 | (col0 << 16));

	row = uncmp;

	for (y = 0; y < 4; y++) {


            /* --- first two pixels in row ----  */

            /* turn bitmask into byte mask */
#if 0
            dwBytes = ((mask & 1) ? 0xffff: 0) |
                   ((mask & 2) ? 0xffff0000 : 0);
#else
            dwBytes = Bits2Bytes[mask&3];
#endif

            /* select both colours and write to dest */
	    dwBytes = (dwBytes & Cxor) ^ Czero;
            *( (DWORD UNALIGNED HUGE *)row) = dwBytes;
	

	    /* ---- second two pixels in row ---- */
            /* turn bitmask into byte mask */
#if 0
            dwBytes = ((mask & 4) ? 0xffff: 0) |
               ((mask & 8) ? 0xffff0000 : 0);
#else
            dwBytes = Bits2Bytes[mask&0xc];
#endif

            /* select both colours and write to dest */
	    dwBytes = (dwBytes & Cxor) ^ Czero;
            *( (DWORD UNALIGNED HUGE *)(row + sizeof(DWORD))) = dwBytes;

            row += bytesPerRow;
	    mask >>= 4;

	}
    }
    return( cmp );

}


DWORD FAR PASCAL DecompressFrame16To555C(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                    LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y)
{
HPWORD  cmp = (HPWORD)lpIn;
INT     bix;
INT     biy;
HPBYTE  blockRow;
HPBYTE  blockColumn;
LONG SkipCount = 0;
INT     bytesPerRow;

    DPF(("DecompressFrame16To555C:\n"));
    bix = (UINT)(lpbiIn->biWidth) / (WIDTH_CBLOCK);   // No negative values in
    biy = (UINT)(lpbiIn->biHeight) / (HEIGHT_CBLOCK); // width or height fields

    StartCounting();

    blockRow = DibXY(lpbiOut, lpOut, x, y, &bytesPerRow);

    for( y=0; y < biy; y++, blockRow += bytesPerRow * HEIGHT_CBLOCK )
    {
        blockColumn = blockRow;
        for( x=0; x < bix; x++, blockColumn += (WIDTH_CBLOCK * sizeof(WORD)))
        {
            cmp = DecompressCBlock16To555(blockColumn, cmp, bytesPerRow, &SkipCount);
        }
    }

    EndCounting("Decompress Frame16To555C took");

    return 0;
}


// 16-bit 565 decompression


// macro to convert a 15-bit 555 colour to a 16-bit 565 colour
#define RGB555_TO_RGB565(c)	(c = ( ((c & 0x7fe0) << 1) | (c & 0x1f)))


/*
 * decompress one 16bpp block to RGB565.
 *
 * same as RGB555 but we need a colour translation between 555->565
 *
 * parameters:
 *   uncmp-     pointer to de-compressed buffer for this block.
 *   cmp -      pointer to compressed data for this block
 *   bytes.. -  size of one row of de-compressed data
 *   pSkipCount - outstanding count of cells to skip - set here and just stored
 * 		in parent stack frame for multi-thread-safe continuity.
 *
 * returns:
 *   pointer to the next block of compressed data.
 *
 */

STATICFN HPWORD INLINE
DecompressCBlock16To565(
    HPBYTE uncmp,
    HPWORD cmp,
    INT bytesPerRow,
    LONG FAR * pSkipCount
)
{
    UINT    y;
    WORD    mask;
    WORD    col0, col1;
    HPBYTE  row;
    DWORD Czero, Cxor, Ctwo, Cxor2, dwBytes;

    // check for outstanding skips

    if (*pSkipCount > 0)
    {
        (*pSkipCount)--;
        return cmp;
    }

    // get mask and init bit mask
    mask = *cmp++;

    // check for a skip or a solid color

    if (mask & 0x8000)
        {
        if ((mask & ~SKIP_MASK) == SKIP_MAGIC)
            {
            *pSkipCount = (mask & SKIP_MASK);

#ifdef _WIN32
            Assert(*pSkipCount != 0);  // break (on debug builds) if SkipCount == 0
#endif

            (*pSkipCount)--;
            return cmp;
            }
        else /* must be solid colour */
        {

	    /* write four rows of 4 2-byte pixels of col0 */

	    /* solid colour is lower 15 bits of mask */
            col0 = mask & 0x7fff;
	    RGB555_TO_RGB565(col0);
	    Czero = col0 | (col0 << 16);

            for(row = uncmp, y = 0; y < HEIGHT_CBLOCK; y++, row+= bytesPerRow) {


                *(DWORD UNALIGNED HUGE *)row = Czero;
		*((DWORD UNALIGNED HUGE *)row+1) = Czero;

        }

            return cmp;
    }
    }


    /* in 16-bit CRAM, both 4-pair and 1-pair cells have bit 15 of mask set
     * to zero. We distinguish between them based on bit 15 of the first
     * colour. if this is set, this is the 4-pair edge case cell.
     */
    if (*cmp & 0x8000) {
        // this is an edge with 4 colour pairs in four small blocks

	/* read 2 colours, and make AND and XOR masks for first subcell*/
	col0 = *cmp++;
	RGB555_TO_RGB565(col0);
	col1 = *cmp++;
	RGB555_TO_RGB565(col1);
	Czero = col1 | (col1 << 16);
	Cxor = Czero ^ (col0 | (col0 << 16));

	/* colour masks for second subcell */
	col0 = *cmp++;
	RGB555_TO_RGB565(col0);
	col1 = *cmp++;
	RGB555_TO_RGB565(col1);
	Ctwo = col1 | (col1 << 16);
	Cxor2 = Ctwo ^ (col0 | (col0 << 16));


	row = uncmp;

	/* first two rows  - top two subcells */
	for (y = 0; y < 2; y++) {

	    /* --- first subcell (two pixels) ----  */

	    /* turn bitmask into byte mask */
#if 0
            dwBytes = ((mask & 1) ? 0xffff: 0) |
                   ((mask & 2) ? 0xffff0000 : 0);
#else
            dwBytes = Bits2Bytes[mask&3];
#endif

	    /* select both colours and write to dest */
	    dwBytes = (dwBytes & Cxor) ^ Czero;
	    *( (DWORD UNALIGNED HUGE *)row) = dwBytes;


	    /* ---- second subcell (two pixels) --- */
	    /* turn bitmask into byte mask */
#if 0
            dwBytes = ((mask & 4) ? 0xffff: 0) |
               ((mask & 8) ? 0xffff0000 : 0);
#else
            dwBytes = Bits2Bytes[mask&0xc];
#endif

	    /* select both colours and write to dest */
	    dwBytes = (dwBytes & Cxor2) ^ Ctwo;
	    *( (DWORD UNALIGNED HUGE *)(row + sizeof(DWORD))) = dwBytes;

	    row += bytesPerRow;
	    mask >>= 4;


	}

	/* second two rows  - bottom two subcells */

	/* read 2 colours, and make AND and XOR masks for first subcell*/
	col0 = *cmp++;
	RGB555_TO_RGB565(col0);
	col1 = *cmp++;
	RGB555_TO_RGB565(col1);
	Czero = col1 | (col1 << 16);
	Cxor = Czero ^ (col0 | (col0 << 16));

	/* colour masks for second subcell */
	col0 = *cmp++;
	RGB555_TO_RGB565(col0);
	col1 = *cmp++;
	RGB555_TO_RGB565(col1);
	Ctwo = col1 | (col1 << 16);
	Cxor2 = Ctwo ^ (col0 | (col0 << 16));



	for (y = 0; y < 2; y++) {

	    /* --- first subcell (two pixels) ----  */

	    /* turn bitmask into byte mask */
#if 0
            dwBytes = ((mask & 1) ? 0xffff: 0) |
                   ((mask & 2) ? 0xffff0000 : 0);
#else
            dwBytes = Bits2Bytes[mask&3];
#endif

	    /* select both colours and write to dest */
	    dwBytes = (dwBytes & Cxor) ^ Czero;
	    *( (DWORD UNALIGNED HUGE *)row) = dwBytes;


	    /* ---- second subcell (two pixels) --- */
	    /* turn bitmask into byte mask */
#if 0
            dwBytes = ((mask & 4) ? 0xffff: 0) |
               ((mask & 8) ? 0xffff0000 : 0);
#else
            dwBytes = Bits2Bytes[mask&0xc];
#endif

	    /* select both colours and write to dest */
	    dwBytes = (dwBytes & Cxor2) ^ Ctwo;
	    *( (DWORD UNALIGNED HUGE *)(row + sizeof(DWORD))) = dwBytes;

	    row += bytesPerRow;
	    mask >>= 4;

	}

    } else {
    	// not an edge with only 1 colour pair and one large block


	/* read colours */
	col0 = *cmp++;
	RGB555_TO_RGB565(col0);
	col1 = *cmp++;
	RGB555_TO_RGB565(col1);
	Czero = col1 | (col1 << 16);
	Cxor = Czero ^ (col0 | (col0 << 16));

	row = uncmp;

	for (y = 0; y < 4; y++) {


            /* --- first two pixels in row ----  */

            /* turn bitmask into byte mask */
#if 0
            dwBytes = ((mask & 1) ? 0xffff: 0) |
                   ((mask & 2) ? 0xffff0000 : 0);
#else
            dwBytes = Bits2Bytes[mask&3];
#endif

            /* select both colours and write to dest */
	    dwBytes = (dwBytes & Cxor) ^ Czero;
            *( (DWORD UNALIGNED HUGE *)row) = dwBytes;
	

	    /* ---- second two pixels in row ---- */
            /* turn bitmask into byte mask */
#if 0
            dwBytes = ((mask & 4) ? 0xffff: 0) |
               ((mask & 8) ? 0xffff0000 : 0);
#else
            dwBytes = Bits2Bytes[mask&0xc];
#endif

            /* select both colours and write to dest */
	    dwBytes = (dwBytes & Cxor) ^ Czero;
            *( (DWORD UNALIGNED HUGE *)(row + sizeof(DWORD))) = dwBytes;

            row += bytesPerRow;
	    mask >>= 4;

	}
    }
    return( cmp );

}

DWORD FAR PASCAL DecompressFrame16To565C(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                    LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y)
{
HPWORD  cmp = (HPWORD)lpIn;
INT     bix;
INT     biy;
HPBYTE  blockRow;
HPBYTE  blockColumn;
LONG	SkipCount = 0;
INT     bytesPerRow;

    DPF(("DecompressFrame16To565C:\n"));
    bix = (UINT)(lpbiIn->biWidth) / (WIDTH_CBLOCK);   // No negative values in
    biy = (UINT)(lpbiIn->biHeight) / (HEIGHT_CBLOCK); // width or height fields

    StartCounting();
    blockRow = DibXY(lpbiOut, lpOut, x, y, &bytesPerRow);

    for( y=0; y < biy; y++, blockRow += bytesPerRow * HEIGHT_CBLOCK )
    {
        blockColumn = blockRow;
        for( x=0; x < bix; x++, blockColumn += (WIDTH_CBLOCK * sizeof(WORD)))
        {
            cmp = DecompressCBlock16To565(blockColumn, cmp, bytesPerRow, &SkipCount);
        }
    }
    EndCounting("Decompress Frame16To565C took");

    return 0;
}


/* ---- 16-bit decompress & dither to 8 bit - in asm for Win16 ---------------------------*/

/*
 * dither using SCALE method. see dcram168.asm or drawdib\dith775a.asm
 *
 * 	8-bit colour = lookup[ scale[ rgb555] + err]
 *
 * where error is one of the values in the 4x4 array below to balance
 * the colour.
 */

/*
 * dither error array - values to add to rgb value after scaling before
 * converting to 8 bits. Balances colour over a 4x4 matrix
 */
int ditherr[4][4] = {
	{0,    3283, 4924, 8207},
	{6565, 6566, 1641, 1642},
	{3283, 0,    8207, 4924},
	{6566, 4925, 3282, 1641}
};

/* scale the rgb555 first by lookup in lpScale[rgb555] */
#define DITHER16TO8(col, x, y)		lpLookup[col + ditherr[(y)&3][(x)&3]]


/*
 * decompress one 16bpp block, and dither to 8 bpp using table dither method.
 *
 * parameters:
 *   uncmp-     pointer to de-compressed buffer for this block.
 *   cmp -      pointer to compressed data for this block
 *   bytes.. -  size of one row of de-compressed data
 *   pSkipCount - skipcount stored in parent stack frame
 *
 * returns:
 *   pointer to the next block of compressed data.
 *
 */

STATICFN HPWORD INLINE
DecompressCBlock16To8(
    HPBYTE uncmp,
    HPWORD cmp,
    INT bytesPerRow,
    LONG * pSkipCount
)
{
    UINT    y;
    WORD    mask;
    WORD    col0, col1, col2, col3;
    HPBYTE  row;
    DWORD Czero, Cone, Cxor, dwBytes;

    // check for outstanding skips

    if (*pSkipCount > 0)
    {
        Assert(!"Skip count should be handled by caller");
        (*pSkipCount)--;
        return cmp;
    }

    // get mask and init bit mask
    mask = *cmp++;

    // check for a skip or a solid color

    if (mask & 0x8000)
    {
        if ((mask & ~SKIP_MASK) == SKIP_MAGIC)
        {
            *pSkipCount = (mask & SKIP_MASK);

#ifdef _WIN32
            Assert(*pSkipCount != 0);  // break (on debug builds) if SkipCount == 0
#endif

            (*pSkipCount)--;
            return cmp;
        }
        else /* must be solid colour */
        {

	    /* solid colour is lower 15 bits of mask */
            col0 = lpScale[mask & 0x7fff];

            for(row = uncmp, y = 0; y < HEIGHT_CBLOCK; y++, row+= bytesPerRow) {

		/* convert colour once for each row */
		Czero = (DITHER16TO8(col0, 0, y) ) |
			(DITHER16TO8(col0, 1, y) << 8 ) |
			(DITHER16TO8(col0, 2, y) << 16 ) |
			(DITHER16TO8(col0, 3, y) << 24 );

                *(DWORD UNALIGNED HUGE *)row = Czero;
            }

            return cmp;
        }
    }


    /* in 16-bit CRAM, both 4-pair and 1-pair cells have bit 15 of mask set
     * to zero. We distinguish between them based on bit 15 of the first
     * colour. if this is set, this is the 4-pair edge case cell.
     */
    if (*cmp & 0x8000) {
        // this is an edge with 4 color pairs in four small blocks

	col0 = lpScale[(*cmp++) & 0x7fff];
	col1 = lpScale[(*cmp++) & 0x7fff];
	col2 = lpScale[(*cmp++) & 0x7fff];
	col3 = lpScale[(*cmp++) & 0x7fff];

	row = uncmp;

	/* first two rows  - top two subcells */
	for (y = 0; y < 2; y++) {


	    /* dithering requires that we make different
	     * colour masks depending on x and y position - and
	     * therefore re-do it each row
	     */
	    Czero = (DITHER16TO8(col1, 0, y) ) |
		    (DITHER16TO8(col1, 1, y) << 8 ) |
		    (DITHER16TO8(col3, 2, y) << 16 ) |
		    (DITHER16TO8(col3, 3, y) << 24 );
	
	    Cone = (DITHER16TO8(col0, 0, y) ) |
		    (DITHER16TO8(col0, 1, y) << 8 ) |
		    (DITHER16TO8(col2, 2, y) << 16 ) |
		    (DITHER16TO8(col2, 3, y) << 24 );

	    Cxor = Czero ^ Cone;

	    /* turn bitmask into byte mask */
            dwBytes = ExpansionTable[mask & 0x0f];

	    /* select colours and write to dest */
	    *( (DWORD UNALIGNED HUGE *)row) = (dwBytes & Cxor) ^ Czero;

	    row += bytesPerRow;
	    mask >>= 4;

	}

	/* second two rows  - bottom two subcells */

	/* read last four colours  */
	col0 = lpScale[(*cmp++) & 0x7fff];
	col1 = lpScale[(*cmp++) & 0x7fff];
	col2 = lpScale[(*cmp++) & 0x7fff];
	col3 = lpScale[(*cmp++) & 0x7fff];


	for (; y < 4; y++) {

	    /* dithering requires that we make different
	     * colour masks depending on x and y position - and
	     * therefore re-do it each row
	     */
	    Czero = (DITHER16TO8(col1, 0, y) ) |
		    (DITHER16TO8(col1, 1, y) << 8 ) |
		    (DITHER16TO8(col3, 2, y) << 16 ) |
		    (DITHER16TO8(col3, 3, y) << 24 );
	
	    Cone = (DITHER16TO8(col0, 0, y) ) |
		    (DITHER16TO8(col0, 1, y) << 8 ) |
		    (DITHER16TO8(col2, 2, y) << 16 ) |
		    (DITHER16TO8(col2, 3, y) << 24 );

	    Cxor = Czero ^ Cone;

	    /* turn bitmask into byte mask */
            dwBytes = ExpansionTable[mask & 0x0f];

	    /* select both colours and write to dest */
	    *( (DWORD UNALIGNED HUGE *)row) = (dwBytes & Cxor) ^ Czero;

	    row += bytesPerRow;
	    mask >>= 4;

	}
    } else {
    	// not an edge with only 1 colour pair and one large block


	/* read colours */
	col0 = lpScale[(*cmp++) & 0x7fff];
	col1 = lpScale[(*cmp++) & 0x7fff];

	row = uncmp;

	for (y = 0; y < 4; y++) {

	    Czero = (DITHER16TO8(col1, 0, y) ) |
		    (DITHER16TO8(col1, 1, y) << 8 ) |
		    (DITHER16TO8(col1, 2, y) << 16 ) |
		    (DITHER16TO8(col1, 3, y) << 24 );
	
	    Cone =  (DITHER16TO8(col0, 0, y) ) |
		    (DITHER16TO8(col0, 1, y) << 8 ) |
		    (DITHER16TO8(col0, 2, y) << 16 ) |
		    (DITHER16TO8(col0, 3, y) << 24 );

	    Cxor = Czero ^ Cone;

            /* turn bitmask into byte mask */
            dwBytes = ExpansionTable[mask & 0x0f];

            /* select both colours and write to dest */
            *( (DWORD UNALIGNED HUGE *)row) = (dwBytes & Cxor) ^ Czero;

            row += bytesPerRow;
	    mask >>= 4;

	}
    }
    return( cmp );

}

DWORD FAR PASCAL DecompressFrame16To8C(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                    LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y)
{
HPWORD  cmp = (HPWORD)lpIn;
INT     bix;
INT     biy;
HPBYTE  blockRow;
HPBYTE  blockColumn;
LONG	SkipCount = 0;
INT     bytesPerRow;

    DPF(("DecompressFrame16To8C:\n"));
    /* init dither table pointers. lpDitherTable is inited in msvidc. */
    lpScale = lpDitherTable;
    lpLookup = (LPBYTE) &lpScale[32768];

    bix = (UINT)(lpbiIn->biWidth) / (WIDTH_CBLOCK);   // No negative values in
    biy = (UINT)(lpbiIn->biHeight) / (HEIGHT_CBLOCK); // width or height fields

    StartCounting();

    blockRow = DibXY(lpbiOut, lpOut, x, y, &bytesPerRow);

    for( y=biy; y--; blockRow += bytesPerRow * HEIGHT_CBLOCK )
    {
        blockColumn = blockRow;
        for( x=bix; x--; blockColumn += WIDTH_CBLOCK)
        {
            cmp = DecompressCBlock16To8(blockColumn, cmp, bytesPerRow, &SkipCount);

            // See if the SkipCount has been set.  If so we want to move to
            // the next location rather than calling DecompressCBlock every
            // time around the loop.  Keep the test simple to minimise the
            // overhead on every iteration that the Skipcount is 0.
            if (SkipCount) {

                if ((x -= SkipCount) <0) { // extends past this row
                    LONG SkipRows;

                    // More than just the remainder of this row to skip
                    SkipCount =-x;  // These bits are on the next row(s)
                    // SkipCount will be >0 otherwise we would have gone
                    // down the else leg.

                    // Calculate how many complete and partial rows to skip.
                    // We know we have skipped at least one row.  The plan
                    // is to restart the X loop at some point along the row.
                    // If the skipcount takes us exactly to the end of a row
                    // we drop out of the x loop, and let the outer y loop do
                    // the decrement.  This takes care of the case when the
                    // skipcount takes us to the very end of the image.

                    SkipRows = 1 + (SkipCount-1)/bix;

                    // Decrement the row count and set new blockrow start

#ifdef _WIN32
                    if (y<SkipRows) {
                        Assert(y >= SkipRows);
                        SkipRows = y;
                    }
#endif

                    // Unless we have finished we need to reset blockRow
                    y -= SkipRows;
                    // y might be 0, but we must still complete the last row
                    blockRow += bytesPerRow*HEIGHT_CBLOCK*SkipRows;

                    // Calculate the offset into the next row we will process
                    x = SkipCount%bix;  // This may be 0

                    if (x) {

                        // Set block column by the amount along the row
                        // this iteration is starting, making allowance for
                        // the "for x..." loop iterating blockColumn once.
                        blockColumn = blockRow + ((x-1)*WIDTH_CBLOCK);

                        x=bix-x;  // Get the counter correct
                    }

                    SkipCount = 0; // Skip count now exhausted (so am I)

                } else {
                    // SkipCount has been exhausted by this row
                    // Either the row has completed, or there is more data
                    // on this row.   Check...
                    if (x) {
                        // More of this row left
                        // Worry about moving blockColumn on the right amount
                        blockColumn += WIDTH_CBLOCK*SkipCount;
                    } // else x==0 and we will drop out of the "for x..." loop
                      // blockColumn will be reset when we reenter the x loop
                    SkipCount=0;
                }
            }
        }
    }
    EndCounting("Decompress Frame16To8C took");

    return 0;
}

/* -- 16-bit decompress to 8-bit X2 -----------------------------------*/

/*
 * given a 16-bit CRAM input stream, decompress and dither to 8
 * bits and stretch by 2 in both dimensions (ie draw each pixel 4 times).
 */

/*
 * decompress one 16bpp block, and dither to 8 bpp using table dither method.
 * write each pixel 4 times to stretch X 2.
 *
 * parameters:
 *   uncmp-     pointer to de-compressed buffer for this block.
 *   cmp -      pointer to compressed data for this block
 *   bytes.. -  size of one row of de-compressed data
 *   pSkipCount - skip count held in parent stack frame
 *
 * returns:
 *   pointer to the next block of compressed data.
 *
 */

STATICFN HPWORD INLINE
DecompressCBlock16To8X2(
    HPBYTE uncmp,
    HPWORD cmp,
    INT bytesPerRow,
    LONG * pSkipCount
)
{
    UINT    x, y;
    WORD    mask;
    WORD    col0, col1, col2, col3;
    HPBYTE  row, col;
    DWORD Czero;

    // check for outstanding skips

    if (*pSkipCount > 0)
    {
        Assert(!"Skip count should be handled by caller");
        (*pSkipCount)--;
        return cmp;
    }

    // get mask and init bit mask
    mask = *cmp++;

    // check for a skip or a solid color

    if (mask & 0x8000)
    {
        if ((mask & ~SKIP_MASK) == SKIP_MAGIC)
        {
            *pSkipCount = (mask & SKIP_MASK);

#ifdef _WIN32
            Assert(*pSkipCount != 0);  // break (on debug builds) if SkipCount == 0
#endif

            (*pSkipCount)--;
            return cmp;
        }
        else /* must be solid colour */
        {

	    /* solid colour is lower 15 bits of mask */
            col0 = lpScale[mask & 0x7fff];


            for(row = uncmp, y = 0; y < HEIGHT_CBLOCK*2; y++, row+= bytesPerRow) {

		/* convert colour once for each row */
		Czero = (DITHER16TO8(col0, 0, (y&3)) ) |
			(DITHER16TO8(col0, 1, (y&3)) << 8 ) |
			(DITHER16TO8(col0, 2, (y&3)) << 16 ) |
			(DITHER16TO8(col0, 3, (y&3)) << 24 );

                *(DWORD UNALIGNED HUGE *)row = Czero;
                *((DWORD UNALIGNED HUGE *)row + 1) = Czero;

            }

            return cmp;
        }
    }


    /* in 16-bit CRAM, both 4-pair and 1-pair cells have bit 15 of mask set
     * to zero. We distinguish between them based on bit 15 of the first
     * colour. if this is set, this is the 4-pair edge case cell.
     */
    if (*cmp & 0x8000) {
        // this is an edge with 4 colour pairs in four small blocks

	row = uncmp;

	/* first two rows  - top two subcells */
	for (y = 0; y < HEIGHT_CBLOCK*2; y += 2) {

	    /* read colours at start, and again half-way through */
    	    if ((y == 0) || (y == HEIGHT_CBLOCK)) {

		col0 = lpScale[(*cmp++) & 0x7fff];
		col1 = lpScale[(*cmp++) & 0x7fff];
		col2 = lpScale[(*cmp++) & 0x7fff];
		col3 = lpScale[(*cmp++) & 0x7fff];

	    }

	    col = row;

	    /* first two pixels (first subcell) */
	    for (x = 0; x < WIDTH_CBLOCK; x += 2) {
		if (mask & 1) {
	    	    *col = DITHER16TO8(col0, (x & 3), (y&3));
		    *(col + bytesPerRow) =
			DITHER16TO8(col0, (x&3), ((y+1) & 3));


		    col++;

	    	    *col = DITHER16TO8(col0, ((x+1)&3), ((y)&3));
	    	    *(col + bytesPerRow) =
			DITHER16TO8(col0, ((x+1)&3), ((y+1)&3));

		} else {
	    	    *col = DITHER16TO8(col1, (x & 3), (y&3));
		    *(col + bytesPerRow) =
			DITHER16TO8(col1, (x&3), ((y+1) & 3));

		    col++;

	    	    *col = DITHER16TO8(col1, ((x+1)&3), ((y)&3));
	    	    *(col + bytesPerRow) =
			DITHER16TO8(col1, ((x+1)&3), ((y+1)&3));
		}
		col++;
		mask >>= 1;
	    }

	    /* second two pixels (second subcell) */
	    for (; x < WIDTH_CBLOCK*2; x += 2) {
		if (mask & 1) {
	    	    *col = DITHER16TO8(col2, (x & 3), (y&3));
		    *(col + bytesPerRow) =
			DITHER16TO8(col2, (x&3), ((y+1) & 3));

                    col++;

	    	    *col = DITHER16TO8(col2, ((x+1)&3), ((y)&3));
	    	    *(col + bytesPerRow) =
			DITHER16TO8(col2, ((x+1)&3), ((y+1)&3));
		} else {
	    	    *col = DITHER16TO8(col3, (x & 3), (y&3));
		    *(col + bytesPerRow) =
			DITHER16TO8(col3, (x&3), ((y+1) & 3));

                    col++;
	    	    *col = DITHER16TO8(col3, ((x+1)&3), ((y)&3));
	    	    *(col + bytesPerRow) =
			DITHER16TO8(col3, ((x+1)&3), ((y+1)&3));
		}
		col++;
		mask >>= 1;
	    }
	    row += bytesPerRow * 2;
    	}

    } else {
    	// not an edge with only 1 colour pair and one large block


	/* read colours */
	col0 = lpScale[(*cmp++) & 0x7fff];
	col1 = lpScale[(*cmp++) & 0x7fff];

	row = uncmp;

	for (y = 0; y < HEIGHT_CBLOCK*2; y += 2) {

	    col = row;
	    for (x = 0; x < WIDTH_CBLOCK*2; x += 2) {
		if (mask & 1) {
	    	    *col = DITHER16TO8(col0, (x & 3), (y&3));
		    *(col + bytesPerRow) =
			DITHER16TO8(col0, (x&3), ((y+1) & 3));

                    col++;
	    	    *col = DITHER16TO8(col0, ((x+1)&3), ((y)&3));
	    	    *(col + bytesPerRow) =
			DITHER16TO8(col0, ((x+1)&3), ((y+1)&3));

		} else {
	    	    *col = DITHER16TO8(col1, (x & 3), (y&3));
		    *(col + bytesPerRow) =
			DITHER16TO8(col1, (x&3), ((y+1) & 3));

		    col++;

	    	    *col = DITHER16TO8(col1, ((x+1)&3), ((y)&3));
	    	    *(col + bytesPerRow) =
			DITHER16TO8(col1, ((x+1)&3), ((y+1)&3));
		}
		col++;
		mask >>= 1;
	    }
	    row += bytesPerRow * 2;
	}
    }
    return( cmp );

}


DWORD FAR PASCAL DecompressFrame16To8X2C(LPBITMAPINFOHEADER lpbiIn,  LPVOID lpIn,
                    LPBITMAPINFOHEADER lpbiOut, LPVOID lpOut, LONG x, LONG y)
{
HPWORD  cmp = (HPWORD)lpIn;
INT     bix;
INT     biy;
HPBYTE  blockRow;
HPBYTE  blockColumn;
LONG	SkipCount = 0;
INT     bytesPerRow;

    DPF(("DecompressFrame16To8X2C:\n"));
    /* init dither table pointers. lpDitherTable is inited in msvidc. */
    lpScale = lpDitherTable;
    lpLookup = (LPBYTE) &lpScale[32768];

    StartCounting();

    bix = (UINT)(lpbiIn->biWidth) / (WIDTH_CBLOCK);   // No negative values in
    biy = (UINT)(lpbiIn->biHeight) / (HEIGHT_CBLOCK); // width or height fields

    blockRow = DibXY(lpbiOut, lpOut, x, y, &bytesPerRow);

    for( y=biy; y--; blockRow += bytesPerRow * HEIGHT_CBLOCK *2 )
    {
        blockColumn = blockRow;
        for( x=bix; x--; blockColumn += WIDTH_CBLOCK*2)
        {
            cmp = DecompressCBlock16To8X2(blockColumn, cmp, bytesPerRow, &SkipCount);

            // See if the SkipCount has been set.  If so we want to move to
            // the next location rather than calling DecompressCBlock every
            // time around the loop.  Keep the test simple to minimise the
            // overhead on every iteration that the Skipcount is 0.
            if (SkipCount) {

                if ((x -= SkipCount) <0) { // extends past this row
                    LONG SkipRows;

                    // More than just the remainder of this row to skip
                    SkipCount =-x;  // These bits are on the next row(s)
                    // SkipCount will be >0 otherwise we would have gone
                    // down the else leg.

                    // Calculate how many complete and partial rows to skip.
                    // We know we have skipped at least one row.  The plan
                    // is to restart the X loop at some point along the row.
                    // If the skipcount takes us exactly to the end of a row
                    // we drop out of the x loop, and let the outer y loop do
                    // the decrement.  This takes care of the case when the
                    // skipcount takes us to the very end of the image.

                    SkipRows = 1 + (SkipCount-1)/bix;

                    // Decrement the row count and set new blockrow start

#ifdef _WIN32
                    if (y<SkipRows) {
                        Assert(y >= SkipRows);
                        SkipRows = y;
                    }
#endif

                    // Unless we have finished we need to reset blockRow
                    y -= SkipRows;
                    // y might be 0, but we must still complete the last row
                    blockRow += bytesPerRow*HEIGHT_CBLOCK*2*SkipRows;

                    // Calculate the offset into the next row we will process
                    x = SkipCount%bix;  // This may be 0

                    if (x) {

                        // Set block column by the amount along the row
                        // this iteration is starting, making allowance for
                        // the "for x..." loop iterating blockColumn once.
                        blockColumn = blockRow + ((x-1)*WIDTH_CBLOCK*2);

                        x=bix-x;  // Get the counter correct
                    }

                    SkipCount = 0; // Skip count now exhausted (so am I)

                } else {
                    // SkipCount has been exhausted by this row
                    // Either the row has completed, or there is more data
                    // on this row.   Check...
                    if (x) {
                        // More of this row left
                        // Worry about moving blockColumn on the right amount
                        blockColumn += WIDTH_CBLOCK*2*SkipCount;
                    } // else x==0 and we will drop out of the "for x..." loop
                      // blockColumn will be reset when we reenter the x loop
                    SkipCount=0;
                }
            }
        }
    }
    EndCounting("Decompress Frame16To8x2C took");

    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvidc\profile.h ===
/*
 * utility functions to read and write values to the profile,
 * using win.ini for Win16 or current user\software\microsoft\mciavi
 * in the registry for Win32
 */


#ifndef _WIN32
// For Win16 calls, mmWriteProfileInt passes a STRING for parm 3
//VOID mmWriteProfileInt(LPSTR appname, LPSTR valuename, UINT uValue);

#define mmWriteProfileInt(app, value, default) \
          WriteProfileString(app, value, (LPSTR)default)

#define mmGetProfileInt(app, value, default) \
          GetProfileInt(app, value, (LPSTR)default)

#define mmGetProfileIntA(app, value, default) \
          GetProfileInt(app, value, (LPSTR)default)

#define mmWriteProfileString(appname, valuename, pData) \
          WriteProfileString(appname, valuename, pData)

#define mmGetProfileString(appname, valuename, pDefault, pResult, cbResult) \
          GetProfileString(appname, valuename, pDefault, pResult, cbResult)

#define mmGetProfileStringA(appname, valuename, pDefault, pResult, cbResult) \
          GetProfileString(appname, valuename, pDefault, pResult, cbResult)

#else

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
UINT mmGetProfileInt(LPTSTR appname, LPTSTR valuename, INT uDefault);
UINT mmGetProfileIntA(LPSTR appname, LPSTR valuename, INT uDefault);

/*
 * write an INT to the profile, if it is not the
 * same as the value already there
 */
VOID mmWriteProfileInt(LPTSTR appname, LPTSTR valuename, INT uValue);

/*
 * read a string from the profile into pResult.
 * result is number of bytes written into pResult
 */
DWORD
mmGetProfileString(
    LPTSTR appname,
    LPTSTR valuename,
    LPTSTR pDefault,
    LPTSTR pResult,
    int cbResult
);

DWORD
mmGetProfileStringA(
    LPSTR appname,
    LPSTR valuename,
    LPSTR pDefault,
    LPSTR pResult,
    int cbResult
);

/*
 * write a string to the profile
 */
VOID mmWriteProfileString(LPTSTR appname, LPTSTR valuename, LPTSTR pData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvidc\msvidc.h ===
/*----------------------------------------------------------------------+
| msvidc.h - Microsoft Video 1 Compressor - header file			|
|									|
| Copyright (c) 1990-1994 Microsoft Corporation.			|
| Portions Copyright Media Vision Inc.					|
| All Rights Reserved.							|
|									|
| You have a non-exclusive, worldwide, royalty-free, and perpetual	|
| license to use this source code in developing hardware, software	|
| (limited to drivers and other software required for hardware		|
| functionality), and firmware for video display and/or processing	|
| boards.   Microsoft makes no warranties, express or implied, with	|
| respect to the Video 1 codec, including without limitation warranties	|
| of merchantability or fitness for a particular purpose.  Microsoft	|
| shall not be liable for any damages whatsoever, including without	|
| limitation consequential damages arising from your use of the Video 1	|
| codec.								|
|									|
|									|
+----------------------------------------------------------------------*/

#ifndef RC_INVOKED

#ifndef _INC_COMPDDK
#define _INC_COMPDDK    50      /* version number */
#endif

#include <vfw.h>

#include "decmprss.h"  // Must include DECMPRSS.H first
#include "compress.h"
#endif

#define ID_SCROLL   100
#define ID_TEXT     101

#define IDS_DESCRIPTION 42
#define IDS_NAME        43
#define IDS_ABOUT       44

extern HMODULE ghModule;

#define ALIGNULONG(i)     ((i+3)&(~3))                  /* ULONG aligned ! */
#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */
#define DIBWIDTHBYTES(bi) (int)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount)

#ifndef _WIN32
extern long FAR PASCAL muldiv32(long, long, long);
#endif

// in invcmap.c
LPVOID FAR PASCAL MakeITable(LPRGBQUAD lprgbq, int nColors);

typedef WORD RGB555;
typedef DWORD RGBDWORD;
typedef BYTE HUGE *HPBYTE;
typedef WORD HUGE *HPWORD;
typedef LONG HUGE *HPLONG;
typedef RGBDWORD HUGE *HPRGBDWORD;
typedef RGB555 HUGE *HPRGB555;
typedef RGBTRIPLE HUGE *HPRGBTRIPLE;
typedef RGBQUAD HUGE *HPRGBQUAD;

typedef struct {
    UINT    wTemporalRatio;     // 100 = 1.0, 50 = .50 etc...
}   ICSTATE;

typedef struct {
    DWORD       dwFlags;        // flags from ICOPEN
    DECOMPPROC  DecompressProc; // current decomp proc...
    DECOMPPROC  DecompressTest; // decomp proc...
    ICSTATE     CurrentState;   // current state of compressor.
    int         nCompress;      // count of COMPRESS_BEGIN calls
    int         nDecompress;    // count of DECOMPRESS_BEGIN calls
    int         nDraw;          // count of DRAW_BEGIN calls
    LONG (CALLBACK *Status) (LPARAM lParam, UINT message, LONG l);
    LPARAM	lParam;
    LPBYTE	lpITable;
    RGBQUAD	rgbqOut[256];
} INSTINFO, *PINSTINFO;


#ifdef _WIN32
#define   VideoLoad()   TRUE
#else
BOOL      NEAR PASCAL VideoLoad(void);
#endif
void      NEAR PASCAL VideoFree(void);
INSTINFO *NEAR PASCAL VideoOpen(ICOPEN FAR *icinfo);
LONG      NEAR PASCAL VideoClose(INSTINFO * pinst);
LONG      NEAR PASCAL GetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize);
LONG      NEAR PASCAL SetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize);
LONG      NEAR PASCAL GetInfo(INSTINFO * pinst, ICINFO FAR *icinfo, DWORD dwSize);

#define QueryAbout(x)  (TRUE)
//BOOL    NEAR PASCAL QueryAbout(INSTINFO * pinst);
LONG      NEAR PASCAL About(INSTINFO * pinst, HWND hwnd);
#define QueryConfigure(x)  (TRUE)
//BOOL    NEAR PASCAL QueryConfigure(INSTINFO * pinst);
LONG      NEAR PASCAL Configure(INSTINFO * pinst, HWND hwnd);

LONG      FAR PASCAL CompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
LONG      FAR PASCAL CompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn,LPBITMAPINFOHEADER lpbiOut);
LONG      FAR PASCAL CompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
LONG      FAR PASCAL Compress(INSTINFO * pinst,ICCOMPRESS FAR *icinfo, DWORD dwSize);
LONG      FAR PASCAL CompressGetSize(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
LONG      FAR PASCAL CompressEnd(INSTINFO * lpinst);

LONG      NEAR PASCAL DecompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
LONG      NEAR PASCAL DecompressGetPalette(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
LONG      NEAR PASCAL DecompressBegin(INSTINFO * pinst, DWORD dwFlags, LPBITMAPINFOHEADER lpbiSrc, LPVOID pSrc, int xSrc, int ySrc, int dxSrc, int dySrc, LPBITMAPINFOHEADER lpbiDst, LPVOID pDst, int xDst, int yDst, int dxDst, int dyDst);
LONG      NEAR PASCAL DecompressQuery(INSTINFO * pinst, DWORD dwFlags, LPBITMAPINFOHEADER lpbiSrc, LPVOID pSrc, int xSrc, int ySrc, int dxSrc, int dySrc, LPBITMAPINFOHEADER lpbiDst, LPVOID pDst, int xDst, int yDst, int dxDst, int dyDst);
LONG      NEAR PASCAL Decompress(INSTINFO * pinst, DWORD dwFlags, LPBITMAPINFOHEADER lpbiSrc, LPVOID pSrc, int xSrc, int ySrc, int dxSrc, int dySrc, LPBITMAPINFOHEADER lpbiDst, LPVOID pDst, int xDst, int yDst, int dxDst, int dyDst);
LONG      NEAR PASCAL DecompressEnd(INSTINFO * pinst);

LONG      NEAR PASCAL DrawQuery(INSTINFO * pinst,ICDRAWBEGIN FAR *icinfo, DWORD dwSize);
LONG      NEAR PASCAL DrawBegin(INSTINFO * pinst,ICDRAWBEGIN FAR *icinfo, DWORD dwSize);
LONG      NEAR PASCAL Draw(INSTINFO * pinst,ICDRAW FAR *icinfo, DWORD dwSize);
LONG      NEAR PASCAL DrawEnd(INSTINFO * pinst);

#ifdef DEBUG
    extern void FAR CDECL dprintf(LPSTR, ...);
    // Allow DPF statements to span multiple lines
    #define DPF( _x_ ) dprintf _x_
#else
    #define DPF(x)
#endif

#ifdef DEBUG
	/* Assert() macros */
	#define Assert(expr)		 _Assert((expr), __FILE__, __LINE__)
	#define AssertEval(expr)	 _Assert((expr), __FILE__, __LINE__)

	/* prototypes */
	BOOL FAR PASCAL _Assert(BOOL fExpr, LPSTR szFile, int iLine);

#else
	/* Assert() macros */
	#define Assert(expr)		 (TRUE)
	#define AssertEval(expr)	 (expr)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvidc\msvidc.c ===
/*----------------------------------------------------------------------+
| msvidc.c - Microsoft Video 1 Compressor                               |
|                                                                       |
| Copyright (c) 1990-1995 Microsoft Corporation.                        |
| Portions Copyright Media Vision Inc.                                  |
| All Rights Reserved.                                                  |
|                                                                       |
| You have a non-exclusive, worldwide, royalty-free, and perpetual      |
| license to use this source code in developing hardware, software      |
| (limited to drivers and other software required for hardware          |
| functionality), and firmware for video display and/or processing      |
| boards.   Microsoft makes no warranties, express or implied, with     |
| respect to the Video 1 codec, including without limitation warranties |
| of merchantability or fitness for a particular purpose.  Microsoft    |
| shall not be liable for any damages whatsoever, including without     |
| limitation consequential damages arising from your use of the Video 1 |
| codec.                                                                |
|                                                                       |
|                                                                       |
+----------------------------------------------------------------------*/
#include <win32.h>
#include <ole2.h>
#include <mmsystem.h>

#ifndef _INC_COMPDDK
#define _INC_COMPDDK    50      /* version number */
#endif

#include <vfw.h>

#ifdef _WIN32
#define abs(x)  ((x) < 0 ? -(x) : (x))
#endif

#ifdef _WIN32
#include <memory.h>     /* for memcpy */
#endif


#ifdef _WIN32
#define _FPInit()       0
#define _FPTerm(x)
#else
void _acrtused2(void) {}
extern LPVOID WINAPI _FPInit(void);
extern void   WINAPI _FPTerm(LPVOID);
#endif

#include "msvidc.h"
#ifdef _WIN32
#include "profile.h"
#endif

#ifndef _WIN32
static BOOL gf286 = FALSE;
#endif

#define FOURCC_MSVC     mmioFOURCC('M','S','V','C')
#define FOURCC_CRAM     mmioFOURCC('C','R','A','M')
#define FOURCC_Cram     mmioFOURCC('C','r','a','m')
#define TWOCC_XX        aviTWOCC('d', 'c')

#define QUALITY_DEFAULT 2500

#define VERSION         0x00010000      // 1.0

ICSTATE   DefaultState = {75};

INT_PTR FAR PASCAL _LOADDS ConfigureDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam);

#ifndef _WIN32
//
// put the compress stuff in the "rare" segment
//
#pragma alloc_text(_TEXT, ConfigureDlgProc)
#pragma alloc_text(_TEXT, CompressBegin)
#pragma alloc_text(_TEXT, CompressQuery)
#pragma alloc_text(_TEXT, CompressGetFormat)
#pragma alloc_text(_TEXT, Compress)
#pragma alloc_text(_TEXT, CompressGetSize)
#pragma alloc_text(_TEXT, CompressEnd)
#endif

/*****************************************************************************
 * dither stuff..
 ****************************************************************************/

#include <dith775.h>

LPVOID lpDitherTable;

//////////////////////////////////////////////////////////////////////////////
//
//  Dither16InitScale()
//
//////////////////////////////////////////////////////////////////////////////

#pragma optimize("", off)
STATICFN LPVOID Dither16InitScale()
{
    LPVOID p;
    LPBYTE pbLookup;
    LPWORD pwScale;
    UINT   r,g,b;

    p = GlobalAllocPtr(GMEM_MOVEABLE|GMEM_SHARE, 32768l*2+64000);

    if (p == NULL)
        return NULL;

    pwScale  = (LPWORD)p;

    for (r=0; r<32; r++)
        for (g=0; g<32; g++)
            for (b=0; b<32; b++)
                *pwScale++ = 1600 * r + 40 * g + b;

    pbLookup = (LPBYTE)(((WORD _huge *)p) + 32768l);

    for (r=0; r<40; r++)
        for (g=0; g<40; g++)
            for (b=0; b<40; b++)
                *pbLookup++ = lookup775[35*rlevel[r] + 5*glevel[g] + blevel[b]];

    return p;
}
#pragma optimize("", on)

/*****************************************************************************
 ****************************************************************************/
#ifndef _WIN32
BOOL NEAR PASCAL VideoLoad(void)
{
    gf286 = (BOOL)(GetWinFlags() & WF_CPU286);

#ifdef DEBUG
    gf286 = GetProfileIntA("Debug", "cpu", gf286 ? 286 : 386) == 286;
#endif

    return TRUE;
}
#endif

/*****************************************************************************
 ****************************************************************************/
void NEAR PASCAL VideoFree()
{
    // CompressFrameFree();        // let compression stuff clean up...

    if (lpDitherTable != NULL) {
        GlobalFreePtr(lpDitherTable);
        lpDitherTable = NULL;
    }
}

/*****************************************************************************
 ****************************************************************************/
INSTINFO * NEAR PASCAL VideoOpen(ICOPEN FAR * icinfo)
{
    INSTINFO *  pinst;

    //
    // refuse to open if we are not being opened as a Video compressor
    //
    if (icinfo->fccType != ICTYPE_VIDEO)
        return NULL;

    pinst = (INSTINFO *)LocalAlloc(LPTR, sizeof(INSTINFO));

    if (!pinst) {
        icinfo->dwError = (DWORD)ICERR_MEMORY;
        return NULL;
    }

    //
    // init structure
    //
    pinst->dwFlags = icinfo->dwFlags;
    pinst->nCompress = 0;
    pinst->nDecompress = 0;
    pinst->nDraw = 0;

    //
    // set the default state.
    //
    SetState(pinst, NULL, 0);

    //
    // return success.
    //
    icinfo->dwError = ICERR_OK;

    return pinst;
}

/*****************************************************************************
 ****************************************************************************/
LONG NEAR PASCAL VideoClose(INSTINFO * pinst)
{
    while (pinst->nCompress > 0)
        CompressEnd(pinst);

    while (pinst->nDecompress > 0)
        DecompressEnd(pinst);

    while (pinst->nDraw > 0)
        DrawEnd(pinst);

    LocalFree((HLOCAL)pinst);

    return 1;
}

/*****************************************************************************
 ****************************************************************************/

#ifndef QueryAbout
BOOL NEAR PASCAL QueryAbout(INSTINFO * pinst)
{
    return TRUE;
}
#endif

LONG NEAR PASCAL About(INSTINFO * pinst, HWND hwnd)
{
    char achDescription[128];
    char achAbout[64];

    LoadStringA(ghModule, IDS_DESCRIPTION, achDescription, sizeof(achDescription));
    LoadStringA(ghModule, IDS_ABOUT, achAbout, sizeof(achAbout));

    MessageBoxA(hwnd,achDescription,achAbout,
    MB_OK|MB_ICONINFORMATION);
    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
#ifndef QueryConfigure
BOOL NEAR PASCAL QueryConfigure(INSTINFO * pinst)
{
    return TRUE;
}
#endif

LONG NEAR PASCAL Configure(INSTINFO * pinst, HWND hwnd)
{
    return (LONG) DialogBoxParam(ghModule,TEXT("Configure"),hwnd,ConfigureDlgProc, (LONG_PTR)(UINT_PTR)pinst);
}

/*****************************************************************************
 ****************************************************************************/
LONG NEAR PASCAL GetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize)
{
    if (pv == NULL || dwSize == 0)
        return sizeof(ICSTATE);

    if (dwSize < sizeof(ICSTATE))
        return 0;

    *((ICSTATE FAR *)pv) = pinst->CurrentState;

    // return number of bytes copied
    return sizeof(ICSTATE);
}

/*****************************************************************************
 ****************************************************************************/
LONG NEAR PASCAL SetState(INSTINFO * pinst, LPVOID pv, DWORD dwSize)
{
    if (pv == NULL)
        pinst->CurrentState = DefaultState;
    else if (dwSize == sizeof(ICSTATE))
        pinst->CurrentState = *((ICSTATE FAR *)pv);
    else
        return 0;

    // return number of bytes copied
    return sizeof(ICSTATE);
}

#if !defined NUMELMS
 #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

#if defined _WIN32 && !defined UNICODE

int LoadUnicodeString(HINSTANCE hinst, UINT wID, LPWSTR lpBuffer, int cchBuffer)
{
    char    ach[128];
    int     i;

    i = LoadString(hinst, wID, ach, sizeof(ach));

    if (i > 0)
        MultiByteToWideChar(CP_ACP, 0, ach, -1, lpBuffer, cchBuffer);

    return i;
}

#else
#define LoadUnicodeString   LoadString
#endif

/*****************************************************************************
 ****************************************************************************/
LONG NEAR PASCAL GetInfo(INSTINFO * pinst, ICINFO FAR *icinfo, DWORD dwSize)
{
    if (icinfo == NULL)
        return sizeof(ICINFO);

    if (dwSize < sizeof(ICINFO))
        return 0;

    icinfo->dwSize            = sizeof(ICINFO);
    icinfo->fccType           = ICTYPE_VIDEO;
    icinfo->fccHandler        = FOURCC_MSVC;
    icinfo->dwFlags           = VIDCF_QUALITY   |  // supports quality
                                VIDCF_TEMPORAL;    // supports inter-frame
    icinfo->dwVersion         = VERSION;
    icinfo->dwVersionICM      = ICVERSION;

    LoadUnicodeString(ghModule, IDS_DESCRIPTION, icinfo->szDescription, NUMELMS(icinfo->szDescription));
    LoadUnicodeString(ghModule, IDS_NAME, icinfo->szName, NUMELMS(icinfo->szName));

    return sizeof(ICINFO);
}

/*****************************************************************************
 ****************************************************************************/
LONG FAR PASCAL CompressQuery(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    if (lpbiOut)
         DPF(("CompressQuery %dx%dx%d --> %dx%dx%d'%4.4hs'", (int)lpbiIn->biWidth, (int)lpbiIn->biHeight, (int)lpbiIn->biBitCount, (int)lpbiOut->biWidth, (int)lpbiOut->biHeight, (int)lpbiOut->biBitCount, (LPSTR)&lpbiOut->biCompression));
    else
        DPF(("CompressQuery %dx%dx%d", (int)lpbiIn->biWidth, (int)lpbiIn->biHeight, (int)lpbiIn->biBitCount));

    //
    // determine if the input DIB data is in a format we like.
    //
    if (lpbiIn == NULL ||
        !(lpbiIn->biBitCount == 8  ||
          lpbiIn->biBitCount == 16 ||
          lpbiIn->biBitCount == 24 ||
          lpbiIn->biBitCount == 32) ||
        lpbiIn->biPlanes != 1 ||
        lpbiIn->biWidth < 4 ||
        lpbiIn->biHeight < 4 ||
        lpbiIn->biCompression != BI_RGB)
        return ICERR_BADFORMAT;

    //
    //  are we being asked to query just the input format?
    //
    if (lpbiOut == NULL)
        return ICERR_OK;

    //
    // make sure we can handle the format to compress to also.
    //
    if (!(lpbiOut->biCompression == FOURCC_MSVC ||  // must be 'MSVC' or 'CRAM'
          lpbiOut->biCompression == FOURCC_CRAM) ||
        !(lpbiOut->biBitCount == 16 ||              // must be 8 or 16
          lpbiOut->biBitCount == 8) ||
        (lpbiOut->biPlanes != 1) ||
        (lpbiOut->biWidth & ~3)  != (lpbiIn->biWidth & ~3)   || // must be 1:1 (no stretch)
        (lpbiOut->biHeight & ~3) != (lpbiIn->biHeight & ~3))
        return ICERR_BADFORMAT;

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
LONG FAR PASCAL CompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    LONG l;

    if (l = CompressQuery(pinst, lpbiIn, NULL))
        return l;

    if (lpbiIn->biBitCount == 8)
    {
        //
        // if lpbiOut == NULL then, return the size required to hold a output
        // format
        //

        DWORD dwClrUsed = lpbiIn->biClrUsed;
        if (dwClrUsed == 0) {
            dwClrUsed = 256;
        }
        l = lpbiIn->biSize + (int)dwClrUsed * sizeof(RGBQUAD);

        if (lpbiOut == NULL)
            return l;

        hmemcpy(lpbiOut, lpbiIn, (int)l);

        lpbiOut->biBitCount    = 8;
    }
    else
    {
        //
        // if lpbiOut == NULL then, return the size required to hold a output
        // format
        //
        if (lpbiOut == NULL)
            return (int)lpbiIn->biSize;

        *lpbiOut = *lpbiIn;

        lpbiOut->biClrUsed     = 0;
        lpbiOut->biBitCount    = 16;
    }

    lpbiOut->biWidth       = lpbiIn->biWidth  & ~3;
    lpbiOut->biHeight      = lpbiIn->biHeight & ~3;
    lpbiOut->biCompression = FOURCC_CRAM;
    lpbiOut->biSizeImage   = CompressGetSize(pinst, lpbiIn, lpbiOut);

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/

LONG FAR PASCAL CompressBegin(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    LONG l;

    if (l = CompressQuery(pinst, lpbiIn, lpbiOut))
        return l;

    DPF(("CompressBegin %dx%dx%d --> %dx%dx%d'%4.4ls'", (int)lpbiIn->biWidth, (int)lpbiIn->biHeight, (int)lpbiIn->biBitCount, (int)lpbiOut->biWidth, (int)lpbiOut->biHeight, (int)lpbiOut->biBitCount,(LPSTR)&lpbiOut->biCompression));

    //
    // initialize for compression, for real....
    //
    pinst->nCompress = 1;

    return CompressFrameBegin(lpbiIn, lpbiOut, &pinst->lpITable, pinst->rgbqOut);
}

/*****************************************************************************
 ****************************************************************************/
LONG FAR PASCAL CompressGetSize(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    int dx,dy;

    dx = (int)lpbiIn->biWidth;
    dy = (int)lpbiIn->biHeight;

    /* maximum compressed size *** your code here *** */

    if (lpbiOut->biBitCount == 8)
        // worst case size of data 10 bytes per 16 pixels (8 colors + mask)
        // remember the EOF code!
        return ((DWORD)dx * (DWORD)dy * 10l) / 16l + 2l;
    else
        // worst case size of data 18 bytes per 16 pixels (8 colors + mask)
        // remember the EOF code!
        return ((DWORD)dx * (DWORD)dy * 10l) / 8l + 2l; // 10/8 ~= 18/16
////////return ((DWORD)dx * (DWORD)dy * 18l) / 16l + 2l;
}

/*****************************************************************************
 ****************************************************************************/
LONG FAR PASCAL Compress(INSTINFO * pinst, ICCOMPRESS FAR *icinfo, DWORD dwSize)
{
    LONG l;
    LPBITMAPINFOHEADER lpbiIn  = icinfo->lpbiInput;
    LPBITMAPINFOHEADER lpbiOut = icinfo->lpbiOutput;
    DWORD threshold;
    DWORD thresholdPrev;
    DWORD dwQualityPrev;
    DWORD dwQuality;
    BOOL  fBegin;
    LPVOID smag;
    PCELLS compressTemp;

    if (l = CompressQuery(pinst, icinfo->lpbiInput, icinfo->lpbiOutput))
        return l;

    //
    // check for being called without a BEGIN message, and do the begin for
    // the caller
    //
    if (fBegin = (pinst->nCompress == 0))
    {
        if (l = CompressBegin(pinst, icinfo->lpbiInput, icinfo->lpbiOutput))
            return l;
    }

    smag = _FPInit();

    DPF(("Compress %dx%dx%d --> %dx%dx%d'%4.4ls'", (int)lpbiIn->biWidth, (int)lpbiIn->biHeight, (int)lpbiIn->biBitCount, (int)lpbiOut->biWidth, (int)lpbiOut->biHeight, (int)lpbiOut->biBitCount, (LPSTR)&lpbiOut->biCompression));

    if (icinfo->dwQuality == ICQUALITY_DEFAULT)
        dwQuality = QUALITY_DEFAULT;
    else
        dwQuality = ICQUALITY_HIGH - icinfo->dwQuality;

    dwQualityPrev = MulDiv((UINT)dwQuality,100,pinst->CurrentState.wTemporalRatio);

    threshold     = QualityToThreshold(dwQuality);
    thresholdPrev = QualityToThreshold(dwQualityPrev);

    if (pinst->Status)
        pinst->Status(pinst->lParam, ICSTATUS_START, 0);

    // For Win16, this needs to be in the data segment so we
    // can use a near pointer to it.
    compressTemp = (PCELLS) LocalAlloc(LPTR, sizeof(CELLS));

    if (!compressTemp)
        return ICERR_MEMORY;

    if (lpbiOut->biBitCount == 8)
        l = CompressFrame8(
                  icinfo->lpbiInput,        // DIB header to compress
                  icinfo->lpInput,          // DIB bits to compress
                  icinfo->lpOutput,         // put compressed data here
                  threshold,                // edge threshold
                  thresholdPrev,            // inter-frame threshold
                  icinfo->lpbiPrev,         // previous frame
                  icinfo->lpPrev,           // previous frame
                  pinst->Status,            // status callback
                  pinst->lParam,
                  compressTemp,
                  pinst->lpITable,
                  pinst->rgbqOut);
    else
        l = CompressFrame16(
                  icinfo->lpbiInput,        // DIB header to compress
                  icinfo->lpInput,          // DIB bits to compress
                  icinfo->lpOutput,         // put compressed data here
                  threshold,                // edge threshold
                  thresholdPrev,            // inter-frame threshold
                  icinfo->lpbiPrev,         // previous frame
                  icinfo->lpPrev,           // previous frame
                  pinst->Status,            // status callback
                  pinst->lParam,
                  compressTemp);

    LocalFree((HLOCAL) compressTemp);

    if (pinst->Status)
        pinst->Status(pinst->lParam, ICSTATUS_END, 0);

    _FPTerm(smag);

    if (l == -1)
        return ICERR_ERROR;

    lpbiOut->biWidth       = lpbiIn->biWidth  & ~3;
    lpbiOut->biHeight      = lpbiIn->biHeight & ~3;
    lpbiOut->biCompression = FOURCC_CRAM;
    lpbiOut->biSizeImage   = l;
////lpbiOut->biBitCount    = 16;

    //
    // return the chunk id
    //
    if (icinfo->lpckid)
        *icinfo->lpckid = TWOCC_XX;

    //
    // set the AVI index flags,
    //
    //    make it a keyframe?
    //
    if (icinfo->lpdwFlags) {
        *icinfo->lpdwFlags = AVIIF_TWOCC;

        if (icinfo->lpbiPrev == NULL || numberOfSkips == 0)
            *icinfo->lpdwFlags |= AVIIF_KEYFRAME;
    }

    if (fBegin)
        CompressEnd(pinst);

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
LONG FAR PASCAL CompressEnd(INSTINFO * pinst)
{
    if (pinst->nCompress == 0)
        return ICERR_ERROR;

    pinst->nCompress = 0;

    return CompressFrameEnd(&pinst->lpITable);
}

/*****************************************************************************
 *
 *  decompress tables
 *
 *      indexed by:
 *          SRC:     0=8 bit Cram 1=16 bit Cram
 *          STRETCH: 0=1:1, 1=1:2
 *          DST:     0=8, 1=16, 2=24, 3=32
 *
 ****************************************************************************/

#ifdef _WIN32

DECOMPPROC  DecompressWin32[2][2][5] = {
        DecompressFrame8,               // Cram8  1:1 to 8
        NULL,                           // Cram8  1:1 to 16 (555)
        NULL,                           // Cram8  1:1 to 24
        NULL,                           // Cram8  1:1 to 32
        NULL,                           // Cram8  1:1 to 565

        DecompressFrame8X2C,            // Cram8  1:2 to 8
        NULL,                           // Cram8  1:2 to 16 (555)
        NULL,                           // Cram8  1:2 to 24
        NULL,                           // Cram8  1:2 to 32
        NULL,                           // Cram8  1:2 to 565

        DecompressFrame16To8C,          // Cram16 1:1 to 8
        DecompressFrame16To555C,        // Cram16 1:1 to 16 (555)
        DecompressFrame24,              // Cram16 1:1 to 24
        NULL,                           // Cram16 1:1 to 32
        DecompressFrame16To565C,        // Cram16 1:1 to 565

        DecompressFrame16To8X2C,        // Cram16 1:2 to 8
        NULL,                           // Cram16 1:2 to 16 (555)
        NULL,                           // Cram16 1:2 to 24
        NULL,                           // Cram16 1:2 to 32
        NULL};                          // Cram16 1:2 to 565

#else

DECOMPPROC  Decompress386[2][2][5] = {
        DecompressCram8,                // Cram8  1:1 to 8
        NULL,                           // Cram8  1:1 to 16 (555)
        NULL,                           // Cram8  1:1 to 24
        NULL,                           // Cram8  1:1 to 32
        NULL,                           // Cram8  1:1 to 565

        DecompressCram8x2,              // Cram8  1:2 to 8
        NULL,                           // Cram8  1:2 to 16 (555)
        NULL,                           // Cram8  1:2 to 24
        NULL,                           // Cram8  1:2 to 32
        NULL,                           // Cram8  1:2 to 565

        DecompressCram168,              // Cram16 1:1 to 8
        DecompressCram16,               // Cram16 1:1 to 16 (555)
        NULL,                           // Cram16 1:1 to 24
        NULL /* DecompressCram32 */,    // Cram16 1:1 to 32
        NULL /* DecompressFrame16To565C */,     // Cram16 1:1 to 565

        NULL,                           // Cram16 1:2 to 8
        DecompressCram16x2,             // Cram16 1:2 to 16 (555)
        NULL,                           // Cram16 1:2 to 24
        NULL,                           // Cram16 1:2 to 32
        NULL};                          // Cram16 1:2 to 565


DECOMPPROC  Decompress286[2][2][5] = {
        DecompressCram8_286,            // Cram8  1:1 to 8
        NULL,                           // Cram8  1:1 to 16 (555)
        NULL,                           // Cram8  1:1 to 24
        NULL,                           // Cram8  1:1 to 32
        NULL,                           // Cram8  1:1 to 565

        NULL,                           // Cram8  1:2 to 8
        NULL,                           // Cram8  1:2 to 16 (555)
        NULL,                           // Cram8  1:2 to 24
        NULL,                           // Cram8  1:2 to 32
        NULL,                           // Cram8  1:2 to 565

        NULL,                           // Cram16 1:1 to 8
        DecompressCram16_286,           // Cram16 1:1 to 16 (555)
        NULL,                           // Cram16 1:1 to 24
        NULL,                           // Cram16 1:1 to 32
        NULL,                           // Cram16 1:1 to 565

        NULL,                           // Cram16 1:2 to 8
        NULL,                           // Cram16 1:2 to 16 (555)
        NULL,                           // Cram16 1:2 to 24
        NULL,                           // Cram16 1:2 to 32
        NULL};                          // Cram16 1:2 to 565
#endif

/*****************************************************************************
 ****************************************************************************/
LONG NEAR PASCAL DecompressQueryFmt(
    INSTINFO * pinst,
    LPBITMAPINFOHEADER lpbiSrc)
{
    //
    // determine if the input DIB data is in a format we like.
    //
    if (lpbiSrc == NULL ||
        !(lpbiSrc->biBitCount == 16 || lpbiSrc->biBitCount == 8) ||
        (lpbiSrc->biPlanes != 1) ||
        !(lpbiSrc->biCompression == FOURCC_MSVC ||
          lpbiSrc->biCompression == FOURCC_CRAM))
        return ICERR_BADFORMAT;

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
LONG NEAR PASCAL DecompressQuery(
    INSTINFO * pinst,
    DWORD dwFlags,
    LPBITMAPINFOHEADER lpbiSrc,
    LPVOID pSrc,
    int xSrc,
    int ySrc,
    int dxSrc,
    int dySrc,
    LPBITMAPINFOHEADER lpbiDst,
    LPVOID pDst,
    int xDst,
    int yDst,
    int dxDst,
    int dyDst)
{
#ifndef _WIN32
    DWORD biSizeImage;
#endif
    DECOMPPROC fn;
    int s,d,n;

    //
    // determine if the input DIB data is in a format we like.
    //
    if (DecompressQueryFmt(pinst, lpbiSrc))
        return ICERR_BADFORMAT;

    //
    // allow (-1) as a default width/height
    //
    if (dxSrc == -1)
        dxSrc = (int)lpbiSrc->biWidth;

    if (dySrc == -1)
        dySrc = (int)lpbiSrc->biHeight;

    //
    //  we cant clip the source.
    //
    if (xSrc != 0 || ySrc != 0)
        return ICERR_BADPARAM;

    if ((dxSrc != (int)lpbiSrc->biWidth) || (dySrc != (int)lpbiSrc->biHeight))
        return ICERR_BADPARAM;

    //
    //  are we being asked to query just the input format?
    //
    if (lpbiDst == NULL)
        return ICERR_OK;

    //
    // allow (-1) as a default width/height
    //
    if (dxDst == -1)
        dxDst = (int)lpbiDst->biWidth;

    if (dyDst == -1)
        dyDst = abs((int)lpbiDst->biHeight);

#ifndef _WIN32
    if (gf286)
        biSizeImage = (DWORD)(UINT)abs((int)lpbiDst->biHeight)*(DWORD)(WORD)DIBWIDTHBYTES(*lpbiDst);
#endif

    s = lpbiSrc->biBitCount/8-1;    //  s = 0,1

#ifdef _WIN32
    // Can't support 16:32 access in our C version, of course....
    if (lpbiDst->biCompression == BI_1632) {
        return ICERR_BADFORMAT;
    }
#endif

    if (lpbiDst->biBitCount != 8 && lpbiDst->biBitCount != 16 && lpbiDst->biBitCount != 24 && lpbiDst->biBitCount != 32)
    {
        return ICERR_BADFORMAT;
    }

    // must be full dib or a '1632' DIB
    if (lpbiDst->biCompression != BI_RGB &&
        lpbiDst->biCompression != BI_1632) {
	    if (lpbiDst->biCompression != BI_BITFIELDS) {
		DPF(("MSVIDC asked to decompress to '%.4hs'!", &lpbiDst->biCompression));
		return ICERR_BADFORMAT;
	    }
	
            // allow 565 dibs
            if ((lpbiDst->biBitCount == 16) &&
                (((LPDWORD)(lpbiDst+1))[0] == 0x00f800) &&
                (((LPDWORD)(lpbiDst+1))[1] == 0x0007e0) &&
                (((LPDWORD)(lpbiDst+1))[2] == 0x00001f) ) {

                    // ok - its 565 format
                    d = 4;
            } else {
                DPF(("Bad bitmask (%lX %lX %lX) in %d-bit BI_BITMAP case!",
                     lpbiDst->biBitCount,
                     ((LPDWORD)(lpbiDst+1))[0],
                     ((LPDWORD)(lpbiDst+1))[1],
                     ((LPDWORD)(lpbiDst+1))[2]));
                return ICERR_BADFORMAT;
            }
    } else {
        d = lpbiDst->biBitCount/8-1;    //  d = 0,1,2,3

        if (lpbiDst->biCompression == BI_1632 && lpbiDst->biBitCount == 16) {

            if ((((LPDWORD)(lpbiDst+1))[0] == 0x007400) &&
                (((LPDWORD)(lpbiDst+1))[1] == 0x0003f0) &&
                (((LPDWORD)(lpbiDst+1))[2] == 0x00000f) ) {
                    // ok - it's 555 format
            } else if ((((LPDWORD)(lpbiDst+1))[0] == 0x00f800) &&
                (((LPDWORD)(lpbiDst+1))[1] == 0x0007e0) &&
                (((LPDWORD)(lpbiDst+1))[2] == 0x00001f) ) {

                    // ok - it's 565 format
                    d = 4;
            } else {
                DPF(("Bad bitmask (%lX %lX %lX) in 16-bit BI_1632 case!",
                     ((LPDWORD)(lpbiDst+1))[0],
                     ((LPDWORD)(lpbiDst+1))[1],
                     ((LPDWORD)(lpbiDst+1))[2]));
                return ICERR_BADFORMAT;
            }
        }

        // What about 24-bit BI_1632?  Should we check the masks?
    }

    //
    //  n = 0 for 1:1, 1 for 1:2
    //
    if (dxDst  == dxSrc && dyDst == dySrc)
        n = 0;
    else if (dxDst == dxSrc*2 && dyDst == dySrc*2)
        n = 1;
    else
        return ICERR_BADSIZE;

#ifdef DEBUG
    DPF(("DecompressQuery %dx%dx%d [%d,%d,%d,%d] --> %dx%dx%d (565) [%d,%d,%d,%d]",
        (int)lpbiSrc->biWidth, (int)lpbiSrc->biHeight, (int)lpbiSrc->biBitCount,
        xSrc, ySrc, dxSrc, dySrc,
        (int)lpbiDst->biWidth, (int)lpbiDst->biHeight, (int)lpbiDst->biBitCount,
        d == 4 ? "(565)" : "",
        xDst, yDst, dxDst, dyDst));

#endif

#ifdef _WIN32
    fn = DecompressWin32[s][n][d];
#else
    if (gf286)
    {
        fn = Decompress286[s][n][d];

        if (fn && biSizeImage > 64l*1024)
            fn = fn==DecompressCram8_286 ? DecompressFrame8 : NULL;
    }
    else
    {
        fn = Decompress386[s][n][d];
    }
#endif

    if (fn == NULL)
        return ICERR_BADFORMAT;

    pinst->DecompressTest = fn;     // return this to DecompressBegin.

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
LONG NEAR PASCAL DecompressGetFormat(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    LONG l;
    int dx,dy;

    if (l = DecompressQueryFmt(pinst, lpbiIn))
        return l;

    //
    // if lpbiOut == NULL then, return the size required to hold a output
    // format
    //
    if (lpbiOut == NULL)
        return (int)lpbiIn->biSize + (int)lpbiIn->biClrUsed * sizeof(RGBQUAD);

    hmemcpy(lpbiOut, lpbiIn,
        (int)lpbiIn->biSize + (int)lpbiIn->biClrUsed * sizeof(RGBQUAD));

    dx = (int)lpbiIn->biWidth & ~3;
    dy = (int)lpbiIn->biHeight & ~3;

    lpbiOut->biWidth       = dx;
    lpbiOut->biHeight      = dy;
    lpbiOut->biBitCount    = lpbiIn->biBitCount;    // convert 8->8 16->16
    lpbiOut->biPlanes      = 1;

    lpbiOut->biCompression = BI_RGB;
    lpbiOut->biSizeImage   = (DWORD)(WORD)abs(dy)*(DWORD)(WORD)DIBWIDTHBYTES(*lpbiOut);

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
LONG NEAR PASCAL DecompressBegin(
    INSTINFO * pinst,
    DWORD dwFlags,
    LPBITMAPINFOHEADER lpbiSrc,
    LPVOID pSrc,
    int xSrc,
    int ySrc,
    int dxSrc,
    int dySrc,
    LPBITMAPINFOHEADER lpbiDst,
    LPVOID pDst,
    int xDst,
    int yDst,
    int dxDst,
    int dyDst)
{
    LONG l;

    if (l = DecompressQuery(pinst, dwFlags, lpbiSrc, pSrc, xSrc, ySrc, dxSrc, dySrc, lpbiDst, pDst, xDst, yDst, dxDst, dyDst))
        return l;

    pinst->DecompressProc = pinst->DecompressTest;

    //
    //  make sure biSizeImage is set, the decompress code needs it to be
    //
    if (lpbiDst->biSizeImage == 0)
        lpbiDst->biSizeImage = (DWORD)(WORD)abs((int)lpbiDst->biHeight)*(DWORD)(WORD)DIBWIDTHBYTES(*lpbiDst);

    //
    // init the dither tables !!! call MSVIDEO, dont have code here!!!
    //
    if (lpbiSrc->biBitCount == 16 &&
        lpbiDst->biBitCount == 8)
    {
        if (lpDitherTable == NULL)
            lpDitherTable = Dither16InitScale();

        if (lpDitherTable == NULL)
            return ICERR_MEMORY;
    }

    pinst->nDecompress = 1;

    return ICERR_OK;
}

/*****************************************************************************
 *
 *  Decompress
 *
 *  we can assume certain things here because DecompressQuery() only lets
 *  valid stuff in.
 *
 *      the source rect is always the entire source.
 *      the dest rect is either 1:1 or 1:2
 *
 ****************************************************************************/
LONG NEAR PASCAL Decompress(
    INSTINFO * pinst,
    DWORD dwFlags,
    LPBITMAPINFOHEADER lpbiSrc,
    LPVOID pSrc,
    int xSrc,
    int ySrc,
    int dxSrc,
    int dySrc,
    LPBITMAPINFOHEADER lpbiDst,
    LPVOID pDst,
    int xDst,
    int yDst,
    int dxDst,
    int dyDst)
{
    //
    //  if we are called without a begin do the begin now, but dont make
    //  the begin "stick"
    //
    if (pinst->nDecompress == 0)
    {
        LONG err;

        if (err = DecompressBegin(pinst, dwFlags, lpbiSrc, pSrc, xSrc, ySrc, dxSrc, dySrc, lpbiDst, pDst, xDst, yDst, dxDst, dyDst))
            return err;

        pinst->nDecompress = 0;
    }

#ifdef DEBUG
    if (lpbiDst->biSizeImage == 0)
        DebugBreak();

    if (pinst->DecompressProc == NULL)
        DebugBreak();
#endif

    (*pinst->DecompressProc)(lpbiSrc,pSrc,lpbiDst,pDst,xDst,yDst);

    return ICERR_OK;
}

/*****************************************************************************
 *
 * DecompressGetPalette() implements ICM_GET_PALETTE
 *
 * This function has no Compress...() equivalent
 *
 * It is used to pull the palette from a frame in order to possibly do
 * a palette change.
 *
 ****************************************************************************/
LONG NEAR PASCAL DecompressGetPalette(INSTINFO * pinst, LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut)
{
    LONG l;
    int i;
    RGBQUAD FAR * prgb;

    DPF(("DecompressGetPalette()"));

    if (l = DecompressQueryFmt(pinst, lpbiIn))
        return l;

    if (lpbiOut->biBitCount != 8)
        return ICERR_BADFORMAT;

    //
    // if you decompress full-color to 8 bit you need to put the "dither"
    // palette in lpbiOut
    //
    if (lpbiIn->biBitCount != 8)
    {
        lpbiOut->biClrUsed = 256;

        prgb = (LPVOID)(lpbiOut + 1);

        for (i=0; i<256; i++)
        {
            prgb[i].rgbRed      = dpal775[i][0];
            prgb[i].rgbGreen    = dpal775[i][1];
            prgb[i].rgbBlue     = dpal775[i][2];
            prgb[i].rgbReserved = 0;
        }

        return ICERR_OK;
    }

    if (lpbiIn->biClrUsed == 0)
        lpbiIn->biClrUsed = 256;

    //
    // return the 8bit palette used for decompression.
    //
    hmemcpy(
        (LPBYTE)lpbiOut + (int)lpbiOut->biSize,
        (LPBYTE)lpbiIn + (int)lpbiIn->biSize,
        (int)lpbiIn->biClrUsed * sizeof(RGBQUAD));

    lpbiOut->biClrUsed = lpbiIn->biClrUsed;

    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
LONG NEAR PASCAL DecompressEnd(INSTINFO * pinst)
{
    if (pinst->nDecompress == 0)
        return ICERR_ERROR;

    pinst->nDecompress = 0;
    return ICERR_OK;
}

/*****************************************************************************
 ****************************************************************************/
LONG NEAR PASCAL DrawBegin(INSTINFO * pinst,ICDRAWBEGIN FAR *icinfo, DWORD dwSize)
{
    return ICERR_UNSUPPORTED;
}

/*****************************************************************************
 ****************************************************************************/
LONG NEAR PASCAL Draw(INSTINFO * pinst, ICDRAW FAR *icinfo, DWORD dwSize)
{
    return ICERR_UNSUPPORTED;
}

/*****************************************************************************
 ****************************************************************************/
LONG NEAR PASCAL DrawEnd(INSTINFO * pinst)
{
    return ICERR_UNSUPPORTED;
}

/*****************************************************************************
 ****************************************************************************/

INT_PTR FAR PASCAL _LOADDS ConfigureDlgProc(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    int     i;
    HWND    hsb;
    TCHAR   ach[10];
    static  TCHAR chDecimal = TEXT('.');

    static  INSTINFO *pinst;

    #define SCROLL_MIN  1       // 0.00
    #define SCROLL_MAX  100     // 1.00

    switch (msg)
    {
        case WM_COMMAND:
            switch (wParam)
            {
                case IDOK:
                    hsb = GetDlgItem(hdlg,ID_SCROLL);
                    pinst->CurrentState.wTemporalRatio = GetScrollPos(hsb,SB_CTL);
                    EndDialog(hdlg,TRUE);
                    break;

                case IDCANCEL:
                    EndDialog(hdlg,FALSE);
                    break;
            }
            break;

        case WM_HSCROLL:
            hsb = GET_WM_HSCROLL_HWND(wParam, lParam);

            i = GetScrollPos(hsb,SB_CTL);

            switch (GET_WM_HSCROLL_CODE(wParam, lParam))
            {
                case SB_LINEDOWN:      i += 1; break;
                case SB_LINEUP:        i -= 1; break;
                case SB_PAGEDOWN:      i += 10; break;
                case SB_PAGEUP:        i -= 10; break;

                case SB_THUMBTRACK:
                case SB_THUMBPOSITION:
                    i = (int)GET_WM_HSCROLL_POS(wParam, lParam);
                    break;

                default:
                    return TRUE;
            }

            i = max(SCROLL_MIN,min(SCROLL_MAX,i));
            SetScrollPos(hsb,SB_CTL,i,TRUE);
            wsprintf(ach, TEXT("%d%c%02d"), i/100, chDecimal, i%100);
            SetDlgItemText(hdlg,ID_TEXT,ach);
            return TRUE;

        case WM_INITDIALOG:
            pinst = (INSTINFO *)lParam;

            ach[0] = chDecimal;
            ach[1] = 0;
            GetProfileString(TEXT("intl"), TEXT("sDecimal"), ach, ach,
                             sizeof(ach) / sizeof(ach[0]));
            chDecimal = ach[0];

            hsb = GetDlgItem(hdlg,ID_SCROLL);
            i = pinst->CurrentState.wTemporalRatio;

            SetScrollRange(hsb,SB_CTL,SCROLL_MIN, SCROLL_MAX, TRUE);
            SetScrollPos(hsb,SB_CTL,i,TRUE);
            wsprintf(ach, TEXT("%d%c%02d"), i/100, chDecimal, i%100);
            SetDlgItemText(hdlg,ID_TEXT,ach);
            return TRUE;
    }
    return FALSE;
}

/*****************************************************************************
 ****************************************************************************/

#ifdef DEBUG

#define _WINDLL
#include <stdarg.h>
#ifdef _WIN32
#define GetProfileIntA  mmGetProfileIntA
#endif

void FAR CDECL dprintf(LPSTR szFormat, ...)
{
    char ach[128];
    static BOOL fDebug = -1;

    va_list va;
    va_start(va, szFormat);

    if (fDebug == -1)
        fDebug = GetProfileIntA("Debug", "MSVIDC", FALSE);

    if (!fDebug)
        return;

#ifdef _WIN32
    wsprintfA(ach, "MSVIDC32: (tid %x) ", GetCurrentThreadId());
    wvsprintfA(ach+strlen(ach),szFormat,va);
#else
    lstrcpyA(ach, "MSVIDC: ");
    wvsprintfA(ach+8,szFormat,va);
#endif
    lstrcatA(ach, "\r\n");

    OutputDebugStringA(ach);
    va_end(va);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvideo.16\debug.asm ===
;--------------------------------------------------------------------------

ifdef	DEBUG
	DEBUG_RETAIL equ 1
endif	; ifdef DEBUG

;--------------------------------------------------------------------------
	?PLM = 1
	?WIN = 0
	PMODE = 1

        .xlist
        include cmacros.inc
        include windows.inc
	include mmsystem.inc
;       include logerror.inc
	include mmddk.inc
        .list

;--------------------------------------------------------------------------

;/* Error modifier bits */

ERR_WARNING             equ 08000h
ERR_PARAM               equ 04000h

;/* Generic parameter values */
ERR_BAD_VALUE           equ 06001h
ERR_BAD_FLAGS           equ 06002h
ERR_BAD_INDEX           equ 06003h
ERR_BAD_DVALUE          equ 07004h
ERR_BAD_DFLAGS          equ 07005h
ERR_BAD_DINDEX          equ 07006h
ERR_BAD_PTR             equ 07007h
ERR_BAD_FUNC_PTR        equ 07008h
ERR_BAD_SELECTOR        equ 06009h
ERR_BAD_STRING_PTR      equ 0700ah
ERR_BAD_HANDLE          equ 0600bh

;/* KERNEL parameter errors */
ERR_BAD_HINSTANCE       equ 06020h
ERR_BAD_HMODULE         equ 06021h
ERR_BAD_GLOBAL_HANDLE   equ 06022h
ERR_BAD_LOCAL_HANDLE    equ 06023h
ERR_BAD_ATOM            equ 06024h
ERR_BAD_HFILE           equ 06025h

;/* USER parameter errors */
ERR_BAD_HWND            equ 06040h
ERR_BAD_HMENU           equ 06041h
ERR_BAD_HCURSOR         equ 06042h
ERR_BAD_HICON           equ 06043h
ERR_BAD_HDWP            equ 06044h
ERR_BAD_CID             equ 06045h
ERR_BAD_HDRVR           equ 06046h

DBF_TRACE           equ 00000h
DBF_WARNING         equ 04000h
DBF_ERROR           equ 08000h
DBF_FATAL           equ 0c000h

; [Windows] DebugFilter and flags values

DBF_KERNEL          equ 01000h
DBF_USER            equ 00800h
DBF_GDI             equ 00400h
DBF_MMSYSTEM        equ 00040h
DBF_PENWIN          equ 00020h
DBF_APPLICATION     equ 00010h
DBF_DRIVER          equ 00008h

;--------------------------------------------------------------------------

AssertF macro reg
        local   assert_ok
ifdef DEBUG
        or      reg,reg
        jnz     assert_ok
        int     3
assert_ok:
endif
        endm

AssertT macro reg
        local   assert_ok
ifdef DEBUG
        or      reg,reg
        jz      assert_ok
        int     3
assert_ok:
endif
        endm

;--------------------------------------------------------------------------
;
; DebugErr() macro
;
ifdef DEBUG_RETAIL

externFP    _DebugOutput        ; in KERNEL (3.1 or above)

DebugErr    macro   flags,msg
        local   a,b

        push    cs
        push    offset a
        push    flags or DBF_DRIVER
        call    _DebugOutput
        add     sp,6
        jmp     short b
a:
        db      "MSVIDEO: "
        db      msg
        db      13,10,0
b:
endm

else    ; DEBUG

DebugErr    macro   flags,msg
endm

endif   ; DEBUG

;--------------------------------------------------------------------------

; Define the return address as a type using the DefD macro in order to
; be able to pass it as a parameter to the LogParamError function.
ReturnAddr equ (dword ptr [bp+2])
DefD ReturnAddr

;--------------------------------------------------------------------------

NSTYPE			equ 00007h	; Segment type mask
NSCODE			equ 00000h	; Code segment
NSDATA			equ 00001h	; Data segment
NSITER			equ 00008h	; Iterated segment flag
NSMOVE			equ 00010h	; Movable segment flag
NSPURE			equ 00020h	; Pure segment flag
NSPRELOAD		equ 00040h	; Preload segment flag
NSRELOC			equ 00100h	; Segment has relocations
NSDEBUG			equ 00200h	; Segment has debug info
NSDPL			equ 00C00h	; 286 DPL bits
NSDISCARD		equ 01000h	; Discard bit for segment

CODEINFO	struc
	ns_sector	dw	?	; File sector of start of segment
	ns_cbseg	dw	?	; Number of bytes in file
	ns_flags	dw	?	; Attribute flags
	ns_minalloc	dw	?	; Minimum allocation in bytes
	ns_handle	dw	?	; handle to object
	ns_align	dw	?	; file alignment
CODEINFO	ends

DSC_CODE_BIT	equ	08h

;--------------------------------------------------------------------------

externA		__AHINCR
externA		__WINFLAGS
externFP	LogParamError		;(WORD wError, FARPROC lpfn, DWORD dValue);
externFP	IsWindow		;(HWND hwnd);
externFP	GetCodeInfo		;(FARPROC lpfnProc, LPVOID lpSegInfo);
externFP	GetCurrentTask		;(void);
externFP	IsTask			;(HANDLE hTask);

; Windows internal pointer validation tools.
externFP	IsBadReadPtr		;(LPVOID lp, WORD cb);
externFP	IsBadWritePtr		;(LPVOID lp, WORD cb);
externFP	IsBadHugeReadPtr	;(LPVOID lp, DWORD cb);
externFP	IsBadHugeWritePtr	;(LPVOID lp, DWORD cb);
externFP	IsBadCodePtr		;(FARPROC lp);
externFP	IsBadStringPtr		;(LPSTR lpsz, WORD wMaxLen);
externFP	IsSharedSelector	;(WORD wSelector);

;--------------------------------------------------------------------------
sBegin Data

sEnd Data

;--------------------------------------------------------------------------

;;;createSeg _TEXT, CodeRes, word, public, CODE
;;;createSeg FIX,   CodeFix, word, public, CODE
createSeg MSVIDEO, CodeRes, word, public, CODE

sBegin  CodeRes
        assumes cs, CodeRes
	assumes ds, Data

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateReadPointer | validates that a pointer is valid to
;	read from.
;
; @parm LPVOID | lpPoint| pointer to validate
; @parm DWORD  | dLen   | supposed length of said pointer 
;
; @rdesc Returns TRUE  if <p> is a valid pointer
;        Returns FALSE if <p> is not a valid pointer
;
; @comm will generate error if the pointer is invalid
;
cProc	ValidateReadPointer, <FAR, PUBLIC, PASCAL> <>
	parmD	lpPoint
	parmD	dLen
cBegin
        cCall   IsBadHugeReadPtr, <lpPoint, dLen>
        or      ax,ax
        jz      ValidateReadPointer_Exit        ; Return TRUE

	cCall	LogParamError, <ERR_BAD_PTR, ReturnAddr, lpPoint>
        mov     ax,-1                           ; Return FALSE

ValidateReadPointer_Exit:
        not     ax
cEnd

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateWritePointer | validates that a pointer is valid to
;	write to.
;
; @parm LPVOID | lpPoint| pointer to validate
; @parm DWORD  | dLen   | supposed length of said pointer 
;
; @rdesc Returns TRUE  if <p> is a valid pointer
;        Returns FALSE if <p> is not a valid pointer
;
; @comm will generate error if the pointer is invalid
;
cProc	ValidateWritePointer, <FAR, PUBLIC, PASCAL> <>
	parmD	lpPoint
	parmD	dLen
cBegin
	cCall	IsBadHugeWritePtr, <lpPoint, dLen>
        or      ax,ax                           ; If not fail,
        jz      ValidateWritePointer_Exit       ; Return TRUE
	cCall	LogParamError, <ERR_BAD_PTR, ReturnAddr, lpPoint>
        mov     ax,-1                           ; Return FALSE
ValidateWritePointer_Exit:
        not     ax
cEnd

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func WORD | ValidDriverCallback |
;
;  validates that a driver callback is valid, to be valid a driver
;  callback must be a valid window, task, or a function in a FIXED DLL
;  code segment.
;
; @parm DWORD  | dwCallback | callback to validate
; @parm  WORD  | wFlags     | driver callback flags
;
; @rdesc Returns 0  if <dwCallback> is a valid callback
;        Returns error condition if <dwCallback> is not a valid callback
;
cProc	ValidDriverCallback, <NEAR, PASCAL> <>
	parmD	dCallback
	parmW	wFlags
	localV	ci, %(SIZE CODEINFO)
cBegin
	mov	ax, wFlags			; switch on callback type
	and	ax, DCB_TYPEMASK
	errnz	<DCB_NULL>
	jnz	ValidDriverCallback_Window	; case DCB_NULL
        jmp     ValidDriverCallback_Exit        ; return zero for success

ValidDriverCallback_Window:
	dec	ax
	errnz	<DCB_WINDOW - 1>
	jnz	ValidDriverCallback_Task	; case DCB_WINDOW
	cmp	dCallback.hi, 0			; HIWORD must be NULL
	jnz	ValidDriverCallback_BadWindow	; Set error
	push	dCallback.lo			; Check for valid HWND
	cCall	IsWindow, <>
	or	ax, ax				; If HWND,
        jnz     ValidDriverCallback_Success     ; Set successful return

ValidDriverCallback_BadWindow:                  ; Else set error return
	mov	ax, ERR_BAD_HWND
        jmp     ValidDriverCallback_Exit        ; Return error

ValidDriverCallback_Task:
	dec	ax
	errnz	<DCB_TASK - 2>
	jnz	ValidDriverCallback_Function	; case DCB_TASK
	cmp	dCallback.hi, 0			; HIWORD must be NULL
	jnz	ValidDriverCallback_BadTask	; Set error
	push	dCallback.lo			; Check for valid Task
	cCall	IsTask, <>
	or	ax, ax				; If Task,
        jnz     ValidDriverCallback_Success     ; Set successful return

ValidDriverCallback_BadTask:			; Else set error return
	mov	ax, ERR_BAD_HANDLE
        jmp     ValidDriverCallback_Exit        ; Return error

ValidDriverCallback_Function:
	dec	ax
        errnz   <DCB_FUNCTION - 3>              ; case DCB_FUNCTION
        jnz     ValidDriverCallback_Default
	lea	ax, ci
	cCall	GetCodeInfo, <dCallback, ss, ax>
	or	ax, ax
	jz	ValidDriverCallback_BadFunction	; Set error return
	mov	ax, ci.ns_flags			; Check for valid flags
	and	ax, NSDATA or NSMOVE or NSDISCARD
        jz      ValidDriverCallback_Exit        ; Return zero for success
        jnz     ValidDriverCallback_BadFunction

ValidDriverCallback_Default:
	mov	ax, ERR_BAD_FLAGS		; default to error condition
        jmp     ValidDriverCallback_Exit

ValidDriverCallback_Success:
        xor     ax, ax

ValidDriverCallback_Exit:
cEnd

ValidDriverCallback_BadFunction:                ; Else set error return
        DebugErr DBF_ERROR, "Driver callbacks MUST be in a FIXED segment of a DLL."
	mov	ax, ERR_BAD_FUNC_PTR
        jmp     ValidDriverCallback_Exit        ; Return error

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateDriverCallback |
;
;  validates that a driver callback is valid, to be valid a driver
;  callback must be a valid window, task, or a function in a FIXED DLL
;  code segment.
;
; @parm DWORD  | dwCallback | callback to validate
; @parm  WORD  | wFlags     | driver callback flags
;
; @rdesc Returns TRUE  if <dwCallback> is a valid callback
;        Returns FALSE if <dwCallback> is not a valid callback
;
; @comm will generate error if the callback is invalid
;
cProc	ValidateDriverCallback, <FAR, PUBLIC, PASCAL> <>
	parmD	dCallback
	parmW	wFlags
cBegin
	cCall	ValidDriverCallback, <dCallback, wFlags>
	or	ax, ax				; If no error return
	jz	ValidateDriverCallback_Exit	; Return TRUE
	cCall	LogParamError, <ax, ReturnAddr, dCallback>
	mov	ax, -1				; Return FALSE
ValidateDriverCallback_Exit:
	not	ax
cEnd

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateCallback |
;
;  validates that a callback is valid.
;
; @parm FARPROC  | dCallback | callback to validate
;
; @rdesc Returns TRUE  if <lpfnCallback> is a valid callback
;        Returns FALSE if <lpfnCallback> is not a valid callback
;
; @comm will generate error if the callback is invalid
;
cProc	ValidateCallback, <FAR, PUBLIC, PASCAL> <>
	parmD	dCallback
cBegin
	cCall	IsBadCodePtr, <dCallback>
        or      ax,ax                           ; If not fail,
        jz      ValidateCallback_Exit           ; Return TRUE
	cCall	LogParamError, <ERR_BAD_FUNC_PTR, ReturnAddr, dCallback>
        mov     ax, -1                          ; Return FALSE
ValidateCallback_Exit:
        not     ax
cEnd

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateString | Validates taht a string is valid
;
;
;  validates that a callback is valid.
cProc	ValidateString, <FAR, PUBLIC, PASCAL> <>
        parmD   lsz
        parmW   max_len
cBegin
        cCall   IsBadStringPtr, <lsz, max_len>  ; Maximum length
        or      ax,ax                           ; If not fail,
        jz      ValidateString_Exit             ; Return TRUE
	cCall	LogParamError, <ERR_BAD_STRING_PTR, ReturnAddr, lsz>
        mov     ax, -1                          ; Return FALSE
ValidateString_Exit:
        not     ax
cEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvideo.16\init.c ===
/*
    init.c initialisation for MSVIDEO.DLL

    Copyright (c) Microsoft Corporation 1992. All rights reserved

*/

#include <windows.h>
#include <win32.h>
#include <verinfo.h>           // to get rup
#include "mmsystem.h"
#include "msviddrv.h"
#include "msvideo.h"
#include "msvideoi.h"

#ifdef WIN32

/* we have to allow the compman dll to perform load and unload
 * processing - it has a critsec that needs to be initialised and freed
 */
extern void IC_Load(void);
extern void IC_Unload(void);
#else
#define IC_Load()
#define IC_Unload()
#endif

extern void FAR PASCAL videoCleanup(HTASK hTask);
extern void FAR PASCAL DrawDibCleanup(HTASK hTask);
extern void FAR PASCAL ICCleanup(HTASK hTask);

/*****************************************************************************
 * @doc INTERNAL VIDEO
 *
 * DLLEntryPoint - common DLL entry point.
 *
 *  this code is called on both Win16 and Win32, libentry.asm handles
 *  this on Win16 and the system handles it on NT.
 *
 ****************************************************************************/

#ifndef DLL_PROCESS_DETACH
    #define DLL_PROCESS_DETACH  0
    #define DLL_PROCESS_ATTACH  1
    #define DLL_THREAD_ATTACH   2
    #define DLL_THREAD_DETACH   3
#endif

#ifndef NOTHUNKS
VOID FAR PASCAL InitThunks(void);
BOOL gfVideo32;
BOOL gfICM32;
#endif // NOTHUNKS


BOOL WINAPI DLLEntryPoint(HINSTANCE hInstance, ULONG Reason, LPVOID pv)
{
    switch (Reason)
    {
        case DLL_PROCESS_ATTACH:
            ghInst = hInstance;
            IC_Load();
#ifndef NOTHUNKS
            DPF(("Setting up the thunk code\n"));
            InitThunks();
            DPF(("All thunks initialised:  gfVideo32=%d,  gfICM32=%d\n", gfVideo32, gfICM32));
#endif // NOTHUNKS
            break;

        case DLL_PROCESS_DETACH:
            DrawDibCleanup(NULL);
            ICCleanup(NULL);
            IC_Unload();
            videoCleanup(NULL);
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_THREAD_ATTACH:
            break;
    }

    return TRUE;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | VideoForWindowsVersion | This function returns the version
 *   of the Microsoft Video for Windows software.
 *
 * @rdesc Returns a DWORD version, the hiword is the product version the
 *  loword is the minor revision.
 *
 * @comm currently returns 0x010A00## (1.10.00.##) ## is the internal build
 *      number.
 *
 ****************************************************************************/
#if 0
#ifdef rup
    #define MSVIDEO_VERSION     (0x01000000l+rup)       // 1.00.00.##
#else
    #define MSVIDEO_VERSION     (0x01000000l)           // 1.00.00.00
#endif
#else
    #define MSVIDEO_VERSION     (0x0L+(((DWORD)MMVERSION)<<24)+(((DWORD)MMREVISION)<<16)+((DWORD)MMRELEASE))
#endif

DWORD FAR PASCAL VideoForWindowsVersion(void)
{
    return MSVIDEO_VERSION;
}

/*****************************************************************************
 *
 * dprintf() is called by the DPF macro if DEBUG is defined at compile time.
 *
 * The messages will be send to COM1: like any debug message. To
 * enable debug output, add the following to WIN.INI :
 *
 * [debug]
 * MSVIDEO=1
 *
 ****************************************************************************/

#ifdef DEBUG

#define MODNAME "MSVIDEO"

#ifndef WIN32
    #define lstrcatA lstrcat
    #define lstrcpyA lstrcpy
    #define lstrlenA lstrlen
    #define wvsprintfA      wvsprintf
    #define GetProfileIntA  GetProfileInt
    #define OutputDebugStringA OutputDebugString
#endif

#define _WINDLL
#include <stdarg.h>

void FAR CDECL dprintf(LPSTR szFormat, ...)
{
    char ach[128];
    va_list va;

    static BOOL fDebug = -1;

    if (fDebug == -1)
        fDebug = GetProfileIntA("Debug", MODNAME, FALSE);

    if (!fDebug)
        return;

    lstrcpyA(ach, MODNAME ": ");
    va_start(va, szFormat);
    wvsprintfA(ach+lstrlenA(ach),szFormat,(LPSTR)va);
    va_end(va);
    lstrcatA(ach, "\r\n");

    OutputDebugStringA(ach);
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvideo.16\msviddrv.h ===
/****************************************************************************/
/*                                                                          */
/*        MSVIDDRV.H - Include file for messages to video drivers           */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1993, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MSVIDDRV
#define _INC_MSVIDDRV	50	/* version number */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****************************************************************************

                 Digital Video Messages (DVM_)

****************************************************************************/

// General messages
#define DVM_START                         DRV_USER
#define DVM_GETERRORTEXT                  (DVM_START + 0)
#define DVM_GETVIDEOAPIVER                (DVM_START + 1)

// This value increments each time the API changes
// It is passed to the driver in the DRV_OPEN message.
#define VIDEOAPIVERSION 		2

// General messages applicable to all channel types
#define DVM_DIALOG			(DVM_START + 100)
#define DVM_CONFIGURESTORAGE		(DVM_START + 101)
#define DVM_GET_CHANNEL_CAPS         	(DVM_START + 102)
#define DVM_UPDATE         		(DVM_START + 103) 

// Single frame msg
#define DVM_FRAME			(DVM_START + 200)  

// stream messages
#define DVM_STREAM_MSG_START            (DVM_START + 300)
#define DVM_STREAM_MSG_END              (DVM_START + 399)

#define DVM_STREAM_ADDBUFFER            (DVM_START + 300)  
#define DVM_STREAM_FINI                 (DVM_START + 301)  
#define DVM_STREAM_GETERROR             (DVM_START + 302)  
#define DVM_STREAM_GETPOSITION          (DVM_START + 303)  
#define DVM_STREAM_INIT                 (DVM_START + 304)  
#define DVM_STREAM_PREPAREHEADER        (DVM_START + 305)  
#define DVM_STREAM_RESET                (DVM_START + 306)
#define DVM_STREAM_START                (DVM_START + 307)  
#define DVM_STREAM_STOP                 (DVM_START + 308)  
#define DVM_STREAM_UNPREPAREHEADER      (DVM_START + 309)  

// NOTE that DVM_CONFIGURE numbers will start at 0x1000 (for configure API)


/****************************************************************************

                            Open Definitions

****************************************************************************/
#define OPEN_TYPE_VCAP mmioFOURCC('v', 'c', 'a', 'p')

// The following structure is the same as IC_OPEN
// to allow compressors and capture devices to share
// the same DriverProc.

typedef struct tag_video_open_parms {
    DWORD               dwSize;         // sizeof(VIDEO_OPEN_PARMS)
    FOURCC              fccType;        // 'vcap'
    FOURCC              fccComp;        // unused
    DWORD               dwVersion;      // version of msvideo opening you
    DWORD               dwFlags;        // channel type
    DWORD               dwError;        // if open fails, this is why
} VIDEO_OPEN_PARMS, FAR * LPVIDEO_OPEN_PARMS;

typedef struct tag_video_geterrortext_parms {
       DWORD  dwError;          // The error number to identify
       LPSTR  lpText;		// Text buffer to fill
       DWORD  dwLength;		// Size of text buffer.
} VIDEO_GETERRORTEXT_PARMS, FAR * LPVIDEO_GETERRORTEXT_PARMS;

typedef struct tag_video_stream_init_parms {
       DWORD  dwMicroSecPerFrame;
       DWORD  dwCallback;
       DWORD  dwCallbackInst;
       DWORD  dwFlags;
       DWORD  hVideo;
} VIDEO_STREAM_INIT_PARMS, FAR * LPVIDEO_STREAM_INIT_PARMS;

typedef struct tag_video_configure_parms {
       LPDWORD  lpdwReturn;	// Return parameter from configure MSG.
       LPVOID	lpData1;	// Pointer to data 1.
       DWORD	dwSize1;	// size of data buffer 1.
       LPVOID	lpData2;	// Pointer to data 2.
       DWORD	dwSize2;	// size of data buffer 2.
} VIDEOCONFIGPARMS, FAR * LPVIDEOCONFIGPARMS;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDDRV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvideo.16\libentry.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   DLLENTRY.ASM
;
;   simulates the NT DllEntryPoint call for a Win16 DLL
;
;   Copyright (c) Microsoft Corporation 1989, 1990. All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        PMODE = 1
        ?PLM=1  ; pascal call convention
        ?WIN=0  ; NO! Windows prolog/epilog code
        .286

        .xlist
        include cmacros.inc
        .list

DLL_PROCESS_DETACH  = 0
DLL_PROCESS_ATTACH  = 1

        externFP DllEntryPoint
        externFP LocalInit

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;
; Stuff needed to avoid the C runtime coming in, and init the windows
; reserved parameter block at the base of DGROUP
;
; NOTE if you need the 'C' startup dont use this file.
;
;-----------------------------------------------------------------------;

if 1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

sBegin  Data
        assumes ds,Data

        DD  0           ; So null pointers get 0
        DW  5           ; number of reserved ptrs
globalW pLocalHeap,0    ; Local heap pointer
globalW pAtomTable,0    ; Atom table pointer
globalW pStackTop,0     ; top of stack
globalW pStackMin,0     ; minimum value of SP
globalW pStackBot,0     ; bottom of stack

public  __acrtused
	__acrtused = 1

sEnd        Data

endif;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

sBegin  CodeSeg
	assumes cs,CodeSeg
        assumes ds,Data
        assumes es,nothing

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used)
; Returns:
;       AX = TRUE if success
; History:
;       06-27-89 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
	assumes ds,nothing
	assumes es,nothing

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
        jcxz    @f
        cCall   LocalInit,<0,0,cx>
@@:     cCall   DllEntryPoint, <di, 0,DLL_PROCESS_ATTACH, 0, 0>
cEnd

;--------------------------Private-Routine-----------------------------;
;
; WEP - called when DLL is unloaded
;
; History:
;       06-27-89 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
	assumes ds,nothing
	assumes es,nothing

cProc   WEP, <FAR, PUBLIC, PASCAL>, <ds>
        ParmW  fSystemExit
cBegin
        ;
        ;   HEY dont cleanup if windows is going down.
        ;
        mov     ax,fSystemExit
        or      ax,ax
;;;     jnz     just_exit

        mov     ax,DataBASE
        mov     ds,ax
        assumes ds,Data

        cCall   DllEntryPoint, <ax, 0,DLL_PROCESS_DETACH, 0, 0>
just_exit:
cEnd

sEnd CodeSeg

        end LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvideo.16\msvideo.h ===
/****************************************************************************/
/*                                                                          */
/*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY   */
/*  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE     */
/*  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR   */
/*  PURPOSE.								    */
/*        MSVIDEO.H - Include file for Video APIs                           */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1993, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MSVIDEO
#define _INC_MSVIDEO	50	/* version number */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef _RCINVOKED

#ifdef BUILDDLL                         /* ;Internal */
#undef WINAPI                           /* ;Internal */
#define WINAPI FAR PASCAL _loadds       /* ;Internal */
#endif                                  /* ;Internal */

/* video data types */
DECLARE_HANDLE(HVIDEO);                 // generic handle
typedef HVIDEO FAR * LPHVIDEO;
#endif                                  // ifndef RCINVOKED

/****************************************************************************

                        version api

****************************************************************************/

DWORD FAR PASCAL VideoForWindowsVersion(void);

/****************************************************************************

                            Error Return Values

****************************************************************************/
#define DV_ERR_OK               (0)                  /* No error */
#define DV_ERR_BASE             (1)                  /* Error Base */
#define DV_ERR_NONSPECIFIC      (DV_ERR_BASE)
#define DV_ERR_BADFORMAT        (DV_ERR_BASE + 1)
				/* unsupported video format */
#define DV_ERR_STILLPLAYING     (DV_ERR_BASE + 2)
				/* still something playing */
#define DV_ERR_UNPREPARED       (DV_ERR_BASE + 3)
				/* header not prepared */
#define DV_ERR_SYNC             (DV_ERR_BASE + 4)
				/* device is synchronous */
#define DV_ERR_TOOMANYCHANNELS  (DV_ERR_BASE + 5)
				/* number of channels exceeded */
#define DV_ERR_NOTDETECTED	(DV_ERR_BASE + 6)    /* HW not detected */
#define DV_ERR_BADINSTALL	(DV_ERR_BASE + 7)    /* Can not get Profile */
#define DV_ERR_CREATEPALETTE	(DV_ERR_BASE + 8)
#define DV_ERR_SIZEFIELD	(DV_ERR_BASE + 9)
#define DV_ERR_PARAM1		(DV_ERR_BASE + 10)
#define DV_ERR_PARAM2		(DV_ERR_BASE + 11)
#define DV_ERR_CONFIG1		(DV_ERR_BASE + 12)
#define DV_ERR_CONFIG2		(DV_ERR_BASE + 13)
#define DV_ERR_FLAGS		(DV_ERR_BASE + 14)
#define DV_ERR_13		(DV_ERR_BASE + 15)

#define DV_ERR_NOTSUPPORTED     (DV_ERR_BASE + 16)   /* function not suported */
#define DV_ERR_NOMEM            (DV_ERR_BASE + 17)   /* out of memory */
#define DV_ERR_ALLOCATED        (DV_ERR_BASE + 18)   /* device is allocated */
#define DV_ERR_BADDEVICEID      (DV_ERR_BASE + 19)
#define DV_ERR_INVALHANDLE      (DV_ERR_BASE + 20)
#define DV_ERR_BADERRNUM        (DV_ERR_BASE + 21)
#define DV_ERR_NO_BUFFERS       (DV_ERR_BASE + 22)   /* out of buffers */

#define DV_ERR_MEM_CONFLICT     (DV_ERR_BASE + 23)   /* Mem conflict detected */
#define DV_ERR_IO_CONFLICT      (DV_ERR_BASE + 24)   /* I/O conflict detected */
#define DV_ERR_DMA_CONFLICT     (DV_ERR_BASE + 25)   /* DMA conflict detected */
#define DV_ERR_INT_CONFLICT     (DV_ERR_BASE + 26)   /* Interrupt conflict detected */
#define DV_ERR_PROTECT_ONLY     (DV_ERR_BASE + 27)   /* Can not run in standard mode */
#define DV_ERR_LASTERROR        (DV_ERR_BASE + 27)

#define DV_ERR_USER_MSG         (DV_ERR_BASE + 1000) /* Hardware specific errors */

/****************************************************************************

                         Callback Messages

Note that the values for all installable driver callback messages are
identical, (ie. MM_DRVM_DATA has the same value for capture drivers,
installable video codecs, and the audio compression manager).
****************************************************************************/
#ifndef _RCINVOKED

#ifndef MM_DRVM_OPEN
#define MM_DRVM_OPEN       0x3D0
#define MM_DRVM_CLOSE      0x3D1
#define MM_DRVM_DATA       0x3D2
#define MM_DRVM_ERROR      0x3D3
#endif

#define DV_VM_OPEN         MM_DRVM_OPEN         // Obsolete messages
#define DV_VM_CLOSE        MM_DRVM_CLOSE
#define DV_VM_DATA         MM_DRVM_DATA
#define DV_VM_ERROR        MM_DRVM_ERROR

/****************************************************************************

                         Structures

****************************************************************************/
/* video data block header */
typedef struct videohdr_tag {
    LPBYTE      lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* Length of data buffer */
    DWORD       dwBytesUsed;            /* Bytes actually used */
    DWORD       dwTimeCaptured;         /* Milliseconds from start of stream */
    DWORD       dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD       dwReserved[4];          /* reserved for driver */
} VIDEOHDR, NEAR *PVIDEOHDR, FAR * LPVIDEOHDR;

/* dwFlags field of VIDEOHDR */
#define VHDR_DONE       0x00000001  /* Done bit */
#define VHDR_PREPARED   0x00000002  /* Set if this header has been prepared */
#define VHDR_INQUEUE    0x00000004  /* Reserved for driver */
#define VHDR_KEYFRAME   0x00000008  /* Key Frame */
#define VHDR_VALID      0x0000000F  /* valid flags */     /* ;Internal */

/* Channel capabilities structure */
typedef struct channel_caps_tag {
    DWORD       dwFlags;                /* Capability flags*/
    DWORD       dwSrcRectXMod;          /* Granularity of src rect in x */
    DWORD       dwSrcRectYMod;          /* Granularity of src rect in y */
    DWORD       dwSrcRectWidthMod;      /* Granularity of src rect width */
    DWORD       dwSrcRectHeightMod;     /* Granularity of src rect height */
    DWORD       dwDstRectXMod;          /* Granularity of dst rect in x */
    DWORD       dwDstRectYMod;          /* Granularity of dst rect in y */
    DWORD       dwDstRectWidthMod;      /* Granularity of dst rect width */
    DWORD       dwDstRectHeightMod;     /* Granularity of dst rect height */
} CHANNEL_CAPS, NEAR *PCHANNEL_CAPS, FAR * LPCHANNEL_CAPS;

/* dwFlags of CHANNEL_CAPS */
#define VCAPS_OVERLAY       0x00000001      /* overlay channel */
#define VCAPS_SRC_CAN_CLIP  0x00000002      /* src rect can clip */
#define VCAPS_DST_CAN_CLIP  0x00000004      /* dst rect can clip */
#define VCAPS_CAN_SCALE     0x00000008      /* allows src != dst */

/****************************************************************************

                        video APIs

****************************************************************************/

DWORD WINAPI videoGetNumDevs(void);

DWORD WINAPI videoOpen  (LPHVIDEO lphVideo,
              DWORD dwDevice, DWORD dwFlags);
DWORD WINAPI videoClose (HVIDEO hVideo);
DWORD WINAPI videoDialog(HVIDEO hVideo, HWND hWndParent, DWORD dwFlags);
DWORD WINAPI videoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps,
                DWORD dwSize);
DWORD WINAPI videoUpdate (HVIDEO hVideo, HWND hWnd, HDC hDC);
DWORD WINAPI videoConfigure (HVIDEO hVideo, UINT msg, DWORD dwFlags,
		LPDWORD lpdwReturn, LPVOID lpData1, DWORD dwSize1,
                LPVOID lpData2, DWORD dwSize2);
DWORD WINAPI videoConfigureStorage (HVIDEO hVideo,
			LPSTR lpstrIdent, DWORD dwFlags);
DWORD WINAPI videoFrame(HVIDEO hVideo, LPVIDEOHDR lpVHdr);
DWORD WINAPI videoMessage(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2);

/* streaming APIs */
DWORD WINAPI videoStreamAddBuffer(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamGetError(HVIDEO hVideo, LPDWORD lpdwErrorFirst,
        LPDWORD lpdwErrorLast);
DWORD WINAPI videoGetErrorText(HVIDEO hVideo, UINT wError,
	        LPSTR lpText, UINT wSize);
DWORD WINAPI videoStreamGetPosition(HVIDEO hVideo, MMTIME FAR* lpInfo,
              DWORD dwSize);
DWORD WINAPI videoStreamInit(HVIDEO hVideo,
              DWORD dwMicroSecPerFrame, DWORD dwCallback,
              DWORD dwCallbackInst, DWORD dwFlags);
DWORD WINAPI videoStreamFini(HVIDEO hVideo);
DWORD WINAPI videoStreamPrepareHeader(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamReset(HVIDEO hVideo);
DWORD WINAPI videoStreamStart(HVIDEO hVideo);
DWORD WINAPI videoStreamStop(HVIDEO hVideo);
DWORD WINAPI videoStreamUnprepareHeader(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);

/****************************************************************************

			API Flags

****************************************************************************/

// Types of channels to open with the videoOpen function
#define VIDEO_EXTERNALIN		0x0001
#define VIDEO_EXTERNALOUT		0x0002
#define VIDEO_IN			0x0004
#define VIDEO_OUT			0x0008

// Is a driver dialog available for this channel?
#define VIDEO_DLG_QUERY			0x0010

// videoConfigure (both GET and SET)
#define VIDEO_CONFIGURE_QUERY   	0x8000

// videoConfigure (SET only)
#define VIDEO_CONFIGURE_SET		0x1000

// videoConfigure (GET only)
#define VIDEO_CONFIGURE_GET		0x2000
#define VIDEO_CONFIGURE_QUERYSIZE	0x0001

#define VIDEO_CONFIGURE_CURRENT		0x0010
#define VIDEO_CONFIGURE_NOMINAL		0x0020
#define VIDEO_CONFIGURE_MIN		0x0040
#define VIDEO_CONFIGURE_MAX		0x0080


/****************************************************************************

			CONFIGURE MESSAGES

****************************************************************************/
#define DVM_USER                        0X4000

#define DVM_CONFIGURE_START		0x1000
#define DVM_CONFIGURE_END		0x1FFF

#define DVM_PALETTE			(DVM_CONFIGURE_START + 1)
#define DVM_FORMAT			(DVM_CONFIGURE_START + 2)
#define DVM_PALETTERGB555		(DVM_CONFIGURE_START + 3)
#define DVM_SRC_RECT    		(DVM_CONFIGURE_START + 4)
#define DVM_DST_RECT    		(DVM_CONFIGURE_START + 5)

#endif  /* ifndef _RCINVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDEO */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvideo.16\dpmipage.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  PAGELOCK
;
;   This module contains functions for page locking memory using DPMI
;
; Created:  03-20-90
; Author:   Todd Laney [ToddLa]
;
; Copyright (c) 1984-1990 Microsoft Corporation
;
; Exported Functions:	none
;
; Public Functions:     DpmiPageLock
;                       DpmiPageUnlock
;
; Public Data:          none
;
; General Description:
;
; Restrictions:
;
;-----------------------------------------------------------------------;

        ?PLM = 1
        ?WIN = 0
        ?NODATA = 1

        .286
        .xlist
        include cmacros.inc
        include int31.inc
        .list

        externA         __AHINCR                    ; KERNEL
        externFP        GlobalHandle                ; KERNEL
        externFP        GlobalHandleNoRip           ; KERNEL
        externFP        GlobalFix                   ; KERNEL
        externFP        GlobalUnFix                 ; KERNEL

ifndef SEGNAME
    SEGNAME equ <MSVIDEO>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

Int31_SelMgt_Get_Base     EQU ((Int31_Sel_Mgt shl 8) + SelMgt_Get_Base )
Int31_Lock_Region         EQU ((Int31_Page_Lock shl 8) + Lock_Region )
Int31_Unlock_Region       EQU ((Int31_Page_Lock shl 8) + Unlock_Region )

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

FARPOINTER      struc
off     dw      ?
sel     dw      ?
FARPOINTER      ends

sBegin CodeSeg
        assumes cs,CodeSeg
        assumes ds,nothing
        assumes es,nothing

;---------------------------Public-Routine------------------------------;
; DpmiPageLock
;
;   page lock a region using DPMI
;
; Entry:
;       lpBase      Selector:offset of base of region to lock
;       dwSize      size in bytes of region to lock
;
; Returns:
;       NZ
;       AX = TRUE if successful
;
; Error Returns:
;       Z
;       AX = FALSE if error
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       INT 31h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   DpmiPageLock, <NEAR>, <>
;       parmD   lpBase
;       parmD   dwSize
cBegin  nogen
        mov     cx,Int31_Lock_Region
        jmp     short DpmiPageLockUnLock
cEnd    nogen

;---------------------------Public-Routine------------------------------;
; DpmiPageUnlock
;
;   un-page lock a region using DPMI
;
; Entry:
;       lpBase      Selector:offset of base of region to unlock
;       dwSize      size in bytes of region to unlock
;
; Returns:
;       NZ
;       AX = TRUE if successful
;
; Error Returns:
;       Z
;       AX = FALSE if error
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       INT 31h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   DpmiPageUnlock, <NEAR>, <>
;       parmD   lpBase
;       parmD   dwSize
cBegin  nogen
        mov     cx,Int31_Unlock_Region
        errn$   DpmiPageLockUnLock
cEnd    nogen

cProc   DpmiPageLockUnLock, <NEAR>, <si,di>
        parmD   lpBase
        parmD   dwSize
cBegin
        mov     si,cx                       ; save lock/unlock flag

        mov     ax,Int31_SelMgt_Get_Base
        mov     bx,lpBase.sel
        int     31h                         ; returns CX:DX selector base
        jc      dpl_exit

        mov     bx,cx                       ; BX:CX is base
        mov     cx,dx

        add     cx,lpBase.off               ; add offset into selector base
        adc     bx,0

        mov     ax,si                       ; get lock/unlock flag
        mov     si,dwSize.hi                ; SI:DI length
        mov     di,dwSize.lo

        int     31h                         ; lock or unlock it
dpl_exit:
        cmc                                 ; set carry iff success
        sbb     ax,ax                       ; return TRUE/FALSE
cEnd

;---------------------------Public-Routine------------------------------;
; HugePageLock
;
;   page lock a range of windows allocated memory
;
; Entry:
;       lpBase      Selector:offset of base of region to lock
;       dwSize      size in bytes of region to lock
;
; Returns:
;       AX = TRUE if successful
;
; Error Returns:
;       AX = FALSE if error
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       INT 31h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   HugePageLock, <FAR, PUBLIC>, <>
        parmD   lpBase
        parmD   dwSize
cBegin
        mov     ax,lpBase.sel               ; NULL pointer, invalid
        or      ax,ax
        jz      GPageLock_Exit

        call    HugeGlobalFix               ; fix the memory, then page lock
        cCall   DpmiPageLock,<lpBase, dwSize>
        jnz     GPageLock_Exit

        mov     ax,lpBase.sel               ; page lock failed, un-fix
        call    HugeGlobalUnFix             ; and return failure
        xor     ax,ax

GPageLock_Exit:
cEnd

;---------------------------Public-Routine------------------------------;
; HugePageUnlock
;
;   un-page lock a range of windows alocated memory, (locked with HugePageLock)
;
; Entry:
;       lpBase      Selector:offset of base of region to lock
;       dwSize      size in bytes of region to lock
;
; Returns:
;       none
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       INT 31h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   HugePageUnlock, <FAR, PUBLIC>, <>
        parmD   lpBase
        parmD   dwSize
cBegin
        cCall   DpmiPageUnlock,<lpBase, dwSize>

        mov     ax,lpBase.sel
        call    HugeGlobalUnFix
cEnd

;---------------------------Public-Routine------------------------------;
; HugeGlobalFix
;
;   fix the global object that represents the passed selector
;
; Entry:
;       AX = SELECTOR
;
; Returns:
;       none
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       GlobalFix
;       HugeGlobalHandle
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

HugeGlobalFix proc near

        call    HugeGlobalHandle
        jz      HugeGlobalFixExit

        cCall   GlobalFix,<ax>

HugeGlobalFixExit:
        ret

HugeGlobalFix endp

;---------------------------Public-Routine------------------------------;
; HugeGlobalUnFix
;
;   un-fix the global object that represents the passed selector
;
; Entry:
;       AX = SELECTOR
;
; Returns:
;       none
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       HugeGlobalHandle
;       GlobalUnFix
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

HugeGlobalUnFix proc near

        call    HugeGlobalHandle
        jz      HugeGlobalUnFixExit

        cCall   GlobalUnFix,<ax>

HugeGlobalUnFixExit:
        ret

HugeGlobalUnFix endp

;---------------------------Public-Routine------------------------------;
; HugeGlobalHandle
;
; Entry:
;       AX = SELECTOR to global object
;
; Returns:
;       NZ
;       AX = HANDLE of global object
;
; Error Returns:
;       Z
;       AX = 0 if error
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       GlobalHandleNoRip
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

HugeGlobalHandle proc near

        push    si
        mov     si,ax

        or      ax,ax                   ; test for NULL pointer!
        jz      HugeGlobalHandleExit

HugeGlobalHandleAgain:
        cCall   GlobalHandleNoRip,<si>
        sub     si,__AHINCR
        or      ax,ax
        jz      HugeGlobalHandleAgain

HugeGlobalHandleExit:
        pop     si
        ret

HugeGlobalHandle endp

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvideo.16\msvideoi.h ===
/****************************************************************************/
/*                                                                          */
/*        MSVIDEOI.H - Internal Include file for Video APIs                 */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1992, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifdef BUILDDLL
#undef WINAPI
#define WINAPI FAR PASCAL _loadds
#endif

/****************************************************************************

                   Digital Video Driver Structures

****************************************************************************/

#define MAXVIDEODRIVERS 10

/****************************************************************************

                            Globals

****************************************************************************/

extern UINT      wTotalVideoDevs;                  // total video devices
// The module handle is used in drawdib to load strings from the resource file
extern HINSTANCE ghInst;                           // our module handle

#ifndef NOTHUNKS
extern BOOL      gfVideo32;     // Do we have a 32-bit avicap.dll to talk to?
extern BOOL      gfICM32;       // Do we have access to 32 bit ICM thunks?
#endif // NOTHUNKS

#ifdef WIN32
//#define SZCODE TCHAR
#define HTASK HANDLE
#else
#define SZCODE char _based(_segname("_CODE"))
#endif

extern SZCODE szNull[];
extern SZCODE szVideo[];
extern SZCODE szSystemIni[];
extern SZCODE szDrivers[];

/* internal video function prototypes */
#ifdef WIN32
/*
 * don't lock pages in NT
 */
#define HugePageLock(x, y)		(TRUE)
#define HugePageUnlock(x, y)
#else
BOOL FAR PASCAL HugePageLock(LPVOID lpArea, DWORD dwLength);
void FAR PASCAL HugePageUnlock(LPVOID lpArea, DWORD dwLength);
#endif


// for correct handling of capGetDriverDescription on NT and Chicago
// this is used by the NT version of avicap.dll (16bit) but not intended for
// public use, hence not in msvideo.h
DWORD WINAPI videoCapDriverDescAndVer (
        DWORD wDriverIndex,
        LPSTR lpszName, UINT cbName,
        LPSTR lpszVer, UINT cbVer);

/****************************************************************************
****************************************************************************/

#ifdef DEBUG_RETAIL
    #define DebugErr(flags, sz)         {static SZCODE ach[] = "MSVIDEO: "sz; DebugOutput((flags)   | DBF_DRIVER, ach); }
#else
    #define DebugErr(flags, sz)
#endif

/****************************************************************************
****************************************************************************/

#ifdef DEBUG
    extern void FAR CDECL dprintf(LPSTR szFormat, ...);
    #define DPF(_x_) dprintf _x_
#else
    #define DPF(_x_)
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvideo.16\thunk16.c ===
/****************************************************************************
    thunks.c

    Contains code for thunking msvideo.dll from 16bit to 32bit

    Copyright (c) Microsoft Corporation 1994. All rights reserved

    Basic Structure:

        When loaded, the 16 bit DLL will try to find the corresponding
        32 bit DLL.  There are two of these.

        The 32bit videoXXXX api entry points are in AVICAP32.DLL
        The 32bit ICM code is in MSVFW32.DLL

        The thunk initialisation routine will check the code is running on
        Windows NT.  If not, no further initialisation is done.  This
        ensures that the same binary can be used on NT, and other Windows
        platforms.

        The code then attempts to access the special entry points provided
        in KERNEL.DLL for loading and calling 32 bit entry points.  If this
        link fails, no thunking can be done.

        Each of the 32 bit DLLs is loaded in turn, and GetProcAddress32 is
        called for the special thunk entry point.  If all works then two
        global flags are set (independently of each other).

        gfVideo32 == TRUE means that the videoXXXX apis can be called.
        gfICM32 == TRUE means that the 32 bit ICM code is available.

****************************************************************************/

#include <windows.h>
#define MMNOMCI
#include <win32.h>
#include <mmsystem.h>
#include <msvideo.h>
#include <msviddrv.h>
#include <compman.h>
#include "vidthunk.h"
#include "msvideoi.h"


SZCODE    gszKernel[]             = TEXT("KERNEL");
SZCODE    gszLoadLibraryEx32W[]   = TEXT("LoadLibraryEx32W");
//SZCODE    gszFreeLibraryEx32W[]   = TEXT("FreeLibraryEx32W");
SZCODE    gszFreeLibrary32W[]     = TEXT("FreeLibrary32W");
SZCODE    gszGetProcAddress32W[]  = TEXT("GetProcAddress32W");
SZCODE    gszCallproc32W[]        = TEXT("CallProc32W");
SZCODE    gszVideoThunkEntry[]    = TEXT("videoThunk32");
SZCODE    gszVideo32[]            = TEXT("avicap32.dll");
SZCODE    gszICMThunkEntry[]      = TEXT("ICMThunk32");
SZCODE    gszICMThunkEntry2[]      = TEXT("ICMTHUNK32");
SZCODE    gszICM32[]              = TEXT("msvfw32.dll");

VIDTHUNK pvth;

#ifndef WIN32
//--------------------------------------------------------------------------;
//
//  BOOL InitThunks
//
//  Description:
//
//
//  Arguments:
//      None.
//
//  Return (BOOL):
//
//  History:
//
//
//--------------------------------------------------------------------------;
void FAR PASCAL InitThunks(VOID)
{
    HMODULE   hmodKernel;
    DWORD     (FAR PASCAL *lpfnLoadLibraryEx32W)(LPCSTR, DWORD, DWORD);
    LPVOID    (FAR PASCAL *lpfnGetProcAddress32W)(DWORD, LPCSTR);
    DWORD     (FAR PASCAL *lpfnFreeLibrary32W)(DWORD hLibModule);

    //
    //  Check if we're WOW
    //

//  if (!(GetWinFlags() & WF_WINNT)) {
//      //DPF(("Not running in WOW... returning FALSE\n"));
//      return;
//  }

    //
    //  See if we can find the thunking routine entry points in KERNEL
    //

    hmodKernel = GetModuleHandle(gszKernel);

    if (hmodKernel == NULL)
    {
	DPF(("Cannot link to kernel module... returning FALSE\n"));
        return;   // !!!!
    }

    *(FARPROC *)&lpfnLoadLibraryEx32W =
        GetProcAddress(hmodKernel, gszLoadLibraryEx32W);
    if (lpfnLoadLibraryEx32W == NULL)
    {
	DPF(("Cannot get address of LoadLibrary32... returning FALSE\n"));
        return;
    }

    *(FARPROC *)&lpfnGetProcAddress32W =
        GetProcAddress(hmodKernel, gszGetProcAddress32W);
    if (lpfnGetProcAddress32W == NULL)
    {
	DPF(("Cannot get address of GetProcAddress32... returning FALSE\n"));
        return;
    }

    *(FARPROC *)&pvth.lpfnCallproc32W =
        GetProcAddress(hmodKernel, gszCallproc32W);
    if (pvth.lpfnCallproc32W == NULL)
    {
	DPF(("Cannot get address of CallProc32... returning FALSE\n"));
        return;
    }

    // In case we need to unload our 32 bit libraries...
    *(FARPROC *)&lpfnFreeLibrary32W =
        GetProcAddress(hmodKernel, gszFreeLibrary32W);


    //
    //  See if we can get pointers to our thunking entry points
    //

    pvth.dwVideo32Handle = (*lpfnLoadLibraryEx32W)(gszVideo32, 0L, 0L);

    if (pvth.dwVideo32Handle != 0)
    {
        pvth.lpVideoThunkEntry = (*lpfnGetProcAddress32W)(pvth.dwVideo32Handle, gszVideoThunkEntry);
        if (pvth.lpVideoThunkEntry != NULL)
        {
            gfVideo32 = TRUE;
        } else {
	    DPF(("Cannot get address of video thunk entry...\n"));
            if (lpfnFreeLibrary32W)
            {
                (*lpfnFreeLibrary32W)(pvth.dwVideo32Handle);
            }
	}
    } else {
	DPF(("Cannot load Video32 DLL...\n"));
    }	

    pvth.dwICM32Handle = (*lpfnLoadLibraryEx32W)(gszICM32, 0L, 0L);

    if (pvth.dwICM32Handle != 0)
    {
        pvth.lpICMThunkEntry = (*lpfnGetProcAddress32W)(pvth.dwICM32Handle, gszICMThunkEntry);
        if (pvth.lpICMThunkEntry != NULL)
        {
	    DPF(("ICM thunks OK!!\n"));
            gfICM32 = TRUE;
        } else {
	    DPF(("Cannot get address of ICM thunk entry... trying #2\n"));
            pvth.lpICMThunkEntry = (*lpfnGetProcAddress32W)(pvth.dwICM32Handle, gszICMThunkEntry2);
            if (pvth.lpICMThunkEntry != NULL)
            {
    	        DPF(("ICM thunks OK!! (at second time of trying)\n"));
                gfICM32 = TRUE;
            } else {
        	DPF(("Cannot get address of ICM thunk entry2...\n"));
                if (lpfnFreeLibrary32W)
                {
                    (*lpfnFreeLibrary32W)(pvth.dwICM32Handle);
                }
            }
	}
    } else {
	DPF(("Cannot load ICM32 DLL...\n"));
    }	

    return;
}
#endif // !WIN32


//
// The following functions generate calls to the 32-bit side
//

DWORD FAR PASCAL videoMessage32(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2)
{
   /*
    *  Check there's something on the other side!
    */

    if (!gfVideo32) {
	DPF(("videoMessage32 - no video thunks... returning FALSE\n"));
        return DV_ERR_INVALHANDLE;
    }

   /*
    *  Watch out for hvideos being passed
    */

    if (msg == DVM_STREAM_INIT) {
        ((LPVIDEO_STREAM_INIT_PARMS)dwP1)->hVideo = hVideo;
    }

    return((DWORD)(pvth.lpfnCallproc32W)(vidThunkvideoMessage32,
                           (DWORD)hVideo,
                           (DWORD)msg,
                           (DWORD)dwP1,
                           (DWORD)dwP2,
                           pvth.lpVideoThunkEntry,
                           0L, // no mapping of pointers
                           5L));
}


DWORD FAR PASCAL videoGetNumDevs32(void)
{
    if (!gfVideo32) {
	DPF(("videoGetNumDevs32 - no video thunks... returning FALSE\n"));
        return 0;
    }

    return((DWORD)(pvth.lpfnCallproc32W)(vidThunkvideoGetNumDevs32,
                           (DWORD)0,
                           (DWORD)0,
                           (DWORD)0,
                           (DWORD)0,
                           pvth.lpVideoThunkEntry,
                           0L, // no mapping of pointers
                           5L));
}

DWORD FAR PASCAL videoClose32(HVIDEO hVideo)
{
   /*
    *  Check there's something on the other side!
    */

    if (!gfVideo32) {
	DPF(("videoClose32 - no video thunks... returning FALSE\n"));
        return DV_ERR_INVALHANDLE;
    }

    return((DWORD)(pvth.lpfnCallproc32W)(vidThunkvideoClose32,
                           (DWORD)hVideo,
                           (DWORD)0,
                           (DWORD)0,
                           (DWORD)0,
                           pvth.lpVideoThunkEntry,
                           0L, // no mapping of pointers
                           5L));
}

DWORD FAR PASCAL videoOpen32(LPHVIDEO lphVideo, DWORD dwDeviceID, DWORD dwFlags)
{
    DWORD dwRetc;

    if (!gfVideo32) {
	DPF(("videoOpen32 - no video thunks... returning FALSE\n"));
        return DV_ERR_NOTDETECTED;
    }

    dwRetc = ((DWORD)(pvth.lpfnCallproc32W)(vidThunkvideoOpen32,
                           (DWORD)lphVideo,
                           (DWORD)dwDeviceID,
                           (DWORD)dwFlags,
                           (DWORD)0,
                           pvth.lpVideoThunkEntry,
                           0L, // no mapping of pointers
                           5L));

    if (dwRetc == DV_ERR_OK) {
#ifdef DEBUG
        if (Is32bitHandle(*lphVideo)) {
            //OutputDebugString("\nMSVIDEO : 32-bit handle does not fit in 16 bits!");
            DebugBreak();
        }
#endif

        *lphVideo = Make32bitHandle(*lphVideo);
    }

    return dwRetc;
}


DWORD FAR PASCAL videoGetDriverDesc32(DWORD wDriverIndex,
        			LPSTR lpszName, short cbName,
        			LPSTR lpszVer, short cbVer)
{
    if (!gfVideo32) {
	DPF(("videoGetDriverDesc32 - no video thunks... returning FALSE\n"));
        return DV_ERR_NOTDETECTED;
    }

    return (BOOL)(pvth.lpfnCallproc32W)(vidThunkvideoGetDriverDesc32,
                           (DWORD)wDriverIndex,
                           (DWORD)lpszName,
                           (DWORD)lpszVer,
                           (DWORD) MAKELONG(cbName, cbVer),
                           pvth.lpVideoThunkEntry,
                           0L, // no mapping of pointers
                           5L);	// 5 params
}



/*
 * The ICM thunking uses the same mechanism as for Video, but calls to a
 * different 32 bit DLL.
 */

BOOL FAR PASCAL ICInfo32(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicInfo)
{
    if (!gfICM32) {
        //OutputDebugString("ICInfo32: gfICM32 is not set - returning FALSE\n");
        return FALSE;
    }

    return ((BOOL)(pvth.lpfnCallproc32W)(compThunkICInfo32,
                           (DWORD)fccType,
                           (DWORD)fccHandler,
                           (DWORD)lpicInfo,
                           (DWORD)0,
                           pvth.lpICMThunkEntry,
                           0L, // no mapping of pointers
                           5L));
}


LRESULT FAR PASCAL ICSendMessage32(DWORD hic, UINT msg, DWORD dwP1, DWORD dwP2)
{
   /*
    *  Check there's something on the other side!
    */

    if (!gfICM32) {
#ifdef DEBUG
        OutputDebugString("ICSendMessage32: gfICM32 is not set - returning FALSE\n");
#endif
        return ICERR_BADHANDLE;
    }

    return ((LRESULT)(pvth.lpfnCallproc32W)(compThunkICSendMessage32,
                           (DWORD)hic,
                           (DWORD)msg,
                           (DWORD)dwP1,
                           (DWORD)dwP2,
                           pvth.lpICMThunkEntry,
                           0L, // no mapping of pointers
                           5L));
}

DWORD FAR PASCAL ICOpen32(DWORD fccType, DWORD fccHandler, UINT wMode)
{
   /*
    *  Check there's something on the other side!
    */

    if (!gfICM32) {
#ifdef DEBUG
        OutputDebugString("ICOpen32: gfICM32 is not set - returning FALSE\n");
#endif
        return NULL;
    }

    return ((DWORD)(pvth.lpfnCallproc32W)(compThunkICOpen32,
                           (DWORD)fccType,
                           (DWORD)fccHandler,
                           (DWORD)wMode,
                           (DWORD)0,
                           pvth.lpICMThunkEntry,
                           0L, // no mapping of pointers
                           5L));
}


LRESULT FAR PASCAL ICClose32(DWORD hic)
{
   /*
    *  Check there's something on the other side!
    */

    if (!gfICM32) {
#ifdef DEBUG
        OutputDebugString("ICClose32: gfICM32 is not set - returning FALSE\n");
#endif
        return ICERR_BADHANDLE;
    }

    return ((LRESULT)(pvth.lpfnCallproc32W)(compThunkICClose32,
                           (DWORD)hic,
                           (DWORD)0,
                           (DWORD)0,
                           (DWORD)0,
                           pvth.lpICMThunkEntry,
                           0L, // no mapping of pointers
                           5L));
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvideo.16\thunks.h ===
/****************************************************************************
    thunks.h

    Contains definitions for thunking msvideo.dll from 16bit to 32bit

    Copyright (c) Microsoft Corporation 1993. All rights reserved

****************************************************************************/

//
// NOTE - 32bit handles have 0x8000 'or'ed in - this makes a BIG ASSUMPTION
// about how handles are generated on the 32-bit side.  We ASSUME here
// that :
//
//    32bit msvideo.dll always uses OpenDriver to create handles
//
//    The OpenDriver returns indices into its table (ie small positive
//    numbers).
//

#define  Is32bitHandle(h) (((h) & 0x8000) != 0)
#define  Make32bitHandle(h) ((h) | 0x8000)
#define  Map32bitHandle(h) ((h) & 0x7FFF)


//
// Functions to link and unlink to 32-bit side

void _loadds FAR UnregisterDLL(void);
BOOL _loadds FAR RegisterDLL(void);


//
// The following functions generate calls to the 32-bit side
//

#ifdef _INC_MSVIDEO

DWORD FAR PASCAL videoMessage32(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2);
DWORD FAR PASCAL videoGetNumDevs32(void);
DWORD FAR PASCAL videoClose32(HVIDEO hVideo);
DWORD FAR PASCAL videoOpen32(LPHVIDEO lphVideo, DWORD dwDeviceID, DWORD dwFlags);
DWORD FAR PASCAL videoGetDriverDesc32(DWORD wDriverIndex,
        			LPSTR lpszName, short cbName,
        			LPSTR lpszVer, short cbVer);


#endif // _INC_MSVIDEO

#ifdef _INC_COMPMAN

BOOL FAR PASCAL ICInfo32(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicInfo);
LRESULT FAR PASCAL ICSendMessage32(DWORD hic, UINT msg, DWORD dwP1, DWORD dwP2);
DWORD FAR PASCAL ICOpen32(DWORD fccType, DWORD fccHandler, UINT wMode);
LRESULT FAR PASCAL ICClose32(DWORD hic);

#endif // _INC_COMPMAN


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\nec_98\makefile.inc ===
#
# NEC98 product requires the US clock.avi renamed.
#

$(O)\winclock.avi: ..\clock.avi
    copy ..\clock.avi $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\vidcap32\arrow.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/
/****************************************************************************
 *
 *   arrow.h: Arrow control window 
 *
 *   Vidcap32 Source code
 *
 ***************************************************************************/

/*
 * interface definition for spin arrow class
 */

#define SPINARROW_CLASSNAME     "comarrow"

//reflect an arrow movement in the attached edit box
LONG FAR PASCAL ArrowEditChange( HWND hwndEdit, UINT wParam,
                                 LONG lMin, LONG lMax );


// call  me first (to register class)
BOOL FAR PASCAL ArrowInit(HANDLE hInst);



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\verinfo.16\verinfo.h ===
/*
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *	!!!!!!!IF YOU CHANGE TABS TO SPACES, YOU WILL BE KILLED!!!!!!!
 *      !!!!!!!!!!!!!!DOING SO MESSES UP THE BUILD PROCESS!!!!!!!!!!!!
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 */


/*
 *  verinfo.h - internal header file to define the build version
 *
 */

//
//  WARNING! the following defines are used by some of the components in
//  the multimedia core. do *NOT* put LEADING ZERO's on these numbers or
//  they will end up as OCTAL numbers in the C code!
//

#ifdef MTN

#define OFFICIAL	1
#define FINAL		0

#ifdef ALTACM

#define /*ALTACM*/ MMVERSION		2
#define /*ALTACM*/ MMREVISION		0
#define /*ALTACM*/ MMRELEASE		158

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME	"Microsoft Audio Compression Manager\0"
#define VERSIONCOPYRIGHT	"Copyright \251 Microsoft Corp. 1992-1994\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*ALTACM*/ VERSIONSTR	"Motown Retail Debug Version 2.00.158\0"
#elif defined(DEBUG)
#define /*ALTACM*/ VERSIONSTR	"Motown Internal Debug Version 2.00.158\0"
#else
#define /*ALTACM*/ VERSIONSTR	"2.00\0"
#endif

#elif defined(ALTVFW)

#define /*ALTVFW*/ MMVERSION		4
#define /*ALTVFW*/ MMREVISION		0
#define /*ALTVFW*/ MMRELEASE		158

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME	"Microsoft Video for Windows\0"
#define VERSIONCOPYRIGHT	"Copyright \251 Microsoft Corp. 1992-1994\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*ALTVFW*/ VERSIONSTR	"Motown Retail Debug Version 4.00.158\0"
#elif defined(DEBUG)
#define /*ALTVFW*/ VERSIONSTR	"Motown Internal Debug Version 4.00.158\0"
#else
#define /*ALTVFW*/ VERSIONSTR	"4.00\0"
#endif

#else

#define /*MTN*/ MMVERSION		4
#define /*MTN*/ MMREVISION		0
#define /*MTN*/ MMRELEASE		158

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME	"Microsoft Windows\0"
#define VERSIONCOPYRIGHT	"Copyright \251 Microsoft Corp. 1991-1994\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*MTN*/ VERSIONSTR	"Motown Retail Debug Version 4.00.158\0"
#elif defined(DEBUG)
#define /*MTN*/ VERSIONSTR	"Motown Internal Debug Version 4.00.158\0"
#else
#define /*MTN*/ VERSIONSTR	"4.00\0"
#endif

#endif

#elif defined(ACM)

#define OFFICIAL	1
#define FINAL		0

#define /*ACM*/ MMVERSION		3
#define /*ACM*/ MMREVISION		50
#define /*ACM*/ MMRELEASE		612

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME	"Microsoft Audio Compression Manager\0"
#define VERSIONCOPYRIGHT	"Copyright \251 Microsoft Corp. 1992-1994\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*ACM*/ VERSIONSTR	"ACM Retail Debug Version 3.50.612\0"
#elif defined(DEBUG)
#define /*ACM*/ VERSIONSTR	"ACM Internal Debug Version 3.50.612\0"
#else
#define /*ACM*/ VERSIONSTR	"3.50\0"
#endif

#elif defined(VFW)

#define OFFICIAL	1
#define FINAL		0

#define /*VFW*/ MMVERSION		1
#define /*VFW*/ MMREVISION		15
#define /*VFW*/ MMRELEASE		1

#ifdef RC_INVOKED
#define VERSIONPRODUCTNAME	"Microsoft Video for Windows\0"
#define VERSIONCOPYRIGHT	"Copyright \251 Microsoft Corp. 1992-1994\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*VFW*/ VERSIONSTR	"VfW Retail Debug Version 1.15.1\0"
#elif defined(DEBUG)
#define /*VFW*/ VERSIONSTR	"VfW Internal Debug Version 1.15.1\0"
#else
#define /*VFW*/ VERSIONSTR	"1.15\0"
#endif

#endif

/***************************************************************************
 *  DO NOT TOUCH BELOW THIS LINE                                           *
 ***************************************************************************/

#ifdef RC_INVOKED
#define VERSIONCOMPANYNAME	"Microsoft Corporation\0"

/*
 *  Version flags
 */

#ifndef OFFICIAL
#define VER_PRIVATEBUILD	VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD	0
#endif

#ifndef FINAL
#define VER_PRERELEASE		VS_FF_PRERELEASE
#else
#define VER_PRERELEASE		0
#endif

#if defined(DEBUG_RETAIL)
#define VER_DEBUG		VS_FF_DEBUG
#elif defined(DEBUG)
#define VER_DEBUG		VS_FF_DEBUG
#else
#define VER_DEBUG		0
#endif

#define VERSIONFLAGS		(VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)
#define VERSIONFILEFLAGSMASK	0x0030003FL

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvideo.16\video.c ===
/****************************************************************************
    video.c

    Contains video APIs

    Copyright (c) Microsoft Corporation 1992. All rights reserved

****************************************************************************/

#include <windows.h>
#include <mmsystem.h>

#include "win32.h"
#include "msviddrv.h"
#include "msvideo.h"
#include "msvideoi.h"
#ifdef WIN32
#include <mmddk.h>
#endif

#include <ver.h>

#ifndef NOTHUNKS
#include "thunks.h"
#endif //!NOTHUNKS

/*****************************************************************************
 * Variables
 *
 ****************************************************************************/

SZCODE  szNull[]        = TEXT("");
SZCODE  szVideo[]       = TEXT("msvideo");
#ifndef WIN32
SZCODE  szDrivers[]     = "Drivers";
SZCODE  szDrivers32[]   = "Drivers32";
#else
STATICDT SZCODE  szDrivers[]     = DRIVERS_SECTION;
#endif

STATICDT SZCODE  szSystemIni[]   = TEXT("system.ini");

UINT    wTotalVideoDevs;                  // total video devices
UINT	wVideoDevs32;			  // 32-bit video devices
UINT    bVideo0Invalid;			  // if true: ignore MSVideo
					  // (see videoGetNumDevs)
HINSTANCE ghInst;                         // our module handle


/*****************************************************************************
 * @doc INTERNAL  VIDEO validation code for VIDEOHDRs
 ****************************************************************************/

#define IsVideoHeaderPrepared(hVideo, lpwh)      ((lpwh)->dwFlags &  VHDR_PREPARED)
#define MarkVideoHeaderPrepared(hVideo, lpwh)    ((lpwh)->dwFlags |= VHDR_PREPARED)
#define MarkVideoHeaderUnprepared(hVideo, lpwh)  ((lpwh)->dwFlags &=~VHDR_PREPARED)



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @func DWORD | videoMessage | This function sends messages to a
 *   video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies the handle to the video device channel.
 *
 * @parm UINT | wMsg | Specifies the message to send.
 *
 * @parm DWORD | dwP1 | Specifies the first parameter for the message.
 *
 * @parm DWORD | dwP2 | Specifies the second parameter for the message.
 *
 * @rdesc Returns the message specific value returned from the driver.
 *
 * @comm This function is used for configuration messages such as
 *      <m DVM_SRC_RECT> and <m DVM_DST_RECT>, and
 *      device specific messages.
 *
 * @xref <f videoConfigure>
 *
 ****************************************************************************/
DWORD WINAPI videoMessage(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

#ifndef NOTHUNKS
    if (Is32bitHandle(hVideo)) {
        return videoMessage32(Map32bitHandle(hVideo), msg, dwP1, dwP2);
    }
#endif
    return SendDriverMessage (hVideo, msg, dwP1, dwP2);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoGetNumDevs | This function returns the number of MSVIDEO
 *   devices installed.
 *
 * @rdesc Returns the number of MSVIDEO devices listed in the
 *  [drivers] (or [drivers32] for NT) section of the SYSTEM.INI file.
 *
 * @comm Because the indexes of the MSVIDEO devices in the SYSTEM.INI
 *       file can be non-contiguous, applications should not assume
 *       the indexes range between zero and the number of devices minus
 *       one.
 *
 * @xref <f videoOpen>
 ****************************************************************************/
DWORD WINAPI videoGetNumDevs(void)
{
    TCHAR szKey[(sizeof(szVideo)/sizeof(TCHAR)) + 2];
    TCHAR szbuf[128];
    TCHAR szMSVideo32[128];
    int i;

#ifndef NOTHUNKS
	
    // find how many 32-bit devices there are. indices 0 to wVideoDevs32
    // will be on the 32-bit side, and wVideoDevs32 to wTotalVideoDevs on the
    // 16-bit side
    wVideoDevs32 = (UINT)videoGetNumDevs32();
    wTotalVideoDevs = wVideoDevs32;

    // now add in the 16-bit devices
#else
    wTotalVideoDevs = 0;
#endif

    // NT 3.5 shipped with a hack solution to the capGetDriverDescription
    // problem which was to copy the MSVideo line from [Drivers32] to
    // [Drivers]

    // we now have to allow for this hack by detecting the case where the two
    // entries are the same. We then set bVideo0Invalid, and do not include it
    // in wTotalVideoDevs.


    bVideo0Invalid = FALSE;

    lstrcpy(szKey, szVideo);
    szKey[(sizeof(szVideo)/sizeof(TCHAR)) - 1] = (TCHAR) 0;
    szKey[sizeof(szVideo)/sizeof(TCHAR)] = (TCHAR) 0;

    // first read the [drivers32] MSVideo to compare against
    GetPrivateProfileString(szDrivers32, szKey, szNull, szMSVideo32,
    	sizeof(szMSVideo32)/sizeof(TCHAR), szSystemIni);

    // now read the [Drivers] entries - compare the first one against this

    for (i=0; i < MAXVIDEODRIVERS; i++) {
        if (GetPrivateProfileString(szDrivers,szKey,szNull,
                szbuf,sizeof(szbuf)/sizeof(TCHAR),szSystemIni)) {

	    if ((i == 0) && (lstrcmp(szbuf, szMSVideo32) == 0)) {
		bVideo0Invalid = TRUE;
	    } else {
		wTotalVideoDevs++;
	    }
	}

        szKey[(sizeof(szVideo)/sizeof(TCHAR))-1] = (TCHAR) TEXT('1'+ i); // advance driver ordinal
    }
    return (DWORD)wTotalVideoDevs;
}

/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoGetErrorText | This function retrieves a
 *   description of the error identified by the error number.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *	This might be NULL if the error is not device specific.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPSTR | lpText | Specifies a far pointer to a buffer used to
 *       return the zero-terminated string corresponding to the error number.
 *
 * @parm UINT | wSize | Specifies the length, in bytes, of the buffer
 *       referenced by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following error is defined:
 *   @flag DV_ERR_BADERRNUM | Specified error number is out of range.
 *   @flag DV_ERR_SIZEFIELD | The return buffer is not large enough
 *         to handle the error text.
 *
 * @comm If the error description is longer than the buffer,
 *   the description is truncated. The returned error string is always
 *   zero-terminated. If <p wSize> is zero, nothing is copied and zero
 *   is returned.
 ****************************************************************************/
DWORD WINAPI videoGetErrorText(HVIDEO hVideo, UINT wError,
			LPSTR lpText, UINT wSize)
{
    VIDEO_GETERRORTEXT_PARMS vet;

    if (IsBadWritePtr (lpText, wSize))
        return DV_ERR_PARAM1;

    lpText[0] = 0;
    if (((wError >= DV_ERR_BASE) && (wError <= DV_ERR_LASTERROR))) {
        if (wSize > 1) {
            if (!LoadStringA(ghInst, wError, lpText, wSize))
                return DV_ERR_BADERRNUM;
            else
                return DV_ERR_OK;
        }
        else
            return DV_ERR_SIZEFIELD;
    }
    else if (wError >= DV_ERR_USER_MSG && hVideo) {
        vet.dwError = (DWORD) wError;
        vet.lpText = lpText;
        vet.dwLength = (DWORD) wSize;
        return videoMessage (hVideo, DVM_GETERRORTEXT, (DWORD) (LPVOID) &vet,
                        (DWORD) NULL);
    }
    else
        return DV_ERR_BADERRNUM;
}


/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoGetChannelCaps | This function retrieves a
 *   description of the capabilities of a channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPCHANNEL_CAPS | lpChannelCaps | Specifies a far pointer to a
 *      <t CHANNEL_CAPS> structure.
 *
 * @parm DWORD | dwSize | Specifies the size, in bytes, of the
 *       <t CHANNEL_CAPS> structure.
 *
 * @rdesc Returns zero if the function is successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_UNSUPPORTED | Function is not supported.
 *
 * @comm The <t CHANNEL_CAPS> structure returns the capability
 *   information. For example, capability information might
 *   include whether or not the channel can crop and scale images,
 *   or show overlay.
 ****************************************************************************/
DWORD WINAPI videoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps,
			DWORD dwSize)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpChannelCaps, sizeof (CHANNEL_CAPS)))
        return DV_ERR_PARAM1;

    // _fmemset (lpChannelCaps, 0, sizeof (CHANNEL_CAPS));

    lpChannelCaps->dwFlags = 0;
    lpChannelCaps->dwSrcRectXMod = 0;
    lpChannelCaps->dwSrcRectYMod = 0;
    lpChannelCaps->dwSrcRectWidthMod = 0;
    lpChannelCaps->dwSrcRectHeightMod = 0;
    lpChannelCaps->dwDstRectXMod = 0;
    lpChannelCaps->dwDstRectYMod = 0;
    lpChannelCaps->dwDstRectWidthMod = 0;
    lpChannelCaps->dwDstRectHeightMod = 0;

    return videoMessage(hVideo, DVM_GET_CHANNEL_CAPS, (DWORD) lpChannelCaps,
	    (DWORD) dwSize);
}


/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoUpdate | This function directs a channel to
 *   repaint the display.  It applies only to VIDEO_EXTERNALOUT channels.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm HWND | hWnd | Specifies the handle of the window to be used
 *      by the channel for image display.
 *
 * @parm HDC | hDC | Specifies a handle to a device context.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_UNSUPPORTED | Specified message is unsupported.
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 * @comm This message is normally sent
 *   whenever the client window receives a <m WM_MOVE>, <m WM_SIZE>,
 *   or <m WM_PAINT> message.
 ****************************************************************************/
DWORD WINAPI videoUpdate (HVIDEO hVideo, HWND hWnd, HDC hDC)
{
    if ((!hVideo) || (!hWnd) || (!hDC) )
        return DV_ERR_INVALHANDLE;

    return videoMessage(hVideo, DVM_UPDATE, (DWORD) hWnd, (DWORD) hDC);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoOpen | This function opens a channel on the
 *  specified video device.
 *
 * @parm LPHVIDEO | lphvideo | Specifies a far pointer to a buffer
 *   used to return an <t HVIDEO> handle. The video capture driver
 *   uses this location to return
 *   a handle that uniquely identifies the opened video device channel.
 *   Use the returned handle to identify the device channel when
 *   calling other video functions.
 *
 * @parm DWORD | dwDeviceID | Identifies the video device to open.
 *      The value of <p dwDeviceID> varies from zero to one less
 *      than the number of video capture devices installed in the system.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device.
 *      The following flags are defined:
 *
 *   @flag VIDEO_EXTERNALIN| Specifies the channel is opened
 *	     for external input. Typically, external input channels
 *      capture images into a frame buffer.
 *
 *   @flag VIDEO_EXTERNALOUT| Specifies the channel is opened
 *      for external output. Typically, external output channels
 *      display images stored in a frame buffer on an auxilary monitor
 *      or overlay.
 *
 *   @flag VIDEO_IN| Specifies the channel is opened
 *      for video input. Video input channels transfer images
 *      from a frame buffer to system memory buffers.
 *
 *   @flag VIDEO_OUT| Specifies the channel is opened
 *      for video output. Video output channels transfer images
 *      from system memory buffers to a frame buffer.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_BADDEVICEID | Indicates the specified device ID is out of range.
 *   @flag DV_ERR_ALLOCATED | Indicates the specified resource is already allocated.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm
 *   At a minimum, all capture drivers support a VIDEO_EXTERNALIN
 *   and a VIDEO_IN channel.
 *   Use <f videoGetNumDevs> to determine the number of video
 *   devices present in the system.
 *
 * @xref <f videoClose>
 ****************************************************************************/
DWORD WINAPI videoOpen (LPHVIDEO lphVideo, DWORD dwDeviceID, DWORD dwFlags)
{
    TCHAR szKey[sizeof(szVideo)/sizeof(TCHAR) + 2];
    TCHAR szbuf[128];
    UINT w;
    VIDEO_OPEN_PARMS vop;       // Same as IC_OPEN struct!!!
    DWORD dwVersion = VIDEOAPIVERSION;

    if (IsBadWritePtr ((LPVOID) lphVideo, sizeof (HVIDEO)) )
        return DV_ERR_PARAM1;

    vop.dwSize = sizeof (VIDEO_OPEN_PARMS);
    vop.fccType = OPEN_TYPE_VCAP;       // "vcap"
    vop.fccComp = 0L;
    vop.dwVersion = VIDEOAPIVERSION;
    vop.dwFlags = dwFlags;      // In, Out, External In, External Out
    vop.dwError = DV_ERR_OK;

    w = (WORD)dwDeviceID;
    *lphVideo = NULL;

    if (!wTotalVideoDevs)   // trying to open without finding how many devs.
        videoGetNumDevs();

    if (!wTotalVideoDevs)              // No drivers installed
        return DV_ERR_BADINSTALL;

    if (w >= MAXVIDEODRIVERS)
        return DV_ERR_BADDEVICEID;

#ifndef NOTHUNKS
    //
    // if it's one of the 32-bit indices then we must open it on the
    // 32-bit side or fail.
    //

    if (w < wVideoDevs32) {
	return videoOpen32( lphVideo, dwDeviceID, dwFlags);
    } else {
	// make it a valid 16-bit index
	w -= wVideoDevs32;
    }
#endif // NOTHUNKS


    // ignore the fake MSVideo copied from [Drivers32]
    if (bVideo0Invalid) {
	w++;
    }


    lstrcpy(szKey, szVideo);
    szKey[(sizeof(szVideo)/sizeof(TCHAR)) - 1] = (TCHAR)0;
    if( w > 0 ) {
        szKey[(sizeof(szVideo)/sizeof(TCHAR))] = (TCHAR)0;
        szKey[(sizeof(szVideo)/sizeof(TCHAR))-1] = (TCHAR) TEXT('1' + (w-1) );  // driver ordinal
    }
    if (GetPrivateProfileString(szDrivers, szKey, szNull,
                szbuf, sizeof(szbuf)/sizeof(TCHAR), szSystemIni)) {

#ifdef THIS_IS_ANCIENT_CODE
        // Removed for VFW1.1
        // Only early Alpha 1.0 drivers required this...

        // Check driver version number by doing a configuration open...
        // Version 1 used LPARAM = dwFlags
        // Version 2 uses LPARAM = LPVIDEO_OPEN_PARMS

        if (hVideoTemp = OpenDriver(szKey, szDrivers, (LPARAM) NULL)) {
            HVIDEO hVideoTemp;

            // Version 1 drivers had the added bug of returning
            // the version from this message, instead of in
            // lParam1
            if (videoMessage (hVideoTemp, DVM_GETVIDEOAPIVER,
                        (LPARAM) (LPVOID) &dwVersion, 0L) == 1)
                dwVersion = 1;
            CloseDriver(hVideoTemp, 0L, 0L );
        }

        if (dwVersion == 1)
            *lphVideo = OpenDriver(szKey, szDrivers, dwFlags);
        else
#endif // THIS_IS_ANCIENT_CODE

        *lphVideo = OpenDriver(szKey, szDrivers, (LPARAM) (LPVOID) &vop);

	if( ! *lphVideo ) {
            if (vop.dwError)    // if driver returned an error code...
                return vop.dwError;
            else {
#ifdef WIN32
		if (GetFileAttributes(szbuf) == (DWORD) -1)
#else
                OFSTRUCT of;

                if (OpenFile (szbuf, &of, OF_EXIST) == HFILE_ERROR)
#endif
                    return (DV_ERR_BADINSTALL);
                else
                    return (DV_ERR_NOTDETECTED);
            }
	}
    } else {
        return( DV_ERR_BADINSTALL );
    }

    return DV_ERR_OK;

}


typedef struct tagVS_VERSION
{
    WORD wTotLen;
    WORD wValLen;
    TCHAR szSig[16];
    VS_FIXEDFILEINFO vffInfo;
} VS_VERSION;

//
// videoGetDriverDesc -
//
// private api to correctly thunk avicap's capGetDriverDescription.
//
// if the index is < wVideoDevs32, then thunk the call through to the
// 32-bit side, otherwise do it here by scanning [drivers].
//

DWORD WINAPI videoCapDriverDescAndVer (
        DWORD wDriverIndex,
        LPSTR lpszName, UINT cbName,
        LPSTR lpszVer, UINT cbVer)
{
    LPTSTR   lpVersion;
    UINT    wVersionLen;
    BOOL    bRetCode;
    TCHAR   szGetName[MAX_PATH];
    DWORD   dwVerInfoSize;
    DWORD   dwVerHnd;
    TCHAR   szBuf[MAX_PATH];
    BOOL    fGetName;
    BOOL    fGetVersion;

    static TCHAR szNull[]        = TEXT("");
    static TCHAR szVideo[]       = TEXT("msvideo");
    static TCHAR szSystemIni[]   = TEXT("system.ini");
    static TCHAR szDrivers[]     = TEXT("Drivers");
    static TCHAR szKey[sizeof(szVideo)/sizeof(TCHAR) + 2];

    static TCHAR szVer[]         = TEXT("ver.dll");
    static TCHAR szGetFileVerInfo[] = TEXT("GetFileVersionInfo");
    static TCHAR szGetFileVerInfoSize[] = TEXT("GetFileVersionInfoSize");
    static TCHAR szVerQueryValue[] = TEXT("VerQueryValue");

    typedef BOOL (WINAPI FAR *LPVERQUERYVALUE)(
        const void FAR* pBlock,
        LPCSTR lpSubBlock,
        void FAR* FAR* lplpBuffer,
        UINT FAR* lpuLen
        );

    typedef BOOL (WINAPI FAR *LPGETFILEVERSIONINFO)(
        LPCSTR lpstrFilename,
        DWORD dwHandle,
        DWORD dwLen,
        void FAR* lpData
        );

    typedef DWORD (WINAPI FAR *LPGETFILEVERSIONINFOSIZE)(
        LPCSTR lpstrFilename,
        DWORD FAR *lpdwHandle
        );

    LPGETFILEVERSIONINFOSIZE lpfnGetFileVersionInfoSize;
    LPGETFILEVERSIONINFO     lpfnGetFileVersionInfo;
    LPVERQUERYVALUE          lpfnVerQueryValue;

    HINSTANCE                hinstVer;


#ifndef NOTHUNKS

    // must have called videoGetNumDevs first before thunking
    if (!wTotalVideoDevs) {
	videoGetNumDevs();
    }


    if (wDriverIndex < wVideoDevs32) {
	return videoGetDriverDesc32(wDriverIndex, lpszName, (short) cbName,
			lpszVer, (short) cbVer);
    } else {
	wDriverIndex -= wVideoDevs32;
	if (bVideo0Invalid) {
	    wDriverIndex++;
	}
    }
#endif

    //this is a 16-bit driver - search [Drivers] for it

    fGetName = lpszName != NULL && cbName != 0;
    fGetVersion = lpszVer != NULL && cbVer != 0;

    if (fGetName)
        lpszName[0] = TEXT('\0');
    if (fGetVersion)
        lpszVer [0] = TEXT('\0');

    lstrcpy(szKey, szVideo);
    szKey[sizeof(szVideo)/sizeof(TCHAR) - 1] = TEXT('\0');
    if( wDriverIndex > 0 ) {
        szKey[sizeof(szVideo)/sizeof(TCHAR)] = TEXT('\0');
        szKey[(sizeof(szVideo)/sizeof(TCHAR))-1] = (TCHAR)(TEXT('1') + (wDriverIndex-1) );  // driver ordinal
    }

    if (GetPrivateProfileString(szDrivers, szKey, szNull,
                szBuf, sizeof(szBuf)/sizeof(TCHAR), szSystemIni) < 2)
        return FALSE;

    // Copy in the driver name initially, just in case the driver
    // has omitted a description field.
    if (fGetName)
        lstrcpyn(lpszName, szBuf, cbName);


    hinstVer = LoadLibrary(szVer);
    if ( hinstVer == NULL) {
        return FALSE;
    }

    *(FARPROC *)&lpfnGetFileVersionInfoSize =
        GetProcAddress(hinstVer, szGetFileVerInfoSize);

    *(FARPROC *)&lpfnGetFileVersionInfo =
        GetProcAddress(hinstVer, szGetFileVerInfo);

    *(FARPROC *)&lpfnVerQueryValue =
        GetProcAddress(hinstVer, szVerQueryValue );

#if 0
    {
        char szBuffer[256];

        wsprintf( szBuffer, "hinstVer = %#X\r\n", hinstVer );
        OutputDebugString(szBuffer);

        wsprintf( szBuffer, "lpfnGetFileVersionInfoSize = %#X\r\n",
                  lpfnGetFileVersionInfoSize );
        OutputDebugString(szBuffer);

        wsprintf( szBuffer, "lpfnGetFileVersionInfo = %#X\r\n",
                  lpfnGetFileVersionInfo );
        OutputDebugString(szBuffer);

        wsprintf( szBuffer, "lpfnVerQueryValue = %#X\r\n",
                  lpfnVerQueryValue );
        OutputDebugString(szBuffer);

    }
#endif

    // You must find the size first before getting any file info
    dwVerInfoSize =
        (*lpfnGetFileVersionInfoSize)(szBuf, &dwVerHnd);

    if (dwVerInfoSize) {
        LPTSTR   lpstrVffInfo;             // Pointer to block to hold info
        HANDLE  hMem;                     // handle to mem alloc'ed

        // Get a block big enough to hold version info
        hMem          = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize);
        lpstrVffInfo  = GlobalLock(hMem);

        // Get the File Version first
        if( (*lpfnGetFileVersionInfo)(szBuf, 0L, dwVerInfoSize, lpstrVffInfo)) {
             VS_VERSION FAR *pVerInfo = (VS_VERSION FAR *) lpstrVffInfo;

             // fill in the file version
             wsprintf(szBuf,
                      TEXT("Version:  %d.%d.%d.%d"),
                      HIWORD(pVerInfo->vffInfo.dwFileVersionMS),
                      LOWORD(pVerInfo->vffInfo.dwFileVersionMS),
                      HIWORD(pVerInfo->vffInfo.dwFileVersionLS),
                      LOWORD(pVerInfo->vffInfo.dwFileVersionLS));
             if (fGetVersion)
                lstrcpyn (lpszVer, szBuf, cbVer);
        }

        // Now try to get the FileDescription
        // First try this for the "Translation" entry, and then
        // try the American english translation.
        // Keep track of the string length for easy updating.
        // 040904E4 represents the language ID and the four
        // least significant digits represent the codepage for
        // which the data is formatted.  The language ID is
        // composed of two parts: the low ten bits represent
        // the major language and the high six bits represent
        // the sub language.

        lstrcpy(szGetName, TEXT("\\StringFileInfo\\040904E4\\FileDescription"));

        wVersionLen   = 0;
        lpVersion     = NULL;

        // Look for the corresponding string.
        bRetCode      =  (*lpfnVerQueryValue)((LPVOID)lpstrVffInfo,
                        (LPTSTR)szGetName,
                        (void FAR* FAR*)&lpVersion,
                        (UINT FAR *) &wVersionLen);

        if (fGetName && bRetCode && wVersionLen && lpVersion)
           lstrcpyn (lpszName, lpVersion, cbName);

        // Let go of the memory
        GlobalUnlock(hMem);
        GlobalFree(hMem);
    }

    FreeLibrary(hinstVer);

    return TRUE;


}



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoClose | This function closes the specified video
 *   device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *  If this function is successful, the handle is invalid
 *   after this call.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NONSPECIFIC | The driver failed to close the channel.
 *
 * @comm If buffers have been sent with <f videoStreamAddBuffer> and
 *   they haven't been returned to the application,
 *   the close operation fails. You can use <f videoStreamReset> to mark all
 *   pending buffers as done.
 *
 * @xref <f videoOpen> <f videoStreamInit> <f videoStreamFini> <f videoStreamReset>
 ****************************************************************************/
DWORD WINAPI videoClose (HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

#ifndef NOTHUNKS
    if (Is32bitHandle(hVideo)) {
        return videoClose32(Map32bitHandle(hVideo));
    }
#endif // NOTHUNKS
    return (CloseDriver(hVideo, 0L, 0L ) ? DV_ERR_OK : DV_ERR_NONSPECIFIC);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoConfigure | This function sets or retrieves
 *      the options for a configurable driver.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm UINT | msg  | Specifies the option to set or retrieve. The
 *       following options are defined:
 *
 *   @flag DVM_PALETTE | Indicates a palette is being sent to the driver
 *         or retrieved from the driver.
 *
 *   @flag DVM_PALETTERGB555 | Indicates an RGB555 palette is being
 *         sent to the driver.
 *
 *   @flag DVM_FORMAT | Indicates format information is being sent to
 *         the driver or retrieved from the driver.
 *
 * @parm DWORD | dwFlags | Specifies flags for configuring or
 *   interrogating the device driver. The following flags are defined:
 *
 *   @flag VIDEO_CONFIGURE_SET | Indicates values are being sent to the driver.
 *
 *   @flag VIDEO_CONFIGURE_GET | Indicates values are being obtained from the driver.
 *
 *   @flag VIDEO_CONFIGURE_QUERY | Determines if the
 *      driver supports the option specified by <p msg>. This flag
 *      should be combined with either the VIDEO_CONFIGURE_SET or
 *      VIDEO_CONFIGURE_GET flag. If this flag is
 *      set, the <p lpData1>, <p dwSize1>, <p lpData2>, and <p dwSize2>
 *      parameters are ignored.
 *
 *   @flag VIDEO_CONFIGURE_QUERYSIZE | Returns the size, in bytes,
 *      of the configuration option in <p lpdwReturn>. This flag is only valid if
 *      the VIDEO_CONFIGURE_GET flag is also set.
 *
 *   @flag VIDEO_CONFIGURE_CURRENT | Requests the current value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_NOMINAL | Requests the nominal value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_MIN | Requests the minimum value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_MAX | Get the maximum value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *	
 * @parm LPDWORD | lpdwReturn  | Points to a DWORD used for returning information
 *      from the driver.  If
 *      the VIDEO_CONFIGURE_QUERYSIZE flag is set, <p lpdwReturn> is
 *      filled with the size of the configuration option.
 *
 * @parm LPVOID | lpData1  |Specifies a pointer to message specific data.
 *
 * @parm DWORD | dwSize1  | Specifies the size, in bytes, of the <p lpData1>
 *       buffer.
 *
 * @parm LPVOID | lpData2  | Specifies a pointer to message specific data.
 *
 * @parm DWORD | dwSize2  | Specifies the size, in bytes, of the <p lpData2>
 *       buffer.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @xref <f videoOpen> <f videoMessage>
 *
 ****************************************************************************/
DWORD WINAPI videoConfigure (HVIDEO hVideo, UINT msg, DWORD dwFlags,
		LPDWORD lpdwReturn, LPVOID lpData1, DWORD dwSize1,
                LPVOID lpData2, DWORD dwSize2)
{
    VIDEOCONFIGPARMS    vcp;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (lpData1)
        if (IsBadHugeReadPtr (lpData1, dwSize1))
            return DV_ERR_CONFIG1;

    if (lpData2)
        if (IsBadHugeReadPtr (lpData2, dwSize2))
            return DV_ERR_CONFIG2;

    if (dwFlags & VIDEO_CONFIGURE_QUERYSIZE) {
        if (!lpdwReturn)
            return DV_ERR_NONSPECIFIC;
        if (IsBadWritePtr (lpdwReturn, sizeof (DWORD)) )
            return DV_ERR_NONSPECIFIC;
    }

    vcp.lpdwReturn = lpdwReturn;
    vcp.lpData1 = lpData1;
    vcp.dwSize1 = dwSize1;
    vcp.lpData2 = lpData2;
    vcp.dwSize2 = dwSize2;

    return videoMessage(hVideo, msg, dwFlags,
	    (DWORD)(LPVIDEOCONFIGPARMS)&vcp );
}



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoConfigureStorage | This function saves or loads
 *	     all configurable options for a channel.  Options
 *      can be saved and recalled for each application or each application
 *      instance.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPSTR | lpstrIdent  | Identifies the application or instance.
 *      Use an arbitrary string which uniquely identifies your application
 *      or instance.
 *
 * @parm DWORD | dwFlags | Specifies any flags for the function. The following
 *   flags are defined:
 *   @flag VIDEO_CONFIGURE_GET | Requests that the values be loaded.
 *   @flag VIDEO_CONFIGURE_SET | Requests that the values be saved.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @comm The method used by a driver to save configuration options is
 *      device dependent.
 *
 * @xref <f videoOpen>
 ****************************************************************************/
DWORD WINAPI videoConfigureStorage (HVIDEO hVideo,
			LPSTR lpstrIdent, DWORD dwFlags)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return videoMessage(hVideo, DVM_CONFIGURESTORAGE,
	    (DWORD)lpstrIdent, dwFlags);
}




/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoDialog | This function displays a channel-specific
 *     dialog box used to set configuration parameters.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm HWND | hWndParent | Specifies the parent window handle.
 *
 * @parm DWORD | dwFlags | Specifies flags for the dialog box. The
 *   following flag is defined:
 *   @flag VIDEO_DLG_QUERY | If this flag is set, the driver immediately
 *	     returns zero if it supplies a dialog box for the channel,
 *           or DV_ERR_NOTSUPPORTED if it does not.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @comm Typically, each dialog box displayed by this
 *      function lets the user select options appropriate for the channel.
 *      For example, a VIDEO_IN channel dialog box lets the user select
 *      the image dimensions and bit depth.
 *
 * @xref <f videoOpen> <f videoConfigureStorage>
 ****************************************************************************/
DWORD WINAPI videoDialog (HVIDEO hVideo, HWND hWndParent, DWORD dwFlags)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if ((!hWndParent) || (!IsWindow (hWndParent)) )
        return DV_ERR_INVALHANDLE;

    return videoMessage(hVideo, DVM_DIALOG, (DWORD)hWndParent, dwFlags);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////


/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api DWORD | videoPrepareHeader | This function prepares the
 *	header and data
 *	by performing a <f GlobalPageLock>.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it
 *   specifies an error number.
 ****************************************************************************/
DWORD WINAPI videoPrepareHeader(LPVIDEOHDR lpVideoHdr, DWORD dwSize)
{
    if (!HugePageLock(lpVideoHdr, (DWORD)sizeof(VIDEOHDR)))
        return DV_ERR_NOMEM;

    if (!HugePageLock(lpVideoHdr->lpData, lpVideoHdr->dwBufferLength)) {
        HugePageUnlock(lpVideoHdr, (DWORD)sizeof(VIDEOHDR));
        return DV_ERR_NOMEM;
    }

    lpVideoHdr->dwFlags |= VHDR_PREPARED;

    return DV_ERR_OK;
}

/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api DWORD | videoUnprepareHeader | This function unprepares the header and
 *   data if the driver returns DV_ERR_NOTSUPPORTED.
 *
 * @rdesc Currently always returns DV_ERR_OK.
 ****************************************************************************/
DWORD WINAPI videoUnprepareHeader(LPVIDEOHDR lpVideoHdr, DWORD dwSize)
{

    HugePageUnlock(lpVideoHdr->lpData, lpVideoHdr->dwBufferLength);
    HugePageUnlock(lpVideoHdr, (DWORD)sizeof(VIDEOHDR));

    lpVideoHdr->dwFlags &= ~VHDR_PREPARED;

    return DV_ERR_OK;
}

//////////////////////////////////////////////////////////////////////////
/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamAllocHdrAndBuffer | This function is used to allow
 *      drivers to optionally allocate video buffers.  Normally, the client
 *      application is responsible for allocating buffer memory, but devices
 *      which have on-board memory may optionally allocate headers and buffers
 *      using this function. Generally, this will avoid an additional data copy,
 *      resulting in faster capture rates.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR FAR * | plpvideoHdr | Specifies a pointer to the address of a
 *   <t VIDEOHDR> structure.  The driver saves the buffer address in this
 *   location, or NULL if it cannot allocate a buffer.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure
 *      and associated video buffer in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the driver does not have on-board memory.
 *
 * @comm If the driver
 *   allocates buffers via this method, the <f videoStreamPrepareHeader> and
 *   <f videoStreamUnprepareHeader> functions must not be used.
 *
 *   The buffer allocated must be accessible for DMA by the host.
 *
 * @xref <f videoStreamFreeHdrAndBuffer>
 ****************************************************************************/
DWORD WINAPI videoStreamAllocHdrAndBuffer(HVIDEO hVideo,
		LPVIDEOHDR FAR * plpvideoHdr, DWORD dwSize)
{

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return(DV_ERR_NOTSUPPORTED);
#if 0
    if (IsBadWritePtr (plpvideoHdr, sizeof (VIDEOHDR *)) )
        return DV_ERR_PARAM1;

    *plpvideoHdr = NULL;        // Init to NULL ptr

    wRet = (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_ALLOCHDRANDBUFFER,
            (DWORD)plpvideoHdr, (DWORD)dwSize);

    if (*plpvideoHdr == NULL ||
                IsBadHugeWritePtr (*plpvideoHdr, dwSize)) {
        DebugErr(DBF_WARNING,"videoStreamAllocHdrAndBuffer: Allocation failed.");
        *plpvideoHdr = NULL;
        return wRet;
    }

    if (IsVideoHeaderPrepared(HVIDEO, *plpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamAllocHdrAndBuffer: header is already prepared.");
        return DV_ERR_OK;
    }

    (*plpvideoHdr)->dwFlags = 0;

    if (wRet == DV_ERR_OK)
        MarkVideoHeaderPrepared(hVideo, *plpvideoHdr);

    return wRet;
#endif
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamFreeHdrAndBuffer | This function is used to free
 *      buffers allocated by the driver using the <f videoStreamAllocHdrAndBuffer>
 *      function.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr | Specifies a pointer to the
 *   <t VIDEOHDR> structure and associated buffer to be freed.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the driver does not have on-board memory.
 *
 * @comm If the driver
 *   allocates buffers via this method, the <f videoStreamPrepareHeader> and
 *   <f videoStreamUnprepareHeader> functions must not be used.
 *
 * @xref <f videoStreamAllocHdrAndBuffer>
 ****************************************************************************/

DWORD WINAPI videoStreamFreeHdrAndBuffer(HVIDEO hVideo,
		LPVIDEOHDR lpvideoHdr)
{

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return(DV_ERR_NOTSUPPORTED);
#if 0
    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (lpvideoHdr->dwFlags & VHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "videoStreamFreeHdrAndBuffer: buffer still in queue.");
        return DV_ERR_STILLPLAYING;
    }

    if (!IsVideoHeaderPrepared(hVideo, lpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamFreeHdrAndBuffer: header is not prepared.");
    }

    wRet = (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_FREEHDRANDBUFFER,
            (DWORD)lpvideoHdr, (DWORD)0);

    if (wRet != DV_ERR_OK)
    {
        DebugErr(DBF_WARNING,"videoStreamFreeHdrAndBuffer: Error freeing buffer.");
    }

    return wRet;
#endif
}

//////////////////////////////////////////////////////////////////////////


/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamPrepareHeader | This function prepares a buffer
 *   for video streaming.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr | Specifies a pointer to a
 *   <t VIDEOHDR> structure identifying the buffer to be prepared.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm Use this function after <f videoStreamInit> or
 *   after <f videoStreamReset> to prepare the data buffers
 *   for streaming data.
 *
 *   The <t VIDEOHDR> data structure and the data block pointed to by its
 *   <e VIDEOHDR.lpData> member must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags, and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared will have no effect
 *   and the function will return zero. Typically, this function is used
 *   to ensure that the buffer will be available for use at interrupt time.
 *
 * @xref <f videoStreamUnprepareHeader>
 ****************************************************************************/
DWORD WINAPI videoStreamPrepareHeader(HVIDEO hVideo,
		LPVIDEOHDR lpvideoHdr, DWORD dwSize)
{
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (IsVideoHeaderPrepared(HVIDEO, lpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamPrepareHeader: header is already prepared.");
        return DV_ERR_OK;
    }

    lpvideoHdr->dwFlags = 0;

    wRet = (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_PREPAREHEADER,
            (DWORD)lpvideoHdr, (DWORD)dwSize);

#ifndef NOTHUNKS
    //
    // 32-bit side can't do the locking but needs it locked
    //
    if (wRet == DV_ERR_OK && Is32bitHandle(hVideo))
        wRet = videoPrepareHeader(lpvideoHdr, dwSize);
#endif // NOTHUNKS

    if (wRet == DV_ERR_NOTSUPPORTED)
        wRet = videoPrepareHeader(lpvideoHdr, dwSize);

    if (wRet == DV_ERR_OK)
        MarkVideoHeaderPrepared(hVideo, lpvideoHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamUnprepareHeader | This function clears the
 *  preparation performed by <f videoStreamPrepareHeader>.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr |  Specifies a pointer to a <t VIDEOHDR>
 *   structure identifying the data buffer to be unprepared.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_STILLPLAYING | Indicates the structure identified by <p lpvideoHdr>
 *   is still in the queue.
 *
 * @comm This function is the complementary function to <f videoStreamPrepareHeader>.
 *   You must call this function before freeing the data buffer with <f GlobalFree>.
 *   After passing a buffer to the device driver with <f videoStreamAddBuffer>, you
 *   must wait until the driver is finished with the buffer before calling
 *   <f videoStreamUnprepareHeader>. Unpreparing a buffer that has not been
 *   prepared or has been already unprepared has no effect,
 *   and the function returns zero.
 *
 * @xref <f videoStreamPrepareHeader>
 ****************************************************************************/
DWORD WINAPI videoStreamUnprepareHeader(HVIDEO hVideo, LPVIDEOHDR lpvideoHdr, DWORD dwSize)
{
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (lpvideoHdr->dwFlags & VHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "videoStreamUnprepareHeader: buffer still in queue.");
        return DV_ERR_STILLPLAYING;
    }

    if (!IsVideoHeaderPrepared(hVideo, lpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamUnprepareHeader: header is not prepared.");
        return DV_ERR_OK;
    }

    wRet = (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_UNPREPAREHEADER,
            (DWORD)lpvideoHdr, (DWORD)dwSize);

#ifndef NOTHUNKS
    //
    // 32-bit side can't do the unlocking but needs it unlocked
    //
    if (wRet == DV_ERR_OK && Is32bitHandle(hVideo))
        wRet = videoUnprepareHeader(lpvideoHdr, dwSize);
#endif // NOTHUNKS

    if (wRet == DV_ERR_NOTSUPPORTED)
        wRet = videoUnprepareHeader(lpvideoHdr, dwSize);

    if (wRet == DV_ERR_OK)
        MarkVideoHeaderUnprepared(hVideo, lpvideoHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamAddBuffer | This function sends a buffer to a
 *   video-capture device. After the buffer is filled by the device,
 *   the device sends it back to the application.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr | Specifies a far pointer to a <t VIDEOHDR>
 *   structure that identifies the buffer.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_UNPREPARED | Indicates the <p lpvideoHdr> structure hasn't been prepared.
 *   @flag DV_ERR_STILLPLAYING | Indicates a buffer is still in the queue.
 *   @flag DV_ERR_PARAM1 | The <p lpvideoHdr> parameter is invalid or
 *       the <e VIDEOHDR.dwBufferLength> member of the <t VIDEOHDR>
 *       structure is not set to the proper value.
 *
 * @comm The data buffer must be prepared with <f videoStreamPrepareHeader>
 *   before it is passed to <f videoStreamAddBuffer>. The <t VIDEOHDR> data
 *   structure and the data buffer referenced by its <e VIDEOHDR.lpData>
 *   member must be allocated with <f GlobalAlloc> using the GMEM_MOVEABLE
 *   and GMEM_SHARE flags, and locked with <f GlobalLock>. Set the
 *   <e VIDEOHDR.dwBufferLength> member to the size of the header.
 *
 * @xref <f videoStreamPrepareHeader>
 ****************************************************************************/
DWORD WINAPI videoStreamAddBuffer(HVIDEO hVideo, LPVIDEOHDR lpvideoHdr, DWORD dwSize)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (!IsVideoHeaderPrepared(hVideo, lpvideoHdr))
    {
        DebugErr(DBF_WARNING, "videoStreamAddBuffer: buffer not prepared.");
        return DV_ERR_UNPREPARED;
    }

    if (lpvideoHdr->dwFlags & VHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "videoStreamAddBuffer: buffer already in queue.");
        return DV_ERR_STILLPLAYING;
    }

    return (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_ADDBUFFER, (DWORD)lpvideoHdr, (DWORD)dwSize);
}



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamStop | This function stops streaming on a video channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following error is defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 * @comm If there are any buffers in the queue, the current buffer will be
 *   marked as done (the <e VIDEOHDR.dwBytesRecorded> member in
 *   the <t VIDEOHDR> header will contain the actual length of data), but any
 *   empty buffers in the queue will remain there. Calling this
 *   function when the channel is not started has no effect, and the
 *   function returns zero.
 *
 * @xref <f videoStreamStart> <f videoStreamReset>
 ****************************************************************************/
DWORD WINAPI videoStreamStop(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return videoMessage((HVIDEO)hVideo, DVM_STREAM_STOP, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamReset | This function stops streaming
 *	     on the specified video device channel and resets the current position
 *      to zero.  All pending buffers are marked as done and
 *      are returned to the application.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 *
 * @xref <f videoStreamReset> <f videoStreamStop> <f videoStreamAddBuffer> <f videoStreamClose>
/****************************************************************************/
DWORD WINAPI videoStreamReset(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return videoMessage((HVIDEO)hVideo, DVM_STREAM_RESET, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamGetPosition | This function retrieves the current
 *   position of the specified video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPMMTIME | lpInfo | Specifies a far pointer to an <t MMTIME>
 *   structure.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t MMTIME> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *
 * @comm Before using <f videoStreamGetPosition>, set the
 *   <e MMTIME.wType> member of the <t MMTIME> structure to indicate
 *   the time format desired. After
 *   <f videoStreamGetPosition> returns, check the <e MMTIME.wType>
 *   member to  determine if the your time format is supported. If
 *   not, <e MMTIME.wType> specifies an alternate format.
 *   Video capture drivers typically provide the millisecond time
 *   format.
 *
 *   The position is set to zero when streaming is started with
 *   <f videoStreamStart>.
 ****************************************************************************/
DWORD WINAPI videoStreamGetPosition(HVIDEO hVideo, LPMMTIME lpInfo, DWORD dwSize)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpInfo, sizeof (MMTIME)) )
        return DV_ERR_PARAM1;

    return videoMessage(hVideo, DVM_STREAM_GETPOSITION,
            (DWORD)lpInfo, (DWORD)dwSize);
}

// ============================================

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamInit | This function initializes a video
 *     device channel for streaming.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm DWORD | dwMicroSecPerFrame | Specifies the number of microseconds
 *     between frames.
 *
 * @parm DWORD | dwCallback | Specifies the address of a callback
 *   function or a handle to a window called during video
 *   streaming. The callback function or window processes
 *  messages related to the progress of streaming.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user
 *  instance data passed to the callback function. This parameter is not
 *  used with window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device channel.
 *   The following flags are defined:
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_BADDEVICEID | Indicates the device ID specified in
 *         <p hVideo> is not valid.
 *   @flag DV_ERR_ALLOCATED | Indicates the resource specified is already allocated.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm If a window or function is chosen to receive callback information, the following
 *   messages are sent to it to indicate the
 *   progress of video input:
 *
 *   <m MM_DRVM_OPEN> is sent at the time of <f videoStreamInit>
 *
 *   <m MM_DRVM_CLOSE> is sent at the time of <f videoStreamFini>
 *
 *   <m MM_DRVM_DATA> is sent when a buffer of image data is available
 *
 *   <m MM_DRVM_ERROR> is sent when an error occurs
 *
 *   Callback functions must reside in a DLL.
 *   You do not have to use <f MakeProcInstance> to get
 *   a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | videoFunc | <f videoFunc> is a placeholder for an
 *   application-supplied function name. The actual name must be exported by
 *   including it in an EXPORTS statement in the DLL's module-definition file.
 *   This is used only when a callback function is specified in
 *   <f videoStreamInit>.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel
 *   associated with the callback.
 *
 * @parm DWORD | wMsg | Specifies the <m MM_DRVM_> messages. Messages indicate
 *       errors and when image data is available. For information on
 *       these messages, see <f videoStreamInit>.
 *
 * @parm DWORD | dwInstance | Specifies the user instance
 *   data specified with <f videoStreamInit>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL. Any data the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref <f videoOpen> <f videoStreamFini> <f videoClose>
 ****************************************************************************/
DWORD WINAPI videoStreamInit(HVIDEO hVideo,
              DWORD dwMicroSecPerFrame, DWORD dwCallback,
              DWORD dwCallbackInst, DWORD dwFlags)
{
    VIDEO_STREAM_INIT_PARMS vsip;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (dwCallback && ((dwFlags & CALLBACK_TYPEMASK) == CALLBACK_FUNCTION) ) {
        if (IsBadCodePtr ((FARPROC) dwCallback) )
            return DV_ERR_PARAM2;
        if (!dwCallbackInst)
            return DV_ERR_PARAM2;
    }

    if (dwCallback && ((dwFlags & CALLBACK_TYPEMASK) == CALLBACK_WINDOW) ) {
        if (!IsWindow((HWND) LOWORD (dwCallback)) )
            return DV_ERR_PARAM2;
    }

    vsip.dwMicroSecPerFrame = dwMicroSecPerFrame;
    vsip.dwCallback = dwCallback;
    vsip.dwCallbackInst = dwCallbackInst;
    vsip.dwFlags = dwFlags;
    vsip.hVideo = (DWORD)hVideo;

    return videoMessage(hVideo, DVM_STREAM_INIT,
                (DWORD) (LPVIDEO_STREAM_INIT_PARMS) &vsip,
                (DWORD) sizeof (VIDEO_STREAM_INIT_PARMS));
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamFini | This function terminates streaming
 *     from the specified device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_STILLPLAYING | Indicates there are still buffers in the queue.
 *
 * @comm If there are buffers that have been sent with
 *   <f videoStreamAddBuffer> that haven't been returned to the application,
 *   this operation will fail. Use <f videoStreamReset> to return all
 *   pending buffers.
 *
 *   Each call to <f videoStreamInit> must be matched with a call to
 *   <f videoStreamFini>.
 *
 *   For VIDEO_EXTERNALIN channels, this function is used to
 *   halt capturing of data to the frame buffer.
 *
 *   For VIDEO_EXTERNALOUT channels supporting overlay,
 *   this function is used to disable the overlay.
 *
 * @xref <f videoStreamInit>
 ****************************************************************************/
DWORD WINAPI videoStreamFini(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return videoMessage(hVideo, DVM_STREAM_FINI, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamStart | This function starts streaming on the
 *   specified video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 *
 * @xref <f videoStreamReset> <f videoStreamStop> <f videoStreamAddBuffer> <f videoStreamClose>
/****************************************************************************/
DWORD WINAPI videoStreamStart(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return videoMessage(hVideo, DVM_STREAM_START, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamGetError | This function returns the error
 *   most recently encountered.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPDWORD | lpdwErrorID | Specifies a far pointer to the <t DWORD>
 *      used to return the error ID.
 *
 * @parm LPDWORD | lpdwErrorValue | Specifies a far pointer to the <t DWORD>
 *      used to return the number of frames skipped.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following error is defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 * @comm While streaming video data, a capture
 *      driver can fill buffers faster than the client application can
 *      save the buffers to disk.  In this case, the
 *      DV_ERR_NO_BUFFERS error is returned in <p lpdwErrorID>
 *      and <p lpdwErrorValue> contains a count of the number of
 *      frames missed.  After
 *      receiving this message and returning the error status, a driver
 *      should reset its internal error flag to DV_ERR_OK and
 *      the count of missed frames to zero.
 *
 *      Applications should send this message frequently during capture
 *      since some drivers which do not have access to interrupts use
 *      this message to trigger buffer processing.
 *
 * @xref <f videoOpen>
/****************************************************************************/
DWORD WINAPI videoStreamGetError(HVIDEO hVideo, LPDWORD lpdwError,
        LPDWORD lpdwFramesSkipped)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpdwError, sizeof (DWORD)) )
        return DV_ERR_PARAM1;

    if (IsBadWritePtr (lpdwFramesSkipped, sizeof (DWORD)) )
        return DV_ERR_PARAM2;

    return videoMessage(hVideo, DVM_STREAM_GETERROR, (DWORD) lpdwError,
        (DWORD) lpdwFramesSkipped);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoFrame | This function transfers a single frame
 *   to or from a video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *      The channel must be of type VIDEO_IN or VIDEO_OUT.
 *
 * @parm LPVIDEOHDR | lpVHdr | Specifies a far pointer to an <t VIDEOHDR>
 *      structure.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_PARAM1 | The <p lpVDHdr> parameter is invalid or
 *       the <e VIDEOHDR.dwBufferLength> member of the <t VIDEOHDR>
 *       structure is not set to the proper value.
 *
 * @comm Use this function with a VIDEO_IN channel to transfer a single
 *      image from the frame buffer.
 *      Use this function with a VIDEO_OUT channel to transfer a single
 *      image to the frame buffer.
 *
 * @xref <f videoOpen>
/****************************************************************************/
DWORD WINAPI videoFrame (HVIDEO hVideo, LPVIDEOHDR lpVHdr)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (!lpVHdr)
        return DV_ERR_PARAM1;

    if (IsBadWritePtr (lpVHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    return videoMessage(hVideo, DVM_FRAME, (DWORD) lpVHdr,
                        sizeof(VIDEOHDR));
}

/**************************************************************************
* @doc INTERNAL VIDEO
*
* @api void | videoCleanup | clean up video stuff
*   called in MSVIDEOs WEP()
*
**************************************************************************/
void FAR PASCAL videoCleanup(HTASK hTask)
{
#ifndef NOTHUNKS
    LRESULT FAR PASCAL ICSendMessage32(DWORD hic, UINT msg, DWORD dwP1, DWORD dwP2);
    // Special internal message to give the 32 bit side a chance to clean
    // up -- which it may or may not need
    videoMessage32(0, DVM_START-1, (DWORD)hTask, 0);
    ICSendMessage32(0, DRV_USER-1, (DWORD)hTask, 0);
    return;
#endif
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\msvideo.16\vidthunk.h ===
/****************************************************************************
    vidthunk.h

    Contains definitions for msvideo thunks (16/32 bit)

    Copyright (c) Microsoft Corporation 1994. All rights reserved

****************************************************************************/

//
// NOTE - 32bit handles have 0x8000 'or'ed in - this makes a BIG ASSUMPTION
// about how handles are generated on the 32-bit side.  We ASSUME here
// that :
//
//    32bit msvideo.dll always uses OpenDriver to create handles
//
//    The OpenDriver returns indices into its table (ie small positive
//    numbers).
//

#define  Is32bitHandle(h) (((h) & 0x8000) != 0)
#define  Make32bitHandle(h) ((h) | 0x8000)
#define  Map32bitHandle(h) ((h) & 0x7FFF)

#ifdef WIN32
#include <wownt32.h>
//
//  Thunking support
//

#define GET_VDM_POINTER_NAME            "WOWGetVDMPointer"
#define GET_HANDLE_MAPPER16             "WOWHandle16"
#define GET_HANDLE_MAPPER32             "WOWHandle32"
#define GET_CALLBACK16                  "WOWCallback16"
#define GET_MAPPING_MODULE_NAME         TEXT("wow32.dll")

typedef LPVOID (APIENTRY *LPGETVDMPOINTER)( DWORD Address, DWORD dwBytes, BOOL fProtectMode );
#define WOW32ResolveMemory( p ) (LPVOID)(GetVdmPointer( (DWORD)(p), 0, TRUE ))

typedef HANDLE  (APIENTRY *LPWOWHANDLE32)(WORD, WOW_HANDLE_TYPE);
typedef WORD    (APIENTRY *LPWOWHANDLE16)(HANDLE, WOW_HANDLE_TYPE);
typedef DWORD   (APIENTRY *LPWOWCALLBACK16)(DWORD vpfn16, DWORD dwParam);

#define StartThunk(Function)                           \
          DWORD ReturnCode = 0;                        \
          DPF2(("Entering function %s", #Function));

#define EndThunk()                                     \
          DPF2(("Returned %4X :%4X",                   \
                   HIWORD(ReturnCode),                 \
                   LOWORD(ReturnCode)));               \
          return ReturnCode;

#define ThunkHWND(h16) ((HWND)lpWOWHandle32(WOW_TYPE_HWND, h16))
#define ThunkHDC(h16)  ((HDC) lpWOWHandle32(WOW_TYPE_HDC , h16))
#define ThunkHPAL(h16) ((HPALETTE)lpWOWHandle32(WOW_TYPE_HPALETTE, h16))

#endif // WIN32

/*
 *  Useful structures and mapping
 */

typedef struct {
    short left, top, right, bottom;
} RECT_SHORT;


#define SHORT_RECT_TO_RECT(OutRect, InRect)  \
    OutRect.left = (LONG)InRect.left;        \
    OutRect.top = (LONG)InRect.top;          \
    OutRect.right = (LONG)InRect.right;      \
    OutRect.bottom = (LONG)InRect.bottom;

#define RECT_TO_SHORT_RECT(OutRect, InRect)  \
    OutRect.left = (short)InRect.left;       \
    OutRect.top = (short)InRect.top;         \
    OutRect.right = (short)InRect.right;     \
    OutRect.bottom = (short)InRect.bottom;


//
//  Function ids across the thunking layer (used by 32 and 16 bit)
//
enum {
   vidThunkvideoMessage32=1,
   vidThunkvideoGetNumDevs32,
   vidThunkvideoOpen32,
   vidThunkvideoClose32,

   compThunkICInfo32,
   compThunkICSendMessage32,
   compThunkICOpen32,
   compThunkICClose32,

   vidThunkvideoGetDriverDesc32
};

#ifndef WIN32
typedef struct _VIDTHUNK
{
//
//  Thunking stuff
//
    DWORD           (FAR PASCAL *lpfnCallproc32W)(DWORD, DWORD, DWORD,
                                                  DWORD, DWORD,
                                                  LPVOID, DWORD, DWORD);
    LPVOID          lpVideoThunkEntry;
    DWORD           dwVideo32Handle;
    LPVOID          lpICMThunkEntry;
    DWORD           dwICM32Handle;


} VIDTHUNK, *PVIDTHUNK, FAR *LPVIDTHUNK;
#endif // !WIN32

//
// The following functions generate calls to the 32-bit side
//

#ifdef _INC_MSVIDEO

DWORD FAR PASCAL videoMessage32(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2);
DWORD FAR PASCAL videoGetNumDevs32(void);
DWORD FAR PASCAL videoClose32(HVIDEO hVideo);
DWORD FAR PASCAL videoOpen32(LPHVIDEO lphVideo, DWORD dwDeviceID, DWORD dwFlags);
DWORD FAR PASCAL videoGetDriverDesc32(DWORD wDriverIndex,
        			LPSTR lpszName, short cbName,
        			LPSTR lpszVer, short cbVer);

#endif // _INC_MSVIDEO

#ifdef _INC_COMPMAN

BOOL FAR PASCAL ICInfo32(DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicInfo);
LRESULT FAR PASCAL ICSendMessage32(DWORD hic, UINT msg, DWORD dwP1, DWORD dwP2);
DWORD FAR PASCAL ICOpen32(DWORD fccType, DWORD fccHandler, UINT wMode);
LRESULT FAR PASCAL ICClose32(DWORD hic);

#endif // _INC_COMPMAN

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\vidcap32\arrow.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/
/****************************************************************************
 *
 *   arrow.c: Arrow control window
 *
 *   Vidcap32 Source code
 *
 ***************************************************************************/


#include <windows.h>
#include <windowsx.h>

#include <stdlib.h>

#include "arrow.h"


// a few porting macros
#ifdef _WIN32
#define SENDSCROLL(hwnd, msg, a, b, h)           \
        SendMessage(hwnd, msg, (UINT)MAKELONG(a,b), (LONG_PTR)(h))

#define EXPORT

#else
#define SENDSCROLL(hwnd, msg, a, b, h)
        SendMessage(hwnd, msg, a, MAKELONG(b,h))   // handle is in HIWORD

#endif


#ifndef LONG2POINT
    #define LONG2POINT(l, pt)               ((pt).x = (SHORT)LOWORD(l), (pt).y = (SHORT)HIWORD(l))
#endif
#define GWID(hwnd)      (GetDlgCtrlID(hwnd))


#define SHIFT_TO_DOUBLE 1
#define DOUBLECLICK     0
#define POINTSPERARROW  3
#define ARROWXAXIS      15
#define ARROWYAXIS      15

POINT ArrowUp[POINTSPERARROW] = {7,1, 3,5, 11,5};
POINT ArrowDown[POINTSPERARROW] = {7,13, 3,9, 11,9};

static    BOOL      bRight;
static    RECT      rUp, rDown;
static    LPRECT    lpUpDown;
static    FARPROC   lpArrowProc;
static    HANDLE    hParent;
BOOL      fInTimer;


#define TEMP_BUFF_SIZE    32

#define SCROLLMSG(hwndTo, msg, code, hwndId)                                     \
                          SENDSCROLL(hwndTo, msg, code, GWID(hwndId), hwndId)

/*
 * @doc EXTERNAL WINCOM
 *
 * @api LONG | ArrowEditChange | This function is helps process the WM_VSCROLL
 * message when using the Arrow controlled edit box.
 * It will increment/decrement the value in the given edit box and return
 * the new value.  Increment/decrement bounds are checked and Beep 0 is produced if
 * the user attempts to go beyond the bounds.
 *
 * @parm        HWND | hwndEdit | Specifies a handle to the edit box window.
 *
 * @parm        UINT | wParam | Specifies the <p wParam> passed to the WM_VSCROLL message.
 *
 * @parm        LONG | lMin | Specifies the minimum value bound for decrements.
 *
 * @parm        LONG | lMax | Specifies the maximum value bound for increments.
 *
 * @rdesc       Returns the updated value of the edit box.
 *
 */
LONG FAR PASCAL ArrowEditChange( HWND hwndEdit, UINT wParam,
                                 LONG lMin, LONG lMax )
{
    TCHAR achTemp[TEMP_BUFF_SIZE];
    LONG l;

    GetWindowText( hwndEdit, achTemp, TEMP_BUFF_SIZE );
    l = atol(achTemp);
    if( wParam == SB_LINEUP ) {
        /* size kluge for now */
        if( l < lMax ) {
            l++;
            wsprintf( achTemp, "%ld", l );
            SetWindowText( hwndEdit, achTemp );
        } else {
        MessageBeep( 0 );
        }
    } else if( wParam == SB_LINEDOWN ) {
        if( l > lMin ) {
            l--;
            wsprintf( achTemp, "%ld", l );
            SetWindowText( hwndEdit, achTemp );
        } else {
            MessageBeep( 0 );
        }
    }
    return( l );

}



UINT NEAR PASCAL UpOrDown()
{
    LONG pos;
    UINT retval;
    POINT pt;

    pos = GetMessagePos();
    LONG2POINT(pos,pt);
    if (PtInRect((LPRECT)&rUp, pt))
        retval = SB_LINEUP;
    else if (PtInRect((LPRECT)&rDown, pt))
        retval = SB_LINEDOWN;
    else
        retval = (UINT)(-1);      /* -1, because SB_LINEUP == 0 */

    return(retval);
}



UINT FAR PASCAL ArrowTimerProc(hWnd, wMsg, nID, dwTime)
HANDLE hWnd;
UINT wMsg;
short nID;
DWORD dwTime;
{
    UINT wScroll;

    if ((wScroll = UpOrDown()) != -1)
    {
        if (bRight == WM_RBUTTONDOWN)
            wScroll += SB_PAGEUP - SB_LINEUP;
        SCROLLMSG( hParent, WM_VSCROLL, wScroll, hWnd);
    }
/* Don't need to call KillTimer(), because SetTimer will reset the right one */
    SetTimer(hWnd, nID, 50, (TIMERPROC)lpArrowProc);
    return(0);
}


void InvertArrow(HANDLE hArrow, UINT wScroll)
{
    HDC hDC;

    lpUpDown = (wScroll == SB_LINEUP) ? &rUp : &rDown;
    hDC = GetDC(hArrow);
    ScreenToClient(hArrow, (LPPOINT)&(lpUpDown->left));
    ScreenToClient(hArrow, (LPPOINT)&(lpUpDown->right));
    InvertRect(hDC, lpUpDown);
    ClientToScreen(hArrow, (LPPOINT)&(lpUpDown->left));
    ClientToScreen(hArrow, (LPPOINT)&(lpUpDown->right));
    ReleaseDC(hArrow, hDC);
    ValidateRect(hArrow, lpUpDown);
    return;
}


LRESULT FAR PASCAL EXPORT ArrowControlProc(HWND hArrow, unsigned message,
                                         WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;
    RECT        rArrow;
    HBRUSH      hbr;
    short       fUpDownOut;
    UINT        wScroll;

    switch (message) {
/*
        case WM_CREATE:
            break;

        case WM_DESTROY:
            break;
*/

        case WM_MOUSEMOVE:
            if (!bRight)  /* If not captured, don't worry about it */
                break;

            if (lpUpDown == &rUp)
                fUpDownOut = SB_LINEUP;
            else if (lpUpDown == &rDown)
                fUpDownOut = SB_LINEDOWN;
            else
                fUpDownOut = -1;

            switch (wScroll = UpOrDown()) {
                case SB_LINEUP:
                    if (fUpDownOut == SB_LINEDOWN)
                        InvertArrow(hArrow, SB_LINEDOWN);

                    if (fUpDownOut != SB_LINEUP)
                        InvertArrow(hArrow, wScroll);

                    break;

                case SB_LINEDOWN:
                    if (fUpDownOut == SB_LINEUP)
                        InvertArrow(hArrow, SB_LINEUP);

                    if (fUpDownOut != SB_LINEDOWN)
                        InvertArrow(hArrow, wScroll);

                    break;

                default:
                    if (lpUpDown) {
                        InvertArrow(hArrow, fUpDownOut);
                        lpUpDown = 0;
                    }
                }

                break;

        case WM_RBUTTONDOWN:
        case WM_LBUTTONDOWN:
            if (bRight)
                break;

            bRight = message;
            SetCapture(hArrow);
            hParent = GetParent(hArrow);
            GetWindowRect(hArrow, (LPRECT) &rUp);
            CopyRect((LPRECT)&rDown, (LPRECT) &rUp);
            rUp.bottom = (rUp.top + rUp.bottom) / 2;
            rDown.top = rUp.bottom + 1;
            wScroll = UpOrDown();
            InvertArrow(hArrow, wScroll);
#if SHIFT_TO_DOUBLE
            if (wParam & MK_SHIFT) {
                if (message != WM_RBUTTONDOWN)
                    goto ShiftLClick;
                else
                    goto ShiftRClick;
            }
#endif
            if (message == WM_RBUTTONDOWN)
                wScroll += SB_PAGEUP - SB_LINEUP;

            SCROLLMSG(hParent, WM_VSCROLL, wScroll, hArrow);

            lpArrowProc = MakeProcInstance((FARPROC) ArrowTimerProc,ghInst);
            SetTimer(hArrow, GWID(hArrow), 200, (TIMERPROC)lpArrowProc);

            break;

        case WM_LBUTTONUP:
        case WM_RBUTTONUP:
            if ((bRight - WM_LBUTTONDOWN + WM_LBUTTONUP) == (int)message) {
                bRight = 0;
                ReleaseCapture();
                if (lpUpDown)
                    InvertArrow(hArrow,(UINT)(lpUpDown==&rUp)?
                                                        SB_LINEUP:SB_LINEDOWN);
                if (lpArrowProc) {
                    SCROLLMSG(hParent, WM_VSCROLL, SB_ENDSCROLL, hArrow);
                    KillTimer(hArrow, GWID(hArrow));

                    FreeProcInstance(lpArrowProc);
                    ReleaseCapture();
                    lpArrowProc = 0;
                }
            }
            break;

        case WM_LBUTTONDBLCLK:
ShiftLClick:
            wScroll = UpOrDown() + SB_TOP - SB_LINEUP;
            SCROLLMSG(hParent, WM_VSCROLL, wScroll, hArrow);
            SCROLLMSG(hParent, WM_VSCROLL, SB_ENDSCROLL, hArrow);

            break;

        case WM_RBUTTONDBLCLK:
ShiftRClick:
            wScroll = UpOrDown() + SB_THUMBPOSITION - SB_LINEUP;
            SCROLLMSG(hParent, WM_VSCROLL, wScroll, hArrow);
            SCROLLMSG(hParent, WM_VSCROLL, SB_ENDSCROLL, hArrow);
/*
            hDC = GetDC(hArrow);
            InvertRect(hDC, (LPRECT) &rArrow);
            ReleaseDC(hArrow, hDC);
            ValidateRect(hArrow, (LPRECT) &rArrow);
*/
            break;

        case WM_PAINT:
            BeginPaint(hArrow, &ps);
            GetClientRect(hArrow, (LPRECT) &rArrow);
            if ( hbr = CreateSolidBrush(GetSysColor(COLOR_BTNFACE)) )
			{
				FillRect(ps.hdc, (LPRECT)&rArrow, hbr);
				DeleteObject(hbr);
			}
            hbr = SelectObject(ps.hdc, GetStockObject(BLACK_BRUSH));
            SetTextColor(ps.hdc, GetSysColor(COLOR_WINDOWFRAME));
            SetMapMode(ps.hdc, MM_ANISOTROPIC);

            SetViewportOrgEx(ps.hdc, rArrow.left, rArrow.top, NULL);

            SetViewportExtEx(ps.hdc, rArrow.right - rArrow.left,
                                                    rArrow.bottom - rArrow.top, NULL);
            SetWindowOrgEx(ps.hdc, 0, 0, NULL);
            SetWindowExtEx(ps.hdc, ARROWXAXIS, ARROWYAXIS, NULL);
            MoveToEx(ps.hdc, 0, (ARROWYAXIS / 2), NULL);
            LineTo(ps.hdc, ARROWXAXIS, (ARROWYAXIS / 2));
/*
            Polygon(ps.hdc, (LPPOINT) Arrow, 10);
*/
            Polygon(ps.hdc, (LPPOINT) ArrowUp, POINTSPERARROW);
            Polygon(ps.hdc, (LPPOINT) ArrowDown, POINTSPERARROW);
            SelectObject(ps.hdc, hbr);

            EndPaint(hArrow, &ps);

            break;

        default:
            return(DefWindowProc(hArrow, message, wParam, lParam));

            break;
        }

    return(0L);
}

#ifndef _WIN32
#pragma alloc_text(_INIT, ArrowInit)
#endif


BOOL FAR PASCAL ArrowInit(HANDLE hInst)
{
    WNDCLASS wcArrow;

    wcArrow.lpszClassName = SPINARROW_CLASSNAME;
    wcArrow.hInstance     = hInst;
    wcArrow.lpfnWndProc   = ArrowControlProc;
    wcArrow.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wcArrow.hIcon         = NULL;
    wcArrow.lpszMenuName  = NULL;
    wcArrow.hbrBackground = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
    wcArrow.style         = CS_HREDRAW | CS_VREDRAW;
#if DOUBLECLICK
    wcArrow.style         |= CS_DBLCLKS;
#endif
    wcArrow.cbClsExtra    = 0;
    wcArrow.cbWndExtra    = 0;

    if (!RegisterClass(&wcArrow))
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\vidcap32\dialogs.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/
/****************************************************************************
 *
 *   dialogs.h: Dialog box include
 *
 *   Vidcap32 Source code
 *
 ***************************************************************************/

/*
 * IDs for the dialogs themselves (as opposed to the controls within them)
 * are also the HELP_CONTEXT ids for the helpfile that we share with the
 * original 16-bit vidcap, and are thus fixed.
 */



#define IDD_HelpAboutBox            300

#define IDD_CapSetUp                    663
#define IDD_FrameRateData           401
#define IDD_FrameRateArrow          402
#define IDD_TimeLimitFlag           403
#define IDD_SecondsText             404
#define IDD_SecondsData             405
#define IDD_SecondsArrow            406
#define IDD_CapAudioFlag            407
#define IDD_AudioConfig             408
#define IDD_CaptureToDisk           409
#define IDD_CaptureToMemory         410
#define IDD_VideoConfig             411
#define IDD_CompConfig              412
#define IDD_MCIControlFlag          413
#define IDD_MCISetup                414

#define IDD_AudioFormat                 658
#define IDD_SampleIDs               420
#define IDD_Sample8Bit              421
#define IDD_Sample16Bit             422
#define IDD_ChannelIDs              423
#define IDD_ChannelMono             424
#define IDD_ChannelStereo           425
#define IDD_FreqIDs                 426
#define IDD_Freq11kHz               427
#define IDD_Freq22kHz               428
#define IDD_Freq44kHz               429
#define IDD_SetLevel                430

#define IDD_AllocCapFileSpace           652
#define IDD_SetCapFileFree          440
#define IDD_SetCapFileSize          441

#define IDD_MakePalette                 664
#define IDD_MakePalColors           450
#define IDD_MakePalStart            451
#define IDD_MakePalSingleFrame      452
#define IDD_MakePalNumFrames        453
#define IDD_MakePalColorArrow       454

#define IDD_NoCapHardware               657
#define IDD_FailReason              460

#define IDD_Prefs                       656
#define IDD_PrefsMasterAudio        465
#define IDD_PrefsMasterNone         466

#define IDD_PrefsSizeFrame          468

#define IDD_PrefsStatus             470
#define IDD_PrefsToolbar            471
#define IDD_PrefsCentre             472
#define IDD_PrefsDefBackground      473
#define IDD_PrefsLtGrey             474
#define IDD_PrefsDkGrey             475
#define IDD_PrefsBlack              476
#define IDD_PrefsSmallIndex         477
#define IDD_PrefsBigIndex           478

#define IDD_CAPFRAMES                   662
#define IDD_CapMessage              480
#define IDD_CapNumFrames            481

#define IDD_MCISETUP                    665
#define IDD_MCI_SOURCE              490
#define IDD_MCI_PLAY                491
#define IDD_MCI_STEP                492
#define IDD_MCI_AVERAGE_2X          493
#define IDD_MCI_AVERAGE_FR          494
#define IDD_MCI_STARTTIME           495
#define IDD_MCI_STOPTIME            496
#define IDD_MCI_STARTSET            497
#define IDD_MCI_STOPSET             498

#define IDD_RECLVLMONO                  667
#define IDD_RECLVLSTEREO                668
#define IDRL_LEVEL1                 510
#define IDRL_LEVEL2                 511


// help context ids for common dialogs (GetOpenFile etc)
#define IDA_LOADPAL                     650
#define IDA_SETCAPFILE                  651
#define IDA_SAVECAPFILE                 653
#define IDA_SAVEPAL                     654
#define IDA_SAVEDIB                     655

// help contexts for dialogs put up by AVICAP
#define IDA_VIDSOURCE                   659
#define IDA_VIDFORMAT                   660
#define IDA_VIDDISPLAY                  661
#define IDA_MCIFRAMES                   662
#define IDA_COMPRESSION                 669

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\vidcap32\help.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/
/****************************************************************************
 *
 *   help.c: Help system interface
 *
 *   Vidcap32 Source code
 *
 ***************************************************************************/

/*
 * supports F1 key help in app and in dialog by installing a hook,
 *
 * Keep track of which dialog is currently displayed in a global:
 * dialog ids are also topic ids in the help file.
 */


#include <windows.h>
#include <windowsx.h>
#include <string.h>

#include "help.h"

int CurrentDialogID = 0;


// app info passed to helpinit
HINSTANCE hInstance;
TCHAR HelpFile[MAX_PATH];
HWND hwndApp;

//hook proc and old msg filter
#ifdef _WIN32
HHOOK hOurHook;
#else
FARPROC fnOldMsgFilter = NULL;
FARPROC fnMsgHook = NULL;
#endif


// call DialogBoxParam, but ensuring correct help processing:
// assumes that each Dialog Box ID is a context number in the help file.
// calls MakeProcInstance as necessary. Uses instance data passed to
// HelpInit().
INT_PTR
DoDialog(
   HWND hwndParent,     // parent window
   int DialogID,        // dialog resource id
   DLGPROC fnDialog,    // dialog proc
   LPARAM lParam          // passed as lparam in WM_INITDIALOG
)
{
    int olddialog;
    DLGPROC fn;
    INT_PTR result;

    // remember current id (for nested dialogs)
    olddialog = CurrentDialogID;

    // save the current id so the hook proc knows what help to display
    CurrentDialogID = DialogID;

    fn = (DLGPROC) MakeProcInstance(fnDialog, hInstance);
    result = DialogBoxParam(
                hInstance,
                MAKEINTRESOURCE(CurrentDialogID),
                hwndParent,
                fn,
                lParam);
    FreeProcInstance(fn);
    CurrentDialogID = olddialog;

    return result;
}


// set the help context id for a dialog displayed other than by DoDialog
// (eg by GetOpenFileName). Returns the old help context that you must
// restore by a further call to this function
int
SetCurrentHelpContext(int DialogID)
{
    int oldid = CurrentDialogID;
    CurrentDialogID = DialogID;
    return(oldid);
}



// return TRUE if lpMsg is a non-repeat F1 key message
BOOL
IsHelpKey(LPMSG lpMsg)
{
    return lpMsg->message == WM_KEYDOWN &&
               lpMsg->wParam == VK_F1 &&
               !(HIWORD(lpMsg->lParam) & KF_REPEAT) &&
               GetKeyState(VK_SHIFT) >= 0 &&
               GetKeyState(VK_CONTROL) >= 0 &&
               GetKeyState(VK_MENU) >= 0;
}



LRESULT CALLBACK
HelpMsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    if (nCode >= 0) {
        if (IsHelpKey((LPMSG)lParam)) {
            if (CurrentDialogID != 0) {
                WinHelp(hwndApp, HelpFile, HELP_CONTEXT, CurrentDialogID);
            } else {
                WinHelp(hwndApp, HelpFile, HELP_CONTENTS, 0);
            }
        }
    }
#ifdef _WIN32
    return CallNextHookEx(hOurHook, nCode, wParam, lParam);
#else
    return DefHookProc(nCode, wParam, lParam, fnOldMsgFilter);
#endif

}





// help init - initialise the support for the F1 key help
BOOL
HelpInit(HINSTANCE hinstance, LPSTR helpfilepath, HWND hwnd)
{
    LPSTR pch;

    // save app details
    hwndApp = hwnd;
    hInstance = hinstance;

    // assume that the help file is in the same directory as the executable-
    // get the executable path, and replace the filename with the help
    // file name.
    GetModuleFileName(hinstance, HelpFile, sizeof(HelpFile));

    // find the final backslash, and append the help file name there
    pch = _fstrrchr(HelpFile, '\\');
    pch++;
    lstrcpy(pch, helpfilepath);

    // install a hook for msgs and save old one
#ifdef _WIN32
    hOurHook = SetWindowsHookEx(
                        WH_MSGFILTER,
                        (HOOKPROC) HelpMsgHook,
                        NULL, GetCurrentThreadId());
#else
    fnMsgHook = (FARPROC) MakeProcInstance(HelpMsgHook, hInstance);
    fnOldMsgFilter = SetWindowsHook(WH_MSGFILTER, (HOOKPROC) fnMsgHook);
#endif

    return(TRUE);
}



// shutdown the help system
void
HelpShutdown(void)
{
#ifdef _WIN32
    UnhookWindowsHookEx(hOurHook);
#else
    if (fnOldMsgFilter) {
        UnhookWindowsHook(WH_MSGFILTER, fnMsgHook);
        FreeProcInstance(fnMsgHook);
    }
#endif

    WinHelp(hwndApp, HelpFile, HELP_QUIT, 0);
}


// start help at the contents page
void
HelpContents(void)
{
    WinHelp(hwndApp, HelpFile, HELP_CONTENTS, 0);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\vidcap32\help.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/
/****************************************************************************
 *
 *   help.h: Help system include file
 *
 *   Vidcap32 Source code
 *
 ***************************************************************************/


// call DialogBoxParam, but ensuring correct help processing:
// assumes that each Dialog Box ID is a context number in the help file.
// calls MakeProcInstance as necessary. Uses instance data passed to
// HelpInit().
INT_PTR
DoDialog(
   HWND hwndParent,     // parent window
   int DialogID,        // dialog resource id
   DLGPROC fnDialog,    // dialog proc
   LPARAM lParam          // passed as lparam in WM_INITDIALOG
);


// set the help context id for a dialog displayed other than by DoDialog
// (eg by GetOpenFileName). Returns the old help context that you must
// restore by a further call to this function
int SetCurrentHelpContext(int DialogID);


// help init - initialise the support for the F1 key help
BOOL HelpInit(HINSTANCE hinstance, LPSTR helpfilepath, HWND hwndApp);


// shutdown the help system
void HelpShutdown(void);

// start help at the contents page
void HelpContents(void);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\vidcap32\dialogs.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/
/****************************************************************************
 *
 *   dialogs.c: Dialog box processing
 *
 *   Vidcap32 Source code
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <io.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <dos.h>
#include <vfw.h>
#include <tchar.h>

#include "arrow.h"
#include "rlmeter.h"
#include "vidcap.h"
#include "vidframe.h"
#include "help.h"

static long GetFreeDiskSpaceInKB(LPTSTR) ;
static int  CountMCIDevices(UINT) ;

LRESULT FAR PASCAL MCISetupProc(HWND, unsigned, WPARAM, LPARAM);


//--- utility functions  ---------------------------------------------------



/*----------------------------------------------------------------------------*\
|   SmartWindowPosition (HWND hWndDlg, HWND hWndShow)
|                                                                              |
|   Description:                                                               |
|       This function attempts to position a dialog box so that it
|       does not obscure the hWndShow window. This function is
|       typically called during WM_INITDIALOG processing.
|                                                                              |
|   Arguments:                                                                 |
|       hWndDlg         handle of the soon to be displayed dialog
|       hWndShow        handle of the window to keep visible
|                                                                              |
|   Returns:                                                                   |
|       1 if the windows overlap and positions were adjusted
|       0 if the windows don't overlap
|                                                                              |
\*----------------------------------------------------------------------------*/
int SmartWindowPosition (HWND hWndDlg, HWND hWndShow)
{
    RECT rc, rcDlg, rcShow;
    int iHeight, iWidth;
    int iScreenHeight, iScreenWidth;

    GetWindowRect(hWndDlg, &rcDlg);
    GetWindowRect(hWndShow, &rcShow);

    iScreenHeight = GetSystemMetrics(SM_CYSCREEN);
    iScreenWidth = GetSystemMetrics(SM_CXSCREEN);

    InflateRect (&rcShow, 5, 5); // allow a small border
    if (IntersectRect(&rc, &rcDlg, &rcShow)){
        /* the two do intersect, now figure out where to place */
        /* this dialog window.  Try to go below the Show window*/
        /* first and then to the right, top and left.	   */

        /* get the size of this dialog */
        iHeight = rcDlg.bottom - rcDlg.top;
        iWidth = rcDlg.right - rcDlg.left;

        if ((UINT)(rcShow.bottom + iHeight + 1) <  (UINT)iScreenHeight){
                /* will fit on bottom, go for it */
                rc.top = rcShow.bottom + 1;
                rc.left = (((rcShow.right - rcShow.left)/2) + rcShow.left)
    		        - (iWidth/2);
        } else if ((UINT)(rcShow.right + iWidth + 1) < (UINT)iScreenWidth){
                /* will fit to right, go for it */
                rc.left = rcShow.right + 1;
                rc.top = (((rcShow.bottom - rcShow.top)/2) + rcShow.top)
    	        - (iHeight/2);
        } else if ((UINT)(rcShow.top - iHeight - 1) > 0){
                /* will fit on top, handle that */
                rc.top = rcShow.top - iHeight - 1;
                rc.left = (((rcShow.right - rcShow.left)/2) + rcShow.left)
    		        - (iWidth/2);
        } else if ((UINT)(rcShow.left - iWidth - 1) > 0){
                /* will fit to left, do it */
                rc.left = rcShow.left - iWidth - 1;
                rc.top = (((rcShow.bottom - rcShow.top)/2) + rcShow.top)
    	        - (iHeight/2);
        } else {
                /* we are hosed, they cannot be placed so that there is */
                /* no overlap anywhere.  To minimize the damage just put*/
                /* the dialog in the lower left corner of the screen    */
                rc.top = (int)iScreenHeight - iHeight;
                rc.left = (int)iScreenWidth - iWidth;
        }

        /* make any adjustments necessary to keep it on the screen */
        if (rc.left < 0) rc.left = 0;
        else if ((UINT)(rc.left + iWidth) > (UINT)iScreenWidth)
                rc.left = (int)(iScreenWidth - iWidth);

        if (rc.top < 0)  rc.top = 0;
        else if ((UINT)(rc.top + iHeight) > (UINT)iScreenHeight)
                rc.top = (int)iScreenHeight - iHeight;

        SetWindowPos(hWndDlg, NULL, rc.left, rc.top, 0, 0,
    	        SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
        return 1;
    } // if the windows overlap by default

    return 0;
}

//
// GetFreeDiskSpace: Function to Measure Available Disk Space
//
static long GetFreeDiskSpaceInKB(LPTSTR pFile)
{
    DWORD dwFreeClusters, dwBytesPerSector, dwSectorsPerCluster, dwClusters;
    TCHAR RootName[MAX_PATH];
    LPTSTR ptmp;    //required arg

    // need to find path for root directory on drive containing
    // this file.

    GetFullPathName(pFile, sizeof(RootName)/sizeof(RootName[0]), RootName, &ptmp);

    // truncate this to the name of the root directory (god how tedious)
    if ((RootName[0] == TEXT('\\')) && (RootName[1] == TEXT('\\'))) {

        // path begins with  \\server\share\path so skip the first
        // three backslashes
        ptmp = &RootName[2];
        while (*ptmp && (*ptmp != TEXT('\\'))) {
            ptmp++;
        }
        if (*ptmp) {
            // advance past the third backslash
            ptmp++;
        }
    } else {
        // path must be drv:\path
        ptmp = RootName;
    }

    // find next backslash and put a null after it
    while (*ptmp && (*ptmp != TEXT('\\'))) {
        ptmp++;
    }
    // found a backslash ?
    if (*ptmp) {
        // skip it and insert null
        ptmp++;
        *ptmp = TEXT('\0');
    }



    if (!GetDiskFreeSpace(RootName,
		&dwSectorsPerCluster,
		&dwBytesPerSector,
		&dwFreeClusters,
		&dwClusters)) {
	    MessageBoxID(IDS_ERR_MEASUREFREEDISK, MB_OK | MB_ICONINFORMATION);
	    return (-1);
    }
    return(MulDiv (dwSectorsPerCluster * dwBytesPerSector,
		   dwFreeClusters,
		   1024));
}

//
// CountMCIDevices: Function to Find the Number of MCI Devices of a Type
//
static int CountMCIDevices(UINT wType)
{
    int               nTotal = 0 ;
    DWORD             dwCount ;
    MCI_SYSINFO_PARMS mciSIP ;

    mciSIP.dwCallback = 0 ;
    mciSIP.lpstrReturn = (LPTSTR)(LPVOID) &dwCount ;
    mciSIP.dwRetSize = sizeof(DWORD) ;
    mciSIP.wDeviceType = wType ;

    // Use an MCI command to get the info
    if (! mciSendCommand(0, MCI_SYSINFO, MCI_SYSINFO_QUANTITY,
                         (DWORD_PTR)(LPVOID) &mciSIP))
        nTotal = (int) *((LPDWORD) mciSIP.lpstrReturn) ;

    return nTotal ;
}



/* lMicroSec = StringRateToMicroSec(szRate)
 *
 * Convert <szRate> (e.g. "3.75" representing 3.75 frames per second)
 * to microseconds (e.g. 266667L microseconds per frame).
 *
 * If the rate is close to zero or negative, then 0L is returned.
 */
DWORD StringRateToMicroSec(PSTR szRate)
{
	double		dRate;

	dRate = atof(szRate);
	
	if (dRate < 0.0001) {
		return 0L;
	} else {
		return (DWORD) /*floor*/((1e6 / dRate) + 0.5);
        }
}

/* ach = MicroSecToStringRate(achRate, lMicroSec)
 *
 * Convert <lMicroSec> (e.g. 266667L microseconds per frame) to a
 * string rate (e.g. "3.75" representing 3.75 frames per second).
 * Returns <achRate>.
 */
PSTR MicroSecToStringRate(PSTR achRate, DWORD dwMicroSec)
{
	sprintf(achRate, "%.3f",
		(dwMicroSec == 0L) ? 0.0 : (1e6 / (double) dwMicroSec));

	return achRate;
}

/*
 * update the text of an edit field based on a comarrow up or down change
 * - write the text in N.NNN format (truncated to an integer)
 */
LONG FAR PASCAL
MilliSecVarArrowEditChange(
    HWND hwndEdit,
    UINT uCode,
    LONG lMin,
    LONG lMax,
    UINT uInc
)
{
    TCHAR achTemp[32];
    LONG l;

    GetWindowText(hwndEdit, achTemp, sizeof(achTemp));

    l = atol(achTemp);
    if(uCode == SB_LINEUP ) {

	if(l + (long)uInc <= lMax ) {
	    l += uInc;
	    wsprintf(achTemp, "%ld.000", l );
	    SetWindowText(hwndEdit, achTemp );
        } else {
	    MessageBeep( 0 );
	}
    } else if (uCode == SB_LINEDOWN ) {
	if( l-(long)uInc >= lMin ) {
	    l -= uInc;
	    wsprintf( achTemp, "%ld.000", l );
	    SetWindowText( hwndEdit, achTemp );
        } else {
	    MessageBeep( 0 );
	}
    }
    return( l );
}


BOOL MCIGetDeviceNameAndIndex (HWND hwnd, LPINT lpnIndex, LPTSTR lpName)
{
    HWND hwndCB;
    TCHAR buf[160];
    TCHAR *cp;

    hwndCB = GetDlgItem( hwnd, IDD_MCI_SOURCE );
    *lpnIndex = (int)SendMessage( hwndCB, CB_GETCURSEL, 0, 0L);
    SendMessage( hwndCB, CB_GETLBTEXT, *lpnIndex,
    		(LONG_PTR)(LPTSTR) buf );
    // Point cp to the system name
    for (cp = buf + lstrlen(buf); cp > buf; cp--) {
        if (*cp == ' ' && *(cp-1) == ',') {
            cp++;
            break;
	}
    }
    lstrcpy (lpName, cp);
    return TRUE;
}


/*--------------------------------------------------------------+
| TimeMSToHMSString() - change milliseconds into a time string   |
+--------------------------------------------------------------*/
void FAR PASCAL TimeMSToHMSString (DWORD dwMS, LPTSTR lpTime)
{
	DWORD	dwTotalSecs;
	LONG	lHundredths;
	WORD	wSecs;
	WORD	wMins;
	WORD	wHours;

	/* convert to number of seconds */
	dwTotalSecs = dwMS / 1000;
	
	/* keep the remainder part */
	lHundredths = (dwMS - (dwTotalSecs * 1000)) / 10;
		
	/* break down into other components */
	wHours = (WORD)(dwTotalSecs / 3600);	// get # Hours
	dwTotalSecs -= (wHours * 3600);
	
	wMins = (WORD)(dwTotalSecs / 60);	// get # Mins
	dwTotalSecs -= (wMins * 60);
	
	wSecs = (WORD)dwTotalSecs;	// what's left is # seconds
	
	/* build the string */
	wsprintf((TCHAR far *)lpTime, "%02u:%02u:%02u.%02lu", wHours, wMins,
		    wSecs, lHundredths);
}


/*--------------------------------------------------------------+
| TimeHMSStringToMS() - change Time string to milliseconds     |
|                       returns dwMilliseconds or -1 if error  |
+--------------------------------------------------------------*/
LONG NEAR PASCAL  TimeHMSStringToMS (LPTSTR lpsz)
{
    TCHAR	achTime[12];	// buffer for time string (input)
    DWORD	dwMSecs;	// total MSecs for this thing */
    TCHAR	*pDelim;	// pointer to next delimeter
    TCHAR	*p;		// general pointer
    DWORD	dwHours = 0;	// # of hours
    DWORD	dwMins = 0;	// # of minutes
    DWORD	dwSecs = 0;		// # of seconds
    UINT	wHundredths = 0;	// # hundredths

    _tcsncpy(achTime, lpsz, sizeof (achTime));

    if (achTime[0] == '\0')
        return -1;	// bad TCHAR so error out
    	
    /* rip through the whole string and look for illegal TCHARs */
    for (p = achTime; *p ; p++){
        if (!_istdigit(*p) && *p != '.' && *p != ':')
    	return -1;	// bad char so error out
    }

    /* go find the hundredths portion if it exists */
    pDelim = _tcschr(achTime, '.');
    if (pDelim && *pDelim){
        p = _tcsrchr(achTime, '.');
        if (pDelim != p) {
    	    return -1;		// string has > 1 '.', return error
        }

        p++;			// move up past delim
        if (_tcslen(p) > 2) {
    	    *(p+2) = '\0';		// knock off all but hundredths
        }

        wHundredths = _ttoi(p);	// get the fractional part

        *pDelim = '\0';		// null out this terminator
    }

    /* try and find seconds */
    pDelim = _tcsrchr(achTime, ':');	// get last ':'
    if (pDelim) {
        p = (pDelim+1);
    } else {
        // no colon - assume just seconds in string
        p = achTime;
    }
    dwSecs = _ttoi(p);

    if (pDelim) {
        *pDelim = '\0';

        /* go and get the minutes part */
        pDelim = _tcsrchr(achTime, ':');
        if (pDelim) {
            p = (pDelim + 1);
        } else {
            // no more colons - assume remainder is just minutes
            p = achTime;
        }
        dwMins = _ttoi(p);

        if (pDelim) {
            *pDelim = '\0';

            /* get the hours */
            p = achTime;
            dwHours = _ttoi(p);
        }
    }

    /* now we've got the hours, minutes, seconds and any	*/
    /* fractional part.  Time to build up the total time	*/

    dwSecs += (dwHours * 3600);	// add in hours worth of seconds
    dwSecs += (dwMins * 60);	// add in minutes worth of seconds
    dwMSecs = (dwSecs * 1000L);
    dwMSecs += (wHundredths * 10L);

    /* now we've got the total number of milliseconds */
    return dwMSecs;
}


/*
 *  MCIDeviceClose
 *      This routine closes the open MCI device.
 */

void MCIDeviceClose (void)
{
    mciSendString( "close mciframes", NULL, 0, NULL );
}



/*
 *  MCIDeviceOpen
 *      This routine opens the mci device for use, and sets the
 *      time format to milliseconds.
 *      Return FALSE on error;
 */

BOOL MCIDeviceOpen (LPTSTR lpDevName)
{
    TCHAR        ach[160];
    DWORD dwMCIError;

    wsprintf( ach, "open %s shareable wait alias mciframes", (LPTSTR) lpDevName);
    dwMCIError = mciSendString( ach, NULL, 0, NULL );
    if( dwMCIError )  {
        return(FALSE);
    }

    dwMCIError = mciSendString( "set mciframes time format milliseconds",
	    NULL, 0, NULL );
    if( dwMCIError ) {
        MCIDeviceClose();
        return(FALSE);
    }
    return ( TRUE );

}


/*
 *  MCIDeviceGetPosition
 *      Stores the current device position in milliseconds in lpdwPos.
 *      Returns TRUE on success, FALSE if error.
 */
BOOL FAR PASCAL MCIDeviceGetPosition (LPDWORD lpdwPos)
{
    TCHAR        ach[80];
    DWORD dwMCIError;

    dwMCIError = mciSendString( "status mciframes position wait",
	    ach, sizeof(ach), NULL );
    if( dwMCIError ) {
        *lpdwPos = 0L;
        return FALSE;
    }

    *lpdwPos = _ttol( ach );
    return TRUE;
}

#ifndef USE_ACM

// --- audio streaming ------------------------------------------------

// the ShowLevel dialog streams data in from the input and
// shows the current volume.

// buffers into which sound data is recorded
#define NUM_LEVEL_BUFFERS   2

// the buffer size is calculated to be about 1/20 sec
#define UPDATES_PER_SEC     20

/*
 * we save all our data in one of these, and write a pointer to it
 * into the dialog DWL_USER field.
 */

typedef struct _LevelStreamData {
    LPWAVEHDR alpWave[NUM_LEVEL_BUFFERS];
    PCMWAVEFORMAT FAR * pwf;
    HWAVEIN hwav;
    int buffersize;
} LEVELSTREAMDATA, FAR * PLEVELSTREAMDATA;


//open the wave-device in the given format, queue all the buffers and
//start data streaming. Save the wavein device to the dialog DWL_USER window
//data area so we can close it on dialog dismissal.
BOOL
OpenStream(HWND hDlg, PCMWAVEFORMAT FAR * pwf)
{
    PLEVELSTREAMDATA pInfo;
    int i;


    pInfo = (PLEVELSTREAMDATA) GlobalLock(GlobalAlloc(GHND, sizeof(LEVELSTREAMDATA)));

    if (pInfo == NULL) {
        return(FALSE);
    }


    // complete remaining areas of wf
    pwf->wf.wFormatTag = WAVE_FORMAT_PCM;
    pwf->wf.nBlockAlign = pwf->wf.nChannels * pwf->wBitsPerSample / 8;
    pwf->wf.nAvgBytesPerSec = pwf->wf.nSamplesPerSec * pwf->wf.nBlockAlign;

    // save for later use
    pInfo->pwf = pwf;

    // buffer size a fixed fraction of a second
    pInfo->buffersize = pwf->wf.nAvgBytesPerSec/UPDATES_PER_SEC;


    pInfo->hwav = NULL;

    if (waveInOpen(
        &pInfo->hwav,
        WAVE_MAPPER,
        (LPWAVEFORMATEX)pwf,
        (DWORD) hDlg,               // callback via MM_WIM_ messages to dialogproc
        0,
        CALLBACK_WINDOW)) {
            SetWindowLong(hDlg, DWL_USER, 0);
            return(FALSE);
    }

    // store the info structure in the dialog, so that even if we fail
    // on this routine we will clean up correctly
    SetWindowLong(hDlg, DWL_USER, (long) pInfo);

    // set all the wave headers to null (for cleanup if error)
    for (i = 0; i < NUM_LEVEL_BUFFERS; i++) {
        pInfo->alpWave[i] = NULL;
    }

    // alloc, prepare and add all the buffers
    for (i = 0; i < NUM_LEVEL_BUFFERS; i++) {

        pInfo->alpWave[i] = GlobalLock(GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE,
                        sizeof(WAVEHDR) + pInfo->buffersize));
        if (pInfo->alpWave[i] == NULL) {
            return(FALSE);
        }

        pInfo->alpWave[i]->lpData = (LPBYTE) (pInfo->alpWave[i] + 1);
        pInfo->alpWave[i]->dwBufferLength = pInfo->buffersize;
        pInfo->alpWave[i]->dwBytesRecorded = 0;
        pInfo->alpWave[i]->dwUser = 0;
        pInfo->alpWave[i]->dwFlags = 0;
        pInfo->alpWave[i]->dwLoops = 0;

        if (waveInPrepareHeader(pInfo->hwav, pInfo->alpWave[i], sizeof(WAVEHDR))) {
            return(FALSE);
        }

        if (waveInAddBuffer(pInfo->hwav, pInfo->alpWave[i], sizeof(WAVEHDR))) {
            return(FALSE);
        }
    }

    waveInStart(pInfo->hwav);

    return(TRUE);
}

// terminate the data streaming on a wavein device associated with a
// dialog, and clean up the buffers allocated
void
CloseStream(HWND hDlg)
{
    PLEVELSTREAMDATA pInfo;
    int i;


    // pick up our info from the dialog
    pInfo = (PLEVELSTREAMDATA) GetWindowLong(hDlg, DWL_USER);
    if ((pInfo == NULL) || (pInfo->hwav == NULL)) {
        return;
    }

    // stop streaming data
    waveInStop(pInfo->hwav);

    // release all buffers
    waveInReset(pInfo->hwav);

    // unlock and free buffers
    for (i = 0; i < NUM_LEVEL_BUFFERS; i++) {
        if (pInfo->alpWave[i]) {
            waveInUnprepareHeader(pInfo->hwav, pInfo->alpWave[i], sizeof(WAVEHDR));
            GlobalFree(GlobalHandle(pInfo->alpWave[i]));
            pInfo->alpWave[i] = NULL;
        }

    }
    waveInClose(pInfo->hwav);

    GlobalFree(GlobalHandle(pInfo));

    SetWindowLong(hDlg, DWL_USER, 0);


}

// we have received a block of data. work out the level(s) and send to
// the appropriate control on the dialog, and then requeue the buffer.
// return FALSE if any error occurs, otherwise TRUE
BOOL
StreamData(HWND hDlg, HWAVEIN hwav, LPWAVEHDR pHdr)
{
    PLEVELSTREAMDATA pInfo;
    int n = 0;
    int LevelLeft = 0, LevelRight = 0;
    int i, l;

    // pick up our info from the dialog
    pInfo = (PLEVELSTREAMDATA) GetWindowLong(hDlg, DWL_USER);
    if ((pInfo == NULL) || (pInfo->hwav != hwav)) {
        return FALSE;
    }

    // go through all samples in buffer looking for maximum absolute level
    while (n < pInfo->buffersize) {

        /*
         * volumes go above and below the mean level - we are
         * interested in the absolute volume
         * 8 bit samples are in the range 0..255
         * 16-bit samples are in the range -32768..+32767
         */

        // skip the first byte if 16-bit
        // and adjust to be in range -127..+128
        if (pInfo->pwf->wBitsPerSample == 16) {
            n++;
            i = (int) (signed char) pHdr->lpData[n];
        } else {
            i = (int) ((unsigned char) pHdr->lpData[n]) - 128;
        }

        // skip past the byte we've picked up
        n++;

        // take absolute volume level
        if (i < 0) {
            i = -i;
        }

        // convert to percentage
        l = (i*100) / 128;

        // compare against current max
        if (LevelLeft < l) {
            LevelLeft = l;
        }


        // if stereo, repeat for right channel
        if (pInfo->pwf->wf.nChannels == 2) {
            // skip the first byte if 16-bit
            if (pInfo->pwf->wBitsPerSample == 16) {
                n++;
                i = (int) (signed char) pHdr->lpData[n];
            } else {
                i = (int) ((unsigned char) pHdr->lpData[n]) - 128;
            }

            // skip past the byte we've picked up
            n++;

            // take absolute volume level
            if (i < 0) {
                i = -i;
            }

            // convert to percentage
            l = (i*100) / 128;

            // compare against current max
            if (LevelRight < l) {
                LevelRight = l;
            }
        }
    }

    // put the buffer back on the queue
    if (waveInAddBuffer(pInfo->hwav, pHdr, sizeof(WAVEHDR))) {
        return(FALSE);
    }

    // send new level to dialog control
    SendDlgItemMessage(hDlg, IDRL_LEVEL1, WMRL_SETLEVEL, 0, LevelLeft);
    if (pInfo->pwf->wf.nChannels == 2) {
        SendDlgItemMessage(hDlg, IDRL_LEVEL2, WMRL_SETLEVEL, 0, LevelRight);
    }

    return(TRUE);
}

#endif  // ! USE_ACM


// --- dialog procs -----------------------------------------------------


//
// AboutProc: About Dialog Box Procedure
//
LRESULT FAR PASCAL AboutProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam)
{
    switch (Message) {
        case WM_INITDIALOG :
             return TRUE ;

        case WM_COMMAND :
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK :
                    EndDialog(hDlg, TRUE) ;
                    return TRUE ;

                case IDCANCEL :
                    EndDialog(hDlg, FALSE) ;
                    return TRUE ;
            }
            break ;
    }

    return FALSE ;
}

#ifndef USE_ACM

/*
 * dialog proc for IDD_RECLVLMONO and IDD_RECLVLSTEREO - show current
 * volume level
 */
LRESULT FAR PASCAL
ShowLevelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message) {

    case WM_INITDIALOG:
        if (!OpenStream(hDlg, (PCMWAVEFORMAT FAR *) lParam)) {
            MessageBoxID(IDS_ERR_ACCESS_SOUNDDRIVER, MB_OK|MB_ICONSTOP);
            EndDialog(hDlg, FALSE);
        }
        return(TRUE);

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDOK:
        case IDCANCEL:

            CloseStream(hDlg);
            EndDialog(hDlg, TRUE);
            return(TRUE);
        }
        break;

    case MM_WIM_DATA:
        if (!StreamData(hDlg, (HWAVEIN)wParam, (LPWAVEHDR)lParam)) {
            MessageBoxID(IDS_ERR_ACCESS_SOUNDDRIVER, MB_OK|MB_ICONSTOP);
            CloseStream(hDlg);
            EndDialog(hDlg, FALSE);
        }
        return(TRUE);

    }
    return FALSE;
}





//
// AudioFormatProc: Audio Format Setting Dialog Box Procedure
//
LRESULT FAR PASCAL AudioFormatProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam)
{
    static int                nChannels ;
    static UINT               wSample ;
    static DWORD              dwFrequency ;

    switch (Message) {
        case WM_INITDIALOG :
            nChannels = IDD_ChannelIDs + glpwfex->nChannels ;
            CheckRadioButton(hDlg, IDD_ChannelMono, IDD_ChannelStereo, nChannels) ;
            wSample = IDD_SampleIDs + glpwfex->wBitsPerSample / 8 ;
            CheckRadioButton(hDlg, IDD_Sample8Bit, IDD_Sample16Bit, wSample) ;
            dwFrequency = IDD_FreqIDs + glpwfex->nSamplesPerSec / 11025 ;
            CheckRadioButton(hDlg, IDD_Freq11kHz, IDD_Freq44kHz, (UINT)dwFrequency) ;
            return TRUE ;

        case WM_COMMAND :
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_SetLevel:
                {
                    // get the current data into a PCMWAVEFORMAT struct,
                    // and run the ShowLevel dialog
                    PCMWAVEFORMAT wf;
                    UINT dlgid;

                    if (IsDlgButtonChecked(hDlg, IDD_ChannelMono)) {
                        wf.wf.nChannels = 1;
                        dlgid = IDD_RECLVLMONO;
                    } else {
                        wf.wf.nChannels = 2;
                        dlgid = IDD_RECLVLSTEREO;
                    }

                    if (IsDlgButtonChecked(hDlg, IDD_Sample8Bit)) {
                        wf.wBitsPerSample = 8;
                    } else {
                        wf.wBitsPerSample = 16;
                    }

                    if (IsDlgButtonChecked(hDlg, IDD_Freq11kHz)) {
                        wf.wf.nSamplesPerSec = 11025 ;
                    } else if (IsDlgButtonChecked(hDlg, IDD_Freq22kHz)) {
                        wf.wf.nSamplesPerSec = 22050 ;
                    } else {
                        wf.wf.nSamplesPerSec =  44100 ;
                    }

                    DoDialog(
                        hDlg,
                        dlgid,
                        ShowLevelProc,
                        (LPARAM) &wf);
                    break;
                }

                case IDOK :
                    if (IsDlgButtonChecked(hDlg, IDD_ChannelMono))
                        nChannels = 1 ;
                    else
                        if (IsDlgButtonChecked(hDlg, IDD_ChannelStereo))
                            nChannels = 2 ;
                        else {
                            MessageBeep(MB_ICONEXCLAMATION) ;
                            return FALSE ;
                        }

                    if (IsDlgButtonChecked(hDlg, IDD_Sample8Bit))
                        wSample = 8 ;
                    else
                        if (IsDlgButtonChecked(hDlg, IDD_Sample16Bit))
                            wSample = 16 ;
                        else {
                            MessageBeep(MB_ICONEXCLAMATION) ;
                            return FALSE ;
                        }

                    if (IsDlgButtonChecked(hDlg, IDD_Freq11kHz))
                        dwFrequency = 11025 ;
                    else
                        if (IsDlgButtonChecked(hDlg, IDD_Freq22kHz))
                            dwFrequency = 22050 ;
                        else
                            if (IsDlgButtonChecked(hDlg, IDD_Freq44kHz))
                                dwFrequency = 44100 ;
                            else {
                                MessageBeep(MB_ICONEXCLAMATION) ;
                                return FALSE ;
                            }

                    // All the entries verfied OK -- save them now
                    glpwfex->nChannels = nChannels ;
                    glpwfex->wBitsPerSample = wSample ;
                    glpwfex->nSamplesPerSec = dwFrequency ;
                    glpwfex->nBlockAlign =  glpwfex->nChannels * (glpwfex->wBitsPerSample / 8) ;
                    glpwfex->nAvgBytesPerSec = (long) glpwfex->nSamplesPerSec *
                                                      glpwfex->nBlockAlign ;
                    glpwfex->cbSize = 0 ;
                    glpwfex->wFormatTag = WAVE_FORMAT_PCM ;
                    EndDialog(hDlg, TRUE) ;
                    return TRUE ;

                case IDCANCEL :
                    EndDialog(hDlg, FALSE) ;
                    return TRUE ;
            }
            break ;
    }

    return FALSE ;
}

#endif // ! USE_ACM

//
// AllocCapFileProc: Capture file Space Allocation Dialog Box Procedure
//
LRESULT FAR PASCAL AllocCapFileProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam)
{
    static int      nFreeMBs = 0 ;

    switch (Message) {
        case WM_INITDIALOG :
        {
            int              fh ;
            long             lFileSize = 0 ;
            long             lFreeSpaceInKB ;
            TCHAR	     achCapFile[_MAX_PATH] ;

            // Get current capture file name and measure its size
            capFileGetCaptureFile(ghWndCap, achCapFile, sizeof(achCapFile) / sizeof(TCHAR)) ;
            if ((fh = _open(achCapFile, _O_RDONLY)) != -1) {
                if ((lFileSize = _lseek(fh, 0L, SEEK_END)) == -1L) {
                    MessageBoxID(IDS_ERR_SIZECAPFILE,
#ifdef BIDI
                MB_RTL_READING |
#endif

                    MB_OK | MB_ICONEXCLAMATION) ;
                    lFileSize = 0 ;
                }
                _close(fh) ;
            }

            // Get free disk space and add current capture file size to that.
            // Convert the available space to MBs.
            if ((lFreeSpaceInKB = GetFreeDiskSpaceInKB(achCapFile)) != -1L) {
                lFreeSpaceInKB += lFileSize / 1024 ;
                nFreeMBs = lFreeSpaceInKB / 1024 ;
                SetDlgItemInt(hDlg, IDD_SetCapFileFree, nFreeMBs, TRUE) ;
            } else {

                EnableWindow(GetDlgItem(hDlg, IDD_SetCapFileFree), FALSE);

            }

            gwCapFileSize = (WORD) (lFileSize / ONEMEG);

            SetDlgItemInt(hDlg, IDD_SetCapFileSize, gwCapFileSize, TRUE) ;
            return TRUE ;
        }

        case WM_COMMAND :
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK :
                {
                    int         iCapFileSize ;

                    iCapFileSize = (int) GetDlgItemInt(hDlg, IDD_SetCapFileSize, NULL, TRUE) ;
                    if (iCapFileSize <= 0 || iCapFileSize > nFreeMBs) {
                        // You are asking for more than we have !! Sorry, ...
                        SetDlgItemInt(hDlg, IDD_SetCapFileSize, iCapFileSize, TRUE) ;
                        SetFocus(GetDlgItem(hDlg, IDD_SetCapFileSize)) ;
                        MessageBeep(MB_ICONEXCLAMATION) ;
                        return FALSE ;
                    }
                    gwCapFileSize = (WORD) iCapFileSize ;

                    EndDialog(hDlg, TRUE) ;
                    return TRUE ;
                }

                case IDCANCEL :
                    EndDialog(hDlg, FALSE) ;
                    return TRUE ;

                case IDD_SetCapFileSize:
                {
                    long l;
                    BOOL bchanged;
                    TCHAR achBuffer[21];

                    // check that entered size is a valid number
                    GetDlgItemText(hDlg, IDD_SetCapFileSize, achBuffer, sizeof(achBuffer));
                    l = atol(achBuffer);
                    bchanged = FALSE;
                    if (l < 1) {
                        l = 1;
                        bchanged = TRUE;
                    } else if (l > nFreeMBs) {
                        l = nFreeMBs;
                        bchanged = TRUE;
                    } else {
                        // make sure there are no non-digit chars
                        // atol() will ignore trailing non-digit characters
                        int c = 0;
                        while (achBuffer[c]) {
                            if (IsCharAlpha(achBuffer[c]) ||
                                !IsCharAlphaNumeric(achBuffer[c])) {

                                // string contains non-digit chars - reset
                                l = 1;
                                bchanged = TRUE;
                                break;
                            }
                            c++;
                        }
                    }
                    if (bchanged) {
                        wsprintf(achBuffer, "%ld", l);
                        SetDlgItemText(hDlg, IDD_SetCapFileSize, achBuffer);
                    }
                    break;
                }
            }
            break ;
    }

    return FALSE ;

}

#if 0
//
// MakePaletteProc: Palette Details Dialog Box Procedure
//
BOOL CALLBACK MakePaletteProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam)
{
    switch (Message) {
        case WM_INITDIALOG :
            SetDlgItemInt(hDlg, IDD_MakePalColors, gwPalColors, FALSE) ;
            SetDlgItemInt(hDlg, IDD_MakePalFrames, gwPalFrames, FALSE) ;
            return TRUE ;

        case WM_COMMAND :
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK :
                {
                    int         iColors ;
                    int         iFrames ;

                    iColors = (int) GetDlgItemInt(hDlg, IDD_MakePalColors, NULL, TRUE) ;
                    if (! (iColors > 0 && iColors <= 236 || iColors == 256)) {
                        // invalid number of palette colors
                        SetDlgItemInt(hDlg, IDD_MakePalColors, iColors, TRUE) ;
                        SetFocus(GetDlgItem(hDlg, IDD_MakePalColors)) ;
                        MessageBeep(MB_ICONEXCLAMATION) ;
                        return FALSE ;
                    }
                    iFrames = (int) GetDlgItemInt(hDlg, IDD_MakePalFrames, NULL, TRUE) ;
                    if (iFrames <= 0 || iFrames > 10000) {
                        // no frame or way t-o-o many frames !!!
                        SetDlgItemInt(hDlg, IDD_MakePalFrames, iFrames, TRUE) ;
                        SetFocus(GetDlgItem(hDlg, IDD_MakePalFrames)) ;
                        MessageBeep(MB_ICONEXCLAMATION) ;
                        return FALSE ;
                    }
                    gwPalColors = iColors ;
                    gwPalFrames = iFrames ;

                    EndDialog(hDlg, TRUE) ;
                    return TRUE ;
                }

                case IDCANCEL :
                    EndDialog(hDlg, FALSE) ;
                    return TRUE ;
            }
            break ;
    }

    return FALSE ;

}

#endif


#define CAPPAL_TIMER    902    
#define CAPTIMER_DELAY  100       // get timers as fast as possible
//
// MakePaletteProc: Palette Details Dialog Box Procedure
//
static int      siNumColors = 256;

LRESULT CALLBACK MakePaletteProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static UINT_PTR shTimer;
    static int  siNumFrames;
    UINT        w;
    TCHAR        ach[40];
    TCHAR        achFormat[40];
    int         i, k;

    switch(msg) {
        case WM_INITDIALOG:
            siNumFrames = 0;
            SetDlgItemInt(hwnd, IDD_MakePalColors, siNumColors, FALSE);
            SmartWindowPosition (hwnd, ghWndCap);
            return TRUE;
            break;

        case WM_VSCROLL:
            /* now handle the scroll */
            i = GetDlgItemInt(hwnd, IDD_MakePalColors, NULL, FALSE);
            ArrowEditChange(GetDlgItem(hwnd, IDD_MakePalColors),
                GET_WM_VSCROLL_CODE(wParam, lParam), 2, 256);
            k = GetDlgItemInt(hwnd, IDD_MakePalColors, NULL, FALSE);
            // Jump over the range 237 to 255
            if (k > 236 && k < 256) {
                if (k > i) 
                   w = 256;
                else
                   w = 236;
                SetDlgItemInt (hwnd, IDD_MakePalColors, w, TRUE);
            }
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDCANCEL:
                    if (siNumFrames) {
                        // The following finishes building the new palette
                        capPaletteManual (ghWndCap, FALSE, siNumColors);
                    }

                    if (shTimer){
                        KillTimer(hwnd, CAPPAL_TIMER);
                        shTimer = 0;
                    }
                    siNumColors = GetDlgItemInt(hwnd, IDD_MakePalColors, (BOOL FAR *)ach, FALSE);
                    siNumColors = max (2, min (256, siNumColors)); 
                    EndDialog(hwnd, siNumFrames);
                    break;
                    
                case IDD_MakePalStart:
                    /* see if we are in START or STOP mode at   */
                    /* this time and handle each one.           */
                    SetFocus (GetDlgItem (hwnd, IDD_MakePalStart));
                    if (!siNumFrames){
                        /* this is the first frame, change the CANCEL */
                        /* button to CLOSE                              */
                        LoadString(ghInstApp, IDS_CAPPAL_CLOSE, ach, sizeof(ach));
                        SetDlgItemText(hwnd, IDCANCEL, ach);
                    }
                    if (!shTimer) {

                        shTimer = SetTimer(hwnd, CAPPAL_TIMER, CAPTIMER_DELAY, NULL);

                        if (shTimer == 0) {
                            //!!!error message here.
                            MessageBeep(0);
                            return TRUE;
                        }

                        /* button said START, let's set up to   */
                        /* do continuous capture.  This involves*/
                        /*   1 - disabling FRAME button         */
                        /*   2 - turning myself to STOP button  */
                        /*   3 - setting up frame timer         */
                        EnableWindow(GetDlgItem(hwnd, IDD_MakePalSingleFrame), FALSE);
                        LoadString(ghInstApp, IDS_CAPPAL_STOP, ach, sizeof(ach));
                        SetDlgItemText(hwnd, IDD_MakePalStart, ach);
                    } else {
                        /* button said STOP, turn things around */
                        /* by:                                  */
                        /*   1 - killing off timers             *
                        /*   2 - turning back into START button */
                        /*   3 - re-enabling FRAME button       */
                        // "&Start"
                        LoadString(ghInstApp, IDS_CAPPAL_START, ach, sizeof(ach));
                        SetDlgItemText(hwnd, IDD_MakePalStart, ach);
                        EnableWindow(GetDlgItem(hwnd, IDD_MakePalSingleFrame), TRUE);
                        KillTimer(hwnd, CAPPAL_TIMER);
                        shTimer = 0;
                    }
                    return TRUE;
                    break;
                    
                case IDD_MakePalSingleFrame:
                    if (!siNumFrames){
                        /* this is the first frame, change the CANCEL */
                        /* button to CLOSE                              */
                        LoadString(ghInstApp, IDS_CAPPAL_CLOSE, ach, sizeof(ach));
                        SetDlgItemText(hwnd, IDCANCEL, ach);
                        siNumColors = GetDlgItemInt(hwnd, IDD_MakePalColors, (BOOL FAR *)ach, FALSE);
                        siNumColors = max (2, min (256, siNumColors)); 
                    }
                    // Get the palette for a single frame
                    capPaletteManual (ghWndCap, TRUE, siNumColors);

                    siNumFrames++;
                    LoadString(ghInstApp, IDS_CAPPAL_STATUS, achFormat, sizeof(achFormat));
                    wsprintf(ach, achFormat, siNumFrames);
                    SetDlgItemText(hwnd, IDD_MakePalNumFrames, ach);
                    return TRUE;
                    break;

                case IDD_MakePalColors:
                    if (HIWORD (lParam) == EN_KILLFOCUS) {
                        w = GetDlgItemInt (hwnd, (UINT) wParam, NULL, FALSE);
                        if ( w < 2) {
                            MessageBeep (0);
                            SetDlgItemInt (hwnd, (UINT) wParam, 2, FALSE);
                        }
                        else if (w > 256) {
                            MessageBeep (0);
                            SetDlgItemInt (hwnd, (UINT) wParam, 256, FALSE);
                        }
                    }
                    return TRUE;
                    break;

                default:
                    return FALSE;
                    
            } // switch(wParam) on WM_COMMAND 
            break;
            
        case WM_TIMER:
            if (wParam == CAPPAL_TIMER){
                SendMessage(hwnd, WM_COMMAND, IDD_MakePalSingleFrame, 0L);
            }
            break;
        default:
            return FALSE;
            
    } // switch(msg)
    return FALSE;
}




//
// CapSetUpProc: Capture SetUp Details Dialog Box Procedure
//
LRESULT FAR PASCAL CapSetUpProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam)
{
    static TCHAR     achBuffer[21] ;
    UINT fValue;

    switch (Message) {
        case WM_INITDIALOG :
        {

            // Convert from MicroSecPerFrame to FPS -- that's easier !!
            MicroSecToStringRate(achBuffer, gCapParms.dwRequestMicroSecPerFrame);
            SetDlgItemText(hDlg, IDD_FrameRateData, achBuffer);


            // If time limit isn't enabled, disable the time data part
            CheckDlgButton(hDlg, IDD_TimeLimitFlag, (fValue = gCapParms.fLimitEnabled)) ;
            EnableWindow(GetDlgItem(hDlg, IDD_SecondsText), fValue) ;
            EnableWindow(GetDlgItem(hDlg, IDD_SecondsData), fValue) ;
            EnableWindow(GetDlgItem(hDlg, IDD_SecondsArrow), fValue);

            SetDlgItemInt(hDlg, IDD_SecondsData, gCapParms.wTimeLimit, FALSE) ;


            // disable audio buttons if no audio hardware
            {
                CAPSTATUS cs;

                capGetStatus(ghWndCap, &cs, sizeof(cs));
                EnableWindow(GetDlgItem(hDlg, IDD_CapAudioFlag), cs.fAudioHardware);
                EnableWindow(GetDlgItem(hDlg, IDD_AudioConfig), cs.fAudioHardware);

                CheckDlgButton(hDlg, IDD_CapAudioFlag, gCapParms.fCaptureAudio);
            }



            /*
             * Capture To Memory means allocate as many memory buffers
             *  as possible.
             * Capture To Disk means only allocate enough buffers
             *  to get us through disk seeks and thermal recalibrations.
             */

            // The use of fUsingDOSMemory is now just a means of keeping
            // track of whether using lots of buffers.  We never actually
            // allocate exclusively from memory under 1Meg.

            CheckRadioButton(hDlg, IDD_CaptureToDisk, IDD_CaptureToMemory,
              (gCapParms.fUsingDOSMemory)? IDD_CaptureToDisk : IDD_CaptureToMemory);

            // Find out how many MCI devices can source video
            if (CountMCIDevices(MCI_DEVTYPE_VCR) +
                CountMCIDevices(MCI_DEVTYPE_VIDEODISC) == 0) {
                // if no VCRs or Videodiscs, disable the controls
                EnableWindow(GetDlgItem(hDlg, IDD_MCIControlFlag), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDD_MCISetup), FALSE);
            } else {
                EnableWindow(GetDlgItem(hDlg, IDD_MCIControlFlag), TRUE);

                // if MCI Control is selected, enable the setup button
                CheckDlgButton(hDlg, IDD_MCIControlFlag,
                    gCapParms.fMCIControl);
                EnableWindow(GetDlgItem(hDlg, IDD_MCISetup), gCapParms.fMCIControl);
            }

            // place the dialog to avoid covering the capture window
            SmartWindowPosition(hDlg, ghWndCap);
            return TRUE ;
        }

        case WM_COMMAND :
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_TimeLimitFlag :
                    // If this flag changes, en/dis-able time limit data part
                    fValue = IsDlgButtonChecked(hDlg, IDD_TimeLimitFlag) ;
                    EnableWindow(GetDlgItem(hDlg, IDD_SecondsText), fValue) ;
                    EnableWindow(GetDlgItem(hDlg, IDD_SecondsData), fValue) ;
                    EnableWindow(GetDlgItem(hDlg, IDD_SecondsArrow), fValue);
                    return TRUE ;

                case IDD_MCIControlFlag :
                    // If this flag changes, en/dis-able MCI Setup button
                    fValue = IsDlgButtonChecked(hDlg, IDD_MCIControlFlag) ;
                    EnableWindow(GetDlgItem(hDlg, IDD_MCISetup), fValue) ;
                    return TRUE ;

                case IDD_CapAudioFlag:
                    fValue = IsDlgButtonChecked(hDlg, IDD_CapAudioFlag) ;
                    EnableWindow(GetDlgItem(hDlg, IDD_AudioConfig), fValue) ;
                    return TRUE ;


                case IDD_FrameRateData:
                    // get the requested frame rate and check it against bounds
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS) {
                        long l, new_l;

                        GetDlgItemText(hDlg, IDD_FrameRateData, achBuffer, sizeof(achBuffer));
                        new_l = l = StringRateToMicroSec(achBuffer);

                        // note that the MAX rate is SMALL! hence <max, >min
                        if (l == 0) {
                            new_l = DEF_CAPTURE_RATE;
                        } else if (l < MAX_CAPTURE_RATE) {
                            new_l = MAX_CAPTURE_RATE;
                        } else if (l > MIN_CAPTURE_RATE) {
                            new_l = MIN_CAPTURE_RATE;
                        }
                        if (l != new_l) {
                            MicroSecToStringRate(achBuffer, new_l);
                            SetDlgItemText(hDlg, IDD_FrameRateData, achBuffer);
                        }
                    }
                    break;

                case IDD_SecondsData:
                {
                    long l, new_l;

                    // get requested time limit and check validity
                    GetDlgItemText(hDlg, IDD_SecondsData, achBuffer, sizeof(achBuffer));
                    new_l = l = atol(achBuffer);
                    if (l < 1) {
                        new_l = 1;
                    } else if (l > 9999) {
                        new_l = 9999;
                    } else {
                        // make sure there are no non-digit chars
                        // atol() will ignore trailing non-digit characters
                        int c = 0;
                        while (achBuffer[c]) {
                            if (IsCharAlpha(achBuffer[c]) ||
                                !IsCharAlphaNumeric(achBuffer[c])) {

                                // string contains non-digit chars - reset
                                new_l = 1;
                                break;
                            }
                            c++;
                        }
                    }
                    if (new_l != l) {
                        wsprintf(achBuffer, "%ld", new_l);
                        SetDlgItemText(hDlg, IDD_SecondsData, achBuffer);
                        // select the changed text so that if you delete the
                        // '1' and then insert '10' you get 10 not 110
                        SendDlgItemMessage(hDlg, IDD_SecondsData,
                                EM_SETSEL, 0, -1);

                    }
                    break;
                }

                // show audio format setup dialog
                case IDD_AudioConfig:

                    // rather than duplicate lots of code from the
                    // main vidcap winproc, lets just ask it to show the dlg...
                    SendMessage(ghWndMain, WM_COMMAND,
                            GET_WM_COMMAND_MPS(IDM_O_AUDIOFORMAT, NULL, 0));

                    break;


                // show MCI step control dialog
                case IDD_MCISetup:
                    DoDialog(hDlg, IDD_MCISETUP, MCISetupProc, 0);
                    break;

                // show video format setup dialog
                case IDD_VideoConfig:
                    // rather than duplicate lots of code from the
                    // main vidcap winproc, lets just ask it to show the dlg...
                    SendMessage(ghWndMain, WM_COMMAND,
                            GET_WM_COMMAND_MPS(IDM_O_VIDEOFORMAT, NULL, 0));
                    break;

                // show the compressor selector dialog
                case IDD_CompConfig:
                    capDlgVideoCompression(ghWndCap);
                    break;



                case IDOK :
                {

                    gCapParms.fCaptureAudio =
                                IsDlgButtonChecked(hDlg, IDD_CapAudioFlag) ;
                    gCapParms.fMCIControl =
                            IsDlgButtonChecked(hDlg, IDD_MCIControlFlag);
                    gCapParms.fLimitEnabled = IsDlgButtonChecked(hDlg, IDD_TimeLimitFlag) ;

                    GetDlgItemText(hDlg, IDD_FrameRateData, achBuffer, sizeof(achBuffer));
                    gCapParms.dwRequestMicroSecPerFrame = StringRateToMicroSec(achBuffer);
                    if (gCapParms.dwRequestMicroSecPerFrame == 0) {
                        gCapParms.dwRequestMicroSecPerFrame = DEF_CAPTURE_RATE;
                    }

                    GetDlgItemText(hDlg, IDD_SecondsData, achBuffer, sizeof(achBuffer));
                    if (gCapParms.fLimitEnabled) {
                         gCapParms.wTimeLimit  = (UINT) atol(achBuffer);
                    }

                    // fUsingDOSMemory is archaic and is now just a flag reflecting
                    // the "CaptureToDisk" selection.
                    // 
                    gCapParms.fUsingDOSMemory = 
                                IsDlgButtonChecked(hDlg, IDD_CaptureToDisk);

                    EndDialog(hDlg, TRUE) ;
                    return TRUE ;
                }

                case IDCANCEL :
                    EndDialog(hDlg, FALSE) ;
                    return TRUE ;
            }
            break ;

        case WM_VSCROLL:
        // message from one of the arrow spinbuttons
        {
            UINT id;

            id = GetDlgCtrlID(GET_WM_COMMAND_HWND(wParam, lParam));
            if (id == IDD_FrameRateArrow) {
                // format n.nnn
                MilliSecVarArrowEditChange(
                    GetDlgItem(hDlg, IDD_FrameRateData),
                    GET_WM_VSCROLL_CODE(wParam, lParam),
                    1, 100, 1);
            } else {
                // simple integer format
                ArrowEditChange(
                    GetDlgItem(hDlg, IDD_SecondsData),
                    GET_WM_VSCROLL_CODE(wParam, lParam),
                    1, 30000);
            }
            break;
        }

    }

    return FALSE ;
}

/*
 * preferences dialog - sets global options about background colour,
 * presence of toolbar, status bar etc
 */
LRESULT FAR PASCAL
PrefsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    DWORD indexsz;

    switch(message) {


    case WM_INITDIALOG:
        CheckDlgButton(hDlg, IDD_PrefsStatus, gbStatusBar);
        CheckDlgButton(hDlg, IDD_PrefsToolbar, gbToolBar);
        CheckDlgButton(hDlg, IDD_PrefsCentre, gbCentre);
        CheckDlgButton(hDlg, IDD_PrefsSizeFrame, gbAutoSizeFrame);
        CheckRadioButton(hDlg, IDD_PrefsDefBackground, IDD_PrefsBlack, gBackColour);

        CheckRadioButton(hDlg, IDD_PrefsSmallIndex, IDD_PrefsBigIndex,
                    (gCapParms.dwIndexSize == CAP_LARGE_INDEX) ?
                    IDD_PrefsBigIndex : IDD_PrefsSmallIndex);

        CheckRadioButton(hDlg, IDD_PrefsMasterAudio, IDD_PrefsMasterNone,
                    gCapParms.AVStreamMaster + IDD_PrefsMasterAudio);

        return(TRUE);

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            return(TRUE);

        case IDOK:
            gbStatusBar = IsDlgButtonChecked(hDlg, IDD_PrefsStatus);
            gbToolBar = IsDlgButtonChecked(hDlg, IDD_PrefsToolbar);
            gbCentre = IsDlgButtonChecked(hDlg, IDD_PrefsCentre);
            gbAutoSizeFrame = IsDlgButtonChecked(hDlg, IDD_PrefsSizeFrame);

            if (IsDlgButtonChecked(hDlg, IDD_PrefsDefBackground)) {
                gBackColour = IDD_PrefsDefBackground;
            } else if (IsDlgButtonChecked(hDlg, IDD_PrefsLtGrey)) {
                gBackColour = IDD_PrefsLtGrey;
            } else if (IsDlgButtonChecked(hDlg, IDD_PrefsDkGrey)) {
                gBackColour = IDD_PrefsDkGrey;
            } else {
                gBackColour = IDD_PrefsBlack;
            }

            if (IsDlgButtonChecked(hDlg, IDD_PrefsSmallIndex)) {
                indexsz = CAP_SMALL_INDEX;

            } else {
                indexsz = CAP_LARGE_INDEX;
            }
            if (indexsz != gCapParms.dwIndexSize) {
                gCapParms.dwIndexSize = indexsz;
            }

            if (IsDlgButtonChecked(hDlg, IDD_PrefsMasterAudio)) {
                gCapParms.AVStreamMaster = AVSTREAMMASTER_AUDIO;
            }
            else {
                gCapParms.AVStreamMaster = AVSTREAMMASTER_NONE;
            }

            EndDialog(hDlg, TRUE);
            return(TRUE);
        }
        break;
    }
    return FALSE;
}


LRESULT FAR PASCAL
NoHardwareDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static HBRUSH hbr;

    switch(message) {
    case WM_INITDIALOG:
        // lParam contains the argument to DialogBoxParam which is the
        // reason text
        SetDlgItemText(hDlg, IDD_FailReason, (LPTSTR) lParam);

        hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
        return TRUE;

    case WM_DESTROY:
        DeleteObject(hbr);

#ifdef _WIN32
    case WM_CTLCOLORSTATIC:
#else
    case WM_CTLCOLOR:
#endif
        if (GET_WM_CTLCOLOR_HWND(wParam, lParam, message) == GetDlgItem(hDlg, IDD_FailReason)) {

            HDC hdc;

            hdc = GET_WM_CTLCOLOR_HDC(wParam, lParam, message);

            SetTextColor(hdc, RGB(0xff, 0, 0));
            SetBkColor(hdc, GetSysColor(COLOR_WINDOW));

            // in order to ensure that the text colour we have chosen for
            // this control is used, we need to actually return a brush.
            // for win31, we also need to align the brush
#ifndef _WIN32
            {
                POINT pt;

                pt.x = 0;
                pt.y = 0;
                ClientToScreen(hDlg, &pt);
                UnrealizeObject(hbr);
                SetBrushOrg(hdc, pt.x, pt.y);
            }
#endif

            return((INT_PTR) hbr);

        }
        break;

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDOK:
            EndDialog(hDlg, TRUE);
            return(TRUE);
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            return(TRUE);
        }
        break;
    }

    return(FALSE);
}


//capture selected single frames
LRESULT
FAR PASCAL
CapFramesProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam)
{
    TCHAR ach[MAX_PATH*2];
    TCHAR achName[MAX_PATH];

    static BOOL bFirst;
    static int iFrames;

    switch(Message) {
    case WM_INITDIALOG:

        // write out the prompt message including the capture file name
        capFileGetCaptureFile(ghWndCap, achName, sizeof(achName));
        wsprintf(ach, tmpString(IDS_PROMPT_CAPFRAMES), achName);
        SetDlgItemText(hDlg, IDD_CapMessage, ach);

        bFirst = TRUE;

        //move dialog so it doesn't obscure the capture window
        SmartWindowPosition(hDlg, ghWndCap);

        return(TRUE);

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam, lParam)) {

        case IDCANCEL:
            if (!bFirst) {
                capCaptureSingleFrameClose(ghWndCap);
                EndDialog(hDlg, TRUE);
            } else {
                EndDialog(hDlg, FALSE);
            }
            return(TRUE);

        case IDOK:
            if (bFirst) {
                bFirst = FALSE;
                iFrames = 0;
                capCaptureSingleFrameOpen(ghWndCap);

                SetDlgItemText(hDlg, IDCANCEL, tmpString(IDS_CAP_CLOSE));

            }
            capCaptureSingleFrame(ghWndCap);
            iFrames++;

            wsprintf(ach, tmpString(IDS_STATUS_NUMFRAMES), iFrames);
            SetDlgItemText(hDlg, IDD_CapNumFrames, ach);
            return(TRUE);

        }
        break;
    }
    return(FALSE);
}

// enumerate all the MCI devices of a particular type and add them and
// their descriptions to a combo box list.
//
void
AddMCIDeviceNames(UINT wDeviceType, HWND hwndCB)
{
    int   nIndex;
    MCI_OPEN_PARMS mciOp;
    MCI_INFO_PARMS mciIp;
    MCI_SYSINFO_PARMS mciSIP;
    MCI_GENERIC_PARMS mciGp;
    TCHAR buf[MAXPNAMELEN + 128]; // Contains eg. Name\t\tVideodisc1
    TCHAR buf2 [64];
    int maxdevs;
    DWORD dwRet;

    // To get the user readable names of the devices, we
    // must open all appropriate devices, and then get info.

    // MCI Open structure
    mciOp.dwCallback = 0;
    mciOp.lpstrElementName = NULL;
    mciOp.lpstrAlias = NULL;

    // MCI Info structure
    mciIp.dwCallback = 0;
    mciIp.lpstrReturn = (LPTSTR) buf;
    mciIp.dwRetSize = MAXPNAMELEN - 1;

    // MCI SysInfo structure
    mciSIP.dwCallback = 0;
    mciSIP.lpstrReturn = (LPTSTR) buf2;
    mciSIP.dwRetSize = sizeof (buf2);
    mciSIP.wDeviceType = wDeviceType;

    // MCI Generic structure
    mciGp.dwCallback = 0;

    // Load the combobox with the product info name, followed by
    // a comma, then a space, and then the mci device name. This allows a
    // single alphabetized list to be kept.

    // eg.
    // Pioneer Laserdisc, videodisc1

    maxdevs = CountMCIDevices((UINT)mciSIP.wDeviceType);
    for (nIndex = 0; nIndex < maxdevs; nIndex++) {

       // Get the system name eg. Videodisc1
       mciSIP.dwNumber = nIndex + 1;
       dwRet = mciSendCommand (0, MCI_SYSINFO,
                    MCI_SYSINFO_NAME,
                    (DWORD_PTR) (LPVOID) &mciSIP);

       mciOp.lpstrDeviceType =
            (LPTSTR) MAKELONG (wDeviceType, nIndex);

       if (!(dwRet = mciSendCommand(0, MCI_OPEN,
                    MCI_WAIT | MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID |
                    MCI_OPEN_SHAREABLE,
                    (DWORD_PTR) (LPVOID) &mciOp))) {
            if (!(dwRet = mciSendCommand (mciOp.wDeviceID, MCI_INFO,
                            MCI_WAIT | MCI_INFO_PRODUCT,
                            (DWORD_PTR) (LPVOID) &mciIp))) {
                lstrcat (buf, ", ");         // append the delimiter
                lstrcat (buf, buf2);         // append the system name
                // Whew, finally put it in the listbox
                SendMessage( hwndCB, CB_ADDSTRING, 0,
                                (LONG_PTR)(LPTSTR) buf);
            } //endif got INFO
            // Close it now
            mciSendCommand (mciOp.wDeviceID, MCI_CLOSE,
                            MCI_WAIT,
                            (DWORD_PTR) (LPVOID) &mciGp);
       } // endif OPEN
    } // endif for all devices of this type
}


//
// dialog proc to select MCI device and parameters, including start,
// stop times.
LRESULT FAR PASCAL
MCISetupProc(HWND hwnd, unsigned msg, WPARAM wParam, LPARAM lParam)
{
  HWND  hwndCB;
  DWORD dw;
  TCHAR buf[MAXPNAMELEN];
  BOOL f;
  int j;
  static int nLastCBIndex = 0;
  static DWORD tdwMCIStartTime;
  static DWORD tdwMCIStopTime;



  switch (msg) {
    case WM_INITDIALOG:

      	CheckRadioButton(hwnd, IDD_MCI_PLAY, IDD_MCI_STEP,
			    gCapParms.fStepMCIDevice ?
                            IDD_MCI_STEP : IDD_MCI_PLAY );

        // enable averaging options only in step mode
        EnableWindow (GetDlgItem (hwnd, IDD_MCI_AVERAGE_2X), gCapParms.fStepMCIDevice);
        EnableWindow (GetDlgItem (hwnd, IDD_MCI_AVERAGE_FR), gCapParms.fStepMCIDevice);
	SetDlgItemInt(hwnd, IDD_MCI_AVERAGE_FR, gCapParms.wStepCaptureAverageFrames, FALSE);
        CheckDlgButton (hwnd, IDD_MCI_AVERAGE_2X, gCapParms.fStepCaptureAt2x);

        // save current dialog time settings
        tdwMCIStartTime = gCapParms.dwMCIStartTime;
        tdwMCIStopTime  = gCapParms.dwMCIStopTime;

        TimeMSToHMSString (gCapParms.dwMCIStartTime, buf);
        SetDlgItemText (hwnd, IDD_MCI_STARTTIME, buf);
        TimeMSToHMSString (gCapParms.dwMCIStopTime, buf);
        SetDlgItemText (hwnd, IDD_MCI_STOPTIME, buf);


        // fill combo box with list of MCI devices
	hwndCB = GetDlgItem( hwnd, IDD_MCI_SOURCE );
        AddMCIDeviceNames(MCI_DEVTYPE_VIDEODISC, hwndCB);
        AddMCIDeviceNames(MCI_DEVTYPE_VCR, hwndCB);


        // set the selection to whatever he chose last time through this dlg
        // default is the first entry.
       	SendMessage( hwndCB, CB_SETCURSEL, nLastCBIndex, 0L);
	break;

    case WM_COMMAND:
	switch (GET_WM_COMMAND_ID(wParam, lParam)) {
	    case IDOK:
                // i think the point of this is to ensure that
                // the KILLFOCUS processing for the edit boxes has been done
                // and thus the temp times are the same as the dialog text
                SetFocus(GET_WM_COMMAND_HWND(wParam, lParam));


                MCIGetDeviceNameAndIndex (hwnd, &nLastCBIndex, gachMCIDeviceName);
                capSetMCIDeviceName(ghWndCap, gachMCIDeviceName) ;
                gCapParms.fStepMCIDevice = IsDlgButtonChecked (hwnd, IDD_MCI_STEP);

                // pick up the temp times - these were set on KILLFOCUS msgs
                // (when we did validation and string->dword conversion
                gCapParms.dwMCIStartTime = tdwMCIStartTime;
                gCapParms.dwMCIStopTime  = tdwMCIStopTime;

                gCapParms.fStepCaptureAt2x = IsDlgButtonChecked (hwnd, IDD_MCI_AVERAGE_2X);
                gCapParms.wStepCaptureAverageFrames = GetDlgItemInt (hwnd, IDD_MCI_AVERAGE_FR, NULL, FALSE);

		EndDialog(hwnd, TRUE);
		break;
		
	    case IDCANCEL:
		EndDialog(hwnd, 0);
		break;

            case IDD_MCI_STEP:
            case IDD_MCI_PLAY:
                //averaging only enabled in play mode
                f = IsDlgButtonChecked (hwnd, IDD_MCI_STEP);
                EnableWindow (GetDlgItem (hwnd, IDD_MCI_AVERAGE_2X), f);
                EnableWindow (GetDlgItem (hwnd, IDD_MCI_AVERAGE_FR), f);
                break;

            case IDD_MCI_AVERAGE_FR:
                // validate the count of frames to average 1..100
                if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS) {
                    j = GetDlgItemInt(hwnd,
                            GET_WM_COMMAND_ID(wParam, lParam), NULL, FALSE);
                    // Limit frames to average between 1 and 100
                    if (j < 1 || j > 100) {
	                SetDlgItemInt (hwnd,
                            GET_WM_COMMAND_ID(wParam, lParam), 1, FALSE);
                    }
                }
                break;

            case IDD_MCI_STARTSET:
	    case IDD_MCI_STOPSET:
                // set the start or stop time to be the time
                // on the device right now.

                // MCI devices could yield and cause us to re-enter - the
                // simplest answer seems to be to disable the dialog
                EnableWindow(hwnd, FALSE);

                MCIGetDeviceNameAndIndex (hwnd, &nLastCBIndex, buf);

                if (MCIDeviceOpen (buf)) {
                    if (GET_WM_COMMAND_ID(wParam, lParam) == IDD_MCI_STARTSET) {
                        if (MCIDeviceGetPosition (&tdwMCIStartTime)) {
                           TimeMSToHMSString (tdwMCIStartTime, buf);
                           SetDlgItemText (hwnd, IDD_MCI_STARTTIME, buf);
                        }
                        else {
                            MessageBoxID(IDS_MCI_CONTROL_ERROR,
                                        MB_OK|MB_ICONEXCLAMATION);
                        }
                    }
                    else {
                        if (MCIDeviceGetPosition (&tdwMCIStopTime)) {
                            TimeMSToHMSString (tdwMCIStopTime, buf);
                            SetDlgItemText (hwnd, IDD_MCI_STOPTIME, buf);
                        }
                        else {
                            MessageBoxID(IDS_MCI_CONTROL_ERROR,
                                        MB_OK|MB_ICONEXCLAMATION);
                        }
                    }
                    MCIDeviceClose ();

                } else {
                    // cant open device
                    MessageBoxID(IDS_MCI_CONTROL_ERROR,
                                MB_OK|MB_ICONEXCLAMATION);
                }
                EnableWindow(hwnd, TRUE);
                break;


            case IDD_MCI_STARTTIME:
            case IDD_MCI_STOPTIME:
                if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS) {
                    GetDlgItemText (hwnd,
                        GET_WM_COMMAND_ID(wParam, lParam), buf, sizeof (buf));
                    if ((dw = TimeHMSStringToMS (buf)) == -1) {
                        // Error in string, reset
                        MessageBeep (0);
                        if (GET_WM_COMMAND_ID(wParam, lParam) == IDD_MCI_STARTTIME)
                            dw = tdwMCIStartTime;
                        else
                            dw = tdwMCIStopTime;
                    }
                    if (GET_WM_COMMAND_ID(wParam, lParam) == IDD_MCI_STARTTIME) {
                        tdwMCIStartTime = dw;
                        TimeMSToHMSString (tdwMCIStartTime, buf);
                        SetDlgItemText (hwnd, IDD_MCI_STARTTIME, buf);
                    }
                    else {
                        tdwMCIStopTime = dw;
                        TimeMSToHMSString (tdwMCIStopTime, buf);
                        SetDlgItemText (hwnd, IDD_MCI_STOPTIME, buf);
                    }
                }
                break;
	}
	break;

  }
  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\vidcap32\profile.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/
/****************************************************************************
 *
 *   profile.c: Stores profile info in the Registry 
 *
 *   Vidcap32 Source code
 *
 ***************************************************************************/

/*
 * win32/win16 utility functions to read and write profile items
 * for multimedia tools
 */

#include <windows.h>
#include <windowsx.h>

#ifdef _WIN32
#define KEYNAME     "Software\\Microsoft\\Multimedia Tools\\"
#define ROOTKEY     HKEY_CURRENT_USER
#else
#define INIFILE    "mmtools.ini"
#endif


/*
 * read a BOOL flag from the profile, or return default if
 * not found.
 */
BOOL
mmGetProfileFlag(LPTSTR appname, LPTSTR valuename, BOOL bDefault)
{
#ifdef _WIN32
    TCHAR achName[MAX_PATH];
    HKEY hkey;
    DWORD dwType;
    BOOL bValue = bDefault;
    DWORD dwData;
    int cbData;


    lstrcpy(achName, KEYNAME);
    lstrcat(achName, appname);
    if (RegOpenKey(ROOTKEY, achName, &hkey) != ERROR_SUCCESS) {
        return(bDefault);
    }

    cbData = sizeof(dwData);
    if (RegQueryValueEx(
        hkey,
        valuename,
        NULL,
        &dwType,
        (PBYTE) &dwData,
        &cbData) == ERROR_SUCCESS) {
            if (dwType == REG_DWORD) {
                if (dwData) {
                    bValue = TRUE;
                } else {
                    bValue = FALSE;
                }
            }
    }

    RegCloseKey(hkey);

    return(bValue);
#else
    TCHAR ach[10];

    GetPrivateProfileString(appname, valuename, "X", ach, sizeof(ach),
            INIFILE);

    switch(ach[0]) {
    case 'N':
    case 'n':
    case '0':
        return(FALSE);

    case 'Y':
    case 'y':
    case '1':
        return(TRUE);

    default:
        return(bDefault);
    }
#endif
}


/*
 * write a boolean value to the registry, if it is not the
 * same as the default or the value already there
 */
VOID
mmWriteProfileFlag(LPTSTR appname, LPTSTR valuename, BOOL bValue, BOOL bDefault)
{
    if (mmGetProfileFlag(appname, valuename, bDefault) == bValue) {
        return;
    }

#ifdef _WIN32
    {
        TCHAR achName[MAX_PATH];
        HKEY hkey;

        lstrcpy(achName, KEYNAME);
        lstrcat(achName, appname);
        if (RegCreateKey(ROOTKEY, achName, &hkey) == ERROR_SUCCESS) {
            RegSetValueEx(
                hkey,
                valuename,
                0,
                REG_DWORD,
                (PBYTE) &bValue,
                sizeof(bValue)
            );

            RegCloseKey(hkey);
        }
    }

#else
    WritePrivateProfileString(
        appname,
        valuename,
        bValue ? "1" : "0",
        INIFILE);
#endif
}

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
UINT
mmGetProfileInt(LPTSTR appname, LPTSTR valuename, UINT uDefault)
{
#ifdef _WIN32
    TCHAR achName[MAX_PATH];
    HKEY hkey;
    DWORD dwType;
    UINT value = uDefault;
    DWORD dwData;
    int cbData;


    lstrcpy(achName, KEYNAME);
    lstrcat(achName, appname);
    if (RegOpenKey(ROOTKEY, achName, &hkey) != ERROR_SUCCESS) {
        return(uDefault);
    }

    cbData = sizeof(dwData);
    if (RegQueryValueEx(
        hkey,
        valuename,
        NULL,
        &dwType,
        (PBYTE) &dwData,
        &cbData) == ERROR_SUCCESS) {
            if (dwType == REG_DWORD) {
                value = (UINT)dwData;
            }
    }

    RegCloseKey(hkey);

    return(value);
#else
    return(GetPrivateProfileInt(appname, valuename, uDefault, INIFILE);
#endif
}


/*
 * write a UINT to the profile, if it is not the
 * same as the default or the value already there
 */
VOID
mmWriteProfileInt(LPTSTR appname, LPTSTR valuename, UINT uValue, UINT uDefault)
{
    if (mmGetProfileInt(appname, valuename, uDefault) == uValue) {
        return;
    }

#ifdef _WIN32
    {
        TCHAR achName[MAX_PATH];
        HKEY hkey;

        lstrcpy(achName, KEYNAME);
        lstrcat(achName, appname);
        if (RegCreateKey(ROOTKEY, achName, &hkey) == ERROR_SUCCESS) {
            RegSetValueEx(
                hkey,
                valuename,
                0,
                REG_DWORD,
                (PBYTE) &uValue,
                sizeof(uValue)
            );

            RegCloseKey(hkey);
        }
    }

#else
    TCHAR ach[12];

    wsprintf(ach, "%d", uValue);

    WritePrivateProfileString(
        appname,
        valuename,
        ach,
        INIFILE);
#endif
}


/*
 * read a string from the profile into pResult.
 * result is number of bytes written into pResult
 */
DWORD
mmGetProfileString(
    LPTSTR appname,
    LPTSTR valuename,
    LPTSTR pDefault,
    LPTSTR pResult,
    int cbResult
)
{
#ifdef _WIN32
    TCHAR achName[MAX_PATH];
    HKEY hkey;
    DWORD dwType;


    lstrcpy(achName, KEYNAME);
    lstrcat(achName, appname);
    if (RegOpenKey(ROOTKEY, achName, &hkey) == ERROR_SUCCESS) {

        if (RegQueryValueEx(
            hkey,
            valuename,
            NULL,
            &dwType,
            pResult,
            &cbResult) == ERROR_SUCCESS) {

                if (dwType == REG_SZ) {
                    // cbResult is set to the size including null
                    RegCloseKey(hkey);
                    return(cbResult - 1);
                }
        }


        RegCloseKey(hkey);
    }

    // if we got here, we didn't find it, or it was the wrong type - return
    // the default string
    lstrcpy(pResult, pDefault);
    return(lstrlen(pDefault));

#else
    return GetPrivateProfileString(
                appname,
                valuename,
                pDefault,
                pResult,
                cbResult
                INIFILE);
#endif
}


/*
 * write a string to the profile
 */
VOID
mmWriteProfileString(LPTSTR appname, LPTSTR valuename, LPSTR pData)
{
#ifdef _WIN32
    TCHAR achName[MAX_PATH];
    HKEY hkey;

    lstrcpy(achName, KEYNAME);
    lstrcat(achName, appname);
    if (RegCreateKey(ROOTKEY, achName, &hkey) == ERROR_SUCCESS) {
        RegSetValueEx(
            hkey,
            valuename,
            0,
            REG_SZ,
            pData,
            lstrlen(pData) + 1
        );

        RegCloseKey(hkey);
    }

#else
    WritePrivateProfileString(
        appname,
        valuename,
        pData,
        INIFILE);
#endif
}

/*
 * read binary values from the profile into pResult.
 * result is number of bytes written into pResult
 */
DWORD
mmGetProfileBinary(
    LPTSTR appname,
    LPTSTR valuename,
    LPVOID pDefault,  
    LPVOID pResult,   // if NULL, return the required size
    int cbSize
)
{
    TCHAR achName[MAX_PATH];
    HKEY hkey;
    DWORD dwType;
    int cbResult = cbSize;

    lstrcpy(achName, KEYNAME);
    lstrcat(achName, appname);
    if (RegOpenKey(ROOTKEY, achName, &hkey) == ERROR_SUCCESS) {

        if (RegQueryValueEx(
            hkey,
            valuename,
            NULL,
            &dwType,
            pResult,
            &cbResult) == ERROR_SUCCESS) {

                if (dwType == REG_BINARY) {
                    // cbResult is the size
                    RegCloseKey(hkey);
                    return(cbResult);
                }
        }


        RegCloseKey(hkey);
    }

    // if we got here, we didn't find it, or it was the wrong type - return
    // the default values (use MoveMemory, since src could equal dst)
    MoveMemory (pResult, pDefault, cbSize);
    return cbSize;

}


/*
 * write binary data to the profile
 */
VOID
mmWriteProfileBinary(LPTSTR appname, LPTSTR valuename, LPVOID pData, int cbData)
{
    TCHAR achName[MAX_PATH];
    HKEY hkey;

    lstrcpy(achName, KEYNAME);
    lstrcat(achName, appname);
    if (RegCreateKey(ROOTKEY, achName, &hkey) == ERROR_SUCCESS) {
        RegSetValueEx(
            hkey,
            valuename,
            0,
            REG_BINARY,
            pData,
            cbData
        );

        RegCloseKey(hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\vidcap32\profile.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/
/****************************************************************************
 *
 *   profile.h: Registry access 
 *
 *   Vidcap32 Source code
 *
 ***************************************************************************/

/*
 * utility functions to read and write values to the profile,
 * using mmtools.ini for Win16 or current user\software\microsoft\mm tools
 * in the registry for Win32
 */

/*
 * read a BOOL flag from the profile, or return default if
 * not found.
 */
BOOL mmGetProfileFlag(LPTSTR appname, LPTSTR valuename, BOOL bDefault);

/*
 * write a boolean value to the registry, if it is not the
 * same as the default or the value already there
 */
VOID mmWriteProfileFlag(LPTSTR appname, LPTSTR valuename, BOOL bValue, BOOL bDefault);

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
UINT mmGetProfileInt(LPTSTR appname, LPTSTR valuename, UINT uDefault);

/*
 * write a UINT to the profile, if it is not the
 * same as the default or the value already there
 */
VOID mmWriteProfileInt(LPTSTR appname, LPTSTR valuename, UINT uValue, UINT uDefault);

/*
 * read a string from the profile into pResult.
 * result is number of bytes written into pResult
 */
DWORD
mmGetProfileString(
    LPTSTR appname,
    LPTSTR valuename,
    LPTSTR pDefault,
    LPTSTR pResult,
    int cbResult
);


/*
 * write a string to the profile
 */
VOID mmWriteProfileString(LPTSTR appname, LPTSTR valuename, LPTSTR pData);


/*
 * read binary values from the profile into pResult.
 * result is number of bytes written into pResult
 */
DWORD
mmGetProfileBinary(
    LPTSTR appname,
    LPTSTR valuename,
    LPVOID pDefault,  
    LPVOID pResult,   // if NULL, return the required buffer size
    int cbSize);

/*
 * write binary data to the profile
 */
VOID
mmWriteProfileBinary(LPTSTR appname, LPTSTR valuename, LPVOID pData, int cbData);
		   





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\vidcap32\rlmeter.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/
/****************************************************************************
 *
 *   rlmeter.h: Audio recording level meter
 *
 *   Vidcap32 Source code
 *
 ***************************************************************************/

/*
 * interface definition for rlmeter window class.
 *
 * This window class acts as a 'VU Meter' showing the current and peak
 * volume. Set the volume via the WMRL_SETLEVEL message (lParam is new level).
 * The peak level will be tracked by the control by means of a 2-second timer.
 */


// call (if first instance) to register class
BOOL RLMeter_Register(HINSTANCE hInstance);


//create a window of this class
#define RLMETERCLASS    TEXT("VCRLMeter")


//send this message to set the current level (wParam not used, lParam == level)
#define WMRL_SETLEVEL   (WM_USER+1)



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\vidcap32\rlmeter.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/
/****************************************************************************
 *
 *   rlmeter.c: Audio recording level window
 *
 *   Vidcap32 Source code
 *
 ***************************************************************************/

/*
 * This window class acts as a 'VU Meter' showing the current and peak
 * volume. Set the volume via the WMRL_SETLEVEL message (lParam is new level).
 * The peak level will be tracked by the control by means of a 2-second timer.
 */

#include <windows.h>
#include <windowsx.h>

#include "rlmeter.h"

#ifdef _WIN32
#ifndef EXPORT
#define EXPORT
#endif
#endif

LRESULT FAR PASCAL EXPORT
RLMeterProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

/*
 * generic window class to support a volume level display.
 *
 * The window has a white background, and draws a black filled
 * rectangle to show the current volume level, and a red line at the
 * peak. Every two seconds on a timer we lower the peak (we set the
 * saved peak value to 0 so that at the next update we move the line to
 * whatever is the current level.
 *
 * We store the pen and brush handles and the current and maximum levels
 * as window words using SetWindowWord on win16 and SetWindowLong on win32.
 */

// window data layout
#define WD_MAX      0                           // current max
#define WD_PREVMAX  (WD_MAX + sizeof(UINT))     // currently drawn max
#define WD_PREVLVL  (WD_PREVMAX + sizeof(UINT)) // currently drawn level

#define WD_PEN      (WD_PREVLVL + sizeof(UINT)) // pen for max line

#define WDBYTES     (WD_PEN + sizeof(UINT_PTR))     // window bytes to alloc

#ifdef _WIN32
#define SetWindowUINT     SetWindowLong
#define GetWindowUINT     GetWindowLong
#define SetWindowUINTPtr     SetWindowLongPtr
#define GetWindowUINTPtr     GetWindowLongPtr
#else
#define SetWindowUINT     SetWindowWord
#define GetWindowUINT     GetWindowWord
#define SetWindowUINTPtr     SetWindowWord
#define GetWindowUINTPtr     GetWindowWord
#endif


// call (if first instance) to register class
BOOL
RLMeter_Register(HINSTANCE hInstance)
{
    WNDCLASS cls;

    cls.hCursor        = LoadCursor(NULL,IDC_ARROW);
    cls.hIcon          = NULL;
    cls.lpszMenuName   = NULL;
    cls.lpszClassName  = RLMETERCLASS;
    cls.hbrBackground  = GetStockObject(WHITE_BRUSH);
    cls.hInstance      = hInstance;
    cls.style          = CS_HREDRAW | CS_VREDRAW;
    cls.lpfnWndProc    = RLMeterProc;
    cls.cbClsExtra     = 0;
    cls.cbWndExtra     = WDBYTES;

    return RegisterClass(&cls);


}


LRESULT FAR PASCAL EXPORT
RLMeterProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message) {
    case WM_CREATE:
        // init current level and max to 0
        SetWindowUINT(hwnd, WD_MAX, 0);
        SetWindowUINT(hwnd, WD_PREVMAX, 0);
        SetWindowUINT(hwnd, WD_PREVLVL, 0);

        // create a red pen for the max line and store this
        SetWindowUINTPtr(hwnd, WD_PEN,
                (UINT_PTR) CreatePen(PS_SOLID, 2, RGB(255, 0, 0)));

        break;

    case WM_DESTROY:
        // destroy the pen we created
        {
            HPEN hpen = (HPEN) GetWindowUINTPtr(hwnd, WD_PEN);
            if (hpen) {
                DeleteObject(hpen);
                SetWindowUINTPtr(hwnd, WD_PEN, 0);
            }

            // also kill the timer we created
            KillTimer(hwnd, 0);
        }
        break;

    case WM_PAINT:
        /*
         * paint the entire control
         *
         * nb we must paint exactly as it is currently drawn because we
         * may be clipped to only part of the control. Thus we must draw
         * the max at WD_PREVMAX as it is currently drawn, since WD_MAX
         * may have been set to 0 and not yet drawn - in this case, with
         * some unfortunate timing and clipping, we would have two max lines.
         */
        {
            PAINTSTRUCT ps;
            HDC hdc;
            RECT rc, rcFill;
            HPEN hpenOld, hpen;

            hdc = BeginPaint(hwnd, &ps);

            GetClientRect(hwnd, &rc);

            // treat the level as a percentage and fill that much of the
            // control with black (from left)
            rcFill = rc;
            rcFill.right = (rc.right * GetWindowUINT(hwnd, WD_PREVLVL)) / 100;
            SetBkColor(hdc, RGB(0,0,0));
            // easy way to fill without creating a brush
            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcFill, NULL, 0, NULL);

            // draw the max line
            rcFill.right = (rc.right * GetWindowUINT(hwnd, WD_PREVLVL)) / 100;
            hpen = (HPEN) GetWindowUINTPtr(hwnd, WD_PEN);
            hpenOld = SelectObject(hdc, hpen);
            MoveToEx(hdc, rcFill.right, rcFill.top, NULL);
            LineTo(hdc, rcFill.right, rcFill.bottom);
            SelectObject(hdc, hpenOld);

            EndPaint(hwnd, &ps);

        }
        break;

    case WMRL_SETLEVEL:
        // set new level, and update the displayed level block and max line
        {
            RECT rc, rcFill;
            UINT uMax, uPrevMax, uPrevLevel, uLevel;
            HDC hdc;

            // new level is lParam
            uLevel = (UINT) lParam;

            // fetch other parameters
            uMax = GetWindowUINT(hwnd, WD_MAX);
            uPrevMax = GetWindowUINT(hwnd, WD_PREVMAX);
            uPrevLevel = GetWindowUINT(hwnd, WD_PREVLVL);


            // decay the max level. This rate works best if we are called
            // to update every 1/20th sec - in this case the decay will be
            // 64% in a second.
            if (uMax > 0) {
                uMax = (uMax * 2007) / 2048;     // = 0.98 * uMax
            }

            hdc = GetDC(hwnd);

            GetClientRect(hwnd, &rc);
            rcFill = rc;

            // is the current level a new peak ?
            if (uLevel > uMax) {
                uMax = uLevel;
            }

            SetWindowUINT(hwnd, WD_MAX, uMax);

            // if the max has moved, erase the old line
            if (uMax != uPrevMax) {
                // white out the line by filling a 2-pixel wide rect
                rcFill.right = ((rc.right * uPrevMax) / 100) + 1;
                rcFill.left = rcFill.right - 2;
                SetBkColor(hdc, RGB(255, 255, 255));
                ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcFill, NULL, 0, NULL);
            }

            // calculate the area to update
            rcFill.right = (rc.right * uPrevLevel) / 100;
            rcFill.left = (rc.right * uLevel) / 100;

            // are we erasing (lowering level) or drawing more black?
            if (rcFill.right > rcFill.left) {

                // level has dropped - so fill with white down to new level
                SetBkColor(hdc, RGB(255, 255, 255));
            } else {
                // level has gone up so fill with black up to new level
                int t;

                t = rcFill.right;
                rcFill.right = rcFill.left;
                rcFill.left = t;

                SetBkColor(hdc, RGB(0, 0, 0));

                // fill a little extra to ensure no rounding gaps
                if (rcFill.left > 0) {
                    rcFill.left -= 1;
                }
            }
            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcFill, NULL, 0, NULL);
            SetWindowUINT(hwnd, WD_PREVLVL, uLevel);

            // draw the new max line if needed
            if (uMax != uPrevMax) {
                HPEN hpen, hpenOld;

                rcFill.right = (rc.right * uMax) /100;

                hpen = (HPEN) GetWindowUINTPtr(hwnd, WD_PEN);
                hpenOld = SelectObject(hdc, hpen);
                MoveToEx(hdc, rcFill.right, rcFill.top, NULL);
                LineTo(hdc, rcFill.right, rcFill.bottom);
                SelectObject(hdc, hpenOld);

                SetWindowUINT(hwnd, WD_PREVMAX, uMax);
            }
            ReleaseDC(hwnd, hdc);
            return(0);
        }

    }
    return DefWindowProc(hwnd, message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\vidcap32\toolbar.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/
/****************************************************************************
 *
 *   toolbar.h: Toolbar include file
 *
 *   Vidcap32 Source code
 *
 ***************************************************************************/

/*****************************************************************************
*                                                                            *
*  Program Description: Implements a generic toolbar.         		     *
*                                                                            *
*  Here's how to use it:                                                     *
*                                                                            *
*            Include the source files "toolbar.h" and "toolbar.c" in your    *
*  application.                                                              *
*                                                                            *
*            Include a line in your application's RC file that gives a file  *
*  name with a resource id eg. IDBMP_BUTTONS.  This is a .BMP file that      *
*  contains all of the pictures of the buttons you want on your toolbar.     *
*  Also, make a define for your label with a unique value.  If your app has  *
*  more than one toolbar, and all toolbars don't share a bitmap file, then   *
*  you will need several defines.                                            *
*                                                                            *
*  e.g.		IDBMP_BUTTONS     BITMAP     "buttons.bmp"                   *
*      		IDBMP_ARROWS      BITMAP     "arrows.bmp"                    *
*                                                                            *
*            This file must have the different buttons across horizontally   *
*  and the different states for these buttons vertically.  Change the        *
*  defines in this header file to match the button names and state names of  *
*  your buttons.  You must include the states listed here, and actually      *
*  you probably won't need to change them at all.  The numbers for a button  *
*  or state are indexes into the bitmap, so the pictures must match.         *
*                                                                            *
*  STATE DESCRIPTIONS:                                                       *
*                       GRAYED:  The button cannot be pressed & is inactive  *
*                           UP:  The button is up                            *
*                         DOWN:  The button is down                          *
*                      FOCUSUP:  The button is up and is the one with focus  *
*                    FOCUSDOWN:  The button is down and is the one with focus*
*                     FULLDOWN:  A checkbox button has this additional state *
*                                where it is all the way down when pressed   *
*                                and when it is let go, it will go into      *
*                                either the UP or DOWN state (maybe focused) *
*                                                                            *
*  When you draw the pictures, make sure to get the right state in the right *
*  vertical position in the bitmap to match the #define's.                   *
*                                                                            *
*  A button can also have a type associated with it:                         *
*                                                                            *
*                 PUSH:  When pressed it goes down, when let go it bounces   *
*                        up.  Therefore, when you aren't currently holding   *
*                        the mouse button or space bar on it, it will        *
*                        ALWAYS be in the up position. It can be in any      *
*                        state except FULLDOWN, which is invalid.            *
*                                                                            *
*             CHECKBOX:  This button can be up or down.  When pushed, it     *
*                        toggles into the opposite state.  However, it       *
*                        is always in the FULLDOWN state when being held     *
*                        down with the mouse button or space bar, and when   *
*                        let go, it will go into the opposite state of what  *
*                        it was in before you pressed it.  E.G.  The button  *
*                        is up.  You press it, and it goes way down. You let *
*                        go, and it comes up a bit, but it's still down.  You*
*                        press it again, and it goes further down before     *
*                        popping all the way up.                             *
*                                                                            *
*                RADIO:  This is a group of buttons that can be up or down,  *
*                        and also have the intermediate step of being        *
*                        FULLDOWN when being held down.  But, when you       *
*                        push one of the radio buttons down, all other radio *
*                        buttons in its group will pop up.  Any group can    *
*                        have only 1 down at a time, and 1 must be down.     *
*                                                                            *
*                CUSTOM: If your application is wierd, you can have a custom *
*                        type button that does anything you want it to.      *
*                                                                            *
*  First, your app must call:    toolbarInit(hInst, hPrev);                  *
*  with the two instance parameters to register a toolbar window class.      *
*  Then your app is free to call CreateWindow with a class of                *
*  szToolBarClass   to create one or more toolbar windows anywhere it wants  *
*  and of any size it wants, presumably as the child window of another of the*
*  app's windows.  The file that creates the window must declare an          *
*  extern char szToolBarClass[];   All messages about activity to a toolbar  *
*  button will go to the parent window of the toolbar.                       *
*                                                                            *
*  Next, call:     toolbarSetBitmap(HWND hwnd, HANDLE hInst, int ibmp,       *
*							 POINT ptSize);      *
*  Pass it the resource ID (eg. IDBMP_BUTTONS) to tell the toolbar where to  *
*  find the pictures for the buttons.  Also pass a point with the width and  *
*  height of each button (eg. 24 X 22) so it knows how to find individual    *
*  buttons in the bitmap file.                                               *
*                                                                            *
*  Next, call:     toolbarAddTool(HWND hwnd, TOOLBUTTON tb);                 *
*  as many times as you want to add a button to the toolbar specified by     *
*  hwnd.  You fill in the "tb" struct with the following information:        *
*                                                                            *
*       tb.rc        = the rect in the toolbar window to place the button    *
*                      based at 0,0 and measured in pixels.                  *
*       tb.iButton   = the ID of the button you wish the add (which is       *
*                      the horizontal offset into the bitmap of buttons).    *
*                      Only one of each button allowed.  Use one of the      *
*                      defines (BTN_??????).                                 *
*       tb.iState    = the initial state of the button (GRAYED, UP, DOWN).   *
*                      If you wish, you can specify a FOCUS'ed state to give *
*                      any button you wish the focus.  By default, it's the  *
*                      one furthest left and tabbing order goes to the right.*
*                      This is the vertical offset into the bitmap.          *
*                      Use one of the defines (BTNST_?????).                 *
*       tb.iType     = The type of button (BTNTYPE_???).  Either pushbutton, *
*                      checkbox, or radio button. (or custom).  If it is a   *
*                      radio button, you can have many groups of radio btn's *
*                      on the same toolbar.  Type BTNTYPE_RADIO is one group.*
*                      Use BTNTYPE_RADIO+1 for another group, BTNTYPE_RADIO+2*
*                      for a third group, etc.  You have thousands.          *
*       tb.iString   = The resource ID of a string to be associated with     *
*                      this button (if you'd like).                          *
*                                                                            *
*                                                                            *
*   At any time in the app, you can call toolbarAddTool to add more buttons  *
*   or toolbarRemoveTool to take some away.  To take one away, identify it   *
*   with it's button ID (horizontal offset in the bitmap).                   *
*                                                                            *
*   You can also call toolbarRetrieveTool to get the TOOLBUTTON struct back  *
*   from a button that is on the toolbar.  This is the way to change a       *
*   button's position.  Change the tb.rc and then Remove and Add the button  *
*   again so that the tabbing order will be re-calculated based on the new   *
*   rect of the tool.                                                        *
*                                                                            *
*   Now, all buttons will automatically behave properly.  They'll go up and  *
*   down as you press on them, or use the keyboard, groups of radio buttons  *
*   will pop up as you press a different one down, etc. etc. etc.            *
*   You don't have to do a thing!                                            *
*                                                                            *
*   The parent of the toolbar window will get a WM_COMMAND message with      *
*   a wParam of IDC_TOOLBAR  whenever anything happens to a button.          *
*   The LOWORD of the lParam is the hwnd of the toolbar window that has the  *
*   button on it.  The (HIWORD & 0xFF) is the button ID of the button.       *
*   Remember to change IDC_TOOLBAR to something unique.                      *
*                                                                            *
*   The app can then call   toolbarIndexFromButton(hwnd, buttonID)           *
*   to get the index of the button (used for subsequent calls).              *
*                                                                            *
*   Then call:      toolbarStateFromButton(hwnd, buttonID)                   *
*                                                                            *
*                   to get either BTNST_UP or BTNST_DOWN.  This is the       *
*                   NEW state of the button since the activity on the        *
*                   button.  It can also be BTNST_GRAYED, but you won't get  *
*                   any activity messages while it's grayed, unless it is a  *
*                   cutsom button.                                           *
*                                                                            *
*             Call  toolbarFullStateFromButton(hwnd, buttonID)               *
*                                                                            *
*                   to get more detail about the state.  It can also return  *
*                   BTNST_FULLDOWN as well as the above states. In the case  *
*                   of BTNST_FULLDOWN, you'll have to call                   *
*                   toolbarPrevStateFromButton(hwnd, btn ID) to get the state*
*                   before it went full down.                                *
*                                                                            *
*                   toolbarPrevStateFromButton(hwnd, buttonID)               *
*                                                                            *
*                   is only valid when the state is BTNST_FULLDOWN.          *
*                                                                            *
*                   toolbarActivityFromIndex(hwnd, buttonID)                 *
*                                                                            *
*                   tells you what just happened to the button.              *
*                   BTNACT_KEYDOWN, BTNACT_MOUSEUP, etc. are possibilities.  *
*                   BTNACT_MOUSEMOUSEOFF means that they pressed it down and *
*                   moved the mouse off of the button (  so it was re- drawn *
*                   in its previous state before being pressed).             *
*                   BTNACT_MOUSEMOUSEON  means that the above happened and   *
*                   then the mouse moved back on top of the button again, so *
*                   the button was re-drawn as if it was pushed again.       *
*                                                                            *
*                   For any of the above activities.......                   *
*                                                                            *
*   HIWORD & BTN_SHIFT     is set if this activity involves the right mouse  *
*                          button, or else it is clear.                      *
*   HIWORD & BTN_DBLCLICK  is set means that this mouse button down activity *
*                          is really a double click (if you care).           *
*                                                                            *
*           If you are a custom button, you can also receive this message... *
*                                                                            *
*   HIWORD & BTN_REPEAT    is set means that the button or key is being held *
*                          down, and you are being sent many down messages   *
*                          in a row.  The first such message is sent with    *
*                          this flag clear, all others have this flag set.   *
*                          If you are a custom button, you will have to      *
*                          ignore messages that are repeats if you don't     *
*                          want to get many down messages in a row.          *
*                                                                            *
*                                                                            *
*                    toolbarStringFromIndex(hwnd, index)                     *
*                                                                            *
*                    will return you the string resource ID you gave when    *
*                    you registered this button.                             *
*                                                                            *
*                                                                            *
*  IMPORTANT !!!!!!!!!!!!!!!!!!!                                             *
*  =============================                                             *
*                                                                            *
*  When you get the state of a button, it's already been changed by the      *
*  activity so it's the NEW STATE!!!!!!!!!                                   *
*                                                                            *
*   EXCEPT!!!   for a custom button!  For a custom button, NOTHING WILL      *
*   happen, you have to do it all yourself!!!! So the state is going to be   *
*   the state BEFORE the activity and you have to call                       *
*   toolbarModifyState(hwnd, buttonID, newState) to change the state         *
*   yourself!!!!                                                             *
*                                                                            *
*   You also have toolbarGetNumButtons(hwnd) to tell you how many are on the *
*   the toolbar.                                                             *
*   And... you have other routines you can use if you really want.           *
*                                                                            *
*   ENJOY!!                                                                  *
*                                                                            *
*  P.S.  Don't forget to pass on WM_SYSCOLORCHANGE msgs to each toolbar.     *
*                                                                            *
*****************************************************************************/

#define TOOLGROW	8		// power of 2

#define IDC_TOOLBAR	189		// wParam sent to Parent

/* We keep an array of these around (one for each button on the toolbar) */

typedef struct {
	RECT	rc;		// draw it at this postion in the toolbar
	int	iButton;	// it's this button
	int	iState;		// in this state
	int	iPrevState;	// for non-push buttons - last state
	int	iType;		// type of button
	int	iActivity;	// what just happened to button
	int	iString;	// string resource associated with button
} TOOLBUTTON, FAR *LPTOOLBUTTON;

BOOL FAR PASCAL toolbarInit(HANDLE hInst, HANDLE hPrev);
BOOL FAR PASCAL toolbarSetBitmap(HWND hwnd, HANDLE hInst, int ibmp,
								POINT ptSize);
BOOL FAR PASCAL toolbarAddTool(HWND hwnd, TOOLBUTTON tb);
BOOL FAR PASCAL toolbarRetrieveTool(HWND hwnd, int iButton, LPTOOLBUTTON tb);
BOOL FAR PASCAL toolbarRemoveTool(HWND hwnd, int iButton);
int FAR PASCAL toolbarGetNumButtons(HWND hwnd);
int FAR PASCAL toolbarButtonFromIndex(HWND hwnd, int iBtnPos);
int FAR PASCAL toolbarIndexFromButton(HWND hwnd, int iButton);
int FAR PASCAL toolbarPrevStateFromButton(HWND hwnd, int iButton);
int FAR PASCAL toolbarActivityFromButton(HWND hwnd, int iButton);
int FAR PASCAL toolbarIndexFromPoint(HWND hwnd, POINT pt);
BOOL FAR PASCAL toolbarRectFromIndex(HWND hwnd, int iBtnPos, LPRECT lprc);
int FAR PASCAL toolbarStringFromIndex(HWND hwnd, int iBtnPos);
int FAR PASCAL toolbarStateFromButton(HWND hwnd, int iButton);
int FAR PASCAL toolbarFullStateFromButton(HWND hwnd, int iButton);
int FAR PASCAL toolbarTypeFromIndex(HWND hwnd, int iBtnPos);
BOOL FAR PASCAL toolbarModifyState(HWND hwnd, int iButton, int iState);
BOOL FAR PASCAL toolbarModifyString(HWND hwnd, int iButton, int iString);
BOOL FAR PASCAL toolbarModifyPrevState(HWND hwnd, int iButton, int iPrevState);
BOOL FAR PASCAL toolbarModifyActivity(HWND hwnd, int iButton, int iActivity);
BOOL FAR PASCAL toolbarExclusiveRadio(HWND hwnd, int iType, int iButton);
BOOL FAR PASCAL toolbarMoveFocus(HWND hwnd, BOOL fBackward);
BOOL FAR PASCAL toolbarSetFocus(HWND hwnd, int iButton);
HBITMAP FAR PASCAL  LoadUIBitmap(
    HANDLE      hInstance,          // EXE file to load resource from
    LPCSTR      szName,             // name of bitmap resource
    COLORREF    rgbText,            // color to use for "Button Text"
    COLORREF    rgbFace,            // color to use for "Button Face"
    COLORREF    rgbShadow,          // color to use for "Button Shadow"
    COLORREF    rgbHighlight,       // color to use for "Button Hilight"
    COLORREF    rgbWindow,          // color to use for "Window Color"
    COLORREF    rgbFrame);          // color to use for "Window Frame"


/* In a bitmap file, each button is the same size, and contains
 * the picture of a button.  Each column contains the picture of a distinct
 * button (e.g. BTN_REWIND, BTN_REVERSE, etc.) and each row contains
 * a specific button state (BTNST_UP, BTNST_DOWN,
 * BTNBAR_GRAYED, etc. just as an example).
 *
 */

#define TB_FIRST	-1
#define TB_LAST		-2



#define BTNST_GRAYED		0	//
#define BTNST_UP		1	//
#define BTNST_DOWN		2	//
#define BTNST_FOCUSUP		3	//
#define BTNST_FOCUSDOWN		4	//
#define BTNST_FULLDOWN		5	//

#define BTN_REPEAT		0x100	// add this to button index
#define BTN_SHIFT		0x200
#define BTN_DBLCLICK		0x400


/* Types of buttons */

#define BTNTYPE_PUSH		0
#define BTNTYPE_CHECKBOX	1
#define BTNTYPE_CUSTOM		2
#define BTNTYPE_RADIO		3	// MUST BE LAST to reserve room for more
					// radio groups.  (3 == one group,
					// 4 == another group, etc.)


/* tells parent recent activity on button */
#define BTNACT_MOUSEDOWN	0	// clicked mouse button down on tool
#define BTNACT_MOUSEUP		1	// let go of mouse button while on tool
#define BTNACT_MOUSEMOVEOFF	2	// moved mouse off tool while btn down
#define BTNACT_MOUSEMOVEON	3	// moved back on tool (btn still down)
#define BTNACT_MOUSEDBLCLK	4	// dbl clicked on tool
#define BTNACT_KEYDOWN		5	// key down on tool
#define BTNACT_KEYUP		6	// key up from tool


/* constants */
#define MSEC_BUTTONREPEAT	200	// milliseconds for auto-repeat

/* timers */
#define TIMER_BUTTONREPEAT	1	// timer for button auto-repeat





// Window words for Toolbar
#ifdef _WIN32
#define GWLP_ARRAYBUTT	0		/* Pointer to array of buttons  */
#define GWL_NUMBUTTONS	(GWLP_ARRAYBUTT + sizeof(HANDLE))	/* Number of buttons in array   */
#define GWL_PRESSED	(GWL_NUMBUTTONS + sizeof(int))		/* Is a button currently pressed*/
#define GWL_KEYPRESSED	(GWL_PRESSED + sizeof(BOOL))      	/* Is a key currently pressed?  */
#define GWL_WHICH	(GWL_KEYPRESSED + sizeof(BOOL))	        /* Which button has the focus?  */
#define GWL_SHIFTED	(GWL_WHICH + sizeof(int))		/* Is it rt-click or shift-left?*/
#define GWLP_BMPHANDLE	(GWL_SHIFTED + sizeof(BOOL))		/* handle to bmp of the buttons */
#define GWL_BMPINT	(GWLP_BMPHANDLE + sizeof(HANDLE))	/* resource int of button bmp	*/
#define GWL_BUTTONSIZE	(GWL_BMPINT + sizeof(int))		/* a point (x=hi y=lo)		*/
#define GWLP_HINST	(GWL_BUTTONSIZE + sizeof(long))	/* hinst of the app   		*/
#define TOOLBAR_EXTRABYTES	(GWLP_HINST + sizeof(HANDLE))
#else
#define GWW_ARRAYBUTT	0		/* Pointer to array of buttons  */
#define GWW_NUMBUTTONS	2		/* Number of buttons in array   */
#define GWW_PRESSED	4		/* Is a button currently pressed*/
#define GWW_KEYPRESSED	6		/* Is a key currently pressed?  */
#define GWW_WHICH	8		/* Which button has the focus?  */
#define GWW_SHIFTED	10		/* Is it rt-click or shift-left?*/
#define GWW_BMPHANDLE	12		/* handle to bmp of the buttons */
#define GWW_BMPINT	14		/* resource int of button bmp	*/
#define GWL_BUTTONSIZE	16		/* a point (x=hi y=lo)		*/
#define GWW_HINST	20		/* hinst of the app   		*/
#define TOOLBAR_EXTRABYTES	22
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\vidcap32\status.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/
/****************************************************************************
 *
 *   status.c: Status bar window
 *
 *   Vidcap32 Source code
 *
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>
//#include <win32.h>
#include <mmsystem.h>
#include "status.h"

/* for compiling under win3.0 - we don't have this attribute */
#ifndef COLOR_BTNHIGHLIGHT
#define COLOR_BTNHIGHLIGHT 20
#endif

#ifdef _WIN32
typedef WNDPROC LPWNDPROC;
#else
typedef long (FAR PASCAL *LPWNDPROC)();
#endif



// class names for status bar and static text windows
TCHAR	szStatusClass[] = "StatusClass";
TCHAR	szText[]   = "SText";
int gStatusStdHeight;   // based on font metrics

static HBRUSH ghbrBackground;
static HANDLE ghFont;
static HBRUSH ghbrHL, ghbrShadow;


/* Function Prototypes */
LRESULT FAR PASCAL statusWndProc(HWND hwnd, unsigned msg,
						WPARAM wParam, LPARAM lParam);
LRESULT FAR PASCAL fnText(HWND, unsigned, WPARAM, LPARAM);
static VOID NEAR PASCAL PaintText(HWND hwnd, HDC hdc);




/*
 * create the brushes we need
 */
void
statusCreateTools(void)
{
    HDC hdc;
    TEXTMETRIC tm;
    HFONT hfont;

    ghbrBackground = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
    ghbrHL = CreateSolidBrush(GetSysColor(COLOR_BTNHIGHLIGHT));
    ghbrShadow = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW));

    /* Create the font we'll use for the status bar - use system as default */
    ghFont = CreateFont(12, 0,		// height, width
                0, 0,			// escapement, orientation
                FW_NORMAL,		// weight,
                FALSE, FALSE, FALSE,	// attributes
                ANSI_CHARSET,		// charset
                OUT_DEFAULT_PRECIS,	// output precision
                CLIP_DEFAULT_PRECIS,	// clip precision
                DEFAULT_QUALITY,	// quality
                VARIABLE_PITCH | FF_MODERN,
                "Helv");

    if (ghFont == NULL) {
        ghFont = GetStockObject(SYSTEM_FONT);
    }

    // find the char size to calc standard status bar height
    hdc = GetDC(NULL);
    hfont = SelectObject(hdc, ghFont);
    GetTextMetrics(hdc, &tm);
    SelectObject(hdc, hfont);
    ReleaseDC(NULL, hdc);

    gStatusStdHeight = tm.tmHeight * 3 / 2;

}

void
statusDeleteTools(void)
{
    DeleteObject(ghbrBackground);
    DeleteObject(ghbrHL);
    DeleteObject(ghbrShadow);

    DeleteObject(ghFont);
}




/*--------------------------------------------------------------+
| statusInit - initialize for status window, register the	|
|	       Window's class.					|
|								|
+--------------------------------------------------------------*/
#pragma alloc_text(INIT_TEXT, statusInit)
BOOL statusInit(HANDLE hInst, HANDLE hPrev)
{
  WNDCLASS  cls;

  statusCreateTools();

  if (!hPrev){
	  cls.hCursor		= LoadCursor(NULL, IDC_ARROW);
	  cls.hIcon		= NULL;
	  cls.lpszMenuName	= NULL;
	  cls.lpszClassName	= szStatusClass;
	  cls.hbrBackground	= ghbrBackground;
	  cls.hInstance		= hInst;
	  cls.style		= CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
	  cls.lpfnWndProc	= statusWndProc;
	  cls.cbClsExtra	= 0;
	  cls.cbWndExtra	= 0;
	
	  if (!RegisterClass(&cls))
		  return FALSE;

	  cls.hCursor        = LoadCursor(NULL,IDC_ARROW);
	  cls.hIcon          = NULL;
	  cls.lpszMenuName   = NULL;
	  cls.lpszClassName  = (LPSTR)szText;
	  cls.hbrBackground  = ghbrBackground;
	  cls.hInstance      = hInst;
	  cls.style          = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
	  cls.lpfnWndProc    = (LPWNDPROC)fnText;
	  cls.cbClsExtra     = 0;
	  cls.cbWndExtra     = 0;
	  if (!RegisterClass(&cls))
		return FALSE;
  }


  return TRUE;
}

/*
 * returns the recommended height for a status bar based on the
 * character dimensions of the font used
 */
int
statusGetHeight(void)
{
    return(gStatusStdHeight);
}


/*--------------------------------------------------------------+
| statusUpdateStatus - update the status line			|
|								|
| The argument can either be NULL, a string, or a resource ID	|
| cast to a LPCSTR with MAKEINTRESOURCE.			|
+--------------------------------------------------------------*/
void statusUpdateStatus(HWND hwnd, LPCTSTR lpsz)
{
    TCHAR	ach[80];
    HWND hwndtext;

    if ((lpsz != NULL) && (HIWORD((DWORD) (DWORD_PTR) lpsz) == 0)) {
	LoadString(GetWindowInstance(hwnd), LOWORD((DWORD) (DWORD_PTR) lpsz), ach, sizeof(ach));
	lpsz = ach;
    }

    hwndtext = GetDlgItem(hwnd, 1);
    if (!lpsz || *lpsz == '\0') {
	SetWindowText(hwndtext,"");
    } else {
	SetWindowText(hwndtext, lpsz);
    }
}

/*--------------------------------------------------------------+
| statusWndProc - window proc for status window			|
|								|
+--------------------------------------------------------------*/
LRESULT FAR PASCAL 
statusWndProc(HWND hwnd, unsigned msg, WPARAM wParam, LPARAM lParam)
{
  PAINTSTRUCT	ps;
  HDC		hdc;
  HWND          hwndSText;

  switch(msg){
    case WM_CREATE:
	
	    /* we need to create the static text control for the status bar */
	    hwndSText = CreateWindow(
                            szText,
                            "",
                            WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,
		            0, 0, 0, 0,
                            hwnd,
                            (HMENU) 1,  // child id
                            GetWindowInstance(hwnd),
                            NULL);

	    if (!hwndSText) {
		    return -1;
            }
	    break;
	
    case WM_DESTROY:
            statusDeleteTools();
	    break;
	
    case WM_SIZE:
        {
            RECT rc;

            GetClientRect(hwnd, &rc);

            MoveWindow(
                GetDlgItem(hwnd, 1),    // get child window handle
                2, 1,                   // xy just inside
                rc.right - 4,
                rc.bottom - 2,
                TRUE);

	    break;
        }

    case WM_PAINT:
	    hdc = BeginPaint(hwnd, &ps);

            // only the background and the child window need painting

	    EndPaint(hwnd, &ps);
	    break;

    case WM_SYSCOLORCHANGE:
        statusDeleteTools();
        statusCreateTools();
#ifdef _WIN32
        SetClassLongPtr(hwnd, GCLP_HBRBACKGROUND, (LONG_PTR) ghbrBackground);
#else
        SetClassWord(hwnd, GCW_HBRBACKGROUND, (WORD) ghbrBackground);
#endif
        break;

    case WM_ERASEBKGND:
        break;

  }
  return DefWindowProc(hwnd, msg, wParam, lParam);
}

/*
 * window proc for static text window
 */
LRESULT FAR PASCAL 
fnText(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
	PAINTSTRUCT ps;

	switch (msg) {
	case WM_SETTEXT:
		DefWindowProc(hwnd, msg, wParam, lParam);
		InvalidateRect(hwnd,NULL,FALSE);
		UpdateWindow(hwnd);
		return 0L;

	case WM_ERASEBKGND:
		return 0L;

	case WM_PAINT:
		BeginPaint(hwnd, &ps);
		PaintText(hwnd, ps.hdc);
		EndPaint(hwnd, &ps);
		return 0L;
        }

	return DefWindowProc(hwnd, msg, wParam, lParam);
}

/*--------------------------------------------------------------+
| PaintText - paint the shadowed static text field.		|
|								|
+--------------------------------------------------------------*/
VOID NEAR PASCAL
PaintText(HWND hwnd, HDC hdc)
{
  RECT rc;
  TCHAR  ach[128];
  int  len;
  int	dx, dy;
  RECT	rcFill;
  HFONT	hfontOld;
  HBRUSH hbrSave;

  GetClientRect(hwnd, &rc);

  len = GetWindowText(hwnd,ach,sizeof(ach));

  SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));
  SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));

  hfontOld = SelectObject(hdc, ghFont);

  rcFill.left = rc.left + 1;
  rcFill.right = rc.right - 1;
  rcFill.top = rc.top + 1;
  rcFill.bottom = rc.bottom - 1;

  /* move in some and do background and text in one swoosh */
  ExtTextOut(hdc,4,1,ETO_OPAQUE,&rcFill,ach,len,NULL);

  dx = rc.right - rc.left;
  dy = rc.bottom - rc.top;

  hbrSave = SelectObject(hdc, ghbrShadow);
  PatBlt(hdc, rc.left, rc.top, 1, dy, PATCOPY);
  PatBlt(hdc, rc.left, rc.top, dx, 1, PATCOPY);

  SelectObject(hdc, ghbrHL);
  PatBlt(hdc, rc.right-1, rc.top+1, 1, dy-1, PATCOPY);
  PatBlt(hdc, rc.left+1, rc.bottom -1, dx-1, 1,  PATCOPY);

  if (hfontOld)
	  SelectObject(hdc, hfontOld);
  if (hbrSave)
	  SelectObject(hdc, hbrSave);
  return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\vidcap32\status.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/
/****************************************************************************
 *
 *   status.h: Status bar include file
 *
 *   Vidcap32 Source code
 *
 ***************************************************************************/


/* Globals */
// class name of window to create
extern TCHAR	szStatusClass[];


/* Function Prototypes */

BOOL  statusInit(HANDLE hInst, HANDLE hPrev);
void  statusUpdateStatus(HWND hwnd, LPCSTR lpsz);	// update status line

/*
 * returns the recommended height for a status bar based on the
 * character dimensions of the font used
 */
int statusGetHeight(void);



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\vidcap32\vidcap.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/
/****************************************************************************
 *
 *   vidcap.c: WinMain and command processing
 *
 *   Vidcap32 Source code
 *
 ***************************************************************************/
 
#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <io.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <dos.h>
#include <shellapi.h>
#include <vfw.h>
#include <tchar.h>

#include "vidcap.h"
#include "vidframe.h"
#include "profile.h"

// generic window control classes
#include "toolbar.h"
#include "status.h"
#include "arrow.h"
#include "rlmeter.h"
#include "help.h"

// the standard toolbar class 'exports' this but doesn't put it in the
// header file
extern TCHAR     szToolBarClass[];//HACK!


// height of the buttons on a toolbar - depends on the
// size of the bitmaps within IDBMP_TOOLBAR
#define BUTTONWIDTH     24
#define BUTTONHEIGHT    22
#define TOOLBAR_HEIGHT          BUTTONHEIGHT + 6


// description and layout of toolbar buttons within IDBMP_TOOLBAR
#define APP_NUMTOOLS 8

#define BTN_SETFILE		0
#define BTN_EDITCAP		1
#define BTN_LIVE		2
#define BTN_CAPFRAME		3
#define BTN_CAPSEL		4
#define BTN_CAPAVI		5
#define BTN_CAPPAL		6
#define BTN_OVERLAY		7

static int           aiButton[] = {BTN_SETFILE, BTN_EDITCAP,
                            BTN_LIVE, BTN_OVERLAY, BTN_CAPFRAME,
                            BTN_CAPSEL, BTN_CAPAVI, BTN_CAPPAL };
static int           aiState[] = {BTNST_FOCUSUP, BTNST_UP,
                            BTNST_UP, BTNST_UP, BTNST_UP,
                            BTNST_UP, BTNST_UP, BTNST_UP};
static int           aiType[] ={BTNTYPE_PUSH, BTNTYPE_PUSH,
                            BTNTYPE_CHECKBOX, BTNTYPE_CHECKBOX,
                            BTNTYPE_PUSH,
                            BTNTYPE_PUSH, BTNTYPE_PUSH, BTNTYPE_PUSH};
static int           aiString[] = { IDC_toolbarSETFILE,
                            IDC_toolbarEDITCAP, IDC_toolbarLIVE,
                            IDC_toolbarOVERLAY,
                            IDC_toolbarCAPFRAME, IDC_toolbarCAPSEL,
                            IDC_toolbarCAPAVI, IDC_toolbarCAPPAL };
static int           aPos[] = { 10, 35, 75, 100, 150, 175, 200, 225 };




//
// Global Variables
//

// preferences
BOOL gbCentre;
BOOL gbToolBar;
BOOL gbStatusBar;
BOOL gbAutoSizeFrame;
int gBackColour;

BOOL gbLive, gbOverlay;
BOOL gfIsRTL;

// saved window sizes
int gWinX, gWinY;
int gWinCX, gWinCY;
int gWinShow;

// command line options
int gCmdLineDeviceID = -1;


TCHAR          gachAppName[]  = "vidcapApp" ;
TCHAR          gachIconName[] = "vidcapIcon" ;
TCHAR          gachMenuName[] = "vidcapMenu" ;
TCHAR          gachAppTitle[20];    //VidCap
TCHAR          gachCaptureFile[_MAX_PATH];
TCHAR          gachMCIDeviceName[21];
TCHAR          gachString[128] ;
TCHAR          gachBuffer[200] ;
TCHAR          gachLastError[256];


HINSTANCE      ghInstApp ;
HWND           ghWndMain = NULL ;
HWND           ghWndFrame;      // child of ghWndMain  - frames and scrolls
HWND           ghWndCap  ;      // child of ghWndCap
HWND           ghWndToolBar;
HWND           ghWndStatus;

HANDLE         ghAccel ;
WORD           gwDeviceIndex ;
WORD           gwPalFrames = DEF_PALNUMFRAMES ;
WORD           gwPalColors = DEF_PALNUMCOLORS ;
WORD           gwCapFileSize ;

CAPSTATUS      gCapStatus ;
CAPDRIVERCAPS  gCapDriverCaps ;
CAPTUREPARMS   gCapParms ;
BOOL           gbHaveHardware;
UINT           gDriverCount;
BOOL           gbIsScrncap;  // For Scrncap.drv, we must yield
BOOL           gbInLayout;
UINT           gAVStreamMaster;

HANDLE         ghwfex ;
LPWAVEFORMATEX glpwfex ;

FARPROC        fpErrorCallback ;
FARPROC        fpStatusCallback ;
FARPROC        fpYieldCallback ;


// set to false when we capture a palette (or if we have warned him and
// he says its ok
BOOL bDefaultPalette = TRUE;

#ifdef DEBUG
int	nTestCount;
#endif

// c-runtime cmd line
extern char ** __argv;
extern int __argc;

#define LimitRange(Val,Low,Hi) (max(Low,(min(Val,Hi))))


//
// Function prototypes
//
LRESULT FAR PASCAL MainWndProc(HWND, UINT, WPARAM, LPARAM) ;
LRESULT FAR PASCAL ErrorCallbackProc(HWND, int, LPSTR) ;
LRESULT FAR PASCAL StatusCallbackProc(HWND, int, LPSTR) ;
LRESULT FAR PASCAL YieldCallbackProc(HWND) ;
void vidcapSetLive(BOOL bLive);
void vidcapSetOverlay(BOOL bOverlay);
void vidcapSetCaptureFile(LPTSTR pFileName);

BOOL vidcapRegisterClasses(HINSTANCE hInstance, HINSTANCE hPrevInstance);
BOOL vidcapCreateWindows(HINSTANCE hInstance, HINSTANCE hPrevInstance);
void vidcapLayout(HWND hwnd);
BOOL vidcapEnumerateDrivers(HWND hwnd);
BOOL vidcapInitHardware(HWND hwnd, HWND hwndCap, UINT uIndex);
void vidcapReadProfile(void);
void vidcapWriteProfile(void);
void vidcapReadSettingsProfile(void);
void vidcapWriteSettingsProfile(void);


/* --- initialisation -------------------------------------------------- */


//
// WinMain: Application Entry Point Function
//
int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
///////////////////////////////////////////////////////////////////////
//  hInstance:      handle for this instance
//  hPrevInstance:  handle for possible previous instances
//  lpszCmdLine:    long pointer to exec command line
//  nCmdShow:       Show code for main window display
///////////////////////////////////////////////////////////////////////

    MSG          msg ;
    BOOL bValidCmdline;
    BOOL fOK;
    int i;
    char ach[2];

    ghInstApp = hInstance ;
    LoadString(hInstance, IDS_CAP_RTL, ach, sizeof(ach));
    gfIsRTL = ach[0] == '1';
    gCmdLineDeviceID = -1;

    // read the app title string - used in several message boxes
    LoadString(hInstance, IDS_APP_TITLE, gachAppTitle, sizeof(gachAppTitle));

    // read defaults out of the registry
    vidcapReadProfile();

    // look for cmd line options
    bValidCmdline = TRUE;

    for ( i = 1; (i < __argc) && bValidCmdline; i++) {
        if ((__argv[i][0] == '/') || (__argv[i][0] == '-')) {

            switch(__argv[i][1]) {
            case 'D':
            case 'd':
                if (gCmdLineDeviceID < 0) {
                    // allow "-d0" and "-d 0"
                    PSTR p = &__argv[i][2];

                    if ((*p == 0) && ((i+1) < __argc)) {
                        p = __argv[++i];
                    }


                    gCmdLineDeviceID = atoi(p);
                } else {
                    bValidCmdline = FALSE;
                }
                break;

            default:
                bValidCmdline = FALSE;
            }
        } else {
            bValidCmdline = FALSE;
        }
    }
    
    if (gCmdLineDeviceID == -1)
	gCmdLineDeviceID = 0;


    if (!bValidCmdline) {
        MessageBoxID(IDS_ERR_CMDLINE, MB_OK|MB_ICONEXCLAMATION);
        return(0);
    }

    if (!vidcapRegisterClasses(hInstance, hPrevInstance)) {

        MessageBoxID(IDS_ERR_REGISTER_CLASS,
#ifdef BIDI
            MB_RTL_READING |
#endif

        MB_ICONEXCLAMATION) ;
        return 0 ;
    }


    if (!vidcapCreateWindows(hInstance, hPrevInstance)) {

        MessageBoxID(IDS_ERR_CREATE_WINDOW,
#ifdef BIDI
                MB_RTL_READING |
#endif

        MB_ICONEXCLAMATION | MB_OK) ;
        return IDS_ERR_CREATE_WINDOW ;
    }

    // Get the default setup for video capture from the AVICap window
    capCaptureGetSetup(ghWndCap, &gCapParms, sizeof(CAPTUREPARMS)) ;

    // Overwrite the defaults with settings we have saved in the profile
    vidcapReadSettingsProfile();

    // Show the main window before connecting the hardware as this can be
    // time consuming and the user should see something happening first...
    ShowWindow(ghWndMain, nCmdShow) ;
    UpdateWindow(ghWndMain) ;
    ghAccel = LoadAccelerators(hInstance, "VIDCAP") ;

    // Create a list of all capture drivers and append them to the Options menu
    if (!(fOK = vidcapEnumerateDrivers(ghWndMain))) {
	LoadString(ghInstApp, IDS_ERR_FIND_HARDWARE, gachLastError, sizeof(gachLastError)/sizeof(*gachLastError));
    }
    // Try to connect to a capture driver
    else if (fOK = vidcapInitHardware(ghWndMain, ghWndCap, 
			       bValidCmdline ? gCmdLineDeviceID : 0)) {
	// Hooray, we now have a capture driver connected!
        vidcapSetCaptureFile(gachCaptureFile);
    }
    
    if (!fOK) {
        if (!DoDialog(ghWndMain, IDD_NoCapHardware, NoHardwareDlgProc,
                        (LONG_PTR) (LPSTR) gachLastError)) {
            // The user has asked to abort, since no driver was available
            PostMessage(ghWndMain, WM_COMMAND,
                        GET_WM_COMMAND_MPS(IDM_F_EXIT, 0, 0));
        }
    }
    
    // All set; get and process messages
    while (GetMessage(&msg, NULL, 0, 0)) {
        if (! TranslateAccelerator(ghWndMain, ghAccel, &msg)) {
            TranslateMessage(&msg) ;
            DispatchMessage(&msg) ;
        }
    }

    return (int) msg.wParam;
}  // End of WinMain


BOOL
vidcapRegisterClasses(HINSTANCE hInstance, HINSTANCE hPrevInstance)
{
    WNDCLASS wc;

    if (! hPrevInstance) {
        // If it's the first instance, register the window class
        wc.lpszClassName = gachAppName ;
        wc.hInstance     = hInstance ;
        wc.lpfnWndProc   = MainWndProc ;
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
        wc.hIcon         = LoadIcon(hInstance, gachIconName) ;
        wc.lpszMenuName  = gachMenuName ;
        wc.hbrBackground = GetStockObject(WHITE_BRUSH) ;
        wc.style         = CS_HREDRAW | CS_VREDRAW ;
        wc.cbClsExtra    = 0 ;
        wc.cbWndExtra    = 0 ;

        if (!RegisterClass(&wc)) {
            return(FALSE);
        }

        if (!ArrowInit(hInstance)) {
            return(FALSE);
        }

        if (!RLMeter_Register(hInstance)) {
            return(FALSE);
        }
    }

    if (!toolbarInit(hInstance, hPrevInstance)) {
        return(FALSE);
    }

    if (!statusInit(hInstance, hPrevInstance)) {
        return(FALSE);
    }
    return(TRUE);

}

BOOL
vidcapCreateWindows(HINSTANCE hInstance, HINSTANCE hPrevInstance)
{

    POINT pt;
    RECT rc;
    TOOLBUTTON tb;
    int i;

    // Create Application's Main window
    ghWndMain = CreateWindowEx(
            gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0,
            gachAppName,
            gachAppTitle,
            WS_CAPTION      |
            WS_SYSMENU      |
            WS_MINIMIZEBOX  |
            WS_MAXIMIZEBOX  |
            WS_THICKFRAME   |
            WS_CLIPCHILDREN |
            WS_OVERLAPPED,
            gWinX, gWinY,
            gWinCX, gWinCY,
            NULL,
            NULL,
            hInstance,
            0) ;

    if (ghWndMain == NULL) {
        return(FALSE);
    }


    /*
     * create a vidframe child window - this will create a child
     * AVICAP window within itself.
     *
     * Don't worry about size and position - vidcapLayout will do this
     * later (once we know the video format size).
     */
    ghWndFrame = vidframeCreate(
                    ghWndMain,
                    hInstance,
                    hPrevInstance,
                    0, 0, 0, 0,
                    &ghWndCap);

    if ((ghWndFrame == NULL) || (ghWndCap == NULL)) {
        return(FALSE);
    }

    // Register the status and error callbacks before driver connects
    // so we can get feedback about the connection process
    fpErrorCallback = MakeProcInstance((FARPROC)ErrorCallbackProc, ghInstApp) ;
    capSetCallbackOnError(ghWndCap, fpErrorCallback) ;

    fpStatusCallback = MakeProcInstance((FARPROC)StatusCallbackProc, ghInstApp) ;
    capSetCallbackOnStatus(ghWndCap, fpStatusCallback) ;

    // We'll only install a yield callback later if using Scrncap.drv
    fpYieldCallback = MakeProcInstance((FARPROC)YieldCallbackProc, ghInstApp) ;
    

    /*
     * CREATE THE TOOL BAR WINDOW
     */
    /* NOTE: let vidcapLayout() position it */
    ghWndToolBar = CreateWindowEx(
            gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0,
            szToolBarClass,
            NULL,
            WS_CHILD|WS_BORDER|WS_VISIBLE|WS_TABSTOP|
            WS_CLIPSIBLINGS,
            0, 0,
            0, 0,
            ghWndMain,
            NULL,
            hInstance,
            NULL);


    if (ghWndToolBar == NULL) {
        return(FALSE);
    }

    /* set the bitmap and button size to be used for this toolbar */
    pt.x = BUTTONWIDTH;
    pt.y = BUTTONHEIGHT;
    toolbarSetBitmap(ghWndToolBar, hInstance, IDBMP_TOOLBAR, pt);

    for (i = 0; i < APP_NUMTOOLS; i++) {
	rc.left = aPos[i];
	rc.top = 2;
	rc.right = rc.left + pt.x;
	rc.bottom = rc.top + pt.y;
	tb.rc = rc;
	tb.iButton = aiButton[i];
	tb.iState = aiState[i];
	tb.iType = aiType[i];
	tb.iString = aiString[i];
	toolbarAddTool(ghWndToolBar, tb);
    }

    // create the status bar - let vidcapLayout do the positioning
    ghWndStatus = CreateWindowEx(
                    gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0,
                    szStatusClass,
                    NULL,
                    WS_CHILD|WS_BORDER|WS_VISIBLE|WS_CLIPSIBLINGS,
                    0, 0,
                    0, 0,
                    ghWndMain,
                    NULL,
                    hInstance,
                    NULL);
    if (ghWndStatus == NULL) {
        return(FALSE);
    }

    return(TRUE);

}

/*
 * Enumerate the potential capture drivers and add the list to the Options
 * menu.  This function is only called once at startup.
 * Returns FALSE if no drivers are available.
 */
BOOL
vidcapEnumerateDrivers(HWND hwnd)
{
    TCHAR   achDeviceVersion[80] ;
    TCHAR   achDeviceAndVersion[160] ;
    UINT    uIndex ;
    HMENU   hMenuSub;

    gDriverCount = 0 ;

    hMenuSub = GetSubMenu (GetMenu (hwnd), 2);  // Options menu

    for (uIndex = 0 ; uIndex < MAXVIDDRIVERS ; uIndex++) {
        if (capGetDriverDescription(uIndex,
                       (LPSTR)achDeviceAndVersion, sizeof(achDeviceAndVersion),
                       (LPSTR)achDeviceVersion, sizeof(achDeviceVersion))) {
            // Concatenate the device name and version strings
            lstrcat (achDeviceAndVersion, ",   ");
            lstrcat (achDeviceAndVersion, achDeviceVersion);

            AppendMenu (hMenuSub, 
                        MF_STRING,
                        IDM_O_DRIVER0 + uIndex, 
                        achDeviceAndVersion);
            gDriverCount++;
        }
        else
            break;
    }		 

    // Now refresh menu, position capture window, start driver etc
    DrawMenuBar(ghWndMain) ;

    return (gDriverCount);
}

/*
 * Connect the capture window to a capture driver.
 * uIndex specifies the index of the driver to use.
 * Returns TRUE on success, or FALSE if the driver connection failed.
 */
BOOL
vidcapInitHardware(HWND hwnd, HWND hwndCap, UINT uIndex)
{
    UINT    uError ;
    UINT    uI;
    HMENU   hMenu;
    TCHAR   szName[MAX_PATH];
    TCHAR   szVersion[MAX_PATH];

    // Since the driver may not provide a reliable error string
    // provide a default
    LoadString(ghInstApp, IDS_ERR_FIND_HARDWARE, gachLastError, sizeof(gachLastError)/sizeof(*gachLastError));

    // Try connecting to the capture driver
    if (uError = capDriverConnect(hwndCap, uIndex)) {
        gbHaveHardware = TRUE;
        gwDeviceIndex = (WORD) uIndex;
    }
    else {
        gbHaveHardware = FALSE;
        gbLive = FALSE;
        gbOverlay = FALSE;
    }

    // Get the capabilities of the capture driver
    capDriverGetCaps(hwndCap, &gCapDriverCaps, sizeof(CAPDRIVERCAPS)) ;

    // Get the settings for the capture window
    capGetStatus(hwndCap, &gCapStatus , sizeof(gCapStatus));

    // Modify the toolbar buttons
    toolbarModifyState(ghWndToolBar, BTN_CAPFRAME, 
        gbHaveHardware ? BTNST_UP : BTNST_GRAYED);
    toolbarModifyState(ghWndToolBar, BTN_CAPSEL, 
        gbHaveHardware ? BTNST_UP : BTNST_GRAYED);
    toolbarModifyState(ghWndToolBar, BTN_CAPAVI, 
        gbHaveHardware ? BTNST_UP : BTNST_GRAYED);
    toolbarModifyState(ghWndToolBar, BTN_LIVE, 
        gbHaveHardware ? BTNST_UP : BTNST_GRAYED);

    // Is overlay supported?
    toolbarModifyState(ghWndToolBar, BTN_OVERLAY, 
        (gbHaveHardware && gCapDriverCaps.fHasOverlay) ? 
        BTNST_UP : BTNST_GRAYED);

    // Can the device create palettes?
    toolbarModifyState(ghWndToolBar, BTN_CAPPAL, 
        (gbHaveHardware && gCapDriverCaps.fDriverSuppliesPalettes) ? 
        BTNST_UP : BTNST_GRAYED);

    // Check the appropriate driver in the Options menu
    hMenu = GetMenu (hwnd);
    for (uI = 0; uI < gDriverCount; uI++) {
        CheckMenuItem (hMenu, IDM_O_DRIVER0 + uI, 
                MF_BYCOMMAND | ((uIndex == uI) ? MF_CHECKED : MF_UNCHECKED));
    } 

    // Unlike all other capture drivers, Scrncap.drv needs to use
    // a Yield callback, and we don't want to abort on mouse clicks,
    // so determine if the current driver is Scrncap.drv
    capGetDriverDescription (uIndex, 
                szName, sizeof (szName),
                szVersion, sizeof (szVersion));

    // Set a flag if we're using Scrncap.drv
    gbIsScrncap = (_tcsstr (szName, "Screen Capture") != NULL);

    // Get video format and adjust capture window
    vidcapLayout(ghWndMain);
    InvalidateRect(ghWndMain, NULL, TRUE);

    // set the preview rate (units are millisecs)
    capPreviewRate(hwndCap, gbHaveHardware ? 33 : 0); 

    // set live/overlay to default
    vidcapSetLive(gbLive);
    vidcapSetOverlay(gbOverlay);

    _tcscat (szName, ",   ");
    _tcscat (szName, szVersion);

    statusUpdateStatus(ghWndStatus, 
        gbHaveHardware ? szName : gachLastError);

    return gbHaveHardware;
}


/*
 * layout the main window. Put the toolbar at the top and the status
 * line at the bottom, and then give all the rest to vidframe,
 *  - it will centre or scroll the AVICAP window appropriately.
 */
void
vidcapLayout(HWND hwnd)
{
    RECT rc;
    RECT rw;
    int cy;
    int cyBorder, cxBorder;
    int cyTotal;
    int cxToolbar;
    int cyMenuAndToolbarAndCaption;

    gbInLayout = TRUE;  // So that we process WM_GETMINMAXINFO normally

    /* for both the toolbar and status bar window,
     * we want just one of the four borders. We do this
     * by setting the WS_BORDER style, and sizing and positioning
     * the window so that the 3 unwanted borders are outside the parent.
     */
    cyBorder = GetSystemMetrics(SM_CYBORDER);
    cxBorder = GetSystemMetrics(SM_CXBORDER);

    // Figure out the height of the menu, toolbar, and caption
    GetWindowRect (hwnd, &rw);
    GetClientRect (hwnd, &rc);

    ClientToScreen (hwnd, (LPPOINT) &rc);
    cyMenuAndToolbarAndCaption = (rc.top - rw.top) + TOOLBAR_HEIGHT;

    cxToolbar = aPos[APP_NUMTOOLS - 1] + BUTTONWIDTH * 3;

    if (gbAutoSizeFrame && gbHaveHardware && gCapStatus.uiImageWidth) {
        cyTotal = gCapStatus.uiImageHeight +
                cyMenuAndToolbarAndCaption +
                (gbStatusBar ? statusGetHeight() : 0) +
                cyBorder * 2 + 
                12;     // vidFrame height
        // Never make the frame smaller than the toolbar
        if (gCapStatus.uiImageWidth >= (UINT) cxToolbar) {
            SetWindowPos(
                hwnd,
                0,	// placement-order handle
                0,	// horizontal position
                0,	// vertical position
                gCapStatus.uiImageWidth + cxBorder * 24,	// width
                cyTotal,	// height
                SWP_NOZORDER | SWP_NOMOVE 	// window-positioning flags
                );
        } else {
            SetWindowPos(
                hwnd,
                0,	// placement-order handle
                0,	// horizontal position
                0,	// vertical position
                cxToolbar,	// width
                cyTotal,	// height
                SWP_NOZORDER | SWP_NOMOVE 	// window-positioning flags
                );
        }
    }

    GetClientRect(hwnd, &rc);

    if (gbToolBar) {
        // put the toolbar at the top - in fact, just off the top so as to
        // hide it's border
        MoveWindow(
            ghWndToolBar,
            -cxBorder, -cyBorder,
            RECTWIDTH(rc)+ (cxBorder * 2),
            TOOLBAR_HEIGHT,
            TRUE);
        rc.top += (TOOLBAR_HEIGHT - cyBorder);
    } else {
        MoveWindow(ghWndToolBar, 0, 0, 0, 0, TRUE);
    }

    // status bar at the bottom
    if (gbStatusBar) {
        cy = statusGetHeight() + cyBorder;
        MoveWindow(
            ghWndStatus,
            -cxBorder, rc.bottom - cy,
            RECTWIDTH(rc) + (2 * cxBorder), cy + cyBorder,
            TRUE);
        rc.bottom -= cy;
    } else {
        MoveWindow(ghWndStatus, 0, 0, 0, 0, TRUE);
    }

    // rest of window goes to vidframe window
    MoveWindow(
        ghWndFrame,
        rc.left, rc.top,
        RECTWIDTH(rc), RECTHEIGHT(rc),
        TRUE);

    // Always layout the frame window, since it is aligned on a
    // DWORD boundary for maximum codec drawing efficiency
    vidframeLayout(ghWndFrame, ghWndCap);

    gbInLayout = FALSE; 
}

/*
 * initialise settings from the profile used before window creation time
 */
void
vidcapReadProfile(void)
{
    // read defaults out of the registry
    gbCentre = mmGetProfileFlag(gachAppTitle, "CenterImage", TRUE);
    gbToolBar = mmGetProfileFlag(gachAppTitle, "ToolBar", TRUE);
    gbStatusBar = mmGetProfileFlag(gachAppTitle, "StatusBar", TRUE);
    gbAutoSizeFrame = mmGetProfileFlag(gachAppTitle, "AutoSizeFrame", TRUE);
    gBackColour = mmGetProfileInt(gachAppTitle, "BackgroundColor", IDD_PrefsLtGrey);

    gWinX = mmGetProfileInt(gachAppTitle, "WindowXPos", (UINT) CW_USEDEFAULT);
	if (gWinX != (UINT) CW_USEDEFAULT)
    	gWinX = LimitRange(gWinX, 0, GetSystemMetrics (SM_CXSCREEN) - 40);
    gWinY = mmGetProfileInt(gachAppTitle, "WindowYPos", 0);
    gWinY = LimitRange(gWinY, 0, GetSystemMetrics (SM_CYSCREEN) - 40);
    gWinCX = mmGetProfileInt(gachAppTitle, "WindowWidth", 320);
    gWinCX = LimitRange(gWinCX, 20, GetSystemMetrics (SM_CXSCREEN));
    gWinCY = mmGetProfileInt(gachAppTitle, "WindowHeight", 240);
    gWinCY = LimitRange(gWinCY, 20, GetSystemMetrics (SM_CYSCREEN));
    gWinShow = mmGetProfileInt(gachAppTitle, "WindowShow", SW_SHOWDEFAULT);
    gWinShow = LimitRange(gWinShow, SW_SHOWNORMAL, SW_SHOWDEFAULT);

    gbOverlay = mmGetProfileInt(gachAppTitle, "OverlayWindow", FALSE);
    gbLive = mmGetProfileInt(gachAppTitle, "LiveWindow", TRUE);
}


void
vidcapWriteProfile(void)
{
    mmWriteProfileFlag(gachAppTitle, "CenterImage", gbCentre, TRUE);
    mmWriteProfileFlag(gachAppTitle, "ToolBar", gbToolBar, TRUE);
    mmWriteProfileFlag(gachAppTitle, "StatusBar", gbStatusBar, TRUE);
    mmWriteProfileFlag(gachAppTitle, "AutoSizeFrame", gbAutoSizeFrame, TRUE);
    mmWriteProfileInt(gachAppTitle,  "BackgroundColor", gBackColour, IDD_PrefsLtGrey);

    mmWriteProfileInt(gachAppTitle, "WindowXPos", gWinX, (UINT) CW_USEDEFAULT);
    mmWriteProfileInt(gachAppTitle, "WindowYPos", gWinY, 0);
    mmWriteProfileInt(gachAppTitle, "WindowWidth", gWinCX, 320);
    mmWriteProfileInt(gachAppTitle, "WindowHeight", gWinCY, 240);
    mmWriteProfileInt(gachAppTitle, "WindowShow", gWinShow, SW_SHOWDEFAULT);

    mmWriteProfileInt(gachAppTitle, "OverlayWindow", gbOverlay, FALSE);
    mmWriteProfileInt(gachAppTitle, "LiveWindow", gbLive, TRUE);
}

/*
 * initialise settings from the profile used AFTER window creation time
 */
void
vidcapReadSettingsProfile(void)
{
    DWORD dwSize;
    
    mmGetProfileString(gachAppTitle, "CaptureFile", "",
        gachCaptureFile, sizeof(gachCaptureFile));

    mmGetProfileString(gachAppTitle, "MCIDevice", "VideoDisc",
                gachMCIDeviceName, sizeof(gachMCIDeviceName));

    gCapParms.dwRequestMicroSecPerFrame = 
                mmGetProfileInt(gachAppTitle, "MicroSecPerFrame", 
                DEF_CAPTURE_RATE);

    gCapParms.dwRequestMicroSecPerFrame = 
                mmGetProfileInt(gachAppTitle, "MicroSecPerFrame", 
                DEF_CAPTURE_RATE);

    gCapParms.fCaptureAudio = mmGetProfileFlag(gachAppTitle, "CaptureAudio", 
                gCapStatus.fAudioHardware);

    gCapParms.fLimitEnabled = mmGetProfileFlag(gachAppTitle, "LimitEnabled", 
                FALSE);

    gCapParms.wTimeLimit = 
                mmGetProfileInt(gachAppTitle, "TimeLimit", 30);

    gCapParms.fMCIControl= mmGetProfileFlag(gachAppTitle, "MCIControl", FALSE);

    gCapParms.fStepMCIDevice= mmGetProfileFlag(gachAppTitle, "StepMCIDevice", FALSE);

    gCapParms.dwMCIStartTime = 
                mmGetProfileInt(gachAppTitle, "MCIStartTime", 10000);

    gCapParms.dwMCIStopTime = 
                mmGetProfileInt(gachAppTitle, "MCIStopTime", 20000);

    gCapParms.fStepCaptureAt2x = mmGetProfileFlag(gachAppTitle, "StepCapture2x", 
                FALSE);

    gCapParms.wStepCaptureAverageFrames = 
                mmGetProfileInt(gachAppTitle, "StepCaptureAverageFrames", 3);

    gCapParms.AVStreamMaster = mmGetProfileInt (gachAppTitle, "AVStreamMaster",
                AVSTREAMMASTER_AUDIO);

    gCapParms.fUsingDOSMemory = mmGetProfileFlag (gachAppTitle, "CaptureToDisk",
                TRUE);

    gCapParms.dwIndexSize = 
                mmGetProfileInt(gachAppTitle, "IndexSize", 
                CAP_SMALL_INDEX);
    
    // Retrieve the saved audio format
    // Ask the ACM what the largest known wave format is
    acmMetrics(NULL,
               ACM_METRIC_MAX_SIZE_FORMAT,
               &dwSize);

    // If a wave format was saved in the registry, use that size
    dwSize = max (dwSize, mmGetProfileBinary(gachAppTitle, "WaveFormatBinary",
			   NULL,
			   NULL,
			   0));
		  
    if (glpwfex = (LPWAVEFORMATEX) GlobalAllocPtr(GHND, dwSize)) {
	capGetAudioFormat(ghWndCap, glpwfex, (WORD)dwSize) ;
	mmGetProfileBinary(gachAppTitle, "WaveFormatBinary",
			   glpwfex,
			   glpwfex,
			   dwSize);

	// Do some sanity checking
	if (MMSYSERR_NOERROR == waveInOpen (NULL, WAVE_MAPPER,
					    glpwfex, 0, 0, WAVE_FORMAT_QUERY)) {
	    capSetAudioFormat(ghWndCap, glpwfex, (WORD)dwSize) ;
	} 
	GlobalFreePtr(glpwfex) ;
    }
}


void
vidcapWriteSettingsProfile(void)
{
    mmWriteProfileString(gachAppTitle, "CaptureFile", gachCaptureFile);

    mmWriteProfileString(gachAppTitle, "MCIDevice", gachMCIDeviceName);

    mmWriteProfileInt(gachAppTitle, "MicroSecPerFrame", 
                gCapParms.dwRequestMicroSecPerFrame, DEF_CAPTURE_RATE);

    mmWriteProfileFlag(gachAppTitle, "CaptureAudio", 
                gCapParms.fCaptureAudio, gCapStatus.fAudioHardware);

    mmWriteProfileFlag(gachAppTitle, "LimitEnabled", 
                gCapParms.fLimitEnabled, FALSE);

    mmWriteProfileInt(gachAppTitle, "TimeLimit", 
                gCapParms.wTimeLimit, 30);

    mmWriteProfileFlag(gachAppTitle, "MCIControl", 
                gCapParms.fMCIControl, FALSE);

    mmWriteProfileFlag(gachAppTitle, "StepMCIDevice", 
                gCapParms.fStepMCIDevice, FALSE);

    mmWriteProfileInt(gachAppTitle, "MCIStartTime", 
                gCapParms.dwMCIStartTime, 10000);

    mmWriteProfileInt(gachAppTitle, "MCIStopTime", 
                gCapParms.dwMCIStopTime, 20000);

    mmWriteProfileFlag(gachAppTitle, "StepCapture2x", 
                gCapParms.fStepCaptureAt2x, FALSE);

    mmWriteProfileInt(gachAppTitle, "StepCaptureAverageFrames", 
                gCapParms.wStepCaptureAverageFrames, 3);

    mmWriteProfileInt(gachAppTitle, "AVStreamMaster", 
                gCapParms.AVStreamMaster, AVSTREAMMASTER_AUDIO);

    mmWriteProfileFlag(gachAppTitle, "CaptureToDisk", 
                gCapParms.fUsingDOSMemory, TRUE);

    mmWriteProfileInt(gachAppTitle, "IndexSize", 
                gCapParms.dwIndexSize, CAP_SMALL_INDEX);

    // The audio format is written whenever it is changed via dlg
}




/* --- error/status functions -------------------------------------------*/

/*
 * put up a message box loading a string from the
 * resource file
 */
int
MessageBoxID(UINT idString, UINT fuStyle)
{
    TCHAR achMessage[256];   // max message length

    LoadString(ghInstApp, idString, achMessage, sizeof(achMessage));

    return MessageBox(ghWndMain, achMessage, gachAppTitle, fuStyle);
}



//
// ErrorCallbackProc: Error Callback Function
//
LRESULT FAR PASCAL ErrorCallbackProc(HWND hWnd, int nErrID, LPSTR lpErrorText)
{
////////////////////////////////////////////////////////////////////////
//  hWnd:          Application main window handle
//  nErrID:        Error code for the encountered error
//  lpErrorText:   Error text string for the encountered error
////////////////////////////////////////////////////////////////////////

    if (!ghWndMain)
        return FALSE;

    if (nErrID == 0)            // Starting a new major function
        return TRUE;            // Clear out old errors...

    // save the error message for use in NoHardwareDlgProc
    _tcscpy(gachLastError, lpErrorText);

    // Show the error ID and text

    MessageBox(hWnd, lpErrorText, gachAppTitle,
#ifdef BIDI
                MB_RTL_READING |
#endif
                MB_OK | MB_ICONEXCLAMATION) ;

    return (LRESULT) TRUE ;
}


//
// StatusCallbackProc: Status Callback Function
//
LRESULT FAR PASCAL StatusCallbackProc(HWND hWnd, int nID, LPSTR lpStatusText)
{
////////////////////////////////////////////////////////////////////////
//  hWnd:           Application main window handle
//  nID:            Status code for the current status
//  lpStatusText:   Status text string for the current status
////////////////////////////////////////////////////////////////////////

    static int CurrentID;

    if (!ghWndMain) {
        return FALSE;
    }

    // the CAP_END message sometimes overwrites a useful
    // statistics message.
    if (nID == IDS_CAP_END) {
        if ((CurrentID == IDS_CAP_STAT_VIDEOAUDIO) ||
            (CurrentID == IDS_CAP_STAT_VIDEOONLY)) {

            return(TRUE);
        }
    }
    CurrentID = nID;


    statusUpdateStatus(ghWndStatus, lpStatusText);

    return (LRESULT) TRUE ;
}


//
// YieldCallbackProc: Status Callback Function
// (Only used for Scrncap.drv driver)
//
LRESULT FAR PASCAL YieldCallbackProc(HWND hWnd)
{
////////////////////////////////////////////////////////////////////////
//  hWnd:           Application main window handle
////////////////////////////////////////////////////////////////////////

    MSG msg;

    if (PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Return TRUE to continue capturing
    return (LRESULT) TRUE;
}



/*
 * load a string from the string table and return
 * a pointer to it for temporary use. Each call
 * overwrites the previous
 */
LPTSTR
tmpString(UINT idString)
{
    static TCHAR ach[350];

    LoadString(ghInstApp, idString, ach, sizeof(ach)/sizeof(TCHAR));

    // ensure null terminated
    ach[sizeof(ach) -1] = 0;

    return(ach);
}




/* --- connect to and init hardware ------------------------------------- */


void
vidcapSetLive(BOOL bLive)
{
    capPreview(ghWndCap, bLive);
    toolbarModifyState(ghWndToolBar, BTN_LIVE, bLive? BTNST_DOWN : BTNST_UP);
    CheckMenuItem(GetMenu(ghWndMain), IDM_O_PREVIEW,
        MF_BYCOMMAND | (bLive ? MF_CHECKED : MF_UNCHECKED));

    gbLive = bLive;

    if (bLive == TRUE) {
        vidcapSetOverlay(FALSE);
    }
}

void
vidcapSetOverlay(BOOL bOverlay)
{
    if (!gCapDriverCaps.fHasOverlay) {
        CheckMenuItem(GetMenu(ghWndMain), IDM_O_OVERLAY,
            MF_BYCOMMAND | MF_UNCHECKED);
        gbOverlay = FALSE;
        return;
    }

    capOverlay(ghWndCap, bOverlay);
    toolbarModifyState(ghWndToolBar, BTN_OVERLAY, bOverlay ? BTNST_DOWN : BTNST_UP);
    CheckMenuItem(GetMenu(ghWndMain), IDM_O_OVERLAY,
        MF_BYCOMMAND | (bOverlay ? MF_CHECKED : MF_UNCHECKED));

    gbOverlay = bOverlay;

    if (bOverlay == TRUE) {
        vidcapSetLive(FALSE);
    }
}

void
vidcapSetCaptureFile(LPTSTR pFileName)
{
    TCHAR achBuffer[_MAX_PATH];

    if ((pFileName != NULL) && (_tcslen(pFileName)  > 0)) {
        // record the capture filename
        if (_tcscmp(gachCaptureFile, pFileName)) {
            _tcscpy(gachCaptureFile, pFileName);
        }

        // and set window title
        wsprintf(achBuffer, "%s - %s", gachAppTitle, pFileName);
    } else {
        gachCaptureFile[0] = 0;
        _tcscpy(achBuffer, gachAppTitle);
    }

    capFileSetCaptureFile(ghWndCap, gachCaptureFile);
    SetWindowText(ghWndMain, achBuffer);
}

/* --- winproc and message handling --------------------------------------- */

/*
 * called from WM_COMMAND processing if the
 * message is from the toolbar. iButton contains the
 * button ID in the lower 8 bits, and the flags in the upper 8 bits/
 */
LONG FAR PASCAL
toolbarCommand (HWND hWnd, int iButton, HWND hwndToolbar)
{
    int iBtnPos, iState, iActivity, iString;


    // check repeat bit
    if (iButton & BTN_REPEAT) {
        return(0);
    }
    iButton &= 0xff;

    iBtnPos = toolbarIndexFromButton(hwndToolbar, iButton);
    iState = toolbarStateFromButton(hwndToolbar, iButton);
    iActivity = toolbarActivityFromButton(hwndToolbar, iButton);
    iString = toolbarStringFromIndex(hwndToolbar, iBtnPos);

    switch(iActivity) {

    case BTNACT_MOUSEDOWN:
    case BTNACT_KEYDOWN:
    case BTNACT_MOUSEMOVEON:
        statusUpdateStatus(ghWndStatus, MAKEINTRESOURCE(iString));
        break;

    case BTNACT_MOUSEMOVEOFF:
        statusUpdateStatus(ghWndStatus, NULL);
        break;

    case BTNACT_MOUSEUP:
    case BTNACT_KEYUP:

        statusUpdateStatus(ghWndStatus, NULL);
        switch(iButton) {
        case BTN_SETFILE:
            SendMessage(hWnd, WM_COMMAND,
                GET_WM_COMMAND_MPS(IDM_F_SETCAPTUREFILE, NULL, 0));
                break;

        case BTN_EDITCAP:
            // edit captured video
            SendMessage(hWnd, WM_COMMAND,
                GET_WM_COMMAND_MPS(IDM_F_EDITVIDEO, NULL, 0));
            break;

        case BTN_LIVE:
            SendMessage(hWnd,WM_COMMAND,
                GET_WM_COMMAND_MPS(IDM_O_PREVIEW, NULL, 0));
            break;

        case BTN_CAPFRAME:
            SendMessage(hWnd, WM_COMMAND,
                GET_WM_COMMAND_MPS(IDM_C_CAPTUREFRAME, NULL, 0));
            break;

        case BTN_CAPSEL:
            // capture selected frames
            SendMessage(hWnd, WM_COMMAND,
                GET_WM_COMMAND_MPS(IDM_C_CAPSEL, NULL, 0));
            break;

        case BTN_CAPAVI:
            SendMessage(hWnd,WM_COMMAND,
                GET_WM_COMMAND_MPS(IDM_C_CAPTUREVIDEO, NULL, 0));
            break;

        case BTN_CAPPAL:
            SendMessage(hWnd, WM_COMMAND,
                GET_WM_COMMAND_MPS(IDM_C_PALETTE, NULL, 0));
            break;

        case BTN_OVERLAY:
            SendMessage(hWnd, WM_COMMAND,
                GET_WM_COMMAND_MPS(IDM_O_OVERLAY, NULL, 0));
            break;
        }
        break;
    }
    return(0);
}


/*
 * Put up a dialog to allow the user to select a capture file.
 */
LONG FAR PASCAL
cmdSetCaptureFile(HWND hWnd)
{
    OPENFILENAME ofn ;
    LPTSTR p;
    TCHAR        achFileName[_MAX_PATH];
    TCHAR        achBuffer[_MAX_PATH] ;
    UINT         wError ;
    HANDLE hFilter;
    int oldhelpid;


    // Get current capture file name and
    // then try to get the new capture file name
    if (wError = capFileGetCaptureFile(ghWndCap, achFileName,
                                sizeof(achFileName))) {

        // Get just the path info
        // Terminate the full path at the last backslash
        _tcscpy (achBuffer, achFileName);
        for (p = achBuffer + _tcslen(achBuffer); p > achBuffer; p--) {
            if (*p == '\\') {
                *(p+1) = '\0';
                break;
            }
        }

        _fmemset(&ofn, 0, sizeof(OPENFILENAME)) ;
        ofn.lStructSize = sizeof(OPENFILENAME) ;
        ofn.hwndOwner = hWnd ;

        //load filters from resource stringtable
		if ( (hFilter = FindResource(ghInstApp, MAKEINTRESOURCE(ID_FILTER_AVI), RT_RCDATA))
		  && (hFilter = LoadResource(ghInstApp, hFilter)) )
		{
            ofn.lpstrFilter = LockResource(hFilter);
		}
		else
		{
            ofn.lpstrFilter = NULL;
		}

        ofn.nFilterIndex = 0 ;
        ofn.lpstrFile = achFileName ;
        ofn.nMaxFile = sizeof(achFileName) ;
        ofn.lpstrFileTitle = NULL;
        ofn.lpstrTitle = tmpString(IDS_TITLE_SETCAPTUREFILE);
        ofn.nMaxFileTitle = 0 ;
        ofn.lpstrInitialDir = achBuffer;
        ofn.Flags =
#ifdef BIDI
        OFN_BIDIDIALOG |
#endif
        OFN_HIDEREADONLY |
        OFN_NOREADONLYRETURN |
        OFN_PATHMUSTEXIST ;

        // set help context for dialog
        oldhelpid = SetCurrentHelpContext(IDA_SETCAPFILE);

        if (GetOpenFileName(&ofn)) {
            OFSTRUCT os;

            vidcapSetCaptureFile(achFileName);


            /*
             * if this is a new file, then invite the user to
             * allocate some space
             */
            if (OpenFile(achFileName, &os, OF_EXIST) == HFILE_ERROR) {

                /*
                 * show the allocate file space dialog to encourage
                 * the user to pre-allocate space
                 */
                if (DoDialog(hWnd, IDD_AllocCapFileSpace, AllocCapFileProc, 0)) {

		    // ensure repaint after dismissing dialog before
		    // possibly lengthy operation
		    UpdateWindow(ghWndMain);

                    // If user has hit OK then alloc requested capture file space
                    if (! capFileAlloc(ghWndCap, (long) gwCapFileSize * ONEMEG)) {
                        MessageBoxID(IDS_ERR_CANT_PREALLOC,
#ifdef BIDI
                                    MB_RTL_READING |
#endif
                                    MB_OK | MB_ICONEXCLAMATION) ;
                    }
                }
            }

        }

        // restore old help context
        SetCurrentHelpContext(oldhelpid);

        if (hFilter) {
            UnlockResource(hFilter);
        }

    }
    return(0);
}

/*
 * query the user for a filename, and then save the captured video
 * to that file
 */
LONG FAR PASCAL
cmdSaveVideoAs(HWND hWnd)
{
    OPENFILENAME ofn ;
    TCHAR        achFileName[_MAX_PATH];
    UINT         wError ;
    HANDLE       hFilter;
    int          oldhelpid;



    // Get the current capture file name and
    // then get the substitute file name to save video in
    if (wError = capFileGetCaptureFile(ghWndCap, achFileName, sizeof(achFileName))) {

        _fmemset(&ofn, 0, sizeof(OPENFILENAME)) ;
        ofn.lStructSize = sizeof(OPENFILENAME) ;
        ofn.hwndOwner = hWnd ;

        //load filters from resource stringtable
		if ( (hFilter = FindResource(ghInstApp, MAKEINTRESOURCE(ID_FILTER_AVI), RT_RCDATA))
		  && (hFilter = LoadResource(ghInstApp, hFilter)) )
		{
            ofn.lpstrFilter = LockResource(hFilter);
		}
		else
		{
            ofn.lpstrFilter = NULL;
		}

        ofn.nFilterIndex = 0 ;
        ofn.lpstrFile = achFileName ;
        ofn.nMaxFile = sizeof(achFileName) ;
        ofn.lpstrFileTitle = NULL ;
        ofn.lpstrTitle = tmpString(IDS_TITLE_SAVEAS);
        ofn.nMaxFileTitle = 0 ;
        ofn.lpstrInitialDir = NULL ;
        ofn.Flags =
#ifdef BIDI
        OFN_BIDIDIALOG |
#endif
        OFN_OVERWRITEPROMPT |  OFN_PATHMUSTEXIST ;


        // set help context
        oldhelpid = SetCurrentHelpContext(IDA_SAVECAPFILE);

        if (GetSaveFileName(&ofn)) {
            // If the user has hit OK then set save file name
            capFileSaveAs(ghWndCap, achFileName) ;
        }

        SetCurrentHelpContext(oldhelpid);

        if (hFilter) {
            UnlockResource(hFilter);
        }
    }
    return(0);
}


/*
 * Put up a dialog to allow the user to select a palette file and then
 * load that palette
 */
LONG FAR PASCAL
cmdLoadPalette(HWND hWnd)
{
    OPENFILENAME ofn ;
    TCHAR        achFileName[_MAX_PATH];
    HANDLE       hFilter;
    int          oldhelpid;



    achFileName[0] = 0;

    _fmemset(&ofn, 0, sizeof(OPENFILENAME));
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hWnd;

    //load filters from resource stringtable
	if ( (hFilter = FindResource(ghInstApp, MAKEINTRESOURCE(ID_FILTER_PALETTE), RT_RCDATA))
	  && (hFilter = LoadResource(ghInstApp, hFilter)) )
	{
        ofn.lpstrFilter = LockResource(hFilter);
	}
	else
	{
        ofn.lpstrFilter = NULL;
	}

    ofn.nFilterIndex = 1;
    ofn.lpstrFile = achFileName;
    ofn.nMaxFile = sizeof(achFileName);
    ofn.lpstrFileTitle = NULL;
    ofn.lpstrTitle = tmpString(IDS_TITLE_LOADPALETTE);
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.Flags =
#ifdef BIDI
    OFN_BIDIDIALOG |
#endif
    OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;


    // set help context id
    oldhelpid = SetCurrentHelpContext(IDA_LOADPAL);

    if (GetOpenFileName(&ofn)) {
        // If the user has hit OK then load palette
        capPaletteOpen(ghWndCap, achFileName);
    }

    SetCurrentHelpContext(oldhelpid);

    if (hFilter) {
        UnlockResource(hFilter);
    }
    return(0);
}

/*
 * query the user for a filename, and then save the current palette
 * to that file
 */
LONG FAR PASCAL
cmdSavePalette(HWND hWnd)
{
    OPENFILENAME ofn ;
    TCHAR        achFileName[_MAX_PATH];
    HANDLE       hFilter;
    int          oldhelpid;


    achFileName[0] = 0;

    _fmemset(&ofn, 0, sizeof(OPENFILENAME)) ;
    ofn.lStructSize = sizeof(OPENFILENAME) ;
    ofn.hwndOwner = hWnd ;

    //load filters from resource stringtable
	if ( (hFilter = FindResource(ghInstApp, MAKEINTRESOURCE(ID_FILTER_PALETTE), RT_RCDATA))
	  && (hFilter = LoadResource(ghInstApp, hFilter)) )
	{
        ofn.lpstrFilter = LockResource(hFilter);
	}
	else
	{
        ofn.lpstrFilter = NULL;
	}

    ofn.nFilterIndex = 1;
    ofn.lpstrFile = achFileName;
    ofn.nMaxFile = sizeof(achFileName);
    ofn.lpstrFileTitle = NULL;
    ofn.lpstrTitle = tmpString(IDS_TITLE_SAVEPALETTE);
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.Flags =
#ifdef BIDI
    OFN_BIDIDIALOG |
#endif
    OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

    // set help context for F1 key
    oldhelpid = SetCurrentHelpContext(IDA_SAVEPAL);

    if (GetSaveFileName(&ofn)) {
        // If the user has hit OK then set save file name
        capPaletteSave(ghWndCap, achFileName);
    }

    SetCurrentHelpContext(oldhelpid);

    if (hFilter) {
        UnlockResource(hFilter);
    }

    return(0);
}


/*
 * query the user for a filename, and then save the current frame
 * to that file
 */
LONG FAR PASCAL
cmdSaveDIB(HWND hWnd)
{
    OPENFILENAME ofn ;
    TCHAR        achFileName[_MAX_PATH];
    HANDLE       hFilter;
    int          oldhelpid;


    achFileName[0] = 0;

    _fmemset(&ofn, 0, sizeof(OPENFILENAME)) ;
    ofn.lStructSize = sizeof(OPENFILENAME) ;
    ofn.hwndOwner = hWnd ;

    //load filters from resource stringtable
	if ( (hFilter = FindResource(ghInstApp, MAKEINTRESOURCE(ID_FILTER_DIB), RT_RCDATA) )
	  && (hFilter = LoadResource(ghInstApp, hFilter) ) )
	{
        ofn.lpstrFilter = LockResource(hFilter);
    }
	else
	{
		ofn.lpstrFilter = NULL;
	}

    ofn.nFilterIndex = 1;
    ofn.lpstrFile = achFileName;
    ofn.nMaxFile = sizeof(achFileName);
    ofn.lpstrFileTitle = NULL;
    ofn.lpstrTitle = tmpString(IDS_TITLE_SAVEDIB);
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.Flags =
#ifdef BIDI
    OFN_BIDIDIALOG |
#endif
    OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY;

    // set help context for F1 handling
    oldhelpid = SetCurrentHelpContext(IDA_SAVEDIB);

    if (GetSaveFileName(&ofn)) {

        // If the user has hit OK then set save file name
        capFileSaveDIB(ghWndCap, achFileName);
    }

    SetCurrentHelpContext(oldhelpid);

    if (hFilter) {
        UnlockResource(hFilter);
    }

    return(0);
}

//
// MenuProc: Processes All Menu-based Operations
//
LRESULT FAR PASCAL MenuProc(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
////////////////////////////////////////////////////////////////////////
//  hWnd:      Application main window handle
//  hMenu:     Application menu handle
//  wParam:    Menu option
//  lParam:    Additional info for any menu option
////////////////////////////////////////////////////////////////////////

    BOOL         fResult ;
    DWORD        dwSize = 0;
    int          oldhelpid;

    HMENU hMenu = GetMenu(hWnd) ;

    switch (GET_WM_COMMAND_ID(wParam, lParam)) {

	case IDC_TOOLBAR:
            return toolbarCommand(hWnd, GET_WM_COMMAND_CMD(wParam, lParam), ghWndToolBar);

/* --- file --- */
        case IDM_F_SETCAPTUREFILE:
            return cmdSetCaptureFile(hWnd);

        case IDM_F_SAVEVIDEOAS:
            return cmdSaveVideoAs(hWnd);
            break;

        case IDM_F_ALLOCATESPACE:
            if (DoDialog(hWnd, IDD_AllocCapFileSpace, AllocCapFileProc, 0)) {

		// ensure repaint after dismissing dialog before
		// possibly lengthy operation
		UpdateWindow(ghWndMain);


                // If user has hit OK then alloc requested capture file space
                if (! capFileAlloc(ghWndCap, (long) gwCapFileSize * ONEMEG)) {
                    MessageBoxID(IDS_ERR_CANT_PREALLOC,
#ifdef BIDI
                                MB_RTL_READING |
#endif
                                MB_OK | MB_ICONEXCLAMATION) ;
                }
            }
            break ;

        case IDM_F_EXIT:
            DestroyWindow(hWnd) ;
            break;

        case IDM_F_LOADPALETTE:
            return cmdLoadPalette(hWnd);

        case IDM_F_SAVEPALETTE:
            return cmdSavePalette(hWnd);

        case IDM_F_SAVEFRAME:
            return cmdSaveDIB(hWnd);

        case IDM_F_EDITVIDEO:
        {
            HINSTANCE  u;
            BOOL	f = TRUE;	/* assume the best */
            HCURSOR     hOldCursor;

            /* build up the command line "AviEdit -n filename" */
            if (lstrlen(gachCaptureFile) > 0) {

                hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
                u = ShellExecute (hWnd, TEXT("open"), gachCaptureFile, NULL, NULL, SW_SHOWNORMAL);
                if ((UINT_PTR) u < 32){
            	/* report error on forking VidEdit */
                    MessageBoxID(IDS_ERR_VIDEDIT, MB_OK|MB_ICONEXCLAMATION);
            	f = FALSE;
                }

                SetCursor(hOldCursor);
            }
            return f;

        }


/* --- edit --- */

        case IDM_E_COPY:
            capEditCopy(ghWndCap) ;
            break;

        case IDM_E_PASTEPALETTE:
            capPalettePaste(ghWndCap) ;
            break;

        case IDM_E_PREFS:
            {
                if (DoDialog(hWnd, IDD_Prefs, PrefsDlgProc, 0)) {

                        // write prefs to profile

                        // force new brush
                        vidframeSetBrush(ghWndFrame, gBackColour);

                        // re-do layout
                        vidcapLayout(hWnd);

                }
            }
            break;

/* --- options --- */

        case IDM_O_PREVIEW:
            // Toggle Preview
    	    capGetStatus(ghWndCap, &gCapStatus, sizeof(CAPSTATUS)) ;
            vidcapSetLive(!gCapStatus.fLiveWindow) ;
            break;

        case IDM_O_OVERLAY:
            // Toggle Overlay
    	    capGetStatus(ghWndCap, &gCapStatus, sizeof(CAPSTATUS)) ;
            vidcapSetOverlay(!gCapStatus.fOverlayWindow);
            break ;

        case IDM_O_AUDIOFORMAT:
#ifdef  USE_ACM
            {
                ACMFORMATCHOOSE cfmt;
                static BOOL fDialogUp = FALSE;

                if (fDialogUp)
                    return FALSE;

                fDialogUp = TRUE;
                // Ask the ACM what the largest wave format is.....
                acmMetrics(NULL,
                            ACM_METRIC_MAX_SIZE_FORMAT,
                            &dwSize);

                // Get the current audio format
                dwSize = max (dwSize, capGetAudioFormatSize (ghWndCap));
                if (glpwfex = (LPWAVEFORMATEX) GlobalAllocPtr(GHND, dwSize)) {
                    capGetAudioFormat(ghWndCap, glpwfex, (WORD)dwSize) ;

		    _fmemset (&cfmt, 0, sizeof (ACMFORMATCHOOSE));
		    cfmt.cbStruct = sizeof (ACMFORMATCHOOSE);
		    cfmt.fdwStyle =  ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT;
		    cfmt.fdwEnum =   ACM_FORMATENUMF_HARDWARE |
				     ACM_FORMATENUMF_INPUT;
		    cfmt.hwndOwner = hWnd;
		    cfmt.pwfx =     glpwfex;
		    cfmt.cbwfx =    dwSize;

		    //oldhelpid = SetCurrentHelpContext(IDA_AUDIOSETUP);
		    if (!acmFormatChoose(&cfmt)) {
			capSetAudioFormat(ghWndCap, glpwfex, (WORD)glpwfex->cbSize +
					  sizeof (WAVEFORMATEX)) ;
			mmWriteProfileBinary(gachAppTitle, "WaveFormatBinary",
					     (LPVOID) glpwfex, glpwfex->cbSize +
					     sizeof (WAVEFORMATEX));
		    }
		    //SetCurrentHelpContext(oldhelpid);

		    GlobalFreePtr(glpwfex) ;
		}
                fDialogUp = FALSE;
            }
#else
            {
                // Get current audio format and then find required format
                dwSize = capGetAudioFormatSize (ghWndCap);  
                glpwfex = (LPWAVEFORMATEX) GlobalAllocPtr(GHND, dwSize) ;
                capGetAudioFormat(ghWndCap, glpwfex, (WORD)dwSize) ;

                if (DoDialog(hWnd, IDD_AudioFormat, AudioFormatProc, 0)) {
                        // If the user has hit OK, set the new audio format
                        capSetAudioFormat(ghWndCap, glpwfex, (WORD)dwSize) ;
			mmWriteProfileBinary(gachAppTitle, "WaveFormatBinary",
					 (LPVOID) glpwfex, dwSize);
                }
                GlobalFreePtr(glpwfex) ;
            }
#endif
            break ;

        case IDM_O_VIDEOFORMAT:
            if (gCapDriverCaps.fHasDlgVideoFormat) {
                // Only if the driver has a "Video Format" dialog box
                oldhelpid = SetCurrentHelpContext(IDA_VIDFORMAT);
                if (capDlgVideoFormat(ghWndCap)) {  // If successful,
                    // Get the new image dimension and center capture window
                    capGetStatus(ghWndCap, &gCapStatus, sizeof(CAPSTATUS)) ;
                    vidcapLayout(hWnd);
                }
                SetCurrentHelpContext(oldhelpid);
            }
            break;

        case IDM_O_VIDEOSOURCE:
            if (gCapDriverCaps.fHasDlgVideoSource) {
                // Only if the driver has a "Video Source" dialog box
                oldhelpid = SetCurrentHelpContext(IDA_VIDSOURCE);
                capDlgVideoSource(ghWndCap) ;
                capGetStatus(ghWndCap, &gCapStatus, sizeof(CAPSTATUS)) ;
                vidcapLayout(hWnd);
                SetCurrentHelpContext(oldhelpid);
            }
            break ;

        case IDM_O_VIDEODISPLAY:
            if (gCapDriverCaps.fHasDlgVideoDisplay) {
                // Only if the driver has a "Video Display" dialog box
                oldhelpid = SetCurrentHelpContext(IDA_VIDDISPLAY);
                capDlgVideoDisplay(ghWndCap) ;
                capGetStatus(ghWndCap, &gCapStatus, sizeof(CAPSTATUS)) ;
                SetCurrentHelpContext(oldhelpid);
            }
            break ;

        case IDM_O_CHOOSECOMPRESSOR:
            oldhelpid = SetCurrentHelpContext(IDA_COMPRESSION);
            capDlgVideoCompression(ghWndCap);
            SetCurrentHelpContext(oldhelpid);
            break;

        // Select a driver to activate
        case IDM_O_DRIVER0:
        case IDM_O_DRIVER1:
        case IDM_O_DRIVER2:
        case IDM_O_DRIVER3:
        case IDM_O_DRIVER4:
        case IDM_O_DRIVER5:
        case IDM_O_DRIVER6:
        case IDM_O_DRIVER7:
        case IDM_O_DRIVER8:
        case IDM_O_DRIVER9:
            vidcapInitHardware(ghWndMain, ghWndCap, (UINT) (wParam - IDM_O_DRIVER0));
            break;

/* --- capture --- */


        case IDM_C_PALETTE:
            if (DoDialog(hWnd, IDD_MakePalette, MakePaletteProc, 0)) {
                // Palette is created within the dialog
                bDefaultPalette = FALSE;
            }
            break;

        case IDM_C_CAPTUREVIDEO:

            // warn user if he is still using the default palette
            if (bDefaultPalette) {

		LPBITMAPINFOHEADER lpbi;
		int sz;

		// fUsingDefaultPalette will be TRUE even if the
		// current capture format is non-palettised. This is a
		// bizarre decision of Jay's.

		sz = (int)capGetVideoFormatSize(ghWndCap);
		lpbi = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, sz);

		if (lpbi) {    // We can warn s/he
		    if (capGetVideoFormat(ghWndCap, lpbi, sz) &&
			(lpbi->biCompression == BI_RGB) &&
			(lpbi->biBitCount <= 8)) {

			CAPSTATUS cs;

			// if we've warned him once, we can forget it
			bDefaultPalette = FALSE;

			capGetStatus(ghWndCap, &cs, sizeof(cs));

			if (cs.fUsingDefaultPalette) {

			    if (MessageBoxID(IDS_WARN_DEFAULT_PALETTE,
       				     MB_OKCANCEL| MB_ICONEXCLAMATION)== IDCANCEL) {
				break;
			    }
			}
		    }
		    LocalFree(lpbi);
		}
            }

            // Invoke a Dlg box to setup all the params
            if (DoDialog(hWnd, IDD_CapSetUp, CapSetUpProc, 0)) {

                // set the defaults we won't bother the user with
                gCapParms.fMakeUserHitOKToCapture = !gCapParms.fMCIControl;
                gCapParms.wPercentDropForError = 10;

                // fUsingDOSMemory is obsolete, but we use it here as
                // a flag which is TRUE if "CapturingToDisk"
                // The number of video buffers should be enough to get through
                // disk seeks and thermal recalibrations if "CapturingToDisk"
                // If "CapturingToMemory", get as many buffers as we can.

                gCapParms.wNumVideoRequested = 
                        gCapParms.fUsingDOSMemory ? 32 : 1000;

                // Don't abort on the left mouse anymore!
                gCapParms.fAbortLeftMouse = FALSE;
                gCapParms.fAbortRightMouse = TRUE;

                // If the Driver is Scrncap.drv, the following values are special

                // If wChunkGranularity is zero, the granularity will be set to the
                // disk sector size.
                gCapParms.wChunkGranularity = (gbIsScrncap ? 32 : 0);

                // Scrncap requires a callback for the message pump
                capSetCallbackOnYield(ghWndCap, 
                        (gbIsScrncap ? fpYieldCallback : NULL));

                // If the user has hit OK, set the new setup info
                capCaptureSetSetup(ghWndCap, &gCapParms, sizeof(CAPTUREPARMS)) ;
            } else {
                break;
            }

            // if no capture file, get that
            if (lstrlen(gachCaptureFile) <= 0) {
                cmdSetCaptureFile(hWnd);
                if (lstrlen(gachCaptureFile) <= 0) {
                    break;
                }
            }

            // Capture video sequence
            fResult = capCaptureSequence(ghWndCap) ;
            break;

        case IDM_C_CAPTUREFRAME:
            // Turn off overlay / preview (gets turned off by frame capture)
            vidcapSetLive(FALSE);
            vidcapSetOverlay(FALSE);

            // Grab a frame
            fResult = capGrabFrameNoStop(ghWndCap) ;
            break;


        case IDM_C_CAPSEL:
            {
                FARPROC fproc;

                // if no capture file, get that
                if (lstrlen(gachCaptureFile) <= 0) {
                    cmdSetCaptureFile(hWnd);
                    if (lstrlen(gachCaptureFile) <= 0) {
                        break;
                    }
                }

                fproc = MakeProcInstance(CapFramesProc, ghInstApp);
                DialogBox(ghInstApp, MAKEINTRESOURCE(IDD_CAPFRAMES), hWnd, (DLGPROC) fproc);
                FreeProcInstance(fproc);
            }
            break;

#ifdef DEBUG
        case IDM_C_TEST:
	    nTestCount = 0;
	    // Intentional fall through
	    
        case IDM_C_TESTAGAIN:
            // set the defaults we won't bother the user with
            gCapParms.fMakeUserHitOKToCapture = FALSE;
            gCapParms.wPercentDropForError = 100;

            gCapParms.wNumVideoRequested = 
                    gCapParms.fUsingDOSMemory ? 32 : 1000;

            // Don't abort on the left mouse anymore!
            gCapParms.fAbortLeftMouse = FALSE;
            gCapParms.fAbortRightMouse = TRUE;

            // If wChunkGranularity is zero, the granularity will be set to the
            // disk sector size.
            gCapParms.wChunkGranularity = (gbIsScrncap ? 32 : 0);

            // If the user has hit OK, set the new setup info
            capCaptureSetSetup(ghWndCap, &gCapParms, sizeof(CAPTUREPARMS)) ;

            // if no capture file, get that
            if (lstrlen(gachCaptureFile) <= 0) {
                cmdSetCaptureFile(hWnd);
                if (lstrlen(gachCaptureFile) <= 0) {
                    break;
                }
            }
	    
	    {
		TCHAR buf[80];

      gCapParms.wNumVideoRequested = 10;
      gCapParms.wNumAudioRequested = 5;
		gCapParms.fLimitEnabled = TRUE;
		if (gCapParms.wTimeLimit == 0)
		    gCapParms.wTimeLimit = 5;
		capCaptureSetSetup(ghWndCap, &gCapParms, sizeof(CAPTUREPARMS)) ;
		
		// Capture video sequence
      fResult = capCaptureSequence(ghWndCap) ;
		
		wsprintf (buf, "TestCount = %d", nTestCount++);
		statusUpdateStatus(ghWndStatus, buf);
		
		// Hold down the right mouse button to abort
		if (!GetAsyncKeyState(VK_RBUTTON) & 0x0001)
		    PostMessage (hWnd, WM_COMMAND, IDM_C_TESTAGAIN, 0L);
            }
            break;
#endif
	    
/* --- help --- */
        case IDM_H_CONTENTS:
            HelpContents();
            break;

        case IDM_H_ABOUT:
            ShellAbout(
                hWnd,
                "VidCap",
                "Video Capture Tool",
                LoadIcon(ghInstApp,  gachIconName)
            );
            //DoDialog(hWnd, IDD_HelpAboutBox, AboutProc, 0);
            break ;


    }

    return 0L ;
}

/* --- menu help and enable/disable handling ------------------------ */

// write or clear status line help text when the user brings up or cancels a
// menu. This depends on there being strings in the string table with
// the same ID as the corresponding menu item.
// Help text for the items along the menu bar (File, Edit etc) depends
// on IDM_FILE, IDM_EDIT being defined with values 100 apart in the same
// order as their index in the menu
void
MenuSelect(HWND hwnd, UINT cmd, UINT flags, HMENU hmenu)
{
    if ((LOWORD(flags) == 0xffff) && (hmenu == NULL)) {
        //menu closing - remove message
        statusUpdateStatus(ghWndStatus, NULL);
    } else if ( (flags & (MF_SYSMENU|MF_POPUP)) == (MF_SYSMENU|MF_POPUP)) {
        // the system menu itself
        statusUpdateStatus(ghWndStatus, MAKEINTRESOURCE(IDM_SYSMENU));
    } else if ((flags & MF_POPUP) == 0) {
        // a menu command item
        statusUpdateStatus(ghWndStatus, MAKEINTRESOURCE(cmd));
    } else {
        //a popup menu - we need to search to find which one.
        // note that the cmd item in Win16 will now have a
        // menu handle, whereas in Win32 it has an index.
        // NOTE: this code assumes that the menu items
        // are #defined 100 apart in the same order, starting
        // with IDM_FILE
#ifdef _WIN32
        statusUpdateStatus(ghWndStatus, MAKEINTRESOURCE(IDM_FILE + (cmd * 100)));
#else
        int i,c;
        HMENU hmenuMain; 

        hmenuMain = GetMenu(hWnd);
        c = GetMenuItemCount(hmenuMain);

        for(i = 0; i < c; i++) {
            if (hmenu == GetSubMenu(hmenuMain, i)) {
                statusUpdateStatus(MAKEINTRESOURCE(IDM_FILE + (cmd*100)));
                return(0);
            }
        }
        statusUpdateStatus(NULL);
#endif
    }
}

// a popup menu is being selected - enable or disable menu items
int
InitMenuPopup(
    HWND hwnd,
    HMENU hmenu,
    int index
)
{
    int i = MF_ENABLED;
    CAPSTATUS cs;
    BOOL bUsesPalettes;

    capGetStatus(ghWndCap, &cs, sizeof(cs));

    // try to see if the driver uses palettes
    if ((cs.hPalCurrent != NULL) || (cs.fUsingDefaultPalette)) {
        bUsesPalettes = TRUE;
    } else {
        bUsesPalettes = FALSE;
    }


    switch(index) {
    case 0:         // IDM_FILE

        if (lstrlen(gachCaptureFile) <= 0) {
            i = MF_GRAYED;
        }
        // save as enabled only if we have a capture file
        EnableMenuItem(hmenu, IDM_F_SAVEVIDEOAS, i);
        // edit video possible only if we have a capture file AND we've
        // captured something
        EnableMenuItem(hmenu, IDM_F_EDITVIDEO,
            (cs.dwCurrentVideoFrame > 0) ? i : MF_GRAYED);

        // allow save palette if there is one
        EnableMenuItem(hmenu, IDM_F_SAVEPALETTE,
            (cs.hPalCurrent != NULL) ? MF_ENABLED:MF_GRAYED);

        // allow load palette if the driver uses palettes
        EnableMenuItem(hmenu, IDM_F_LOADPALETTE,
            bUsesPalettes ? MF_ENABLED : MF_GRAYED);

        break;

    case 1:         // IDM_EDIT

        // paste palettes if driver uses them and there is one pastable
        EnableMenuItem(hmenu, IDM_E_PASTEPALETTE,
            (bUsesPalettes && IsClipboardFormatAvailable(CF_PALETTE)) ? MF_ENABLED:MF_GRAYED);

        break;

    case 2:         // IDM_OPTIONS

        EnableMenuItem(hmenu, IDM_O_AUDIOFORMAT,
            cs.fAudioHardware ? MF_ENABLED : MF_GRAYED);

        EnableMenuItem(hmenu, IDM_O_OVERLAY,
            gCapDriverCaps.fHasOverlay ? MF_ENABLED:MF_GRAYED);

        EnableMenuItem(hmenu, IDM_O_VIDEOFORMAT,
            gCapDriverCaps.fHasDlgVideoFormat ? MF_ENABLED:MF_GRAYED);

        EnableMenuItem(hmenu, IDM_O_VIDEODISPLAY,
            gCapDriverCaps.fHasDlgVideoDisplay ? MF_ENABLED:MF_GRAYED);

        EnableMenuItem(hmenu, IDM_O_VIDEOSOURCE,
            gCapDriverCaps.fHasDlgVideoSource ? MF_ENABLED:MF_GRAYED);

        EnableMenuItem(hmenu, IDM_O_PREVIEW,
                gbHaveHardware ? MF_ENABLED:MF_GRAYED);


    case 3:     // IDM_CAPTURE
        if (!gbHaveHardware) {
            i = MF_GRAYED;
        }
        EnableMenuItem(hmenu, IDM_C_CAPSEL, i);
        EnableMenuItem(hmenu, IDM_C_CAPTUREFRAME, i);
        EnableMenuItem(hmenu, IDM_C_CAPTUREVIDEO, i);
        EnableMenuItem(hmenu, IDM_C_PALETTE, (gbHaveHardware &&
            gCapDriverCaps.fDriverSuppliesPalettes) ? MF_ENABLED : MF_GRAYED);

        break;
    }
    return(0);
}




//
// MainWndProc: Application Main Window Procedure
//
LRESULT FAR PASCAL MainWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
////////////////////////////////////////////////////////////////////////
//  hWnd:      Application main window handle
//  Message:   Next message to be processed
//  wParam:    WORD param for the message
//  lParam:    LONG param for the message
////////////////////////////////////////////////////////////////////////

    switch (Message) {

        static BOOL fMinimized;

        case WM_SYSCOMMAND:
	    if ((wParam & 0xfff0) == SC_MAXIMIZE)
	    	fMinimized = FALSE;
	    else if ((wParam & 0xfff0) == SC_RESTORE)
	    	fMinimized = FALSE;
	    else if ((wParam & 0xfff0) == SC_MINIMIZE)
	    	fMinimized = TRUE;	
	    return DefWindowProc(hWnd, Message, wParam, lParam);			
	    break;

        case WM_COMMAND:
            MenuProc(hWnd, wParam, lParam) ;
            break ;

        case WM_CREATE:
            HelpInit(ghInstApp, "vidcap.hlp", hWnd);
            break;

        case WM_NCHITTEST:
        {
            LRESULT dw;

            dw = DefWindowProc(hWnd, Message, wParam, lParam);
            // Don't allow border resize if autosizing
            if (gbAutoSizeFrame) {
                if (dw >= HTSIZEFIRST && dw <= HTSIZELAST)
                    dw = HTCAPTION;
            }
            return dw;
                
        }
            break;

        case WM_GETMINMAXINFO:
            // Don't allow manual sizing if window locked to the capture size
            if (gbHaveHardware && gbAutoSizeFrame && !gbInLayout) {
                RECT rW;

                LPMINMAXINFO lpMMI = (LPMINMAXINFO) lParam;

                GetWindowRect (hWnd, &rW);
                lpMMI->ptMinTrackSize.x = rW.right - rW.left;
                lpMMI->ptMinTrackSize.y = rW.bottom - rW.top;
                lpMMI->ptMaxTrackSize = lpMMI->ptMinTrackSize;
            }
            break;

        case WM_MOVE:
	    if (!fMinimized) {
	    	vidcapLayout (hWnd);
	    }
	    break;

        case WM_SIZE:
	    if (!fMinimized) {
	    	vidcapLayout (hWnd);
	    }
	    break;

        case WM_MENUSELECT:
            {
                UINT cmd = GET_WM_MENUSELECT_CMD(wParam, lParam);
                UINT flags = GET_WM_MENUSELECT_FLAGS(wParam, lParam);
                HMENU hmenu = GET_WM_MENUSELECT_HMENU(wParam, lParam);

                MenuSelect(hWnd, cmd, flags, hmenu);
            }
            break;

        case WM_INITMENUPOPUP:
            {
                BOOL bSystem = (BOOL) HIWORD(lParam);

                if (!bSystem) {
                    return InitMenuPopup(hWnd,
                            (HMENU) wParam, (int) LOWORD(lParam));
                } else {
                    return(DefWindowProc(hWnd, Message, wParam, lParam));
                }
            }


        case WM_SYSCOLORCHANGE:
            // we don't use this ourselves, but we should pass
            // it on to all three children
            SendMessage(ghWndFrame, Message, wParam, lParam);
            SendMessage(ghWndToolBar, Message, wParam, lParam);
            SendMessage(ghWndStatus, Message, wParam, lParam);
            return (TRUE);


        case WM_PALETTECHANGED:
        case WM_QUERYNEWPALETTE:
            // Pass the buck to Capture window proc
            return SendMessage(ghWndCap, Message, wParam, lParam) ;
            break ;

        case WM_SETFOCUS:
            // the toolbar is the only part that needs the focus
            SetFocus(ghWndToolBar);
            break;


        case WM_ACTIVATEAPP:
            if (wParam && ghWndCap) 
                capPreviewRate(ghWndCap, 15); // Fast preview when active
            else
                capPreviewRate(ghWndCap, 1000); // Slow preview when inactive
            break;

        case WM_NEXTDLGCTL:
            // if anyone is tabbing about, move the focus to the
            // toolbar
            SetFocus(ghWndToolBar);

            // select the correct button to handle moving off one
            // end and back on the other end
            if (lParam == FALSE) {
                // are we moving forwards or backwards ?
                if (wParam == 0) {
                    // move to next - so select first button
                    toolbarSetFocus(ghWndToolBar, TB_FIRST);
                } else {
                    // move to previous - so select last
                    toolbarSetFocus(ghWndToolBar, TB_LAST);
                }
            }
            break;

        case WM_PAINT:
        {
            HDC           hDC ;
            PAINTSTRUCT   ps ;

            hDC = BeginPaint(hWnd, &ps) ;

            // Included in case the background is not a pure color
            SetBkMode(hDC, TRANSPARENT) ;

            EndPaint(hWnd, &ps) ;
            break ;
        }

        case WM_CLOSE:
            // Disable and free all the callbacks 
            capSetCallbackOnError(ghWndCap, NULL) ;
			if (fpErrorCallback) {
            	FreeProcInstance(fpErrorCallback) ;
				fpErrorCallback = NULL;
			}

            capSetCallbackOnStatus(ghWndCap, NULL) ;
			if (fpStatusCallback) {
            	FreeProcInstance(fpStatusCallback) ;
				fpStatusCallback = NULL;
			}

            capSetCallbackOnYield(ghWndCap, NULL) ;
			if (fpYieldCallback) {
            	FreeProcInstance(fpYieldCallback) ;
				fpYieldCallback = NULL;
			}

            // Disconnect the current capture driver
            capDriverDisconnect (ghWndCap);

            // Destroy child windows, modeless dialogs, then this window...
            // DestroyWindow(ghWndCap) ;
            DestroyWindow(hWnd) ;
            break ;

        case WM_DESTROY:
            {
                // remember window size and position
                // - this will be written to the profile
                WINDOWPLACEMENT wp;

                wp.length = sizeof (WINDOWPLACEMENT);
                GetWindowPlacement(hWnd, &wp);

                gWinShow = wp.showCmd;
                gWinX = wp.rcNormalPosition.left;
                gWinY = wp.rcNormalPosition.top;
                gWinCX = RECTWIDTH(wp.rcNormalPosition);
                gWinCY = RECTHEIGHT(wp.rcNormalPosition);

                // write defaults out to the registry
                vidcapWriteProfile();
                vidcapWriteSettingsProfile();

                HelpShutdown();

            }

            PostQuitMessage(0) ;
            break ;

        default:
            return DefWindowProc(hWnd, Message, wParam, lParam) ;
    }

    return 0L;
}   // End of MainWndProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\vidcap32\toolbar.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/
/****************************************************************************
 *
 *   toolbar.c: Toolbar control window
 *
 *   Vidcap32 Source code
 *
 ***************************************************************************/

#include <string.h>

#include <windows.h>
#include <windowsx.h>
//#include <win32.h>
#include "toolbar.h"		// use this for generic app
/************************************************************************/

/* work for win3.0 */
#ifndef COLOR_BTNHIGHLIGHT
#define COLOR_BTNHIGHLIGHT 20
#endif

TCHAR    szToolBarClass[] = "ToolBarClass";
HBRUSH	ghbrToolbar;		// brush for toolbar background

//
// Window proc for buttons, THIS FUNCTION MUST BE EXPORTED
//
LRESULT FAR PASCAL toolbarWndProc(HWND, unsigned, WPARAM, LPARAM);

typedef long (FAR PASCAL *LPWNDPROC)();

/*
	Defines
*/

#ifdef _WIN32

#define GETARRAYBUTT(hwnd)	((HANDLE)GetWindowLongPtr(hwnd,GWLP_ARRAYBUTT))
#define GETNUMBUTTONS(hwnd)	((int)GetWindowLong(hwnd,GWL_NUMBUTTONS))
#define GETPRESSED(hwnd)	((BOOL)GetWindowLong(hwnd,GWL_PRESSED))
#define GETKEYPRESSED(hwnd)	((BOOL)GetWindowLong(hwnd,GWL_KEYPRESSED))
#define GETWHICH(hwnd)		((int)GetWindowLong(hwnd,GWL_WHICH))
#define GETSHIFTED(hwnd)	((BOOL)GetWindowLong(hwnd,GWL_SHIFTED))
#define GETBMPHANDLE(hwnd)	((HANDLE)GetWindowLongPtr(hwnd,GWLP_BMPHANDLE))
#define GETBMPINT(hwnd)		((int)GetWindowLong(hwnd,GWL_BMPINT))
#define GETBUTTONSIZE(hwnd)	GetWindowLong(hwnd,GWL_BUTTONSIZE)
#define GETHINST(hwnd)		((HANDLE)GetWindowLongPtr(hwnd,GWLP_HINST))


#define SETARRAYBUTT(hwnd, h) SetWindowLongPtr(hwnd, GWLP_ARRAYBUTT, (UINT_PTR)h)
#define SETNUMBUTTONS(hwnd, wNumButtons) \
			SetWindowLong(hwnd, GWL_NUMBUTTONS, wNumButtons)
#define SETPRESSED(hwnd, f)	SetWindowLong(hwnd, GWL_PRESSED, (UINT)f)
#define SETKEYPRESSED(hwnd, f)	SetWindowLong(hwnd, GWL_KEYPRESSED, (UINT)f)
#define SETWHICH(hwnd, i)	SetWindowLong(hwnd, GWL_WHICH, (UINT)i)
#define SETSHIFTED(hwnd, i)	SetWindowLong(hwnd, GWL_SHIFTED, (UINT)i)
#define SETBMPHANDLE(hwnd, h)	SetWindowLongPtr(hwnd, GWLP_BMPHANDLE, (UINT_PTR)h)
#define SETBMPINT(hwnd, i)	SetWindowLong(hwnd, GWL_BMPINT, (UINT)i)
#define SETBUTTONSIZE(hwnd, l)	SetWindowLong(hwnd, GWL_BUTTONSIZE, l)
#define SETHINST(hwnd, h)	SetWindowLongPtr(hwnd, GWLP_HINST, (UINT_PTR)h)

#else

#define GETARRAYBUTT(hwnd)	((HANDLE)GetWindowWord(hwnd,GWW_ARRAYBUTT))
#define GETNUMBUTTONS(hwnd)	((int)GetWindowWord(hwnd,GWW_NUMBUTTONS))
#define GETPRESSED(hwnd)	((BOOL)GetWindowWord(hwnd,GWW_PRESSED))
#define GETKEYPRESSED(hwnd)	((BOOL)GetWindowWord(hwnd,GWW_KEYPRESSED))
#define GETWHICH(hwnd)		((int)GetWindowWord(hwnd,GWW_WHICH))
#define GETSHIFTED(hwnd)	((BOOL)GetWindowWord(hwnd,GWW_SHIFTED))
#define GETBMPHANDLE(hwnd)	((HANDLE)GetWindowWord(hwnd,GWW_BMPHANDLE))
#define GETBMPINT(hwnd)		((int)GetWindowWord(hwnd,GWW_BMPINT))
#define GETBUTTONSIZE(hwnd)	GetWindowLong(hwnd,GWL_BUTTONSIZE)
#define GETHINST(hwnd)		((HANDLE)GetWindowWord(hwnd,GWW_HINST))


#define SETARRAYBUTT(hwnd, h) SetWindowWord(hwnd, GWW_ARRAYBUTT, (WORD)h)
#define SETNUMBUTTONS(hwnd, wNumButtons) \
			SetWindowWord(hwnd, GWW_NUMBUTTONS, wNumButtons)
#define SETPRESSED(hwnd, f)	SetWindowWord(hwnd, GWW_PRESSED, (WORD)f)
#define SETKEYPRESSED(hwnd, f)	SetWindowWord(hwnd, GWW_KEYPRESSED, (WORD)f)
#define SETWHICH(hwnd, i)	SetWindowWord(hwnd, GWW_WHICH, (WORD)i)
#define SETSHIFTED(hwnd, i)	SetWindowWord(hwnd, GWW_SHIFTED, (WORD)i)
#define SETBMPHANDLE(hwnd, h)	SetWindowWord(hwnd, GWW_BMPHANDLE, (WORD)h)
#define SETBMPINT(hwnd, i)	SetWindowWord(hwnd, GWW_BMPINT, (WORD)i)
#define SETBUTTONSIZE(hwnd, l)	SetWindowLong(hwnd, GWL_BUTTONSIZE, l)
#define SETHINST(hwnd, h)	SetWindowWord(hwnd, GWW_HINST, (WORD)h)

#endif

#define lpCreate ((LPCREATESTRUCT)lParam)

/* Prototypes */

static void NEAR PASCAL NotifyParent(HWND, int);



/**************************************************************************
	toolbarInit( hInst, hPrev )

	Call this routine to initialize the toolbar code.

	Arguments:
		hPrev	instance handle of previous instance
		hInst	instance handle of current instance

	Returns:
		TRUE if successful, FALSE if not
***************************************************************************/

BOOL FAR PASCAL toolbarInit(HANDLE hInst, HANDLE hPrev)
{
	WNDCLASS	cls;
	
	/* Register the tool bar window class */
	if (!hPrev) {

	    cls.hCursor        = LoadCursor(NULL,IDC_ARROW);
	    cls.hIcon          = NULL;
	    cls.lpszMenuName   = NULL;
	    cls.lpszClassName  = (LPSTR)szToolBarClass;
	    cls.hbrBackground  = (HBRUSH)(COLOR_BTNFACE + 1);
	    cls.hInstance      = hInst;
	    cls.style          = CS_DBLCLKS;
	    cls.lpfnWndProc    = toolbarWndProc;
	    cls.cbClsExtra     = 0;
	    cls.cbWndExtra     = TOOLBAR_EXTRABYTES;
	    if (!RegisterClass(&cls))
		return FALSE;
	}

	return TRUE;
}


/***************************************************************************/
/* toolbarSetBitmap:  takes a resource ID and associates that bitmap with  */
/*                    a given toolbar.  Also takes the instance handle and */
/*                    the size of the buttons on the toolbar.              */
/***************************************************************************/
BOOL FAR PASCAL toolbarSetBitmap(HWND hwnd, HANDLE hInst, int ibmp, POINT ptSize)
{
	SETHINST(hwnd, hInst);
	SETBMPHANDLE(hwnd, NULL);
	SETBMPINT(hwnd, ibmp);
	SETBUTTONSIZE(hwnd, MAKELONG(ptSize.y, ptSize.x));
	return (BOOL)SendMessage(hwnd, WM_SYSCOLORCHANGE, 0, 0L); // do the work
}

/***************************************************************************/
/* toolbarGetNumButtons:  return the number of buttons registered on a     */
/*                        given toolbar window.                            */
/***************************************************************************/
int FAR PASCAL toolbarGetNumButtons(HWND hwnd)
{
    return GETNUMBUTTONS(hwnd);
}


/***************************************************************************/
/* toolbarButtonFromIndex:  Given an index into the array of buttons on    */
/*                          this toolbar, return which button is there.    */
/*                          Returns -1 for an error code.                  */
/***************************************************************************/
int FAR PASCAL toolbarButtonFromIndex(HWND hwnd, int iBtnPos)
{
	int		iButton;
	HANDLE		h;
	TOOLBUTTON	far *lpaButtons;

	/* Get the array of buttons on this toolbar */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return -1;
	
	/* Validate the index passed in */
	if (iBtnPos > GETNUMBUTTONS(hwnd) || iBtnPos < 0)
		return -1;

	lpaButtons = (TOOLBUTTON far *)GlobalLock(h);

	/* Read off the answer */
	iButton = lpaButtons[iBtnPos].iButton;

	GlobalUnlock(h);
	return iButton;
}


/***************************************************************************/
/* toolbarIndexFromButton:  Given a button ID, return the position in the  */
/*                          array that it appears at.                      */
/*                          Returns -1 for an error code.                  */
/***************************************************************************/
int FAR PASCAL toolbarIndexFromButton(HWND hwnd, int iButton)
{
	int		i, iBtnPos = -1;
	HANDLE		h;
	TOOLBUTTON	far *lpButton;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return -1;
	lpButton = (TOOLBUTTON far *)GlobalLock(h);

	/* loop through until you find it */
	for(i = 0; i < GETNUMBUTTONS(hwnd); i++, lpButton++)
		if (lpButton->iButton == iButton) {
			iBtnPos = i;
			break;
		}

	GlobalUnlock(h);
	return iBtnPos;
}



/***************************************************************************/
/* toolbarPrevStateFromButton:  Given a button ID, return the state that   */
/*                              the button was in before it was pressed    */
/*                              all the way down (for non-push buttons).   */
/*                              Return -1 for an error code.               */
/***************************************************************************/
int FAR PASCAL toolbarPrevStateFromButton(HWND hwnd, int iButton)
{
	int		i, iPrevState = -1;
	HANDLE		h;
	TOOLBUTTON	far *lpButton;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return -1;
	lpButton = (TOOLBUTTON far *)GlobalLock(h);

	/* look for what we need */
	for(i = 0; i < GETNUMBUTTONS(hwnd); i++, lpButton++)
		if (lpButton->iButton == iButton) {
			iPrevState = lpButton->iPrevState;
			break;
		}

	GlobalUnlock(h);
	return iPrevState;
}



/***************************************************************************/
/* toolbarActivityFromButton:   Given a button ID, return the most recent  */
/*                              activity that happened to it. (eg DBLCLK)  */
/*                              Return -1 for an error code.               */
/***************************************************************************/
int FAR PASCAL toolbarActivityFromButton(HWND hwnd, int iButton)
{
	int		i, iActivity = -1;
	HANDLE		h;
	TOOLBUTTON	far *lpButton;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return -1;
	lpButton = (TOOLBUTTON far *)GlobalLock(h);

	/* loop through until you find it */
	for(i = 0; i < GETNUMBUTTONS(hwnd); i++, lpButton++)
		if (lpButton->iButton == iButton)
			iActivity = lpButton->iActivity;

	GlobalUnlock(h);
	return iActivity;
}



/***************************************************************************/
/* toolbarIndexFromPoint:  Given a point in the toolbar window, return the */
/*                         index of the button beneath that point.         */
/*                         Return -1 for an error code.                    */
/***************************************************************************/
int FAR PASCAL toolbarIndexFromPoint(HWND hwnd, POINT pt)
{
	int		i, iBtnPos = -1;
	HANDLE		h;
	TOOLBUTTON	far *lpButton;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return -1;
	lpButton = (TOOLBUTTON far *)GlobalLock(h);

	/* loop through until we find an intersection */
	for(i = 0; i < GETNUMBUTTONS(hwnd); i++, lpButton++)
		if (PtInRect(&lpButton->rc, pt)) {
			iBtnPos = i;
			break;
		}

	GlobalUnlock(h);
	return iBtnPos;
}



/***************************************************************************/
/* toolbarRectFromIndex:   Given an index into our array of buttons, return*/
/*                         the rect occupied by that button.               */
/*                         Return a NULL rect for an error.                */
/***************************************************************************/
BOOL FAR PASCAL toolbarRectFromIndex(HWND hwnd, int iBtnPos, LPRECT lprc)
{
	HANDLE		h;
	TOOLBUTTON	far *lpaButtons;
	
	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
	    return FALSE;

	/* Validate the index passed in */
	if (iBtnPos > GETNUMBUTTONS(hwnd) || iBtnPos < 0)
	    return FALSE;

	lpaButtons = (TOOLBUTTON far *)GlobalLock(h);

	/* Read off the rect */
	*lprc = lpaButtons[iBtnPos].rc;

	GlobalUnlock(h);
        return TRUE;
}



/***************************************************************************/
/* toolbarFullStateFromButton: Given a button in our array of buttons,     */
/*                             return the state of that button.            */
/*                             (including the wierd state FULLDOWN). For   */
/*                             just UP or DOWN or GRAYED,                  */
/*                             call toolbarStateFromButton.		   */
/*                             Return -1 for an error.                     */
/***************************************************************************/
int FAR PASCAL toolbarFullStateFromButton(HWND hwnd, int iButton)
{
	int		iState, iBtnPos;
	HANDLE		h;
	TOOLBUTTON	far *lpaButtons;

	iBtnPos = toolbarIndexFromButton(hwnd, iButton);
	if (iBtnPos == -1)
		return -1;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return -1;

	lpaButtons = (TOOLBUTTON far *)GlobalLock(h);

	/* Read off the state */
	iState = lpaButtons[iBtnPos].iState;

	GlobalUnlock(h);
	return iState;
}	



/***************************************************************************/
/* toolbarStateFromButton: This fn is called by the parent application     */
/*                         to get the state of a button.  It will only     */
/*                         return DOWN, or UP or GRAYED as opposed to      */
/*                         toolbarFullStateFromButton which could return   */
/*                         FULLDOWN.                                       */
/***************************************************************************/
int FAR PASCAL toolbarStateFromButton(HWND hwnd, int iButton)
{
	int	iState;

	/* If a checkbox button is all the way down, it's previous state is */
	/* the one we want.						    */
	if ((iState = toolbarFullStateFromButton(hwnd, iButton))
							== BTNST_FULLDOWN) {
	    iState = toolbarPrevStateFromButton(hwnd, iButton);
	    return iState;
	} else
	    return iState;
}



/***************************************************************************/
/* toolbarStringFromIndex: Given an index into our array of buttons, return*/
/*                         the string resource associated with it.         */
/*                         Return -1 for an error.                         */
/***************************************************************************/
int FAR PASCAL toolbarStringFromIndex(HWND hwnd, int iBtnPos)
{
	int		iString;
	HANDLE		h;
	TOOLBUTTON	far *lpaButtons;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return -1;

	/* Validate the index passed in */
	if (iBtnPos > GETNUMBUTTONS(hwnd) || iBtnPos < 0)
		return -1;

	lpaButtons = (TOOLBUTTON far *)GlobalLock(h);

	/* Read off the ID */
	iString = lpaButtons[iBtnPos].iString;	

	GlobalUnlock(h);
	return iString;
}



/***************************************************************************/
/* toolbarTypeFromIndex:   Given an index into our array of buttons, return*/
/*                         the type of button it is (PUSH, RADIO, etc.)    */
/*                         Return -1 for an error.                         */
/***************************************************************************/
int FAR PASCAL toolbarTypeFromIndex(HWND hwnd, int iBtnPos)
{
	int		iType;
	HANDLE		h;
	TOOLBUTTON	far *lpaButtons;

	/* Get the Array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return -1;

	/* Validate the index passed in */
	if (iBtnPos > GETNUMBUTTONS(hwnd) || iBtnPos < 0)
		return -1;

	lpaButtons = (TOOLBUTTON far *)GlobalLock(h);

	/* Read off the type */
	iType = lpaButtons[iBtnPos].iType;

	GlobalUnlock(h);
	return iType;
}


/***************************************************************************/
/* toolbarAddTool:  Add a button to this toolbar.  Sort them by leftmost   */
/*                  position in the window (for tabbing order).            */
/*                  Return FALSE for an error.                             */
/***************************************************************************/
BOOL FAR PASCAL toolbarAddTool(HWND hwnd, TOOLBUTTON tb)
{
	HANDLE		h;
	TOOLBUTTON far  *lpaButtons;
	int		cButtons, i, j;
	BOOL		fInsert = FALSE;

	/* We better not have this button on the toolbar already */
	if (toolbarIndexFromButton(hwnd, tb.iButton) != -1)
		return FALSE;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return FALSE;

	/* How many buttons are there already? */
	cButtons = GETNUMBUTTONS(hwnd);

	/* If we have filled our alloced memory for this array already, we */
	/* need to re-alloc some more memory				   */
	if ( ((cButtons & (TOOLGROW - 1)) == 0) && (cButtons > 0) ) {

		/* Re-alloc it bigger */
		h = GlobalReAlloc(h,
			GlobalSize(h) + TOOLGROW * sizeof(TOOLBUTTON),
			GMEM_MOVEABLE | GMEM_SHARE);
		if (!h)
		    return FALSE;
	}

	lpaButtons = (TOOLBUTTON far *)GlobalLock(h);

	/* Look for the spot we need to insert this new guy at.	*/
 	/* Remember, we sort by left x position	breaking ties   */
 	/* with top y position.					*/
	for (i = 0; i < cButtons; i++) {
						// Here it goes
 	    if (lpaButtons[i].rc.left > tb.rc.left ||
 			(lpaButtons[i].rc.left == tb.rc.left &&
 				lpaButtons[i].rc.top > tb.rc.top)) {
		fInsert = TRUE;
		/* Open up a spot in the array */
		for (j = cButtons; j > i; j--)
		    lpaButtons[j] = lpaButtons[j-1];
		/* Add our new guy */
		lpaButtons[i] = tb;		// redraw now
		InvalidateRect(hwnd, &(lpaButtons[i].rc), FALSE);
		break;
	    }
	}

	/* If our loop didn't insert it, we need to add it to the end */
	if (!fInsert)
	    lpaButtons[i] = tb;

	/* If we are told that this button has the focus, we better	*/
	/* change the focus to it.  Then use the normal state.          */
	if (tb.iState == BTNST_FOCUSUP) {
	    tb.iState = BTNST_UP;
	    SETWHICH(hwnd, i);
	} else if (tb.iState == BTNST_FOCUSDOWN || tb.iState == BTNST_FULLDOWN){
	    tb.iState = BTNST_DOWN;	// nonsense to init to FULLDOWN
	    SETWHICH(hwnd, i);
	}

	cButtons++;		// one more button now.
	GlobalUnlock(h);

	SETNUMBUTTONS(hwnd, cButtons);	// new count
	SETARRAYBUTT(hwnd, h);		// re-alloc might have changed it

	/* Just in case no one else makes this new button draw */
	InvalidateRect(hwnd, &(tb.rc), FALSE);

	return TRUE;
}


 /***************************************************************************/
 /* toolbarRetrieveTool:  Get the TOOLBUTTON struct for the given button.   */
 /*                       Return FALSE for an error.                        */
 /***************************************************************************/
 BOOL FAR PASCAL toolbarRetrieveTool(HWND hwnd, int iButton, LPTOOLBUTTON lptb)
 {
 	int		i;
 	HANDLE		h;
 	TOOLBUTTON	far *lpButton;
 	BOOL		fFound = FALSE;
 	
 	/* Get the array of buttons */
 	h = GETARRAYBUTT(hwnd);
 	if (!h)
 		return FALSE;
 	lpButton = (TOOLBUTTON far *)GlobalLock(h);

 	/* look for what we need */
 	for(i = 0; i < GETNUMBUTTONS(hwnd); i++, lpButton++)
 		if (lpButton->iButton == iButton) {
 			*lptb = *lpButton;
 			fFound = TRUE;
 			break;
 		}

 	GlobalUnlock(h);
 	return fFound;
 }



/***************************************************************************/
/* toolbarRemoveTool:  Remove this button ID from our array of buttons on  */
/*                    the toolbar.  (only 1 of each button ID allowed).   */
/*                     Return FALSE for an error.                          */
/***************************************************************************/
BOOL FAR PASCAL toolbarRemoveTool(HWND hwnd, int iButton)
{
	HANDLE		h;
	TOOLBUTTON far  *lpaButtons;
	int		cButtons, i, j;
	BOOL		fFound = FALSE;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return FALSE;

	/* How many buttons are on there now? */
	cButtons = GETNUMBUTTONS(hwnd);

	lpaButtons = (TOOLBUTTON far *)GlobalLock(h);

	/* Find a match, remove it, and close the array around it. */
	for (i = 0; i < cButtons; i++)
		if (lpaButtons[i].iButton == iButton) {	
			fFound = TRUE;
						// redraw now
			InvalidateRect(hwnd, &(lpaButtons[i].rc), FALSE);
			if (i != cButtons - 1)	// Last button? Don't bother!
				for (j = i; j < cButtons; j++)
					lpaButtons[j] = lpaButtons[j + 1];
			break;
		}

	GlobalUnlock(h);

	/* Didn't find it! */
	if (!fFound)
	    return FALSE;

	/* One less button */
	cButtons--;

	/* Every once in a while, re-alloc a smaller array chunk to	*/
	/* save memory.							*/
	if ( ((cButtons & (TOOLGROW - 1)) == 0) && (cButtons > 0) ) {

		/* Re-alloc it smaller */
		h = GlobalReAlloc(h,
			GlobalSize(h) - TOOLGROW * sizeof(TOOLBUTTON),
			GMEM_MOVEABLE | GMEM_SHARE);
		if (!h)
		    return FALSE;
	}

	SETNUMBUTTONS(hwnd, cButtons);	// new count
	SETARRAYBUTT(hwnd, h);		// re-alloc could have changed it

	return TRUE;
}

/***************************************************************************/
/* toolbarModifyString: Given a button ID on the toolbar, change it's      */
/*                      string resource associated with it.                */
/*                      returns FALSE for an error or if no such button    */
/***************************************************************************/
BOOL FAR PASCAL toolbarModifyString(HWND hwnd, int iButton, int iString)
{
	HANDLE		h;
	TOOLBUTTON far  *lpButton;
	int		cButtons, i;
	BOOL		fFound = FALSE;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return FALSE;

	/* How many buttons? */
	cButtons = GETNUMBUTTONS(hwnd);
	lpButton = (TOOLBUTTON far *)GlobalLock(h);

	/* Find that button, and change it's state */
	for (i = 0; i < cButtons; i++, lpButton++)
		if (lpButton->iButton == iButton) {
			lpButton->iString = iString;
			fFound = TRUE;			// redraw now
			break;
		}

	GlobalUnlock(h);
	return fFound;
}

/***************************************************************************/
/* toolbarModifyState:  Given a button ID on the toolbar, change it's      */
/*                      state.                                             */
/*                      returns FALSE for an error or if no such button    */
/***************************************************************************/
BOOL FAR PASCAL toolbarModifyState(HWND hwnd, int iButton, int iState)
{
	HANDLE		h;
	TOOLBUTTON far  *lpButton;
	int		cButtons, i;
	BOOL		fFound = FALSE;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return FALSE;

	/* How many buttons? */
	cButtons = GETNUMBUTTONS(hwnd);
	lpButton = (TOOLBUTTON far *)GlobalLock(h);

	/* Find that button, and change it's state */
	for (i = 0; i < cButtons; i++, lpButton++)
		if (lpButton->iButton == iButton) {
			if (lpButton->iState != iState) {
				lpButton->iState = iState;
				InvalidateRect(hwnd, &(lpButton->rc), FALSE);
			}
			fFound = TRUE;			// redraw now

			/* if we're pushing a radio button down, bring */
			/* all others in its group up */
			if (lpButton->iType >= BTNTYPE_RADIO &&
					iState == BTNST_DOWN)
			    toolbarExclusiveRadio(hwnd, lpButton->iType,
								iButton);
			break;
		}

	GlobalUnlock(h);
	return fFound;
}


/***************************************************************************/
/* toolbarModifyPrevState: Given a button on the toolbar, change it's prev-*/
/*                      ious state. Used for non-PUSH buttons to remember  */
/*                      what state a button was in before pressed all the  */
/*                      way down, so that when you let go, you know what   */
/*                      state to set it to (the opposite of what it was).  */
/*                      returns FALSE for an error (no button array)       */
/***************************************************************************/
BOOL FAR PASCAL toolbarModifyPrevState(HWND hwnd, int iButton, int iPrevState)
{
	HANDLE		h;
	TOOLBUTTON far  *lpButton;
	int		cButtons, i;

	/* Get button array */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return FALSE;

	/* How many buttons? */
	cButtons = GETNUMBUTTONS(hwnd);

	lpButton = (TOOLBUTTON far *)GlobalLock(h);

	/* Find the button, change the state */
	for (i = 0; i < cButtons; i++, lpButton++)
		if (lpButton->iButton == iButton) {
			lpButton->iPrevState = iPrevState;
			break;
		}

	GlobalUnlock(h);
	return TRUE;
}


/***************************************************************************/
/* toolbarModifyActivity: Given a button ID on the toolbar, change it's    */
/*                        activity.  This tells the app what just happened */
/*                        to the button (ie. KEYUP, MOUSEDBLCLK, etc.)     */
/*                        returns FALSE for an error or if no such button  */
/***************************************************************************/
BOOL FAR PASCAL toolbarModifyActivity(HWND hwnd, int iButton, int iActivity)
{
	HANDLE		h;
	TOOLBUTTON far  *lpButton;
	int		cButtons, i;

	/* Get the button array */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return FALSE;

	/* How many buttons */
	cButtons = GETNUMBUTTONS(hwnd);

	lpButton = (TOOLBUTTON far *)GlobalLock(h);

	/* loop through and change the right one */
	for (i = 0; i < cButtons; i++, lpButton++)
		if (lpButton->iButton == iButton) {
			lpButton->iActivity = iActivity;
			break;
		}

	GlobalUnlock(h);
	return TRUE;
}



/***************************************************************************/
/* toolbarFixFocus:  SETWHICH() has been called to tell us which button    */
/*                   has the focus, but the states of all the buttons are  */
/*                   not updated (ie. take focus away from the old button) */
/*                   This routine is called from the Paint routine to fix  */
/*                   the states of all the buttons before drawing them.    */
/*                   Returns FALSE for an error.                           */
/***************************************************************************/
BOOL FAR PASCAL toolbarFixFocus(HWND hwnd)
{
	int		iFocus;
	HANDLE		h;
	TOOLBUTTON	far *lpaButtons;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return FALSE;
	lpaButtons = (TOOLBUTTON far *)GlobalLock(h);

        /* if focus is on an illegal button, default to the first one */
	iFocus = GETWHICH(hwnd);
	if (iFocus < 0 || iFocus >= GETNUMBUTTONS(hwnd))
	    SETWHICH(hwnd, 0);

	/* First of all, make sure that the focus in not on a grayed button. */
	/* if so, we advance focus.  If it runs out of buttons without       */
	/* finding a non-gray one, we start back at the beginning and start  */
	/* looking for a non-gray one from there.  If every button is grayed,*/
	/* we leave no focus anywhere.					     */
	if (lpaButtons[GETWHICH(hwnd)].iState == BTNST_GRAYED) {
	    if (!toolbarMoveFocus(hwnd, FALSE)) {
		SETWHICH(hwnd, -1);
		toolbarMoveFocus(hwnd, FALSE);
	    }
	}

	GlobalUnlock(h);
	return TRUE;
}



/***************************************************************************/
/* toolbarExclusiveRadio:  For radio buttons, we need to pop all others    */
/*                         in the group up when one goes down.  Pass the   */
/*                         button that is going down, and its group, and   */
/*                         this routine will pop all others up.            */
/*                         Returns FALSE for an error.                     */
/***************************************************************************/
BOOL FAR PASCAL toolbarExclusiveRadio(HWND hwnd, int iType, int iButton)
{
	int		i;
	HANDLE		h;
	TOOLBUTTON	far *lpButton;

	/* Get the array of buttons */
	h = GETARRAYBUTT(hwnd);
	if (!h)
		return FALSE;
	lpButton = (TOOLBUTTON far *)GlobalLock(h);

	/* all buttons with this type that aren't this button come up	*/
	/* if they are not grayed					*/
	for(i = 0; i < GETNUMBUTTONS(hwnd); i++, lpButton++)
	    if (lpButton->iType == iType)
		if (lpButton->iButton != iButton &&
				lpButton->iState != BTNST_GRAYED) {
		    toolbarModifyState(hwnd, lpButton->iButton,	BTNST_UP);
		}

	GlobalUnlock(h);
	return TRUE;
}


/*	NotifyParent()  of activity to a button  */

static void NEAR PASCAL NotifyParent(HWND hwnd, int iButton)
{
#ifdef _WIN32
        PostMessage(
            GetParent(hwnd),
            WM_COMMAND,
            GET_WM_COMMAND_MPS(GetWindowLong(hwnd, GWL_ID), hwnd, iButton));
#else
	PostMessage(GetParent(hwnd),WM_COMMAND,
			GetWindowWord(hwnd,GWW_ID),MAKELONG(hwnd,iButton));
#endif
}


/***************************************************************************/
/* toolbarPaintControl:  Handles paint messages by blitting each bitmap    */
/*                       that is on the toolbar to its rect.               */
/*                       First, it fixes the states of the buttons to give */
/*                       the focus to the proper button.                   */
/*                       Returns FALSE for an error.                       */
/***************************************************************************/
static BOOL NEAR PASCAL toolbarPaintControl(HWND hwnd, HDC hdc)
{
    int		iBtnPos;	/* 0 to toolbarGetNumButtons inclusive	*/
    int		iButton;	/* 0 to NUMBUTTONS-1 inclusive		*/
    int		iState;		/* 0 to NUMSTATES-1 inclusive		*/
    HDC		hdcBtn;		/* DC onto button bitmap		*/

    RECT	rcDest;
    POINT	pt;
    long	l;
    HANDLE	hbm;

    /* Make a source HDC for the button pictures, and select the button */
    /* bitmap into it.							*/
    hdcBtn = CreateCompatibleDC(hdc);
    if (!hdcBtn)
	return FALSE;
    hbm = GETBMPHANDLE(hwnd);
    if (hbm) {
	if (!SelectObject(hdcBtn, GETBMPHANDLE(hwnd))) {
	    DeleteDC(hdcBtn);
	    return FALSE;
	}
    }

    toolbarFixFocus(hwnd);	// set the focus field correctly

    /* Go through all buttons on the toolbar */
    for (iBtnPos = 0; iBtnPos < toolbarGetNumButtons(hwnd); iBtnPos++) {

	iButton = toolbarButtonFromIndex(hwnd, iBtnPos);	// button
	iState = toolbarFullStateFromButton(hwnd, iButton);	// state
	toolbarRectFromIndex(hwnd, iBtnPos, &rcDest);		// Dest Rect
	
	/* If we have the focus, we should draw it that way */
        if (GetFocus() == hwnd && GETWHICH(hwnd) == iBtnPos
						&& iState == BTNST_UP)
	    iState = BTNST_FOCUSUP;
        if (GetFocus() == hwnd && GETWHICH(hwnd) == iBtnPos
						&& iState == BTNST_DOWN)
	    iState = BTNST_FOCUSDOWN;

	/* If we don't have the focus, we should take it away */
        if ((GetFocus() != hwnd || GETWHICH(hwnd) != iBtnPos)
						&& iState == BTNST_FOCUSUP)
	    iState = BTNST_UP;
        if ((GetFocus() != hwnd || GETWHICH(hwnd) == iBtnPos)
						&& iState == BTNST_FOCUSDOWN)
	    iState = BTNST_DOWN;

	/* The size of each button */
	l = GETBUTTONSIZE(hwnd);
	pt.x = HIWORD(l);
	pt.y = LOWORD(l);

	/* Blit from the button picture to the toolbar window */
	BitBlt(hdc, rcDest.left, rcDest.top,
	    rcDest.right - rcDest.left, rcDest.bottom - rcDest.top,
	    hdcBtn, pt.x * iButton, pt.y * iState,
	    SRCCOPY);
    }

    DeleteDC(hdcBtn);

    return TRUE;
}




/***************************************************************************/
/* toolbarMoveFocus:  Move Focus forward or backward one button.  You give */
/*                    it the direction to move the focus.  The routine will*/
/*                    stop at the end of the button list without wrapping  */
/*                    around.                                              */
/*                    Returns TRUE if focus moved, or FALSE if it ran out  */
/*                    of buttons before finding a non-grayed one.          */
/***************************************************************************/
BOOL FAR PASCAL toolbarMoveFocus(HWND hwnd, BOOL fBackward)
{
	int 	iBtnPos, iButton, nOffset, nStopAt;
	RECT	rc;
	int iPrevPos = GETWHICH(hwnd); 	/* Who used to have focus? */

	/* Fix illegal value.  It's OK to be one less or greater than range */
	if (iPrevPos < -1 || iPrevPos > GETNUMBUTTONS(hwnd))
	    SETWHICH(hwnd, 0);	// good a default as any

	if (fBackward) {
	    nOffset = -1;
	    nStopAt = -1;
	} else {
	    nOffset = 1;
	    nStopAt = GETNUMBUTTONS(hwnd);
	}
			
	/* look for next button that isn't grayed    */
	/* DON'T wrap around - future code will pass */
	/* the focus to another window (???)         */
	for (iBtnPos = GETWHICH(hwnd) + nOffset;
		    iBtnPos != nStopAt;
		    iBtnPos += nOffset) {
	    iButton = toolbarButtonFromIndex(hwnd, iBtnPos);
	    if (toolbarStateFromButton(hwnd, iButton) !=
				    BTNST_GRAYED) {
		SETWHICH(hwnd, iBtnPos);	// set focus

		/* Redraw both old and new focused button */
		toolbarRectFromIndex(hwnd, iPrevPos, &rc);
		InvalidateRect(hwnd, &rc, FALSE);
		toolbarRectFromIndex(hwnd, iBtnPos, &rc);
		InvalidateRect(hwnd, &rc, FALSE);
		break;

	    }
	}

	if (GETWHICH(hwnd) != iPrevPos)
	    return TRUE;
	else
	    return FALSE;
}

/***************************************************************************/
/* toolbarSetFocus :  Set the focus in the toolbar to the specified button.*/
/*                    If it's gray, it'll set focus to next ungrayed btn.  */
/*                    Returns TRUE if focus set, or FALSE if the button    */
/*                    doesn't exist or if it and all buttons after it were */
/*                    grayed...       You can use TB_FIRST or TB_LAST in   */
/*                    place of a button ID.  This uses the first or last   */
/*                    un-grayed button.                                    */
/***************************************************************************/
BOOL FAR PASCAL toolbarSetFocus(HWND hwnd, int iButton)
{
    int iBtnPos;
    RECT rc = {0};

    /* Don't move focus while a button is down */
    if (GetCapture() != hwnd && !GETKEYPRESSED(hwnd)) {

	/* redraw button with focus in case focus moves */
	toolbarRectFromIndex(hwnd, GETWHICH(hwnd), &rc);
	InvalidateRect(hwnd, &rc, FALSE);

	if (iButton == TB_FIRST) {
	    SETWHICH(hwnd, -1); // move forward to 1st button
	    return toolbarMoveFocus(hwnd, FALSE);
	} else if (iButton == TB_LAST) {
	    SETWHICH(hwnd, GETNUMBUTTONS(hwnd));
	    return toolbarMoveFocus(hwnd, TRUE);
	} else {
	    iBtnPos = toolbarIndexFromButton(hwnd, iButton);
	    if (iBtnPos != -1) {
		SETWHICH(hwnd, --iBtnPos);
		return toolbarMoveFocus(hwnd, FALSE);
	    } else
		return FALSE;
	}
	return TRUE;

    } else
	return FALSE;
}

//
//  LoadUIBitmap() - load a bitmap resource
//
//      load a bitmap resource from a resource file, converting all
//      the standard UI colors to the current user specifed ones.
//
//      this code is designed to load bitmaps used in "gray ui" or
//      "toolbar" code.
//
//      the bitmap must be a 4bpp windows 3.0 DIB, with the standard
//      VGA 16 colors.
//
//      the bitmap must be authored with the following colors
//
//          Button Text        Black        (index 0)
//          Button Face        lt gray      (index 7)
//          Button Shadow      gray         (index 8)
//          Button Highlight   white        (index 15)
//          Window Color       yellow       (index 11)
//          Window Frame       green        (index 10)
//
//      Example:
//
//          hbm = LoadUIBitmap(hInstance, "TestBmp",
//              GetSysColor(COLOR_BTNTEXT),
//              GetSysColor(COLOR_BTNFACE),
//              GetSysColor(COLOR_BTNSHADOW),
//              GetSysColor(COLOR_BTNHIGHLIGHT),
//              GetSysColor(COLOR_WINDOW),
//              GetSysColor(COLOR_WINDOWFRAME));
//
//      Author:     JimBov, ToddLa
//
//

HBITMAP FAR PASCAL  LoadUIBitmap(
    HANDLE      hInstance,          // EXE file to load resource from
    LPCSTR      szName,             // name of bitmap resource
    COLORREF    rgbText,            // color to use for "Button Text"
    COLORREF    rgbFace,            // color to use for "Button Face"
    COLORREF    rgbShadow,          // color to use for "Button Shadow"
    COLORREF    rgbHighlight,       // color to use for "Button Hilight"
    COLORREF    rgbWindow,          // color to use for "Window Color"
    COLORREF    rgbFrame)           // color to use for "Window Frame"
{
    LPBYTE              lpb;
    HBITMAP             hbm = NULL;
    LPBITMAPINFOHEADER  lpbi;
    HANDLE              h;
    HDC                 hdc;
    LPDWORD             lprgb;
    int isize;
    HANDLE hmem;
    LPBYTE lpCopy;

    // convert a RGB into a RGBQ
    #define RGBQ(dw) RGB(GetBValue(dw),GetGValue(dw),GetRValue(dw))

	if ( !(h = LoadResource (hInstance,FindResource(hInstance, szName, RT_BITMAP)) ) )
		return NULL;

    lpbi = (LPBITMAPINFOHEADER)LockResource(h);

    if (!lpbi)
        return(NULL);

    if (lpbi->biSize != sizeof(BITMAPINFOHEADER))
        return NULL;

    if (lpbi->biBitCount != 4)
        return NULL;

    /*
     * copy the resource since they are now loaded read-only
     */
#ifdef _WIN32
    isize = lpbi->biSize + lpbi->biSizeImage +
            ((int)lpbi->biClrUsed ?
                    (int)lpbi->biClrUsed :
                    (1 << (int)lpbi->biBitCount))
            * sizeof(RGBQUAD);
    hmem = GlobalAlloc(GHND, isize);
    lpCopy = GlobalLock(hmem);
    if ((hmem == NULL) || (lpCopy == NULL)) {
        UnlockResource(h);
        FreeResource(h);
        return(NULL);
    }

    CopyMemory(lpCopy, lpbi, isize);

    lpbi = (LPBITMAPINFOHEADER)lpCopy;
#endif

    /* Calcluate the pointer to the Bits information */
    /* First skip over the header structure */

    lprgb = (LPDWORD)((LPBYTE)(lpbi) + lpbi->biSize);

    /* Skip the color table entries, if any */
    lpb = (LPBYTE)lprgb + ((int)lpbi->biClrUsed ? (int)lpbi->biClrUsed :
        (1 << (int)lpbi->biBitCount)) * sizeof(RGBQUAD);

    lprgb[0]  = RGBQ(rgbText);          // Black
    lprgb[7]  = RGBQ(rgbFace);          // lt gray
    lprgb[8]  = RGBQ(rgbShadow);        // gray
    lprgb[15] = RGBQ(rgbHighlight);     // white
    lprgb[11] = RGBQ(rgbWindow);        // yellow
    lprgb[10] = RGBQ(rgbFrame);         // green

    if ( hdc = GetDC(NULL) )
	{
		hbm = CreateDIBitmap (hdc, lpbi, CBM_INIT, (LPVOID)lpb,
			(LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

		ReleaseDC(NULL, hdc);
	}

    UnlockResource(h);
    FreeResource(h);

    return(hbm);
}

/****************************************************************************
	toolbarWndProc()

	Window proc for toolbar.

	Arguments:
		Standard window proc
****************************************************************************/

LRESULT FAR PASCAL toolbarWndProc(HWND hwnd, unsigned message,
						WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT	ps;
    POINT		pt;
    RECT		rc;
    int			iBtnPos, iButton, ibmp;
    HANDLE		lpaButtons, hbm, hInst;

    switch (message) {

        case WM_CREATE:			// do all initialization
		
		/* What do these do? */
		SetWindowPos(hwnd, NULL, 0, 0, 0, 0,
		    			SWP_NOZORDER | SWP_NOSIZE |
					SWP_NOMOVE | SWP_NOACTIVATE);
		SetWindowLong(hwnd,GWL_STYLE,lpCreate->style & 0xFFFF00FF);
		
		/* Alloc some space for the array of buttons on this bar */
		lpaButtons = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE,
					TOOLGROW * sizeof(TOOLBUTTON));

		SETARRAYBUTT(hwnd, lpaButtons);	// list of buttons on toolbar
		SETNUMBUTTONS(hwnd, 0);		// # buttons in toolbar
		SETPRESSED(hwnd, FALSE);	// mouse button being pressed?
		SETKEYPRESSED(hwnd, FALSE);	// is a key being pressed?
		SETWHICH(hwnd, -1);		// which button has the focus?
		SETSHIFTED(hwnd, FALSE);	// shift-click or right-click?

		/* This wParam will be sent to the parent window to indentify */
		/* that the toolbar sent the WM_COMMAND msg.  The hwnd of the */
		/* toolbar that sent the msg will be in the lParam.	      */
#ifdef _WIN32
		SetWindowLong(hwnd, GWL_ID, IDC_TOOLBAR);
#else
		SetWindowWord(hwnd, GWW_ID, (WORD)IDC_TOOLBAR);
#endif

		/* later on, someone will set the bmp handle of the buttons */
		SETBMPHANDLE(hwnd, NULL);

		break;

        case WM_LBUTTONDOWN:	// button goes down on a toolbar button
        case WM_RBUTTONDOWN:
        case WM_LBUTTONDBLCLK:
        case WM_RBUTTONDBLCLK:

		/* If we don't give ourself focus, we'll never get KEYDOWN */
		/* or KEYUP messages.					   */
		/* Get the focus only if we're a TABSTOP and the app wants */
		/* us to take focus.					   */
		if ( (GetWindowLong(hwnd, GWL_STYLE) & WS_TABSTOP)
						&& GetFocus() != hwnd)
		    SetFocus(hwnd);

		/* ignore messages if window is disabled */
		if (!IsWindowEnabled(hwnd))
		    return 0L;

		/* ignore multiple down messages (we set Capture here) */
		/* also ignore if a key is down                        */
		if (GetCapture() == hwnd || GETPRESSED(hwnd))
		    return 0L;
		
		/* Where did the mouse go down? */
                pt.x = (short)LOWORD(lParam);
                pt.y = (short)HIWORD(lParam);

		/* which button was pressed? */
		iBtnPos = toolbarIndexFromPoint(hwnd, pt);

		/* If it was a valid button... */
		if (iBtnPos >= 0) {
		    int		iOldPos;
		    int		iState, iType, iButton;

		    /* Everything you wanted to know about this button */
		    iType = toolbarTypeFromIndex(hwnd, iBtnPos);
		    iButton = toolbarButtonFromIndex(hwnd, iBtnPos);
		    iState = toolbarFullStateFromButton(hwnd, iButton);

		    /* ignore downs on a grayed button, unless it's a	*/
		    /* custom button, then tell them anyway		*/
		    if (iType != BTNTYPE_CUSTOM && iState == BTNST_GRAYED)
			return 0;

		    /* We better get all mouse messages from now on */
		    SetCapture(hwnd);

		    /* Shift key or right button indicates a SHIFT down */
		    SETSHIFTED(hwnd, (message == WM_RBUTTONDOWN) ||
						    (wParam & MK_SHIFT));

		    /* Yes, we've pressed the button down */
		    SETPRESSED(hwnd, TRUE);

		    /* Remember who used to have the focus, and we get it now */
		    iOldPos = GETWHICH(hwnd);
		    SETWHICH(hwnd, iBtnPos);

		    /* For a push button, send it down */
		    if (iType == BTNTYPE_PUSH)
			toolbarModifyState(hwnd, iButton, BTNST_DOWN);

		    /* for a checkbox or radio button (of any group),       */
		    /* remember what state it was in, and send it FULL down */
		    /* (with focus).					    */
		    if (iType == BTNTYPE_CHECKBOX || iType >= BTNTYPE_RADIO) {
			toolbarModifyPrevState(hwnd, iButton, iState);
			toolbarModifyState(hwnd,iButton,BTNST_FULLDOWN);
		    }

		    toolbarModifyActivity(hwnd, iButton, BTNACT_MOUSEDOWN);

		    /* Set Double click flag appropriately */
		    if (message == WM_LBUTTONDBLCLK ||
						message == WM_RBUTTONDBLCLK)
			NotifyParent(hwnd, (GETSHIFTED(hwnd) ? BTN_SHIFT : 0)
						 + BTN_DBLCLICK + iButton);
		    else
			NotifyParent(hwnd, (GETSHIFTED(hwnd) ? BTN_SHIFT : 0)
						 + iButton);

		    /* Invalidate the Rect of the button being pressed */
		    toolbarRectFromIndex(hwnd, iBtnPos, &rc);
		    InvalidateRect(hwnd, &rc, FALSE);

		    /* Invalidate the Rect of the button losing focus */
		    toolbarRectFromIndex(hwnd, iOldPos, &rc);
		    InvalidateRect(hwnd, &rc, FALSE);

		    /* Force re-paint now */
		    UpdateWindow(hwnd);

		    /* Set a timer for repeated mouse downs */
		    SetTimer(hwnd, TIMER_BUTTONREPEAT,
				 MSEC_BUTTONREPEAT, NULL);
		}
		
		return 0L;

        case WM_MOUSEMOVE:

#if 0
		/* This should be impossible - it means that the system lost */
		/* a mouse up (maybe codeview is up?) We need to force a     */
		/* mouse up at this point.				     */
		if (GetCapture() == hwnd &&
			(wParam & (MK_LBUTTON | MK_RBUTTON) == 0))
		    SendMessage(hwnd, WM_LBUTTONUP, 0, lParam);
#endif

		/* Mouse moving while pressing a button?  If not, ignore. */
		if (GetCapture() == hwnd) {
		    int		iPrevState, iState, iButton, iType;
		    BOOL	fPressed;
		
		    /* Which button is being pressed down? */
		    iBtnPos = GETWHICH(hwnd);

		    /* Where is mouse cursor now? */
                    pt.x = (short)LOWORD(lParam);
                    pt.y = (short)HIWORD(lParam);

		    /* where is button being pressed? Are we still on */
		    /* top of that button or have we moved?	      */
		    toolbarRectFromIndex(hwnd, iBtnPos, &rc);
		    fPressed = PtInRect(&rc, pt);

		    /* Let go if we move off of the button, but don't */
		    /* act like it was pressed.                       */
		    /* Also, push it back down if we move back on top */
		    /* of it (while the mouse button is STILL down).  */
		    if (fPressed != GETPRESSED(hwnd)) {

			/* update: is this button pressed anymore? */
			SETPRESSED(hwnd, fPressed);

			iType = toolbarTypeFromIndex(hwnd, iBtnPos);
			iButton = toolbarButtonFromIndex(hwnd, iBtnPos);
			iState = toolbarFullStateFromButton(hwnd, iButton);

			/* The mouse moved back onto the button while */
			/* the mouse button was still pressed.	      */
			if (fPressed) {

			    /* Push the push button back down again */
	 		    if (iType == BTNTYPE_PUSH)
				toolbarModifyState(hwnd, iButton,
							BTNST_DOWN);

			    /* Push the radio or checkbox button ALL the */
			    /* way down again.				 */
			    if (iType >= BTNTYPE_RADIO ||
						iType == BTNTYPE_CHECKBOX)
				toolbarModifyState(hwnd, iButton,
							BTNST_FULLDOWN);

			    toolbarModifyActivity(hwnd, iButton,
							BTNACT_MOUSEMOVEON);
			    NotifyParent(hwnd,
					(GETSHIFTED(hwnd) ? BTN_SHIFT : 0) +
					iButton);

			/* We moved the mouse off of the toolbar button */
			/* while still holding the mouse button down.   */
			} else {

			    /* lift the push button up */
	 		    if (iType == BTNTYPE_PUSH)
				toolbarModifyState(hwnd, iButton,
							BTNST_UP);

			    /* Restore radio button or checkbox button to */
			    /* where it was before pressed		  */
			    if (iType >= BTNTYPE_RADIO ||
						iType == BTNTYPE_CHECKBOX) {
				iPrevState = toolbarPrevStateFromButton(hwnd,
							iButton);
				toolbarModifyState(hwnd, iButton, iPrevState);
			    }

			    toolbarModifyActivity(hwnd, iButton,
							BTNACT_MOUSEMOVEOFF);
			    NotifyParent(hwnd,
					(GETSHIFTED(hwnd) ? BTN_SHIFT : 0) +
					toolbarButtonFromIndex(hwnd, iBtnPos));
			}
		    }
		}
		return 0L;

        case WM_LBUTTONUP:	
        case WM_RBUTTONUP:

		/* If we don't have capture, we aren't expecting this. Ignore */
		if (GetCapture() == hwnd) {
		    int		iPrevState, iState, iButton, iType;
		
		    /* Who has the focus? */
		    iBtnPos = GETWHICH(hwnd);

		    /* Release the mouse */
		    ReleaseCapture();
		
		    /* No more repeats of the mouse button downs */
		    KillTimer(hwnd, TIMER_BUTTONREPEAT);
		
		    /* Everything you wanted to know about the button */
		    toolbarRectFromIndex(hwnd, iBtnPos, &rc);
		    iType = toolbarTypeFromIndex(hwnd, iBtnPos);
		    iButton = toolbarButtonFromIndex(hwnd, iBtnPos);
		    iState = toolbarFullStateFromButton(hwnd, iButton);

		    /* Don't do anything if we've moved off the button */
		    if (GETPRESSED(hwnd)) {

			/* No longer down */
			SETPRESSED(hwnd, FALSE);

			/* Bring the push button up */
			if (iType == BTNTYPE_PUSH)
			    toolbarModifyState(hwnd, iButton, BTNST_UP);

			/* Bring the checkbox to the opposite state it was in */
			if (iType == BTNTYPE_CHECKBOX) {
			    iPrevState = toolbarPrevStateFromButton(hwnd,
							iButton);
			    if (iPrevState == BTNST_DOWN)
				toolbarModifyState(hwnd, iButton, BTNST_UP);
			    if (iPrevState == BTNST_UP)
				toolbarModifyState(hwnd, iButton, BTNST_DOWN);
			}

			/* Force a radio button down, and bring all   */
			/* other radio buttons of this type up	      */
			if (iType >= BTNTYPE_RADIO) {
			    toolbarModifyState(hwnd, iButton, BTNST_DOWN);
			    toolbarExclusiveRadio(hwnd, iType, iButton);
			}

			/* Notify the parent that the mouse button came up */
			/* on this button so the app can do something.     */
			/* Every button should notify the app, not just a  */
			/* custom button.				   */
			toolbarModifyActivity(hwnd, iButton, BTNACT_MOUSEUP);
			NotifyParent(hwnd,
			    (GETSHIFTED(hwnd) ? BTN_SHIFT : 0) + iButton);
		    }
		}

		return 0L;

		
	case WM_TIMER:

		/* If we have a tool button down, send a repeat message */
		if (GETPRESSED(hwnd)) {
		    int		iButton, iType;

		    iBtnPos = GETWHICH(hwnd);
		    iButton = toolbarButtonFromIndex(hwnd, iBtnPos);
		    iType = toolbarTypeFromIndex(hwnd, iBtnPos);

		    NotifyParent(hwnd, BTN_REPEAT +
					(GETSHIFTED(hwnd) ? BTN_SHIFT : 0) +
					toolbarButtonFromIndex(hwnd, iBtnPos));
		}
		break;
		

        case WM_DESTROY:
		if (GETBMPHANDLE(hwnd))
		    DeleteObject(GETBMPHANDLE(hwnd));
		SETBMPHANDLE(hwnd, NULL);
		if (GETARRAYBUTT(hwnd))
		    GlobalFree(GETARRAYBUTT(hwnd));
		SETARRAYBUTT(hwnd, NULL);
		break;

        case WM_SETTEXT:
		break;
		
/* MANY, MANY cases deleted */

	case WM_SETFOCUS:		// focus comes to toolbar window
	    {
		/* Remember who had the focus and give it back.  Of course, */
		/* if by some wierdness that button is now grayed, give it  */
		/* to the next person in line.				    */
		iBtnPos = GETWHICH(hwnd);
		if (iBtnPos < 0 || iBtnPos >= toolbarGetNumButtons(hwnd)) {
		    iBtnPos = 0;
		    SETWHICH(hwnd, 0);
		}

		do {
		    iButton = toolbarButtonFromIndex(hwnd, iBtnPos);
		    if (toolbarFullStateFromButton(hwnd, iButton)
							!= BTNST_GRAYED)
			break;			// give it here
		    iBtnPos++;
		    if (iBtnPos >= toolbarGetNumButtons(hwnd))
			iBtnPos = 0;		// wrap around
		    if (iBtnPos == GETWHICH(hwnd))
			return 0L;		// uh-oh! They're all gray!
		} while (iBtnPos != GETWHICH(hwnd));
			
		SETWHICH(hwnd, iBtnPos);	// give focus here
		
		/* And redraw! */
		toolbarRectFromIndex(hwnd, iBtnPos, &rc);
		InvalidateRect(hwnd, &rc, FALSE);
		UpdateWindow(hwnd);
		return 0;
	    }
	
	case WM_KILLFOCUS:

		/* Send a KEYUP if one is pending */
		if (GETKEYPRESSED(hwnd))
		    SendMessage(hwnd, WM_KEYUP, VK_SPACE, 0L);

		/* Redraw the focused button, because now that focus is gone */
		/* from our toolbar window, the focused button won't be      */
		/* focused anymore, although we remember which one it was.   */
		toolbarRectFromIndex(hwnd, GETWHICH(hwnd), &rc);
		InvalidateRect(hwnd, &rc, FALSE);
		UpdateWindow(hwnd);
		return 0;

	case WM_SYSKEYDOWN:
		/* Send a KEYUP if one is pending */
		if (GETKEYPRESSED(hwnd))
		    SendMessage(hwnd, WM_KEYUP, VK_SPACE, 0L);
		break;	// MUST LET DEFWNDPROC RUN!!! (to handle the key)

        case WM_GETDLGCODE:
		return DLGC_WANTARROWS | DLGC_WANTTAB;

	case WM_KEYDOWN:

		/* Window disabled or a key is already down */
		if (IsWindowEnabled(hwnd) && !GETPRESSED(hwnd)) {

		    /* Tab forward to next button and move focus there */
		    if (wParam == VK_TAB && GetKeyState(VK_SHIFT) >= 0 ) {

			/* Move Focus forward one.  If */
			/* we've tabbed off of the toolbar, it's time */
			/* to go on to the next control. We need to invldte */
			/* because we might be the only control and we need */
			/* to repaint to show the new button with highlight */
			/* after it wrapped around the end of the toolbar.  */
			if (!toolbarMoveFocus(hwnd, FALSE)) {
			    PostMessage(GetParent(hwnd), WM_NEXTDLGCTL, 0, 0L);
			    toolbarRectFromIndex(hwnd, GETWHICH(hwnd), &rc);
			    InvalidateRect(hwnd, &rc, FALSE);
			}

			return 0L;
		    }
		    if (wParam == VK_TAB && GetKeyState(VK_SHIFT) < 0 ) {

			/* Move focus backward one.  If */
			/* We've tabbed off of the toolbar, it's time    */
			/* to go on to the next control. We need to invldte */
			/* because we might be the only control and we need */
			/* to repaint to show the new button with highlight */
			/* after it wrapped around the end of the toolbar.  */
			if (!toolbarMoveFocus(hwnd, TRUE)) {
			    PostMessage(GetParent(hwnd), WM_NEXTDLGCTL, 1, 0L);
			    toolbarRectFromIndex(hwnd, GETWHICH(hwnd), &rc);
			    InvalidateRect(hwnd, &rc, FALSE);
			}

			return 0L;
		    }
		    if ((wParam == VK_SPACE) && (GetCapture() != hwnd)) {

			int	iButton, iType, iState;

			/* Same as mouse button down -- Press the button! */
			iBtnPos = GETWHICH(hwnd);
			iType = toolbarTypeFromIndex(hwnd, iBtnPos);
			iButton = toolbarButtonFromIndex(hwnd, iBtnPos);
			iState = toolbarFullStateFromButton(hwnd, iButton);

			/* ignore multiple key downs */
			if (!GETKEYPRESSED(hwnd)) {

			    SETKEYPRESSED(hwnd, TRUE);	// a key is pressed

			    SETSHIFTED(hwnd, FALSE);	// NEVER shifted
			    SETPRESSED(hwnd, TRUE);	// a button is pressed

			    /* Push button goes down - with focus */
			    if (iType == BTNTYPE_PUSH)
				toolbarModifyState(hwnd, iButton, BTNST_DOWN);

			    /* Radio or checkbox button goes full down */
			    /* with focus - and remember previous state*/
			    if (iType >= BTNTYPE_RADIO ||
						iType == BTNTYPE_CHECKBOX) {
				toolbarModifyPrevState(hwnd, iButton, iState);
				toolbarModifyState(hwnd, iButton,
							BTNST_FULLDOWN);
			    }

			    toolbarModifyActivity(hwnd, iButton,
								BTNACT_KEYDOWN);
			    NotifyParent(hwnd, (GETSHIFTED(hwnd)
						? BTN_SHIFT : 0) + iButton);

			    return 0L;
			}
		
			/* If this is another KEYDOWN msg, it's a REPEAT */
			/* Notify parent.                                */
			NotifyParent(hwnd, BTN_REPEAT +
					(GETSHIFTED(hwnd) ? BTN_SHIFT : 0) +
					toolbarButtonFromIndex(hwnd,
							GETWHICH(hwnd)));
		    }
		}
		break;
	
	case WM_KEYUP:

		/* A button was pressed and should come up now */
		if ((wParam == VK_SPACE) && (GETKEYPRESSED(hwnd))) {
		    int		iButton, iState, iType, iPrevState;

		    iBtnPos = GETWHICH(hwnd);		// which button?
		    SETKEYPRESSED(hwnd, FALSE);		// let go
		    SETPRESSED(hwnd, FALSE);

		    /* Everything about this button */
		    toolbarRectFromIndex(hwnd, iBtnPos, &rc);
		    iType = toolbarTypeFromIndex(hwnd, iBtnPos);
		    iButton = toolbarButtonFromIndex(hwnd, iBtnPos);
		    iState = toolbarFullStateFromButton(hwnd, iButton);

		    /* Bring a push button up */
		    if (iType == BTNTYPE_PUSH)
			toolbarModifyState(hwnd, iButton, BTNST_UP);

		    /* Bring a checkbox to the opposite state it was in */
		    if (iType == BTNTYPE_CHECKBOX) {
			iPrevState = toolbarPrevStateFromButton(hwnd, iButton);
			if (iPrevState == BTNST_DOWN)
			    toolbarModifyState(hwnd, iButton, BTNST_UP);
			if (iPrevState == BTNST_UP)
			    toolbarModifyState(hwnd, iButton, BTNST_DOWN);
		    }

		    /* Bring a radio button down, and bring all others in */
		    /* its group up.					  */
		    if (iType >= BTNTYPE_RADIO) {
			toolbarModifyState(hwnd, iButton, BTNST_DOWN);
			toolbarExclusiveRadio(hwnd, iType, iButton);
		    }

		    toolbarModifyActivity(hwnd, iButton, BTNACT_KEYUP);
		    NotifyParent(hwnd, toolbarButtonFromIndex(hwnd,
					(GETSHIFTED(hwnd) ? BTN_SHIFT : 0) +
					GETWHICH(hwnd)));
		}
		break;
	
	case WM_SYSCOLORCHANGE:
		/* load the bitmap of what all the buttons look like */
		/* and change the colours to the system colours.     */
		hInst = GETHINST(hwnd);
		ibmp = GETBMPINT(hwnd);
		hbm = GETBMPHANDLE(hwnd);
		if (hbm)
		    DeleteObject(hbm);
		hbm = LoadUIBitmap(hInst, MAKEINTRESOURCE(ibmp),
		    GetSysColor(COLOR_BTNTEXT),
		    GetSysColor(COLOR_BTNFACE),
		    GetSysColor(COLOR_BTNSHADOW),
		    GetSysColor(COLOR_BTNHIGHLIGHT),
		    GetSysColor(COLOR_BTNFACE),
		    GetSysColor(COLOR_WINDOWFRAME));
		SETBMPHANDLE(hwnd, hbm);
#ifdef _WIN32
		return (LONG_PTR) hbm;
#else
		return MAKELONG(hbm, 0);
#endif

        case WM_ERASEBKGND:
		break;


        case WM_PAINT:

		/* Call our paint code */
		BeginPaint(hwnd, &ps);
		toolbarPaintControl(hwnd, ps.hdc);
		EndPaint(hwnd, &ps);

		return 0L;
    }

    return DefWindowProc(hwnd, message, wParam, lParam);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\vidcap32\vidcap.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/
/****************************************************************************
 *
 *   vidcap.h: Main application include file
 *
 *   Vidcap32 Source code
 *
 ***************************************************************************/

#include "dialogs.h"

#define USE_ACM	1	        // Use ACM dialogs for audio format selection

//
// General purpose constants...
//
#define MAXVIDDRIVERS            10

#define DEF_CAPTURE_FPS          15
#define MIN_CAPTURE_FPS          (1.0 / 60)     // one frame per minute
#define MAX_CAPTURE_FPS          100

#define FPS_TO_MS(f)             ((DWORD) ((double)1.0e6 / f))

#define DEF_CAPTURE_RATE         FPS_TO_MS(DEF_CAPTURE_FPS)
#define MIN_CAPTURE_RATE         FPS_TO_MS(MIN_CAPTURE_FPS)
#define MAX_CAPTURE_RATE         FPS_TO_MS(MAX_CAPTURE_FPS)


#define DEF_PALNUMFRAMES         10
#define DEF_PALNUMCOLORS         236L
#define ONEMEG                   (1024L * 1024L)

//standard index size options
#define CAP_LARGE_INDEX          (30 * 60 * 60 * 3)     // 3 hrs @ 30fps
#define CAP_SMALL_INDEX          (30 * 60 * 15)         // 15 minutes @ 30fps


//
// Menu Ids...must not conflict with string table ids
// these are also the id of help strings in the string table
// (along with all the SC_ system menu items).
// menu popups must start 10 apart and be numbered in the same order
// as they appear if the help text is to work correctly for the
// popup heads as well as for the menu items.
//
#define IDM_SYSMENU               100

#define IDM_FILE                  200
#define IDM_F_SETCAPTUREFILE      201
#define IDM_F_SAVEVIDEOAS         202
#define IDM_F_ALLOCATESPACE       203
#define IDM_F_EXIT                204
#define IDM_F_LOADPALETTE         205
#define IDM_F_SAVEPALETTE         206
#define IDM_F_SAVEFRAME           207
#define IDM_F_EDITVIDEO           208


#define IDM_EDIT                  300
#define IDM_E_COPY                301
#define IDM_E_PASTEPALETTE        302
#define IDM_E_PREFS               303

#define IDM_CAPTURE               400
#define IDM_C_CAPTUREVIDEO        401
#define IDM_C_CAPTUREFRAME        402
#define IDM_C_PALETTE             403
#define IDM_C_CAPSEL              404
#define IDM_C_TEST                405
#define IDM_C_TESTAGAIN           406

#define IDM_OPTIONS               500
#define IDM_O_PREVIEW             501
#define IDM_O_OVERLAY             502
#define IDM_O_AUDIOFORMAT         503
#define IDM_O_VIDEOFORMAT         504
#define IDM_O_VIDEOSOURCE         505
#define IDM_O_VIDEODISPLAY        506
#define IDM_O_CHOOSECOMPRESSOR    507

#define IDM_O_DRIVER0             520
#define IDM_O_DRIVER1             521
#define IDM_O_DRIVER2             522
#define IDM_O_DRIVER3             523
#define IDM_O_DRIVER4             524
#define IDM_O_DRIVER5             525
#define IDM_O_DRIVER6             526
#define IDM_O_DRIVER7             527
#define IDM_O_DRIVER8             528
#define IDM_O_DRIVER9             529

#define IDM_HELP                  600
#define IDM_H_CONTENTS            601
#define IDM_H_ABOUT               602


// filter rcdata ids
#define ID_FILTER_AVI           900
#define ID_FILTER_PALETTE       901
#define ID_FILTER_DIB           902


/*
 * string table id
 *
 * NOTE: string table ID's must not conflict with IDM_ menu ids,
 * as there is a help string for each menu id.
 */


#define IDS_APP_TITLE            1001

#define IDS_ERR_REGISTER_CLASS   1002
#define IDS_ERR_CREATE_WINDOW    1003
#define IDS_ERR_FIND_HARDWARE    1004
#define IDS_ERR_CANT_PREALLOC    1005
#define IDS_ERR_MEASUREFREEDISK  1006
#define IDS_ERR_SIZECAPFILE      1007
#define IDS_ERR_RECONNECTDRIVER  1008
#define IDS_ERR_CMDLINE          1009
#define IDS_WARN_DEFAULT_PALETTE 1010

#define IDS_TITLE_SETCAPTUREFILE 1101
#define IDS_TITLE_SAVEAS         1102
#define IDS_TITLE_LOADPALETTE    1104
#define IDS_TITLE_SAVEPALETTE    1105
#define IDS_TITLE_SAVEDIB        1106
#define IDS_PROMPT_CAPFRAMES     1107
#define IDS_STATUS_NUMFRAMES     1108
#define IDS_CAP_CLOSE            1109
#define IDS_MCI_CONTROL_ERROR    1110
#define IDS_ERR_ACCESS_SOUNDDRIVER 1111
#define IDS_ERR_VIDEDIT          1112

#define IDC_toolbarSETFILE      1220
#define IDC_toolbarCAPFRAME     1221
#define IDC_toolbarCAPSEL       1222
#define IDC_toolbarCAPAVI       1223
#define IDC_toolbarCAPPAL       1224
#define IDC_toolbarLIVE         1225
#define IDC_toolbarEDITCAP      1226
#define IDC_toolbarOVERLAY      1227

#define IDS_CAPPAL_CLOSE        1230
#define IDS_CAPPAL_STATUS       1231
#define IDS_CAPPAL_STOP         1232
#define IDS_CAPPAL_START        1233

#define	IDS_CAP_RTL             1234

#define IDBMP_TOOLBAR		100	// main toolbar


//
// Macro Definitions...
//
#define IsDriverIndex(w) ( ((w) >= IDM_O_DRIVERS)  &&  \
                           ((w) - IDM_O_DRIVERS < MAXVIDDRIVERS) )

#define RECTWIDTH(rc)  ((rc).right - (rc).left)
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)


//
// Global Variables...
//

// preferences
extern BOOL gbCentre;
extern BOOL gbToolBar;
extern BOOL gbStatusBar;
extern BOOL gbAutoSizeFrame;
extern int gBackColour;
extern BOOL gfIsRTL;

extern TCHAR           gachAppName[] ;
extern TCHAR           gachAppTitle[];
extern TCHAR           gachIconName[] ;
extern TCHAR           gachMenuName[] ;
extern TCHAR           gachString[] ;
extern TCHAR           gachMCIDeviceName[] ;

extern HINSTANCE      ghInstApp ;
extern HWND           ghWndMain ;
extern HWND           ghWndCap ;
extern HWND           ghWndFrame;
extern HANDLE         ghAccel ;
extern WORD           gwDeviceIndex ;
extern WORD           gwPalFrames ;
extern WORD           gwPalColors ;
extern WORD           gwCapFileSize ;
extern BOOL           gbLive ;

extern CAPSTATUS      gCapStatus ;
extern CAPDRIVERCAPS  gCapDriverCaps ;
extern CAPTUREPARMS   gCapParms ;

extern HANDLE         ghwfex ;
extern LPWAVEFORMATEX glpwfex ;

//
// Dialog Box Procedures...
//
LRESULT FAR PASCAL AboutProc(HWND, UINT, WPARAM, LPARAM) ;
LRESULT FAR PASCAL AudioFormatProc(HWND, UINT, WPARAM, LPARAM) ;
LRESULT FAR PASCAL CapSetUpProc(HWND, UINT, WPARAM, LPARAM) ;
LRESULT CALLBACK MakePaletteProc(HWND, UINT, WPARAM, LPARAM) ;
LRESULT FAR PASCAL AllocCapFileProc(HWND, UINT, WPARAM, LPARAM) ;
LRESULT FAR PASCAL PrefsDlgProc(HWND, UINT, WPARAM, LPARAM);
LRESULT FAR PASCAL NoHardwareDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT FAR PASCAL CapFramesProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam);

// utility functions (in vidcap.c)
/*
 * put up a message box. the main window ghWndMain is used as the parent
 * window, and the app title gachAppTitle is used as the dialog title.
 * the text for the dialog -idString- is loaded from the resource string table
 */
int MessageBoxID(UINT idString, UINT fuStyle);
LPSTR tmpString(UINT idString);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\vidcap32\vidframe.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/
/****************************************************************************
 *
 *   vidframe.h: Frame for capture window
 *
 *   Vidcap32 Source code
 *
 ***************************************************************************/

/*
 * interface to vidframe window class - this window class creates a child
 * AVICAP window, and is responsible for positioning it within the vidframe
 * window, framing it, and scrolling it if it will not fit. Call
 * vidframeCreate to create the window, and vidframeLayout if the
 * video image size might have changed.
 */



/*
 * create a frame window and child capture window at the
 * given location. Initialise the class if this is the
 * first time through.
 *
 * returns the window handle of the frame window
 * (or NULL if failure). returns the window handle of the AVICAP window
 * via phwndCap.
 */
HWND vidframeCreate(
    HWND hwndParent,
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    int x,
    int y,
    int cx,
    int cy,
    HWND FAR * phwndCap
);


/*
 * layout the window  - decide if we need scrollbars or
 * not, and position the avicap window correctly
 *
 * called if the size of the vidframe window changes or can be
 * called externally whenever the video size might have changed.
 */
void vidframeLayout(HWND hwndFrame, HWND hwndCap);

/*
 * change the background fill brush to be one of-
 *  IDD_PrefsDefBackground  - windows default background colour
 *  IDD_PrefsLtGrey - light grey
 *  IDD_PrefsDkGrey - dark grey
 *  IDD_PrefsBlack - black
 */
void vidframeSetBrush(HWND hwnd, int iPref);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\vidcap32\vidframe.c ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
 *
 **************************************************************************/
/****************************************************************************
 *
 *   vidframe.c: Frame for the capture window
 *
 *   Vidcap32 Source code
 *
 ***************************************************************************/

/*
 * Window class that provides a frame for the AVICAP window in the
 * VidCap capture tool. Responsible for positioning within the
 * parent window, handling scrolling and painting a size border if
 * there is room.
 */

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <vfw.h>
#include "vidcap.h"

#include "vidframe.h"

/*
 * pixels to move when asked to scroll one line or page
 */
#define LINE_SCROLL	10
#define PAGE_SCROLL	50

// class name
#define VIDFRAMECLASSNAME   "vidframeClass"


/*
 * standard brushes
 */
static HBRUSH ghbrBackground = NULL, ghbrFace, ghbrHighlight, ghbrShadow;
static BOOL   fhbrBackgroundIsSysObj;


/*
 * create brushes to be used in painting
 */
void
vidframeCreateTools(HWND hwnd)
{

    vidframeSetBrush(hwnd, gBackColour);

    ghbrHighlight  = CreateSolidBrush(GetSysColor(COLOR_BTNHIGHLIGHT));
    ghbrShadow  = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW));
    ghbrFace  = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
}

void
vidframeDeleteTools(void)
{
    if (ghbrBackground) {
        if (!fhbrBackgroundIsSysObj) {
            DeleteObject(ghbrBackground);
            ghbrBackground = NULL;
        }
    }

    if (ghbrHighlight) {
        DeleteObject(ghbrHighlight);
        ghbrHighlight = NULL;
    }

    if (ghbrShadow) {
        DeleteObject(ghbrShadow);
        ghbrShadow = NULL;
    }

    if (ghbrFace) {
        DeleteObject(ghbrFace);
        ghbrFace = NULL;
    }
}


/*
 * change the background fill brush to be one of-
 *  IDD_PrefsDefBackground  - windows default background colour
 *  IDD_PrefsLtGrey - light grey
 *  IDD_PrefsDkGrey - dark grey
 *  IDD_PrefsBlack - black
 */
void
vidframeSetBrush(HWND hwnd, int iPref)
{
    if (ghbrBackground != NULL) {
        if (!fhbrBackgroundIsSysObj) {
            DeleteObject(ghbrBackground);
            ghbrBackground = NULL;
        }
    }

    switch(iPref) {
    case IDD_PrefsDefBackground:
        ghbrBackground = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
        fhbrBackgroundIsSysObj = FALSE;
        break;

    case IDD_PrefsLtGrey:
        ghbrBackground = GetStockObject(LTGRAY_BRUSH);
        fhbrBackgroundIsSysObj = TRUE;
        break;

    case IDD_PrefsDkGrey:
        ghbrBackground = GetStockObject(DKGRAY_BRUSH);
        fhbrBackgroundIsSysObj = TRUE;
        break;

    case IDD_PrefsBlack:
        ghbrBackground = GetStockObject(BLACK_BRUSH);
        fhbrBackgroundIsSysObj = TRUE;
        break;

    default:
        return;
    }

    if (hwnd != NULL) {
#ifdef _WIN32
        SetClassLongPtr(hwnd, GCLP_HBRBACKGROUND, (LONG_PTR) ghbrBackground);
#else
        SetClassWord(hwnd, GCW_HBRBACKGROUND, (WORD) ghbrBackground);
#endif
        InvalidateRect(hwnd, NULL, TRUE);
    }
}




/*
 * layout the window  - decide if we need scrollbars or
 * not, and position the avicap window correctly
 */
void
vidframeLayout(HWND hwnd, HWND hwndCap)
{
    RECT rc;
    RECT rcCap;
    CAPSTATUS cs;
    int cx, cy;
    POINT ptScroll;


    // get the x and y scroll pos so we can reset them
    ptScroll.y = GetScrollPos(hwnd, SB_VERT);
    ptScroll.x = GetScrollPos(hwnd, SB_HORZ);

    GetClientRect(hwnd, &rc);
    if (!capGetStatus(hwndCap, &cs, sizeof(cs))) {
        // no current window? - make it 0 size
        cs.uiImageWidth = 0;
        cs.uiImageHeight = 0;

    }

    SetRect(&rcCap, 0, 0, cs.uiImageWidth, cs.uiImageHeight);

    /*
     * check which scrollbars we need - note that adding and removing
     * scrollbars affects the other dimension - so recheck client rect
     */
    if (RECTWIDTH(rcCap) < RECTWIDTH(rc)) {
        // fits horz.
        SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE);
    } else {
        // need horz scrollbar
        SetScrollRange(hwnd, SB_HORZ, 0, RECTWIDTH(rcCap) - RECTWIDTH(rc), FALSE);
    }

    // get client size in case shrunk/expanded
    GetClientRect(hwnd, &rc);

    // check vert scrollbar
    if (RECTHEIGHT(rcCap) < RECTHEIGHT(rc)) {
        SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE);
    } else {
        SetScrollRange(hwnd, SB_VERT, 0, RECTHEIGHT(rcCap) - RECTHEIGHT(rc), FALSE);

        // this may have caused the horz scrollbar to be unneeded
        GetClientRect(hwnd, &rc);
        if (RECTWIDTH(rcCap) < RECTWIDTH(rc)) {
            // fits horz.
            SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE);
        } else {
            // need horz scrollbar
            SetScrollRange(hwnd, SB_HORZ, 0, RECTWIDTH(rcCap) - RECTWIDTH(rc), FALSE);
        }
    }

    /*
     * be sure we don't leave any underwear showing if we have scrolled
     * back or removed the scrollbars
     */
    {
        int cmax, cmin;

        GetScrollRange(hwnd, SB_HORZ, &cmin, &cmax);
        if (ptScroll.x > cmax) {
            ptScroll.x = cmax;
        }
        GetScrollRange(hwnd, SB_VERT, &cmin, &cmax);
        if (ptScroll.y > cmax) {
            ptScroll.y = cmax;
        }
        SetScrollPos(hwnd, SB_HORZ, ptScroll.x, TRUE);
        SetScrollPos(hwnd, SB_VERT, ptScroll.y, TRUE);
        capSetScrollPos(hwndCap, &ptScroll);
    }

    // centre the window if requested and if room
    if(gbCentre) {
        GetClientRect(hwnd, &rc);
        cx = max(0, (RECTWIDTH(rc) - (int) cs.uiImageWidth)/2);
        cy = max(0, (RECTHEIGHT(rc) - (int) cs.uiImageHeight)/2);
        OffsetRect(&rcCap, cx, cy);
    }

    // DWORD align the capture window for optimal codec speed
    // during preview.  
    rc = rcCap;
    MapWindowPoints (hwnd, NULL, (LPPOINT)&rc, 1);
    cx = rc.left - (rc.left & ~3);
    OffsetRect(&rcCap, -cx, 0);

    MoveWindow(hwndCap,
            rcCap.left, rcCap.top,         
            RECTWIDTH(rcCap), RECTHEIGHT(rcCap),
            TRUE);

    InvalidateRect(hwnd, NULL, TRUE);
}

/*
 * paint the vidframe window. The fill colour is always selected as the
 * background brush, so all we need to do here is paint the
 * fancy border around the inner window if room.
 */
void
vidframePaint(HWND hwnd, HWND hwndCap)
{
    POINT ptInner;
    RECT rcCap;
    PAINTSTRUCT ps;
    HDC hdc;
    HBRUSH hbr;
    int cx, cy;

    hdc = BeginPaint(hwnd, &ps);

    /*
     * first calculate the location of the upper left corner
     * of the avicap window in vidframe-window client co-ordinates
     */
    ptInner.x = 0;
    ptInner.y = 0;
    MapWindowPoints(hwndCap, hwnd, &ptInner, 1);

    // width and height of cap window
    GetWindowRect(hwndCap, &rcCap);
    cx = RECTWIDTH(rcCap);
    cy = RECTHEIGHT(rcCap);

    // shadow lines
    hbr = SelectObject(hdc, ghbrShadow);
    PatBlt(hdc, ptInner.x-1, ptInner.y-1, cx + 1, 1, PATCOPY);
    PatBlt(hdc, ptInner.x-1, ptInner.y-1, 1, cy + 1, PATCOPY);
    PatBlt(hdc, ptInner.x + cx + 4, ptInner.y-5, 1, cy+10, PATCOPY);
    PatBlt(hdc, ptInner.x -5, ptInner.y+cy+4, cx+10, 1, PATCOPY);

    // hi-light lines
    SelectObject(hdc, ghbrHighlight);
    PatBlt(hdc, ptInner.x - 5, ptInner.y - 5, 1, cy+9, PATCOPY);
    PatBlt(hdc, ptInner.x - 5, ptInner.y - 5, cx+9, 1, PATCOPY);
    PatBlt(hdc, ptInner.x+cx, ptInner.y-1, 1, cy+2, PATCOPY);
    PatBlt(hdc, ptInner.x-1, ptInner.y+cy, cx, 1, PATCOPY);

    // fill bordered area with button face colour
    SelectObject(hdc, ghbrFace);
    PatBlt(hdc, ptInner.x-4, ptInner.y-4, cx+8, 3, PATCOPY);
    PatBlt(hdc, ptInner.x-4, ptInner.y+cy+1, cx+8, 3, PATCOPY);
    PatBlt(hdc, ptInner.x-4, ptInner.y-1, 3, cy+2, PATCOPY);
    PatBlt(hdc, ptInner.x+cx+1, ptInner.y-1, 3, cy+2, PATCOPY);

    SelectObject(hdc, hbr);

    EndPaint(hwnd, &ps);

}

/*
 * respond to a scrollbar message by moving the current scroll
 * position horizontally
 */
void
vidframeHScroll(HWND hwnd, HWND hwndCap, int code, int pos)
{
    POINT pt;
    int cmax, cmin;

    pt.x = GetScrollPos(hwnd, SB_HORZ);
    pt.y = GetScrollPos(hwnd, SB_VERT);
    GetScrollRange(hwnd, SB_HORZ, &cmin, &cmax);


    switch(code) {
    case SB_LINEUP:
        pt.x -= LINE_SCROLL;
        break;

    case SB_LINEDOWN:
        pt.x += LINE_SCROLL;
        break;

    case SB_PAGEUP:
        pt.x -= PAGE_SCROLL;
        break;

    case SB_PAGEDOWN:
        pt.x += PAGE_SCROLL;
        break;

    case SB_THUMBTRACK:
    case SB_THUMBPOSITION:
        pt.x = pos;
        break;
    }

    if (pt.x < cmin) {
        pt.x = cmin;
    } else if (pt.x > cmax) {
        pt.x = cmax;
    }
    SetScrollPos(hwnd, SB_HORZ, pt.x, TRUE);
    capSetScrollPos(hwndCap, &pt);

}


/*
 * respond to a scrollbar message by moving the current scroll
 * position vertically
 */
void
vidframeVScroll(HWND hwnd, HWND hwndCap, int code, int pos)
{
    POINT pt;
    int cmax, cmin;

    pt.x = GetScrollPos(hwnd, SB_HORZ);
    pt.y = GetScrollPos(hwnd, SB_VERT);
    GetScrollRange(hwnd, SB_VERT, &cmin, &cmax);


    switch(code) {
    case SB_LINEUP:
        pt.y -= LINE_SCROLL;
        break;

    case SB_LINEDOWN:
        pt.y += LINE_SCROLL;
        break;

    case SB_PAGEUP:
        pt.y -= PAGE_SCROLL;
        break;

    case SB_PAGEDOWN:
        pt.y += PAGE_SCROLL;
        break;

    case SB_THUMBTRACK:
    case SB_THUMBPOSITION:
        pt.y = pos;
        break;
    }

    if (pt.y < cmin) {
        pt.y = cmin;
    } else if (pt.y > cmax) {
        pt.y = cmax;
    }
    SetScrollPos(hwnd, SB_VERT, pt.y, TRUE);
    capSetScrollPos(hwndCap, &pt);
}



LRESULT FAR PASCAL 
vidframeProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch(message) {

    case WM_MOVE:
    case WM_SIZE:
        if (ghWndCap) {
            vidframeLayout(hwnd, ghWndCap);
        }
        break;

    case WM_SYSCOLORCHANGE:
        // re-get brushes - we will be sent a paint message
        vidframeDeleteTools();
        vidframeCreateTools(hwnd);
        return(TRUE);


    case WM_PALETTECHANGED:
    case WM_QUERYNEWPALETTE:
        // allow the avicap window to handle this
        if (ghWndCap) {
            return SendMessage(ghWndCap, message, wParam, lParam) ;
        }

    case WM_PAINT:
        if (ghWndCap) {
            vidframePaint(hwnd, ghWndCap);
        }
        break;

    case WM_HSCROLL:
        if (ghWndCap) {
            vidframeHScroll(hwnd, ghWndCap,
                GET_WM_HSCROLL_CODE(wParam, lParam),
                GET_WM_HSCROLL_POS(wParam, lParam)
                );
        }
        break;

    case WM_VSCROLL:
        if (ghWndCap) {
            vidframeVScroll(hwnd, ghWndCap,
                GET_WM_VSCROLL_CODE(wParam, lParam),
                GET_WM_VSCROLL_POS(wParam, lParam)
                );
        }
        break;

    case WM_DESTROY:
        vidframeDeleteTools();
        break;

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));

    }
    return(0);
}



/*
 * create a frame window and child capture window at the
 * given location. Initialise the class if this is the
 * first time through.
 *
 * returns the window handle of the frame window
 * (or NULL if failure). returns the window handle of the AVICAP window
 * via phwndCap.
 */
HWND
vidframeCreate(
    HWND hwndParent,
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    int x,
    int y,
    int cx,
    int cy,
    HWND FAR * phwndCap
)
{
    HWND hwnd, hwndCap;
    static BOOL bInitDone = FALSE;

    if (!bInitDone) {
        WNDCLASS wc;

        vidframeCreateTools(NULL);

        if (!hPrevInstance) {
            // If it's the first instance, register the window class
            wc.lpszClassName = VIDFRAMECLASSNAME;
            wc.hInstance     = hInstance;
            wc.lpfnWndProc   = vidframeProc;
            wc.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
            wc.hIcon         = NULL;
            wc.lpszMenuName  = NULL;
            wc.hbrBackground = ghbrBackground;
            wc.style         = CS_HREDRAW | CS_VREDRAW ;
            wc.cbClsExtra    = 0 ;
            wc.cbWndExtra    = 0 ;   

            if(!RegisterClass(&wc)) {
                return(NULL);
            }
        }
        bInitDone = TRUE;
    }

    hwnd = CreateWindowEx(
                gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0,
                VIDFRAMECLASSNAME,
                NULL,
                WS_CHILD|WS_VISIBLE|WS_HSCROLL|WS_VSCROLL|WS_CLIPCHILDREN,
                x, y, cx, cy,
                hwndParent,
                (HMENU) 0,
                hInstance,
                NULL);

    if (hwnd == NULL) {
        return(NULL);
    }


    /*
     * create an AVICAP window within this window. Leave vidframeLayout
     * to do the layout
     */
    hwndCap = capCreateCaptureWindow(
                    NULL,
                    WS_CHILD | WS_VISIBLE,
                    0, 0, 160, 120,
                    hwnd,               // parent window
                    1                   // child window id
              );


    if (hwndCap == NULL) {
        return(NULL);
    }

    *phwndCap = hwndCap;
    return(hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\video\compdef.h ===
/***************************************************************************
 *
 *  compdef.h
 *
 *  Copyright (c) 1993  Microsoft Corporation
 *
 *  32-bit Thunks for msvideo.dll
 *
 *  Structures for mapping compression manager calls
 *
 **************************************************************************/

/**************************************************************************\

 Thunking of compman APIs

 Functions:

    ICInstall is NOT supported from 16-bit to 32-bit

    ICRemove is also NOT supported

    ICInfo - tries the 32-bit side first

    Handles

        Are pointers to the PIC table.

        The 16-bit side handle manager will store these and call us back
        with our 32-bit handles so the thunking routines here receive
        real 32-bit handles.

        There is NO handle cleanup (why not ???) on task termination

/*
 *  Make sure the compiler doesn't think it knows better about packing
 *  The 16-bit stack is effectively pack(2)
 */

#pragma pack(2)

/*
 *  Note that everything is in the reverse order to keep with the PASCAL
 *  calling convention on the other side
 */


/****************************************************************************

   compman entry point parameter lists

 ****************************************************************************/

typedef struct {
#ifdef ICINFOA
    ICINFOA  *lpicinfo;  // Why is there no ASCII 32-bit API?
#else
    ICINFO   *lpicinfo;  // Why is there no ASCII 32-bit API?
#endif
    DWORD    fccHandler;
    DWORD    fccType;
} UNALIGNED *PICInfoParms16;

typedef struct {
    DWORD    dw2;
    DWORD    dw1;
    WORD     msg;
    DWORD    hic;
} UNALIGNED *PICSendMessageParms16;

typedef struct {
    WORD     wMode;
    DWORD    fccHandler;
    DWORD    fccType;
} UNALIGNED *PICOpenParms16;

typedef struct {
    DWORD    hic;
} UNALIGNED *PICCloseParms16;

typedef struct {
    DWORD    dwFlags;
    WORD     hpal;
    WORD     hwnd;
    WORD     hdc;
    short    xDst;
    short    yDst;
    short    dxDst;
    short    dyDst;
    LPBITMAPINFOHEADER lpbi;
    short    xSrc;
    short    ySrc;
    short    dxSrc;
    short    dySrc;
    DWORD    dwRate;
    DWORD    dwScale;
} ICDRAWBEGIN16;

#pragma pack()



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\video\compmn16.h ===
/***************************************************************************
 *
 *  compdef.h
 *
 *  Copyright (c) 1993-1994  Microsoft Corporation
 *
 *  32-bit Thunks for msvideo.dll
 *
 *  Structures for mapping compression manager calls
 *
 **************************************************************************/

/**************************************************************************\

 Thunking of compman APIs

 Functions:

    ICInstall is NOT supported from 16-bit to 32-bit

    ICRemove is also NOT supported

    ICInfo - tries the 32-bit side first

    Handles

        Are pointers to the PIC table.

        The 16-bit side handle manager will store these and call us back
        with our 32-bit handles so the thunking routines here receive
        real 32-bit handles.

        There is NO handle cleanup (why not ???) on task termination

/*
 *  Make sure the compiler doesn't think it knows better about packing
 *  The 16-bit stack is effectively pack(2)
 */

#pragma pack(2)

/*
 *  Note that everything is in the reverse order to keep with the PASCAL
 *  calling convention on the other side
 */


/****************************************************************************

   compman entry point parameter lists

 ****************************************************************************/

typedef struct {
    DWORD   dwSize;                 // sizeof(ICINFOA)
    DWORD   fccType;                // compressor type     'vidc' 'audc'
    DWORD   fccHandler;             // compressor sub-type 'rle ' 'jpeg' 'pcm '
    DWORD   dwFlags;                // flags LOWORD is type specific
    DWORD   dwVersion;              // version of the driver
    DWORD   dwVersionICM;           // version of the ICM used
    char    szName[16];             // short name
    char    szDescription[128];     // long name
    char    szDriver[128];          // driver that contains compressor
}   ICINFO16;

#define ICINFOA ICINFO16

typedef struct {
#ifdef ICINFOA
    ICINFOA  *lpicinfo;  // Why is there no ASCII 32-bit API?
#else
    ICINFO   *lpicinfo;  // Why is there no ASCII 32-bit API?
#endif
    DWORD    fccHandler;
    DWORD    fccType;
} UNALIGNED *PICInfoParms16;

typedef struct {
    DWORD    dw2;
    DWORD    dw1;
    WORD     msg;
    DWORD    hic;
} UNALIGNED *PICSendMessageParms16;

typedef struct {
    WORD     wMode;
    DWORD    fccHandler;
    DWORD    fccType;
} UNALIGNED *PICOpenParms16;

typedef struct {
    DWORD    hic;
} UNALIGNED *PICCloseParms16;

typedef struct {
    DWORD    dwFlags;
    WORD     hpal;
    WORD     hwnd;
    WORD     hdc;
    short    xDst;
    short    yDst;
    short    dxDst;
    short    dyDst;
    LPBITMAPINFOHEADER lpbi;
    short    xSrc;
    short    ySrc;
    short    dxSrc;
    short    dySrc;
    DWORD    dwRate;
    DWORD    dwScale;
} ICDRAWBEGIN16;

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\video\debug.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992, 1994  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//
//==========================================================================;

#include <win32.h> // to translate DBG -> DEBUG for NT builds
#ifdef DEBUG

#include <windows.h>
#include <windowsx.h>
#include <stdarg.h>
#define _INC_DEBUG_CODE
#include "debug.h"


//
//  since we don't UNICODE our debugging messages, use the ASCII entry
//  points regardless of how we are compiled.
//
#ifdef _WIN32
    #include <wchar.h>
#else
    #define lstrcpyA		lstrcpy
    #define lstrcatA            lstrcat
    #define lstrlenA            lstrlen
    #define GetProfileIntA      GetProfileInt
    #define OutputDebugStringA  OutputDebugString
    #define wsprintfA           wsprintf
    #define MessageBoxA         MessageBox
#endif

//
//
//
#define cDbgSpecs (sizeof(aszDbgSpecs) / sizeof(aszDbgSpecs[0]))

BOOL    __gfDbgEnabled[cDbgSpecs];     // master enable
UINT    __guDbgLevel[cDbgSpecs];       // current debug level


//--------------------------------------------------------------------------;
//
//  void DbgVPrintF
//
//  Description:
//
//
//  Arguments:
//      LPSTR szFormat:
//
//      va_list va:
//
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL DbgVPrintF
(
    LPSTR                   szFormat,
    va_list                 va
)
{
    char                ach[DEBUG_MAX_LINE_LEN];
    BOOL                fDebugBreak = FALSE;
    BOOL                fPrefix     = TRUE;
    BOOL                fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch (*szFormat)
        {
            case '!':
                fDebugBreak = TRUE;
                szFormat++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFormat++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFormat++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
    {
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");
    }

#ifdef _WIN32
    wvsprintfA(ach + lstrlenA(ach), szFormat, va);
#else
    wvsprintf(ach + lstrlenA(ach), szFormat, (LPSTR)va);
#endif

    if (fCRLF)
    {
        lstrcatA(ach, "\r\n");
    }

    OutputDebugStringA(ach);

    if (fDebugBreak)
    {
        DebugBreak();
    }
} // DbgVPrintF()


//--------------------------------------------------------------------------;
//
//  void dprintfS
//
//  Description:
//      dprintfS() is called by the DPFS() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPFS() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//
//  Arguments:
//	UINT uDbgSpec:
//
//      UINT uDbgLevel:
//
//      LPSTR szFormat:
//
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintfS
(
    UINT		    uDbgSpec,
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled[uDbgSpec] || (__guDbgLevel[uDbgSpec] < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//
//  void dprintf
//
//  Description:
//      dprintf() is called by the DPF() macro if DEBUG is defined at compile
//      time. It is recommended that you only use the DPF() macro to call
//      this function--so you don't have to put #ifdef DEBUG around all
//      of your code.
//
//  Arguments:
//      UINT uDbgLevel:
//
//      LPSTR szFormat:
//
//  Return (void):
//      No value is returned.
//
//--------------------------------------------------------------------------;

void FAR CDECL dprintf
(
    UINT                    uDbgLevel,
    LPSTR                   szFormat,
    ...
)
{
    va_list va;

    if (!__gfDbgEnabled[dbgNone] || (__guDbgLevel[dbgNone] < uDbgLevel))
        return;

    va_start(va, szFormat);
    DbgVPrintF(szFormat, va);
    va_end(va);
} // dprintf()


//--------------------------------------------------------------------------;
//
//  BOOL DbgEnable
//
//  Description:
//
//
//  Arguments:
//      BOOL fEnable:
//
//  Return (BOOL):
//      Returns the previous debugging state.
//
//--------------------------------------------------------------------------;

BOOL WINAPI DbgEnable
(
    UINT	uDbgSpec,
    BOOL        fEnable
)
{
    BOOL	fOldState;

    fOldState			= __gfDbgEnabled[uDbgSpec];
    __gfDbgEnabled[uDbgSpec]	= fEnable;

    return (fOldState);
} // DbgEnable()


//--------------------------------------------------------------------------;
//
//  UINT DbgSetLevel
//
//  Description:
//
//
//  Arguments:
//      UINT uLevel:
//
//  Return (UINT):
//      Returns the previous debugging level.
//
//--------------------------------------------------------------------------;

UINT WINAPI DbgSetLevel
(
    UINT	uDbgSpec,
    UINT        uLevel
)
{
    UINT        uOldLevel;

    uOldLevel		    = __guDbgLevel[uDbgSpec];
    __guDbgLevel[uDbgSpec]  = uLevel;

    return (uOldLevel);
} // DbgSetLevel()


//--------------------------------------------------------------------------;
//
//  UINT DbgGetLevel
//
//  Description:
//
//
//  Arguments:
//      None.
//
//  Return (UINT):
//      Returns the current debugging level.
//
//--------------------------------------------------------------------------;

UINT WINAPI DbgGetLevel
(
    UINT    uDbgSpec
)
{
    return (__guDbgLevel[uDbgSpec]);
} // DbgGetLevel()


//--------------------------------------------------------------------------;
//
//  UINT DbgInitializeSpec
//
//  Description:
//
//
//  Arguments:
//      BOOL fEnable:
//
//  Return (UINT):
//      Returns the debugging level that was set.
//
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitializeSpec
(
    UINT	uDbgSpec,
    BOOL	fEnable
)
{
    UINT        uLevel;
    char	szKey[DEBUG_MAX_LINE_LEN];

    lstrcpyA(szKey, DEBUG_MODULE_NAME);
    lstrcatA(szKey, aszDbgSpecs[uDbgSpec]);
	
    uLevel = GetProfileIntA(DEBUG_SECTION, szKey, (UINT)-1);
    if ((UINT)-1 == uLevel)
    {
	//
	//  if the debug key is not present, then force debug output to
	//  be disabled. this way running a debug version of a component
	//  on a non-debugging machine will not generate output unless
	//  the debug key exists.
	//
	uLevel  = 0;
	fEnable = FALSE;
    }

    DbgSetLevel(uDbgSpec, uLevel);
    DbgEnable(uDbgSpec, fEnable);

    return (__guDbgLevel[uDbgSpec]);
} // DbgInitialize()


//--------------------------------------------------------------------------;
//
//  VOID DbgInitialize
//
//  Description:
//
//
//  Arguments:
//      BOOL fEnable:
//
//  Return (UINT):
//      Returns the debugging level that was set.
//
//--------------------------------------------------------------------------;

VOID WINAPI DbgInitialize
(
    BOOL	fEnable
)
{
    UINT	i;

    for (i=0; i<sizeof(__guDbgLevel)/sizeof(__guDbgLevel[0]); i++)
    {
	DbgInitializeSpec(i, fEnable);
    }

    return;
} // DbgInitialize()


//--------------------------------------------------------------------------;
//
//  void _Assert
//
//  Description:
//      This routine is called if the ASSERT macro (defined in debug.h)
//      tests an expression that evaluates to FALSE.  This routine
//      displays an "assertion failed" message box allowing the user to
//      abort the program, enter the debugger (the "retry" button), or
//      ignore the assertion and continue executing.  The message box
//      displays the file name and line number of the _Assert() call.
//
//  Arguments:
//      char *  szFile: Filename where assertion occurred.
//      int     iLine:  Line number of assertion.
//
//--------------------------------------------------------------------------;

#ifndef _WIN32
#pragma warning(disable:4704)
#endif

void WINAPI _Assert
(
    char *  szFile,
    int     iLine
)
{
    static char     ach[300];       // debug output (avoid stack overflow)
    int	            id;
#ifndef _WIN32
    int             iExitCode;
#endif

    wsprintfA(ach, "Assertion failed in file %s, line %d.  [Press RETRY to debug.]", (LPSTR)szFile, iLine);

    id = MessageBoxA(NULL, ach, "Assertion Failed",
            MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE );

	switch (id)
	{

	case IDABORT:               // Kill the application.
#ifndef _WIN32
        iExitCode = 0;
        _asm
        {
	        mov	ah, 4Ch
	        mov	al, BYTE PTR iExitCode
	        int     21h
        }
#else
        FatalAppExit(0, TEXT("Good Bye"));
#endif // WIN16
		break;

	case IDRETRY:               // Break into the debugger.
		DebugBreak();
		break;

	case IDIGNORE:              // Ignore assertion, continue executing.
		break;
	}
} // _Assert

#ifndef _WIN32
#pragma warning(default:4704)
#endif

#endif // #ifdef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\video\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992, 1993  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif



#ifndef _WIN32
#ifndef LPCTSTR
#define LPCTSTR LPCSTR
#endif
#ifndef TCHAR
#define TCHAR char
#endif
#endif


//--------------------------------------------------------------------------;
//
//  The following is the only stuff that should need to be changed when
//  moving this debug code from one project component to another.
//
//--------------------------------------------------------------------------;

//
//  DEBUG_MODULE_NAME is the module name of the component you are
//  building.  In the [debug] section of WIN.INI you can add
//  an entry MYMODULE=n to set the debug level for you module.
//  You can use debug statements like:
//	DPF(2, "My debug string");
//  This output would appear only if MYMODULE=n appears in WIN.INI
//  and n>=2.
//
#ifdef _WIN32
#define DEBUG_MODULE_NAME       "MSVFW32"    // key name and prefix for output
#else
#define DEBUG_MODULE_NAME       "MSVIDEO"   // key name and prefix for output
#endif

//
//  You can also specify certain types of debug information.  For example,
//  you may have much debug output that is associated only with initialization.
//  By adding an entry to the following enumeration, and then adding the
//  corresponding string to the following array of strings, you can specify
//  a debug level for different types of debug information.  Using the
//  initialization example, you can add an entry like "MYMODULENAME_dbgInit=n"
//  to the [debug] section to set a debug level for debug information
//  associated only with initialization.  You would use debug statements like:
//	DPFS(dbgInit, 3, "My debug string");
//  This output would appear only if MYMODULENAME_dbgInit=n appears in WIN.INI
//  and n>=3.  This would be usefull when you only want to debug the logic
//  associated only with a certain part of you program.
//
//  DO NOT CHANGE the first entry in the enum and the aszDbgSpecs.
//
enum {
    dbgNone=0,
    dbgInit,
    dbgThunks
};

#ifdef _INC_DEBUG_CODE
LPCSTR aszDbgSpecs[] = {
    "\0",
    "_dbgInit",
    "_dbgThunks"
};
#endif

//--------------------------------------------------------------------------;
//
//  You should NOT need to modify anthing below here when
//  moving this debug code from one project component to another.
//
//--------------------------------------------------------------------------;


//
//
//
#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef _WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//  #pragma message(REMIND("this is a reminder"))
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define DEBUG_QUOTE(x)      #x
#define DEBUG_QQUOTE(y)     DEBUG_QUOTE(y)
#define REMIND(sz)          __FILE__ "(" DEBUG_QQUOTE(__LINE__) ") : " sz

#ifdef DEBUG
    BOOL WINAPI DbgEnable(UINT uDbgSpec, BOOL fEnable);
    UINT WINAPI DbgGetLevel(UINT uDbgSpec);
    UINT WINAPI DbgSetLevel(UINT uDbgSpec, UINT uLevel);
    VOID WINAPI DbgInitialize(BOOL fEnable);
    void WINAPI _Assert( char * szFile, int iLine );

    void FAR CDECL dprintfS(UINT uDbgSpec, UINT uDbgLevel, LPSTR szFmt, ...);
    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define D(x)        {x;}
    #define DPFS	dprintfS
    #define DPF		dprintf
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}
    #define ASSERT(x)   if( !(x) )  _Assert( __FILE__, __LINE__)
#else
    #define DbgEnable(x)        FALSE
    #define DbgGetLevel()       0
    #define DbgSetLevel(x)      0
    #define DbgInitialize(x)

    #ifdef _MSC_VER
    #pragma warning(disable:4002)
    #endif

    #define D(x)
    #define DPFS()
    #define DPF()
    #define DPI(sz)
    #define ASSERT(x)
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef RDEBUG
    #define DebugErr(flags, sz)         {static char BCODE szx[] = DEBUG_MODULE_NAME ": " sz; DebugOutput((flags) | DBF_MMSYSTEM, szx);}
    #define DebugErr1(flags, sz, a)     {static char BCODE szx[] = DEBUG_MODULE_NAME ": " sz; DebugOutput((flags) | DBF_MMSYSTEM, szx, a);}
    #define DebugErr2(flags, sz, a, b)  {static char BCODE szx[] = DEBUG_MODULE_NAME ": " sz; DebugOutput((flags) | DBF_MMSYSTEM, szx, a, b);}
#else
    #define DebugErr(flags, sz)
    #define DebugErr1(flags, sz, a)
    #define DebugErr2(flags, sz, a, b)
#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\video\dpmipage.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  PAGELOCK
;
;   This module contains functions for page locking memory using DPMI
;
; Created:  03-20-90
; Author:   Todd Laney [ToddLa]
;
; Copyright (c) 1984-1990 Microsoft Corporation
;
; Exported Functions:	none
;
; Public Functions:     DpmiPageLock
;                       DpmiPageUnlock
;
; Public Data:          none
;
; General Description:
;
; Restrictions:
;
;-----------------------------------------------------------------------;

        ?PLM = 1
        ?WIN = 0
        ?NODATA = 1

        .286
        .xlist
        include cmacros.inc
        include int31.inc
        .list

        externA         __AHINCR                    ; KERNEL
        externFP        GlobalHandle                ; KERNEL
        externFP        GlobalHandleNoRip           ; KERNEL
        externFP        GlobalFix                   ; KERNEL
        externFP        GlobalUnFix                 ; KERNEL

ifndef SEGNAME
    SEGNAME equ <MSVIDEO>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

Int31_SelMgt_Get_Base     EQU ((Int31_Sel_Mgt shl 8) + SelMgt_Get_Base )
Int31_Lock_Region         EQU ((Int31_Page_Lock shl 8) + Lock_Region )
Int31_Unlock_Region       EQU ((Int31_Page_Lock shl 8) + Unlock_Region )

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

FARPOINTER      struc
off     dw      ?
sel     dw      ?
FARPOINTER      ends

sBegin CodeSeg
        assumes cs,CodeSeg
        assumes ds,nothing
        assumes es,nothing

;---------------------------Public-Routine------------------------------;
; DpmiPageLock
;
;   page lock a region using DPMI
;
; Entry:
;       lpBase      Selector:offset of base of region to lock
;       dwSize      size in bytes of region to lock
;
; Returns:
;       NZ
;       AX = TRUE if successful
;
; Error Returns:
;       Z
;       AX = FALSE if error
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       INT 31h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   DpmiPageLock, <NEAR>, <>
;       parmD   lpBase
;       parmD   dwSize
cBegin  nogen
        mov     cx,Int31_Lock_Region
        jmp     short DpmiPageLockUnLock
cEnd    nogen

;---------------------------Public-Routine------------------------------;
; DpmiPageUnlock
;
;   un-page lock a region using DPMI
;
; Entry:
;       lpBase      Selector:offset of base of region to unlock
;       dwSize      size in bytes of region to unlock
;
; Returns:
;       NZ
;       AX = TRUE if successful
;
; Error Returns:
;       Z
;       AX = FALSE if error
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       INT 31h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   DpmiPageUnlock, <NEAR>, <>
;       parmD   lpBase
;       parmD   dwSize
cBegin  nogen
        mov     cx,Int31_Unlock_Region
        errn$   DpmiPageLockUnLock
cEnd    nogen

cProc   DpmiPageLockUnLock, <NEAR>, <si,di>
        parmD   lpBase
        parmD   dwSize
cBegin
        mov     si,cx                       ; save lock/unlock flag

        mov     ax,Int31_SelMgt_Get_Base
        mov     bx,lpBase.sel
        int     31h                         ; returns CX:DX selector base
        jc      dpl_exit

        mov     bx,cx                       ; BX:CX is base
        mov     cx,dx

        add     cx,lpBase.off               ; add offset into selector base
        adc     bx,0

        mov     ax,si                       ; get lock/unlock flag
        mov     si,dwSize.hi                ; SI:DI length
        mov     di,dwSize.lo

        int     31h                         ; lock or unlock it
dpl_exit:
        cmc                                 ; set carry iff success
        sbb     ax,ax                       ; return TRUE/FALSE
cEnd

;---------------------------Public-Routine------------------------------;
; HugePageLock
;
;   page lock a range of windows allocated memory
;
; Entry:
;       lpBase      Selector:offset of base of region to lock
;       dwSize      size in bytes of region to lock
;
; Returns:
;       AX = TRUE if successful
;
; Error Returns:
;       AX = FALSE if error
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       INT 31h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   HugePageLock, <FAR, PUBLIC>, <>
        parmD   lpBase
        parmD   dwSize
cBegin
        mov     ax,lpBase.sel               ; NULL pointer, invalid
        or      ax,ax
        jz      GPageLock_Exit

        call    HugeGlobalFix               ; fix the memory, then page lock
        cCall   DpmiPageLock,<lpBase, dwSize>
        jnz     GPageLock_Exit

        mov     ax,lpBase.sel               ; page lock failed, un-fix
        call    HugeGlobalUnFix             ; and return failure
        xor     ax,ax

GPageLock_Exit:
cEnd

;---------------------------Public-Routine------------------------------;
; HugePageUnlock
;
;   un-page lock a range of windows alocated memory, (locked with HugePageLock)
;
; Entry:
;       lpBase      Selector:offset of base of region to lock
;       dwSize      size in bytes of region to lock
;
; Returns:
;       none
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       INT 31h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   HugePageUnlock, <FAR, PUBLIC>, <>
        parmD   lpBase
        parmD   dwSize
cBegin
        cCall   DpmiPageUnlock,<lpBase, dwSize>

        mov     ax,lpBase.sel
        call    HugeGlobalUnFix
cEnd

;---------------------------Public-Routine------------------------------;
; HugeGlobalFix
;
;   fix the global object that represents the passed selector
;
; Entry:
;       AX = SELECTOR
;
; Returns:
;       none
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       GlobalFix
;       HugeGlobalHandle
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

HugeGlobalFix proc near

        call    HugeGlobalHandle
        jz      HugeGlobalFixExit

        cCall   GlobalFix,<ax>

HugeGlobalFixExit:
        ret

HugeGlobalFix endp

;---------------------------Public-Routine------------------------------;
; HugeGlobalUnFix
;
;   un-fix the global object that represents the passed selector
;
; Entry:
;       AX = SELECTOR
;
; Returns:
;       none
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       HugeGlobalHandle
;       GlobalUnFix
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

HugeGlobalUnFix proc near

        call    HugeGlobalHandle
        jz      HugeGlobalUnFixExit

        cCall   GlobalUnFix,<ax>

HugeGlobalUnFixExit:
        ret

HugeGlobalUnFix endp

;---------------------------Public-Routine------------------------------;
; HugeGlobalHandle
;
; Entry:
;       AX = SELECTOR to global object
;
; Returns:
;       NZ
;       AX = HANDLE of global object
;
; Error Returns:
;       Z
;       AX = 0 if error
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       GlobalHandleNoRip
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

HugeGlobalHandle proc near

        push    si
        mov     si,ax

        or      ax,ax                   ; test for NULL pointer!
        jz      HugeGlobalHandleExit

HugeGlobalHandleAgain:
        cCall   GlobalHandleNoRip,<si>
        sub     si,__AHINCR
        or      ax,ax
        jz      HugeGlobalHandleAgain

HugeGlobalHandleExit:
        pop     si
        ret

HugeGlobalHandle endp

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\video\ivideo32.h ===
/****************************************************************************/
/*                                                                          */
/* ivideo32.h                                                               */
/*                                                                          */
/* private structures & prototypes for 32bit videoXXX api's                 */
/* this header file is specific to WIN32                                    */
/*                                                                          */
/****************************************************************************/

// include public stuff about the videoXXX interface
//
#include <vfw.h>

// include private stuff IFF _WIN32 and we have not already done so
//
#if !defined _INC_IVIDEO32 && defined _WIN32
#define _INC_IVIDEO32

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

#ifndef _RCINVOKED


/****************************************************************************

                         Structures

****************************************************************************/
#if 0
/* video data block header */
typedef struct videohdr_tag {
    LPBYTE      lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* Length of data buffer */
    DWORD       dwBytesUsed;            /* Bytes actually used */
    DWORD       dwTimeCaptured;         /* Milliseconds from start of stream */
    DWORD       dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD       dwReserved[4];          /* reserved for driver */
} VIDEOHDR, NEAR *PVIDEOHDR, FAR * LPVIDEOHDR;

/* dwFlags field of VIDEOHDR */
#define VHDR_DONE       0x00000001  /* Done bit */
#define VHDR_PREPARED   0x00000002  /* Set if this header has been prepared */
#define VHDR_INQUEUE    0x00000004  /* Reserved for driver */
#define VHDR_KEYFRAME   0x00000008  /* Key Frame */
#define VHDR_VALID      0x0000000F  /* valid flags */     /* ;Internal */

/* Channel capabilities structure */
typedef struct channel_caps_tag {
    DWORD       dwFlags;                /* Capability flags*/
    DWORD       dwSrcRectXMod;          /* Granularity of src rect in x */
    DWORD       dwSrcRectYMod;          /* Granularity of src rect in y */
    DWORD       dwSrcRectWidthMod;      /* Granularity of src rect width */
    DWORD       dwSrcRectHeightMod;     /* Granularity of src rect height */
    DWORD       dwDstRectXMod;          /* Granularity of dst rect in x */
    DWORD       dwDstRectYMod;          /* Granularity of dst rect in y */
    DWORD       dwDstRectWidthMod;      /* Granularity of dst rect width */
    DWORD       dwDstRectHeightMod;     /* Granularity of dst rect height */
} CHANNEL_CAPS, NEAR *PCHANNEL_CAPS, FAR * LPCHANNEL_CAPS;

/* dwFlags of CHANNEL_CAPS */
#define VCAPS_OVERLAY       0x00000001      /* overlay channel */
#define VCAPS_SRC_CAN_CLIP  0x00000002      /* src rect can clip */
#define VCAPS_DST_CAN_CLIP  0x00000004      /* dst rect can clip */
#define VCAPS_CAN_SCALE     0x00000008      /* allows src != dst */
#endif

/****************************************************************************

                        video APIs

****************************************************************************/


DWORD WINAPI videoGetNumDevs(void);

DWORD WINAPI videoOpen  (LPHVIDEO lphVideo,
              DWORD dwDevice, DWORD dwFlags);
DWORD WINAPI videoClose (HVIDEO hVideo);
DWORD WINAPI videoDialog(HVIDEO hVideo, HWND hWndParent, DWORD dwFlags);
DWORD WINAPI videoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps,
                DWORD dwSize);
DWORD WINAPI videoUpdate (HVIDEO hVideo, HWND hWnd, HDC hDC);
DWORD WINAPI videoConfigure (HVIDEO hVideo, UINT msg, DWORD dwFlags,
		LPDWORD lpdwReturn, LPVOID lpData1, DWORD dwSize1,
                LPVOID lpData2, DWORD dwSize2);

DWORD WINAPI videoConfigureStorageA(HVIDEO hVideo,
                      LPSTR lpstrIdent, DWORD dwFlags);
DWORD WINAPI videoConfigureStorageW(HVIDEO hVideo,
                      LPWSTR lpstrIdent, DWORD dwFlags);
#ifdef UNICODE
  #define videoConfigureStorage  videoConfigureStorageW
#else
  #define videoConfigureStorage  videoConfigureStorageA
#endif // !UNICODE

DWORD WINAPI videoFrame(HVIDEO hVideo, LPVIDEOHDR lpVHdr);
DWORD WINAPI videoMessage(HVIDEO hVideo, UINT msg, LPARAM dwP1, LPARAM dwP2);

/* streaming APIs */
DWORD WINAPI videoStreamAddBuffer(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamGetError(HVIDEO hVideo, LPDWORD lpdwErrorFirst,
        LPDWORD lpdwErrorLast);

DWORD WINAPI videoGetErrorTextA(HVIDEO hVideo, UINT wError,
              LPSTR lpText, UINT wSize);
DWORD WINAPI videoGetErrorTextW(HVIDEO hVideo, UINT wError,
              LPWSTR lpText, UINT wSize);

#ifdef UNICODE
  #define videoGetErrorText  videoGetErrorTextW
#else
  #define videoGetErrorText  videoGetErrorTextA
#endif // !UNICODE

DWORD WINAPI videoStreamGetPosition(HVIDEO hVideo, MMTIME FAR* lpInfo,
              DWORD dwSize);
DWORD WINAPI videoStreamInit(HVIDEO hVideo,
              DWORD dwMicroSecPerFrame, DWORD_PTR dwCallback,
              DWORD_PTR dwCallbackInst, DWORD dwFlags);
DWORD WINAPI videoStreamFini(HVIDEO hVideo);
DWORD WINAPI videoStreamPrepareHeader(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamReset(HVIDEO hVideo);
DWORD WINAPI videoStreamStart(HVIDEO hVideo);
DWORD WINAPI videoStreamStop(HVIDEO hVideo);
DWORD WINAPI videoStreamUnprepareHeader(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);

// Added post VFW1.1a
DWORD WINAPI videoStreamAllocHdrAndBuffer(HVIDEO hVideo,
              LPVIDEOHDR FAR * plpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamFreeHdrAndBuffer(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr);


/****************************************************************************

			API Flags

****************************************************************************/

// Types of channels to open with the videoOpen function
#define VIDEO_EXTERNALIN		0x0001
#define VIDEO_EXTERNALOUT		0x0002
#define VIDEO_IN			0x0004
#define VIDEO_OUT			0x0008

// Is a driver dialog available for this channel?
#define VIDEO_DLG_QUERY			0x0010

// videoConfigure (both GET and SET)
#define VIDEO_CONFIGURE_QUERY   	0x8000

// videoConfigure (SET only)
#define VIDEO_CONFIGURE_SET		0x1000

// videoConfigure (GET only)
#define VIDEO_CONFIGURE_GET		0x2000
#define VIDEO_CONFIGURE_QUERYSIZE	0x0001

#define VIDEO_CONFIGURE_CURRENT		0x0010
#define VIDEO_CONFIGURE_NOMINAL		0x0020
#define VIDEO_CONFIGURE_MIN		0x0040
#define VIDEO_CONFIGURE_MAX		0x0080

/****************************************************************************

			CONFIGURE MESSAGES

****************************************************************************/
#define DVM_USER                        0X4000

#define DVM_CONFIGURE_START		0x1000
#define DVM_CONFIGURE_END		0x1FFF

#define DVM_PALETTE			(DVM_CONFIGURE_START + 1)
#define DVM_FORMAT			(DVM_CONFIGURE_START + 2)
#define DVM_PALETTERGB555		(DVM_CONFIGURE_START + 3)
#define DVM_SRC_RECT    		(DVM_CONFIGURE_START + 4)
#define DVM_DST_RECT                    (DVM_CONFIGURE_START + 5)

#endif  /* ifndef _RCINVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif // _INC_VIDEO32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\video\init.c ===
/*
    init.c initialisation for MSVIDEO.DLL

    Copyright (c) Microsoft Corporation 1992. All rights reserved

*/

#include <windows.h>
#include <win32.h>
#include <verinfo.h>           // to get rup and MMVERSION
#include "mmsystem.h"
#include "msviddrv.h"
#include <vfw.h>
#include "msvideoi.h"
#ifdef _WIN32
#include "profile.h"
#endif

#include "debug.h"

/*
 * we have to allow the compman dll to perform load and unload
 * processing - among other things, it has a critsec that needs to
 * be initialised and freed
 */
#ifdef _WIN32
extern BOOL     WINAPI ICDllEntryPoint(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
#else
extern BOOL FAR PASCAL ICDllEntryPoint(DWORD dwReason, HINSTANCE hinstDLL, WORD	wDS, WORD wHeapSize, DWORD dwReserved1, WORD wReserved2);
#endif

//
//
//
#ifndef _WIN32
extern void FAR PASCAL videoCleanup(HTASK hTask);
#else
    #define videoCleanup(hTask) // Nothing to do for 32 bit code
#endif
extern void FAR PASCAL DrawDibCleanup(HTASK hTask);
extern void FAR PASCAL ICCleanup(HTASK hTask);

//--------------------------------------------------------------------------;
//
//
//  -- ==  DLL Initialization entry points  == --
//
//
//--------------------------------------------------------------------------;

/*****************************************************************************
 * Variables
 *
 ****************************************************************************/

HINSTANCE ghInst;                         // our module handle
BOOL gfIsRTL;

// dont change this without changing DRAWDIB\PROFDISP.C & MSVIDEO.RC
#define IDS_ISRTL 4003

#ifdef _WIN32
/*****************************************************************************
 * @doc INTERNAL VIDEO
 *
 * DLLEntryPoint - Standard 32-bit DLL entry point.
 *
 ****************************************************************************/

BOOL WINAPI DLLEntryPoint (
   HINSTANCE hInstance,
   ULONG Reason,
   LPVOID pv)
{
    BOOL fReturn = TRUE;

    switch (Reason)
    {
        TCHAR    ach[2];

	case DLL_PROCESS_ATTACH:
	    DbgInitialize(TRUE);

	    ghInst = hInstance;
	    LoadString(ghInst, IDS_ISRTL, ach, sizeof(ach)/sizeof(TCHAR));
	    gfIsRTL = ach[0] == TEXT('1');

	    DisableThreadLibraryCalls(hInstance);

	    fReturn = ICDllEntryPoint(hInstance, Reason, pv);

            break;

        case DLL_PROCESS_DETACH:
	    DrawDibCleanup(NULL);

	    ICCleanup(NULL);

	    ICDllEntryPoint(hInstance, Reason, pv);

	    videoCleanup(NULL);

	    CloseKeys();

	    break;

        //case DLL_THREAD_DETACH:
        //    break;

        //case DLL_THREAD_ATTACH:
        //    break;
    }

    return TRUE;
}

#else
//--------------------------------------------------------------------------;
//
//  BOOL DllEntryPoint
//
//  Description:
//	This is a special 16-bit entry point called by the Chicago kernel
//	for thunk initialization and cleanup.  It is called on each usage
//	increment or decrement.  Do not call GetModuleUsage within this
//	function as it is undefined whether the usage is updated before
//	or after this DllEntryPoint is called.
//
//  Arguments:
//	DWORD dwReason:
//		1 - attach (usage increment)
//		0 - detach (usage decrement)
//
//	HINSTANCE hinst:
//
//	WORD wDS:
//
//	WORD wHeapSize:
//
//	DWORD dwReserved1:
//
//	WORD wReserved2:
//
//  Return (BOOL):
//
//  Notes:
//	DAYTONA 16-bit builds (ie, WOW):
//	    We call this function from LibEntry.asm.  Daytona WOW does not
//	    call this function directly.  Since we only call it from
//	    LibEntry and WEP, cUsage just bounces between 0 and 1.
//
//	CHICAGO 16-bit builds:
//	    The Chicago kernel calls this directly for every usage increment
//	    and decrement.  cUsage will track the usages and init or terminate
//	    appropriately.
//
//  History:
//      07/07/94    [frankye]
//
//--------------------------------------------------------------------------;

BOOL FAR PASCAL _export DllEntryPoint
(
 DWORD	    dwReason,
 HINSTANCE  hInstance,
 WORD	    wDS,
 WORD	    wHeapSize,
 DWORD	    dwReserved1,
 WORD	    wReserved2
)
{
    static UINT cUsage = 0;

    switch (dwReason)
    {
	case 1:
	{
	    //
	    //	Usage increment
	    //
	    cUsage++;

	    ASSERT( 0 != cUsage );
	
	    if (1 == cUsage)
	    {
		TCHAR ach[2];
		DbgInitialize(TRUE);
		ghInst = hInstance;
		LoadString(ghInst, IDS_ISRTL, ach, sizeof(ach)/sizeof(TCHAR));
		gfIsRTL = ach[0] == TEXT('1');
	    }
	
	    //
	    //	Call ICProcessAttach on _every_ usage increment.  On Chicago,
	    //	the ICM stuff needs to be aware of all processes that load
	    //	and free this dll.  The only way to do this is to allow it to
	    //	look at stuff on every usage delta.
	    //
	    ICProcessAttach();

	    return TRUE;
	}
	
	case 0:
	{
	    //
	    //	Usage decrement
	    //
	    ASSERT( 0 != cUsage );
	
	    cUsage--;

	    if (0 == cUsage)
	    {
		DrawDibCleanup(NULL);
		ICCleanup(NULL);
	    }
	
	    //
	    //	Call ICProcessDetach on _every_ usage increment.  On Chicago,
	    //	the ICM stuff needs to be aware of all processes that load
	    //	and free this dll.  The only way to do this is to allow it to
	    //	look at stuff on every usage delta.
	    //
            ICProcessDetach();
	
	    if (0 == cUsage)
	    {
		videoCleanup(NULL);
	    }

	    return TRUE;
	}

    }
    return TRUE;
}

#endif

//--------------------------------------------------------------------------;
//
//
//
//
//--------------------------------------------------------------------------;

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | VideoForWindowsVersion | This function returns the version
 *   of the Microsoft Video for Windows software.
 *
 * @rdesc Returns a DWORD version, the hiword is the product version the
 *  loword is the minor revision.
 *
 * @comm currently returns 0x010A00## (1.10.00.##) ## is the internal build
 *      number.
 *
 ****************************************************************************/
#if 0
#ifdef rup
    #define MSVIDEO_VERSION     (0x01000000l+rup)       // 1.00.00.##
#else
    #define MSVIDEO_VERSION     (0x01000000l)           // 1.00.00.00
#endif
#else
    #define MSVIDEO_VERSION     (0x0L+(((DWORD)MMVERSION)<<24)+(((DWORD)MMREVISION)<<16)+((DWORD)MMRELEASE))
#endif

DWORD FAR PASCAL VideoForWindowsVersion(void)
{
    return MSVIDEO_VERSION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\video\libentry.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   DLLENTRY.ASM
;
;   simulates the NT DllEntryPoint call for a Win16 DLL
;
;   Copyright (c) Microsoft Corporation 1989, 1990. All rights reserved.
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        PMODE = 1
        ?PLM=1  ; pascal call convention
        ?WIN=0  ; NO! Windows prolog/epilog code
        .286

        .xlist
        include cmacros.inc
        .list

        externFP DllEntryPoint
        externFP LocalInit

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;
; Stuff needed to avoid the C runtime coming in, and init the windows
; reserved parameter block at the base of DGROUP
;
; NOTE if you need the 'C' startup dont use this file.
;
;-----------------------------------------------------------------------;

if 1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

sBegin  Data
        assumes ds,Data

        DD  0           ; So null pointers get 0
        DW  5           ; number of reserved ptrs
globalW pLocalHeap,0    ; Local heap pointer
globalW pAtomTable,0    ; Atom table pointer
globalW pStackTop,0     ; top of stack
globalW pStackMin,0     ; minimum value of SP
globalW pStackBot,0     ; bottom of stack

public  __acrtused
	__acrtused = 1

sEnd        Data

endif;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

sBegin  CodeSeg
	assumes cs,CodeSeg
        assumes ds,Data
        assumes es,nothing

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used)
; Returns:
;       AX = TRUE if success
; History:
;       06-27-89 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
	assumes ds,nothing
	assumes es,nothing

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
        jcxz    @f
        cCall   LocalInit,<0,0,cx>
@@:
ifdef DAYTONA
	cCall   DllEntryPoint, <1, di, ds, cx, 0, 0, 0>
endif
cEnd

;--------------------------Private-Routine-----------------------------;
;
; WEP - called when DLL is unloaded
;
; History:
;       06-27-89 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
	assumes ds,nothing
	assumes es,nothing

cProc   WEP, <FAR, PUBLIC, PASCAL>, <ds>
        ParmW  fSystemExit
cBegin
        ;
        ;   HEY dont cleanup if windows is going down.
        ;
        mov     ax,fSystemExit
        or      ax,ax
;;;     jnz     just_exit

        mov     ax,DataBASE
        mov     ds,ax
        assumes ds,Data

ifdef DAYTONA
	cCall   DllEntryPoint, <0, di, ds, cx, 0, 0, 0>
endif
just_exit:
cEnd

sEnd CodeSeg

        end LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\video\msvideoi.h ===
/****************************************************************************/
/*                                                                          */
/*        MSVIDEOI.H - Internal Include file for Video APIs                 */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1992, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifdef BUILDDLL
#undef WINAPI
#define WINAPI FAR PASCAL _loadds
#endif

/****************************************************************************

                   Digital Video Driver Structures

****************************************************************************/

#define MAXVIDEODRIVERS 10

/****************************************************************************

                            Globals

****************************************************************************/

extern UINT      wTotalVideoDevs;                  // total video devices
// The module handle is used in drawdib to load strings from the resource file
extern HINSTANCE ghInst;                           // our module handle
extern BOOL gfIsRTL;
extern SZCODE szVideo[];
extern SZCODE szSystemIni[];
extern SZCODE szDrivers[];

// If the following structure changes, update AVICAP and AVICAP.32 also!!!
typedef struct tCapDriverInfo {
   TCHAR szKeyEnumName[MAX_PATH];
   TCHAR szDriverName[MAX_PATH];
   TCHAR szDriverDescription[MAX_PATH];
   TCHAR szDriverVersion[80];
   TCHAR szSoftwareKey[MAX_PATH];
   DWORD dnDevNode;         // Set if this is a PnP device
   BOOL  fOnlySystemIni;    // If the [path]drivername is only in system.ini
   BOOL  fDisabled;         // User has disabled driver in the control panel
   BOOL  fActive;           // Reserved
} CAPDRIVERINFO, FAR *LPCAPDRIVERINFO;

/* internal video function prototypes */

#ifdef _WIN32
/*
 * don't lock pages in NT
 */
#define HugePageLock(x, y)		(TRUE)
#define HugePageUnlock(x, y)
#else

BOOL FAR PASCAL HugePageLock(LPVOID lpArea, DWORD dwLength);
void FAR PASCAL HugePageUnlock(LPVOID lpArea, DWORD dwLength);

#define videoGetErrorTextW videoGetErrorText

#endif

/****************************************************************************
****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\video\msviddrv.h ===
/****************************************************************************/
/*                                                                          */
/*        MSVIDDRV.H - Include file for messages to video capture drivers   */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1995, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MSVIDDRV
#define _INC_MSVIDDRV	50	/* version number */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****************************************************************************

                 Digital Video Messages (DVM_)

****************************************************************************/

// General messages
#define DVM_START                         DRV_USER
#define DVM_GETERRORTEXT                  (DVM_START + 0)
#define DVM_GETVIDEOAPIVER                (DVM_START + 1)

// This value increments each time the API changes
// It is passed to the driver in the DRV_OPEN message.
#define VIDEOAPIVERSION 		4

// General messages applicable to all channel types
#define DVM_DIALOG			(DVM_START + 100)
#define DVM_CONFIGURESTORAGE		(DVM_START + 101)
#define DVM_GET_CHANNEL_CAPS         	(DVM_START + 102)
#define DVM_UPDATE         		(DVM_START + 103)

// Single frame msg
#define DVM_FRAME			(DVM_START + 200)

// stream messages
#define DVM_STREAM_MSG_START            (DVM_START + 300)
#define DVM_STREAM_MSG_END              (DVM_START + 399)

#define DVM_STREAM_ADDBUFFER            (DVM_START + 300)
#define DVM_STREAM_FINI                 (DVM_START + 301)
#define DVM_STREAM_GETERROR             (DVM_START + 302)
#define DVM_STREAM_GETPOSITION          (DVM_START + 303)
#define DVM_STREAM_INIT                 (DVM_START + 304)
#define DVM_STREAM_PREPAREHEADER        (DVM_START + 305)
#define DVM_STREAM_RESET                (DVM_START + 306)
#define DVM_STREAM_START                (DVM_START + 307)
#define DVM_STREAM_STOP                 (DVM_START + 308)
#define DVM_STREAM_UNPREPAREHEADER      (DVM_START + 309)

// Following added post VFW1.1a, but are now obsolete
#define DVM_STREAM_ALLOCHDRANDBUFFER    (DVM_START + 310)
#define DVM_STREAM_FREEHDRANDBUFFER     (DVM_START + 311)
// The 2 messages above will be removed once the ALLOCBUFFER code is ready

// Following added for Win95 and NTPPC
#define DVM_STREAM_ALLOCBUFFER          (DVM_START + 312)
#define DVM_STREAM_FREEBUFFER           (DVM_START + 313)

// NOTE that DVM_CONFIGURE numbers will start at 0x1000 (for configure API)


/****************************************************************************

                            Open Definitions

****************************************************************************/
#define OPEN_TYPE_VCAP mmioFOURCC('v', 'c', 'a', 'p')

// The following structure is the same as IC_OPEN
// to allow compressors and capture devices to share
// the same DriverProc.

typedef struct tag_video_open_parms {
    DWORD               dwSize;         // sizeof(VIDEO_OPEN_PARMS)
    FOURCC              fccType;        // 'vcap'
    FOURCC              fccComp;        // unused
    DWORD               dwVersion;      // version of msvideo opening you
    DWORD               dwFlags;        // channel type
    DWORD               dwError;        // if open fails, this is why
    LPVOID              pV1Reserved;    // Reserved
    LPVOID              pV2Reserved;    // Reserved
    DWORD               dnDevNode;      // Devnode for PnP devices
} VIDEO_OPEN_PARMS, FAR * LPVIDEO_OPEN_PARMS;

typedef struct tag_video_geterrortext_parms {
       DWORD  dwError;          // The error number to identify
#ifdef _WIN32
       LPWSTR lpText;		// Text buffer to fill
#else
       LPSTR lpText;		// Text buffer to fill
#endif
       DWORD  dwLength;		// Size of text buffer in characters
} VIDEO_GETERRORTEXT_PARMS, FAR * LPVIDEO_GETERRORTEXT_PARMS;

typedef struct tag_video_stream_init_parms {
       DWORD  dwMicroSecPerFrame;
       DWORD_PTR  dwCallback;
       DWORD_PTR  dwCallbackInst;
       DWORD  dwFlags;
       DWORD_PTR  hVideo;
} VIDEO_STREAM_INIT_PARMS, FAR * LPVIDEO_STREAM_INIT_PARMS;

typedef struct tag_video_configure_parms {
       LPDWORD  lpdwReturn;	// Return parameter from configure MSG.
       LPVOID	lpData1;	// Pointer to data 1.
       DWORD	dwSize1;	// size of data buffer 1.
       LPVOID	lpData2;	// Pointer to data 2.
       DWORD	dwSize2;	// size of data buffer 2.
} VIDEOCONFIGPARMS, FAR * LPVIDEOCONFIGPARMS;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDDRV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\video\msvideo.h ===
/****************************************************************************/
/*                                                                          */
/*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY   */
/*  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE     */
/*  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR   */
/*  PURPOSE.								    */
/*        MSVIDEO.H - Include file for Video APIs                           */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1994, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MSVIDEO
#define _INC_MSVIDEO    50      /* version number */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

// begin_vfw32

#ifndef _RCINVOKED

// end_vfw32

#ifdef BUILDDLL                         /* ;Internal */
#undef WINAPI                           /* ;Internal */
#define WINAPI FAR PASCAL _loadds       /* ;Internal */
#endif                                  /* ;Internal */

// begin_vfw32

/* video data types */
DECLARE_HANDLE(HVIDEO);                 // generic handle
typedef HVIDEO FAR * LPHVIDEO;
#endif                                  // ifndef RCINVOKED

/****************************************************************************

                        version api

****************************************************************************/

DWORD FAR PASCAL VideoForWindowsVersion(void);

/****************************************************************************

                            Error Return Values

****************************************************************************/
#define DV_ERR_OK               (0)                  /* No error */
#define DV_ERR_BASE             (1)                  /* Error Base */
#define DV_ERR_NONSPECIFIC      (DV_ERR_BASE)
#define DV_ERR_BADFORMAT        (DV_ERR_BASE + 1)
				/* unsupported video format */
#define DV_ERR_STILLPLAYING     (DV_ERR_BASE + 2)
				/* still something playing */
#define DV_ERR_UNPREPARED       (DV_ERR_BASE + 3)
				/* header not prepared */
#define DV_ERR_SYNC             (DV_ERR_BASE + 4)
				/* device is synchronous */
#define DV_ERR_TOOMANYCHANNELS  (DV_ERR_BASE + 5)
				/* number of channels exceeded */
#define DV_ERR_NOTDETECTED	(DV_ERR_BASE + 6)    /* HW not detected */
#define DV_ERR_BADINSTALL	(DV_ERR_BASE + 7)    /* Can not get Profile */
#define DV_ERR_CREATEPALETTE	(DV_ERR_BASE + 8)
#define DV_ERR_SIZEFIELD	(DV_ERR_BASE + 9)
#define DV_ERR_PARAM1		(DV_ERR_BASE + 10)
#define DV_ERR_PARAM2		(DV_ERR_BASE + 11)
#define DV_ERR_CONFIG1		(DV_ERR_BASE + 12)
#define DV_ERR_CONFIG2		(DV_ERR_BASE + 13)
#define DV_ERR_FLAGS		(DV_ERR_BASE + 14)
#define DV_ERR_13		(DV_ERR_BASE + 15)

#define DV_ERR_NOTSUPPORTED     (DV_ERR_BASE + 16)   /* function not suported */
#define DV_ERR_NOMEM            (DV_ERR_BASE + 17)   /* out of memory */
#define DV_ERR_ALLOCATED        (DV_ERR_BASE + 18)   /* device is allocated */
#define DV_ERR_BADDEVICEID      (DV_ERR_BASE + 19)
#define DV_ERR_INVALHANDLE      (DV_ERR_BASE + 20)
#define DV_ERR_BADERRNUM        (DV_ERR_BASE + 21)
#define DV_ERR_NO_BUFFERS       (DV_ERR_BASE + 22)   /* out of buffers */

#define DV_ERR_MEM_CONFLICT     (DV_ERR_BASE + 23)   /* Mem conflict detected */
#define DV_ERR_IO_CONFLICT      (DV_ERR_BASE + 24)   /* I/O conflict detected */
#define DV_ERR_DMA_CONFLICT     (DV_ERR_BASE + 25)   /* DMA conflict detected */
#define DV_ERR_INT_CONFLICT     (DV_ERR_BASE + 26)   /* Interrupt conflict detected */
#define DV_ERR_PROTECT_ONLY     (DV_ERR_BASE + 27)   /* Can not run in standard mode */
#define DV_ERR_LASTERROR        (DV_ERR_BASE + 27)

//#define DV_IDS_PROFILING        (DV_ERR_BASE + 900)
//#define DV_IDS_LISTBOX          (DV_ERR_BASE + 901)

#define DV_ERR_USER_MSG         (DV_ERR_BASE + 1000) /* Hardware specific errors */

/****************************************************************************

                         Callback Messages

Note that the values for all installable driver callback messages are
identical, (ie. MM_DRVM_DATA has the same value for capture drivers,
installable video codecs, and the audio compression manager).
****************************************************************************/
#ifndef _RCINVOKED

#ifndef MM_DRVM_OPEN
#define MM_DRVM_OPEN       0x3D0
#define MM_DRVM_CLOSE      0x3D1
#define MM_DRVM_DATA       0x3D2
#define MM_DRVM_ERROR      0x3D3
#endif

#define DV_VM_OPEN         MM_DRVM_OPEN         // Obsolete messages
#define DV_VM_CLOSE        MM_DRVM_CLOSE
#define DV_VM_DATA         MM_DRVM_DATA
#define DV_VM_ERROR        MM_DRVM_ERROR

/****************************************************************************

                         Structures

****************************************************************************/
/* video data block header */
typedef struct videohdr_tag {
    LPBYTE      lpData;                 /* pointer to locked data buffer */
    DWORD       dwBufferLength;         /* Length of data buffer */
    DWORD       dwBytesUsed;            /* Bytes actually used */
    DWORD       dwTimeCaptured;         /* Milliseconds from start of stream */
    DWORD       dwUser;                 /* for client's use */
    DWORD       dwFlags;                /* assorted flags (see defines) */
    DWORD       dwReserved[4];          /* reserved for driver */
} VIDEOHDR, NEAR *PVIDEOHDR, FAR * LPVIDEOHDR;

/* dwFlags field of VIDEOHDR */
#define VHDR_DONE       0x00000001  /* Done bit */
#define VHDR_PREPARED   0x00000002  /* Set if this header has been prepared */
#define VHDR_INQUEUE    0x00000004  /* Reserved for driver */
#define VHDR_KEYFRAME   0x00000008  /* Key Frame */
#define VHDR_VALID      0x0000000F  /* valid flags */     /* ;Internal */

/* Channel capabilities structure */
typedef struct channel_caps_tag {
    DWORD       dwFlags;                /* Capability flags*/
    DWORD       dwSrcRectXMod;          /* Granularity of src rect in x */
    DWORD       dwSrcRectYMod;          /* Granularity of src rect in y */
    DWORD       dwSrcRectWidthMod;      /* Granularity of src rect width */
    DWORD       dwSrcRectHeightMod;     /* Granularity of src rect height */
    DWORD       dwDstRectXMod;          /* Granularity of dst rect in x */
    DWORD       dwDstRectYMod;          /* Granularity of dst rect in y */
    DWORD       dwDstRectWidthMod;      /* Granularity of dst rect width */
    DWORD       dwDstRectHeightMod;     /* Granularity of dst rect height */
} CHANNEL_CAPS, NEAR *PCHANNEL_CAPS, FAR * LPCHANNEL_CAPS;

/* dwFlags of CHANNEL_CAPS */
#define VCAPS_OVERLAY       0x00000001      /* overlay channel */
#define VCAPS_SRC_CAN_CLIP  0x00000002      /* src rect can clip */
#define VCAPS_DST_CAN_CLIP  0x00000004      /* dst rect can clip */
#define VCAPS_CAN_SCALE     0x00000008      /* allows src != dst */

// end_vfw32

/****************************************************************************

   videoXXXX API's are only available on Win 3.x!  they are Not in Win32

****************************************************************************/

#if !defined _WIN32

/****************************************************************************

                        video APIs

****************************************************************************/


DWORD WINAPI videoGetNumDevs(void);

DWORD WINAPI videoOpen  (LPHVIDEO lphVideo,
              DWORD dwDevice, DWORD dwFlags);
DWORD WINAPI videoClose (HVIDEO hVideo);
DWORD WINAPI videoDialog(HVIDEO hVideo, HWND hWndParent, DWORD dwFlags);
DWORD WINAPI videoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps,
                DWORD dwSize);
DWORD WINAPI videoUpdate (HVIDEO hVideo, HWND hWnd, HDC hDC);
DWORD WINAPI videoConfigure (HVIDEO hVideo, UINT msg, DWORD dwFlags,
		LPDWORD lpdwReturn, LPVOID lpData1, DWORD dwSize1,
                LPVOID lpData2, DWORD dwSize2);

#ifdef UNICODE
DWORD WINAPI videoConfigureStorageA(HVIDEO hVideo,
                      LPSTR lpstrIdent, DWORD dwFlags);

DWORD WINAPI videoConfigureStorageW(HVIDEO hVideo,
			LPWSTR lpstrIdent, DWORD dwFlags);
#define videoConfigureStorage  videoConfigureStorageW
#else
#define videoConfigureStorage  videoConfigureStorageA
#else
DWORD WINAPI videoConfigureStorage(HVIDEO hVideo,
                      LPSTR lpstrIdent, DWORD dwFlags);
#define videoConfigureStorageA videoConfigureStorage
#endif // !UNICODE
DWORD WINAPI videoFrame(HVIDEO hVideo, LPVIDEOHDR lpVHdr);
DWORD WINAPI videoMessage(HVIDEO hVideo, UINT msg, LPARAM dwP1, LPARAM dwP2);

/* streaming APIs */
DWORD WINAPI videoStreamAddBuffer(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamGetError(HVIDEO hVideo, LPDWORD lpdwErrorFirst,
        LPDWORD lpdwErrorLast);

#ifdef UNICODE
DWORD WINAPI videoGetErrorTextA(HVIDEO hVideo, UINT wError,
              LPSTR lpText, UINT wSize);

DWORD WINAPI videoGetErrorTextW(HVIDEO hVideo, UINT wError,
	        LPWSTR lpText, UINT wSize);
#define videoGetErrorText  videoGetErrorTextW
#else
#define videoGetErrorText  videoGetErrorTextA
#else
DWORD WINAPI videoGetErrorText(HVIDEO hVideo, UINT wError,
              LPSTR lpText, UINT wSize);
#define videoGetErrorTextA videoGetErrorText
#endif // !UNICODE

DWORD WINAPI videoStreamGetPosition(HVIDEO hVideo, MMTIME FAR* lpInfo,
              DWORD dwSize);
DWORD WINAPI videoStreamInit(HVIDEO hVideo,
              DWORD dwMicroSecPerFrame, DWORD_PTR dwCallback,
              DWORD_PTR dwCallbackInst, DWORD dwFlags);
DWORD WINAPI videoStreamFini(HVIDEO hVideo);
DWORD WINAPI videoStreamPrepareHeader(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamReset(HVIDEO hVideo);
DWORD WINAPI videoStreamStart(HVIDEO hVideo);
DWORD WINAPI videoStreamStop(HVIDEO hVideo);
DWORD WINAPI videoStreamUnprepareHeader(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr, DWORD dwSize);

// Added post VFW1.1a
DWORD WINAPI videoStreamAllocHdrAndBuffer(HVIDEO hVideo,
              LPVIDEOHDR FAR * plpVHdr, DWORD dwSize);
DWORD WINAPI videoStreamFreeHdrAndBuffer(HVIDEO hVideo,
              LPVIDEOHDR lpVHdr);


#endif // ! _WIN32

// begin_vfw32

/****************************************************************************

			API Flags

****************************************************************************/

// Types of channels to open with the videoOpen function
#define VIDEO_EXTERNALIN		0x0001
#define VIDEO_EXTERNALOUT		0x0002
#define VIDEO_IN			0x0004
#define VIDEO_OUT			0x0008

// Is a driver dialog available for this channel?
#define VIDEO_DLG_QUERY			0x0010

// videoConfigure (both GET and SET)
#define VIDEO_CONFIGURE_QUERY   	0x8000

// videoConfigure (SET only)
#define VIDEO_CONFIGURE_SET		0x1000

// videoConfigure (GET only)
#define VIDEO_CONFIGURE_GET		0x2000
#define VIDEO_CONFIGURE_QUERYSIZE	0x0001

#define VIDEO_CONFIGURE_CURRENT		0x0010
#define VIDEO_CONFIGURE_NOMINAL		0x0020
#define VIDEO_CONFIGURE_MIN		0x0040
#define VIDEO_CONFIGURE_MAX		0x0080

/****************************************************************************

			CONFIGURE MESSAGES

****************************************************************************/
#define DVM_USER                        0X4000

#define DVM_CONFIGURE_START		0x1000
#define DVM_CONFIGURE_END		0x1FFF

#define DVM_PALETTE			(DVM_CONFIGURE_START + 1)
#define DVM_FORMAT			(DVM_CONFIGURE_START + 2)
#define DVM_PALETTERGB555		(DVM_CONFIGURE_START + 3)
#define DVM_SRC_RECT    		(DVM_CONFIGURE_START + 4)
#define DVM_DST_RECT    		(DVM_CONFIGURE_START + 5)

#endif  /* ifndef _RCINVOKED */

// end_vfw32

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDEO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\video\thunk32.c ===
//==========================================================================;
//  COMMENTS DO NOT YET APPLY TO MSVFW32.DLL
//  thunk32.c
//
//  Copyright (c) 1991-1994 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//      This module contains routines for thunking the
//      ICM APIs (messages) from 16-bit Windows to 32-bit WOW.
//
//  History:
//
//==========================================================================;

/*

    WOW Thunking design:

        Thunks are generated as follows :

        16-bit :
           acmBootDrivers->acmInitThunks :

               Generate calls to 32-bit drivers if we're in WOW call across
               to KERNEL to find thunking entry points.

               If we're thunking 'load' all the 32-bit ACM drivers as well as
               the 16-bit ones.

               Priority is always to find a 32-bit driver first but this is
               done via searching for one on open.

               The internal flag ACM_DRIVERADDF_32BIT is specified when
               calling IDriverAdd and this flag is stored in the ACMDRIVERID
               structure.

           IDriverAdd->IDriverLoad->IDriverLoad32

               The 16-bit side calls the 32-bit side passing in the driver
               alias which is used to compare against the aliases on the 32
               bit side and the 32-bit HACMDRIVERID is passed back for the
               relevant driver and stored in the hdrvr field of the
               ACMDRIVERID structure.

           IDriverOpen->IDriverOpen32

               The parameters are passed to the 32-bit side using the hdrvr
               field deduced from the HACMDRIVERID as the 32-bit HACMDRIVERID.

           IDriverMessageId->IDriverMessageId32 :

               If the driver is 32-bit (as identified in the ACMDRIVERID
               structure) then call IDriverMessageId32.  The hadid for
               the 32-bit driver is stored in the hdrvr field of ACMDRIVERID
               on the 16-bit side.

           IDriverMessage->IDriverMessage32

               If the driver is 32-bit (as identified in the ACMDRIVERID
               structure pointed to by the ACMDRIVER structure) then call
               IDriverMessage32.  The had for the 32-bit driver is stored
               in the hdrvr field of ACMDRIVER on the 16-bit side.

           Stream headers

               These must be persistent on the 32-bit side too and kept
               in synch.

               They are allocated on the 32-bit side for ACMDM_STREAM_PREPARE
               and freed on ACMDM_STREAM_UNPREPARE.  While in existence
               the 32-bit stream header is stored in the dwDriver field in

*/

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <mmreg.h>
#include <memory.h>
#include <win32.h>
#include <vfw.h>
#include <msviddrv.h>
#include <msvideoi.h>
#ifdef WIN32
    #include <wownt32.h>
    #include <stdlib.h>        // for mbstowcs and wcstombs
#endif // WIN32
#include "compmn16.h"

//
// pick up the function definitions
//

int thunkDebugLevel = 1;

#include "vidthunk.h"

/* -------------------------------------------------------------------------
** Handle and memory mapping functions.
** -------------------------------------------------------------------------
*/
LPWOWHANDLE32          lpWOWHandle32;
LPWOWHANDLE16          lpWOWHandle16;
LPWOWCALLBACK16        lpWOWCallback16;
LPGETVDMPOINTER        GetVdmPointer;
int                    ThunksInitialized;

//
//  16-bit structures
//

typedef struct {
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO16;

//
//  Useful functions
//

//
//  CopyAlloc - allocate a new piece of memory, and copy the data in
//  Must use LocalFree to release the memory later
//
PVOID CopyAlloc(PVOID   pvSrc, UINT    uSize)
{
    PVOID   pvDest;

    pvDest = (PVOID)LocalAlloc(LMEM_FIXED, uSize);

    if (pvDest != NULL) {
        CopyMemory(pvDest, pvSrc, uSize);
    }

    return pvDest;
}

/*
 *  Copy data from source to dest where source is a 32bit pointer
 *  and dest is a 16bit pointer
 */
void CopyTo16Bit(LPVOID Dest16, LPVOID Src32, DWORD Length)
{
    PVOID Dest32;

    if (Src32 == NULL) {
        return;
    }

    Dest32 = GetVdmPointer((DWORD)Dest16, Length, TRUE);

    CopyMemory(Dest32, Src32, Length);
}


/*
 *  Copy data from source to dest where source is a 16bit pointer
 *  and dest is a 32bit pointer
 */
PVOID CopyTo32Bit(LPVOID Dest32, LPVOID Src16, DWORD Length)
{
    PVOID Src32;

    if (Src16 == NULL) {
        return NULL;
    }

    Src32 = GetVdmPointer((DWORD)Src16, Length, TRUE);

    CopyMemory(Dest32, Src32, Length);
    return(Src32);
}

/*
 *  Copy data from source to dest where source is a 16bit pointer
 *  and dest is a 32bit pointer ONLY if the source is not aligned
 *
 *  Returns which pointer to use (src or dest)
 */
LPVOID CopyIfNotAligned(LPVOID Dest32, LPVOID Src16, DWORD Length)
{
    PVOID Src32;

    if (Src16 == NULL) {
        return Dest32;
    }

    Src32 = GetVdmPointer((DWORD)Src16, Length, TRUE);

    CopyMemory(Dest32, Src32, Length);

    return Dest32;
}

#ifdef _INC_COMPMAN


/*--------------------------------------------------------------------------*\
|                                                                            |
| Now thunk the compman functions                                            |
|                                                                            |
|                                                                            |
|                                                                            |
|                                                                            |
\*--------------------------------------------------------------------------*/

/*
 *  Convert ICDRAWBEGIN structures
 */

INLINE STATICFN void ConvertICDRAWBEGIN(ICDRAWBEGIN *DrawBegin32,
                                        LPBITMAPINFOHEADER lpBmi,
                                        DWORD dw)
{
    ICDRAWBEGIN16 DrawBegin16;

    CopyTo32Bit(&DrawBegin16, (LPVOID)dw, sizeof(ICDRAWBEGIN16));

    DrawBegin32->dwFlags = DrawBegin16.dwFlags;
    DrawBegin32->hpal = ThunkHPAL(DrawBegin16.hpal);
    DrawBegin32->hwnd = ThunkHWND(DrawBegin16.hwnd);
    DrawBegin32->hdc = ThunkHDC(DrawBegin16.hdc);
    DrawBegin32->xDst = (int)DrawBegin16.xDst;
    DrawBegin32->yDst = (int)DrawBegin16.yDst;
    DrawBegin32->dxDst = (int)DrawBegin16.dxDst;
    DrawBegin32->dyDst = (int)DrawBegin16.dyDst;

    CopyTo32Bit(lpBmi, DrawBegin16.lpbi, sizeof(BITMAPINFOHEADER));

    DrawBegin32->lpbi = lpBmi;
    DrawBegin32->xSrc = (int)DrawBegin16.xSrc;
    DrawBegin32->ySrc = (int)DrawBegin16.ySrc;
    DrawBegin32->dxSrc = (int)DrawBegin16.dxSrc;
    DrawBegin32->dySrc = (int)DrawBegin16.dySrc;
    DrawBegin32->dwRate = DrawBegin16.dwRate;
    DrawBegin32->dwScale = DrawBegin16.dwScale;
}


/*
 *  Following logic copied from mvdm\wow32\wstruc.c - however since we
 *  don't have the usage parameter we're a bit stuck on the size of the
 *  entries.
 *
 *  See also the video for windows documentation - only a limited range of
 *  bitmap types are discussed.
 */

INT GetBMI16Size(UNALIGNED BITMAPINFOHEADER *pbmi16)
{
   int      nHdrSize;
   int      nEntSize;
   int      nEntries;
   int      nBitCount;
   DWORD    dwClrUsed;

   nHdrSize = (int)pbmi16->biSize;

  /*
   *  We don't have some of the info we need so assume RGBQUAD
   */

   nEntSize = sizeof(RGBQUAD);

   nBitCount = pbmi16->biBitCount;
   dwClrUsed = pbmi16->biClrUsed;

/* the following block of code should be this:
 *
 *  if ( nBitCount >= 9 ) { // this is how Win3.1 code says == 24
 *      nEntries = 1;
 *  }
 *  else if ( dwClrUsed ) {
 *      nEntries = dwClrUsed;
 *  }
 *  else {
 *      nEntries = 1 << nBitCount;
 *  }
 *
 *  but due to the fact that many apps don't initialize the biBitCount &
 *  biClrUsed fields (especially biClrUsed) we have to do the following
 *  sanity checking instead.  v-cjones
 */

   nEntries = 1;
   if ( nBitCount < 9 ) {
       if((nBitCount == 4) || (nBitCount == 8) || (nBitCount == 1)) {
           nEntries = 1 << nBitCount;
       }
       // sanity check for apps (lots) that don't init the dwClrUsed field
       if(dwClrUsed) {
           nEntries = (int)min((DWORD)nEntries, dwClrUsed);
       }
   }

   return ( nHdrSize + (nEntries * nEntSize) );
}

INLINE LPBITMAPINFO CopyBitmapInfo(DWORD Bi16)
{
    UNALIGNED BITMAPINFOHEADER *pbmi16;

    pbmi16 = WOW32ResolveMemory(Bi16);
    if ((int)pbmi16->biSize == 0) {
        pbmi16->biSize = sizeof(BITMAPINFOHEADER);
        DPF1(("WARNING: null bitmap info size, setting it correctly"));
    }

    return (LPBITMAPINFO)CopyAlloc((LPVOID)pbmi16, GetBMI16Size(pbmi16));
}

/*
 * Allocate a BITMAPINFO structure to contain 256 colours
 */
INLINE LPBITMAPINFO AllocBitmapInfo()
{
    return (PVOID)LocalAlloc(LMEM_FIXED, sizeof(BITMAPINFOHEADER)+
                                         (sizeof(RGBQUAD)*256));
}

INLINE LPBITMAPINFOHEADER CopyBitmapInfoHeader(DWORD Bi16)
{
    UNALIGNED BITMAPINFOHEADER *pbmi16;

    pbmi16 = WOW32ResolveMemory(Bi16);

    return (LPBITMAPINFOHEADER)CopyAlloc((LPVOID)pbmi16, pbmi16->biSize);
}



DWORD CopyICINFOTo16bit(DWORD dw, ICINFO *IcInfoCopy, DWORD Length)
{
    ICINFO16 IcInfo;
    LONG   ReturnCode;

   /*
    *  Make a copy since the behaviour of wcstombs is undefined
    *  for overlapping input and output
    */

    memcpy(&IcInfo, IcInfoCopy, FIELD_OFFSET(ICINFO, szName[0]));

   /*
    *  Massage the strings
    */

    wcstombs(IcInfo.szName,
             IcInfoCopy->szName,
             sizeof(IcInfo.szName));
    // HACK : overwrite the last five characters with "[32]\0"

    if ((IcInfo.szName[0]))
    {
        UINT n = min(sizeof(IcInfo.szName)-5, lstrlenA(IcInfo.szName));
        IcInfo.szName[n++] = '[';
        IcInfo.szName[n++] = '3';
        IcInfo.szName[n++] = '2';
        IcInfo.szName[n++] = ']';
        IcInfo.szName[n]   = '\0';
    }

    wcstombs(IcInfo.szDescription,
             IcInfoCopy->szDescription,
             sizeof(IcInfo.szDescription));
    // HACK : overwrite the last five characters with "[32]\0"
    if ((IcInfo.szDescription[0]))
    {
        UINT n = min(sizeof(IcInfo.szDescription)-5, lstrlenA(IcInfo.szDescription));
        IcInfo.szDescription[n++] = '[';
        IcInfo.szDescription[n++] = '3';
        IcInfo.szDescription[n++] = '2';
        IcInfo.szDescription[n++] = ']';
        IcInfo.szDescription[n]   = '\0';
    }

    wcstombs(IcInfo.szDriver,
             IcInfoCopy->szDriver,
             sizeof(IcInfo.szDriver));


    IcInfo.dwSize = sizeof(IcInfo);

    ReturnCode = min(Length, IcInfo.dwSize);

    CopyTo16Bit((LPVOID)dw, &IcInfo, ReturnCode);

    return ReturnCode;
}

STATICFN DWORD DoICM_DecompressX(DWORD hic, UINT msg, DWORD dwP1, DWORD dwP2)
{
   /*
    *  We need to convert the various fields in the ICDECOMPRESS/EX
    *  structure(s).  Fortunately(?) the EX structure is a simple
    *  extension.
    */
    typedef struct {
        //
        // same as ICM_DECOMPRESS
        //
        DWORD               dwFlags;

        LPBITMAPINFOHEADER  lpbiSrc;    // BITMAPINFO of compressed data
        LPVOID              lpSrc;      // compressed data

        LPBITMAPINFOHEADER  lpbiDst;    // DIB to decompress to
        LPVOID              lpDst;      // output data

        //
        // new for ICM_DECOMPRESSEX
        //
        short               xDst;       // destination rectangle
        short               yDst;
        short               dxDst;
        short               dyDst;

        short               xSrc;       // source rectangle
        short               ySrc;
        short               dxSrc;
        short               dySrc;

    } ICDECOMPRESSEX16;

    ICDECOMPRESSEX16 UNALIGNED     *lpicdmpr16;
    ICDECOMPRESSEX                  ICDecompressEx;
    DWORD                           l;

    /* Copy the standard or extended structure */
    lpicdmpr16 = GetVdmPointer( dwP1, dwP2, TRUE );
    ICDecompressEx.dwFlags = lpicdmpr16->dwFlags;


    ICDecompressEx.lpbiSrc = (LPBITMAPINFOHEADER)CopyBitmapInfo((DWORD)lpicdmpr16->lpbiSrc);
    if (NULL == ICDecompressEx.lpbiSrc) {
        return (DWORD)ICERR_MEMORY;
    }


    ICDecompressEx.lpbiDst =  (LPBITMAPINFOHEADER)CopyBitmapInfo((DWORD)lpicdmpr16->lpbiDst);
    if (NULL == ICDecompressEx.lpbiDst) {
        LocalFree( (HLOCAL)ICDecompressEx.lpbiSrc );
        return (DWORD)ICERR_MEMORY;
    }

    ICDecompressEx.lpSrc =
        GetVdmPointer((DWORD)lpicdmpr16->lpSrc,
                  ICDecompressEx.lpbiSrc->biSizeImage, TRUE);

    ICDecompressEx.lpDst =
        GetVdmPointer((DWORD)lpicdmpr16->lpDst,
                  ICDecompressEx.lpbiDst->biSizeImage, TRUE);

    if (dwP2 == sizeof(ICDECOMPRESSEX16) ) {

        ICDecompressEx.xDst     = (int)lpicdmpr16->xDst;
        ICDecompressEx.yDst     = (int)lpicdmpr16->yDst;
        ICDecompressEx.dxDst    = (int)lpicdmpr16->dxDst;
        ICDecompressEx.dyDst    = (int)lpicdmpr16->dyDst;

        ICDecompressEx.xSrc     = (int)lpicdmpr16->xSrc;
        ICDecompressEx.ySrc     = (int)lpicdmpr16->ySrc;
        ICDecompressEx.dxSrc    = (int)lpicdmpr16->dxSrc;
        ICDecompressEx.dySrc    = (int)lpicdmpr16->dySrc;
	dwP2 = sizeof(ICDecompressEx);  // Make the size relate to 32 bit
    }


    l = ICSendMessage( (HIC)hic, (UINT)msg, (DWORD)&ICDecompressEx, dwP2 );

    if ( l == ICERR_OK) {

        CopyTo16Bit( lpicdmpr16->lpbiDst, ICDecompressEx.lpbiDst,
                     sizeof(BITMAPINFOHEADER) );
    }


    LocalFree( (HLOCAL)ICDecompressEx.lpbiSrc );
    LocalFree( (HLOCAL)ICDecompressEx.lpbiDst );

    return l;
}



/*
 *  Generate our thunks - refer to msvideo!compman.c for definitions of
 *  functions.
 *
 *  NOTE - we often rely here on the fact that most of the message
 *  parameter structures are identical for 16 and 32-bit - ie they
 *  contain DWORDs and 32-bit pointers.
 */


BOOL FAR PASCAL ICInfo32(DWORD fccType, DWORD fccHandler, ICINFO16 FAR * lpicInfo)
{
    ICINFO ReturnedICInfo;
    StartThunk(ICInfo);

    DPF2(("Calling ICInfo %4.4hs %4.4hs %8X", &fccType, &fccHandler, lpicInfo));

    ReturnedICInfo.fccHandler = 0;  // Initialise...
    ReturnCode = ICInfo(fccType, fccHandler, &ReturnedICInfo);

    CopyICINFOTo16bit((DWORD)lpicInfo, &ReturnedICInfo, sizeof(ReturnedICInfo));
    EndThunk()
}

LRESULT FAR PASCAL ICSendMessage32(DWORD hic, UINT msg, DWORD dwP1, DWORD dwP2)
{
    StartThunk(ICSendMessage);
    DPF2(("Calling ICSendMessage %4X %4X %8X %8X",
              hic, msg, dwP1, dwP2));

    switch (msg) {
    case ICM_GETSTATE:
    case ICM_SETSTATE:

        if (dwP1 == 0) {
            ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                       (UINT)msg,
                                       dwP1,
                                       dwP2);
        } else {
            PVOID pState;
           /*
            *  Create some aligned memory to return or pass on the data
            */
            pState = (PVOID)LocalAlloc(LPTR, dwP2);

            if (pState == NULL) {
                ReturnCode = ICERR_MEMORY;
            } else {

                if ((UINT)msg == ICM_SETSTATE) {
                    // Copy the data from 16 bit land
                    CopyTo32Bit(pState, (LPVOID)dwP1, dwP2);
                }
                ReturnCode = ICSendMessage((HIC)(DWORD)hic, (UINT)msg,
                                           (DWORD)pState, dwP2);

               /*
                *  Copy back the state, if the driver returned any data
                */

                if (ReturnCode > 0 && (UINT)msg == ICM_GETSTATE) {
                    CopyTo16Bit((LPVOID)dwP1, pState,
                                min((DWORD)ReturnCode, dwP2));
                }

                LocalFree((HLOCAL)pState);
            }
        }
        break;

    case ICM_GETINFO:
        {
            ICINFO IcInfo;

            ReturnCode = ICGetInfo((HIC)(DWORD)hic, &IcInfo, sizeof(IcInfo));

            if (ReturnCode != 0) {
                ReturnCode = CopyICINFOTo16bit(dwP1, &IcInfo, ReturnCode);
            }
        }


        break;

    case ICM_CONFIGURE:
    case ICM_ABOUT:

       /*
        *  dwP1 = -1 is a special value asking if config is supported,
        *  otherwise it's a window handle
        */

        ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                   (UINT)msg,
                                   dwP1 == (DWORD)-1 ?
                                       (DWORD)-1 :
                                       (DWORD)ThunkHWND(LOWORD(dwP1)),
                                   dwP2);


        break;

    case ICM_COMPRESS:
        {

            if (dwP2 != sizeof(ICCOMPRESS)) {  // validation code
                ReturnCode = ICERR_BADSIZE;
            } else {

                DWORD dwFlags;
                LPDWORD lpdwFlags16, lpckid16;
                LPBITMAPINFOHEADER  lpbih16;

                DWORD ckid;

                ICCOMPRESS IcCompress;

                ReturnCode = ICERR_OK;

                /*
                 *  We need to convert the various fields in the ICCOMPRESS
                 *  structure
                 */

                CopyTo32Bit( &IcCompress, (LPVOID)dwP1, dwP2 );

                IcCompress.lpbiInput =  (LPBITMAPINFOHEADER)CopyBitmapInfo((DWORD)IcCompress.lpbiInput);
                if (NULL == IcCompress.lpbiInput) {
                    ReturnCode = ICERR_MEMORY;
                    break;
                }

                lpbih16 = IcCompress.lpbiOutput;
                IcCompress.lpbiOutput =  (LPBITMAPINFOHEADER)CopyBitmapInfo((DWORD)IcCompress.lpbiOutput);
                if (NULL == IcCompress.lpbiOutput) {
                    LocalFree((HLOCAL)IcCompress.lpbiInput);
                    ReturnCode = ICERR_MEMORY;
                    break;
                }

                IcCompress.lpInput =
                    GetVdmPointer((DWORD)IcCompress.lpInput,
                              IcCompress.lpbiInput->biSizeImage, TRUE);

                IcCompress.lpOutput =
                    GetVdmPointer((DWORD)IcCompress.lpOutput,
                              IcCompress.lpbiOutput->biSizeImage, TRUE);

                if (IcCompress.lpbiPrev) {

                    IcCompress.lpbiPrev =  (LPBITMAPINFOHEADER)CopyBitmapInfo((DWORD)IcCompress.lpbiPrev);
                    if (NULL == IcCompress.lpbiPrev) {
                        LocalFree((HLOCAL)IcCompress.lpbiOutput);
                        LocalFree((HLOCAL)IcCompress.lpbiInput);
                        ReturnCode = ICERR_MEMORY;
                        break;
                    }

                    IcCompress.lpPrev =
                        GetVdmPointer((DWORD)IcCompress.lpPrev,
                                  IcCompress.lpbiPrev->biSizeImage, TRUE);
                }

                lpdwFlags16 = IcCompress.lpdwFlags;

                IcCompress.lpdwFlags = &dwFlags;

                if (IcCompress.lpckid != NULL) {
                    lpckid16 = IcCompress.lpckid;
                    IcCompress.lpckid = &ckid;
                }


                ReturnCode = ICSendMessage((HIC)(DWORD)hic, (UINT)msg,
                                           (DWORD)&IcCompress, dwP2);

                if (ReturnCode == ICERR_OK) {


                    CopyTo16Bit( lpbih16, IcCompress.lpbiOutput,
                                 sizeof(BITMAPINFOHEADER) );

                    if (lpdwFlags16 != NULL) {
                        CopyTo16Bit(lpdwFlags16, &dwFlags, sizeof(DWORD));
                    }

                    if (IcCompress.lpckid != NULL) {
                        CopyTo16Bit(lpckid16, &ckid, sizeof(DWORD));
                    }
                }



                /*
                ** Free the bitmap info storage regardless of the return code
                */

                if (NULL == IcCompress.lpbiPrev) {
                    LocalFree((HLOCAL)IcCompress.lpbiPrev);
                }

                LocalFree((HLOCAL)IcCompress.lpbiOutput);
                LocalFree((HLOCAL)IcCompress.lpbiInput);
            }

        }
        break;


    case ICM_DECOMPRESS_SET_PALETTE:
	// takes one (optionally null) bitmapinfo
	{
	    LPBITMAPINFO bmi = 0;

	    if (dwP1 != 0) {
		bmi = CopyBitmapInfo(dwP1);
	    }

	    ReturnCode = ICSendMessage((HIC)(DWORD)hic,
				       (UINT)msg,
				       (DWORD)bmi,
				       (DWORD)0);
            if (bmi != NULL) {
                LocalFree((HLOCAL)bmi);
            }

	    break;
	}



    case ICM_COMPRESS_GET_SIZE:
    case ICM_COMPRESS_BEGIN:
    case ICM_COMPRESS_QUERY:

    case ICM_DECOMPRESS_BEGIN:
    case ICM_DECOMPRESS_GET_PALETTE:
    case ICM_DECOMPRESS_QUERY:

        {
            LPBITMAPINFO bmi1, bmi2;

	    bmi1 = CopyBitmapInfo(dwP1);

            if (dwP2 != 0) {
                bmi2 = CopyBitmapInfo(dwP2);
            } else {
                bmi2 = NULL;
            }

            if (bmi1 == NULL || bmi2 == NULL && dwP2 != 0) {
                ReturnCode =
                    (UINT)msg == ICM_COMPRESS_GET_SIZE ? 0 : ICERR_MEMORY;
            } else {

                ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                           (UINT)msg,
                                           (DWORD)bmi1,
                                           (DWORD)bmi2);

                if (bmi2 != NULL) {

                    // We might have to return data to the 16 bit side.
                    // The messages for which we have to do this are:
                    //      ICM_DECOMPRESS_QUERY (iff retcode == ICERR_OK)
                    //      ICM_DECOMPRESS_GET_PALETTE (iff retcode >= 0)

                    if (((ReturnCode == ICERR_OK) && (msg == ICM_DECOMPRESS_QUERY))
                        || ((ReturnCode >= 0) && (msg == ICM_DECOMPRESS_GET_PALETTE)))
                    {
                        CopyTo16Bit((LPVOID)dwP2, bmi2, GetBMI16Size((LPBITMAPINFOHEADER)bmi2));
                    }
                    LocalFree((HLOCAL)bmi2);
                }

            }

            if (bmi1 != NULL) {
                LocalFree((HLOCAL)bmi1);
            }
        }
        break;

    case ICM_COMPRESS_END:

    case ICM_DECOMPRESS_END:
    case ICM_DECOMPRESSEX_END:
    case ICM_DRAW_END:
    case ICM_DRAW_FLUSH:
    case ICM_DRAW_START:         //??
    case ICM_DRAW_STOP:          //??
    case ICM_DRAW_SETTIME:
    case ICM_DRAW_RENDERBUFFER:
    case ICM_SETQUALITY:

        ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                   (UINT)msg,
                                   dwP1,
                                   dwP2);
        break;

    case ICM_DRAW_GETTIME:
    case ICM_GETBUFFERSWANTED:
    case ICM_GETDEFAULTQUALITY:
    case ICM_GETDEFAULTKEYFRAMERATE:
    case ICM_GETQUALITY:
        {
            DWORD dwReturn;

            ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                       (UINT)msg,
                                       (DWORD)&dwReturn,
                                       dwP2);

            // Note: although the definition of these messages state
            // that dwParam2 is not used, trouble will brew if the
            // decompressor ever tries to use dwParam2.  We cannot
            // thunk non-standard uses of this parameter.

            if (ReturnCode == ICERR_OK) {
                CopyTo16Bit((LPVOID)dwP1, &dwReturn, sizeof(DWORD));
            }

        }
        break;

    case ICM_COMPRESS_GET_FORMAT:
    case ICM_DECOMPRESS_GET_FORMAT:

       /*
        *  This is a tricky one - we first have to find the size of
        *  the output format so we can get a copy of the (aligned)
        *  version before passing it back to the app
        */

        {
            LPBITMAPINFO bmi1, bmi2;

            if ( dwP1 == 0L ) {
                ReturnCode = ICERR_OK;
                break;
            }

            bmi1 = CopyBitmapInfo(dwP1);

            if (bmi1 == NULL) {
                ReturnCode = ICERR_MEMORY;
            } else {

                ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                           (UINT)msg,
                                           (DWORD)bmi1,
                                           0);

                if (ReturnCode > 0 && dwP2 != 0) {
                    bmi2 = LocalAlloc(LMEM_FIXED, ReturnCode);

                    if (bmi2 == NULL) {
                       /*
                        *  Can't do anything!!! - there's not good return code
                        */

                        ReturnCode = ICERR_MEMORY;
                    } else {
                        DWORD Length;

                        Length = ReturnCode; /* preserve length */

                        ReturnCode =
                            ICSendMessage((HIC)(DWORD)hic,
                                          (UINT)msg,
                                          (DWORD)bmi1,
                                          (DWORD)bmi2);

                        if (ReturnCode >= 0) {
                            CopyTo16Bit((LPVOID)dwP2, bmi2, Length);
                        }

                        LocalFree((HLOCAL)bmi2);
                    }
                }

                LocalFree((HLOCAL)bmi1);
            }

        }
        break;

    case ICM_DECOMPRESS:
        if (dwP2 != sizeof(ICDECOMPRESS)) {
            ReturnCode = ICERR_BADSIZE;
        } else {
            ReturnCode = DoICM_DecompressX(hic, msg, dwP1, dwP2);
        }
        break;

    case ICM_DECOMPRESSEX:
    case ICM_DECOMPRESSEX_BEGIN:
        if (dwP2 != sizeof(ICDECOMPRESSEX)) {
            ReturnCode = ICERR_BADSIZE;
        } else {
            ReturnCode = DoICM_DecompressX(hic, msg, dwP1, dwP2);
        }
        break;

    case ICM_DECOMPRESSEX_QUERY:
            {
               /*
                *  We need to convert the various fields in the ICDECOMPRESSEX
                *  structure(s).
                */

                ICDECOMPRESSEX ICDecompressEx1;
                ICDECOMPRESSEX ICDecompressEx2;
                BITMAPINFOHEADER biInput1, biOutput1;
                BITMAPINFOHEADER biInput2, biOutput2;

                /* Copy the structure */
                CopyTo32Bit(&ICDecompressEx1,
                            (LPVOID)dwP1,
                            sizeof(ICDECOMPRESSEX));

               /*
                *  We now need : converted forms of the bitmap info headers
                *  an aligned version of the input bytes (CHECK and if
                *  already aligned do nothing)
                *  and an aligned (again only if ncessary) version of the
                *  output data buffer - actually we'll assume there aren't
                *  necessary
                */

                ICDecompressEx1.lpbiSrc =
                    CopyIfNotAligned(&biInput1, ICDecompressEx1.lpbiSrc,
                                     sizeof(BITMAPINFOHEADER));

                ICDecompressEx1.lpbiDst =
                    CopyIfNotAligned(&biOutput1, ICDecompressEx1.lpbiDst,
                                     sizeof(BITMAPINFOHEADER));

                ICDecompressEx1.lpSrc =
                    GetVdmPointer((DWORD)ICDecompressEx1.lpSrc,
                              ICDecompressEx1.lpbiSrc->biSizeImage, TRUE);

                ICDecompressEx1.lpDst =
                    GetVdmPointer((DWORD)ICDecompressEx1.lpDst,
                              ICDecompressEx1.lpbiDst->biSizeImage, TRUE);

                /* Copy the optional structure */
                if (dwP2) {
                    CopyTo32Bit(&ICDecompressEx2,
                                 (LPVOID)dwP2,
                                 sizeof(ICDECOMPRESSEX));
                    dwP2 = (DWORD)&ICDecompressEx2;

                    ICDecompressEx2.lpbiSrc =
                        CopyIfNotAligned(&biInput2, ICDecompressEx2.lpbiSrc,
                                         sizeof(BITMAPINFOHEADER));

                    ICDecompressEx2.lpbiDst =
                        CopyIfNotAligned(&biOutput2, ICDecompressEx2.lpbiDst,
                                         sizeof(BITMAPINFOHEADER));

                    ICDecompressEx2.lpSrc =
                        GetVdmPointer((DWORD)ICDecompressEx2.lpSrc,
                                  ICDecompressEx2.lpbiSrc->biSizeImage, TRUE);

                    ICDecompressEx2.lpDst =
                        GetVdmPointer((DWORD)ICDecompressEx2.lpDst,
                                  ICDecompressEx2.lpbiDst->biSizeImage, TRUE);
                }

                return ICSendMessage((HIC)hic,
                                     (UINT)msg,
                                     (DWORD)&ICDecompressEx1,
                                     (DWORD)dwP2);
            }

        break;


    case ICM_DRAW:

       /*
        *  We can't support unknown extensions
        */

        if (dwP2 != sizeof(ICDRAW)) {
            ReturnCode = ICERR_BADSIZE;
        } else {
            ICDRAW ICDraw;
            BITMAPINFOHEADER bmi;

            CopyTo32Bit(&ICDraw, (LPVOID)dwP1, dwP2);

           /*
            *  We have to assume this is a draw for video
            */

            CopyTo32Bit(&bmi, ICDraw.lpFormat, sizeof(BITMAPINFOHEADER));

            ICDraw.lpFormat = (LPVOID)&bmi;

            ICDraw.lpData = GetVdmPointer((DWORD)ICDraw.lpData, ICDraw.cbData, TRUE);

            ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                       (UINT)msg,
                                       (DWORD)&ICDraw,
                                       dwP2);
        }
        break;

    case ICM_DRAW_BEGIN:
        {
            ICDRAWBEGIN InputFormat;
            BITMAPINFOHEADER bmihInput;

            ConvertICDRAWBEGIN(&InputFormat, &bmihInput, dwP1);

            ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                       (UINT)msg,
                                       (DWORD)&InputFormat,
                                       dwP2);
        }
        break;

    case ICM_DRAW_CHANGEPALETTE:
    case ICM_DRAW_QUERY:
        {
            LPBITMAPINFO lpbi;

            lpbi = CopyBitmapInfo(dwP1);

            if (lpbi == NULL) {
                ReturnCode = ICERR_MEMORY;
            } else {
                ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                           (UINT)msg,
                                           (DWORD)lpbi,
                                           dwP2);

                LocalFree((HLOCAL)lpbi);
            }
        }
        break;

    case ICM_DRAW_REALIZE:

        ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                   (UINT)msg,
                                   (DWORD)ThunkHDC(LOWORD(dwP1)),
                                   dwP2);

        break;

    case ICM_DRAW_WINDOW:
        {
            RECT_SHORT SRect;
            RECT Rect;

            CopyTo32Bit(&SRect, (LPVOID)dwP1, sizeof(SRect));

            SHORT_RECT_TO_RECT(Rect, SRect);

            ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                       (UINT)msg,
                                       (DWORD)&Rect,
                                       dwP2);
        }
        break;

    // The next three messages are INTERNAL ones
    case ICM_GETERRORTEXT:
        break;

    case ICM_GETFORMATNAME:
        break;

    case ICM_ENUMFORMATS:
        break;

    case ICM_COMPRESS_FRAMES_INFO:
        {
            ICCOMPRESSFRAMES icf32;
            CopyTo32Bit(&icf32, (LPBYTE)dwP1, dwP2);

            // Now fix up the 32 bit structure
            icf32.PutData = icf32.GetData = NULL;  // For safety.  should not be used for this message

            if (icf32.lpbiOutput) {
                icf32.lpbiOutput = CopyBitmapInfoHeader((DWORD)icf32.lpbiOutput);
            }
            if (icf32.lpbiInput) {
                icf32.lpbiInput = CopyBitmapInfoHeader((DWORD)icf32.lpbiInput);
            }

            icf32.lInput = (LPARAM)
                GetVdmPointer((DWORD)icf32.lInput,
                          icf32.lpbiInput->biSizeImage, TRUE);

            icf32.lOutput = (LPARAM)
                GetVdmPointer((DWORD)icf32.lOutput,
                          icf32.lpbiOutput->biSizeImage, TRUE);

            // After the fixups have been done, call the actual routine
            ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                       (UINT)msg,
                                       (DWORD)&icf32,
                                       dwP2);
            if (icf32.lpbiOutput) {
                LocalFree(icf32.lpbiOutput);
            }
            if (icf32.lpbiInput) {
                LocalFree(icf32.lpbiInput);
            }
        }
        break;

    case ICM_DRAW_GET_PALETTE:
        {
            ReturnCode = ICSendMessage((HIC) hic,
                                       (UINT)msg,
                                       dwP1,
                                       dwP2);
            if ((ReturnCode != 0L) && (ReturnCode != ICERR_UNSUPPORTED)) {

                FARPROC lpWOWHandle16;
                HMODULE hmodWow;

                if ( (hmodWow = GetModuleHandle( GET_MAPPING_MODULE_NAME ))
                   && (lpWOWHandle16 = GetProcAddress(hmodWow, "WOWHandle16"))) {
                    ReturnCode = (WORD)(lpWOWHandle16((HANDLE)ReturnCode, (WOW_HANDLE_TYPE)WOW_TYPE_HPALETTE));
                } else {
                    ReturnCode = ICERR_ERROR;
                }
            }
        }
        break;

    case ICM_DRAW_SUGGESTFORMAT:
        {
            ICDRAWSUGGEST icdrwsug;
            UNALIGNED ICDRAWSUGGEST * pic;
            UNALIGNED LPBITMAPINFOHEADER lpbmihdr16;

            // Remember the 16 bit address
            pic = (ICDRAWSUGGEST *)CopyTo32Bit(&icdrwsug, (LPBYTE)dwP1, dwP2);
            lpbmihdr16 = pic->lpbiSuggest;

            // Now fix up the 32 bit structure

            if (icdrwsug.lpbiIn) {
                icdrwsug.lpbiIn = CopyBitmapInfoHeader((DWORD)icdrwsug.lpbiIn);
            }

            if (icdrwsug.lpbiSuggest) {
                icdrwsug.lpbiSuggest = CopyBitmapInfoHeader((DWORD)icdrwsug.lpbiSuggest);
            }

            // After the fixups have been done, call the actual routine
            ReturnCode = ICSendMessage((HIC)(DWORD)hic,
                                       (UINT)msg,
                                       (DWORD)&icdrwsug,
                                       dwP2);
            if (icdrwsug.lpbiIn) {
                LocalFree(icdrwsug.lpbiIn);
            }

            // We must return the 32 bit suggested format to 16 bit land
            if (icdrwsug.lpbiSuggest) {
                if (ReturnCode == ICERR_OK) {
                    CopyTo16Bit( pic->lpbiSuggest, icdrwsug.lpbiSuggest,
                                 lpbmihdr16->biSize);
                }
                LocalFree(icdrwsug.lpbiSuggest);
            }
        }
        break;

    case ICM_SET_STATUS_PROC:
        // We do not need to support this under NT.  It is much
        // easier not to add the callback support... even if we could
        // guarantee to be on the right thread to actually do the callback.

    default:
        ReturnCode = ICERR_UNSUPPORTED;
        break;
    }

EndThunk()
}

INLINE DWORD FAR PASCAL ICOpen32(DWORD fccType, DWORD fccHandler, UINT wMode)
{
    StartThunk(ICOpen);
    DPF2(("Calling ICOpen %4.4hs %4.4hs %4X", &fccType, &fccHandler, wMode));
    ReturnCode = (LONG)ICOpen(fccType, fccHandler, (UINT)wMode);
    EndThunk();
}

INLINE LRESULT FAR PASCAL ICClose32(DWORD hic)
{
    StartThunk(ICClose);
    DPF2(("Calling ICClose %4X", hic));
    ReturnCode = ICClose((HIC)hic);
    EndThunk();
}

#endif // _INC_COMPMAN


DWORD ICMThunk32(DWORD dwThunkId,DWORD dw1,DWORD dw2,DWORD dw3,DWORD dw4)
{
    //
    //  Make sure we've got thunking functionality
    //

#if 0
    {
        char    szBuffer[80];
        char    szMsg[32];


        switch (dwThunkId) {

        case compThunkICSendMessage32:
            lstrcpyA( szMsg, "ICSendMessage32" );
            break;

        case compThunkICInfo32:
            lstrcpyA( szMsg, "ICInfo32" );
            break;

        case compThunkICOpen32:
            lstrcpyA( szMsg, "ICOpen32" );
            break;

        case compThunkICClose32:
            lstrcpyA( szMsg, "ICClose32" );
            break;

        default:
            lstrcpyA( szMsg, "Unknown" );
            break;
        }

        wsprintfA( szBuffer, "%18.18s 0x%08X 0x%08X 0x%08X 0x%08X\r\n",
                   szMsg, dw1, dw2, dw3, dw4);

        OutputDebugStringA( szBuffer );

    }
#endif

    if (ThunksInitialized <= 0) {

        HMODULE hMod;

        if (ThunksInitialized == -1) {
            return MMSYSERR_ERROR;
        }

        hMod = GetModuleHandle(GET_MAPPING_MODULE_NAME);
        if (hMod != NULL) {

            GetVdmPointer =
                (LPGETVDMPOINTER)GetProcAddress(hMod, GET_VDM_POINTER_NAME);
            lpWOWHandle32 =
                (LPWOWHANDLE32)GetProcAddress(hMod, GET_HANDLE_MAPPER32 );
            lpWOWHandle16 =
                (LPWOWHANDLE16)GetProcAddress(hMod, GET_HANDLE_MAPPER16 );
            lpWOWCallback16 =
                (LPWOWCALLBACK16)GetProcAddress(hMod, GET_CALLBACK16 );
        }

        if ( GetVdmPointer == NULL
          || lpWOWHandle16 == NULL
          || lpWOWHandle32 == NULL ) {

            ThunksInitialized = -1;
            return MMSYSERR_ERROR;

        } else {
            ThunksInitialized = 1;
        }
    }


    //
    //  Perform the requested function
    //

    switch (dwThunkId) {

        case compThunkICSendMessage32:
            return ICSendMessage32(dw1, (UINT)dw2, dw3, dw4);
            break;

        case compThunkICInfo32:
            return ICInfo32(dw1, dw2, (ICINFOA FAR * )dw3);
            break;

        case compThunkICOpen32:
            return ICOpen32(dw1, dw2, (UINT)dw3);
            break;

        case compThunkICClose32:
            return ICClose32(dw1);
            break;

        default:
            return(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\video\profile.c ===
/*
 * MSVFW32: (Compman, drawdib and video)
 *
 * profile.c
 *
 * win32/win16 utility functions to read and write profile items
 * for VFW
 *
 * JMK: added functions to convert from Ansi to Unicode & back
 *
 * WARNING:  This code caches open registry keys.  When a profile call
 * is made the code looks for an atom to correspond to the appname supplied.
 * If an atom is found, then the table of cached registry keys is searched
 * for the matching registry handle.  If the handle exists, it is used.
 * No handle would mean that someone else registered an atom using this
 * name, so we proceed to the next step.
 *
 * No atom found, or no matching registry handle, means that we have to
 * open a registry key.  If successful, and there is space in the cache,
 * we AddAtom the appname, and cache the registry key before returning to
 * the caller.
 */

#include <windows.h>
#include <windowsx.h>

#ifdef _WIN32
// This whole file is only used for 32 bit code.  It is the implementation
// that allows Win GetProfilexxx calls to use the registry.
#include <profile.key>

#include <win32.h>
#include <profile.key>
#include "mmsystem.h"
#include <vfw.h>
#include "msvideoi.h"
#include "debug.h"

#include "profile.h"

#if MMPROFILECACHE

#ifdef DEBUG
#define KEYSCACHED 3 // Normally DrawDib, Debug and ??
#else
#define KEYSCACHED 2 // Normally DrawDib and ??
#endif

HKEY   ahkey[KEYSCACHED];
ATOM   akeyatoms[KEYSCACHED];
UINT   keyscached = 0;

#else
#define KEYSCACHED 0
#endif


static HKEY GetKeyA(LPCSTR appname, BOOL * closekey, BOOL fCreate)
{
    HKEY key = 0;
    char achName[MAX_PATH];
#if !MMPROFILECACHE
    *closekey = TRUE;
#else
    UINT n;
    ATOM atm;

    *closekey = FALSE;
    //
    // See if we have already used this key
    //
    atm = FindAtomA(appname);

    if (atm != 0) {
	// Atom exists... search the table for it.
        for (n=0; n<keyscached; ++n) {
            if (akeyatoms[n] == atm) {
                DPF(2,"Found existing key for %s\n", appname);
                return ahkey[n];
            }
        }
    }
    DPF(2, "No key found for %s", appname);
#endif

    lstrcpyA(achName, KEYNAMEA);
    lstrcatA(achName, appname);

    if ((!fCreate && RegOpenKeyA(ROOTKEY, achName, &key) == ERROR_SUCCESS)
        || (fCreate && RegCreateKeyA(ROOTKEY, achName, &key) == ERROR_SUCCESS)) {
#if MMPROFILECACHE
        if ((keyscached < KEYSCACHED)
	  && (atm = AddAtomA(appname))) {
            // Add this key to the cache array
            akeyatoms[keyscached] = atm;
            ahkey[keyscached] = key;
            DPF(1, "Adding key %s to cache array in position %d\n", appname, keyscached);
            ++keyscached;
        } else {
            DPF(2,"Not adding key %s to cache array\n", appname);
            *closekey = TRUE;
        }
#endif
    }

    return(key);
}

#ifdef UNICODE
static HKEY GetKeyW(LPCWSTR appname, BOOL * closekey, BOOL fCreate) {

    HKEY key = 0;
    WCHAR achName[MAX_PATH];
#if !MMPROFILECACHE
    *closekey = TRUE;
#else
    UINT n;
    ATOM atm;

    *closekey = FALSE;
    //
    // See if we have already used this key
    //
    atm = FindAtomW(appname);

    if (atm != 0) {
	// Atom exists... search the table for it.
        for (n=0; n<keyscached; ++n) {
            if (akeyatoms[n] == atm) {
                DPF(2,"(W)Found existing key for %ls\n", appname);
                return ahkey[n];
            }
        }
    }
    DPF(2,"(W)No key found for %ls\n", appname);
#endif

    lstrcpyW(achName, KEYNAME );
    lstrcatW(achName, appname);

    if ((!fCreate && RegOpenKeyW(ROOTKEY, achName, &key) == ERROR_SUCCESS)
        || (fCreate && RegCreateKeyW(ROOTKEY, achName, &key) == ERROR_SUCCESS)) {
#if MMPROFILECACHE
        if (keyscached < KEYSCACHED
	  && (atm = AddAtomW(appname))) {
            // Add this key to the cache array
            akeyatoms[keyscached] = atm;
            ahkey[keyscached] = key;
            DPF(1,"Adding key %ls to cache array in position %d\n", appname, keyscached);
            ++keyscached;
        } else {
            DPF(2,"Not adding key to cache array\n");
            *closekey = TRUE;
        }
#endif
    }

    return(key);
}
#define GetKey GetKeyW
#else
#define GetKey GetKeyA
#endif // UNICODE

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
#ifdef _WIN32
UINT
mmGetProfileIntA(LPCSTR appname, LPCSTR valuename, INT uDefault)
{
    DWORD dwType;
    INT value = uDefault;
    DWORD dwData;
    int cbData;
    BOOL fCloseKey;

    HKEY key = GetKeyA(appname, &fCloseKey, FALSE);

    if (key) {

        cbData = sizeof(dwData);
        if (RegQueryValueExA(
            key,
            (LPSTR)valuename,
            NULL,
            &dwType,
            (PBYTE) &dwData,
            &cbData) == ERROR_SUCCESS) {
            if (dwType == REG_DWORD || dwType == REG_BINARY) {
                value = (INT)dwData;
#ifdef USESTRINGSALSO
            } else if (dwType == REG_SZ) {
		value = atoi((LPSTR) &dwData);
#endif
	    }
	}

        // close open key open if we did not cache it
        if (fCloseKey) {
            RegCloseKey(key);
        }
    }

    return((UINT)value);
}
#endif

/*
 * read a string from the profile into pResult.
 * result is number of bytes written into pResult
 */
#ifdef _WIN32
DWORD
mmGetProfileString(
    LPCTSTR appname,
    LPCTSTR valuename,
    LPCTSTR pDefault,
    LPTSTR pResult,
    int cbResult
)
{
    DWORD dwType;
    BOOL fCloseKey;

    HKEY key = GetKey(appname, &fCloseKey, FALSE);

    if (key) {

        cbResult = cbResult * sizeof(TCHAR);
        if (RegQueryValueEx(
            key,
            (LPTSTR)valuename,
            NULL,
            &dwType,
            (LPBYTE)pResult,
            &cbResult) == ERROR_SUCCESS) {

                if (dwType == REG_SZ) {
                    // cbResult is set to the size including null
                    // we return the number of characters

                    // close key if we did not cache it
                    if (fCloseKey) {
                        RegCloseKey(key);
                    }
                    return(cbResult/sizeof(TCHAR) - 1);
                }
        }

        // close open key if we did not cache it
        if (fCloseKey) {
            RegCloseKey(key);
        }
    }

    // if we got here, we didn't find it, or it was the wrong type - return
    // the default string
    lstrcpy(pResult, pDefault);
    return(lstrlen(pDefault));
}
#endif


/*
 * write a string to the profile
 */
#ifdef _WIN32
VOID
mmWriteProfileString(LPCTSTR appname, LPCTSTR valuename, LPCTSTR pData)
{
    BOOL fCloseKey;
    HKEY key = GetKey(appname, &fCloseKey, TRUE);

    if (key) {
        if (pData) {
            RegSetValueEx(
                key,
                (LPTSTR)valuename,
                0,
                REG_SZ,
                (LPBYTE)pData,
                (lstrlen(pData) + 1) * sizeof(TCHAR)
            );
        } else {
            RegDeleteValue(
                key,
                (LPTSTR)valuename
            );
        }

        if (fCloseKey) {
            RegCloseKey(key);
        }
    }
}

/*****************************************************************************

 functions to help convert wide characters to multibyte & vv. (using
 functions to control code size...)

 these functions are not needed if we are building 16 bit code

 ****************************************************************************/

/*
 * convert an Ansi string to Unicode
 */
LPWSTR mmAnsiToWide (
   LPWSTR lpwsz,  // out: wide char buffer to convert into
   LPCSTR lpsz,   // in: ansi string to convert from
   UINT   nChars) // in: count of characters in each buffer
{
   MultiByteToWideChar(GetACP(), 0, lpsz, nChars, lpwsz, nChars);
   return lpwsz;
}

/*
 * convert a unicode string to ansi
 */
LPSTR mmWideToAnsi (
   LPSTR   lpsz,   // out: ansi buffer to convert into
   LPCWSTR lpwsz,  // in: wide char buffer to convert from
   UINT    nChars) // in: count of characters (not bytes!)
{
   WideCharToMultiByte(GetACP(), 0, lpwsz, nChars, lpsz, nChars, NULL, NULL);
   return lpsz;
}


/*
 * Close all open registry keys
 */
#if MMPROFILECACHE
VOID CloseKeys()
{
    for (; keyscached--;) {

#ifdef DEBUG
        if (!ahkey[keyscached]) {           //Assertion!
            DPF(0,"Closing a null key\n");
            //DebugBreak();
        }
#endif
        RegCloseKey(ahkey[keyscached]);
        DeleteAtom(akeyatoms[keyscached]);
    }
}

#endif //MMPROFILECACHE
#endif // _WIN32

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\video\profile.h ===
/*
 * MSVFW32: (Compman, drawdib and video)
 *
 * utility functions to read and write values to the profile,
 * using win.ini for Win16 or current user\software\microsoft\vfw\...
 * in the registry for Win32
 */

#define MMPROFILECACHE 0  // Set to 1 to cache keys, 0 otherwise

#ifndef _WIN32

#define mmGetProfileIntA(app, value, default) \
          GetProfileInt(app, value, default)

#define mmWriteProfileString(appname, valuename, pData) \
          WriteProfileString(appname, valuename, pData)

#define mmGetProfileString(appname, valuename, pDefault, pResult, cbResult) \
          GetProfileString(appname, valuename, pDefault, pResult, cbResult)

//#define mmAnsiToWide(lpwsz,lpsz,nChars) (lpsz)
//#define mmWideToAnsi(lpsz,lpwsz,nChars) (lpwsz)

#define CloseKeys()

#else

#ifdef DAYTONA
#undef MMPROFILECACHE
#define MMPROFILECACHE 1  // Set to 1 to cache keys, 0 otherwise
#endif

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
UINT mmGetProfileIntA(LPCSTR appname, LPCSTR valuename, INT uDefault);

/*
 * read a string from the profile into pResult.
 * result is number of characters written into pResult
 */
DWORD mmGetProfileString(LPCTSTR appname, LPCTSTR valuename, LPCTSTR pDefault,
                    LPTSTR pResult, int cbResult
);

/*
 * write a string to the profile
 */
VOID mmWriteProfileString(LPCTSTR appname, LPCTSTR valuename, LPCTSTR pData);


#if MMPROFILECACHE
VOID CloseKeys(VOID);
#else
#define CloseKeys()
#endif

/*
 * convert an Ansi string to Wide characters
 */
LPWSTR mmAnsiToWide (
   LPWSTR lpwsz,   // out: wide char buffer to convert into
   LPCSTR  lpsz,   // in: ansi string to convert from
   UINT   nChars); // in: count of characters in each buffer

/*
 * convert a Wide char string to Ansi
 */
LPSTR mmWideToAnsi (
   LPSTR  lpsz,    // out: ansi buffer to convert into
   LPCWSTR lpwsz,  // in: wide char buffer to convert from
   UINT   nChars); // in: count of characters (not bytes!)

#if !defined NUMELMS
 #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\video\vidthunk.h ===
/****************************************************************************
    vidthunk.h

    Contains definitions for msvideo thunks (16/32 bit)

    Copyright (c) Microsoft Corporation 1994. All rights reserved

****************************************************************************/

//
// NOTE - 32bit handles have 0x8000 'or'ed in - this makes a BIG ASSUMPTION
// about how handles are generated on the 32-bit side.  We ASSUME here
// that :
//
//    32bit msvideo.dll always uses OpenDriver to create handles
//
//    The OpenDriver returns indices into its table (ie small positive
//    numbers).
//

#define  Is32bitHandle(h) (((h) & 0x8000) != 0)
#define  Make32bitHandle(h) ((h) | 0x8000)
#define  Map32bitHandle(h) ((h) & 0x7FFF)

#ifdef WIN32
#include <wownt32.h>
//
//  Thunking support
//

#define GET_VDM_POINTER_NAME            "WOWGetVDMPointer"
#define GET_HANDLE_MAPPER16             "WOWHandle16"
#define GET_HANDLE_MAPPER32             "WOWHandle32"
#define GET_CALLBACK16                  "WOWCallback16"
#define GET_MAPPING_MODULE_NAME         TEXT("wow32.dll")

typedef LPVOID (APIENTRY *LPGETVDMPOINTER)( DWORD Address, DWORD dwBytes, BOOL fProtectMode );
#define WOW32ResolveMemory( p ) (LPVOID)(GetVdmPointer( (DWORD)(p), 0, TRUE ))

typedef HANDLE  (APIENTRY *LPWOWHANDLE32)(WORD, WOW_HANDLE_TYPE);
typedef WORD    (APIENTRY *LPWOWHANDLE16)(HANDLE, WOW_HANDLE_TYPE);
typedef DWORD   (APIENTRY *LPWOWCALLBACK16)(DWORD vpfn16, DWORD dwParam);


#ifdef DEBUG
    extern int thunkDebugLevel;
    extern int videoDebugLevel;
    extern void FAR CDECL dprintf(LPSTR szFormat, ...);
    #define thDPF( _x_ )	if (thunkDebugLevel || videoDebugLevel >= 1) dprintf _x_
    #define thDPF0( _x_ )                           dprintf _x_
    #define thDPF1( _x_ )	if (thunkDebugLevel || videoDebugLevel >= 1) dprintf _x_
    #define thDPF2( _x_ )	if (thunkDebugLevel || videoDebugLevel >= 2) dprintf _x_
    #define thDPF3( _x_ )	if (thunkDebugLevel || videoDebugLevel >= 3) dprintf _x_
    #define thDPF4( _x_ ) if (videoDebugLevel >= 4) dprintf _x_
#else
    /* debug printf macros */
    #define thDPF( x )
    #define thDPF0( x )
    #define thDPF1( x )
    #define thDPF2( x )
    #define thDPF3( x )
    #define thDPF4( x )
#endif

#define StartThunk(Function)                           \
          LONG  ReturnCode = 0;                        \
          thDPF2(("Entering function %s", #Function));

#define EndThunk()                                     \
          thDPF2(("Returned %4X :%4X",                   \
                   HIWORD(ReturnCode),                 \
                   LOWORD(ReturnCode)));               \
          return ReturnCode;

#define ThunkHWND(h16) ((HWND)lpWOWHandle32(h16, WOW_TYPE_HWND))
#define ThunkHDC(h16)  ((HDC) lpWOWHandle32(h16, WOW_TYPE_HDC))
#define ThunkHPAL(h16) ((HPALETTE)lpWOWHandle32(h16, WOW_TYPE_HPALETTE))

#endif // WIN32

/*
 *  Useful structures and mapping
 */

typedef struct {
    short left, top, right, bottom;
} RECT_SHORT;


#define SHORT_RECT_TO_RECT(OutRect, InRect)  \
    OutRect.left = (LONG)InRect.left;        \
    OutRect.top = (LONG)InRect.top;          \
    OutRect.right = (LONG)InRect.right;      \
    OutRect.bottom = (LONG)InRect.bottom;

#define RECT_TO_SHORT_RECT(OutRect, InRect)  \
    OutRect.left = (short)InRect.left;       \
    OutRect.top = (short)InRect.top;         \
    OutRect.right = (short)InRect.right;     \
    OutRect.bottom = (short)InRect.bottom;


//
//  Function ids across the thunking layer (used by 32 and 16 bit)
//
enum {
   vidThunkvideoMessage32=1,
   vidThunkvideoGetNumDevs32,
   vidThunkvideoOpen32,
   vidThunkvideoClose32,

   compThunkICInfo32,
   compThunkICSendMessage32,
   compThunkICOpen32,
   compThunkICClose32
};

#ifndef WIN32
typedef struct _VIDTHUNK
{
//
//  Thunking stuff
//
    DWORD           (FAR PASCAL *lpfnCallproc32W)(DWORD, DWORD, DWORD,
                                                  DWORD, DWORD,
                                                  LPVOID, DWORD, DWORD);
    LPVOID          lpvThunkEntry;
    DWORD           dwVideo32Handle;


} VIDTHUNK, *PVIDTHUNK, FAR *LPVIDTHUNK;
#endif // !WIN32

//
// The following functions generate calls to the 32-bit side
//

#ifdef _INC_MSVIDEO

DWORD FAR PASCAL videoMessage32(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2);
DWORD FAR PASCAL videoGetNumDevs32(void);
DWORD FAR PASCAL videoClose32(HVIDEO hVideo);
DWORD FAR PASCAL videoOpen32(LPHVIDEO lphVideo, DWORD dwDeviceID, DWORD dwFlags);

#endif // _INC_MSVIDEO

#ifdef _INC_COMPMAN

BOOL FAR PASCAL ICInfo32(DWORD fccType, DWORD fccHandler, ICINFO16 FAR * lpicInfo);
LRESULT FAR PASCAL ICSendMessage32(DWORD hic, UINT msg, DWORD dwP1, DWORD dwP2);
DWORD FAR PASCAL ICOpen32(DWORD fccType, DWORD fccHandler, UINT wMode);
LRESULT FAR PASCAL ICClose32(DWORD hic);

#endif // _INC_COMPMAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\avi\video\video.c ===
/****************************************************************************
    video.c

    Contains video APIs

    Copyright (c) Microsoft Corporation 1992. All rights reserved

****************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include <win32.h>
#include <winerror.h>

#include "msviddrv.h"
#include "ivideo32.h" // includes msvideo.h
#include "msvideoi.h"

#ifdef _WIN32
#include "profile.h"
#include <mmddk.h>
#include <stdlib.h>
#include <winver.h>
#else
#include <ver.h>
#endif


#include "debug.h"

#ifndef DEVNODE
typedef	DWORD	   DEVNODE;	// Devnode.
#endif

#ifndef LPHKEY
typedef HKEY FAR * LPHKEY;
#endif

#if defined _WIN32 && !defined UNICODE
HDRVR WINAPI OpenDriverA( LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
#endif


/*****************************************************************************
 * Variables
 *
 ****************************************************************************/

#ifdef WIN16 // All of this is currently only used in 16 bit land

SZCODE  szVideo[]           = TEXT("msvideo");

#ifndef UNICODE
// Registry settings of interest to capture drivers
SZCODE  szRegKey[]          = TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaResources\\msvideo");
SZCODE  szRegActive[]       = TEXT("Active");
SZCODE  szRegDisabled[]     = TEXT("Disabled");
SZCODE  szRegDescription[]  = TEXT("Description");
SZCODE  szRegDevNode[]      = TEXT("DevNode");
SZCODE  szRegDriver[]       = TEXT("Driver");
SZCODE  szRegSoftwareKey[]  = TEXT("SOFTWAREKEY");
#endif

#ifndef _WIN32
SZCODE  szDrivers[]     = "Drivers";
#else
STATICDT SZCODE  szDrivers[]     = DRIVERS_SECTION;
#endif

STATICDT SZCODE  szSystemIni[]   = TEXT("system.ini");

static SZCODE	szNull[] = TEXT("");

UINT    wTotalVideoDevs;                  // total video devices
LPCAPDRIVERINFO aCapDriverList[MAXVIDEODRIVERS]; // Array of all capture drivers

/*****************************************************************************
 * @doc INTERNAL  VIDEO validation code for VIDEOHDRs
 ****************************************************************************/

#define IsVideoHeaderPrepared(hVideo, lpwh)      ((lpwh)->dwFlags &  VHDR_PREPARED)
#define MarkVideoHeaderPrepared(hVideo, lpwh)    ((lpwh)->dwFlags |= VHDR_PREPARED)
#define MarkVideoHeaderUnprepared(hVideo, lpwh)  ((lpwh)->dwFlags &=~VHDR_PREPARED)


/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api BOOL | videoRegOpenMSVideoKey | This function returns a key
 *      for the msvideo node in the registry.
 *      If the key does not exist it will be created,
 *      and the default entries made.
 *
 * @rdesc Returns Key on success, else NULL.
 ****************************************************************************/
HKEY videoRegOpenMSVideoKey (void)
{
    HKEY hKey = NULL;

    // Get the key if it already exists
    if (RegOpenKey (
                HKEY_LOCAL_MACHINE,
                szRegKey,
                &hKey) != ERROR_SUCCESS) {

        // Otherwise make a new key
        if (RegCreateKey (
                        HKEY_LOCAL_MACHINE,
                        szRegKey,
                        &hKey) == ERROR_SUCCESS) {
            // Add the default entries to the msvideo node?

        }
    }
    return hKey;
}

/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api BOOL | videoRegGetDriverByIndex | This function returns information
 *      about a capture driver by index from the registry.
 *
 * @parm DWORD | dwDeviceID | Identifies the video device to open.
 *      The value of <p dwDeviceID> varies from zero to one less
 *      than the number of video capture devices installed in the system.
 *
 * @parm LPDEVNODE | lpDevnode | Specifies a far pointer to a buffer
 *   used to return an <t DEVNODE> handle.  For non Plug-and-Play devices,
 *   this return value will be NULL.
 *
 * @parm LPBOOL | lpEnabled | Specifies a far pointer to a buffer
 *   used to return a <t BOOL> flag.  If this value is TRUE, the driver is
 *   enabled, if FALSE, the corresponding device is disabled.
 *
 * @rdesc Returns TRUE if successful, or FALSE if a driver was not found
 *  with the <p dwDeviceID> index.
 *
 * @comm Because the indexes of the MSVIDEO devices in the SYSTEM.INI
 *       file can be non-contiguous, applications should not assume
 *       the indexes range between zero and the number of devices minus
 *       one.
 *
 ****************************************************************************/


BOOL videoRegGetKeyByIndex (
        HKEY            hKeyMSVideoRoot,
        DWORD           dwDeviceID,
        LPCAPDRIVERINFO lpCapDriverInfo,
        LPHKEY          phKeyChild)
{
    BOOL fOK = FALSE;
    HKEY hKeyEnum;
    int i;

    *phKeyChild = (HKEY) 0;

    for (i=0; i < MAXVIDEODRIVERS; i++) {

        if (RegEnumKey (
                hKeyMSVideoRoot,
                i,
                lpCapDriverInfo-> szKeyEnumName,
                sizeof(lpCapDriverInfo->szKeyEnumName)/sizeof(TCHAR)) != ERROR_SUCCESS)
            break;

        // Found a subkey, does it match the requested index?
        if (i == (int) dwDeviceID) {

            if (RegOpenKey (
                        hKeyMSVideoRoot,
                        lpCapDriverInfo-> szKeyEnumName,
                        &hKeyEnum) == ERROR_SUCCESS) {

                *phKeyChild = hKeyEnum;  // Found it!!!
                fOK = TRUE;

            }
            break;
        }
    } // endof all driver indices
    return fOK;
}

// Fetches driver info listed in the registry.
// Returns: TRUE if the index was valid, FALSE if no driver at that index
// Note: Registry entry ordering is random.

BOOL videoRegGetDriverByIndex (
        DWORD           dwDeviceID,
        LPCAPDRIVERINFO lpCapDriverInfo)
{
    DWORD dwType;
    DWORD dwSize;
    BOOL fOK;
    HKEY hKeyChild;
    HKEY hKeyMSVideoRoot;

    // Always start clean since the entry may be recycled
    _fmemset (lpCapDriverInfo, 0, sizeof (CAPDRIVERINFO));

    if (!(hKeyMSVideoRoot = videoRegOpenMSVideoKey()))
        return FALSE;

    if (fOK = videoRegGetKeyByIndex (
                hKeyMSVideoRoot,
                dwDeviceID,
                lpCapDriverInfo,
                &hKeyChild)) {

        // Fetch the values:
        //      Active
        //      Disabled
        //      Description
        //      DEVNODE
        //      Driver
        //      SOFTWAREKEY

        dwSize = sizeof(BOOL);          // Active
        RegQueryValueEx(
                   hKeyChild,
                   szRegActive,
                   NULL,
                   &dwType,
                   (LPBYTE) &lpCapDriverInfo->fActive,
                   &dwSize);

        dwSize = sizeof(BOOL);          // Enabled
        RegQueryValueEx(
                   hKeyChild,
                   szRegDisabled,
                   NULL,
                   &dwType,
                   (LPBYTE) &lpCapDriverInfo->fDisabled,
                   &dwSize);
        // Convert this thing to a bool
        lpCapDriverInfo->fDisabled = (lpCapDriverInfo->fDisabled == '1');

        // DriverDescription
        dwSize = sizeof (lpCapDriverInfo->szDriverDescription) / sizeof (TCHAR);
        RegQueryValueEx(
                   hKeyChild,
                   szRegDescription,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szDriverDescription,
                   &dwSize);

        // DEVNODE
        dwSize = sizeof(DEVNODE);
        RegQueryValueEx(
                   hKeyChild,
                   szRegDevNode,
                   NULL,
                   &dwType,
                   (LPBYTE) &lpCapDriverInfo->dnDevNode,
                   &dwSize);

        // DriverName
        dwSize = sizeof (lpCapDriverInfo->szDriverName) / sizeof (TCHAR);
        RegQueryValueEx(
                   hKeyChild,
                   szRegDriver,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szDriverName,
                   &dwSize);

        // SoftwareKey
        dwSize = sizeof (lpCapDriverInfo->szSoftwareKey) / sizeof (TCHAR);
        RegQueryValueEx(
                   hKeyChild,
                   szRegSoftwareKey,
                   NULL,
                   &dwType,
                   (LPBYTE) lpCapDriverInfo->szSoftwareKey,
                   &dwSize);

        RegCloseKey (hKeyChild);

    } // if the subkey could be opened

    RegCloseKey (hKeyMSVideoRoot);

    return fOK;
}

// Fetches driver info listed in system.ini
// Returns: TRUE if the index was valid, FALSE if no driver at that index

BOOL videoIniGetDriverByIndex (
        DWORD           dwDeviceID,
        LPCAPDRIVERINFO lpCapDriverInfo)
{
    TCHAR szKey[sizeof(szVideo)/sizeof(TCHAR) + 2];
    int w = (int) dwDeviceID;
    BOOL fOK = FALSE;

    // Always start clean since the entry may be recycled
    _fmemset (lpCapDriverInfo, 0, sizeof (CAPDRIVERINFO));

    lstrcpy(szKey, szVideo);
    szKey[(sizeof(szVideo)/sizeof(TCHAR)) - 1] = (TCHAR)0;
    if( w > 0 ) {
        szKey[(sizeof(szVideo)/sizeof(TCHAR))] = (TCHAR)0;
        szKey[(sizeof(szVideo)/sizeof(TCHAR))-1] = (TCHAR) TEXT('1' + (w-1) );  // driver ordinal
    }
    if (GetPrivateProfileString(szDrivers, szKey, szNull,
                lpCapDriverInfo->szDriverName,
                sizeof(lpCapDriverInfo->szDriverName)/sizeof(TCHAR),
                szSystemIni)) {

        // Found an entry at the requested index
        // The description and version info will be inserted as
        // requested by the client app.

        lpCapDriverInfo-> fOnlySystemIni = TRUE;

        fOK = TRUE;
    }

    return fOK;
}

DWORD videoFreeDriverList (void)

{
    int i;

    // Free the driver list
    for (i = 0; i < MAXVIDEODRIVERS; i++) {
        if (aCapDriverList[i])
            GlobalFreePtr (aCapDriverList[i]);
        aCapDriverList[i] = NULL;
    }

    return DV_ERR_OK;
}

// This function may be called a number of times to create the
// current driver array.  Since Capscrn assumes it can throw a
// driver into system.ini on the fly and have it immediately accessible,
// this routine is called on videoGetNumDevs() and when AVICapx.dll
// tries to get the driver description and version.
//
// Drivers in the registry will be the first entries in the list.
//
// If a driver is listed in the registry AND in system.ini AND
// the full path to the drivers match, the system.ini entry will NOT
// be in the resulting list.

// The variable wTotalVideoDevs is set as a byproduct of this function.

// Returns DV_ERR_OK on success, even if no drivers are installed.
//
DWORD videoCreateDriverList (void)

{
    int i, j, k;

    wTotalVideoDevs = 0;

    // Delete the existing list
    videoFreeDriverList ();

    // Allocate an array of pointers to all possible capture drivers
    for (i = 0; i < MAXVIDEODRIVERS; i++) {
        aCapDriverList[i] = (LPCAPDRIVERINFO) GlobalAllocPtr (
                GMEM_MOVEABLE |
                GMEM_SHARE |
                GMEM_ZEROINIT,
                sizeof (CAPDRIVERINFO));
        if (aCapDriverList[i] == NULL)
            return DV_ERR_NOMEM;
    }

    // Walk the list of Registry drivers and get each entry
    for (i = 0; i < MAXVIDEODRIVERS; i++) {
        if (videoRegGetDriverByIndex (
                    (DWORD) i, aCapDriverList[wTotalVideoDevs])) {

            wTotalVideoDevs++;

        }
        else
            break;
    }

    if (wTotalVideoDevs == MAXVIDEODRIVERS)
        goto AllDone;

    // Now add the entries listed in system.ini, (msvideo[0-9] = driver.drv)
    // to the driver array, ONLY if the entry doesn't exactly match
    // an existing registry entry.

    for (j = 0; j < MAXVIDEODRIVERS; j++) {
        if (videoIniGetDriverByIndex ((DWORD) j,
                        aCapDriverList[wTotalVideoDevs])) {

            // Found an entry, now see if it is a duplicate of an existing
            // registry entry

            for (k = 0; k < (int) wTotalVideoDevs; k++) {

                if (lstrcmpi (aCapDriverList[k]->szDriverName,
                    aCapDriverList[wTotalVideoDevs]->szDriverName) == 0) {

                    // Found an exact match, so skip it!
                    goto SkipThisEntry;
                }
            }

            if (wTotalVideoDevs >= MAXVIDEODRIVERS - 1)
                break;

            wTotalVideoDevs++;

SkipThisEntry:
            ;
        } // If sytem.ini entry was found
    } // For all system.ini possibilities

AllDone:

    // Decrement wTotalVideoDevs for any entries which are marked as disabled
    // And remove disabled entries from the list
    for (i = 0; i < MAXVIDEODRIVERS; ) {

        if (aCapDriverList[i] && aCapDriverList[i]->fDisabled) {

            GlobalFreePtr (aCapDriverList[i]);

            // Shift down the remaining drivers
            for (j = i; j < MAXVIDEODRIVERS - 1; j++) {
                aCapDriverList[j] = aCapDriverList[j + 1];
            }
            aCapDriverList[MAXVIDEODRIVERS - 1] = NULL;

            wTotalVideoDevs--;
        }
        else
            i++;
    }

    // Free the unused pointers
    for (i = wTotalVideoDevs; i < MAXVIDEODRIVERS; i++) {
        if (aCapDriverList[i])
            GlobalFreePtr (aCapDriverList[i]);
        aCapDriverList[i] = NULL;
    }

    // Put PnP drivers first in the list
    // These are the only entries that have a DevNode
    for (k = i = 0; i < (int) wTotalVideoDevs; i++) {
        if (aCapDriverList[i]-> dnDevNode) {
            LPCAPDRIVERINFO lpCDTemp;

            if (k != i) {
                // Swap the entries
                lpCDTemp = aCapDriverList[k];
                aCapDriverList[k] = aCapDriverList[i];
                aCapDriverList[i] = lpCDTemp;
            }
            k++;   // Index of first non-PnP driver
        }
    }

    return DV_ERR_OK;
}



typedef struct tagVS_VERSION
{
    WORD wTotLen;
    WORD wValLen;
    char szSig[16];
    VS_FIXEDFILEINFO vffInfo;
} VS_VERSION;

typedef struct tagLANGANDCP
{
    WORD wLanguage;
    WORD wCodePage;
} LANGANDCP;

// Extracts the Description string and version info from a driver.
// Drivers listed in the registry will typically already include a
// description string, but not version info.
// Drivers listed in system.ini will fetch both.
//
// Returns DV_ERR_OK on success, even if no version info was available.
//

DWORD WINAPI videoGetDriverDescAndVer (
        LPCAPDRIVERINFO lpCapDriverInfo)
{
    LPSTR   lpVersion;
    WORD    wVersionLen;
    BOOL    bRetCode;
    DWORD   dwVerInfoSize;
    DWORD   dwVerHnd;
    TCHAR   szBuf[MAX_PATH];
    BOOL    fGetDesc;
    BOOL    fGetVersion;

    // Only get the description if not already supplied by the registry
    fGetDesc = (lpCapDriverInfo->szDriverDescription[0] == '\0');
    fGetVersion = (lpCapDriverInfo->szDriverVersion[0] == '\0');

    if (fGetDesc)
        lpCapDriverInfo->szDriverDescription[0] = '\0';
    if (fGetVersion)
        lpCapDriverInfo->szDriverVersion [0] = '\0';

    // Copy in the driver name initially, just in case the driver
    // has omitted a description field.
    if (fGetDesc)
        lstrcpyn (lpCapDriverInfo->szDriverDescription,
                lpCapDriverInfo->szDriverName,
                sizeof (lpCapDriverInfo->szDriverDescription) / sizeof (TCHAR));

    // You must find the size first before getting any file info
    dwVerInfoSize =
        GetFileVersionInfoSize(lpCapDriverInfo->szDriverName, &dwVerHnd);

    if (dwVerInfoSize) {
        LPSTR   lpstrVffInfo;             // Pointer to block to hold info

        // Get a block big enough to hold version info
        if (lpstrVffInfo  = GlobalAllocPtr(GMEM_MOVEABLE, dwVerInfoSize)) {

           // Get the File Version first
           if(GetFileVersionInfo(lpCapDriverInfo->szDriverName, 0L,
                           dwVerInfoSize, lpstrVffInfo)) {
           VS_VERSION FAR *pVerInfo = (VS_VERSION FAR *) lpstrVffInfo;

           // fill in the file version
           wsprintf(szBuf,
                   "Version:  %d.%d.%d.%d",
                   HIWORD(pVerInfo->vffInfo.dwFileVersionMS),
                   LOWORD(pVerInfo->vffInfo.dwFileVersionMS),
                   HIWORD(pVerInfo->vffInfo.dwFileVersionLS),
                   LOWORD(pVerInfo->vffInfo.dwFileVersionLS));
           if (fGetVersion)
                   lstrcpyn (lpCapDriverInfo->szDriverVersion, szBuf,
                           sizeof (lpCapDriverInfo->szDriverVersion) / sizeof(TCHAR));
           }

           // Now try to get the FileDescription
           // First try this for the "Translation" entry, and then
           // try the American english translation.
           // Keep track of the string length for easy updating.
           // 040904E4 represents the language ID and the four
           // least significant digits represent the codepage for
           // which the data is formatted.  The language ID is
           // composed of two parts: the low ten bits represent
           // the major language and the high six bits represent
           // the sub language.

           lstrcpy(szBuf, "\\StringFileInfo\\040904E4\\FileDescription");

           wVersionLen   = 0;
           lpVersion     = NULL;

           // Look for the corresponding string.
           bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo,
                           (LPSTR)szBuf,
                           (void FAR* FAR*)&lpVersion,
                           (UINT FAR *) &wVersionLen);

           if (fGetDesc && bRetCode && wVersionLen && lpVersion)
                lstrcpyn (lpCapDriverInfo->szDriverDescription, lpVersion,
                   sizeof (lpCapDriverInfo->szDriverDescription) / sizeof(TCHAR));

           // Let go of the memory
           GlobalFreePtr(lpstrVffInfo);
        }
        else
            return DV_ERR_NOMEM;
    }
    return DV_ERR_OK;
}


// Called by AVICap and AVICap32 to get driver strings
// Returns:
//      DV_ERR_OK on success
//      DV_ERR_BADINSTALL if the driver at the specified index is not found

DWORD WINAPI videoCapDriverDescAndVer (
        DWORD dwDeviceID,
        LPTSTR lpszDesc, UINT cbDesc,
        LPTSTR lpszVer, UINT cbVer)
{
    DWORD dwR = DV_ERR_OK;

    if (lpszDesc && IsBadWritePtr (lpszDesc, cbDesc))
        return DV_ERR_NONSPECIFIC;
    else if (lpszDesc)
        *lpszDesc = '\0';
    if (lpszVer && IsBadWritePtr (lpszVer, cbVer))
        return DV_ERR_NONSPECIFIC;
    else if (lpszVer)
        *lpszVer = '\0';

    if (!wTotalVideoDevs)
        dwR = videoCreateDriverList ();

    if (dwR != DV_ERR_OK)
        return dwR;

    if ((WORD) dwDeviceID >= wTotalVideoDevs)
        return DV_ERR_BADDEVICEID;

    dwR = videoGetDriverDescAndVer (aCapDriverList[(int)dwDeviceID]);

    if (dwR == DV_ERR_OK) {
       if (lpszDesc)
           lstrcpyn (lpszDesc, aCapDriverList[(int)dwDeviceID]->szDriverDescription, cbDesc);

       if (lpszVer)
           lstrcpyn (lpszVer, aCapDriverList[(int)dwDeviceID]->szDriverVersion, cbVer);

    }
    return (dwR);
}


/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @func DWORD | videoMessage | This function sends messages to a
 *   video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies the handle to the video device channel.
 *
 * @parm UINT | wMsg | Specifies the message to send.
 *
 * @parm DWORD | dwP1 | Specifies the first parameter for the message.
 *
 * @parm DWORD | dwP2 | Specifies the second parameter for the message.
 *
 * @rdesc Returns the message specific value returned from the driver.
 *
 * @comm This function is used for configuration messages such as
 *      <m DVM_SRC_RECT> and <m DVM_DST_RECT>, and
 *      device specific messages.
 *
 * @xref <f videoConfigure>
 *
 ****************************************************************************/
DWORD WINAPI videoMessage(HVIDEO hVideo, UINT msg, DWORD dwP1, DWORD dwP2)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return SendDriverMessage ((HDRVR)hVideo, msg, dwP1, dwP2);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoGetNumDevs | This function returns the number of MSVIDEO
 *   devices installed.
 *
 * @rdesc Returns the number of MSVIDEO devices listed in the
 *  [drivers] (or [drivers32] for NT) section of the SYSTEM.INI file
 *  plus drivers listed in the registry.
 *
 * @comm Because the indexes of the MSVIDEO devices in the SYSTEM.INI
 *       file can be non-contiguous, applications should not assume
 *       the indexes range between zero and the number of devices minus
 *       one.
 *
 * @xref <f videoOpen>
 ****************************************************************************/
DWORD WINAPI videoGetNumDevs(void)
{
    if (wTotalVideoDevs)
        return (DWORD)wTotalVideoDevs;

    videoCreateDriverList ();

    return (DWORD)wTotalVideoDevs;
}

/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoGetErrorText | This function retrieves a
 *   description of the error identified by the error number.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *	This might be NULL if the error is not device specific.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPSTR | lpText | Specifies a far pointer to a buffer used to
 *       return the zero-terminated string corresponding to the error number.
 *
 * @parm UINT | wSize | Specifies the length, in bytes, of the buffer
 *       referenced by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following error is defined:
 *   @flag DV_ERR_BADERRNUM | Specified error number is out of range.
 *   @flag DV_ERR_SIZEFIELD | The return buffer is not large enough
 *         to handle the error text.
 *
 * @comm If the error description is longer than the buffer,
 *   the description is truncated. The returned error string is always
 *   zero-terminated. If <p wSize> is zero, nothing is copied and zero
 *   is returned.
 ****************************************************************************/

#if defined _WIN32
//
// for WIN32 this is the ansi entry point
//
DWORD WINAPI videoGetErrorTextA (HVIDEO hVideo,
    UINT wError, LPSTR lpText, UINT wSize)
{
    VIDEO_GETERRORTEXT_PARMS vet;

    if (IsBadWritePtr (lpText, wSize))
        return DV_ERR_PARAM1;

    lpText[0] = 0;
    if (((wError >= DV_ERR_BASE) && (wError <= DV_ERR_LASTERROR))) {
        if (wSize > 1) {
            if (!LoadStringA(ghInst, wError, lpText, wSize))
                return DV_ERR_BADERRNUM;
            else
                return DV_ERR_OK;
        }
        else
            return DV_ERR_SIZEFIELD;
    }
    else if (wError >= DV_ERR_USER_MSG && hVideo) {
        DWORD dwResult;
        LPWSTR lpwstr = LocalAlloc(LPTR, wSize*sizeof(WCHAR));
        if (NULL == lpwstr) {
            return(DV_ERR_NOMEM);
        }
        vet.dwError = (DWORD) wError;
        vet.lpText = lpwstr;
        vet.dwLength = (DWORD) wSize;
        dwResult = videoMessage (hVideo, DVM_GETERRORTEXT, (DWORD) (LPVOID) &vet,
                        (DWORD) NULL);
        if (DV_ERR_OK == dwResult) {
            wcstombs(lpText, lpwstr, wSize);
        }
        LocalFree(lpwstr);
        return(dwResult);
    }
    else
        return DV_ERR_BADERRNUM;
}
#endif

//
// The unicode/Win16 equivalent of the above
//
#ifdef _WIN32
DWORD WINAPI videoGetErrorTextW (HVIDEO hVideo, UINT wError,
                        LPWSTR lpText, UINT wSize)
#else
DWORD WINAPI videoGetErrorText (HVIDEO hVideo, UINT wError,
                        LPSTR lpText, UINT wSize)
#endif
{
    VIDEO_GETERRORTEXT_PARMS vet;
    lpText[0] = 0;

    if (((wError > DV_ERR_BASE) && (wError <= DV_ERR_LASTERROR))) {
        if (wSize > 1) {
           #ifdef _WIN32
            LPSTR lpsz = LocalAlloc (LPTR, wSize);
            UINT  cch;

            if (!lpsz)
                return DV_ERR_NOMEM;
            cch = LoadString (ghInst, wError, lpsz, wSize);

            lpsz[cch] = 0;
            mbstowcs (lpText, lpsz, cch+1);
            LocalFree (lpsz);

            if (!cch)
           #else
            if (!LoadString(ghInst, wError, lpText, wSize))
           #endif
                return DV_ERR_BADERRNUM;
            else
                return DV_ERR_OK;
        }
        else
            return DV_ERR_SIZEFIELD;
    }
    else if (wError >= DV_ERR_USER_MSG && hVideo) {
        vet.dwError = (DWORD) wError;
        vet.lpText = lpText;
        vet.dwLength = wSize;
        return videoMessage (hVideo, DVM_GETERRORTEXT, (DWORD) (LPVOID) &vet,
                             (DWORD) NULL);
    }
    else
        return DV_ERR_BADERRNUM;
}


/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoGetChannelCaps | This function retrieves a
 *   description of the capabilities of a channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPCHANNEL_CAPS | lpChannelCaps | Specifies a far pointer to a
 *      <t CHANNEL_CAPS> structure.
 *
 * @parm DWORD | dwSize | Specifies the size, in bytes, of the
 *       <t CHANNEL_CAPS> structure.
 *
 * @rdesc Returns zero if the function is successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_UNSUPPORTED | Function is not supported.
 *
 * @comm The <t CHANNEL_CAPS> structure returns the capability
 *   information. For example, capability information might
 *   include whether or not the channel can crop and scale images,
 *   or show overlay.
 ****************************************************************************/
DWORD WINAPI videoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps,
			DWORD dwSize)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpChannelCaps, sizeof (CHANNEL_CAPS)))
        return DV_ERR_PARAM1;

    // _fmemset (lpChannelCaps, 0, sizeof (CHANNEL_CAPS));

    lpChannelCaps->dwFlags = 0;
    lpChannelCaps->dwSrcRectXMod = 0;
    lpChannelCaps->dwSrcRectYMod = 0;
    lpChannelCaps->dwSrcRectWidthMod = 0;
    lpChannelCaps->dwSrcRectHeightMod = 0;
    lpChannelCaps->dwDstRectXMod = 0;
    lpChannelCaps->dwDstRectYMod = 0;
    lpChannelCaps->dwDstRectWidthMod = 0;
    lpChannelCaps->dwDstRectHeightMod = 0;

    return videoMessage(hVideo, DVM_GET_CHANNEL_CAPS, (DWORD) lpChannelCaps,
	    (DWORD) dwSize);
}


/*****************************************************************************
 * @doc EXTERNAL VIDEO
 *
 * @func DWORD | videoUpdate | This function directs a channel to
 *   repaint the display.  It applies only to VIDEO_EXTERNALOUT channels.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm HWND | hWnd | Specifies the handle of the window to be used
 *      by the channel for image display.
 *
 * @parm HDC | hDC | Specifies a handle to a device context.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_UNSUPPORTED | Specified message is unsupported.
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 * @comm This message is normally sent
 *   whenever the client window receives a <m WM_MOVE>, <m WM_SIZE>,
 *   or <m WM_PAINT> message.
 ****************************************************************************/
DWORD WINAPI videoUpdate (HVIDEO hVideo, HWND hWnd, HDC hDC)
{
    if ((!hVideo) || (!hWnd) || (!hDC) )
        return DV_ERR_INVALHANDLE;

    return videoMessage(hVideo, DVM_UPDATE, (DWORD) hWnd, (DWORD) hDC);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoOpen | This function opens a channel on the
 *  specified video device.
 *
 * @parm LPHVIDEO | lphvideo | Specifies a far pointer to a buffer
 *   used to return an <t HVIDEO> handle. The video capture driver
 *   uses this location to return
 *   a handle that uniquely identifies the opened video device channel.
 *   Use the returned handle to identify the device channel when
 *   calling other video functions.
 *
 * @parm DWORD | dwDeviceID | Identifies the video device to open.
 *      The value of <p dwDeviceID> varies from zero to one less
 *      than the number of video capture devices installed in the system.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device.
 *      The following flags are defined:
 *
 *   @flag VIDEO_EXTERNALIN| Specifies the channel is opened
 *	     for external input. Typically, external input channels
 *      capture images into a frame buffer.
 *
 *   @flag VIDEO_EXTERNALOUT| Specifies the channel is opened
 *      for external output. Typically, external output channels
 *      display images stored in a frame buffer on an auxilary monitor
 *      or overlay.
 *
 *   @flag VIDEO_IN| Specifies the channel is opened
 *      for video input. Video input channels transfer images
 *      from a frame buffer to system memory buffers.
 *
 *   @flag VIDEO_OUT| Specifies the channel is opened
 *      for video output. Video output channels transfer images
 *      from system memory buffers to a frame buffer.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_BADDEVICEID | Indicates the specified device ID is out of range.
 *   @flag DV_ERR_ALLOCATED | Indicates the specified resource is already allocated.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm
 *   At a minimum, all capture drivers support a VIDEO_EXTERNALIN
 *   and a VIDEO_IN channel.
 *   Use <f videoGetNumDevs> to determine the number of video
 *   devices present in the system.
 *
 * @xref <f videoClose>
 ****************************************************************************/
DWORD WINAPI videoOpen (LPHVIDEO lphVideo, DWORD dwDeviceID, DWORD dwFlags)
{
    UINT w;
    VIDEO_OPEN_PARMS vop;       // Same as IC_OPEN struct!!!
    DWORD dwVersion = VIDEOAPIVERSION;

    if (IsBadWritePtr ((LPVOID) lphVideo, sizeof (HVIDEO)) )
        return DV_ERR_PARAM1;

    vop.dwSize = sizeof (VIDEO_OPEN_PARMS);
    vop.fccType = OPEN_TYPE_VCAP;       // "vcap"
    vop.fccComp = 0L;
    vop.dwVersion = VIDEOAPIVERSION;
    vop.dwFlags = dwFlags;      // In, Out, External In, External Out
    vop.dwError = DV_ERR_OK;

    w = (UINT) dwDeviceID;
    *lphVideo = NULL;

    if (!wTotalVideoDevs)   // trying to open without finding how many devs.
        videoGetNumDevs();

    if (!wTotalVideoDevs)              // No drivers installed
        return DV_ERR_BADINSTALL;

    if (w >= wTotalVideoDevs)
        return DV_ERR_BADDEVICEID;

    // New for Chicago, drivers are passed a Devnode if PnP at Open time
    vop.dnDevNode = aCapDriverList[w]->dnDevNode;

#ifdef UNICODE
    *lphVideo = (HVIDEO) OpenDriver(aCapDriverList[w]->szDriverName,
                        NULL, (LPARAM) (LPVOID) &vop);
#else

#if defined _WIN32
    *lphVideo = (HVIDEO) OpenDriverA(aCapDriverList[w]->szDriverName,
                        NULL, (LPARAM) (LPVOID) &vop);
#else
    *lphVideo = (HVIDEO) OpenDriver(aCapDriverList[w]->szDriverName,
                        NULL, (LPARAM) (LPVOID) &vop);
#endif
#endif


    if( ! *lphVideo ) {
        if (vop.dwError)    // if driver returned an error code...
            return vop.dwError;
        else {
#ifdef _WIN32
            if (GetFileAttributes(aCapDriverList[w]->szDriverName) == (DWORD) -1)
#else
            OFSTRUCT of;

            if (OpenFile (aCapDriverList[w]->szDriverName, &of, OF_EXIST) == HFILE_ERROR)
#endif
                return (DV_ERR_BADINSTALL);
            else
                return (DV_ERR_NOTDETECTED);
	}
    }

    return DV_ERR_OK;

}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoClose | This function closes the specified video
 *   device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *  If this function is successful, the handle is invalid
 *   after this call.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NONSPECIFIC | The driver failed to close the channel.
 *
 * @comm If buffers have been sent with <f videoStreamAddBuffer> and
 *   they haven't been returned to the application,
 *   the close operation fails. You can use <f videoStreamReset> to mark all
 *   pending buffers as done.
 *
 * @xref <f videoOpen> <f videoStreamInit> <f videoStreamFini> <f videoStreamReset>
 ****************************************************************************/
DWORD WINAPI videoClose (HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (CloseDriver((HDRVR)hVideo, 0L, 0L ))
       return DV_ERR_OK;

    return DV_ERR_NONSPECIFIC;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoConfigure | This function sets or retrieves
 *      the options for a configurable driver.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm UINT | msg  | Specifies the option to set or retrieve. The
 *       following options are defined:
 *
 *   @flag DVM_PALETTE | Indicates a palette is being sent to the driver
 *         or retrieved from the driver.
 *
 *   @flag DVM_PALETTERGB555 | Indicates an RGB555 palette is being
 *         sent to the driver.
 *
 *   @flag DVM_FORMAT | Indicates format information is being sent to
 *         the driver or retrieved from the driver.
 *
 * @parm DWORD | dwFlags | Specifies flags for configuring or
 *   interrogating the device driver. The following flags are defined:
 *
 *   @flag VIDEO_CONFIGURE_SET | Indicates values are being sent to the driver.
 *
 *   @flag VIDEO_CONFIGURE_GET | Indicates values are being obtained from the driver.
 *
 *   @flag VIDEO_CONFIGURE_QUERY | Determines if the
 *      driver supports the option specified by <p msg>. This flag
 *      should be combined with either the VIDEO_CONFIGURE_SET or
 *      VIDEO_CONFIGURE_GET flag. If this flag is
 *      set, the <p lpData1>, <p dwSize1>, <p lpData2>, and <p dwSize2>
 *      parameters are ignored.
 *
 *   @flag VIDEO_CONFIGURE_QUERYSIZE | Returns the size, in bytes,
 *      of the configuration option in <p lpdwReturn>. This flag is only valid if
 *      the VIDEO_CONFIGURE_GET flag is also set.
 *
 *   @flag VIDEO_CONFIGURE_CURRENT | Requests the current value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_NOMINAL | Requests the nominal value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_MIN | Requests the minimum value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *   @flag VIDEO_CONFIGURE_MAX | Get the maximum value.
 *      This flag is valid only if  the VIDEO_CONFIGURE_GET flag is also set.
 *	
 * @parm LPDWORD | lpdwReturn  | Points to a DWORD used for returning information
 *      from the driver.  If
 *      the VIDEO_CONFIGURE_QUERYSIZE flag is set, <p lpdwReturn> is
 *      filled with the size of the configuration option.
 *
 * @parm LPVOID | lpData1  |Specifies a pointer to message specific data.
 *
 * @parm DWORD | dwSize1  | Specifies the size, in bytes, of the <p lpData1>
 *       buffer.
 *
 * @parm LPVOID | lpData2  | Specifies a pointer to message specific data.
 *
 * @parm DWORD | dwSize2  | Specifies the size, in bytes, of the <p lpData2>
 *       buffer.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @xref <f videoOpen> <f videoMessage>
 *
 ****************************************************************************/
DWORD WINAPI videoConfigure (HVIDEO hVideo, UINT msg, DWORD dwFlags,
		LPDWORD lpdwReturn, LPVOID lpData1, DWORD dwSize1,
                LPVOID lpData2, DWORD dwSize2)
{
    VIDEOCONFIGPARMS    vcp;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (lpData1)
        if (IsBadHugeReadPtr (lpData1, dwSize1))
            return DV_ERR_CONFIG1;

    if (lpData2)
        if (IsBadHugeReadPtr (lpData2, dwSize2))
            return DV_ERR_CONFIG2;

    if (dwFlags & VIDEO_CONFIGURE_QUERYSIZE) {
        if (!lpdwReturn)
            return DV_ERR_NONSPECIFIC;
        if (IsBadWritePtr (lpdwReturn, sizeof (DWORD)) )
            return DV_ERR_NONSPECIFIC;
    }

    vcp.lpdwReturn = lpdwReturn;
    vcp.lpData1 = lpData1;
    vcp.dwSize1 = dwSize1;
    vcp.lpData2 = lpData2;
    vcp.dwSize2 = dwSize2;

    return videoMessage(hVideo, msg, dwFlags,
	    (DWORD)(LPVIDEOCONFIGPARMS)&vcp );
}



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoConfigureStorage | This function saves or loads
 *	     all configurable options for a channel.  Options
 *      can be saved and recalled for each application or each application
 *      instance.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPSTR | lpstrIdent  | Identifies the application or instance.
 *      Use an arbitrary string which uniquely identifies your application
 *      or instance.
 *
 * @parm DWORD | dwFlags | Specifies any flags for the function. The following
 *   flags are defined:
 *   @flag VIDEO_CONFIGURE_GET | Requests that the values be loaded.
 *   @flag VIDEO_CONFIGURE_SET | Requests that the values be saved.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @comm The method used by a driver to save configuration options is
 *      device dependent.
 *
 * @xref <f videoOpen>
 ****************************************************************************/

#if defined _WIN32
//
// for win32 this is the ansi entry point
//
DWORD WINAPI videoConfigureStorageA (
    HVIDEO hVideo,
    LPSTR lpstrIdent,
    DWORD dwFlags)
{
    DWORD ret;
    LPWSTR lpwstr;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;


    // Convert the input string to Unicode
    // Call the driver, free the Unicode string and return the result
    ret = strlen(lpstrIdent);
    lpwstr = LocalAlloc(LPTR, ret*sizeof(WCHAR));
    if (!lpwstr) {
        return(DV_ERR_NOMEM);
    }

    mbstowcs(lpwstr, lpstrIdent, ret);

    ret = videoMessage(hVideo, DVM_CONFIGURESTORAGE,
	    (DWORD)lpwstr, dwFlags);

    LocalFree(lpwstr);
    return(ret);
}

#endif // _WIN32

// this code is correct for WIN32 UNICODE and for win16
// messages we send are expected to contain unicode strings.
// so send them off...
//
#ifdef _WIN32
DWORD WINAPI videoConfigureStorageW (HVIDEO hVideo,
   LPWSTR lpstrIdent, DWORD  dwFlags)
#else
DWORD WINAPI videoConfigureStorage (HVIDEO hVideo,
   LPSTR lpstrIdent, DWORD  dwFlags)
#endif
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return videoMessage(hVideo, DVM_CONFIGURESTORAGE,
                        (DWORD)lpstrIdent, dwFlags);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoDialog | This function displays a channel-specific
 *     dialog box used to set configuration parameters.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm HWND | hWndParent | Specifies the parent window handle.
 *
 * @parm DWORD | dwFlags | Specifies flags for the dialog box. The
 *   following flag is defined:
 *   @flag VIDEO_DLG_QUERY | If this flag is set, the driver immediately
 *	     returns zero if it supplies a dialog box for the channel,
 *           or DV_ERR_NOTSUPPORTED if it does not.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Function is not supported.
 *
 * @comm Typically, each dialog box displayed by this
 *      function lets the user select options appropriate for the channel.
 *      For example, a VIDEO_IN channel dialog box lets the user select
 *      the image dimensions and bit depth.
 *
 * @xref <f videoOpen> <f videoConfigureStorage>
 ****************************************************************************/
DWORD WINAPI videoDialog (HVIDEO hVideo, HWND hWndParent, DWORD dwFlags)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if ((!hWndParent) || (!IsWindow (hWndParent)) )
        return DV_ERR_INVALHANDLE;

    return videoMessage(hVideo, DVM_DIALOG, (DWORD)hWndParent, dwFlags);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api DWORD | videoPrepareHeader | This function prepares the
 *	header and data
 *	by performing a <f GlobalPageLock>.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it
 *   specifies an error number.
 ****************************************************************************/
DWORD WINAPI videoPrepareHeader(LPVIDEOHDR lpVideoHdr, DWORD dwSize)
{
    if (!HugePageLock(lpVideoHdr, (DWORD)sizeof(VIDEOHDR)))
        return DV_ERR_NOMEM;

    if (!HugePageLock(lpVideoHdr->lpData, lpVideoHdr->dwBufferLength)) {
        HugePageUnlock(lpVideoHdr, (DWORD)sizeof(VIDEOHDR));
        return DV_ERR_NOMEM;
    }

    lpVideoHdr->dwFlags |= VHDR_PREPARED;

    return DV_ERR_OK;
}

/*****************************************************************************
 * @doc INTERNAL  VIDEO
 *
 * @api DWORD | videoUnprepareHeader | This function unprepares the header and
 *   data if the driver returns DV_ERR_NOTSUPPORTED.
 *
 * @rdesc Currently always returns DV_ERR_OK.
 ****************************************************************************/
DWORD WINAPI videoUnprepareHeader(LPVIDEOHDR lpVideoHdr, DWORD dwSize)
{

    HugePageUnlock(lpVideoHdr->lpData, lpVideoHdr->dwBufferLength);
    HugePageUnlock(lpVideoHdr, (DWORD)sizeof(VIDEOHDR));

    lpVideoHdr->dwFlags &= ~VHDR_PREPARED;

    return DV_ERR_OK;
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamAllocHdrAndBuffer | This function is used to allow
 *      drivers to optionally allocate video buffers.  Normally, the client
 *      application is responsible for allocating buffer memory, but devices
 *      which have on-board memory may optionally allocate headers and buffers
 *      using this function. Generally, this will avoid an additional data copy,
 *      resulting in faster capture rates.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR FAR * | plpvideoHdr | Specifies a pointer to the address of a
 *   <t VIDEOHDR> structure.  The driver saves the buffer address in this
 *   location, or NULL if it cannot allocate a buffer.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure
 *      and associated video buffer in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the driver does not have on-board memory.
 *
 * @comm If the driver
 *   allocates buffers via this method, the <f videoStreamPrepareHeader> and
 *   <f videoStreamUnprepareHeader> functions must not be used.
 *
 *   The buffer allocated must be accessible for DMA by the host.
 *
 * @xref <f videoStreamFreeHdrAndBuffer>
 ****************************************************************************/
DWORD WINAPI videoStreamAllocHdrAndBuffer(HVIDEO hVideo,
		LPVIDEOHDR FAR * plpvideoHdr, DWORD dwSize)
{
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (plpvideoHdr, sizeof (VIDEOHDR *)) )
        return DV_ERR_PARAM1;

    *plpvideoHdr = NULL;        // Init to NULL ptr

    wRet = (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_ALLOCHDRANDBUFFER,
            (DWORD)plpvideoHdr, (DWORD)dwSize);

    if (*plpvideoHdr == NULL ||
                IsBadHugeWritePtr (*plpvideoHdr, dwSize)) {
        DebugErr(DBF_WARNING,"videoStreamAllocHdrAndBuffer: Allocation failed.");
        *plpvideoHdr = NULL;
        return wRet;
    }

    if (IsVideoHeaderPrepared(HVIDEO, *plpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamAllocHdrAndBuffer: header is already prepared.");
        return DV_ERR_OK;
    }

    (*plpvideoHdr)->dwFlags = 0;

    if (wRet == DV_ERR_OK)
        MarkVideoHeaderPrepared(hVideo, *plpvideoHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamFreeHdrAndBuffer | This function is used to free
 *      buffers allocated by the driver using the <f videoStreamAllocHdrAndBuffer>
 *      function.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr | Specifies a pointer to the
 *   <t VIDEOHDR> structure and associated buffer to be freed.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the driver does not have on-board memory.
 *
 * @comm If the driver
 *   allocates buffers via this method, the <f videoStreamPrepareHeader> and
 *   <f videoStreamUnprepareHeader> functions must not be used.
 *
 * @xref <f videoStreamAllocHdrAndBuffer>
 ****************************************************************************/

DWORD WINAPI videoStreamFreeHdrAndBuffer(HVIDEO hVideo,
		LPVIDEOHDR lpvideoHdr)
{
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (lpvideoHdr->dwFlags & VHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "videoStreamFreeHdrAndBuffer: buffer still in queue.");
        return DV_ERR_STILLPLAYING;
    }

    if (!IsVideoHeaderPrepared(hVideo, lpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamFreeHdrAndBuffer: header is not prepared.");
    }

    wRet = (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_FREEHDRANDBUFFER,
            (DWORD)lpvideoHdr, (DWORD)0);

    if (wRet != DV_ERR_OK)
    {
        DebugErr(DBF_WARNING,"videoStreamFreeHdrAndBuffer: Error freeing buffer.");
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamPrepareHeader | This function prepares a buffer
 *   for video streaming.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr | Specifies a pointer to a
 *   <t VIDEOHDR> structure identifying the buffer to be prepared.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm Use this function after <f videoStreamInit> or
 *   after <f videoStreamReset> to prepare the data buffers
 *   for streaming data.
 *
 *   The <t VIDEOHDR> data structure and the data block pointed to by its
 *   <e VIDEOHDR.lpData> member must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags, and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared will have no effect
 *   and the function will return zero. Typically, this function is used
 *   to ensure that the buffer will be available for use at interrupt time.
 *
 * @xref <f videoStreamUnprepareHeader>
 ****************************************************************************/
DWORD WINAPI videoStreamPrepareHeader(HVIDEO hVideo,
		LPVIDEOHDR lpvideoHdr, DWORD dwSize)
{
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (IsVideoHeaderPrepared(HVIDEO, lpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamPrepareHeader: header is already prepared.");
        return DV_ERR_OK;
    }

    lpvideoHdr->dwFlags = 0;

    wRet = (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_PREPAREHEADER,
            (DWORD)lpvideoHdr, (DWORD)dwSize);

    if (wRet == DV_ERR_NOTSUPPORTED)
        wRet = videoPrepareHeader(lpvideoHdr, dwSize);

    if (wRet == DV_ERR_OK)
        MarkVideoHeaderPrepared(hVideo, lpvideoHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamUnprepareHeader | This function clears the
 *  preparation performed by <f videoStreamPrepareHeader>.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr |  Specifies a pointer to a <t VIDEOHDR>
 *   structure identifying the data buffer to be unprepared.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_STILLPLAYING | Indicates the structure identified by <p lpvideoHdr>
 *   is still in the queue.
 *
 * @comm This function is the complementary function to <f videoStreamPrepareHeader>.
 *   You must call this function before freeing the data buffer with <f GlobalFree>.
 *   After passing a buffer to the device driver with <f videoStreamAddBuffer>, you
 *   must wait until the driver is finished with the buffer before calling
 *   <f videoStreamUnprepareHeader>. Unpreparing a buffer that has not been
 *   prepared or has been already unprepared has no effect,
 *   and the function returns zero.
 *
 * @xref <f videoStreamPrepareHeader>
 ****************************************************************************/
DWORD WINAPI videoStreamUnprepareHeader(HVIDEO hVideo, LPVIDEOHDR lpvideoHdr, DWORD dwSize)
{
    DWORD         wRet;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (lpvideoHdr->dwFlags & VHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "videoStreamUnprepareHeader: buffer still in queue.");
        return DV_ERR_STILLPLAYING;
    }

    if (!IsVideoHeaderPrepared(hVideo, lpvideoHdr))
    {
        DebugErr(DBF_WARNING,"videoStreamUnprepareHeader: header is not prepared.");
        return DV_ERR_OK;
    }

    wRet = (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_UNPREPAREHEADER,
            (DWORD)lpvideoHdr, (DWORD)dwSize);

    if (wRet == DV_ERR_NOTSUPPORTED)
        wRet = videoUnprepareHeader(lpvideoHdr, dwSize);

    if (wRet == DV_ERR_OK)
        MarkVideoHeaderUnprepared(hVideo, lpvideoHdr);

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamAddBuffer | This function sends a buffer to a
 *   video-capture device. After the buffer is filled by the device,
 *   the device sends it back to the application.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPVIDEOHDR | lpvideoHdr | Specifies a far pointer to a <t VIDEOHDR>
 *   structure that identifies the buffer.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t VIDEOHDR> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_UNPREPARED | Indicates the <p lpvideoHdr> structure hasn't been prepared.
 *   @flag DV_ERR_STILLPLAYING | Indicates a buffer is still in the queue.
 *   @flag DV_ERR_PARAM1 | The <p lpvideoHdr> parameter is invalid or
 *       the <e VIDEOHDR.dwBufferLength> member of the <t VIDEOHDR>
 *       structure is not set to the proper value.
 *
 * @comm The data buffer must be prepared with <f videoStreamPrepareHeader>
 *   before it is passed to <f videoStreamAddBuffer>. The <t VIDEOHDR> data
 *   structure and the data buffer referenced by its <e VIDEOHDR.lpData>
 *   member must be allocated with <f GlobalAlloc> using the GMEM_MOVEABLE
 *   and GMEM_SHARE flags, and locked with <f GlobalLock>. Set the
 *   <e VIDEOHDR.dwBufferLength> member to the size of the header.
 *
 * @xref <f videoStreamPrepareHeader>
 ****************************************************************************/
DWORD WINAPI videoStreamAddBuffer(HVIDEO hVideo, LPVIDEOHDR lpvideoHdr, DWORD dwSize)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpvideoHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    if (!IsVideoHeaderPrepared(hVideo, lpvideoHdr))
    {
        DebugErr(DBF_WARNING, "videoStreamAddBuffer: buffer not prepared.");
        return DV_ERR_UNPREPARED;
    }

    if (lpvideoHdr->dwFlags & VHDR_INQUEUE)
    {
        DebugErr(DBF_WARNING, "videoStreamAddBuffer: buffer already in queue.");
        return DV_ERR_STILLPLAYING;
    }

    return (DWORD)videoMessage((HVIDEO)hVideo, DVM_STREAM_ADDBUFFER, (DWORD)lpvideoHdr, (DWORD)dwSize);
}



/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamStop | This function stops streaming on a video channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video
 *   device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following error is defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 * @comm If there are any buffers in the queue, the current buffer will be
 *   marked as done (the <e VIDEOHDR.dwBytesRecorded> member in
 *   the <t VIDEOHDR> header will contain the actual length of data), but any
 *   empty buffers in the queue will remain there. Calling this
 *   function when the channel is not started has no effect, and the
 *   function returns zero.
 *
 * @xref <f videoStreamStart> <f videoStreamReset>
 ****************************************************************************/
DWORD WINAPI videoStreamStop(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return videoMessage((HVIDEO)hVideo, DVM_STREAM_STOP, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamReset | This function stops streaming
 *	     on the specified video device channel and resets the current position
 *      to zero.  All pending buffers are marked as done and
 *      are returned to the application.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 *
 * @xref <f videoStreamReset> <f videoStreamStop> <f videoStreamAddBuffer> <f videoStreamClose>
/****************************************************************************/
DWORD WINAPI videoStreamReset(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return videoMessage((HVIDEO)hVideo, DVM_STREAM_RESET, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamGetPosition | This function retrieves the current
 *   position of the specified video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPMMTIME | lpInfo | Specifies a far pointer to an <t MMTIME>
 *   structure.
 *
 * @parm DWORD | dwSize | Specifies the size of the <t MMTIME> structure in bytes.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *
 *   @flag DV_ERR_INVALHANDLE | Indicates the specified device handle is invalid.
 *
 * @comm Before using <f videoStreamGetPosition>, set the
 *   <e MMTIME.wType> member of the <t MMTIME> structure to indicate
 *   the time format desired. After
 *   <f videoStreamGetPosition> returns, check the <e MMTIME.wType>
 *   member to  determine if the your time format is supported. If
 *   not, <e MMTIME.wType> specifies an alternate format.
 *   Video capture drivers typically provide the millisecond time
 *   format.
 *
 *   The position is set to zero when streaming is started with
 *   <f videoStreamStart>.
 ****************************************************************************/
DWORD WINAPI videoStreamGetPosition(HVIDEO hVideo, LPMMTIME lpInfo, DWORD dwSize)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpInfo, sizeof (MMTIME)) )
        return DV_ERR_PARAM1;

    return videoMessage(hVideo, DVM_STREAM_GETPOSITION,
            (DWORD)lpInfo, (DWORD)dwSize);
}

// ============================================

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamInit | This function initializes a video
 *     device channel for streaming.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm DWORD | dwMicroSecPerFrame | Specifies the number of microseconds
 *     between frames.
 *
 * @parm DWORD | dwCallback | Specifies the address of a callback
 *   function or a handle to a window called during video
 *   streaming. The callback function or window processes
 *  messages related to the progress of streaming.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user
 *  instance data passed to the callback function. This parameter is not
 *  used with window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device channel.
 *   The following flags are defined:
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_BADDEVICEID | Indicates the device ID specified in
 *         <p hVideo> is not valid.
 *   @flag DV_ERR_ALLOCATED | Indicates the resource specified is already allocated.
 *   @flag DV_ERR_NOMEM | Indicates the device is unable to allocate or lock memory.
 *
 * @comm If a window or function is chosen to receive callback information, the following
 *   messages are sent to it to indicate the
 *   progress of video input:
 *
 *   <m MM_DRVM_OPEN> is sent at the time of <f videoStreamInit>
 *
 *   <m MM_DRVM_CLOSE> is sent at the time of <f videoStreamFini>
 *
 *   <m MM_DRVM_DATA> is sent when a buffer of image data is available
 *
 *   <m MM_DRVM_ERROR> is sent when an error occurs
 *
 *   Callback functions must reside in a DLL.
 *   You do not have to use <f MakeProcInstance> to get
 *   a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | videoFunc | <f videoFunc> is a placeholder for an
 *   application-supplied function name. The actual name must be exported by
 *   including it in an EXPORTS statement in the DLL's module-definition file.
 *   This is used only when a callback function is specified in
 *   <f videoStreamInit>.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel
 *   associated with the callback.
 *
 * @parm DWORD | wMsg | Specifies the <m MM_DRVM_> messages. Messages indicate
 *       errors and when image data is available. For information on
 *       these messages, see <f videoStreamInit>.
 *
 * @parm DWORD | dwInstance | Specifies the user instance
 *   data specified with <f videoStreamInit>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL. Any data the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref <f videoOpen> <f videoStreamFini> <f videoClose>
 ****************************************************************************/
DWORD WINAPI videoStreamInit(HVIDEO hVideo,
              DWORD dwMicroSecPerFrame, DWORD_PTR dwCallback,
              DWORD_PTR dwCallbackInst, DWORD dwFlags)
{
    VIDEO_STREAM_INIT_PARMS vsip;

    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (dwCallback && ((dwFlags & CALLBACK_TYPEMASK) == CALLBACK_FUNCTION) ) {
        if (IsBadCodePtr ((FARPROC) dwCallback) )
            return DV_ERR_PARAM2;
        if (!dwCallbackInst)
            return DV_ERR_PARAM2;
    }

    if (dwCallback && ((dwFlags & CALLBACK_TYPEMASK) == CALLBACK_WINDOW) ) {
        if (!IsWindow((HWND) dwCallback) )
            return DV_ERR_PARAM2;
    }

    vsip.dwMicroSecPerFrame = dwMicroSecPerFrame;
    vsip.dwCallback = dwCallback;
    vsip.dwCallbackInst = dwCallbackInst;
    vsip.dwFlags = dwFlags;
    vsip.hVideo = (DWORD_PTR)hVideo;

    return videoMessage(hVideo, DVM_STREAM_INIT,
                (DWORD_PTR) (LPVIDEO_STREAM_INIT_PARMS) &vsip,
                (DWORD) sizeof (VIDEO_STREAM_INIT_PARMS));
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamFini | This function terminates streaming
 *     from the specified device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *   @flag DV_ERR_STILLPLAYING | Indicates there are still buffers in the queue.
 *
 * @comm If there are buffers that have been sent with
 *   <f videoStreamAddBuffer> that haven't been returned to the application,
 *   this operation will fail. Use <f videoStreamReset> to return all
 *   pending buffers.
 *
 *   Each call to <f videoStreamInit> must be matched with a call to
 *   <f videoStreamFini>.
 *
 *   For VIDEO_EXTERNALIN channels, this function is used to
 *   halt capturing of data to the frame buffer.
 *
 *   For VIDEO_EXTERNALOUT channels supporting overlay,
 *   this function is used to disable the overlay.
 *
 * @xref <f videoStreamInit>
 ****************************************************************************/
DWORD WINAPI videoStreamFini(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return videoMessage(hVideo, DVM_STREAM_FINI, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamStart | This function starts streaming on the
 *   specified video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 *   @flag DV_ERR_NOTSUPPORTED | Indicates the device does not support this
 *         function.
 *
 * @xref <f videoStreamReset> <f videoStreamStop> <f videoStreamAddBuffer> <f videoStreamClose>
/****************************************************************************/
DWORD WINAPI videoStreamStart(HVIDEO hVideo)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    return videoMessage(hVideo, DVM_STREAM_START, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoStreamGetError | This function returns the error
 *   most recently encountered.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *
 * @parm LPDWORD | lpdwErrorID | Specifies a far pointer to the <t DWORD>
 *      used to return the error ID.
 *
 * @parm LPDWORD | lpdwErrorValue | Specifies a far pointer to the <t DWORD>
 *      used to return the number of frames skipped.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following error is defined:
 *   @flag DV_ERR_INVALHANDLE | Indicates the device handle specified is invalid.
 *
 * @comm While streaming video data, a capture
 *      driver can fill buffers faster than the client application can
 *      save the buffers to disk.  In this case, the
 *      DV_ERR_NO_BUFFERS error is returned in <p lpdwErrorID>
 *      and <p lpdwErrorValue> contains a count of the number of
 *      frames missed.  After
 *      receiving this message and returning the error status, a driver
 *      should reset its internal error flag to DV_ERR_OK and
 *      the count of missed frames to zero.
 *
 *      Applications should send this message frequently during capture
 *      since some drivers which do not have access to interrupts use
 *      this message to trigger buffer processing.
 *
 * @xref <f videoOpen>
/****************************************************************************/
DWORD WINAPI videoStreamGetError(HVIDEO hVideo, LPDWORD lpdwError,
        LPDWORD lpdwFramesSkipped)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (IsBadWritePtr (lpdwError, sizeof (DWORD)) )
        return DV_ERR_PARAM1;

    if (IsBadWritePtr (lpdwFramesSkipped, sizeof (DWORD)) )
        return DV_ERR_PARAM2;

    return videoMessage(hVideo, DVM_STREAM_GETERROR, (DWORD) lpdwError,
        (DWORD) lpdwFramesSkipped);
}

/*****************************************************************************
 * @doc EXTERNAL  VIDEO
 *
 * @api DWORD | videoFrame | This function transfers a single frame
 *   to or from a video device channel.
 *
 * @parm HVIDEO | hVideo | Specifies a handle to the video device channel.
 *      The channel must be of type VIDEO_IN or VIDEO_OUT.
 *
 * @parm LPVIDEOHDR | lpVHdr | Specifies a far pointer to an <t VIDEOHDR>
 *      structure.
 *
 * @rdesc Returns zero if the function was successful. Otherwise, it returns
 *   an error number. The following errors are defined:
 *   @flag DV_ERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag DV_ERR_PARAM1 | The <p lpVDHdr> parameter is invalid or
 *       the <e VIDEOHDR.dwBufferLength> member of the <t VIDEOHDR>
 *       structure is not set to the proper value.
 *
 * @comm Use this function with a VIDEO_IN channel to transfer a single
 *      image from the frame buffer.
 *      Use this function with a VIDEO_OUT channel to transfer a single
 *      image to the frame buffer.
 *
 * @xref <f videoOpen>
/****************************************************************************/
DWORD WINAPI videoFrame (HVIDEO hVideo, LPVIDEOHDR lpVHdr)
{
    if (!hVideo)
        return DV_ERR_INVALHANDLE;

    if (!lpVHdr)
        return DV_ERR_PARAM1;

    if (IsBadWritePtr (lpVHdr, sizeof (VIDEOHDR)) )
        return DV_ERR_PARAM1;

    return videoMessage(hVideo, DVM_FRAME, (DWORD) lpVHdr,
                        sizeof(VIDEOHDR));
}

#endif  // ifdef WIN16

/**************************************************************************
* @doc INTERNAL VIDEO
*
* @api void | videoCleanup | clean up video stuff
*   called in MSVIDEOs WEP()
*
**************************************************************************/
void FAR PASCAL videoCleanup(HTASK hTask)
{
#ifdef WIN16
        videoFreeDriverList();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\buttons.c ===
/******************************Module*Header*******************************\
* Module Name: buttons.c
*
* Bitmap button support.  On Daytona bitmap buttons are provided by
* mmcntrls.  On Chicago there is no mmcntrls, so we use the functions
* in this file.
*
*
* Created: 19-04-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>

#include "buttons.h"
#include "literals.h"


/* -------------------------------------------------------------------------
** Color globals
** -------------------------------------------------------------------------
*/
int         nSysColorChanges = 0;
DWORD       rgbFace;
DWORD       rgbShadow;
DWORD       rgbHilight;
DWORD       rgbFrame;



/*****************************Private*Routine******************************\
* PatB
*
* Fast way to fill an rectangle with a solid colour.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
PatB(
    HDC hdc,
    int x,
    int y,
    int dx,
    int dy,
    DWORD rgb
    )
{
    RECT    rc;

    SetBkColor(hdc,rgb);
    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}




/*****************************Private*Routine******************************\
* CheckSysColors
*
* Checks the system colors and updates the cached global variables if
* they have changed.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CheckSysColors(
    void
    )
{
   static COLORREF rgbSaveFace    = 0xffffffffL,
                   rgbSaveShadow  = 0xffffffffL,
                   rgbSaveHilight = 0xffffffffL,
                   rgbSaveFrame   = 0xffffffffL;

   rgbFace    = GetSysColor(COLOR_BTNFACE);
   rgbShadow  = GetSysColor(COLOR_BTNSHADOW);
   rgbHilight = GetSysColor(COLOR_BTNHIGHLIGHT);
   rgbFrame   = GetSysColor(COLOR_WINDOWFRAME);

   if (rgbSaveFace!=rgbFace || rgbSaveShadow!=rgbShadow
      || rgbSaveHilight!=rgbHilight || rgbSaveFrame!=rgbFrame)
   {
      ++nSysColorChanges;

      rgbSaveFace    = rgbFace;
      rgbSaveShadow  = rgbShadow;
      rgbSaveHilight = rgbHilight;
      rgbSaveFrame   = rgbFrame;

   }
}


/* -------------------------------------------------------------------------
** Button globals  -- some of these should be constants
** -------------------------------------------------------------------------
*/
const TCHAR   szBbmProp[]     = TEXT("ButtonBitmapProp");
const TCHAR   szButtonProp[]  = TEXT("ButtonProp");

typedef struct tagBTNSTATE {      /* instance data for toolbar window */
    WNDPROC     lpfnDefProc;
    HWND        hwndToolTips;
    HINSTANCE   hInst;
    UINT        wID;
    UINT        uStyle;
    HBITMAP     hbm;
    HDC         hdcGlyphs;
    HDC         hdcMono;
    HBITMAP     hbmMono;
    HBITMAP     hbmDefault;
    int         dxBitmap;
    int         dyBitmap;
    int         nButtons;
    int         nSysColorChanges;
    BITMAPBTN   Buttons[1];
} BTNSTATE, NEAR *PBTNSTATE, FAR *LPBTNSTATE;

typedef struct {
    WNDPROC     lpfnDefProc;
    HWND        hwndParent;
    HWND        hwndToolTips;
} BTN_INFO, *LPBTN_INFO;


LRESULT CALLBACK
ButtonSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT CALLBACK
ParentSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

void FAR PASCAL
RelayToToolTips(
    HWND hwndToolTips,
    HWND hWnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
InitObjects(
    LPBTNSTATE pTBState
    );

BOOL
FreeObjects(
    LPBTNSTATE pTBState
    );

void
CreateButtonMask(
    LPBTNSTATE pTBState,
    PBITMAPBTN pTBButton
    );


/*****************************Private*Routine******************************\
* InitObjects
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
InitObjects(
    LPBTNSTATE pTBState
    )
{
    pTBState->hdcGlyphs = CreateCompatibleDC(NULL);
    if (pTBState->hdcGlyphs == NULL ) {
        return FALSE;
    }

    pTBState->hdcMono = CreateCompatibleDC(NULL);
    if (pTBState->hdcMono == NULL ) {
        DeleteObject( pTBState->hdcGlyphs );
        return FALSE;
    }

    pTBState->hbmMono = CreateBitmap( pTBState->dxBitmap,
                                      pTBState->dyBitmap, 1, 1, NULL);
    if ( pTBState->hbmMono == NULL ) {
        DeleteObject( pTBState->hdcGlyphs );
        DeleteObject( pTBState->hdcMono );
        return FALSE;
    }

    pTBState->hbmDefault = SelectObject(pTBState->hdcMono, pTBState->hbmMono);

    return TRUE;
}


/*****************************Private*Routine******************************\
* FreeObjects
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
FreeObjects(
    LPBTNSTATE pTBState
    )
{
    if (pTBState->hdcMono) {
        SelectObject(pTBState->hdcMono, pTBState->hbmDefault);
        DeleteDC(pTBState->hdcMono);              /* toast the DCs */
    }

    if (pTBState->hdcGlyphs) {
        DeleteDC(pTBState->hdcGlyphs);
    }

    if (pTBState->hbmMono) {
        DeleteObject(pTBState->hbmMono);
    }

    return TRUE;
}



/*****************************Private*Routine******************************\
* CreateButtonMask
*
* create a mono bitmap mask:
*   1's where color == COLOR_BTNFACE || COLOR_HILIGHT
*   0's everywhere else
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CreateButtonMask(
    LPBTNSTATE pTBState,
    PBITMAPBTN pTBButton
    )
{
    /* initalize whole area with 0's */
    PatBlt( pTBState->hdcMono, 0, 0, pTBState->dxBitmap,
            pTBState->dyBitmap, WHITENESS);

    /* create mask based on color bitmap
    ** convert this to 1's
    */
    SetBkColor(pTBState->hdcGlyphs, rgbFace);
    BitBlt( pTBState->hdcMono, 0, 0, pTBState->dxBitmap, pTBState->dyBitmap,
            pTBState->hdcGlyphs, pTBButton->iBitmap * pTBState->dxBitmap, 0,
            SRCCOPY );

    /* convert this to 1's */
    SetBkColor(pTBState->hdcGlyphs, rgbHilight);

    /* OR in the new 1's */
    BitBlt( pTBState->hdcMono, 0, 0, pTBState->dxBitmap, pTBState->dyBitmap,
            pTBState->hdcGlyphs, pTBButton->iBitmap * pTBState->dxBitmap, 0,
            SRCPAINT );
}



#define PSDPxax     0x00B8074A


/*****************************Private*Routine******************************\
* BtnDrawButton
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void WINAPI
BtnDrawButton(
    HWND hwnd,
    HDC hdc,
    int dx,
    int dy,
    LPBITMAPBTN ptButton
    )
{
    int         glyph_offset;
    HBRUSH      hbrOld, hbr;
    BOOL        bMaskCreated = FALSE;
    RECT        rcFocus;
    PBTNSTATE   pTBState;
    int         x = 0, y = 0;


    pTBState = (PBTNSTATE)GetProp(hwnd, szBbmProp);

    CheckSysColors();
    if (pTBState->nSysColorChanges != nSysColorChanges) {

        DeleteObject( pTBState->hbm );
        pTBState->hbm = CreateMappedBitmap( pTBState->hInst,
                                            pTBState->wID, TRUE, NULL, 0);
        pTBState->nSysColorChanges = nSysColorChanges;
    }

    /*
    ** erase with face color
    */

    PatB(hdc, x, y, dx, dy, rgbFace);
    SetRect( &rcFocus, x, y, x + dx, y + dy );

    if (ptButton->fsState & BTNSTATE_PRESSED) {
        DrawEdge( hdc, &rcFocus, EDGE_SUNKEN, BF_RECT );
        glyph_offset = 1;
    }
    else {
        DrawEdge( hdc, &rcFocus, EDGE_RAISED, BF_RECT );
        glyph_offset = 0;
    }


    /*
    ** make the coordinates the interior of the button
    */
    x += 2;
    y += 2;
    dx -= 4;
    dy -= 4;

    SelectObject( pTBState->hdcGlyphs, pTBState->hbm );

    /* now put on the face */

    /*
    ** We need to centre the Bitmap here within the button
    */
    x += (dx - pTBState->dxBitmap ) / 2;
    y += (dy - pTBState->dyBitmap ) / 2;

    if (!(ptButton->fsState & BTNSTATE_DISABLED)) {

        /* regular version */
        BitBlt( hdc, x + glyph_offset, y + glyph_offset,
                pTBState->dxBitmap, pTBState->dyBitmap,
                pTBState->hdcGlyphs,
                ptButton->iBitmap * pTBState->dxBitmap, 0, SRCCOPY);
    }
    else {

        /* disabled version */
        bMaskCreated = TRUE;
        CreateButtonMask(pTBState, ptButton );

        SetTextColor(hdc, 0L);          /* 0's in mono -> 0 (for ROP) */
        SetBkColor(hdc, 0x00FFFFFF);    /* 1's in mono -> 1 */

        hbr = CreateSolidBrush(rgbHilight);
        if (hbr) {
            hbrOld = SelectObject(hdc, hbr);
            if (hbrOld) {
                /* draw hilight color where we have 0's in the mask */
                BitBlt( hdc, x + 1, y + 1,
                        pTBState->dxBitmap, pTBState->dyBitmap,
                        pTBState->hdcMono, 0, 0, PSDPxax);
                SelectObject(hdc, hbrOld);
            }
            DeleteObject(hbr);
        }

        hbr = CreateSolidBrush(rgbShadow);
        if (hbr) {
            hbrOld = SelectObject(hdc, hbr);
            if (hbrOld) {
                /* draw the shadow color where we have 0's in the mask */
                BitBlt(hdc, x, y, pTBState->dxBitmap, pTBState->dyBitmap,
                       pTBState->hdcMono, 0, 0, PSDPxax);
                SelectObject(hdc, hbrOld);
            }
            DeleteObject(hbr);
        }
    }

    if (ptButton->fsState & ODS_FOCUS) {

        BtnDrawFocusRect(hdc, &rcFocus, ptButton->fsState);
    }
}



/*****************************Private*Routine******************************\
* BtnCreateBitmapButtons
*
* Returns TRUE if successful, otherwise FALSE;
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL WINAPI
BtnCreateBitmapButtons(
    HWND hWnd,
    HINSTANCE hInst,
    UINT wID,
    UINT uStyle,
    LPBITMAPBTN lpButtons,
    int nButtons,
    int dxBitmap,
    int dyBitmap
    )
{
    PBTNSTATE pTBState;


    /*
    ** If we have already created Bitmap Buttons for this
    ** window just return.
    */
    if (GetProp(hWnd, szBbmProp)) {
        return TRUE;
    }


    CheckSysColors();

    /*
    ** Allocate the required storage and save the pointer in the window
    ** property list.
    */
    pTBState = (PBTNSTATE)LocalAlloc( LMEM_FIXED,
                                      (sizeof(BTNSTATE) - sizeof(BITMAPBTN)) +
                                      (nButtons * sizeof(BITMAPBTN)) );
    if (pTBState == NULL ) {
        return FALSE;
    }
    SetProp(hWnd, szBbmProp, (HANDLE)pTBState);


    pTBState->hInst       = hInst;
    pTBState->wID         = wID;
    pTBState->uStyle      = uStyle;
    pTBState->nButtons    = nButtons;
    pTBState->hbm         = CreateMappedBitmap( hInst, wID, TRUE, NULL, 0);
    pTBState->dxBitmap    = dxBitmap;
    pTBState->dyBitmap    = dyBitmap;

    InitObjects( pTBState );

    CopyMemory( pTBState->Buttons, lpButtons, nButtons * sizeof(BITMAPBTN) );

    /*
    ** Does the caller want tool tips ?
    */
    if (pTBState->uStyle & BBS_TOOLTIPS) {

        pTBState->hwndToolTips = CreateWindow(TOOLTIPS_CLASS, g_szEmpty,
                                              WS_POPUP,
                                              CW_USEDEFAULT, CW_USEDEFAULT,
                                              CW_USEDEFAULT, CW_USEDEFAULT,
                                              hWnd, NULL, hInst, NULL);

        if (pTBState->hwndToolTips != (HWND)NULL ) {

            int         i;
            TOOLINFO    ti;

            pTBState->lpfnDefProc = SubclassWindow( hWnd, ParentSubclassProc );

            ti.uFlags = 0;
            ti.cbSize = sizeof(ti);
            ti.lpszText = LPSTR_TEXTCALLBACK;

            for ( i = 0; i < nButtons; i++ ) {

                LPBTN_INFO  lpBtnInfo;
                HWND        hwndBtn;

                hwndBtn = GetDlgItem(hWnd, pTBState->Buttons[i].uId);
                if ( hwndBtn == (HWND)NULL ) {
                    break;
                }

                lpBtnInfo = (LPBTN_INFO)LocalAlloc(LPTR, sizeof(BTN_INFO));
                if (lpBtnInfo == NULL ) {
                    break;
                }

                SetProp(hwndBtn, szButtonProp, (HANDLE)lpBtnInfo);
                lpBtnInfo->hwndToolTips = pTBState->hwndToolTips;
                lpBtnInfo->hwndParent   = hWnd;
                lpBtnInfo->lpfnDefProc = SubclassWindow( hwndBtn,
                                                         ButtonSubclassProc );

                ti.hwnd = hwndBtn;
                ti.uId = pTBState->Buttons[i].uId;

                GetClientRect( hwndBtn, &ti.rect );
                SendMessage( lpBtnInfo->hwndToolTips, TTM_ADDTOOL,
                             (WPARAM)0, (LPARAM)&ti );


                /*
                ** Add the same rectangle in parent co-ordinates so that
                ** the tooltip still gets displayed even though the button
                ** is disabled.
                */
                MapWindowRect( hwndBtn, hWnd, &ti.rect );
                ti.hwnd = hWnd;
                SendMessage( lpBtnInfo->hwndToolTips, TTM_ADDTOOL,
                             (WPARAM)0, (LPARAM)&ti );
            }

        }
        else {

            /*
            ** No tips available, just remove the BBS_TOOLTIPS style
            */
            pTBState->uStyle &= ~BBS_TOOLTIPS;
        }
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* BtnDestroyBitmapButtons
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void WINAPI
BtnDestroyBitmapButtons(
    HWND hwnd
    )
{
    PBTNSTATE pTBState;

    pTBState = (PBTNSTATE)GetProp(hwnd, szBbmProp);
    if ( pTBState != NULL ) {

        DeleteObject( pTBState->hbm );
        FreeObjects( pTBState );
    }
    RemoveProp(hwnd, szBbmProp);
}


/******************************Public*Routine******************************\
* BtnDrawFocusRect
*
* Use this function to draw focus rectangle around a bitmap button.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void WINAPI
BtnDrawFocusRect(
    HDC hdc,
    const RECT *lpRect,
    UINT fsState
    )
{
    int     iFaceOffset;
    RECT    rc;

    CopyRect( &rc, lpRect );

    rc.top = rc.left = 3;

    if (fsState & ODS_SELECTED) {
        iFaceOffset = 2;
    }
    else {
        iFaceOffset = 4;
    }

    rc.right  -= iFaceOffset;
    rc.bottom -= iFaceOffset;

    SetBkColor( hdc, rgbFace );
    DrawFocusRect( hdc, &rc );
}


/******************************Public*Routine******************************\
* BtnUpdateColors
*
* After a WM_SYSCOLORCHANGE message is received this function should be
* called to update the colors of the button bitmaps.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void WINAPI
BtnUpdateColors(
    HWND hwnd
    )
{
    PBTNSTATE   pTBState;

    pTBState = (PBTNSTATE)GetProp(hwnd, szBbmProp);
    if (pTBState->nSysColorChanges != nSysColorChanges)
    {
        DeleteObject( pTBState->hbm );
        pTBState->hbm = CreateMappedBitmap( pTBState->hInst,
                                            pTBState->wID, TRUE, NULL, 0);

        pTBState->nSysColorChanges = nSysColorChanges;
    }
}


/******************************Public*Routine******************************\
* ButtonSubclassProc
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
ButtonSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LPBTN_INFO  lpBtnInfo;
    WNDPROC     lpfnDefProc;


    lpBtnInfo = (LPBTN_INFO)GetProp( hwnd, szButtonProp );

    /*
    ** Save this in case anything happens to lpBtnInfo before we return.
    */
    lpfnDefProc = lpBtnInfo->lpfnDefProc;

    switch ( uMsg ) {

    case WM_DESTROY:
        SubclassWindow( hwnd, lpfnDefProc );
        if (lpBtnInfo) {
            LocalFree((HLOCAL)lpBtnInfo);
            RemoveProp(hwnd, szButtonProp);
        }
        break;

    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONUP:
    case WM_MOUSEMOVE:
        RelayToToolTips( lpBtnInfo->hwndToolTips, hwnd, uMsg, wParam, lParam );
        break;

    case WM_MOVE:
        {
            TOOLINFO    ti;

            ti.cbSize = sizeof(ti);
            ti.uFlags = 0;
            ti.hwnd = hwnd;
            ti.lpszText = LPSTR_TEXTCALLBACK;
            ti.uId = GetDlgCtrlID( hwnd );

            GetClientRect( hwnd, &ti.rect );

            SendMessage( lpBtnInfo->hwndToolTips, TTM_NEWTOOLRECT, 0,
                         (LPARAM)&ti );

            /*
            ** Add the same rectangle in parent co-ordinates so that
            ** the tooltip still gets displayed even though the button
            ** is disabled.
            */
            MapWindowRect( hwnd, lpBtnInfo->hwndParent, &ti.rect );
            ti.hwnd = lpBtnInfo->hwndParent;
            SendMessage( lpBtnInfo->hwndToolTips, TTM_NEWTOOLRECT,
                         (WPARAM)0, (LPARAM)&ti );
        }
        break;

    case WM_NOTIFY:
        SendMessage(lpBtnInfo->hwndParent, WM_NOTIFY, wParam, lParam);
        break;

    }

    return CallWindowProc(lpfnDefProc, hwnd, uMsg, wParam, lParam);
}


/******************************Public*Routine******************************\
* ParentSubclassProc
*
* Why do I need to subclass the buttons parent window ?  Well,
* if a button is disable it will not receive mouse messages, the
* messages go to the window underneath the button (ie. the parent).
* Therefore we detect this and relay the mouse message to the tool tips
* window as above.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
ParentSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    WNDPROC     lpfnDefProc;
    PBTNSTATE   pTBState;


    pTBState = (PBTNSTATE)GetProp(hwnd, szBbmProp);

    /*
    ** Save this in case anything happens to lpBtnInfo before we return.
    */
    lpfnDefProc = pTBState->lpfnDefProc;

    switch ( uMsg ) {

    case TB_GETTOOLTIPS:
        return (LRESULT)(UINT)pTBState->hwndToolTips;

    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONUP:
    case WM_MOUSEMOVE:
    case WM_NCMOUSEMOVE:
        RelayToToolTips( pTBState->hwndToolTips, hwnd, uMsg, wParam, lParam );
        break;
    }

    return CallWindowProc(lpfnDefProc, hwnd, uMsg, wParam, lParam);
}

/******************************Public*Routine******************************\
* RelayToToolTips
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void FAR PASCAL
RelayToToolTips(
    HWND hwndToolTips,
    HWND hWnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if(hwndToolTips) {
        MSG msg;
        msg.lParam = lParam;
        msg.wParam = wParam;
        msg.message = wMsg;
        msg.hwnd = hWnd;
        SendMessage(hwndToolTips, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)&msg);
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\buttons.h ===
/******************************Module*Header*******************************\
* Module Name: chicago.h
*
* CD Playing application - support for Chicago
*
*
* Created: 19-04-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

/* -------------------------------------------------------------------------
** Button helper functions
** -------------------------------------------------------------------------
*/
void
PatB(
    HDC hdc,
    int x,
    int y,
    int dx,
    int dy,
    DWORD rgb
    );

void
CheckSysColors(
    void
    );


extern DWORD        rgbFace;
extern DWORD        rgbShadow;
extern DWORD        rgbHilight;
extern DWORD        rgbFrame;
extern int          nSysColorChanges;


#ifndef NOBITMAPBTN

/* -------------------------------------------------------------------------
** Bitmap button styles
** -------------------------------------------------------------------------
*/

/*
** If you want little tool tips to popup next to your toolbar buttons
** use the style below.
*/
#define BBS_TOOLTIPS    0x00000100L   /* make/use a tooltips control */



/* -------------------------------------------------------------------------
** Bitmap button states
** -------------------------------------------------------------------------
*/
#define BTNSTATE_PRESSED     ODS_SELECTED
#define BTNSTATE_DISABLED    ODS_DISABLED
#define BTNSTATE_HAS_FOCUS   ODS_FOCUS




/* -------------------------------------------------------------------------
** Bitmap button structures
** -------------------------------------------------------------------------
*/
typedef struct {
    int     iBitmap;    /* Index into mondo bitmap of this button's picture */
    UINT    uId;        /* Button ID */
    UINT    fsState;    /* Button's state, see BTNSTATE_XXXX above */
} BITMAPBTN, NEAR *PBITMAPBTN, FAR *LPBITMAPBTN;




/* -------------------------------------------------------------------------
** Bitmap buttons public interfaces
** -------------------------------------------------------------------------
*/

BOOL WINAPI
BtnCreateBitmapButtons(
    HWND hwndOwner,
    HINSTANCE hBMInst,
    UINT wBMID,
    UINT uStyle,
    LPBITMAPBTN lpButtons,
    int nButtons,
    int dxBitmap,
    int dyBitmap
    );

void WINAPI
BtnDestroyBitmapButtons(
    HWND hwndOwner
    );

void WINAPI
BtnDrawButton(
    HWND hwndOwner,
    HDC hdc,
    int dxButton,
    int dyButton,
    LPBITMAPBTN lpButton
    );

void WINAPI
BtnDrawFocusRect(
    HDC hdc,
    const RECT *lpRect,
    UINT fsState
    );

void WINAPI
BtnUpdateColors(
    HWND hwndOwner
    );
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\cdapi.c ===
/******************************Module*Header*******************************\
* Module Name: cdapi.c
*
* This module encapsulates the CD-ROM device into a set of callable apis.
* The api's are implemented using the scsi cdrom IOCTLS.
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
#ifdef USE_IOCTLS
#pragma warning( once : 4201 4214 )

#define NOOLE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>

#include <windows.h>    /* required for all Windows applications */
#include <windowsx.h>
#include <string.h>

#include "resource.h"
#include "cdplayer.h"
#include "cdapi.h"
#include "scan.h"
#include "trklst.h"


/* -------------------------------------------------------------------------
**
** High level routines
**
** -------------------------------------------------------------------------
*/

/******************************Public*Routine******************************\
* CheckStatus
*
* Check return code for known bad codes and inform
* user how to correct (if possible) the problem.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CheckStatus(
    LPSTR szCaller,
    DWORD status,
    int cdrom
    )
{

    TCHAR s[100];

    if (status==ERROR_SUCCESS)
        return;

    switch( status ) {

    case ERROR_GEN_FAILURE:
        wsprintf( s, IdStr( STR_ERR_GEN ), g_Devices[cdrom]->drive, szCaller );
        break;

    case ERROR_NO_MEDIA_IN_DRIVE:
        wsprintf( s, IdStr( STR_ERR_NO_MEDIA ), g_Devices[cdrom]->drive );
        NoMediaUpdate( cdrom );
        break;

    case ERROR_UNRECOGNIZED_MEDIA:
        wsprintf( s, IdStr( STR_ERR_UNREC_MEDIA ), g_Devices[cdrom]->drive );
        if (!(g_Devices[cdrom]->State & CD_DATA_CD_LOADED))
            NoMediaUpdate( cdrom );
        break;

    case ERROR_FILE_NOT_FOUND:
        wsprintf( s, IdStr( STR_ERR_NO_DEVICE ), szCaller, g_Devices[cdrom]->drive );
        NoMediaUpdate( cdrom );
        break;

    case ERROR_INVALID_FUNCTION:
        wsprintf( s, IdStr( STR_ERR_INV_DEV_REQ ), g_Devices[cdrom]->drive );
        break;

    case ERROR_NOT_READY:
        wsprintf( s, IdStr( STR_ERR_NOT_READY ), g_Devices[cdrom]->drive );
        NoMediaUpdate( cdrom );
        break;

    case ERROR_SECTOR_NOT_FOUND:
        wsprintf( s, IdStr( STR_ERR_BAD_SEC ), g_Devices[cdrom]->drive );
        break;

    case ERROR_IO_DEVICE:
        wsprintf( s, IdStr( STR_ERR_IO_ERROR ), g_Devices[cdrom]->drive );
        break;

    default:
        wsprintf( s, IdStr( STR_ERR_DEFAULT ), g_Devices[cdrom]->drive, szCaller, status );
        break;

    }

#if DBG
    /* StatusLine( SL_ERROR, s ); */
    SetWindowText( g_hwndStatusbar, s );
#endif

}



/******************************Public*Routine******************************\
* CheckUnitCdrom
*
* Queries the device state, checking to see if a disc has been ejected or
* inserted.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CheckUnitCdrom(
    int cdrom
    )
{
    DWORD   status;

    if ( g_Devices[cdrom]->hCd == NULL ) {

        HANDLE  hTemp;
        TCHAR   chDevRoot[] = TEXT("\\\\.\\A:");

        chDevRoot[4] = g_Devices[cdrom]->drive;
        hTemp = CreateFile( chDevRoot, GENERIC_READ,
                            FILE_SHARE_READ, NULL, OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL, NULL );

        if ( hTemp == INVALID_HANDLE_VALUE ) {

            g_Devices[cdrom]->hCd = NULL;
            return;
        }
        else {

            g_Devices[cdrom]->hCd = hTemp;
        }
    }

    status = TestUnitReadyCdrom( g_Devices[cdrom]->hCd );

    if (g_Devices[cdrom]->State & CD_NO_CD) {

        if (status == ERROR_SUCCESS) {

            /*
            ** A new disc has been inserted, scan it now.
            */

            RescanDevice( g_hwndApp, cdrom );
        }
    }
    else {

        if (status != ERROR_SUCCESS) {

            /*
            ** Disc has been ejected.
            */

            NoMediaUpdate( cdrom );
        }
    }
}


/******************************Public*Routine******************************\
* NoMediaUpdate
*
* Update the user display when it is found that no media is in the device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
NoMediaUpdate(
    int cdrom
    )
{
    BOOL fChangePlayButtons;

    if ( cdrom == g_CurrCdrom ) {
        fChangePlayButtons = TRUE;
    }
    else {
        fChangePlayButtons = FALSE;
    }

    g_Devices[cdrom]->State = (CD_NO_CD | CD_STOPPED);

    if (fChangePlayButtons) {
        SetPlayButtonsEnableState();
    }

    TimeAdjustInitialize( cdrom );
}



/******************************Public*Routine******************************\
* EjectTheCdromDisc
*
* Eject the disc from the specified cdrom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
EjectTheCdromDisc(
    IN INT cdrom
    )
{
    DWORD status;

    /*
    ** Stop the drive first
    */

    status = StopCdrom( g_Devices[cdrom]->hCd );

    /*
    ** Eject the disc
    */

    status = EjectCdrom( g_Devices[cdrom]->hCd );

    CheckStatus( "EjectCdrom", status, cdrom );

    return status == ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* PlayCurrTrack
*
* Set cdrom device playing from start MSF to end MSF of current
* track.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
PlayCurrTrack(
    int cdrom
    )
{
    DWORD status;
    CDROM_PLAY_AUDIO_MSF pam;
    int retry,min,sec,endindex;
    int i;
    PTRACK_PLAY tr;

    tr = CURRTRACK( cdrom );
    if (tr==NULL) {

        return( FALSE );

    }

    sec = TRACK_S(cdrom,tr->TocIndex) + CDTIME(cdrom).TrackCurSec;
    min = TRACK_M(cdrom,tr->TocIndex) + CDTIME(cdrom).TrackCurMin;
    min += (sec / 60);
    sec = (sec % 60);
    pam.StartingM = min;
    pam.StartingS = sec;
    pam.StartingF = TRACK_F(cdrom,tr->TocIndex);

    endindex = FindContiguousEnd( cdrom, tr );

    pam.EndingM   = TRACK_M(cdrom,endindex);
    pam.EndingS   = TRACK_S(cdrom,endindex);
    pam.EndingF   = TRACK_F(cdrom,endindex);

    /*
    ** for some reason, sometimes the lead out track
    ** gived bad values, because when we try to
    ** play the last track, we get an error.  However,
    ** if we back up a little bit from what is reported
    ** to us as the end of the last track, we can get
    ** it to play.  Below is a hack to do just that...
    */


    retry = 0;

    do {

        status = PlayCdrom( g_Devices[cdrom]->hCd, &pam );

        if ( (status != ERROR_SUCCESS)
           ) {

            /*
            ** Didn't play, so try backing off a little bit
            ** at the end of the track
            */

            retry++;

            i = (INT)pam.EndingF - 30;
            if (i<0) {

                pam.EndingF = (UCHAR)(70 + i);

                if (pam.EndingS!=0) {

                    pam.EndingS--;

                } else {

                    pam.EndingS=59;
                    pam.EndingM--;

                }

            } else {

                pam.EndingF = (UCHAR)i;

            }

            /*
            ** Store the information in our structures so that
            ** we don't have to recompute this next time...
            */

            TRACK_M(cdrom,endindex) = pam.EndingM;
            TRACK_S(cdrom,endindex) = pam.EndingS;
            TRACK_F(cdrom,endindex) = pam.EndingF;

        } else

            retry = 15;

    } while ((retry<15) && (status!=ERROR_SUCCESS));

    CheckStatus( "PlayCurrTrack", status, cdrom );

    if (status == ERROR_SUCCESS) {

        ValidatePosition( cdrom );

    }

    return status == ERROR_SUCCESS;

}


/******************************Public*Routine******************************\
* StopTheCdromDrive
*
* Tell the cdrom device to stop playing
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
StopTheCdromDrive(
    int cdrom
    )
{

    DWORD status;

    status = StopCdrom( g_Devices[cdrom]->hCd );

    CheckStatus( "StopCdrom", status, cdrom );

    return status == ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* PauseTheCdromDrive
*
* Tell the cdrom device to pause playing
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
PauseTheCdromDrive(
    int cdrom
    )
{

    DWORD status;

    status = PauseCdrom( g_Devices[cdrom]->hCd );

    CheckStatus( "PauseCdrom", status, cdrom );

    return status == ERROR_SUCCESS;
}



/******************************Public*Routine******************************\
* ResumeTheCdromDrive
*
* Tell the cdrom device to resume playing
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
ResumeTheCdromDrive(
    int cdrom
    )
{

    DWORD status;

    status = ResumeCdrom( g_Devices[cdrom]->hCd );

    CheckStatus( "ResumeCdrom", status, cdrom );
    if ( status == ERROR_NOT_READY )
        NoMediaUpdate( cdrom );
    else
        ValidatePosition( cdrom );

    return status == ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* SeekToCurrSecond
*
* Seek to the position on the disc represented by the
* current time (position) information in gDevices, and
* continue playing to the end of the current track.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
SeekToCurrSecond(
    int cdrom
    )
{

    DWORD status;
    CDROM_PLAY_AUDIO_MSF pam;
    int retry,i,endindex;
    PTRACK_PLAY tr;
    SUB_Q_CHANNEL_DATA subq;
    CDROM_SUB_Q_DATA_FORMAT df;

    /*
    ** Build starting and ending positions for play
    */

    tr = CDTIME(cdrom).CurrTrack;
    if (tr==NULL) {

        return( FALSE );
    }


    /*
    ** This routine sometimes wants to play from the current position
    ** through the end of the contiguous play. Since the current
    ** position is only being stored accurate down to seconds, we get
    ** the current position, see if it's reasonably close to our
    ** starting position, then start the play from the actual current
    ** position.
    */

    df.Format = IOCTL_CDROM_CURRENT_POSITION;
    df.Track = (UCHAR)CDTIME(cdrom).CurrTrack->TocIndex;
    GetCdromSubQData( g_Devices[ cdrom ]->hCd, &subq, &df );

    pam.StartingM = (UCHAR)(TRACK_M(cdrom,tr->TocIndex) + CDTIME(cdrom).TrackCurMin);
    pam.StartingS = (UCHAR)(TRACK_S(cdrom,tr->TocIndex) + CDTIME(cdrom).TrackCurSec);
    pam.StartingF = 0;

    i = pam.StartingM * 60 + pam.StartingS;
    i-= (INT) subq.CurrentPosition.AbsoluteAddress[1] * 60;
    i-= (INT) subq.CurrentPosition.AbsoluteAddress[2];


    if (ABS(i) <= 1) {

        pam.StartingM = (INT) subq.CurrentPosition.AbsoluteAddress[1];
        pam.StartingS = (INT) subq.CurrentPosition.AbsoluteAddress[2];
        pam.StartingF = (INT) subq.CurrentPosition.AbsoluteAddress[3];

    }


    if (pam.StartingS > 59) {
        pam.StartingM++;
        pam.StartingS = (UCHAR)(pam.StartingS - 60);
    }

    if ((CDTIME(cdrom).TrackCurMin==0) && (CDTIME(cdrom).TrackCurSec==0))
        pam.StartingF = TRACK_F(cdrom,tr->TocIndex);

    if (g_Devices[ cdrom ]->State & CD_PLAYING) {

        endindex = FindContiguousEnd( cdrom, tr );

        pam.EndingM   = TRACK_M(cdrom,endindex);
        pam.EndingS   = TRACK_S(cdrom,endindex);
        pam.EndingF   = TRACK_F(cdrom,endindex);

    } else {

        endindex = 0;
        pam.EndingM   = pam.StartingM;
        pam.EndingS   = pam.StartingS;
        pam.EndingF   = pam.StartingF;

    }

    retry = 0;

    do {

        status = PlayCdrom( g_Devices[ cdrom ]->hCd, &pam );

        if (status != ERROR_SUCCESS) {

            /*
            ** Didn't play, so try backing off a little bit
            ** at the end of the track
            */

            retry++;

            i = (INT)pam.EndingF - 30;
            if (i<0) {

                pam.EndingF = (UCHAR)(70 + i);

                if (pam.EndingS!=0) {

                    pam.EndingS--;

                } else {

                    pam.EndingS=59;
                    pam.EndingM--;

                }

            } else {

                pam.EndingF = (UCHAR)i;

            }

            /*
            ** Store the information in our structures so that
            ** we don't have to recompute this next time...
            */

            TRACK_M(cdrom,endindex) = pam.EndingM;
            TRACK_S(cdrom,endindex) = pam.EndingS;
            TRACK_F(cdrom,endindex) = pam.EndingF;

        } else

            retry = 15;

    } while ((retry<15) && (status!=ERROR_SUCCESS));

    CheckStatus( "SeekToCurrSec", status, cdrom );

    if (status == ERROR_SUCCESS) {

        ValidatePosition(cdrom);

    }

    return status == ERROR_SUCCESS;

}


/******************************Public*Routine******************************\
* GetCurrPos
*
* Query cdrom device for its current position and status
* and return information in callers buffer.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
GetCurrPos(
    int cdrom,
    PCURRPOS CpPtr
    )
{

    DWORD status;
    SUB_Q_CHANNEL_DATA subq;
    CDROM_SUB_Q_DATA_FORMAT df;

    /*
    ** Tell lower layer what we want it to do...in this case,
    ** we need to specify which SubQData format we want returned.
    ** This is exported from scsicdrom.sys to the user layer
    ** so that it could be implemented in one call, instead of
    ** four separate calls (there are four SubQData formats)
    */

    /*
    ** Set up for current position SubQData format.
    */

    df.Format = IOCTL_CDROM_CURRENT_POSITION;
    if (CDTIME(cdrom).CurrTrack != NULL) {

        df.Track = (UCHAR)CDTIME(cdrom).CurrTrack->TocIndex;
        status = GetCdromSubQData( g_Devices[ cdrom ]->hCd, &subq, &df );

    }
    else {

        status = (DWORD)~ERROR_SUCCESS;

    }


    if (status==ERROR_SUCCESS) {

        CpPtr->AudioStatus = subq.CurrentPosition.Header.AudioStatus;
        CpPtr->Track = (INT)subq.CurrentPosition.TrackNumber;
        CpPtr->Index = (INT)subq.CurrentPosition.IndexNumber;
        CpPtr->m = (INT)subq.CurrentPosition.TrackRelativeAddress[1];
        CpPtr->s = (INT)subq.CurrentPosition.TrackRelativeAddress[2];
        CpPtr->f = (INT)subq.CurrentPosition.TrackRelativeAddress[3];
        CpPtr->ab_m = (INT)subq.CurrentPosition.AbsoluteAddress[1];
        CpPtr->ab_s = (INT)subq.CurrentPosition.AbsoluteAddress[2];
        CpPtr->ab_f = (INT)subq.CurrentPosition.AbsoluteAddress[3];

    }
    else {

        CpPtr->AudioStatus = 0;
        CpPtr->Track = 0;
        CpPtr->Index = 0;
        CpPtr->m = 0;
        CpPtr->s = 0;
        CpPtr->f = 0;
        CpPtr->ab_m = 0;
        CpPtr->ab_s = 0;
        CpPtr->ab_f = 0;

    }

    CheckStatus( "GetCurrPos", status, cdrom );

    return status==ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* SeekToTrackAndHold
*
* Seek to specified track and enter hold state.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
SeekToTrackAndHold(
    int cdrom,
    int tindex
    )
{

    DWORD status;
    CDROM_SEEK_AUDIO_MSF sam;

    sam.M = TRACK_M(cdrom,tindex);
    sam.S = TRACK_S(cdrom,tindex);
    sam.F = TRACK_F(cdrom,tindex);

    status = SeekCdrom( g_Devices[ cdrom ]->hCd, &sam );

    CheckStatus( "SeekToTrackAndHold", status, cdrom );

    if (status == ERROR_SUCCESS) {

        ValidatePosition( cdrom );

    }


    return status == ERROR_SUCCESS;
}



/* -------------------------------------------------------------------------
**
** Low level routines
**
** -------------------------------------------------------------------------
*/


/******************************Public*Routine******************************\
* GetCdromTOC
*
* This routine will get the table of contents from
* a CDRom device.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
GetCdromTOC(
    HANDLE DeviceHandle,
    PCDROM_TOC TocPtr
    )

{
    DWORD bytesRead;

    if (DeviceIoControl( DeviceHandle,
                         IOCTL_CDROM_READ_TOC,
                         NULL,
                         0,
                         (LPVOID)TocPtr,
                         sizeof(CDROM_TOC),
                         &bytesRead,
                         NULL )) {

        return ERROR_SUCCESS;
    }
    else {
        return GetLastError();
    }

}




/******************************Public*Routine******************************\
* StopCdrom
*
* This routine will stop a CDRom device that is playing.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
StopCdrom(
    HANDLE DeviceHandle
    )
{
    DWORD bytesRead;

    if (DeviceIoControl( DeviceHandle,
                         IOCTL_CDROM_STOP_AUDIO,
                         NULL,
                         0,
                         NULL,
                         0,
                         &bytesRead,
                         NULL )) {

        return ERROR_SUCCESS;
    }
    else {
        return GetLastError();
    }
}



/******************************Public*Routine******************************\
* PauseCdrom
*
* This routine will pause a CDRom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
PauseCdrom(
    HANDLE DeviceHandle
    )
{
    DWORD bytesRead;

    if (DeviceIoControl( DeviceHandle,
                         IOCTL_CDROM_PAUSE_AUDIO,
                         NULL,
                         0,
                         NULL,
                         0,
                         &bytesRead,
                         NULL )) {

        return ERROR_SUCCESS;
    }
    else {
        return GetLastError();
    }
}


/******************************Public*Routine******************************\
* ResumeCdrom
*
* This routine will resume a paused CDRom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
ResumeCdrom(
    HANDLE DeviceHandle
    )

{
    DWORD bytesRead;

    if (DeviceIoControl( DeviceHandle,
                         IOCTL_CDROM_RESUME_AUDIO,
                         NULL,
                         0,
                         NULL,
                         0,
                         &bytesRead,
                         NULL )) {

        return ERROR_SUCCESS;
    }
    else {
        return GetLastError();
    }
}



/******************************Public*Routine******************************\
* PlayCdrom
*
* This routine plays a CDRom device starting and ending at the MSF
* positions specified in the structure passed in.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
PlayCdrom(
    HANDLE DeviceHandle,
    PCDROM_PLAY_AUDIO_MSF PlayAudioPtr
    )
{
    DWORD bytesRead;

    if (DeviceIoControl( DeviceHandle,
                         IOCTL_CDROM_PLAY_AUDIO_MSF,
                         (LPVOID)PlayAudioPtr,
                         sizeof(CDROM_PLAY_AUDIO_MSF),
                         NULL,
                         0,
                         &bytesRead,
                         NULL )) {

        return ERROR_SUCCESS;
    }
    else {
        return GetLastError();
    }
}



/******************************Public*Routine******************************\
* GetCdromSubQData
*
* DeviceHandle - Handle to CDRom device to retrieve information from.
* SubQPtr - A pointer to a SUB_Q_CHANNEL_DATA structure to be filled in by
*           this routine.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
GetCdromSubQData(
    HANDLE DeviceHandle,
    PSUB_Q_CHANNEL_DATA SubQDataPtr,
    PCDROM_SUB_Q_DATA_FORMAT SubQFormatPtr
    )
{
    DWORD bytesRead;

    if (DeviceIoControl( DeviceHandle,
                         IOCTL_CDROM_READ_Q_CHANNEL,
                         (LPVOID)SubQFormatPtr,
                         sizeof(CDROM_SUB_Q_DATA_FORMAT),
                         (LPVOID)SubQDataPtr,
                         sizeof(SUB_Q_CHANNEL_DATA),
                         &bytesRead,
                         NULL )) {

        return ERROR_SUCCESS;

    }
    else {
        return GetLastError();
    }
}


/******************************Public*Routine******************************\
* SeekCdrom
*
* This routine seek to an MSF address on the audio CD and enters
* a hold (paused) state.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
SeekCdrom(
    HANDLE DeviceHandle,
    PCDROM_SEEK_AUDIO_MSF SeekAudioPtr
    )
{
    DWORD bytesRead;


    if (DeviceIoControl( DeviceHandle,
                         IOCTL_CDROM_SEEK_AUDIO_MSF,
                         (LPVOID)SeekAudioPtr,
                         sizeof(CDROM_SEEK_AUDIO_MSF),
                         NULL,
                         0,
                         &bytesRead,
                         NULL )) {

        return ERROR_SUCCESS;
    }
    else {
        return GetLastError();
    }
}



/******************************Public*Routine******************************\
* EjectCdrom
*
* This routine will eject a disc from a CDRom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
EjectCdrom(
    HANDLE DeviceHandle
    )
{
    DWORD bytesRead;

    if (DeviceIoControl( DeviceHandle,
                         IOCTL_CDROM_EJECT_MEDIA,
                         NULL,
                         0,
                         NULL,
                         0,
                         &bytesRead,
                         NULL )) {

        return ERROR_SUCCESS;
    }
    else {
        return GetLastError();
    }
}



/******************************Public*Routine******************************\
* TestUnitReadyCdrom
*
* This routine will retrieve the status of the CDRom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
TestUnitReadyCdrom(
    HANDLE DeviceHandle
    )
{
    DWORD bytesRead;

    if (DeviceIoControl( DeviceHandle,
                         IOCTL_DISK_CHECK_VERIFY,
                         NULL,
                         0,
                         NULL,
                         0,
                         &bytesRead,
                         NULL )) {

        return ERROR_SUCCESS;

    }
    else {
        return GetLastError();
    }
}


#if 0
/******************************Public*Routine******************************\
* GetCdromVolume
*
* This routine will get the table of contents from
* a CDRom device.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
GetCdromVolume(
    HANDLE DeviceHandle
    )
{
    DWORD bytesRead;
    VOLUME_CONTROL vc;
    TCHAR   buff[80];

    ZeroMemory( &vc, sizeof(vc) );

    if (DeviceIoControl( DeviceHandle,
                         IOCTL_CDROM_GET_VOLUME,
                         NULL,
                         0,
                         (LPVOID)&vc,
                         sizeof(vc),
                         &bytesRead,
                         NULL )) {

        wsprintf( buff, "%d %d %d %d\n", vc.PortVolume[0], vc.PortVolume[1],
                  vc.PortVolume[2], vc.PortVolume[3] );
        OutputDebugString( buff );

        return ERROR_SUCCESS;
    }
    else {
        return GetLastError();
    }

}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\cdapi.h ===
/******************************Module*Header*******************************\
* Module Name: cdapi.h
*
*
*
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#ifdef USE_IOCTLS
#include <ntddcdrm.h>
#else
#include <mmsystem.h>
#endif

#define MAX_CD_DEVICES 50

/* -------------------------------------------------------------------------
** Defines for cdrom state
**
**  These are bit flags
** -------------------------------------------------------------------------
*/

#define CD_PLAYING          0x0001
#define CD_STOPPED          0x0002
#define CD_PAUSED           0x0004
#define CD_SKIP_F           0x0008
#define CD_SKIP_B           0x0010
#define CD_FF               0x0020
#define CD_RW               0x0040
#define CD_SEEKING          (CD_FF | CD_RW)
#define CD_LOADED           0x0080
#define CD_NO_CD            0x0100
#define CD_DATA_CD_LOADED   0x0200
#define CD_EDITING          0x0400
#define CD_PAUSED_AND_MOVED 0x0800
#define CD_PLAY_PENDING     0x1000
#define CD_WAS_PLAYING      0x2000
#define CD_IN_USE           0x4000
#define CD_BEING_SCANNED    0x8000


/* -------------------------------------------------------------------------
** Some MACROS
** -------------------------------------------------------------------------
*/

#ifdef USE_IOCTLS
#define CDHANDLE    HANDLE
#else
#define CDHANDLE    MCIDEVICEID
#endif

#define CDTIME(x)       g_Devices[x]->time
#define CURRTRACK(x)    g_Devices[x]->time.CurrTrack

#ifdef USE_IOCTLS
#define TRACK_M(x,y)    g_Devices[x]->toc.TrackData[y].Address[1]
#define TRACK_S(x,y)    g_Devices[x]->toc.TrackData[y].Address[2]
#define TRACK_F(x,y)    g_Devices[x]->toc.TrackData[y].Address[3]
#else
#define TRACK_M(x,y)    MCI_MSF_MINUTE(g_Devices[x]->toc.TrackData[y].Address)
#define TRACK_S(x,y)    MCI_MSF_SECOND(g_Devices[x]->toc.TrackData[y].Address)
#define TRACK_F(x,y)    MCI_MSF_FRAME(g_Devices[x]->toc.TrackData[y].Address)
#endif

#define FIRSTTRACK(x)   g_Devices[x]->toc.FirstTrack
#define LASTTRACK(x)    g_Devices[x]->toc.LastTrack
#define ALLTRACKS(x)    g_Devices[x]->CdInfo.AllTracks
#define PLAYLIST(x)     g_Devices[x]->CdInfo.PlayList
#define SAVELIST(x)     g_Devices[x]->CdInfo.SaveList
#define TITLE(x)        g_Devices[x]->CdInfo.Title
#define ARTIST(x)       g_Devices[x]->CdInfo.Artist
#define NUMTRACKS(x)    g_Devices[x]->CdInfo.NumTracks
#define STATE(x)        g_Devices[x]->State
#define g_State         (g_Devices[g_CurrCdrom]->State)
#define ABS(x)          ((x) < 0 ? (-(x)) : (x))


/* -------------------------------------------------------------------------
** Type definitions for CD database entries, etc.
**
** -------------------------------------------------------------------------
*/
#define TITLE_LENGTH        50
#define ARTIST_LENGTH       50
#define TRACK_TITLE_LENGTH  40
#define MAX_TRACKS          100
#define NEW_FRAMEOFFSET     1234567

#ifndef USE_IOCTLS
//
// Maximum CD Rom size
//

#define MAXIMUM_NUMBER_TRACKS 100
#define MAXIMUM_CDROM_SIZE 804


//
// Used with StatusTrackPos call
//
#define MCI_STATUS_TRACK_POS 0xBEEF

typedef struct
{
    DWORD   dwStatus;
    DWORD   dwTrack;
    DWORD   dwDiscTime;
} STATUSTRACKPOS, *PSTATUSTRACKPOS;

//
// CD ROM Table OF Contents (TOC)
//
// Format 0 - Get table of contents
//

typedef struct _TRACK_DATA {
    UCHAR TrackNumber;
    DWORD Address;
    DWORD AddressF;
} TRACK_DATA, *PTRACK_DATA;

typedef struct _CDROM_TOC {

    //
    // Header
    //

    UCHAR Length[2];
    UCHAR FirstTrack;
    UCHAR LastTrack;

    //
    // Track data
    //

    TRACK_DATA TrackData[MAXIMUM_NUMBER_TRACKS];
} CDROM_TOC, *PCDROM_TOC;

#define CDROM_TOC_SIZE sizeof(CDROM_TOC)
#endif

typedef struct _TRACK_INF {
    struct _TRACK_INF   *next;
    int                 TocIndex;
    TCHAR               name[TRACK_TITLE_LENGTH];
} TRACK_INF, *PTRACK_INF;

typedef struct _TRACK_PLAY {
    struct _TRACK_PLAY  *prevplay;
    struct _TRACK_PLAY  *nextplay;
    int                 TocIndex;
    int                 min;
    int                 sec;
} TRACK_PLAY, *PTRACK_PLAY;

typedef struct _TIMES {
    PTRACK_PLAY         CurrTrack;
    int                 TotalMin;
    int                 TotalSec;
    int                 RemMin;
    int                 RemSec;
    int                 TrackCurMin;
    int                 TrackCurSec;
    int                 TrackTotalMin;
    int                 TrackTotalSec;
    int                 TrackRemMin;
    int                 TrackRemSec;
} TIMES, *PTIMES;

typedef struct _ENTRY {
    PTRACK_INF          AllTracks;
    PTRACK_PLAY         PlayList;
    PTRACK_PLAY         SaveList;
    int                 NumTracks;
    DWORD               Id;
    BOOL                save;
    BOOL                IsVirginCd;
    int                 iFrameOffset;
    TCHAR               Title[TITLE_LENGTH];
    TCHAR               Artist[TITLE_LENGTH];
} ENTRY, *PENTRY;

typedef struct _CDROM {
    CDHANDLE            hCd;
    HANDLE              hThreadToc;
    BOOL                fIsTocValid;
    TCHAR               drive;
    DWORD               State;
    CDROM_TOC           toc;
    ENTRY               CdInfo;
    TIMES               time;
    BOOL                fShowLeadIn;
    BOOL                fProcessingLeadIn;
    BOOL                fKilledPlayList;  // Used to prevent bug with -track option
} CDROM, *PCDROM;

typedef struct _CURRPOS {
#ifdef USE_IOCTLS
    UCHAR               AudioStatus;
#else
    DWORD               AudioStatus;
#endif
    int                 Track;
    int                 Index;
    int                 m;
    int                 s;
    int                 f;
    int                 ab_m;
    int                 ab_s;
    int                 ab_f;
} CURRPOS, *PCURRPOS;


/* -------------------------------------------------------------------------
** High level function declarations
**
** -------------------------------------------------------------------------
*/

void
CheckStatus(
    LPSTR szCaller,
    DWORD status,
    int cdrom
    );

void
NoMediaUpdate(
    int cdrom
    );

void
CheckUnitCdrom(
    int cdrom,
    BOOL fForceRescan
    );

BOOL
EjectTheCdromDisc(
    INT cdrom
    );

BOOL
PlayCurrTrack(
    int cdrom
    );

BOOL
StopTheCdromDrive(
    int cdrom
    );

BOOL
PauseTheCdromDrive(
    int cdrom
    );

BOOL
ResumeTheCdromDrive(
    int cdrom
    );

BOOL
SeekToCurrSecond(
    int cdrom
    );

BOOL
GetCurrPos(
    int cdrom,
    PCURRPOS CpPtr
    );

BOOL
SeekToTrackAndHold(
    int cdrom,
    int tindex
    );


/* -------------------------------------------------------------------------
** NT Layer Function Declarations
**
** These are the low-level functions that manipulate the specified CD-ROM
** device.
** -------------------------------------------------------------------------
*/
DWORD
GetCdromTOC(
    CDHANDLE,
    PCDROM_TOC
    );

DWORD
StopCdrom(
    CDHANDLE
    );

DWORD
PauseCdrom(
    CDHANDLE
    );


#ifdef USE_IOCTLS
DWORD
ResumeCdrom(
    CDHANDLE
    );

DWORD
PlayCdrom(
    CDHANDLE,
    PCDROM_PLAY_AUDIO_MSF
    );

DWORD
SeekCdrom(
    CDHANDLE,
    PCDROM_SEEK_AUDIO_MSF
    );

DWORD
GetCdromSubQData(
    CDHANDLE,
    PSUB_Q_CHANNEL_DATA,
    PCDROM_SUB_Q_DATA_FORMAT
    );

#else

DWORD
ResumeCdrom(
    CDHANDLE,
    int
    );

CDHANDLE
OpenCdRom(
    TCHAR chDrive,
    LPDWORD lpdwErrCode
    );

void
CloseCdRom(
    CDHANDLE DevHandle
    );

DWORD
GetCdromMode(
    CDHANDLE DevHandle
    );

DWORD
GetCdromCurrentTrack(
    CDHANDLE DevHandle
    );

BOOL
IsCdromTrackAudio(
    CDHANDLE DevHandle,
    int iTrackNumber
    );

DWORD
PlayCdrom(
    CDHANDLE DeviceHandle,
    MCI_PLAY_PARMS *mciPlay
    );

DWORD
SeekCdrom(
    CDHANDLE DeviceHandle,
    MCI_SEEK_PARMS *mciSeek
    );

DWORD
GetCdromCurrentPosition(
    CDHANDLE DevHandle,
    DWORD *lpdwPosition
    );

#endif

DWORD
EjectCdrom(
    CDHANDLE
    );

DWORD
TestUnitReadyCdrom(
    CDHANDLE DeviceHandle
    );

#if 0
DWORD
GetCdromVolume(
    CDHANDLE DeviceHandle
    );
#endif

DWORD
StatusTrackPosCdrom(
    MCIDEVICEID DevHandle,
    DWORD * pStatus,
    DWORD * pTrack,
    DWORD * pPos
    );


/* -------------------------------------------------------------------------
** Public Globals - Most of these should be treated as read only.
** -------------------------------------------------------------------------
*/
#ifndef GLOBAL
#define GLOBAL extern
#endif
GLOBAL  PCDROM  g_Devices[MAX_CD_DEVICES];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\cdapimci.c ===
/******************************Module*Header*******************************\
* Module Name: cdapimci.c
*
* This module encapsulates the CD-ROM device into a set of callable apis.
* The api's are implemented using the cdaudio mci interface.
*
* Created: 26-04-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 - 1995 Microsoft Corporation.  All rights reserved.
\**************************************************************************/
#ifndef USE_IOCTLS
#pragma warning( once : 4201 4214 )

#define NOOLE

#include <windows.h>    /* required for all Windows applications */
#include <windowsx.h>
#include <string.h>

#include "resource.h"
#include "cdplayer.h"
#include "cdapi.h"
#include "scan.h"
#include "trklst.h"


/* -------------------------------------------------------------------------
**
** High level routines
**
** -------------------------------------------------------------------------
*/

/******************************Public*Routine******************************\
* OpenCdRom
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
MCIDEVICEID
OpenCdRom(
    TCHAR chDrive,
    LPDWORD lpdwErrCode
    )
{
    MCI_OPEN_PARMS  mciOpen;
    TCHAR           szElementName[4];
    TCHAR           szAliasName[32];
    DWORD           dwFlags;
    DWORD           dwAliasCount = GetCurrentTime();
    DWORD           dwRet;

    ZeroMemory( &mciOpen, sizeof(mciOpen) );

    mciOpen.lpstrDeviceType = (LPTSTR)MCI_DEVTYPE_CD_AUDIO;
    wsprintf( szElementName, TEXT("%c:"), chDrive );
    wsprintf( szAliasName, TEXT("SJE%lu:"), dwAliasCount );

    mciOpen.lpstrElementName = szElementName;
    mciOpen.lpstrAlias = szAliasName;

#ifdef DAYTONA
    dwFlags = MCI_OPEN_ELEMENT | MCI_OPEN_SHAREABLE | MCI_OPEN_ALIAS |
              MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID | MCI_WAIT;
#else
    dwFlags = MCI_OPEN_ELEMENT | MCI_OPEN_ALIAS |
              MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID | MCI_WAIT;
#endif

    dwRet = mciSendCommand(0, MCI_OPEN, dwFlags, (DWORD)(LPVOID)&mciOpen);


    if ( dwRet == MMSYSERR_NOERROR ) {

        MCI_SET_PARMS   mciSet;

        ZeroMemory( &mciSet, sizeof(mciSet) );

        mciSet.dwTimeFormat = MCI_FORMAT_MSF;
        mciSendCommand( mciOpen.wDeviceID, MCI_SET,
                        MCI_SET_TIME_FORMAT, (DWORD)(LPVOID)&mciSet );
    }
    else {

        /*
        ** Only return the error code if we have been given a valid pointer
        */
        if (lpdwErrCode != NULL) {
            *lpdwErrCode = dwRet;
        }

        mciOpen.wDeviceID = 0;
    }

    return mciOpen.wDeviceID;
}


/******************************Public*Routine******************************\
* CloseCdRom
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
CloseCdRom(
    MCIDEVICEID DevHandle
    )
{
    mciSendCommand( DevHandle, MCI_CLOSE, 0L, 0L );
}


/******************************Public*Routine******************************\
* CheckStatus
*
* Check return code for known bad codes and inform
* user how to correct (if possible) the problem.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CheckStatus(
    LPSTR szCaller,
    DWORD status,
    int cdrom
    )
{
#if DBG
    TCHAR   s[200];
    TCHAR   err[100];
#endif


    if (status==ERROR_SUCCESS)
        return;

    switch (status) {

    case MCIERR_HARDWARE:
        NoMediaUpdate( cdrom );
        break;
    }

#if DBG
    mciGetErrorString( status, err, sizeof(err) / sizeof(TCHAR) );
    wsprintf( s, IdStr( STR_ERR_GEN ), g_Devices[cdrom]->drive, err );

    OutputDebugString (s);
    OutputDebugString (TEXT("\r\n"));

    SetWindowText( g_hwndStatusbar, s );
#endif
}



/******************************Public*Routine******************************\
* CheckUnitCdrom
*
* Queries the device state, checking to see if a disc has been ejected or
* inserted.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CheckUnitCdrom(
    int cdrom,
    BOOL fForceRescan
    )
{
    DWORD   status;

    if ((cdrom < 0) || (cdrom >= MAX_CD_DEVICES))
    {
        return;
    }

    if (fForceRescan)
    {
        // Close Device to force read of correct TOC
        if (g_Devices[cdrom]->hCd != 0L)
        {
            CloseCdRom (g_Devices[cdrom]->hCd);
            g_Devices[cdrom]->hCd = 0L;
        }
    }

    if ( g_Devices[cdrom]->hCd == 0L ) {

        g_Devices[cdrom]->hCd = OpenCdRom( g_Devices[cdrom]->drive, NULL );

        if ( g_Devices[cdrom]->hCd == 0 ) {
            return;
        }
        else {

            /*
            ** Force a rescan of this disc.
            */
            g_Devices[cdrom]->State = CD_NO_CD;
        }

    }

    status = TestUnitReadyCdrom( g_Devices[cdrom]->hCd );

    if (g_Devices[cdrom]->State & CD_NO_CD)
    {

        if (status == ERROR_SUCCESS) {

            /*
            ** A new disc has been inserted, scan it now.
            */

            RescanDevice( g_hwndApp, cdrom );
        }
    }
    else {

        if (status != ERROR_SUCCESS) {

            /*
            ** Disc has been ejected.
            */

            NoMediaUpdate( cdrom );
        }
    }
}


/******************************Public*Routine******************************\
* NoMediaUpdate
*
* Update the user display when it is found that no media is in the device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
NoMediaUpdate(
    int cdrom
    )
{
    BOOL fChangePlayButtons;

    if ( cdrom == g_CurrCdrom ) {
        fChangePlayButtons = TRUE;
    }
    else {
        fChangePlayButtons = FALSE;
    }

    g_Devices[cdrom]->State = (CD_NO_CD | CD_STOPPED);

    if (fChangePlayButtons) {
        SetPlayButtonsEnableState();
    }

    TimeAdjustInitialize( cdrom );
}



/******************************Public*Routine******************************\
* EjectTheCdromDisc
*
* Eject the disc from the specified cdrom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
EjectTheCdromDisc(
    int cdrom
    )
{
    DWORD status;

    /*
    ** Stop the drive first
    */

    status = StopCdrom( g_Devices[cdrom]->hCd );

    /*
    ** Eject the disc
    */

    status = EjectCdrom( g_Devices[cdrom]->hCd );

    CheckStatus( "EjectCdrom", status, cdrom );

    return status == ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* PlayCurrTrack
*
* Set cdrom device playing from start MSF to end MSF of current
* track.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
PlayCurrTrack(
    int cdrom
    )
{
    DWORD status;
    MCI_PLAY_PARMS pam;
    int min,sec,endindex;
    PTRACK_PLAY tr;

    tr = CURRTRACK( cdrom );
    if (tr==NULL) {

        return( FALSE );

    }

    sec = TRACK_S(cdrom,tr->TocIndex) + CDTIME(cdrom).TrackCurSec;
    min = TRACK_M(cdrom,tr->TocIndex) + CDTIME(cdrom).TrackCurMin;
    min+= (sec / 60);
    sec = (sec % 60);

    pam.dwFrom = MCI_MAKE_MSF( min, sec, TRACK_F(cdrom,tr->TocIndex) );

    endindex = FindContiguousEnd( cdrom, tr );

    pam.dwTo = MCI_MAKE_MSF( TRACK_M(cdrom,endindex),
                             TRACK_S(cdrom,endindex),
                             TRACK_F(cdrom,endindex) );

#if DBG
{
    long lAddress, lEndPos, lStartPos;

    dprintf( "Playing from     : %2.2d:%2.2d:%2.2d",
             MCI_MSF_MINUTE(pam.dwFrom),
             MCI_MSF_SECOND(pam.dwFrom),
             MCI_MSF_FRAME( pam.dwFrom) );
    dprintf( "Playing to       : %2.2d:%2.2d:%2.2d",
             MCI_MSF_MINUTE(pam.dwTo),
             MCI_MSF_SECOND(pam.dwTo),
             MCI_MSF_FRAME( pam.dwTo) );

    lAddress = pam.dwFrom;
    lStartPos = (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
                (MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
                (MCI_MSF_FRAME(lAddress));

    lAddress = pam.dwTo;
    lEndPos   = (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
                (MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
                (MCI_MSF_FRAME(lAddress));

    lAddress = lEndPos - lStartPos;
    lStartPos =
        MCI_MAKE_MSF((lAddress / FRAMES_PER_MINUTE),
                     (lAddress % FRAMES_PER_MINUTE) / FRAMES_PER_SECOND,
                     (lAddress % FRAMES_PER_MINUTE) % FRAMES_PER_SECOND);

    lAddress = lStartPos;
    dprintf( "Play length      : %2.2d:%2.2d:%2.2d",
             MCI_MSF_MINUTE(lAddress),
             MCI_MSF_SECOND(lAddress),
             MCI_MSF_FRAME( lAddress) );
}
#endif
    status = PlayCdrom( g_Devices[cdrom]->hCd, &pam );

    CheckStatus( "PlayCurrTrack", status, cdrom );

    return status == ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* StopTheCdromDrive
*
* Tell the cdrom device to stop playing
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
StopTheCdromDrive(
    int cdrom
    )
{

    DWORD status;

    status = StopCdrom( g_Devices[cdrom]->hCd );

    CheckStatus( "StopCdrom", status, cdrom );

    return status == ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* PauseTheCdromDrive
*
* Tell the cdrom device to pause playing
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
PauseTheCdromDrive(
    int cdrom
    )
{

    DWORD status;

    status = PauseCdrom( g_Devices[cdrom]->hCd );

    CheckStatus( "PauseCdrom", status, cdrom );

    return status == ERROR_SUCCESS;
}



/******************************Public*Routine******************************\
* ResumeTheCdromDrive
*
* Tell the cdrom device to resume playing
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
ResumeTheCdromDrive(
    int cdrom
    )
{

    DWORD status;

    status = ResumeCdrom( g_Devices[cdrom]->hCd, cdrom );

    CheckStatus( "ResumeCdrom", status, cdrom );

    if ( status == ERROR_NOT_READY ) {
        NoMediaUpdate( cdrom );
    }

    return status == ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* SeekToCurrSecond
*
* Seek to the position on the disc represented by the
* current time (position) information in gDevices, and
* continue playing to the end of the current track.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
SeekToCurrSecond(
    int cdrom
    )
{
    DWORD       status;
    int         endindex;
    PTRACK_PLAY tr;
    UCHAR       StartingF, StartingS, StartingM;


    /*
    ** Build starting and ending positions for play
    */

    tr = CDTIME(cdrom).CurrTrack;
    if (tr == NULL) {

        return FALSE;
    }

    StartingM = (TRACK_M(cdrom,tr->TocIndex) + CDTIME(cdrom).TrackCurMin);
    StartingS = (TRACK_S(cdrom,tr->TocIndex) + CDTIME(cdrom).TrackCurSec);
    StartingF = (TRACK_F(cdrom,tr->TocIndex));

    if (StartingS > 59) {
        StartingM++;
        StartingS -= (UCHAR)60;
    }

    if (g_Devices[ cdrom ]->State & CD_PLAYING) {

        MCI_PLAY_PARMS mciPlay;


        endindex = FindContiguousEnd( cdrom, tr );

        mciPlay.dwFrom = MCI_MAKE_MSF( StartingM, StartingS, StartingF );
        mciPlay.dwTo   = MCI_MAKE_MSF( TRACK_M(cdrom,endindex),
                                       TRACK_S(cdrom,endindex),
                                       TRACK_F(cdrom,endindex) );
        status = PlayCdrom( g_Devices[ cdrom ]->hCd, &mciPlay );
    }
    else {

        MCI_SEEK_PARMS mciSeek;

        mciSeek.dwTo = MCI_MAKE_MSF( StartingM, StartingS, StartingF );

        status = SeekCdrom( g_Devices[ cdrom ]->hCd, &mciSeek );

    }

    CheckStatus( "SeekToCurrSec", status, cdrom );

    return status == ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* GetCurrPos
*
* Query cdrom device for its current position and status
* and return information in callers buffer.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
GetCurrPos(
    int cdrom,
    PCURRPOS CpPtr
    )
{
    DWORD status;
    DWORD dwStatus;
    DWORD dwTrack;
    DWORD dwAbsPos;

    /*
    ** Tell lower layer what we want it to do...in this case,
    ** we need to specify which SubQData format we want returned.
    ** This is exported from scsicdrom.sys to the user layer
    ** so that it could be implemented in one call, instead of
    ** four separate calls (there are four SubQData formats)
    */

    /*
    ** Set up for current position SubQData format.
    */

    if (CDTIME(cdrom).CurrTrack != NULL) {

        //status = GetCdromCurrentPosition( g_Devices[ cdrom ]->hCd, &dwAbsPos );
        status = StatusTrackPosCdrom ( g_Devices[ cdrom ]->hCd, &dwStatus, &dwTrack, &dwAbsPos);

    }
    else {

        status = MCIERR_INTERNAL;

    }

    if (status == ERROR_SUCCESS) {

        int     iTrack;
        LONG    lAbsPosF;
        LONG    lStartPos;
        LONG    lTrackPos;

        //iTrack = (int)GetCdromCurrentTrack( g_Devices[ cdrom ]->hCd );
        iTrack = (int)dwTrack;

        //CpPtr->AudioStatus = GetCdromMode( g_Devices[ cdrom ]->hCd );
        CpPtr->AudioStatus = dwStatus;
        CpPtr->Track = iTrack;
        CpPtr->Index = 1;

        iTrack--;

        lStartPos = (TRACK_M(cdrom, iTrack ) * FRAMES_PER_MINUTE) +
                    (TRACK_S(cdrom, iTrack ) * FRAMES_PER_SECOND) +
                    (TRACK_F(cdrom, iTrack ));

        lAbsPosF  = (MCI_MSF_MINUTE(dwAbsPos) * FRAMES_PER_MINUTE) +
                    (MCI_MSF_SECOND(dwAbsPos) * FRAMES_PER_SECOND) +
                    (MCI_MSF_FRAME(dwAbsPos));

        lTrackPos = lAbsPosF - lStartPos;

        /*
        ** Are we in the track lead in zone ?
        */
        if ( lTrackPos < 0 ) {

            /*
            ** Have we just entered the lead in zone
            */
            if (!g_Devices[cdrom]->fProcessingLeadIn) {

                g_Devices[cdrom]->fProcessingLeadIn = TRUE;

                /*
                ** Is the track that we are currently in the next track
                ** that we actually want to play.  If it is then everything is
                ** OK.  If it isn't then we need to hack the current position
                ** information so that it looks like we sre still playing the
                ** previous track.
                */
                if ( CURRTRACK(cdrom)->nextplay
                  && CURRTRACK(cdrom)->nextplay->TocIndex == iTrack) {

                    g_Devices[cdrom]->fShowLeadIn = TRUE;
                }
                else {
                    g_Devices[cdrom]->fShowLeadIn = FALSE;
                }
            }

            if (g_Devices[cdrom]->fShowLeadIn) {

                CpPtr->Index = 0;
                lTrackPos = -lTrackPos;
            }
            else {

                CpPtr->Track = iTrack;
                iTrack--;
                lTrackPos = lAbsPosF
                               - g_Devices[cdrom]->toc.TrackData[iTrack].AddressF;
            }
        }
        else {

            g_Devices[cdrom]->fShowLeadIn = FALSE;
            g_Devices[cdrom]->fProcessingLeadIn = FALSE;
        }

        CpPtr->m = (int)(lTrackPos / FRAMES_PER_MINUTE);
        CpPtr->s = (int)(lTrackPos % FRAMES_PER_MINUTE) / FRAMES_PER_SECOND;
        CpPtr->f = (int)(lTrackPos % FRAMES_PER_MINUTE) % FRAMES_PER_SECOND;

        CpPtr->ab_m = (int)MCI_MSF_MINUTE(dwAbsPos);
        CpPtr->ab_s = (int)MCI_MSF_SECOND(dwAbsPos);
        CpPtr->ab_f = (int)MCI_MSF_FRAME(dwAbsPos);

        /*
        ** Round up to the nearest second.
        */
        if (CpPtr->f > (FRAMES_PER_SECOND / 2) ) {

            if ( ++CpPtr->s > 59 ) {
                CpPtr->s = 0;
                CpPtr->m++;
            }
        }
        else {
            CpPtr->f = 0;
        }

        if (CpPtr->ab_f > (FRAMES_PER_SECOND / 2) ) {

            if ( ++CpPtr->ab_s > 59 ) {
                CpPtr->ab_s = 0;
                CpPtr->ab_m++;
            }
        }
        else {
            CpPtr->ab_f = 0;
        }

    }
    else {

        ZeroMemory( CpPtr, sizeof(*CpPtr) );
    }

    CheckStatus( "GetCurrPos", status, cdrom );

    return status==ERROR_SUCCESS;
}


/******************************Public*Routine******************************\
* SeekToTrackAndHold
*
* Seek to specified track and enter hold state.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
SeekToTrackAndHold(
    int cdrom,
    int tindex
    )
{
    DWORD status;
    MCI_SEEK_PARMS sam;

    sam.dwTo = MCI_MAKE_MSF( TRACK_M(cdrom,tindex),
                             TRACK_S(cdrom,tindex),
                             TRACK_F(cdrom,tindex) );

    status = SeekCdrom( g_Devices[ cdrom ]->hCd, &sam );

    CheckStatus( "SeekToTrackAndHold", status, cdrom );

    return status == ERROR_SUCCESS;
}



/* -------------------------------------------------------------------------
**
** Low level routines
**
** -------------------------------------------------------------------------
*/


/******************************Public*Routine******************************\
* GetCdromTOC
*
* This routine will get the table of contents from
* a CDRom device.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
GetCdromTOC(
    MCIDEVICEID DevHandle,
    PCDROM_TOC TocPtr
    )
{
    MCI_STATUS_PARMS mciStatus;
    long lAddress, lStartPos, lDiskLen;
    int i;
    DWORD dwRet;

#if DBG
    dprintf( "Reading TOC for drive %d", DevHandle );
#endif

    ZeroMemory( &mciStatus, sizeof(mciStatus) );
    mciStatus.dwItem = MCI_STATUS_NUMBER_OF_TRACKS;

    //
    // NOTE: none of the mciSendCommand calls below bother to check the
    //       return code.  This is asking for trouble... but if the
    //       commands fail we cannot do much about it.
    //
    dwRet = mciSendCommand( DevHandle, MCI_STATUS,
                    MCI_STATUS_ITEM, (DWORD)(LPVOID)&mciStatus);

    TocPtr->FirstTrack = 1;
    TocPtr->LastTrack = (UCHAR)mciStatus.dwReturn;

    mciStatus.dwItem = MCI_STATUS_POSITION;
    for ( i = 0; i < TocPtr->LastTrack; i++ ) {

        mciStatus.dwTrack = i + 1;
        dwRet = mciSendCommand( DevHandle, MCI_STATUS,
                        MCI_STATUS_ITEM | MCI_TRACK,
                        (DWORD)(LPVOID)&mciStatus);

        TocPtr->TrackData[i].TrackNumber = (UCHAR)(i + 1);
        lAddress = TocPtr->TrackData[i].Address = mciStatus.dwReturn;

        lStartPos = (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
                    (MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
                    (MCI_MSF_FRAME( lAddress));

        TocPtr->TrackData[i].AddressF = lStartPos;

    }


    mciStatus.dwItem = MCI_STATUS_LENGTH;
    dwRet = mciSendCommand( DevHandle, MCI_STATUS,
                    MCI_STATUS_ITEM, (DWORD)(LPVOID)&mciStatus);

    /*
    ** Convert the absolute start address of the first track
    ** into Frames
    */
    lAddress  = TocPtr->TrackData[0].Address;
    lStartPos = TocPtr->TrackData[0].AddressF;

    /*
    ** Convert the total disk length into Frames
    */
    lAddress  = mciStatus.dwReturn;
    lDiskLen  = (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
                (MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
                (MCI_MSF_FRAME(lAddress));

    /*
    ** Now, determine the absolute start position of the sentinel
    ** track.  That is, the special track that marks the end of the
    ** disk.
    */
    lAddress = lStartPos + lDiskLen;

    TocPtr->TrackData[i].TrackNumber = 0;
    TocPtr->TrackData[i].Address     =
        MCI_MAKE_MSF((lAddress / FRAMES_PER_MINUTE),
                     (lAddress % FRAMES_PER_MINUTE) / FRAMES_PER_SECOND,
                     (lAddress % FRAMES_PER_MINUTE) % FRAMES_PER_SECOND);

    return (TocPtr->LastTrack != 0) ? ERROR_SUCCESS : MCIERR_INTERNAL;
}




/******************************Public*Routine******************************\
* StopCdrom
*
* This routine will stop a CDRom device that is playing.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
StopCdrom(
    MCIDEVICEID DevHandle
    )
{
    MCI_GENERIC_PARMS mciGen;

    ZeroMemory( &mciGen, sizeof(mciGen) );

    return mciSendCommand( DevHandle, MCI_STOP, 0L, (DWORD)(LPVOID)&mciGen );
}



/******************************Public*Routine******************************\
* PauseCdrom
*
* This routine will pause a CDRom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
PauseCdrom(
    MCIDEVICEID DevHandle
    )
{
    MCI_GENERIC_PARMS mciGen;

    ZeroMemory( &mciGen, sizeof(mciGen) );

    return mciSendCommand( DevHandle, MCI_PAUSE, 0L, (DWORD)(LPVOID)&mciGen );
}


/******************************Public*Routine******************************\
* ResumeCdrom
*
* This routine will resume a paused CDRom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
ResumeCdrom(
    MCIDEVICEID DevHandle,
    int cdrom
    )

{
    MCI_GENERIC_PARMS   mciGen;
    DWORD               dwRet;
    static int          fCanResume = -1;

    ZeroMemory( &mciGen, sizeof(mciGen) );

    switch (fCanResume) {

    case -1:
        dwRet = mciSendCommand( DevHandle, MCI_RESUME, MCI_TO, (DWORD)(LPVOID)&mciGen );

        fCanResume = (dwRet == MMSYSERR_NOERROR ? 1 : 0);

        if (0 == fCanResume) {
            dwRet = (PlayCurrTrack( cdrom ) ? MMSYSERR_NOERROR : MCIERR_HARDWARE);
        }
        break;

    case 0:
        dwRet = (PlayCurrTrack( cdrom ) ? MMSYSERR_NOERROR : MCIERR_HARDWARE);
        break;

    case 1:
        dwRet = mciSendCommand( DevHandle, MCI_RESUME, MCI_TO, (DWORD)(LPVOID)&mciGen );
        break;
    }

    return dwRet;
}



/******************************Public*Routine******************************\
* PlayCdrom
*
* This routine plays a CDRom device starting and ending at the MSF
* positions specified in the structure passed in.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
PlayCdrom(
    MCIDEVICEID DevHandle,
    MCI_PLAY_PARMS *mciPlay
    )
{
    return mciSendCommand( DevHandle, MCI_PLAY,
                           MCI_FROM | MCI_TO, (DWORD)(LPVOID)mciPlay );
}

/******************************Public*Routine******************************\
* IsCdromTrackAudio
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
IsCdromTrackAudio(
    CDHANDLE DevHandle,
    int iTrackNumber
    )
{
    MCI_STATUS_PARMS mciStatus;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );
    mciStatus.dwItem = MCI_CDA_STATUS_TYPE_TRACK;
    mciStatus.dwTrack = iTrackNumber + 1;

    mciSendCommand( DevHandle, MCI_STATUS, MCI_STATUS_ITEM | MCI_TRACK,
                    (DWORD)(LPVOID)&mciStatus);

    return mciStatus.dwReturn == MCI_CDA_TRACK_AUDIO;
}


/******************************Public*Routine******************************\
* GetCdromCurrentPosition
*
* Gets the current ABSOLUTE position of the specified cdrom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
GetCdromCurrentPosition(
    CDHANDLE DevHandle,
    DWORD *lpdwPosition
    )
{

    MCI_STATUS_PARMS mciStatus;
    DWORD            dwErr;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );

    mciStatus.dwItem = MCI_STATUS_POSITION;
    dwErr = mciSendCommand( DevHandle, MCI_STATUS,
                            MCI_STATUS_ITEM, (DWORD)(LPVOID)&mciStatus );
    *lpdwPosition = mciStatus.dwReturn;

    return dwErr;
}



/******************************Public*Routine******************************\
* GetCdromMode
*
* Gets the current mode of the cdrom.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
GetCdromMode(
    MCIDEVICEID DevHandle
    )
{

    MCI_STATUS_PARMS mciStatus;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );

    mciStatus.dwItem = MCI_STATUS_MODE;
    mciSendCommand( DevHandle, MCI_STATUS,
                    MCI_STATUS_ITEM, (DWORD)(LPVOID)&mciStatus );
    return mciStatus.dwReturn;
}


/******************************Public*Routine******************************\
* GetCdromCurrentTrack
*
* Gets the current track of the cdrom.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
GetCdromCurrentTrack(
    MCIDEVICEID DevHandle
    )
{

    MCI_STATUS_PARMS mciStatus;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );

    mciStatus.dwItem = MCI_STATUS_CURRENT_TRACK;
    mciSendCommand( DevHandle, MCI_STATUS,
                    MCI_STATUS_ITEM, (DWORD)(LPVOID)&mciStatus );
    return mciStatus.dwReturn;
}


/******************************Public*Routine******************************\
* SeekCdrom
*
* This routine seek to an MSF address on the audio CD and enters
* a hold (paused) state.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
SeekCdrom(
    MCIDEVICEID DevHandle,
    MCI_SEEK_PARMS *mciSeek
    )
{
    return mciSendCommand( DevHandle, MCI_SEEK,
                           MCI_TO, (DWORD)(LPVOID)mciSeek );
}



/******************************Public*Routine******************************\
* EjectCdrom
*
* This routine will eject a disc from a CDRom device or close the tray if
* it is open.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
EjectCdrom(
    MCIDEVICEID DevHandle
    )
{
    MCI_SET_PARMS   mciSet;

    ZeroMemory( &mciSet, sizeof(mciSet) );

    if (GetCdromMode(DevHandle) == MCI_MODE_OPEN) {

        return mciSendCommand( DevHandle, MCI_SET,
                               MCI_SET_DOOR_CLOSED, (DWORD)(LPVOID)&mciSet );
    }
    else {

        return mciSendCommand( DevHandle, MCI_SET,
                               MCI_SET_DOOR_OPEN, (DWORD)(LPVOID)&mciSet );
    }
}



/******************************Public*Routine******************************\
* TestUnitReadyCdrom
*
* This routine will retrieve the status of the CDRom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
TestUnitReadyCdrom(
    MCIDEVICEID DevHandle
    )
{
    MCI_STATUS_PARMS mciStatus;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );

    mciStatus.dwItem = MCI_STATUS_MEDIA_PRESENT;
    if ( mciSendCommand( DevHandle, MCI_STATUS, MCI_STATUS_ITEM,
                         (DWORD)(LPVOID)&mciStatus ) == MMSYSERR_NOERROR ) {

        return mciStatus.dwReturn ? ERROR_SUCCESS : ERROR_NOT_READY;
    }

    return ERROR_NOT_READY;

}



/******************************Public*Routine******************************\
* StatusTrackPosCdrom
*
* This routine will retrieve the 
* status, current track, and current position of the CDRom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
DWORD
StatusTrackPosCdrom(
    MCIDEVICEID DevHandle,
    DWORD * pStatus,
    DWORD * pTrack,
    DWORD * pPos
    )
{
    DWORD dwErr;
    MCI_STATUS_PARMS mciStatus;
    PSTATUSTRACKPOS pSTP = NULL;
    STATUSTRACKPOS stp;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );

    // Note:  This is a non-standard MCI call (I.E. HACK!)
    //        the only reason for this behavior is it reduces
    //        the number of IOCTL's per 1/2 second on the HeartBeat
    //        thread for updating the timer display from ~15 to only
    //        ~1 on average.   Resulting in a major reduction in
    //        system traffic on the SCSI or IDE bus.

    // Note:  we are passing down a structre to MCICDA containing
    //        the position, track, and status values which it will
    //        fill in for us and return.
    mciStatus.dwItem = MCI_STATUS_TRACK_POS;
    mciStatus.dwReturn = (DWORD)&stp;
    dwErr = mciSendCommand( DevHandle, MCI_STATUS, MCI_STATUS_ITEM,
                         (DWORD)(LPVOID)&mciStatus );
    if (dwErr == MMSYSERR_NOERROR)
    {
        pSTP = (PSTATUSTRACKPOS)mciStatus.dwReturn;
        if (pSTP)
        {
            if (pStatus)
                *pStatus = pSTP->dwStatus;
            if (pTrack)
                *pTrack = pSTP->dwTrack;
            if (pPos)
                *pPos = pSTP->dwDiscTime;

            pSTP = NULL;
        }
    }

    return dwErr;
} // End StatusTrackPosCdrom


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\cdplayer.c ===
/******************************Module*Header*******************************\
* Module Name: cdplayer.c
*
* CD Playing application
*
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 - 1995 Microsoft Corporation.  All rights reserved.
\**************************************************************************/
#pragma warning( once : 4201 4214 )


#include <windows.h>    /* required for all Windows applications          */
#include <shellapi.h>
#include <windowsx.h>

#include <ole2.h>
#include <shlobj.h>
#include <dbt.h>


#define NOMENUHELP
#define NOBTNLIST
#define NOTRACKBAR
#define NODRAGLIST
#define NOUPDOWN
#include <commctrl.h>   /* want toolbar and status bar                    */


#include <string.h>
#include <stdio.h>
#include <tchar.h>      /* contains portable ascii/unicode macros         */
#include <stdarg.h>
#include <stdlib.h>
#include <math.h>   // for ceil()

#include <htmlhelp.h>   /* new help system for NT 5.0                     */

#define GLOBAL          /* This allocates storage for the public globals  */

#include "resource.h"
#include "cdplayer.h"
#include "ledwnd.h"
#include "cdapi.h"
#include "scan.h"
#include "trklst.h"
#include "database.h"
#include "commands.h"
#include "buttons.h"
#include "preferen.h"
#include "literals.h"
#include "helpids.h"


// Next 2 lines added to add multimon support: <mwetzel 08.22.97>
#define COMPILE_MULTIMON_STUBS
#include <multimon.h> 


//#ifndef WM_CDPLAYER_COPYDATA
#define WM_CDPLAYER_COPYDATA (WM_USER+0x100)
//#endif


/* -------------------------------------------------------------------------
** Private functions
** -------------------------------------------------------------------------
*/
void
StartSndVol(
    DWORD unused
    );

int
CopyWord(
    TCHAR *szWord,
    TCHAR *szSource
    );

void
AppendTrackToPlayList(
    PTRACK_PLAY pHead,
    PTRACK_PLAY pInsert
    );

BOOL
IsTrackFileNameValid(
    LPTSTR lpstFileName,
    int *piCdRomIndex,
    int *piTrackIndex,
    BOOL fScanningTracks,
    BOOL fQuiet
    );

TCHAR *
ParseTrackList(
    TCHAR *szTrackList,
    int *piCdRomIndex
    );

int
ParseCommandLine(
    LPTSTR lpstr,
    int *piTrackToSeekTo,
    BOOL fQuiet
    );

void
HandlePassedCommandLine(
    LPTSTR lpCmdLine,
    BOOL   fCheckCDRom
    );

int
FindMostSuitableDrive(
    void
    );

void
AskUserToInsertCorrectDisc(
    DWORD dwID
    );

WORD
GetMenuLine(
    HWND hwnd
    );

#ifndef USE_IOCTLS
BOOL CheckMCICDA (TCHAR chDrive);
#endif // ! USE_IOCTLS

BOOL
CDPlay_CopyData(
    HWND hwnd,
    PCOPYDATASTRUCT lpcpds
    );

/* -------------------------------------------------------------------------
** Private Globals
** -------------------------------------------------------------------------
*/

RECT            rcToolbar;
RECT            rcStatusbar;
RECT            rcTrackInfo;

RECT            rcControls[NUM_OF_CONTROLS];
long            cyTrackInfo;
int             cyMenuCaption;

HICON           hIconCdPlayer;
HBRUSH          g_hBrushBkgd;


BOOL            g_fTitlebarShowing = TRUE;
BOOL            g_fVolumeController;
BOOL            g_fTrackInfoVisible = 1;
TCHAR           g_szTimeSep[10];
int             g_AcceleratorCount;

BOOL            g_fInCopyData = FALSE;

CRITICAL_SECTION g_csTOCSerialize;

static HHOOK     fpfnOldMsgFilter;
static HOOKPROC  fpfnMsgHook;
//Data used for supporting context menu help
BOOL   bF1InMenu=FALSE;	//If true F1 was pressed on a menu item.
UINT   currMenuItem=0;	//The current selected menu item if any.

//---------------------------------------------------------------------------
// Stuff required to make drag/dropping of a shortcut file work on Chicago
//---------------------------------------------------------------------------
BOOL
ResolveLink(
    TCHAR * szFileName
    );

BOOL g_fOleInitialized = FALSE;

void CALLBACK
ToolTipsTimerFunc(
    HWND hwnd,
    UINT uMsg,
    UINT idEvent,
    DWORD dwTime
    );

WNDPROC g_lpfnToolTips;
#define TOOLTIPS_TIMER_ID   0x5236
#define TOOLTIPS_TIMER_LEN  150

TBBUTTON tbButtons[DEFAULT_TBAR_SIZE] = {
    { IDX_SEPARATOR,    1,                      0,                                  TBSTYLE_SEP                                },
    { IDX_1,            IDM_DATABASE_EDIT,      TBSTATE_ENABLED,                    TBSTYLE_BUTTON,                0,0,  0, -1 },
    { IDX_SEPARATOR,    2,                      0,                                  TBSTYLE_SEP                                },
    { IDX_2,            IDM_TIME_REMAINING,     TBSTATE_CHECKED | TBSTATE_ENABLED,  TBSTYLE_CHECK | TBSTYLE_GROUP, 0,0,  0, -1 },
    { IDX_3,            IDM_TRACK_REMAINING,    TBSTATE_ENABLED,                    TBSTYLE_CHECK | TBSTYLE_GROUP, 0,0,  0, -1 },
    { IDX_4,            IDM_DISC_REMAINING,     TBSTATE_ENABLED,                    TBSTYLE_CHECK | TBSTYLE_GROUP, 0,0,  0, -1 },
    { IDX_SEPARATOR,    3,                      0,                                  TBSTYLE_SEP                                },
    { IDX_5,            IDM_OPTIONS_RANDOM,     TBSTATE_ENABLED,                    TBSTYLE_CHECK,                 0,0,  0, -1 },
    { IDX_6,            IDM_OPTIONS_MULTI,      TBSTATE_ENABLED,                    TBSTYLE_CHECK,                 0,0,  0, -1 },
    { IDX_7,            IDM_OPTIONS_CONTINUOUS, TBSTATE_ENABLED,                    TBSTYLE_CHECK,                 0,0,  0, -1 },
    { IDX_8,            IDM_OPTIONS_INTRO,      TBSTATE_ENABLED,                    TBSTYLE_CHECK,                 0,0,  0, -1 }
};


BITMAPBTN tbPlaybar[] = {
    { IDX_1, IDM_PLAYBAR_PLAY,          0 },
    { IDX_2, IDM_PLAYBAR_PAUSE,         0 },
    { IDX_3, IDM_PLAYBAR_STOP,          0 },
    { IDX_4, IDM_PLAYBAR_PREVTRACK,     0 },
    { IDX_5, IDM_PLAYBAR_SKIPBACK,      0 },
    { IDX_6, IDM_PLAYBAR_SKIPFORE,      0 },
    { IDX_7, IDM_PLAYBAR_NEXTTRACK,     0 },
    { IDX_8, IDM_PLAYBAR_EJECT,         0 }
};


/*
** these values are defined by the UI gods...
*/
const int dxButton     = 24;
const int dyButton     = 22;
const int dxBitmap     = 16;
const int dyBitmap     = 16;
//#ifdef DBCS // needs more width of main dlg
// the value was 8 but now 14 so that the window size of cdplayer is little
// bit larger than previous one. 
#if 1
const int xFirstButton = 14;
#else
const int xFirstButton = 8;
#endif


/* -------------------------------------------------------------------------
** Try to prevent multiple cdplayers
** -------------------------------------------------------------------------
*/
#pragma data_seg(".sdata")
int g_iInUse = -1;
#pragma data_seg()


/*------------------------------------------------------+
| HelpMsgFilter - filter for F1 key in dialogs          |
|                                                       |
+------------------------------------------------------*/

DWORD FAR PASCAL HelpMsgFilter(int nCode, UINT wParam, DWORD lParam)
{
  if (nCode >= 0){
      LPMSG    msg = (LPMSG)lParam;

      if (g_hwndApp && (msg->message == WM_KEYDOWN) && (msg->wParam == VK_F1))
	  {
		if(nCode == MSGF_MENU)
			bF1InMenu = TRUE;
	  	SendMessage(g_hwndApp, WM_COMMAND, (WPARAM)IDM_HELP_TOPICS, 0L);
	  }	
  }
    return 0;
}

/******************************Public*Routine******************************\
* WinMain
*
*
* Windows recognizes this function by name as the initial entry point
* for the program.  This function calls the application initialization
* routine, if no other instance of the program is running, and always
* calls the instance initialization routine.  It then executes a message
* retrieval and dispatch loop that is the top-level control structure
* for the remainder of execution.  The loop is terminated when a WM_QUIT
* message is received, at which time this function exits the application
* instance by returning the value passed by PostQuitMessage().
*
* If this function must abort before entering the message loop, it
* returns the conventional value NULL.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
int PASCAL
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{
    MSG     msg;
    BOOL    fFirstInstance = (InterlockedIncrement( &g_iInUse ) == 0);
    HACCEL  hAccel;

#ifdef DBG
    /*
    ** This removes the Gdi batch feature.  It ensures that the screen
    ** is updated after every gdi call - very useful for debugging.
    */
    GdiSetBatchLimit(1);
#endif

    /*
    ** Save the instance handle in static variable, which will be used in
    ** many subsequence calls from this application to Windows.
    */
    g_hInst = hInstance;
    g_lpCmdLine = lpCmdLine;


    /* setup the message filter to handle grabbing F1 for this task */
    fpfnMsgHook = (HOOKPROC)MakeProcInstance((FARPROC)HelpMsgFilter, ghInst);
    fpfnOldMsgFilter = (HHOOK)SetWindowsHook(WH_MSGFILTER, fpfnMsgHook);

	/*
    ** If CDPlayer is already running try to bring it to the top.
    ** If we can't find its window it probably means that the it has
    ** either crashed or not got around to creating it yet.
    */
    if ( !fFirstInstance ) {

	CdPlayerAlreadyRunning();

	if (g_fOleInitialized) {
	    OleUninitialize();
	}
    InterlockedDecrement( &g_iInUse );
    return FALSE;
    }

    InitializeCriticalSection (&g_csTOCSerialize);

    /*
    ** Initialize the cdplayer application.
    */
    CdPlayerStartUp();

    /*
    ** If the "-Play" command line option was specified we need to start
    ** minimized and non active.
    */
    if (IsPlayOptionGiven( GetCommandLine() )) {
	nCmdShow = SW_SHOWMINNOACTIVE;
    }


    /*
    ** Try to load the accelerator table for the app
    */
    hAccel = LoadAccelerators( hInstance, MAKEINTRESOURCE(IDR_ACCELTABLE) );


    /*
    ** Make the window visible; update its client area
    */
    ShowWindow( g_hwndApp, nCmdShow );
    UpdateWindow( g_hwndApp );


    /*
    ** Acquire and dispatch messages until a WM_QUIT message is received.
    */
    while ( GetMessage( &msg, NULL, 0, 0 ) ) {

	if ( hAccel && TranslateAccelerator(g_hwndApp, hAccel, &msg) ) {
	    continue;
	}

	if ( !IsDialogMessage( g_hwndApp, &msg ) ) {
	    TranslateMessage( &msg );
	    DispatchMessage( &msg );
	}
    }

    // Cleanup

	/* if the message hook was installed, remove it and free */
    /* up our proc instance for it.                          */
    if (fpfnOldMsgFilter){
		UnhookWindowsHook(WH_MSGFILTER, fpfnMsgHook);
    }

    DeleteCriticalSection (&g_csTOCSerialize);

    if (g_fOleInitialized) {
	OleUninitialize();
    }

    InterlockedDecrement( &g_iInUse );

    return msg.wParam;
}


/*****************************Private*Routine******************************\
* InitInstance
*
*
* This function is called at initialization time for every instance of
* this application.  This function performs initialization tasks that
* cannot be shared by multiple instances.
*
* In this case, we save the instance handle in a static variable and
* create and display the main program window.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
InitInstance(
    HANDLE hInstance
    )
{
    HWND        hwnd;
    WNDCLASS    cls;

    /*
    ** Load in some strings
    */

    _tcscpy( g_szArtistTxt,  IdStr( STR_HDR_ARTIST ) );
    _tcscpy( g_szTitleTxt,   IdStr( STR_HDR_TITLE ) );
    _tcscpy( g_szUnknownTxt, IdStr( STR_UNKNOWN ) );
    _tcscpy( g_szTrackTxt,   IdStr( STR_HDR_TRACK ) );

    g_szTimeSep[0] = TEXT(':');
    g_szTimeSep[1] = g_chNULL;
    GetLocaleInfo( GetUserDefaultLCID(), LOCALE_STIME, g_szTimeSep, 10 );


    /*
    ** Load the applications icon
    */
    hIconCdPlayer = LoadIcon( hInstance, MAKEINTRESOURCE(IDR_CDPLAYER_ICON) );
    g_hbmTrack = LoadBitmap( hInstance, MAKEINTRESOURCE(IDR_TRACK) );
    CheckSysColors();

    /*
    ** Initialize the my classes.  We do this here because the dialog
    ** that we are about to create contains two windows on my class.
    ** The dialog would fail to be created if the classes was not registered.
    */
    g_fDisplayT = TRUE;
    InitLEDClass( g_hInst );
    Init_SJE_TextClass( g_hInst );

    cls.lpszClassName  = g_szSJE_CdPlayerClass;
    cls.hCursor        = LoadCursor(NULL, IDC_ARROW);
    cls.hIcon          = hIconCdPlayer;
    cls.lpszMenuName   = NULL;
    cls.hbrBackground  = (HBRUSH)(COLOR_BTNFACE + 1);
    cls.hInstance      = hInstance;
    cls.style          = CS_DBLCLKS;
    cls.lpfnWndProc    = DefDlgProc;
    cls.cbClsExtra     = 0;
    cls.cbWndExtra     = DLGWINDOWEXTRA;
    if ( !RegisterClass(&cls) ) {
	return FALSE;
    }

    /*
    ** Create a main window for this application instance.
    */
    hwnd = CreateDialog( g_hInst, MAKEINTRESOURCE(IDR_CDPLAYER),
			 (HWND)NULL, MainWndProc );

    /*
    ** If window could not be created, return "failure"
    */
    if ( !hwnd ) {
	return FALSE;
    }

    g_hwndApp = hwnd;

    return TRUE;
}


/*****************************Private*Routine******************************\
* CdPlayerAlreadyRunning
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerAlreadyRunning(
    void
    )
{
    COPYDATASTRUCT  cpds;
    HWND            hwndFind;
    DWORD           dwForeGndThreadID = 0L;
    HWND            hwndForeGnd;

    hwndFind = FindWindow( g_szSJE_CdPlayerClass, NULL );

    /*
    ** If the foreground window is an instance of cdplayer don't
    ** forward the command line to it.  This just confuses the user
    ** as his app suddenly starts play without him pressing play.
    ** This is only a problem on Chicago when the user inserts a
    ** a new disc into the drive.
    */
    hwndForeGnd = GetForegroundWindow();
    if (hwndForeGnd != NULL) {
	dwForeGndThreadID = GetWindowThreadProcessId(hwndForeGnd, NULL);
    }

    if ( (hwndFind != NULL) &&
	 (IsIconic(hwndFind) ||
	     GetWindowThreadProcessId(hwndFind, NULL) != dwForeGndThreadID) ) {

	    /*
	    ** First parse the command line to see if the play command has
	    ** been specified.  If "play" has been specified then don't bother
	    ** restoring the other instance of CDPlayer.
	    */
	    if (! IsPlayOptionGiven( GetCommandLine() )) {
		hwndFind = GetLastActivePopup( hwndFind );

		if ( IsIconic( hwndFind ) ) {
			ShowWindow( hwndFind, SW_RESTORE );
		}

		BringWindowToTop( hwndFind );
		SetForegroundWindow( hwndFind );
	}

	    /*
	    ** Now transfer our command line to the other instance of
	    ** CDPlayer.  We don't do any track/disc validation here but
	    ** rather defer everything to the cdplayer that is already running.
	    */
	    cpds.dwData = 0L;
	    cpds.cbData = (_tcslen(GetCommandLine()) + 1) * sizeof(TCHAR);
	    cpds.lpData = AllocMemory(cpds.cbData);
	if (cpds.lpData == NULL) {
	    // Error - not enough memory to continue
	    return;
	}

	    _tcscpy((LPTSTR)cpds.lpData, GetCommandLine());

	    SendMessage(hwndFind, WM_COPYDATA, 0, (LPARAM)(LPVOID)&cpds);
	    LocalFree((HLOCAL)cpds.lpData);
    } 
    else if (hwndFind != NULL) {
	UINT cch, cchInsert;
	UINT cchCmd, cchUpdate;
	LPTSTR lpstr;

	// Tell primary instance to just update,
	// In case this CD was just inserted
	cchUpdate  = _tcslen (g_szUpdateOption);
	cchCmd = _tcslen(GetCommandLine());
	cch = cchUpdate + cchCmd;

	    cpds.dwData = 0L;
	    cpds.cbData = (cch + 1) * sizeof(TCHAR);
	    cpds.lpData = AllocMemory(cpds.cbData);
	if (cpds.lpData == NULL) {
	    // Error - not enough memory to continue
	    return;
	}
	    //
	    // Insert the -UPDATE option between cdplayer.exe
	    // parameter and rest of parameters
	    //

	    // find insertion point
	lpstr = (LPTSTR)GetCommandLine();
	cchInsert = _tcsspn(lpstr, g_szBlank);
	lpstr += cchInsert;
	cchInsert += _tcscspn(lpstr, g_szBlank);
	lpstr += cchInsert;

	_tcsncpy((LPTSTR)cpds.lpData, GetCommandLine(), cchInsert);
	((LPTSTR)cpds.lpData)[cchInsert] = 0;
	_tcscat((LPTSTR)cpds.lpData, g_szUpdateOption);
	cchInsert += cchUpdate;
	((LPTSTR)cpds.lpData)[cchInsert] = 0;
	_tcscat((LPTSTR)cpds.lpData, lpstr);

	    SendMessage(hwndFind, WM_COPYDATA, 0, (LPARAM)(LPVOID)&cpds);
	    LocalFree((HLOCAL)cpds.lpData);        
    }

}


/*****************************Private*Routine******************************\
* CdPlayerStartUp
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerStartUp(
    void
    )
{
    /*
    ** Reseed random generator
    */
    srand( GetTickCount() );


    /*
    ** Set error mode popups for critical errors (like
    ** no disc in drive) OFF.
    */
    SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );


    /*
    ** Scan device chain for CDROM devices...   Terminate if none found.
    */
    g_NumCdDevices = ScanForCdromDevices( );

    if ( g_NumCdDevices == 0 ) {

	LPTSTR lpstrTitle;
	LPTSTR lpstrText;

	lpstrTitle = AllocMemory( STR_MAX_STRING_LEN * sizeof(TCHAR) );
	lpstrText  = AllocMemory( STR_MAX_STRING_LEN * sizeof(TCHAR) );

	_tcscpy( lpstrText, IdStr(STR_NO_CDROMS) );
	_tcscpy( lpstrTitle, IdStr(STR_CDPLAYER) );

	MessageBox( NULL, lpstrText, lpstrTitle,
		    MB_APPLMODAL | MB_ICONINFORMATION |
		    MB_OK | MB_SETFOREGROUND );

	LocalFree( (HLOCAL)lpstrText );
	LocalFree( (HLOCAL)lpstrTitle );

	ExitProcess( (UINT)-1 );
    }

#ifndef USE_IOCTLS
    // Make sure we have a functional MCI (CD Audio)
    if (! CheckMCICDA (g_Devices[0]->drive)) {
    ExitProcess( (UINT)-1 );
    }
#endif // ! USE_IOCTLS

    /*
    ** Perform initializations that apply to a specific instance
    ** This function actually creates the CdPlayer window.  (Note that it is
    ** not visible yet).  If we get here we know that there is a least one
    ** cdrom device detected which may have a music cd in it.  If it does
    ** contain a music cdrom the table of contents will have been read and
    ** cd database queryed to determine if the music cd is known.  Therefore
    ** on the WM_INITDIALOG message we should update the "Artist", "Title" and
    ** "Track" fields of the track info display and adjust the enable state
    ** of the play buttons.
    */

    if ( !InitInstance( g_hInst ) ) {
	FatalApplicationError( STR_TERMINATE );
    }


    /*
    ** Restore ourselves from the ini file
    */
    ReadSettings();


    /*
    ** Scan command the command line.  If we were given any valid commandline
    ** args we have to adjust the nCmdShow parameter.  (ie.  start minimized
    ** if the user just wants us to play a certain track.  ScanCommandLine can
    ** overide the default playlist for all the cd-rom devices installed.  It
    ** modifies the global flag g_fPlay and returns the index of the first
    ** CD-Rom that should be played.
    */
    g_CurrCdrom = g_LastCdrom = 0;


    /*
    ** Check to see if the volume controller piglett can be found on
    ** the path.
    */
    {
	TCHAR   chBuffer[8];
	LPTSTR  lptstr;

	g_fVolumeController = (SearchPath( NULL, g_szSndVol32,
					   NULL, 8, chBuffer, &lptstr ) != 0L);
    }
}

/*****************************Private*Routine******************************\
* CompleteCdPlayerStartUp
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
CompleteCdPlayerStartUp(
    void
    )
{
    int iTrackToSeekTo = -1;
    int i;

    /*
    ** Scan command the command line.  If we were given any valid
    ** commandline args we have to adjust the nCmdShow parameter.  (ie.
    ** start minimized if the user just wants us to play a certain
    ** track.  ScanCommandLine can overide the default playlist for all
    ** the cd-rom devices installed.  It modifies the global flag
    ** g_fPlay and returns the index of the first CD-Rom that should be
    ** played.
    **
    */
    g_CurrCdrom = g_LastCdrom = ParseCommandLine( GetCommandLine(),
						  &iTrackToSeekTo, FALSE );
    /*
    ** If the message box prompting the user to insert the correct cd disc in
    ** the drive was displayed, ParseCommandLine will return -1, in which case
    ** find the most suitable drive, also make sure that we don't come up
    ** playing.
    */
    if (g_LastCdrom == -1) {
	g_fPlay = FALSE;
	g_CurrCdrom = g_LastCdrom = FindMostSuitableDrive();
    }

    /*
    ** If there was no commandline specifed and there is more
    ** than one drive available try to select the best drive to make the
    ** current drive.
    **
    ** We should choose the first disc that is playing if any are
    ** playing.
    **
    ** Else we should choose the first disc with a music disk in
    ** it if there any drives with music discs in them.
    **
    ** Else we should chose the first drive that is available if
    ** any of the drives are available.
    **
    ** Else just choose the first (ie. zeroth) drive.
    */
    if (g_lpCmdLine && !*g_lpCmdLine && g_NumCdDevices > 1) {

	g_CurrCdrom = g_LastCdrom = FindMostSuitableDrive();
    }

    for ( i = 0; i < g_NumCdDevices; i++) {

	TimeAdjustInitialize( i );
    }

    /*
    ** All the rescan threads are either dead or in the act of dying.
    ** It is now safe to initalize the time information for each
    ** cdrom drive.
    */
    if ( iTrackToSeekTo != -1 ) {

	PTRACK_PLAY tr;

	tr = PLAYLIST( g_CurrCdrom );
	if ( tr != NULL ) {

	    for( i = 0; i < iTrackToSeekTo; i++, tr = tr->nextplay );

	    TimeAdjustSkipToTrack( g_CurrCdrom, tr );
	}
    }


    /*
    ** if we are in random mode, then we need to shuffle the play lists.
    */

    if (!g_fSelectedOrder) {
	ComputeAndUseShufflePlayLists();
    }
    SetPlayButtonsEnableState();


    /*
    ** Start the heart beat time.  This timer is responsible for:
    **  1. detecting new or ejected cdroms.
    **  2. flashing the LED display if we are in paused mode.
    **  3. Incrementing the LED display if we are in play mode.
    */
    SetTimer( g_hwndApp, HEARTBEAT_TIMER_ID, HEARTBEAT_TIMER_RATE,
	      HeartBeatTimerProc );

    if ( g_fPlay ) {
	CdPlayerPlayCmd();
    }

    /*
    ** Make sure that the focus is on a suitable control
    */
    if (g_State & (CD_NO_CD | CD_DATA_CD_LOADED)) {
	SetFocus( g_hwndControls[INDEX(IDM_PLAYBAR_EJECT)] );
    }
    else if ((g_State & CD_IN_USE) == 0) {

	if (g_State & (CD_PLAYING | CD_PAUSED)) {
	    SetFocus( g_hwndControls[INDEX(IDM_PLAYBAR_PAUSE)] );
	}
	else {
	    SetFocus( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)] );
	}
    }
}


/******************************Public*Routine******************************\
* MainWndProc
*
* Use the message crackers to dispatch the dialog messages to appropirate
* message handlers.  The message crackers are portable between 16 and 32
* bit versions of Windows.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL CALLBACK
MainWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch ( message ) {

    HANDLE_MSG( hwnd, WM_INITDIALOG,        CDPlay_OnInitDialog );
    HANDLE_MSG( hwnd, WM_INITMENUPOPUP,     CDPlay_OnInitMenuPopup );
    HANDLE_MSG( hwnd, WM_SYSCOLORCHANGE,    CDPlay_OnSysColorChange );
    HANDLE_MSG( hwnd, WM_DRAWITEM,          CDPlay_OnDrawItem );
    HANDLE_MSG( hwnd, WM_COMMAND,           CDPlay_OnCommand );
    HANDLE_MSG( hwnd, WM_DESTROY,           CDPlay_OnDestroy );
    HANDLE_MSG( hwnd, WM_SIZE,              CDPlay_OnSize );
    HANDLE_MSG( hwnd, WM_ENDSESSION,        CDPlay_OnEndSession );
    HANDLE_MSG( hwnd, WM_WININICHANGE,      CDPlay_OnWinIniChange );
    HANDLE_MSG( hwnd, WM_CTLCOLORSTATIC,    Common_OnCtlColor );
    HANDLE_MSG( hwnd, WM_CTLCOLORDLG,       Common_OnCtlColor );
    HANDLE_MSG( hwnd, WM_MEASUREITEM,       Common_OnMeasureItem );
    HANDLE_MSG( hwnd, WM_NOTIFY,            CDPlay_OnNotify );
    HANDLE_MSG( hwnd, WM_MENUSELECT,        CDPlay_OnMenuSelect );
    HANDLE_MSG( hwnd, WM_LBUTTONDBLCLK,     CDPlay_OnLButtonDown );
    HANDLE_MSG( hwnd, WM_NCHITTEST,         CDPlay_OnNCHitTest );
	HANDLE_MSG( hwnd, WM_PAINT,             CDPlay_OnPaint );

    HANDLE_MSG( hwnd, WM_DROPFILES,         CDPlay_OnDropFiles );

    case WM_DEVICECHANGE:
	return CDPlay_OnDeviceChange (hwnd, wParam, lParam);
    
	case WM_ACTIVATEAPP:
	if ((BOOL)wParam) {
	    if (g_State & CD_PLAYING) {
		SetFocus( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)] );
	    }
	    else {
		SetFocus( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)] );
	    }
	}
	return 1;
    
	case WM_ERASEBKGND:
	return 1;

    case WM_CLOSE:
	return CDPlay_OnClose(hwnd, FALSE);

    case WM_NCLBUTTONDBLCLK:
	if (g_fTitlebarShowing) {
	    return DefWindowProc( hwnd, message, wParam, lParam );
	}
	return HANDLE_WM_NCLBUTTONDBLCLK( hwnd, wParam, lParam,
					  CDPlay_OnLButtonDown );

    case WM_COPYDATA:
	    return CDPlay_CopyData( hwnd,  (PCOPYDATASTRUCT)lParam );

    case WM_CDPLAYER_COPYDATA:
	    return CDPlay_OnCopyData( hwnd,  (PCOPYDATASTRUCT)lParam );

    case WM_NOTIFY_TOC_READ:
	return CDPlay_OnTocRead( (int)wParam );

    default:
	return FALSE;
    }
}


/*****************************Private*Routine******************************\
* CDPlay_OnInitDialog
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
CDPlay_OnInitDialog(
    HWND hwnd,
    HWND hwndFocus,
    LPARAM lParam
    )
{
    LOGFONT lf;
    int     iLogPelsY;
    HDC     hdc;
    int     i;
    CHARSETINFO csi;
    DWORD dw = GetACP();

    if (!TranslateCharsetInfo((DWORD *)dw, &csi, TCI_SRCCODEPAGE))
	csi.ciCharset = ANSI_CHARSET;

    hdc = GetDC( hwnd );
    iLogPelsY = GetDeviceCaps( hdc, LOGPIXELSY );
    ReleaseDC( hwnd, hdc );

    ZeroMemory( &lf, sizeof(lf) );

    lf.lfHeight = (-9 * iLogPelsY) / 72;   /* 10pt                         */
    lf.lfWeight = 400;                      /* normal                       */
    lf.lfCharSet = csi.ciCharset;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = PROOF_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
    _tcscpy( lf.lfFaceName, g_szAppFontName );
    g_hDlgFont = CreateFontIndirect(&lf);

#ifdef DAYTONA
    if (g_hDlgFont) {

	SendDlgItemMessage( hwnd, IDC_ARTIST_NAME,
			    WM_SETFONT, (WPARAM)(g_hDlgFont), 0L );
	SendDlgItemMessage( hwnd, IDC_TITLE_NAME,
			    WM_SETFONT, (WPARAM)(g_hDlgFont), 0L );
	SendDlgItemMessage( hwnd, IDC_TRACK_LIST,
			    WM_SETFONT, (WPARAM)(g_hDlgFont), 0L );
    }
#endif

    cyMenuCaption = GetSystemMetrics( SM_CYMENU ) +
		    GetSystemMetrics( SM_CYCAPTION );

    g_hBrushBkgd = CreateSolidBrush( rgbFace );

    BtnCreateBitmapButtons( hwnd, g_hInst, IDR_PLAYBAR, BBS_TOOLTIPS,
			    tbPlaybar, NUM_OF_BUTTONS, 16, 15 );

    /*
    ** Before I go off creating toolbars and status bars
    ** I need to create a list of all the child windows positions
    ** so that I can manipulate them when displaying the toolbar,
    ** status bar and disk info.
    */
    EnumChildWindows( hwnd, ChildEnumProc, (LPARAM)hwnd );
    AdjustChildButtons(hwnd);
    EnumChildWindows( hwnd, ChildEnumProc, (LPARAM)hwnd );

    /*
    ** fix kksuzuka#5285
    ** If System font size is 20/24 dot, the menubar will be two or
    ** more lines. So we need to resize main window again.
    */
    {
	RECT rc;
	WORD iMenuLine = GetMenuLine( hwnd );
	int  cyMenu;

	GetWindowRect( hwnd, &rc );
	if (iMenuLine > 1) {
	    cyMenu = (GetSystemMetrics( SM_CYMENU ) + GetSystemMetrics( SM_CYBORDER )) *
		     (iMenuLine - GetSystemMetrics( SM_CYBORDER ));
	    rc.bottom += cyMenu;
	}
	SetWindowPos( hwnd, HWND_TOP, 0, 0,
		      rc.right - rc.left, rc.bottom - rc.top,
		      SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE );
    }

    if ( CreateToolbarsAndStatusbar(hwnd) == FALSE ) {

	/*
	** No toolbar - no application, simple !
	*/
	FatalApplicationError( STR_FAIL_INIT );
    }

    DragAcceptFiles( hwnd, TRUE );


    /*
    ** Initialize and read the TOC for all the detected CD-ROMS
    */
    SetPlayButtonsEnableState();
    for ( i = 0; i < g_NumCdDevices; i++ ) {

	ASSERT(g_Devices[i]->State == CD_BEING_SCANNED);
	ASSERT(g_Devices[i]->hCd == 0L);

	TimeAdjustInitialize( i );

	g_Devices[i]->State = CD_NO_CD;
	RescanDevice( hwnd, i );
    }

    return FALSE;
}

#ifdef DAYTONA
/*****************************Private*Routine******************************\
* CDPlay_OnPaint
*
* Paints the hilight under the menu but only if the toolbar is NOT visible.
* I use IsWindowVisible to get the TRUE visiblity status of the toolbar.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnPaint(
    HWND hwnd
    )
{
    HDC         hdc;
    PAINTSTRUCT ps;
    RECT        rc;

    hdc = BeginPaint( hwnd, &ps );

    CheckSysColors();

    GetClientRect( hwnd, &rc );

    if (!IsWindowVisible( g_hwndToolbar)) {

	PatB( hdc, 0, 0, rc.right, 1, rgbHilight );
	ExcludeClipRect( hdc, 0, 0, rc.right, 1 );
    }

    if ( ps.fErase ) {
	DefWindowProc( hwnd, WM_ERASEBKGND, (WPARAM)hdc, 0 );
    }

    EndPaint( hwnd, &ps );
}
#endif


/*****************************Private*Routine******************************\
* CDPlay_OnInitMenuPopup
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnInitMenuPopup(
    HWND hwnd,
    HMENU hMenu,
    UINT item,
    BOOL fSystemMenu
    )
{
    switch ( item ) {

    case 0:
	/*
	** Do we have a music cd loaded.
	*/
	if (g_State & (CD_BEING_SCANNED | CD_IN_USE | CD_NO_CD | CD_DATA_CD_LOADED)) {
	    EnableMenuItem(hMenu, IDM_DATABASE_EDIT, MF_GRAYED | MF_BYCOMMAND);
	}
	else {
	    EnableMenuItem(hMenu, IDM_DATABASE_EDIT, MF_ENABLED | MF_BYCOMMAND);
	}
	break;

    case 1:
	CheckMenuItemIfTrue( hMenu, IDM_VIEW_STATUS, g_fStatusbarVisible );
	CheckMenuItemIfTrue( hMenu, IDM_VIEW_TRACKINFO, g_fTrackInfoVisible );
	CheckMenuItemIfTrue( hMenu, IDM_VIEW_TOOLBAR, g_fToolbarVisible );

	CheckMenuItemIfTrue( hMenu, IDM_TIME_REMAINING, g_fDisplayT );
	CheckMenuItemIfTrue( hMenu, IDM_TRACK_REMAINING, g_fDisplayTr );
	CheckMenuItemIfTrue( hMenu, IDM_DISC_REMAINING, g_fDisplayDr );

	if (g_fVolumeController) {
	    EnableMenuItem(hMenu, IDM_VIEW_VOLUME, MF_ENABLED | MF_BYCOMMAND);
	}
	else {
	    EnableMenuItem(hMenu, IDM_VIEW_VOLUME, MF_GRAYED | MF_BYCOMMAND);
	}
	break;

    case 2:
	CheckMenuItemIfTrue( hMenu, IDM_OPTIONS_RANDOM, !g_fSelectedOrder );

	//if (g_fMultiDiskAvailable) {
	//    CheckMenuItemIfTrue( hMenu, IDM_OPTIONS_MULTI, !g_fSingleDisk );
	//}

	CheckMenuItemIfTrue( hMenu, IDM_OPTIONS_CONTINUOUS, g_fContinuous );
	CheckMenuItemIfTrue( hMenu, IDM_OPTIONS_INTRO, g_fIntroPlay );
	break;
    }
}


/*****************************Private*Routine******************************\
* CDPlay_OnSysColorChange
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnSysColorChange(
    HWND hwnd
    )
{
    CheckSysColors();
    if (g_hBrushBkgd) {
	DeleteObject(g_hBrushBkgd);
	g_hBrushBkgd = CreateSolidBrush( rgbFace );
    }

    BtnUpdateColors( hwnd );
    FORWARD_WM_SYSCOLORCHANGE(g_hwndToolbar, SendMessage);
}



/*****************************Private*Routine******************************\
* CDPlay_OnWinIniChange
*
* Updates the time format separator and the LED display
*
* History:
* 29-09-94 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnWinIniChange(
    HWND hwnd,
    LPCTSTR lpszSectionName
    )
{
    int     cy;
    RECT    rc;

    cy = GetSystemMetrics( SM_CYMENU ) + GetSystemMetrics( SM_CYCAPTION );
    if ( cy != cyMenuCaption ) {

	GetWindowRect( hwnd, &rc );
	rc.bottom += cy - cyMenuCaption;

	SetWindowPos( hwnd, HWND_TOP, 0, 0,
		      rc.right - rc.left, rc.bottom - rc.top,
		      SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER );
	cyMenuCaption = cy;
    }

    GetLocaleInfo( GetUserDefaultLCID(), LOCALE_STIME, g_szTimeSep, 10 );
    UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_DISC_TIME | DISPLAY_UPD_TRACK_TIME );
}






/*****************************Private*Routine******************************\
* CDPlay_OnDrawItem
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
CDPlay_OnDrawItem(
    HWND hwnd,
    const DRAWITEMSTRUCT *lpdis
    )
{
    int         i;

    i = INDEX(lpdis->CtlID);

    switch (lpdis->CtlType) {

    case ODT_BUTTON:

	/*
	** See if the fast foreward or backward buttons has been pressed or
	** released.  If so execute the seek command here.  Do nothing on
	** the WM_COMMAND message.
	*/
	if ( lpdis->CtlID == IDM_PLAYBAR_SKIPBACK
	  || lpdis->CtlID == IDM_PLAYBAR_SKIPFORE ) {

	    if (lpdis->itemAction & ODA_SELECT ) {

		g_AcceleratorCount = 0;
		CdPlayerSeekCmd( hwnd, (lpdis->itemState & ODS_SELECTED),
				 lpdis->CtlID );
	    }
	}

	/*
	** Now draw the button according to the buttons state information.
	*/

	tbPlaybar[i].fsState = LOBYTE(lpdis->itemState);

	if (lpdis->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)) {

	    BtnDrawButton( hwnd, lpdis->hDC, (int)lpdis->rcItem.right,
			   (int)lpdis->rcItem.bottom,
			   &tbPlaybar[i] );
	}
	else if (lpdis->itemAction & ODA_FOCUS) {

	    BtnDrawFocusRect(lpdis->hDC, &lpdis->rcItem, lpdis->itemState);
	}
	return TRUE;

    case ODT_COMBOBOX:
	if (lpdis->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)) {

	    switch (lpdis->CtlID) {

	    case IDC_ARTIST_NAME:
		DrawDriveItem( lpdis->hDC, &lpdis->rcItem,
			       lpdis->itemData,
			       (ODS_SELECTED & lpdis->itemState) );
		break;

	    case IDC_TRACK_LIST:
		DrawTrackItem( lpdis->hDC, &lpdis->rcItem,
			       lpdis->itemData,
			       (ODS_SELECTED & lpdis->itemState) );
		break;

	    }
	}
	return TRUE;
    }
    return FALSE;
}

void DoHtmlHelp()
{
	//note, using ANSI version of function because UNICODE is foobar in NT5 builds
    char chDst[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, g_HTMLHelpFileName, 
									    -1, chDst, MAX_PATH, NULL, NULL); 
	HtmlHelpA(GetDesktopWindow(), chDst, HH_DISPLAY_TOPIC, 0);
}

void ProcessHelp(HWND hwnd)
{
	static TCHAR HelpFile[] = TEXT("CDPLAYER.HLP");
	
	//Handle context menu help
	if(bF1InMenu) 
	{
		switch(currMenuItem)
		{
		case IDM_DATABASE_EDIT:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_CDPLAYER_CS_CDPLAYER_DISC_EDIT_PLAY_LIST);
		break;
		case IDM_DATABASE_EXIT:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_CDPLAYER_CS_CDPLAYER_DISC_EXIT);
		break;
		case IDM_VIEW_TOOLBAR:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_CDPLAYER_CS_CDPLAYER_VIEW_TOOLBAR);
		break;
		case IDM_VIEW_TRACKINFO:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_CDPLAYER_CS_CDPLAYER_VIEW_DISC_TRACK_INFO);
		break;
		case IDM_VIEW_STATUS:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_CDPLAYER_CS_CDPLAYER_VIEW_STATUS_BAR);
		break;
		case IDM_TIME_REMAINING:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_CDPLAYER_CS_CDPLAYER_VIEW_TRACK_TIME_ELAPSED);
		break;
		case IDM_TRACK_REMAINING:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_CDPLAYER_CS_CDPLAYER_VIEW_REMAINING_TRACK_TIME);
		break;
		case IDM_DISC_REMAINING:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_CDPLAYER_CS_CDPLAYER_VIEW_REMAINING_DISC_TIME);
		break;
		case IDM_VIEW_VOLUME:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_CDPLAYER_CS_CDPLAYER_VIEW_VOLUME_CONTROL);
		break;
		case IDM_OPTIONS_RANDOM:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_CDPLAYER_CS_CDPLAYER_OPTIONS_RANDOM_ORDER);
		break;
		case IDM_OPTIONS_CONTINUOUS:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_CDPLAYER_CS_CDPLAYER_OPTIONS_CONTINUOUS_PLAY);
		break;
		case IDM_OPTIONS_INTRO:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_CDPLAYER_CS_CDPLAYER_OPTIONS_INTRO_PLAY);
		break;
		case IDM_OPTIONS_PREFERENCES:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_CDPLAYER_CS_CDPLAYER_OPTIONS_PREFERENCES);
		break;
		case IDM_HELP_TOPICS:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_CDPLAYER_CS_CDPLAYER_HELP_HELP_TOPICS);
		break;
		case IDM_HELP_ABOUT:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_CDPLAYER_CS_CDPLAYER_HELP_ABOUT);
		break;
		default://In the default case just display the HTML Help.
			DoHtmlHelp();
		}
		bF1InMenu = FALSE; //This flag will be set again if F1 is pressed in a menu.
	}
	else
		DoHtmlHelp();
}


/*****************************Private*Routine******************************\
* CDPlay_OnCommand
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnCommand(
    HWND hwnd,
    int id,
    HWND hwndCtl,
    UINT codeNotify
    )
{

    /*
    ** Comobo box notification ?
    */

    int index, i;
    HWND hwndCtrl;
    PTRACK_PLAY tr;

    switch( id ) {

    case IDC_TRACK_LIST:
	switch (codeNotify) {
	case CBN_SELENDOK:
	    hwndCtrl = g_hwndControls[INDEX(IDC_TRACK_LIST)];
	    index = SendMessage( hwndCtrl, CB_GETCURSEL, 0, 0L );

	    tr = PLAYLIST( g_CurrCdrom );
	    if ( tr != NULL ) {

		PTRACK_PLAY trCurrent = CURRTRACK(g_CurrCdrom);
		for( i = 0; tr && (i < index); i++, tr = tr->nextplay );

		if (tr != trCurrent) {
		    TimeAdjustSkipToTrack( g_CurrCdrom, tr );
		}
	    }
	    break;

	case CBN_CLOSEUP:
	    {
		// Here we have to check that the track currently playing
		// is actually the same track thats selected in the combo box.
		PTRACK_PLAY trCurrent = CURRTRACK(g_CurrCdrom);

		hwndCtrl = g_hwndControls[INDEX(IDC_TRACK_LIST)];
		index = SendMessage( hwndCtrl, CB_GETCURSEL, 0, 0L );
		tr = PLAYLIST( g_CurrCdrom );
		if (tr != NULL && trCurrent != NULL) {

		    for( i = 0; tr && (i < index); i++, tr = tr->nextplay );

		    // If tr and trCurrent don't point to the same thing
		    // then we need to change the combo boxes selection.
		    if ( tr != trCurrent ) {

			for( i = 0, tr = PLAYLIST( g_CurrCdrom );
			     tr && tr != trCurrent; i++, tr = tr->nextplay );

			if ( tr != NULL ) {
			    ComboBox_SetCurSel( hwndCtrl, i);
			}
		    }
		}
		break;
	    }
	}
	break;

    case IDC_ARTIST_NAME:

	if (codeNotify == CBN_SELCHANGE) {
	    i = g_CurrCdrom;
	    hwndCtrl = g_hwndControls[INDEX(IDC_ARTIST_NAME)];
	    index = SendMessage( hwndCtrl, CB_GETCURSEL, 0, 0L );
	    SwitchToCdrom( index, TRUE );
	    SetPlayButtonsEnableState();
	    if ( g_CurrCdrom == i ) {
		SendMessage( hwndCtrl, CB_SETCURSEL, (WPARAM)i, 0 );
	    }
	}
	break;


    case IDM_VIEW_VOLUME:
	{
	    HANDLE  hThread;
	    DWORD   dwThreadId;

	    /*
	    ** We WinExec sndvol on a separate thread because winexec
	    ** is a potentially lengthy call.  If we are playing a cd
	    ** when we try to start sndvol the LED display freezes
	    ** for a short time this looks real ugly.
	    */
	    hThread = CreateThread( NULL, 0L,
				    (LPTHREAD_START_ROUTINE)StartSndVol,
				    NULL, 0L, &dwThreadId );

	    if ( hThread != NULL ) {
		CloseHandle( hThread );
	    }
	}
	break;

    case IDM_VIEW_TOOLBAR:
	ShowToolbar();
	break;

    case IDM_VIEW_STATUS:
	ShowStatusbar();
	break;

    case IDM_VIEW_TRACKINFO:
	ShowTrackInfo();
	break;

    case IDM_OPTIONS_RANDOM:
	if ( LockALLTableOfContents() ) {
	    FlipBetweenShuffleAndOrder();
	    g_fSelectedOrder = !g_fSelectedOrder;
	}
	break;

    //case IDM_OPTIONS_MULTI:
	//g_fSingleDisk = !g_fSingleDisk;
	//break;

    case IDM_OPTIONS_INTRO:
	g_fIntroPlay = !g_fIntroPlay;
	break;

    case IDM_OPTIONS_CONTINUOUS:
	g_fContinuous = !g_fContinuous;
	break;

    case IDM_OPTIONS_PREFERENCES:
	DialogBox( g_hInst, MAKEINTRESOURCE(IDR_PREFERENCES), hwnd, PreferencesDlgProc );
	break;

    case IDM_TIME_REMAINING:
	g_fDisplayT  = TRUE;
	g_fDisplayTr = g_fDisplayDr = FALSE;
	if (codeNotify == 0) {
	    UpdateToolbarTimeButtons();
	}
	UpdateDisplay( DISPLAY_UPD_LED );
	break;

    case IDM_TRACK_REMAINING:
	g_fDisplayTr = TRUE;
	g_fDisplayDr = g_fDisplayT = FALSE;
	if (codeNotify == 0) {
	    UpdateToolbarTimeButtons();
	}
	UpdateDisplay( DISPLAY_UPD_LED );
	break;

    case IDM_DISC_REMAINING:
	g_fDisplayDr = TRUE;
	g_fDisplayTr = g_fDisplayT = FALSE;
	if (codeNotify == 0) {
	    UpdateToolbarTimeButtons();
	}
	UpdateDisplay( DISPLAY_UPD_LED );
	break;

    case IDM_PLAYBAR_EJECT:
	CdPlayerEjectCmd();
	break;

    case IDM_PLAYBAR_PLAY:
	/*
	** If we currently in PLAY mode and the command came from
	** a keyboard accelerator then assume that the user really
	** means Pause.  This is because the Ctrl-P key sequence
	** is a toggle between Play and Paused.  codeNotify is 1 when
	** the WM_COMMAND message came from an accelerator and 0 when
	** it cam from a menu.
	*/
	if ((g_State & CD_PLAYING) && (codeNotify == 1)) {
	    CdPlayerPauseCmd();
	}
	else {
	    CdPlayerPlayCmd();
	}
	break;

    case IDM_PLAYBAR_PAUSE:
	CdPlayerPauseCmd();
	break;

    case IDM_PLAYBAR_STOP:
	CdPlayerStopCmd();
	break;

    case IDM_PLAYBAR_PREVTRACK:
	CdPlayerPrevTrackCmd();
	break;

    case IDM_PLAYBAR_NEXTTRACK:
	CdPlayerNextTrackCmd();
	break;

    case IDM_DATABASE_EXIT:
	PostMessage( hwnd, WM_CLOSE, 0, 0L );
	break;

    case IDM_DATABASE_EDIT:
	CdDiskInfoDlg();
	break;

    case IDM_HELP_TOPICS:
		ProcessHelp(hwnd);
	break;

    case IDM_HELP_ABOUT:
	ShellAbout( hwnd, IdStr(STR_CDPLAYER), g_szEmpty, hIconCdPlayer );
	break;
    }
    UpdateToolbarButtons();
}


/******************************Public*Routine******************************\
* CDPlay_OnDestroy
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnDestroy(
    HWND hwnd
    )
{
    int     i;

    for ( i = 0; i < g_NumCdDevices; i++ ) {

	if (g_fStopCDOnExit) {

	    if ( g_Devices[i]->State & CD_PLAYING
	      || g_Devices[i]->State & CD_PAUSED ) {

		  StopTheCdromDrive( i );
	    }
	}

#ifdef USE_IOCTLS
	if ( g_Devices[i]->hCd != NULL ) {
	    CloseHandle( g_Devices[i]->hCd );
	}
#else
	if ( g_Devices[i]->hCd != 0L ) {

	    CloseCdRom( g_Devices[i]->hCd );
	    g_Devices[i]->hCd = 0L;
	}
#endif

	LocalFree( (HLOCAL) g_Devices[i] );

    }

    if (g_hBrushBkgd) {
	DeleteObject( g_hBrushBkgd );
    }

    if ( g_hDlgFont ) {
	DeleteObject( g_hDlgFont );
    }

    WinHelp( hwnd, g_HelpFileName, HELP_QUIT, 0 );

    PostQuitMessage( 0 );
}


/******************************Public*Routine******************************\
* CDPlay_OnClose
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL
CDPlay_OnClose(
    HWND hwnd,
    BOOL fShuttingDown
    )
{
    /*
    ** If we are playing or paused and the "don't stop playing
    ** on exit" flag set, then we need to tell the user that he is about
    ** to go into stupid mode.  Basically CD Player can only perform as expected
    ** if the user has not mucked about with the play list, hasn't put the
    ** app into random mode or intro play mode or continuous play mode or
    ** multi-disc mode.
    */
    if ( !fShuttingDown && !g_fStopCDOnExit
      && (g_State & (CD_PLAYING | CD_PAUSED) ) ) {

	if ( !g_fSelectedOrder || g_fIntroPlay || g_fContinuous
	  || !g_fSingleDisk || !PlayListMatchesAvailList() ) {

	    TCHAR   s1[256];
	    TCHAR   s2[256];
	    int     iMsgBoxRtn;

	    _tcscpy( s1, IdStr( STR_EXIT_MESSAGE ) );
	    _tcscpy( s2, IdStr( STR_CDPLAYER ) );

	    iMsgBoxRtn = MessageBox( g_hwndApp, s1, s2,
				     MB_APPLMODAL | MB_DEFBUTTON1 |
				     MB_ICONQUESTION | MB_YESNO);

	    if ( iMsgBoxRtn == IDNO ) {
		return TRUE;
	    }

	}
    }

    WriteSettings();

    return DestroyWindow( hwnd );
}


/*****************************Private*Routine******************************\
* CDPlay_OnEndSession
*
* If the session is really ending make sure that we stop the CD Player
* from playing and that all the ini file stuff is saved away.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnEndSession(
    HWND hwnd,
    BOOL fEnding
    )
{
    if ( fEnding ) {
	CDPlay_OnClose( hwnd, fEnding );
    }
}


/******************************Public*Routine******************************\
* CDPlay_OnSize
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnSize(
    HWND hwnd,
    UINT state,
    int cx,
    int cy
    )
{
    if (g_fIsIconic && (state != SIZE_MINIMIZED)) {
	SetWindowText( hwnd, IdStr( STR_CDPLAYER ) );
    }
    g_fIsIconic = (state == SIZE_MINIMIZED);

    if (IsWindow(g_hwndStatusbar)) {
	SendMessage( g_hwndStatusbar, WM_SIZE, 0, 0L );
    }

    if (IsWindow(g_hwndToolbar)) {
	SendMessage( g_hwndToolbar, WM_SIZE, 0, 0L );
    }
}

/*****************************Private*Routine******************************\
* CDPlay_OnNotify
*
* Time to display the little tool tips.  Also, change the status bar
* so that it displays a longer version of the tool tip text.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT
CDPlay_OnNotify(
    HWND hwnd,
    int idFrom,
    NMHDR *pnmhdr
    )
{
    switch (pnmhdr->code) {

    case TTN_NEEDTEXT:
	{
	    LPTOOLTIPTEXT   lpTt;
	    LPTSTR          lpstr;
	    UINT            msgId;

	    lpTt = (LPTOOLTIPTEXT)pnmhdr;

	    msgId = lpTt->hdr.idFrom;

	    /*
	    ** If we are paused, the pause button will cause the device
	    ** to play.  So we change the ToolTip text to show "Play"
	    ** when the cursor is over "Pause".  We should not need to
	    ** check that a music CD is loaded because the CD_PAUSED
	    ** state can only be set after Play starts.
	    */

	    if ( (g_State & CD_PAUSED)
	      && (msgId == IDM_PLAYBAR_PAUSE || msgId == IDM_PLAYBAR_PLAY)) {
		msgId = IDM_PLAYBAR_RESUME;
	    }
	    LoadString( g_hInst, msgId, lpTt->szText, sizeof(lpTt->szText) );

	    lpstr = IdStr(lpTt->hdr.idFrom + MENU_STRING_BASE);
	    if (*lpstr) {
		SendMessage( g_hwndStatusbar, SB_SETTEXT, SBT_NOBORDERS|255,
			     (LPARAM)lpstr );
		SendMessage(g_hwndStatusbar, SB_SIMPLE, 1, 0L);
		UpdateWindow(g_hwndStatusbar);
	    }
	}
	break;
    }

    return TRUE;
}

/*****************************Private*Routine******************************\
* CDPlay_OnNCHitTest
*
* Here we pretend that the client area is really the caption if we are in
* mini-mode.  This allows the user to move the player to a new position.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
UINT
CDPlay_OnNCHitTest(
    HWND hwnd,
    int x,
    int y
    )
{
    UINT ht = FORWARD_WM_NCHITTEST(hwnd, x, y, DefWindowProc );

    if (!g_fTitlebarShowing && (ht == HTCLIENT) ) {
	ht = HTCAPTION;
    }
    SetWindowLong(hwnd, DWL_MSGRESULT, ht);

    return ht;
}


/*****************************Private*Routine******************************\
* CDPlay_OnLButtonDown
*
* This function processes the WM_LBUTTONDBLCLK and WM_NCLBUTTONDBLCLK
* messages.  Here we determine if it is possible for CD Player to go
* into mini-mode or whether CD Player should be restored from min-mode.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnLButtonDown(
    HWND hwnd,
    BOOL fDoubleClick,
    int x,
    int y,
    UINT keyFlags
    )
{
    static UINT uID;
    const DWORD dwTransientStyle = (WS_BORDER | WS_SYSMENU | WS_MINIMIZEBOX);
    DWORD       dwStyle;
    RECT        rc;
    int         xpos, ypos, dx, dy;

    if (!(g_fToolbarVisible || g_fStatusbarVisible || g_fTrackInfoVisible)) {

	dwStyle = GetWindowLong( hwnd, GWL_STYLE );
	GetWindowRect( hwnd, &rc );

	xpos = rc.left;
	dx = rc.right - rc.left;

	if (g_fTitlebarShowing) {

	    dwStyle &= ~dwTransientStyle;
	    uID = SetWindowLong( hwnd, GWL_ID, 0 );
	    ypos = rc.top + cyMenuCaption;
	    dy = (rc.bottom - rc.top) - cyMenuCaption;
	}
	else {

	    dwStyle |= dwTransientStyle;
	    SetWindowLong( hwnd, GWL_ID, uID );
	    ypos = rc.top - cyMenuCaption;
	    dy = (rc.bottom - rc.top) + cyMenuCaption;
	}

	if (g_fTitlebarShowing) {

	    DWORD dwExStyle;

	    dwExStyle = GetWindowLong( hwnd, GWL_EXSTYLE );
	    dwExStyle |= WS_EX_WINDOWEDGE;
	    SetWindowLong( hwnd, GWL_STYLE, dwStyle );
	    SetWindowLong( hwnd, GWL_EXSTYLE, dwExStyle );
	}
	else {
	    SetWindowLong( hwnd, GWL_STYLE, dwStyle );
	}
	g_fTitlebarShowing = !g_fTitlebarShowing;
	SetWindowPos( hwnd, NULL, xpos, ypos, dx, dy,
		      SWP_NOACTIVATE | SWP_NOZORDER | SWP_FRAMECHANGED );
    }
}


BOOL
CDPlay_CopyData(
    HWND hwnd,
    PCOPYDATASTRUCT lpcpds
    )
{
    LPTSTR lpCmdLine;

    // Make a copy of the passed command line as we are not supposed
    // to write into the one passed in the WM_COPYDATA message.
    lpCmdLine = AllocMemory( lpcpds->cbData );
    _tcscpy( lpCmdLine, (LPCTSTR)lpcpds->lpData );

    PostMessage (hwnd, WM_CDPLAYER_COPYDATA, 0, (LPARAM)(LPVOID)lpCmdLine);
    return TRUE;
} // End CopyData


  
/*****************************Private*Routine******************************\
* CDPlay_OnCopyData
*
* Handles command lines passed from other intances of CD Player
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
CDPlay_OnCopyData(
    HWND hwnd,
    PCOPYDATASTRUCT lpcpds
    )
{
    LPTSTR lpCmdLine;
    BOOL fWasPlaying = FALSE;
    BOOL fUpdate;
    int iTrack = -1;
    int iCdRom;

    // Prevent Re-entrancy while
    // we are opening/closing CD's
    if (g_fInCopyData)
	return FALSE;
    g_fInCopyData = TRUE;

    /*
    ** Make a copy of the passed command line as we are not supposed
    ** to write into the one passed in the WM_COPYDATA message.
    */
    //lpCmdLine = AllocMemory( lpcpds->cbData );
    //_tcscpy( lpCmdLine, (LPCTSTR)lpcpds->lpData );

    lpCmdLine = (LPTSTR)(LPVOID)lpcpds;
    if (lpCmdLine == NULL)
    {
	g_fInCopyData = FALSE;
	return 0L;
    }


    iCdRom = ParseCommandLine( lpCmdLine, &iTrack, FALSE );
    if (iCdRom < 0 && iTrack < 0) {
	LocalFree( (HLOCAL)lpCmdLine );
	g_fInCopyData = FALSE;
	    return 0L;
    }

    // Check if it is just an update command?!?
    fUpdate = IsUpdateOptionGiven (lpCmdLine);
    if ((fUpdate) && (iTrack == -1))
    {
	if ((iCdRom >= 0) && (iCdRom < g_NumCdDevices))
	{
		CheckUnitCdrom(iCdRom, TRUE);
	}

	LocalFree( (HLOCAL)lpCmdLine );
	g_fInCopyData = FALSE;
	    return 0L;
    }

    /*
    ** Remember our current playing state as we need to temporarly
    ** stop the CD if it is currently playing.
    */
    if ( g_State & (CD_PLAYING | CD_PAUSED) ) 
    {

#ifdef DBG
	dprintf("Auto Stopping");
#endif

	    while( !LockALLTableOfContents() ) 
	{

		MSG msg;

#if DBG
		dprintf("Busy waiting for TOC to become valid!");
#endif

		GetMessage( &msg, NULL, WM_NOTIFY_TOC_READ, WM_NOTIFY_TOC_READ );
		DispatchMessage( &msg );
	    }

	    CdPlayerStopCmd();
	    fWasPlaying = TRUE;
    }


    /*
    ** Figure what has been passed and act on it accordingly.
    */
    HandlePassedCommandLine( lpCmdLine, TRUE );


    /*
    ** If we were playing make sure that we are still playing the
    ** new track(s)
    */
    if ( fWasPlaying || g_fPlay ) 
    {

#ifdef DBG
	    dprintf("Trying to autoplay");
#endif

	    while( !LockTableOfContents(g_CurrCdrom) ) 
	{

		MSG     msg;

#ifdef DBG
	    dprintf("Busy waiting for TOC to become valid!");
#endif

		GetMessage( &msg, NULL, WM_NOTIFY_TOC_READ, WM_NOTIFY_TOC_READ );
		DispatchMessage( &msg );
	    }

	    CdPlayerPlayCmd();
    }

    /*
    ** Free the local copy of the command line.
    */
    LocalFree( (HLOCAL)lpCmdLine );

    g_fInCopyData = FALSE;
    return 0L;
}


/*****************************Private*Routine******************************\
* CDPlay_OnTocRead
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
CDPlay_OnTocRead(
    int iDriveRead
    )
{
    static int iNumRead = 0;

    //  This serializes processing between this
    //  function and the various Table of Content Threads
    //  Preventing resource contention on CDROM Multi-Changers.
    EnterCriticalSection (&g_csTOCSerialize);

    /*
    ** Have we finished the initial read of the CD-Rom TOCs ?
    ** If so we have to re-open the device.  We only need to do this
    ** on Daytona because MCI device handles are not shared between threads.
    */
    iNumRead++;

#ifndef USE_IOCTLS
#ifdef DAYTONA
    if (iNumRead <= g_NumCdDevices) {

	/*
	** Now, open the cdrom device on the UI thread.
	*/
	g_Devices[iDriveRead]->hCd =
	    OpenCdRom( g_Devices[iDriveRead]->drive, NULL );
    }
#endif
#endif


    /*
    ** This means that one of the threads dedicated to reading the
    ** toc has finished.  iDriveRead contains the relevant cdrom id.
    */
    LockALLTableOfContents();
    if ( g_Devices[iDriveRead]->State & CD_LOADED ) {

	/*
	** We have a CD loaded, so generate unique ID
	** based on TOC information.
	*/
	g_Devices[iDriveRead]->CdInfo.Id = ComputeNewDiscId( iDriveRead );


	/*
	** Check database for this compact disc
	*/
	AddFindEntry( iDriveRead, g_Devices[iDriveRead]->CdInfo.Id,
		      &(g_Devices[iDriveRead]->toc) );
    }


    /*
    ** If we have completed the initialization of the Cd-Rom drives we can
    ** now complete the startup processing of the application.
    */
    if (iNumRead == g_NumCdDevices) {

	CompleteCdPlayerStartUp();
    }
    else {

	/*
	** if we are in random mode, then we need to shuffle the play lists.
	** but only if we can lock all the cd devices.
	*/

	TimeAdjustInitialize( iDriveRead );

	if ( g_fSelectedOrder == FALSE ) {
	    if ( LockALLTableOfContents() ) {
		ComputeAndUseShufflePlayLists();
	    }
	}

	ComputeDriveComboBox();

	if (iDriveRead == g_CurrCdrom) {

	    SetPlayButtonsEnableState();
	}
    }

    LeaveCriticalSection (&g_csTOCSerialize);

    return TRUE;
}


/*****************************Private*Routine******************************\
* SubClassedToolTips
*
* If the tooltips window is being hidden we need to reset the status bar
* to its normal display.  In all instance we pass the message on the
* the tooltip window proc for processing.  This is all done by use of a timer.
* If the timer fires it means that the tooltips have been invisible for
* a reasonable length of time.  We always kill the timer when the tooltips
* are about to be displayed, this means that if the user is displaying the
* tips quickly we won't see the annoying flicker.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
SubClassedToolTips(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if ( (uMsg == WM_SHOWWINDOW) && ((BOOL)wParam == FALSE) ) {

	SetTimer( g_hwndApp, TOOLTIPS_TIMER_ID, TOOLTIPS_TIMER_LEN,
		  ToolTipsTimerFunc );
    }
    else if ( uMsg == WM_MOVE ) {

	KillTimer( g_hwndApp, TOOLTIPS_TIMER_ID );
    }
    return CallWindowProc(g_lpfnToolTips, hwnd, uMsg, wParam, lParam);
}


/*****************************Private*Routine******************************\
* ToolTipsTimerFunc
*
* If this timer fires it means its time to remove the tooltips text on
* the status bar.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void CALLBACK
ToolTipsTimerFunc(
    HWND hwnd,
    UINT uMsg,
    UINT idEvent,
    DWORD dwTime
    )
{

    KillTimer( g_hwndApp, TOOLTIPS_TIMER_ID );
    SendMessage(g_hwndStatusbar, SB_SIMPLE, 0, 0L);
}


/*****************************Private*Routine******************************\
* CDPlay_OnMenuSelect
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnMenuSelect(
    HWND hwnd,
    HMENU hmenu,
    int item,
    HMENU hmenuPopup,
    UINT flags
    )
{

    TCHAR szString[STR_MAX_STRING_LEN + 1];

	//Keep track of which menu bar item is currently popped up.
	//This will be used for displaying the appropriate help from the mplayer.hlp file
	//when the user presses the F1 key.
	currMenuItem = item;

	//The menu help being processed below is for the toolbar. It uses the string table
	//to display the menu help. F1 help uses the help file for the app.

    /*
    ** Is it time to end the menu help ?
    */

    if ( (flags == 0xFFFFFFFF) && (hmenu == NULL) ) {

	SendMessage(g_hwndStatusbar, SB_SIMPLE, 0, 0L);
    }

    /*
    ** Do we have a separator, popup or the system menu ?
    */
    else if ( flags & MF_POPUP ) {

	SendMessage(g_hwndStatusbar, SB_SIMPLE, 0, 0L);
    }

    else if (flags & MF_SYSMENU) {

	if (flags & MF_SEPARATOR) {

	    szString[0] = g_chNULL;
	}
	else {

	    int id = -1;

	    switch (item) {

	    case SC_RESTORE:
		id = STR_SYSMENU_RESTORE;
		break;

	    case SC_MOVE:
		id = STR_SYSMENU_MOVE;
		break;

	    case SC_SIZE:
		id = STR_SYSMENU_SIZE;
		break;

	    case SC_MINIMIZE:
		id = STR_SYSMENU_MINIMIZE;
		break;

	    case SC_MAXIMIZE:
		id = STR_SYSMENU_MAXIMIZE;
		break;

	    case SC_CLOSE:
		id = STR_SYSMENU_CLOSE;
		break;
#ifdef DAYTONA
	    case SC_TASKLIST:
		id = STR_SYSMENU_SWITCH;
		break;
#endif
	    }
	    _tcscpy( szString, IdStr(id) );
	}

	SendMessage( g_hwndStatusbar, SB_SETTEXT, SBT_NOBORDERS|255,
		     (LPARAM)(LPTSTR)szString );
	SendMessage( g_hwndStatusbar, SB_SIMPLE, 1, 0L );
	UpdateWindow(g_hwndStatusbar);

    }

    /*
    ** Hopefully its one of ours
    */
    else {

	if (flags & MF_SEPARATOR) {

	    szString[0] = g_chNULL;
	}
	else {

	    _tcscpy( szString, IdStr(item + MENU_STRING_BASE) );

	}

	SendMessage( g_hwndStatusbar, SB_SETTEXT, SBT_NOBORDERS|255,
		     (LPARAM)(LPTSTR)szString );
	SendMessage( g_hwndStatusbar, SB_SIMPLE, 1, 0L );
	UpdateWindow(g_hwndStatusbar);
    }
}



/*****************************Private*Routine******************************\
* CDPlay_OnDeviceChange
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/

BOOL
CDPlay_OnDeviceChange(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam)
{
    UINT  uiEvent = (UINT)wParam;
    DWORD dwData  = (DWORD)lParam;

    switch (uiEvent)
    {
    case DBT_DEVICEARRIVAL:             // Insertion
    case DBT_DEVICEREMOVECOMPLETE:      // Ejection
	if ((PDEV_BROADCAST_HDR)dwData)
	{
	    switch (((PDEV_BROADCAST_HDR)dwData)->dbch_devicetype)
	    {
	    case DBT_DEVTYP_VOLUME:
		{
		TCHAR chDrive[4] = TEXT("A:\\");
		INT   i,j,drive;
		DWORD dwCurr;
		PDEV_BROADCAST_VOLUME pdbv;
		DWORD dwMask, dwDrives;

		pdbv = (PDEV_BROADCAST_VOLUME)dwData;
		dwMask = pdbv->dbcv_unitmask;
		dwDrives = GetLogicalDrives();
		dwMask &= dwDrives;

		if (dwMask)
		{
			// Check all drives for match
		    for (i = 0; i < 32; i++)
		    {
			dwCurr = 1 << i;
			if (dwCurr & dwMask)
			{
				// Check drive
			    chDrive[0] = TEXT('A') + i;
			    if ( GetDriveType(chDrive) == DRIVE_CDROM ) 
			    {
				    // Find Associated Drive structure
				drive = -1;
				for (j = 0; j < g_NumCdDevices; j++)
				{
				    if (g_Devices[j]->drive == chDrive[0])
					drive = j;
				}
				    // Structure not found, make one
				if (drive == -1)
				{
			    #ifdef DBG
				    dprintf ("CDPlay_OnDeviceChange - didn't find drive");
			    #endif
				    if (g_NumCdDevices > MAX_CD_DEVICES)
				    {
					// Error - not enough device slots
					break;
				    }
				    
				    g_Devices[g_NumCdDevices] = AllocMemory( sizeof(CDROM) );
				    if (NULL == g_Devices[g_NumCdDevices])
				    {
					// Error - unable to get enough memory
					break;
				    }
				    g_Devices[g_NumCdDevices]->drive = chDrive[0];
				    drive = g_NumCdDevices;
				    g_NumCdDevices++;
				}

				    // Insert/Eject new drive
				if (uiEvent == DBT_DEVICEARRIVAL) {
				    // Drive has been inserted

				    // Do nothing for an inserted CD-ROM
				    // The Shell should inform us using 
				    // the AUTOPLAY through WM_COPYDDATA
				}
				else {
				    // Drive has been ejected
				    NoMediaUpdate (drive);
				}
			    }
		   
			}
		    }
		}
		break;
		}

	    default:
		// Not a logical volume message
		break;
	    }
	}
	break;
    
    case DBT_DEVICEQUERYREMOVE:         // Permission to remove a device is requested.
    case DBT_DEVICEQUERYREMOVEFAILED:   // Request to remove a device has been canceled.
    case DBT_DEVICEREMOVEPENDING:       // Device is about to be removed. Can not be denied.
    case DBT_DEVICETYPESPECIFIC:        // Device-specific event.
    case DBT_CONFIGCHANGED:             // Current configuration has changed.
    default:
	break;
    }

    return TRUE;
} // End CDPlay_OnDeviceChange


  
/*****************************Private*Routine******************************\
* CDPlay_OnDropFiles
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
CDPlay_OnDropFiles(
    HWND hwnd,
    HDROP hdrop
    )
{
    int     cFiles;
    int     cGoodFiles;
    int     iTextLen;
    int     i;
    TCHAR   szFileName[MAX_PATH+3];
    LPTSTR  lpCommandLine;
    BOOL    fWasPlaying = FALSE;

    // Prevent Re-entrancy while we are 
    // Opening and closing CD's
    if (g_fInCopyData)
	return;
    g_fInCopyData = TRUE;


    /*
    ** Determine how many files were passed to us.
    */
    cFiles = DragQueryFile( hdrop, (UINT)-1, (LPTSTR)NULL, 0 );

    /*
    ** Calculate the length of the command line each filename should be
    ** separated by a space character
    */
    iTextLen  = _tcslen( g_szCdplayer );
    iTextLen += _tcslen( g_szPlayOption );
    iTextLen += _tcslen( g_szTrackOption );
    for ( cGoodFiles = cFiles, i = 0; i < cFiles; i++ ) {

	int unused1, unused2;

	DragQueryFile( hdrop, i, szFileName, MAX_PATH );


	if (IsTrackFileNameValid( szFileName, &unused1,
				  &unused2, TRUE, FALSE )) {

	    // Add on 3 extra characters - one for the space and
	    // two for quote marks, we do this because the filename
	    // given may contain space characters.
	    iTextLen += _tcslen( szFileName ) + 2 + 1;
	}
	else {
	    cGoodFiles--;
	}
    }

    /*
    ** If the none of the dropped files are valid tracks just return
    */
    if (cGoodFiles < 1) {
	g_fInCopyData = FALSE;
	    return;
    }


    /*
    ** Allocate a chunk of memory big enough for all the options and
    ** filenames.  Don't forget the NULL.
    */
    lpCommandLine = AllocMemory(sizeof(TCHAR) * (iTextLen + 1));


    /*
    ** Add a dummy intial command line arg.  This is because the
    ** first arg is always the name of the invoked application.  We ignore
    ** this paramter.  Also if we are currently playing we need to
    ** add the -play option to command line as well as stop the CD.
    */
    _tcscpy( lpCommandLine, g_szCdplayer );
    if ( g_State & (CD_PLAYING | CD_PAUSED) ) {

	CdPlayerStopCmd();
	fWasPlaying = TRUE;

	_tcscat( lpCommandLine, g_szPlayOption );
    }


    /*
    ** If there is more than one file name specified then we should constuct
    ** a new playlist from the given files.
    */
    if ( cGoodFiles > 1) {
	_tcscat( lpCommandLine, g_szTrackOption );
    }


    /*
    ** Build up the command line.
    */
    for ( i = 0; i < cFiles; i++ ) {

	int unused1, unused2;

	DragQueryFile( hdrop, i, szFileName, MAX_PATH );

	if (IsTrackFileNameValid( szFileName, &unused1,
				  &unused2, TRUE, TRUE )) {

	    _tcscat( lpCommandLine, TEXT("\'") );
	    _tcscat( lpCommandLine, szFileName );
	    _tcscat( lpCommandLine, TEXT("\'") );
	    _tcscat( lpCommandLine, g_szBlank );
	}
    }

    /*
    ** now process the newly constructed command line.
    */
    HandlePassedCommandLine( lpCommandLine, FALSE );

    /*
    ** If we were playing make sure that we are still playing the
    ** new track(s)
    */
    if ( fWasPlaying ) {

	CdPlayerPlayCmd();
    }

    LocalFree( lpCommandLine );
    DragFinish( hdrop );

    g_fInCopyData = FALSE;
}


/*****************************Private*Routine******************************\
* ResolveLink
*
* Takes the shortcut (shell link) file pointed to be szFileName and
* resolves the link returning the linked file name in szFileName.
*
* szFileName must point to at least MAX_PATH amount of TCHARS.  The function
* return TRUE if the link was successfully resolved and FALSE otherwise.
*
* History:
* dd-mm-94 - StephenE - Created
* 03-11-95 - ShawnB - Unicode enabled
*
\**************************************************************************/
BOOL
ResolveLink(
    TCHAR *szFileName
    )
{
#ifndef UNICODE
	char  cszPath[MAX_PATH];
    WCHAR wszPath[MAX_PATH];

	MultiByteToWideChar(CP_ACP, 0, szFileName, -1, wszPath, MAX_PATH);
	lstrcpy (cszPath, szFileName);
#endif // End !UNICODE

	IShellLink * psl = NULL;
    HRESULT hres;
    int iCountTries;
    const int MAX_TRIES = 3;

    if (!g_fOleInitialized) {
	return FALSE;
    }

    //
    // Sometimes on Chicago I keep getting an error code from
    // CoCreateInstance that implies that the server is busy,
    // so I'll give it a chance to get its act together.
    //
    for ( iCountTries = 0; iCountTries < MAX_TRIES; iCountTries++ ) {

	hres = CoCreateInstance(&CLSID_ShellLink, NULL, CLSCTX_INPROC,
				&IID_IShellLink, (LPVOID *)&psl);
	if ( SUCCEEDED(hres) ) {
	    break;
	}
	Sleep(100);
    }

    //
    // Make sure we that have the interface before proceeding
    //
    if (SUCCEEDED(hres) && psl != NULL) {

	IPersistFile *ppf;

	psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, (LPVOID *)&ppf);

	if ( NULL != ppf ) {

#ifdef UNICODE
	    hres = ppf->lpVtbl->Load(ppf, szFileName, 0);
#else
	    hres = ppf->lpVtbl->Load(ppf, wszPath, 0);
#endif
	    ppf->lpVtbl->Release(ppf);

	    if ( FAILED(hres) ) {
		psl->lpVtbl->Release(psl);
		psl = NULL;
		return FALSE;
	    }
	}
	else {
	    psl->lpVtbl->Release(psl);
	    psl = NULL;
	    return FALSE;
	}
    }

    if ( NULL != psl ) {
	psl->lpVtbl->Resolve(psl, NULL, SLR_NO_UI);
#ifdef UNICODE
	hres = psl->lpVtbl->GetPath(psl, szFileName, MAX_PATH, NULL, 0);
#else
	hres = psl->lpVtbl->GetPath(psl, cszPath, MAX_PATH, NULL, 0);
#endif
	psl->lpVtbl->Release(psl);

#ifndef UNICODE
		if (SUCCEEDED(hres))
		{
			lstrcpy (szFileName, cszPath);
		}
#endif

	return SUCCEEDED(hres);
    }

    return FALSE;
}
//#endif

/*****************************Private*Routine******************************\
* ShowStatusbar
*
* If the status bar is not visible:
*   Expand the client window, position the status bar and make it visible.
* else
*   Hide the status bar, and then contract the client window.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ShowStatusbar(
    void
    )
{
    RECT    rcApp;

    GetWindowRect( g_hwndApp, &rcApp );

    if (g_fStatusbarVisible) {

	ShowWindow( g_hwndStatusbar, SW_HIDE );

	rcApp.bottom -= rcStatusbar.bottom;
	SetWindowPos( g_hwndApp, HWND_TOP,
		      0, 0,
		      (int)(rcApp.right - rcApp.left),
		      (int)(rcApp.bottom - rcApp.top),
		      SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER );

    }
    else {

	rcApp.bottom += rcStatusbar.bottom;
	SetWindowPos( g_hwndApp, HWND_TOP,
		      0, 0,
		      (int)(rcApp.right - rcApp.left),
		      (int)(rcApp.bottom - rcApp.top),
		      SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER  );

	ShowWindow( g_hwndStatusbar, SW_SHOW );
    }

    g_fStatusbarVisible = !g_fStatusbarVisible;
}


/*****************************Private*Routine******************************\
* ShowToolbar
*
* If the tool bar is not visible:
*   Grow the client window, position the child controls and show toolbar
* else
*   Hide the tool bar, position controls and contract client window.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ShowToolbar(
    void
    )
{
    RECT    rcApp;
    HDWP    hdwp;
    LONG    lIncrement;
    int     i;

    GetWindowRect( g_hwndApp, &rcApp );

    if (g_fToolbarVisible) {

	lIncrement = -rcToolbar.bottom;
	ShowWindow( g_hwndToolbar, SW_HIDE );
    }
    else {

	lIncrement = rcToolbar.bottom;
    }


    /*
    ** First resize the application.
    */
    rcApp.bottom += lIncrement;
    SetWindowPos( g_hwndApp, HWND_TOP,
		  0, 0,
		  (int)(rcApp.right - rcApp.left),
		  (int)(rcApp.bottom - rcApp.top),
		  SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER );


    /*
    ** Now move the buttons and the track info stuff.
    */
    hdwp = BeginDeferWindowPos( 20 );
    for ( i = 0; i < NUM_OF_CONTROLS; i++ ) {

	rcControls[i].top += lIncrement;
	hdwp = DeferWindowPos( hdwp,
			       g_hwndControls[i],
			       HWND_TOP,
			       (int)rcControls[i].left,
			       (int)rcControls[i].top,
			       0, 0,
			       SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER );

    }

    ASSERT(hdwp != NULL);
    EndDeferWindowPos( hdwp );

    if (!g_fToolbarVisible) {
	ShowWindow( g_hwndToolbar, SW_SHOW );
    }

    g_fToolbarVisible = !g_fToolbarVisible;
}


/*****************************Private*Routine******************************\
* ShowTrackInfo
*
* If the track info is not visible:
*   Expand the client window, position the track info and make it visible.
* else
*   Hide the track info, and then contract the client window.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ShowTrackInfo(
    void
    )
{
    RECT    rcApp;
    int     i;

    GetWindowRect( g_hwndApp, &rcApp );

    if (g_fTrackInfoVisible) {

	for ( i = IDC_TRACKINFO_FIRST - IDC_CDPLAYER_FIRST;
	      i < NUM_OF_CONTROLS; i++ ) {

	    ShowWindow( g_hwndControls[i], SW_HIDE );
	}

	rcApp.bottom -= cyTrackInfo;
	SetWindowPos( g_hwndApp, HWND_TOP,
		      0, 0,
		      (int)(rcApp.right - rcApp.left),
		      (int)(rcApp.bottom - rcApp.top),
		      SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER );

    }
    else {

	rcApp.bottom += cyTrackInfo;

	SetWindowPos( g_hwndApp, HWND_TOP,
		      0, 0,
		      (int)(rcApp.right - rcApp.left),
		      (int)(rcApp.bottom - rcApp.top),
		      SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER );

	for ( i = IDC_TRACKINFO_FIRST - IDC_CDPLAYER_FIRST;
	      i < NUM_OF_CONTROLS; i++ ) {

	    ShowWindow( g_hwndControls[i], SW_SHOW );
	}

    }

    g_fTrackInfoVisible = !g_fTrackInfoVisible;
}


/******************************Public*Routine******************************\
* ChildEnumProc
*
* Gets the position of each child control window.  As saves the associated
* window handle for later use.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL CALLBACK
ChildEnumProc(
    HWND hwndChild,
    LPARAM hwndParent
    )
{
    int index;

    index = INDEX(GetDlgCtrlID( hwndChild ));

    GetWindowRect( hwndChild, &rcControls[index] );
    MapWindowPoints( NULL, (HWND)hwndParent, (LPPOINT)&rcControls[index], 2 );
    g_hwndControls[index] = hwndChild;

    return TRUE;
}


/*****************************Private*Routine******************************\
* CreateToolbarAndStatusbar
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
CreateToolbarsAndStatusbar(
    HWND hwnd
    )
{
    HDC             hdc;
    int             RightOfPane[2];
    RECT            rcApp;
    HWND            hwndToolbarTips;

    GetClientRect( hwnd, &rcApp );
    cyTrackInfo = (rcApp.bottom - rcApp.top)
		   - rcControls[IDC_TRACKINFO_FIRST - IDC_CDPLAYER_FIRST].top;

    g_hwndToolbar = CreateToolbarEx( hwnd,
				     WS_CHILD | TBSTYLE_TOOLTIPS,
				     ID_TOOLBAR, NUMBER_OF_BITMAPS,
				     g_hInst, IDR_TOOLBAR, tbButtons,
				     DEFAULT_TBAR_SIZE, dxBitmap, dyBitmap,
				     dxBitmap, dyBitmap, sizeof(TBBUTTON) );
    if ( g_hwndToolbar == NULL ) {
	return FALSE;
    }

    /*
    ** Calculate the size of the toolbar.  The WM_SIZE message forces the
    ** toolbar to recalculate its size and thus return the correct value to
    ** us.
    */
    SendMessage( g_hwndToolbar, WM_SIZE, 0, 0L );
    GetClientRect( g_hwndToolbar, &rcToolbar );

    hwndToolbarTips = (HWND)SendMessage( g_hwndToolbar, TB_GETTOOLTIPS, 0, 0L );
    if (hwndToolbarTips) {
	g_lpfnToolTips = SubclassWindow( hwndToolbarTips, SubClassedToolTips );
    }

    g_hwndStatusbar = CreateStatusWindow( WS_CHILD | WS_BORDER,
					  g_szEmpty, hwnd, ID_STATUSBAR );

    if ( g_hwndStatusbar == NULL ) {
	return FALSE;
    }


    /*
    ** Partition the status bar window into two.  The first partion is
    ** 1.5 inches long.  The other partition fills the remainder of
    ** the bar.
    */

    hdc = GetWindowDC( hwnd );

    RightOfPane[0] = (rcApp.right-rcApp.left) / 2;

    RightOfPane[1] = -1;
    ReleaseDC( hwnd, hdc );
    SendMessage( g_hwndStatusbar, SB_SETPARTS, 2, (LPARAM)RightOfPane );
    GetClientRect( g_hwndStatusbar, &rcStatusbar );

    return TRUE;
}


/*****************************Private*Routine******************************\
* AdjustChildButtons
*
* The child buttons should be aligned with the right hand edge of the
* track info controls.  They should be be positioned so that vertically they
* are in the centre of the space between the track info controls and
* the top of the dialog box.
*
* The buttons are positioned such that the left hand edge of a button is
* flush with the right hand edge of the next button.  The play button is
* 3 times the width of the other buttons.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
AdjustChildButtons(
    HWND hwnd
    )
{
    int     cyVerticalSpace;
    int     cxFromLeft;
    int     i, x, y, cx, cy;
    SIZE    sizeLed;
    HDC     hdc;
    HFONT   hFont;
    TCHAR   szDisplay[16];
    RECT    rc;


    /*
    ** Calculate the max size that the display LED needs to be
    */
    hdc = GetWindowDC( hwnd );
    hFont = SelectObject( hdc, hLEDFontL );
    wsprintf( szDisplay, TRACK_REM_FORMAT, 0, 0, TEXT("M"), 0 );
    GetTextExtentPoint32( hdc, szDisplay, _tcslen(szDisplay), &sizeLed );
    SelectObject( hdc, hFont );
    ReleaseDC( hwnd, hdc );

    /*
    ** Set the size of the CD Player window based on the max size of the LED display
    ** and the width of the buttons.
    */
    GetWindowRect( hwnd, &rc );
    SetWindowPos( hwnd, HWND_TOP, 0, 0,
		  (4 * GetSystemMetrics(SM_CXBORDER)) + (5 * xFirstButton) +
		  (5 * dxButton) + sizeLed.cx,
		  rc.bottom - rc.top,
		  SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE );


    /*
    ** Now work out hown much vertical space there is between the menu and the buttons
    ** and the buttons and the tack info display.
    */
    cyVerticalSpace = (rcControls[INDEX(IDC_TRACKINFO_FIRST)].top -
		      (2 * dyButton)) / 3;
    cxFromLeft = (4 * xFirstButton) + sizeLed.cx;


    /*
    ** There are 3 buttons on the top row.  The first button is 3 times
    ** the width of the other buttons, it gets adjusted first.
    */
    y = cyVerticalSpace;
    x = cxFromLeft;

    SetWindowPos( g_hwndControls[0], HWND_TOP,
		  x, y, 3 * dxButton, dyButton, SWP_NOACTIVATE | SWP_NOZORDER );
    x += (3 * dxButton);

    for ( i = 1; i < 3; i++ ) {

	SetWindowPos( g_hwndControls[i], HWND_TOP,
		      x, y, dxButton, dyButton, SWP_NOACTIVATE | SWP_NOZORDER );
	x += dxButton;
    }


    /*
    ** There are 5 buttons on the bottom row.
    */
    y = dyButton + (2 * cyVerticalSpace);
    x = cxFromLeft;

    for ( i = 0; i < 5; i++ ) {

	SetWindowPos( g_hwndControls[i + 3], HWND_TOP,
		      x, y, dxButton, dyButton, SWP_NOACTIVATE | SWP_NOZORDER );
	x += dxButton;
    }


    /*
    ** Now adjust the LED window position.
    */
    y = cyVerticalSpace;
    x = xFirstButton;       /* see toolbar.h and toolbar.c for definition. */
    cx = (2 * xFirstButton) + sizeLed.cx;
    cy = (2 * dyButton) + cyVerticalSpace;

    SetWindowPos( g_hwndControls[INDEX(IDC_LED)], HWND_TOP,
		  x, y, cx, cy, SWP_NOACTIVATE | SWP_NOZORDER );

    /*
    ** Now expand (or shrink) the track info controls to fit the available space.
    */
    cx = (4 * xFirstButton) + (5 * dxButton) + sizeLed.cx;

    ComboBox_GetDroppedControlRect( g_hwndControls[INDEX(IDC_COMBO1)], &rc );
    i = rc.bottom - rc.top;

    SetWindowPos( g_hwndControls[INDEX(IDC_COMBO1)],
		  HWND_TOP,
		  0, 0,
		  cx - rcControls[INDEX(IDC_COMBO1)].left,
		  rcControls[INDEX(IDC_COMBO1)].bottom -
		  rcControls[INDEX(IDC_COMBO1)].top + i,
		  SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE );

    SetWindowPos( g_hwndControls[INDEX(IDC_EDIT1)],
		  HWND_TOP,
		  0, 0,
		  cx - rcControls[INDEX(IDC_EDIT1)].left,
		  rcControls[INDEX(IDC_EDIT1)].bottom -
		  rcControls[INDEX(IDC_EDIT1)].top,
		  SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE );

    SetWindowPos( g_hwndControls[INDEX(IDC_COMBO2)],
		  HWND_TOP,
		  0, 0,
		  cx - rcControls[INDEX(IDC_COMBO2)].left,
		  rcControls[INDEX(IDC_COMBO2)].bottom -
		  rcControls[INDEX(IDC_COMBO2)].top + i,
		  SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE );
}


/******************************Public*Routine******************************\
* FatalApplicationError
*
* Call this function if something "bad" happens to the application.  It
* displays an error message and then kills itself.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
FatalApplicationError(
    INT uIdStringResource,
    ...
    )
{
    va_list va;
    TCHAR   chBuffer1[ STR_MAX_STRING_LEN ];
    TCHAR   chBuffer2[ STR_MAX_STRING_LEN ];

    /*
    ** Load the relevant messages
    */
    va_start(va, uIdStringResource);
    wvsprintf(chBuffer1, IdStr(uIdStringResource), va);
    va_end(va);

    _tcscpy( chBuffer2, IdStr(STR_FATAL_ERROR) ); /*"CD Player: Fatal Error"*/

    /*
    ** How much of the application do we need to kill
    */

    if (g_hwndApp) {

	if ( IsWindowVisible(g_hwndApp) ) {
	    BringWindowToTop(g_hwndApp);
	}

	MessageBox( g_hwndApp, chBuffer1, chBuffer2,
		    MB_ICONSTOP | MB_OK | MB_APPLMODAL | MB_SETFOREGROUND );

	DestroyWindow( g_hwndApp );

    }
    else {

	MessageBox( NULL, chBuffer1, chBuffer2,
		    MB_APPLMODAL | MB_ICONSTOP | MB_OK | MB_SETFOREGROUND );
    }

    ExitProcess( (UINT)-1 );

}


/******************************Public*Routine******************************\
* IdStr
*
* Loads the given string resource ID into the passed storage.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
LPTSTR
IdStr(
    int idResource
    )
{
    static TCHAR    chBuffer[ STR_MAX_STRING_LEN ];

    if (LoadString(g_hInst, idResource, chBuffer, STR_MAX_STRING_LEN) == 0) {
	return g_szEmpty;
    }

    return chBuffer;

}


/******************************Public*Routine******************************\
* CheckMenuItemIfTrue
*
* If "flag" TRUE the given menu item is checked, otherwise it is unchecked.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CheckMenuItemIfTrue(
    HMENU hMenu,
    UINT idItem,
    BOOL flag
    )
{
    UINT uFlags;

    if (flag) {
	uFlags = MF_CHECKED | MF_BYCOMMAND;
    }
    else {
	uFlags = MF_UNCHECKED | MF_BYCOMMAND;
    }

    CheckMenuItem( hMenu, idItem, uFlags );
}


/******************************Public*Routine******************************\
* ReadSettings
*
* Read app settings from ini file.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ReadSettings(
    void
    )
{
    HKEY    hKey;
    LONG    lRet;

    /*
    ** See if the user has setting information stored in the registry.
    ** If so read the stuff from there.  Otherwise fall thru and try to
    ** get the stuff from cdplayer.ini.
    */
    lRet = RegOpenKey( HKEY_CURRENT_USER, g_szRegistryKey, &hKey );

    if ( (lRet == ERROR_SUCCESS) ) {

	DWORD   dwTmp, dwType, dwLen;
	int     x, y;
	int     cxApp, cyApp;
	int     cxDesktop, cyDesktop;
	RECT    rcApp, rcDesktop;

	// Save settings on exit ?
	dwLen = sizeof( g_fSaveOnExit );
	if ( ERROR_SUCCESS != RegQueryValueEx( hKey,
					       g_szSaveSettingsOnExit,
					       0L,
					       &dwType,
					       (LPBYTE)&g_fSaveOnExit,
					       &dwLen ) ) {
	    g_fSaveOnExit = TRUE;
	}


	// Small LED font
	dwLen = sizeof( g_fSmallLedFont );
	RegQueryValueEx( hKey, g_szSmallFont, 0L, &dwType,
			 (LPBYTE)&g_fSmallLedFont, &dwLen );

	if (g_fSmallLedFont) {
	    LED_ToggleDisplayFont(g_hwndControls[INDEX(IDC_LED)], g_fSmallLedFont );
	}


	// Enable Tooltips
	dwLen = sizeof( g_fToolTips );
	if ( ERROR_SUCCESS != RegQueryValueEx( hKey, g_szToolTips, 0L, &dwType,
				    (LPBYTE)&g_fToolTips, &dwLen ) ) {
	    g_fToolTips = TRUE;
	}


	/*
	** Stop CD playing on exit
	**
	** As this is a new setting it might not present in systems
	** that have upgraded.
	*/
	dwLen = sizeof( g_fStopCDOnExit );
	if ( ERROR_SUCCESS != RegQueryValueEx(hKey, g_szStopCDPlayingOnExit,
				    0L, &dwType, (LPBYTE)&g_fStopCDOnExit,
				    &dwLen) ) {
	    g_fStopCDOnExit = TRUE;
	}


	// Play in selected order
	dwLen = sizeof( g_fSelectedOrder );
	if ( ERROR_SUCCESS != RegQueryValueEx( hKey,
					       g_szInOrderPlay, 0L,
					       &dwType,
					       (LPBYTE)&g_fSelectedOrder,
					       &dwLen ) ) {
	    g_fSelectedOrder = TRUE;
	}


	// Use single disk
    /*
	dwLen = sizeof( dwTmp );
	if ( ERROR_SUCCESS != RegQueryValueEx( hKey,
					       g_szMultiDiscPlay,
					       0L,
					       &dwType,
					       (LPBYTE)&dwTmp,
					       &dwLen ) ) {
	    dwTmp = FALSE;
	}
	g_fSingleDisk = !(BOOL)dwTmp;
    */

	//if ( g_NumCdDevices < 2 ) {
	    g_fMultiDiskAvailable = FALSE;
	    g_fSingleDisk = TRUE;
	//}
	//else {
	//    g_fMultiDiskAvailable = TRUE;
	//}


	// Current track time
	dwLen = sizeof( g_fDisplayT );
	RegQueryValueEx( hKey, g_szDisplayT, 0L, &dwType,
			 (LPBYTE)&g_fDisplayT, &dwLen );


	// Time remaining for this track
	dwLen = sizeof( g_fDisplayTr );
	RegQueryValueEx( hKey, g_szDisplayTr, 0L, &dwType,
			 (LPBYTE)&g_fDisplayTr, &dwLen );


	// Time remaining for this play list
	dwLen = sizeof( g_fDisplayDr );
	RegQueryValueEx( hKey, g_szDisplayDr, 0L, &dwType,
			 (LPBYTE)&g_fDisplayDr, &dwLen );


	// Intro play (default 10Secs)
	dwLen = sizeof( g_fIntroPlay );
	RegQueryValueEx( hKey, g_szIntroPlay, 0L, &dwType,
			 (LPBYTE)&g_fIntroPlay, &dwLen );

	dwLen = sizeof( g_IntroPlayLength );
	RegQueryValueEx( hKey, g_szIntroPlayLen, 0L, &dwType,
			 (LPBYTE)&g_IntroPlayLength, &dwLen );
	/*
	** As this is a new setting it might not present in systems
	** that have upgraded.
	*/
	if (g_IntroPlayLength == 0) {
	    g_IntroPlayLength = INTRO_DEFAULT_LEN;
	}


	// Continuous play (loop at end)
	dwLen = sizeof( g_fContinuous );
	RegQueryValueEx( hKey, g_szContinuousPlay, 0L, &dwType,
			 (LPBYTE)&g_fContinuous, &dwLen );


	// Show toolbar
	dwLen = sizeof( g_fToolbarVisible );
	RegQueryValueEx( hKey, g_szToolbar, 0L, &dwType,
			 (LPBYTE)&g_fToolbarVisible, &dwLen );


	// Show track information
	dwLen = sizeof( g_fTrackInfoVisible );
	RegQueryValueEx( hKey, g_szDiscAndTrackDisplay, 0L, &dwType,
			 (LPBYTE)&g_fTrackInfoVisible, &dwLen );


	// Show track status bar
	dwLen = sizeof( g_fStatusbarVisible );
	RegQueryValueEx( hKey, g_szStatusBar, 0L, &dwType,
			 (LPBYTE)&g_fStatusbarVisible, &dwLen );


	// X pos
	dwLen = sizeof( x );
	RegQueryValueEx( hKey, g_szWindowOriginX, 0L, &dwType,
			 (LPBYTE)&x, &dwLen );

	// Y pos
	dwLen = sizeof( y );
	RegQueryValueEx( hKey, g_szWindowOriginY, 0L, &dwType,
			 (LPBYTE)&y, &dwLen );

	// Next 25 lines changed to add multimon support: <mwetzel 08.26.97>
	// Calc the app rect as it was during the last use
	GetClientRect( g_hwndApp, &rcApp );
	cxApp = (rcApp.right - rcApp.left);
	cyApp = (rcApp.bottom - rcApp.top);
	rcApp.left   = x;
	rcApp.top    = y;
	rcApp.right  = x + cxApp;
	rcApp.bottom = y + cyApp;
	
	// Check if the app's rect is visible is any of the monitors
	if( NULL == MonitorFromRect( &rcApp, 0L ) )
	{
		//The window is not visible. Let's center it in the primary monitor.
		//Note: the window could be in this state if (1) the display mode was changed from 
		//a high-resolution to a lower resolution, with the cdplayer in the corner. Or,
		//(2) the multi-mon configuration was rearranged.

		GetWindowRect( GetDesktopWindow(), &rcDesktop );
		cxDesktop = (rcDesktop.right - rcDesktop.left);
		cyDesktop = (rcDesktop.bottom - rcDesktop.top);

		x = (cxDesktop - cxApp) / 2; //center in x
		y = (cyDesktop - cyApp) / 3; //and a little towards the top
	}
	//else, the window is visible, so let's leave the (x,y) as read from the settings

	SetWindowPos( g_hwndApp, HWND_TOP, x, y, 0, 0,
		      SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE );

	/*
	** Make sure that the LED display format is correct
	*/
	if ( g_fDisplayT == FALSE && g_fDisplayTr == FALSE
	  && g_fDisplayDr == FALSE ) {

	    g_fDisplayT = TRUE;
	}


	RegCloseKey( hKey );
    }
    else {

	RECT    r;
	TCHAR   s[80],t[80];
	int     i, j;


	if (lRet == ERROR_SUCCESS) {
		     // presumably dwDesposition == REG_CREATED_NEW_KEY

	    RegCloseKey( hKey );
	}


	g_fSmallLedFont = GetPrivateProfileInt( g_szSettings,
						g_szSmallFont,
						FALSE,
						g_IniFileName );
	if (g_fSmallLedFont) {
	    LED_ToggleDisplayFont(g_hwndControls[INDEX(IDC_LED)], g_fSmallLedFont );
	}


	g_fToolTips = GetPrivateProfileInt( g_szSettings, g_szToolTips,
					    TRUE, g_IniFileName );

	/*
	** Get disc play settings
	*/

	i = GetPrivateProfileInt( g_szSettings, g_szInOrderPlay,
				  FALSE, g_IniFileName );
	j = GetPrivateProfileInt( g_szSettings, g_szRandomPlay,
				  FALSE, g_IniFileName );

	/*
	** Because the orignal CD Player had a way of recording
	** whether the state was random or inorder play we need the following
	** state table.
	**
	** if  i == j   => g_fSelectedOrder = TRUE;
	** else         => g_fSelectedOrder = i;
	*/
	if ( i == j ) {
	    g_fSelectedOrder = TRUE;
	}
	else {
	    g_fSelectedOrder = (BOOL)i;
	}


	//i = GetPrivateProfileInt( g_szSettings, g_szMultiDiscPlay,
	//                        3, g_IniFileName );
	//if (i == 0 || i == 3) {
	//    g_fSingleDisk = TRUE;

	//}
	//else {
	//    g_fSingleDisk = FALSE;
	//}

	//if ( g_NumCdDevices < 2 ) {
	    g_fMultiDiskAvailable = FALSE;
	    g_fSingleDisk = TRUE;
	//}
	//else {
	///    g_fMultiDiskAvailable = TRUE;
	//}


	g_fIntroPlay = (BOOL)GetPrivateProfileInt( g_szSettings,
						   g_szIntroPlay,
						   FALSE,
						   g_IniFileName );

	g_IntroPlayLength = (BOOL)GetPrivateProfileInt( g_szSettings,
							g_szIntroPlayLen,
							INTRO_DEFAULT_LEN,
							g_IniFileName );

	g_fContinuous = (BOOL)GetPrivateProfileInt( g_szSettings,
						    g_szContinuousPlay,
						    FALSE, g_IniFileName );

	g_fSaveOnExit = (BOOL)GetPrivateProfileInt( g_szSettings,
						    g_szSaveSettingsOnExit,
						    TRUE,
						    g_IniFileName );

	g_fStopCDOnExit = (BOOL)GetPrivateProfileInt( g_szSettings,
						      g_szStopCDPlayingOnExit,
						      TRUE,
						      g_IniFileName );

	g_fDisplayT = (BOOL)GetPrivateProfileInt( g_szSettings,
						  g_szDisplayT,
						  TRUE, g_IniFileName );

	g_fDisplayTr = (BOOL)GetPrivateProfileInt( g_szSettings,
						   g_szDisplayTr,
						   FALSE, g_IniFileName );

	g_fDisplayDr = (BOOL)GetPrivateProfileInt( g_szSettings,
						   g_szDisplayDr,
						   FALSE, g_IniFileName );


	/*
	** When the app is created the toolbar is inially NOT shown.  Therefore
	** only show it if the user requests it.
	*/
	g_fToolbarVisible = (BOOL)GetPrivateProfileInt( g_szSettings,
							g_szToolbar,
							FALSE, g_IniFileName );


	/*
	** When the app is created the track info stuff is initially shown.
	** Therefore only hide it if the user requests it.
	*/
	g_fTrackInfoVisible = (BOOL)GetPrivateProfileInt( g_szSettings,
							  g_szDiscAndTrackDisplay,
							  TRUE, g_IniFileName );


	/*
	** When the app is created the statusbar is initially NOT shown.
	** Therefore only show it if the user requests it.
	*/
	g_fStatusbarVisible = (BOOL)GetPrivateProfileInt( g_szSettings,
							  g_szStatusBar,
							  TRUE, g_IniFileName );


	GetWindowRect( g_hwndApp, &r );

	wsprintf(t, TEXT("%d %d"),r.left, r.top);

	GetPrivateProfileString( g_szSettings, g_szWindowOrigin, t, s, 80,
				 g_IniFileName  );

	_stscanf(s, TEXT("%d %d"), &r.left, &r.top);

	SetWindowPos( g_hwndApp, HWND_TOP, r.left, r.top, 0, 0,
		      SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE );

    }

    /*
    ** Update the various buttons, toolbars and statusbar
    */
    if (g_fToolbarVisible) {

	g_fToolbarVisible = FALSE;
	ShowToolbar();
    }

    if (!g_fTrackInfoVisible) {

	g_fTrackInfoVisible = TRUE;
	ShowTrackInfo();
    }

    if (g_fStatusbarVisible) {

	g_fStatusbarVisible = FALSE;
	ShowStatusbar();
    }

    /*
    ** If there is only one disc drive available remove the "Multidisc play"
    ** menu item.  UpdateToolbarButtons below will take care of the
    ** Multidisc toolbar button.
    */
    //if ( !g_fMultiDiskAvailable ) {
    {
	HMENU hMenu = GetSubMenu( GetMenu(g_hwndApp), 2 );

	DeleteMenu( hMenu, IDM_OPTIONS_MULTI, MF_BYCOMMAND );
    }

    UpdateToolbarButtons();
    UpdateToolbarTimeButtons();
}


/******************************Public*Routine******************************\
* UpdateToolbarButtons
*
* Ensures that the toolbar buttons are in the correct state.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
UpdateToolbarButtons(
    void
    )
{
    LRESULT lResult;

    /*
    ** Read the current state of the button.  If the current button state
    ** does not match (!g_fSelectedOrder) we need to toggle the button state.
    */

    lResult = SendMessage( g_hwndToolbar, TB_ISBUTTONCHECKED,
			   IDM_OPTIONS_RANDOM, 0L );

    if ( g_fSelectedOrder || (lResult == 0L) ) {

	    SendMessage( g_hwndToolbar, TB_CHECKBUTTON,
			 IDM_OPTIONS_RANDOM, (LPARAM)!g_fSelectedOrder );
    }


    /*
    ** Whats the current visible state of the multi-disk button ?
    ** If lResult != 0 the button is already visible.
    */
    lResult = SendMessage( g_hwndToolbar, TB_ISBUTTONHIDDEN,
			   IDM_OPTIONS_MULTI, 0L );

    /*
    ** Does the multi-disk button visible state match the g_fMultiDiskAvailable
    ** flag ?  If so we need to toggle the buttons visible state.
    */
    //if ( !(g_fMultiDiskAvailable && lResult) ) {

	    SendMessage( g_hwndToolbar, TB_HIDEBUTTON, IDM_OPTIONS_MULTI,
			 MAKELPARAM( !g_fMultiDiskAvailable, 0) );
    //}


    /*
    ** If there are multiple discs available does the current
    ** state of the MULTI disc button match the state of (!g_fSingleDisk)
    */
    if (g_fMultiDiskAvailable) {

	lResult = SendMessage( g_hwndToolbar, TB_ISBUTTONCHECKED,
			       IDM_OPTIONS_MULTI, 0L );


	if ( g_fSingleDisk || (lResult == 0L) ) {

	    SendMessage( g_hwndToolbar, TB_CHECKBUTTON,
			 IDM_OPTIONS_MULTI, (LPARAM)!g_fSingleDisk );
	}
    }


    /*
    ** Read the current state of the button.  If the current button state
    ** does not match g_fContinuous we need to toggle the button state.
    */

    lResult = SendMessage( g_hwndToolbar, TB_ISBUTTONCHECKED,
			   IDM_OPTIONS_CONTINUOUS, (LPARAM)0L );

    if ( !(g_fContinuous && lResult) ) {

	    SendMessage( g_hwndToolbar, TB_CHECKBUTTON,
			 IDM_OPTIONS_CONTINUOUS, (LPARAM)g_fContinuous );

    }


    /*
    ** Read the current state of the button.  If the current button state
    ** does not match g_fIntroPlay we need to toggle the button state.
    */

    lResult = SendMessage( g_hwndToolbar, TB_ISBUTTONCHECKED,
			   IDM_OPTIONS_INTRO, (LPARAM)0L );

    if ( !(g_fIntroPlay && lResult) ) {

	    SendMessage( g_hwndToolbar, TB_CHECKBUTTON,
			 IDM_OPTIONS_INTRO, (LPARAM)g_fIntroPlay );

    }

    /*
    ** Turn the tool tips on or off
    */
    EnableToolTips( g_fToolTips );
}


/******************************Public*Routine******************************\
* UpdateToolbarTimeButtons
*
* Ensures that the time remaining toolbar buttons are in the correct state.
* This function should only be called from the LED wndproc when it receives
* a mouse button up message.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
UpdateToolbarTimeButtons(
    void
    )
{
    if (g_fDisplayT) {
	SendMessage( g_hwndToolbar, TB_CHECKBUTTON,
		     IDM_TIME_REMAINING, (LPARAM)g_fDisplayT );
    }
    else if (g_fDisplayTr) {
	SendMessage( g_hwndToolbar, TB_CHECKBUTTON,
		     IDM_TRACK_REMAINING, (LPARAM)g_fDisplayTr );
    }
    else if (g_fDisplayDr) {
	SendMessage( g_hwndToolbar, TB_CHECKBUTTON,
		     IDM_DISC_REMAINING, (LPARAM)g_fDisplayDr );
    }
}


/******************************Public*Routine******************************\
* LockTableOfContents
*
* This function is used to determine if it is valid for the UI thread
* to access the table of contents for the specified CD Rom.  If this
* function returns FALSE the UI thread should NOT touch the table of
* contents for this CD Rom.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
LockTableOfContents(
    int cdrom
    )
{
    DWORD   dwRet;

    if (g_Devices[cdrom]->fIsTocValid) {
	return TRUE;
    }

    if (g_Devices[cdrom]->hThreadToc == NULL) {
	return FALSE;
    }

    dwRet = WaitForSingleObject(g_Devices[cdrom]->hThreadToc, 0L );
    if (dwRet == WAIT_OBJECT_0) {

	GetExitCodeThread( g_Devices[cdrom]->hThreadToc, &dwRet );
	g_Devices[cdrom]->fIsTocValid = (BOOL)dwRet;
	CloseHandle( g_Devices[cdrom]->hThreadToc );
	g_Devices[cdrom]->hThreadToc = NULL;
    }

    return g_Devices[cdrom]->fIsTocValid;
}


/******************************Public*Routine******************************\
* LockAllTableOfContents
*
* This function is used to determine if it is valid for the UI thread
* to access the table of contents for the ALL the cdroms devices.
* The function returns FALSE the UI thread should NOT touch the table of
* contents for any CD Rom.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
LockALLTableOfContents(
    void
    )
{
    BOOL    fLock;
    int     i;

    for (i = 0, fLock = TRUE; fLock && (i < g_NumCdDevices); i++) {
	fLock = LockTableOfContents(i);
    }

    return fLock;
}


/******************************Public*Routine******************************\
* AllocMemory
*
* Allocates a memory of the given size.  This function will terminate the
* application if the allocation failed.  Memory allocated by this function
* must be freed with LocalFree.  The memory should not be locked or unlocked.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
LPVOID
AllocMemory(
    UINT uSize
    )
{
    LPVOID lp;
    lp = LocalAlloc( LPTR, uSize );
    if (lp == NULL) {

	/*
	** No memory - no application, simple !
	*/

	FatalApplicationError( STR_FAIL_INIT );
    }

    return lp;
}


/******************************Public*Routine******************************\
* SetPlayButtonsEnableState
*
* Sets the play buttons enable state to match the state of the current
* cdrom device.  See below...
*
*
*                 CDPlayer buttons enable state table
* 
* E=Enabled D=Disabled       Play  Pause  Eject  Stop   Other DataB 
* 
* Disk in use                 D     D      D       D      D     D   
* 
* No music cd or data cdrom   D     D      E       D      D     D   
* 
* Music cd (playing)          D     E      E       E      E     E   
* 
* Music cd (paused)           E     E      E       E      E     E   
* 
* Music cd (stopped)          E     D      E       D      E     E   
* 
*
* Note that the DataB(ase) button is actually on the toolbar.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
SetPlayButtonsEnableState(
    void
    )
{
    BOOL    fEnable;
    BOOL    fMusicCdLoaded;
    BOOL    fActivePlayList;
    int     i;


    /*
    ** Do we have a music cd loaded.
    */
    if (g_State & (CD_BEING_SCANNED | CD_NO_CD | CD_DATA_CD_LOADED | CD_IN_USE)) {
	fMusicCdLoaded = FALSE;
    }
    else {
	fMusicCdLoaded = TRUE;
    }


    /*
    ** Is there an active playlist
    */
    if ( (CDTIME(g_CurrCdrom).TotalMin == 0) && (CDTIME(g_CurrCdrom).TotalSec == 0) ) {
	fActivePlayList = FALSE;
    }
    else {

	fActivePlayList = TRUE;
    }


    /*
    ** Do the play button
    */
    if ( fMusicCdLoaded
      && fActivePlayList
      && ((g_State & CD_STOPPED) || (g_State & CD_PAUSED))) {

	fEnable = TRUE;
    }
    else {
	fEnable = FALSE;
    }
    EnableWindow( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)], fEnable );

    /*
    ** Do the stop and pause buttons
    */
    if ( fMusicCdLoaded
      && fActivePlayList
      && ((g_State & CD_PLAYING) || (g_State & CD_PAUSED))) {

	EnableWindow( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)], TRUE );
	EnableWindow( g_hwndControls[INDEX(IDM_PLAYBAR_PAUSE)], TRUE );
    }
    else {

	EnableWindow( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)], FALSE );
	EnableWindow( g_hwndControls[INDEX(IDM_PLAYBAR_PAUSE)], FALSE );
    }


    /*
    ** Do the remaining buttons
    */

    for ( i = IDM_PLAYBAR_PREVTRACK; i <= IDM_PLAYBAR_NEXTTRACK; i++ ) {

	EnableWindow( g_hwndControls[INDEX(i)], (fMusicCdLoaded && fActivePlayList) );
    }

    /*
    ** If the drive is in use then we must diable the eject button.
    */
    EnableWindow( g_hwndControls[INDEX(IDM_PLAYBAR_EJECT)],
		  (g_State & (CD_BEING_SCANNED | CD_IN_USE)) ? FALSE : TRUE );


    /*
    ** Now do the database button on the toolbar.
    */
    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON,
		 IDM_DATABASE_EDIT, (LPARAM)fMusicCdLoaded );

    /*
    ** Make sure that the keyboard focus is on the Eject button
    ** if we have not got a CD loaded.
    */
    if ( GetFocus() == NULL ) {
	if ( g_State & (CD_NO_CD | CD_DATA_CD_LOADED) ) {
	    SetFocus( g_hwndControls[INDEX(IDM_PLAYBAR_EJECT)] );
	}
    }
}


/******************************Public*Routine******************************\
* HeartBeatTimerProc
*
* This function is responsible for.
*
*  1. detecting new or ejected cdroms.
*  2. flashing the LED display if we are in paused mode.
*  3. Incrementing the LED display if we are in play mode.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void CALLBACK
HeartBeatTimerProc(
    HWND hwnd,
    UINT uMsg,
    UINT idEvent,
    DWORD dwTime
    )
{
    static DWORD dwTickCount;
    int i;
    DWORD   dwMod;

    ++dwTickCount;

    dwMod = (dwTickCount % 6);

    /*
    ** Check for new/ejected cdroms, do this every three seconds.
    */
#if 0
    // Note: This code no longer necessary, it is done on the
    // WM_DEVICECHANGE message instead!!!
    if ( 0 == dwMod ) {

	for (i = 0; i < g_NumCdDevices; i++) {

	    if ( (!(g_Devices[i]->State & CD_EDITING))
	      && (!(g_Devices[i]->State & CD_PLAYING)) ) {

		CheckUnitCdrom(i, FALSE);
	    }
	}
    }
#endif

    if ( g_State & CD_PLAYING ) {

	if ( LockALLTableOfContents() ) {
	    SyncDisplay();
	}
    }

    /*
    ** If we are paused and NOT skipping flash the display.
    */

    else if ((g_State & CD_PAUSED) && !(g_State & CD_SEEKING)) {

	HWND hwnd;

	switch ( dwMod ) {

	case 2:
	case 5:
	case 8:
	case 11:
	    if ( g_fIsIconic ) {
			//Next two lines removed to fix tooltip bug:<mwetzel 08.26.97>
			//SetWindowText( g_hwndApp, g_szBlank );
			//UpdateWindow( g_hwndApp );
	    }
	    else {

		hwnd = g_hwndControls[INDEX(IDC_LED)];

		g_fFlashLed = TRUE;
		SetWindowText( hwnd, g_szBlank );
		g_fFlashLed = FALSE;
	    }
	    break;

	case 0:
	case 3:
	case 6:
	case 9:
	    UpdateDisplay( DISPLAY_UPD_LED );
	    break;
	}

    }
}


/******************************Public*Routine******************************\
* SkipBeatTimerProc
*
* This function is responsible for advancing or retreating the current
* playing position.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void CALLBACK
SkipBeatTimerProc(
    HWND hwnd,
    UINT uMsg,
    UINT idEvent,
    DWORD dwTime
    )
{

    /*
    ** Deteremine if it is time to accelerate the skipping frequency.
    */
    switch (++g_AcceleratorCount) {

    case SKIP_ACCELERATOR_LIMIT1:
	KillTimer( hwnd, idEvent );
	SetTimer( hwnd, idEvent, SKIPBEAT_TIMER_RATE2, SkipBeatTimerProc );
	break;

    case SKIP_ACCELERATOR_LIMIT2:
	KillTimer( hwnd, idEvent );
	SetTimer( hwnd, idEvent, SKIPBEAT_TIMER_RATE3, SkipBeatTimerProc );
	break;
    }

    if ( LockALLTableOfContents() ) {
	if ( idEvent == IDM_PLAYBAR_SKIPFORE) {

	    TimeAdjustIncSecond( g_CurrCdrom );

	    /*
	    ** When TimeAjustIncSecond gets to the end of the last track
	    ** it sets CURRTRACK(g_CurrCdrom) equal to NULL.  When this
	    ** occurs we effectively reset the CD Player
	    */
	    if ( CURRTRACK(g_CurrCdrom) == NULL ) {

		if ( g_State & (CD_WAS_PLAYING | CD_PAUSED) ) {

		    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
				 WM_LBUTTONDOWN, 0, 0L );

		    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
				 WM_LBUTTONUP, 0, 0L );
		}
		else {

		    /*
		    ** Seek to the first playable track.
		    */
		    CURRTRACK(g_CurrCdrom) = FindFirstTrack( g_CurrCdrom );
		    if ( CURRTRACK(g_CurrCdrom) != NULL ) {

			TimeAdjustSkipToTrack( g_CurrCdrom,
					       CURRTRACK(g_CurrCdrom) );

			UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_TIME |
				       DISPLAY_UPD_TRACK_NAME );

			SetPlayButtonsEnableState();
			SetFocus( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)] );
		    }
		}
	    }
	}
	else {
	    TimeAdjustDecSecond( g_CurrCdrom );
	}
    }
}


/******************************Public*Routine******************************\
* UpdateDisplay
*
* This routine updates the display according to the flags that
* are passed in.  The display consists of the LED display, the
* track and title names, the disc and track lengths and the cdrom
* combo-box.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
UpdateDisplay(
    DWORD Flags
    )
{
    TCHAR       lpsz[55];
    TCHAR       lpszIcon[75];
    PTRACK_PLAY tr;
    int         track;
    int         mtemp, stemp, m, s;


    /*
    ** Check for valid flags
    */

    if ( Flags == 0 ) {
	return;
    }


    /*
    ** Grab current track information
    */

    if (CURRTRACK(g_CurrCdrom) != NULL) {

	track = CURRTRACK(g_CurrCdrom)->TocIndex + FIRSTTRACK(g_CurrCdrom);
    }
    else {

	track = 0;
    }

    /*
    ** Update the LED box?
    */


    if (Flags & DISPLAY_UPD_LED) {

	/*
	** Update LED box
	*/

	if (g_fDisplayT) {

	    if (Flags & DISPLAY_UPD_LEADOUT_TIME) {

		wsprintf( lpsz, TRACK_TIME_LEADOUT_FORMAT,
			  track,
			  CDTIME(g_CurrCdrom).TrackCurMin,
			  g_szTimeSep,
			  CDTIME(g_CurrCdrom).TrackCurSec );
	    }
	    else {

		wsprintf( lpsz, TRACK_TIME_FORMAT,
			  track,
			  CDTIME(g_CurrCdrom).TrackCurMin,
			  g_szTimeSep,
			  CDTIME(g_CurrCdrom).TrackCurSec );
	    }
	}

	if (g_fDisplayTr) {

	    if (Flags & DISPLAY_UPD_LEADOUT_TIME) {

		wsprintf( lpsz, TRACK_REM_FORMAT, track - 1,
			  CDTIME(g_CurrCdrom).TrackCurMin,
			  g_szTimeSep,
			  CDTIME(g_CurrCdrom).TrackCurSec );
	    }
	    else {

		wsprintf( lpsz, TRACK_REM_FORMAT, track,
			  CDTIME(g_CurrCdrom).TrackRemMin,
			  g_szTimeSep,
			  CDTIME(g_CurrCdrom).TrackRemSec );
	    }
	}

	if (g_fDisplayDr) {

	    /*
	    ** Compute remaining time
	    */

	    mtemp = stemp = m = s =0;

	    if (CURRTRACK(g_CurrCdrom) != NULL) {

		for ( tr = CURRTRACK(g_CurrCdrom)->nextplay;
		      tr != NULL;
		      tr = tr->nextplay ) {

		    FigureTrackTime( g_CurrCdrom, tr->TocIndex, &mtemp, &stemp );

		    m+=mtemp;
		    s+=stemp;

		}

		m+= CDTIME(g_CurrCdrom).TrackRemMin;
		s+= CDTIME(g_CurrCdrom).TrackRemSec;

	    }

	    m+= (s / 60);
	    s = (s % 60);

	    CDTIME(g_CurrCdrom).RemMin = m;
	    CDTIME(g_CurrCdrom).RemSec = s;

	    wsprintf( lpsz, DISC_REM_FORMAT,
		      CDTIME(g_CurrCdrom).RemMin,
		      g_szTimeSep,
		      CDTIME(g_CurrCdrom).RemSec );
	}

	SetWindowText( g_hwndControls[INDEX(IDC_LED)], lpsz );


	if (g_fIsIconic) {
		//Next four lines changed to fix tooltip bugs: <mwetzel 08.26.97>
		if( g_Devices[g_CurrCdrom]->State & CD_PAUSED )
			wsprintf( lpszIcon, IdStr( STR_CDPLAYER_PAUSED), lpsz );
		else
			wsprintf( lpszIcon, IdStr( STR_CDPLAYER_TIME ), lpsz );
	    SetWindowText( g_hwndApp, lpszIcon );
	}
    }

    /*
    ** Update Title?
    */

    if (Flags & DISPLAY_UPD_TITLE_NAME) {

	ComputeDriveComboBox( );

	SetWindowText( g_hwndControls[INDEX(IDC_TITLE_NAME)],
		       (LPCTSTR)TITLE(g_CurrCdrom) );
    }


    /*
    ** Update track name?
    */

    if (Flags & DISPLAY_UPD_TRACK_NAME) {

	HWND hwnd;

	hwnd = g_hwndControls[INDEX(IDC_TRACK_LIST)];

	if (CURRTRACK(g_CurrCdrom) != NULL) {

	    track = 0;

	    for( tr =  PLAYLIST(g_CurrCdrom);
		 tr != CURRTRACK(g_CurrCdrom);
		 tr = tr->nextplay, track++ );

	    ComboBox_SetCurSel( hwnd, track );

	}
	else {

	    ComboBox_SetCurSel( hwnd, 0 );
	}
    }


    /*
    ** Update disc time?
    */

    if (Flags & DISPLAY_UPD_DISC_TIME) {

	wsprintf( lpsz,
		  IdStr( STR_TOTAL_PLAY ), /*"Total Play: %02d:%02d m:s", */
		  CDTIME(g_CurrCdrom).TotalMin,
		  g_szTimeSep,
		  CDTIME(g_CurrCdrom).TotalSec,
		  g_szTimeSep );

	SendMessage( g_hwndStatusbar, SB_SETTEXT, 0, (LPARAM)lpsz );

    }


    /*
    ** Update track time?
    */

    if (Flags & DISPLAY_UPD_TRACK_TIME) {

	wsprintf( lpsz,
		  IdStr( STR_TRACK_PLAY ), /* "Track: %02d:%02d m:s", */
		  CDTIME(g_CurrCdrom).TrackTotalMin,
		  g_szTimeSep,
		  CDTIME(g_CurrCdrom).TrackTotalSec,
		  g_szTimeSep );

	SendMessage( g_hwndStatusbar, SB_SETTEXT, 1, (LPARAM)lpsz );
    }

}


/******************************Public*Routine******************************\
* Common_OnCtlColor
*
* Here we return a brush to paint the background with.  The brush is the same
* color as the face of a button.  We also set the text background color so
* that static controls draw correctly.  This function is shared with the
* disk info/editing dialog box.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
HBRUSH
Common_OnCtlColor(
    HWND hwnd,
    HDC hdc,
    HWND hwndChild,
    int type
    )
{
    SetBkColor( hdc, rgbFace );
    return g_hBrushBkgd;
}

/******************************Public*Routine******************************\
* Common_OnMeasureItem
*
* All items are the same height and width.
*
* We only have to update the height field for owner draw combo boxes and
* list boxes.  This function is shared with the disk edit/info dialog box.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL
Common_OnMeasureItem(
    HWND hwnd,
    MEASUREITEMSTRUCT *lpMeasureItem
    )
{
    HFONT   hFont;
    int     cyBorder;
    LOGFONT lf;

    hFont = GetWindowFont( hwnd );
//fix kksuzuka: #3116
//in 16, 20, 24 dot font, some charcters, such as "g" or "p", needs more rooms.
    {
	UINT    iHeight;
	if ( hFont != NULL )
	{
	    GetObject( hFont, sizeof(lf), &lf );
	}
	else
	{
	    SystemParametersInfo( SPI_GETICONTITLELOGFONT,
		sizeof(lf), (LPVOID)&lf, 0 );
	}
	iHeight = ABS( lf.lfHeight );
	lpMeasureItem->itemHeight = iHeight / 2 * 3;
    }
    return TRUE;
}

/******************************Public*Routine******************************\
* DrawTrackItem
*
* This routine draws the information in a cell of the track name
* combo box.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
DrawTrackItem(
    HDC hdc,
    const RECT *r,
    DWORD item,
    BOOL selected
    )
{
    SIZE        si;
    int         i;
    int         cxTrk;
    PTRACK_INF  t;
    TCHAR       s[ARTIST_LENGTH];
    TCHAR       szTrk[16];

    /*
    ** Check for invalid items
    */

    if ( item == (DWORD)-1 ) {

	return;
    }

    if ( ALLTRACKS(g_CurrCdrom) == NULL ) {

	return;
    }


    /*
    ** Check selection status, and set up to draw correctly
    */

    if ( selected ) {

	SetBkColor( hdc, GetSysColor( COLOR_HIGHLIGHT ) );
	SetTextColor( hdc, GetSysColor( COLOR_HIGHLIGHTTEXT ) );
    }
    else {

	SetBkColor( hdc, GetSysColor(COLOR_WINDOW));
	SetTextColor( hdc, GetSysColor(COLOR_WINDOWTEXT));
    }

    /*
    ** Get track info
    */

    t = FindTrackNodeFromTocIndex( item, ALLTRACKS( g_CurrCdrom ) );


    if ( (t != NULL) && (t->name != NULL) ) {

	/*
	** Do we need to munge track name (clip to listbox)?
	*/

	wsprintf(szTrk, TEXT("<%02d> "), t->TocIndex + FIRSTTRACK(g_CurrCdrom));
	GetTextExtentPoint( hdc, szTrk, _tcslen(szTrk), &si );
	cxTrk = si.cx;

	i = _tcslen( t->name ) + 1;

	do {
	    GetTextExtentPoint( hdc, t->name, --i, &si );

	} while( si.cx > (r->right - r->left - cxTrk) );

	ZeroMemory( s, TRACK_TITLE_LENGTH * sizeof( TCHAR ) );
	_tcsncpy( s, t->name, i );

    }
    else {

	_tcscpy( s, g_szBlank );
	i = 1;

    }

    /*
    ** Draw track name
    */

    ExtTextOut( hdc, r->left, r->top,
		ETO_OPAQUE | ETO_CLIPPED,
		r, s, i, NULL );

    /*
    ** draw track number
    */
    if ( t != NULL ) {
	ExtTextOut( hdc, r->right - cxTrk, r->top, ETO_CLIPPED,
		    r, szTrk, _tcslen( szTrk ), NULL );
    }

}


/******************************Public*Routine******************************\
* DrawDriveItem
*
* This routine draws the information in a cell of the drive/artist
* combo box.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
DrawDriveItem(
    HDC   hdc,
    const RECT *r,
    DWORD item,
    BOOL  selected
    )
{
    SIZE    si;
    int     i;
    int     j;
    int     cxDrv;
    TCHAR   szDrv[16];

    /*
    ** Check for invalid items
    */

    if ( item == (DWORD)-1 ) {

	return;
    }

    /*
    ** Check selection status, and set up to draw correctly
    */

    if (selected) {

	SetBkColor( hdc, GetSysColor( COLOR_HIGHLIGHT ) );
	SetTextColor( hdc, GetSysColor( COLOR_HIGHLIGHTTEXT ) );
    }
    else {

	SetBkColor( hdc, GetSysColor(COLOR_WINDOW));
	SetTextColor( hdc, GetSysColor(COLOR_WINDOWTEXT));
    }

    /*
    ** Do we need to munge artist name (clip)?
    */

    wsprintf( szDrv, TEXT("<%c:> "), g_Devices[item]->drive );
    j = _tcslen( szDrv );
    GetTextExtentPoint( hdc, szDrv, j, &si );
    cxDrv = si.cx;

    i = _tcslen( ARTIST(item) ) + 1;

    do {

	GetTextExtentPoint( hdc, ARTIST(item), --i, &si );

    } while( si.cx > (r->right - r->left - cxDrv)  );


    /*
    ** Draw artist name
    */
    ExtTextOut( hdc, r->left, r->top, ETO_OPAQUE | ETO_CLIPPED, r,
		ARTIST(item), i, NULL );

    /*
    ** draw drive letter
    */
    ExtTextOut( hdc, r->right - cxDrv, r->top, ETO_CLIPPED, r,
		szDrv, j, NULL );
}

/*****************************Private*Routine******************************\
* StartSndVol
*
* Trys to start sndvol (the NT sound volume piglet).
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
StartSndVol(
    DWORD unused
    )
{
    /*
    ** WinExec returns a value greater than 31 if suceeds
    */

    g_fVolumeController = (WinExec( "sndvol32", SW_SHOW ) > 31);
    ExitThread( 0 );
}


/*****************************Private*Routine******************************\
* EnableToolTips
*
* Enables or disables the display of tool tips according to the fEnable
* parameter
*
* History:
* 18-09-94 - StephenE - Created
*
\**************************************************************************/
void
EnableToolTips(
    BOOL    fEnable
    )
{
    HWND    hwndTips;

    hwndTips = (HWND)SendMessage( g_hwndApp, TB_GETTOOLTIPS, 0, 0L );
    SendMessage( hwndTips, TTM_ACTIVATE, fEnable, 0L );

    hwndTips = (HWND)SendMessage( g_hwndToolbar, TB_GETTOOLTIPS, 0, 0L );
    SendMessage( hwndTips, TTM_ACTIVATE, fEnable, 0L );
}




/*****************************Private*Routine******************************\
* HandlePassedCommandLine
*
* This function gets called to handle command line options that are passed to
* CDPlayer as the result of the WM_DROPFILES or WM_COPYDATA messages.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
HandlePassedCommandLine(
    LPTSTR lpCmdLine,
    BOOL   fCheckCDRom
    )
{

    int     i;
    int     iTrack = -1, iCDrom;

    iCDrom = ParseCommandLine( lpCmdLine, &iTrack, TRUE );
    if ((iCDrom < 0) || (iCDrom >= g_NumCdDevices))
	return;

    
	// CheckUnitCDRom to reload Table of Contents
    if ( fCheckCDRom ) 
    {

	CheckUnitCdrom(iCDrom, TRUE);

	while( !LockTableOfContents(iCDrom) ) 
	{

		MSG     msg;

	    GetMessage( &msg, NULL, WM_NOTIFY_TOC_READ, WM_NOTIFY_TOC_READ );
		DispatchMessage( &msg );
	    }
    }

    if (iCDrom != g_CurrCdrom)
    {
	    HWND hwndBtn = g_hwndControls[INDEX(IDC_ARTIST_NAME)];

	    SwitchToCdrom( iCDrom, TRUE );
	    SetPlayButtonsEnableState();
	    SendMessage( hwndBtn, CB_SETCURSEL, (WPARAM)iCDrom, 0 );
    }


    /*
    ** Initialize the new play list for each drive.
    */
    for ( i = 0; i < g_NumCdDevices; i++) 
    {
	    TimeAdjustInitialize( i );
    }

    // Set Current Track to specified track
    if ( iTrack != -1 ) 
    {
		//<mwetzel:08.28.97> Big change here to fix a null-ptr reference bug, when a
		//track was requested that wasn't in the playlist.
		//The new code checks to see if the track is in the playlist, and if not, adds
		//it temporarily, and plays it
	    PTRACK_PLAY tr;
		CURRPOS cp;
		cp.Track = iTrack+1;

	    tr = PLAYLIST( g_CurrCdrom );

		while( tr )
		{
			if( tr->TocIndex == iTrack )
			{
		    TimeAdjustSkipToTrack( g_CurrCdrom, tr );
				return;
			}
			tr = tr->nextplay;
		}

		//If not found, add it then get tr for it
	AddTemporaryTrackToPlayList(&cp);
				
		tr = PLAYLIST( g_CurrCdrom );
		while( tr )
		{
			if( tr->TocIndex == iTrack )
			{
		    TimeAdjustSkipToTrack( g_CurrCdrom, tr );
				return;
			}
			tr = tr->nextplay;
		}

    }
}

/******************************Public*Routine******************************\
* IsPlayOptionGiven
*
* Checks the command line to see if the "-play" option has been passed.
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
IsPlayOptionGiven(
    LPTSTR lpstr
    )
{
    TCHAR   chOption[MAX_PATH];


    /*
    ** Start by converting everything to upper case.
    */
    CharUpperBuff( lpstr, _tcslen(lpstr) );

    /*
    ** The first parameter on the command line is always the
    ** string used invoke the program.  ie cdplayer.exe
    */
    lpstr += _tcsspn( lpstr, g_szBlank );
    lpstr += CopyWord( chOption, lpstr );


    /*
    ** Remove leading space
    */
    lpstr += _tcsspn( lpstr, g_szBlank );


    /*
    ** process any command line options
    */
    while ( (*lpstr == g_chOptionHyphen) || (*lpstr == g_chOptionSlash) ) {

	/*
	** pass over the option delimeter
	*/
	lpstr++;

	/*
	** Copy option and skip over it.
	*/
	lpstr += CopyWord( chOption, lpstr );


	/*
	** Is this the play option ??  If so, don't  bother processing anymore
	** options.
	*/
	if ( 0 == _tcscmp( chOption, g_szPlay ) ) {

	    return TRUE;
	}

	/*
	** Remove leading space
	*/
	lpstr += _tcsspn( lpstr, g_szBlank );
    }

    return FALSE;
}



/******************************Public*Routine******************************\
* IsUpdateOptionGiven
*
* Checks the command line to see if the "-update" option has been passed.
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
IsUpdateOptionGiven(
    LPTSTR lpstr
    )
{
    TCHAR   chOption[MAX_PATH];


    /*
    ** Start by converting everything to upper case.
    */
    CharUpperBuff( lpstr, _tcslen(lpstr) );

    /*
    ** The first parameter on the command line is always the
    ** string used invoke the program.  ie cdplayer.exe
    */
    lpstr += _tcsspn( lpstr, g_szBlank );
    lpstr += CopyWord( chOption, lpstr );


    /*
    ** Remove leading space
    */
    lpstr += _tcsspn( lpstr, g_szBlank );


    /*
    ** process any command line options
    */
    while ( (*lpstr == g_chOptionHyphen) || (*lpstr == g_chOptionSlash) ) {

	/*
	** pass over the option delimeter
	*/
	lpstr++;

	/*
	** Copy option and skip over it.
	*/
	lpstr += CopyWord( chOption, lpstr );


	/*
	** Is this the play option ??  If so, don't  bother processing anymore
	** options.
	*/
	if ( 0 == _tcscmp( chOption, g_szUpdate ) ) {

	    return TRUE;
	}

	/*
	** Remove leading space
	*/
	lpstr += _tcsspn( lpstr, g_szBlank );
    }

    return FALSE;
}



/*****************************Private*Routine******************************\
* ParseCommandLine
*
* Here we look to see if we have been asked to play a particular track.
* The format of the command line is:
*
*
*  CDPlayer command options.
*
*  CDPLAYER {Options}
*
*   Options     :   -play | {Sub-Options}
*   Sub-Options :   {-track tracklist} | trackname
*   trackname   :   filename | drive letter
*   tracklist   :   filename+
*
*      -track      A track list if a list of tracks that the user wants
*                  to play.  It overides any play list that may already be stored
*                  for the current cd.
*
*      -play       Start playing the current play list.  If -play is not specified
*                  CD Player seeks to the first track in the play list.
*
*
*   On Windows NT the format of [file] is:
*       d:\track(nn).cda
*
*   where d: is the drive letter of the cdrom that you want to play
*   and \track(nn) is the track number that you want to play.
*
*   Therefore to play track 8 from a cd-rom drive mapped to e:
*
*       cdplayer /play e:\track08.cda
*
*   On Chicago the file is actually a riff CDDA file which contains
*   all the info required to locate the disc and track.
*
* Returns the index of the CD-Rom drive which should be played first.  Can return
* -1 iff the caller passed FALSE for the fQuiet parameter and the message box was
* actually displayed.  This should only occur when the user trys to start a new
* copy of cdplayer passing it the track.cda file of a disk that is not inserted
* in any of the current CD-Drives attached to the machine.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int
ParseCommandLine(
    LPTSTR lpstr,
    int *piTrackToSeekTo,
    BOOL fQuiet
    )
{

    TCHAR   chOption[MAX_PATH];
    BOOL    fTrack = FALSE;
    int     iCdRomIndex = -1;  // Assume Failure until proven otherwise
    int     ii;

    for (ii = 0; ii < g_NumCdDevices; ii++) {
    g_Devices[ii]->fKilledPlayList = FALSE;
    }
    

    /*
    ** Start by converting everything to upper case.
    */
    CharUpperBuff( lpstr, _tcslen(lpstr) );

#if DBG
#ifdef UNICODE
    dprintf( "CD Player Command line : %ls", lpstr );
#else
    dprintf( "CD Player Command line : %s", lpstr );
#endif
#endif

    /*
    ** The first parameter on the command line is always the
    ** string used invoke the program.  ie cdplayer.exe
    */
    lpstr += _tcsspn( lpstr, g_szBlank );
    lpstr += CopyWord( chOption, lpstr );


    /*
    ** Remove leading space
    */
    lpstr += _tcsspn( lpstr, g_szBlank );


    /*
    ** process any command line options
    */
    while ( (*lpstr == g_chOptionHyphen) || (*lpstr == g_chOptionSlash) ) {

	/*
	** pass over the option delimeter
	*/
	lpstr++;

	/*
	** Copy option and skip over it.
	*/
	lpstr += CopyWord( chOption, lpstr );


	/*
	** Is this a command line option we understand - ignore ones
	** we don't understand.
	*/
	if ( 0 == _tcscmp( chOption, g_szTrack ) ) {

	    if ( !fTrack ) {
		lpstr = ParseTrackList( lpstr, &iCdRomIndex );
		fTrack = TRUE;
	    }
	}
	else if ( 0 == _tcscmp( chOption, g_szPlay ) ) {

	    g_fPlay = TRUE;
	}
	else {
#if DBG
#ifdef UNICODE
	    dprintf("Ignoring unknown option %ls\n", chOption );
#else
	    dprintf("Ignoring unknown option %s\n", chOption );
#endif
#endif
	}

	/*
	** Remove leading space
	*/
	lpstr += _tcsspn( lpstr, g_szBlank );
    }


    /*
    ** parse remaining command line parameters
    */

    if ( (*lpstr != g_chNULL) && !fTrack) {

	/*
	** Copy track name and skip over it.  Sometimes the shell
	** gives us quoted strings and sometimes it doesn't.  If the
	** string is not quoted assume that remainder of the command line
	** is the track name.
	*/
	if ( (*lpstr == TEXT('\'')) || (*lpstr == TEXT('\"')) ) {
	    lpstr += CopyWord( chOption, lpstr );
	}
	else {
	    _tcscpy(chOption, lpstr);
	}

	if ( IsTrackFileNameValid( chOption, &iCdRomIndex,
				   piTrackToSeekTo, FALSE, fQuiet ) ) {

	    ResetPlayList( iCdRomIndex );
	}
#if DBG
#ifdef UNICODE
	dprintf("Seeking to track %ls\n", chOption );
#else
	dprintf("Seeking to track %s\n", chOption );
#endif
#endif
    }

    return iCdRomIndex;
}



/*****************************Private*Routine******************************\
* ParseTrackList
*
* Each track is separated by a ' ' character.  The track list is terminated
* by the NULL, '/' or '-' character.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
TCHAR *
ParseTrackList(
    TCHAR *szTrackList,
    int *piCdRomIndex
    )
{
    TCHAR   chTrack[MAX_PATH];
    int     iTrackIndex;
    int     iCdRom = -1;                // Assume failure, until proven otherwise
    BOOL    fPlayListErased = FALSE;


    /*
    ** Remove any stray white space
    */

    szTrackList += _tcsspn( szTrackList, g_szBlank );

    /*
    ** While there are still valid characters to process
    */

    while ( (*szTrackList != g_chNULL)
	 && (*szTrackList != g_chOptionHyphen)
	 && (*szTrackList != g_chOptionSlash) ) {

	/*
	** Copy the track name and skip over it.
	*/
	szTrackList += CopyWord( chTrack, szTrackList );

	/*
	** Now check that we have been given a valid filename
	*/

	if ( IsTrackFileNameValid( chTrack, &iCdRom, &iTrackIndex, TRUE, FALSE ) ) {

	    PTRACK_PLAY     pt;

	    /*
	    ** If this is the first valid file given nuke the
	    ** existing play lists and prepare for a new list.  Note that
	    ** things are complicated by the fact that we could be given
	    ** files from more than one CD-Rom drive.
	    */

	if (! g_Devices[iCdRom]->fKilledPlayList)
	{
		    /*
		    ** Kill the old play and save lists.
		    */

		    ErasePlayList( iCdRom );
		    EraseSaveList( iCdRom );

		    PLAYLIST( iCdRom ) = NULL;
		    SAVELIST( iCdRom ) = NULL;

		    fPlayListErased = TRUE;
		    
		g_Devices[iCdRom]->fKilledPlayList = TRUE;
		    *piCdRomIndex = iCdRom;
	    }

	    pt = AllocMemory( sizeof(TRACK_PLAY) );

	    pt->TocIndex = iTrackIndex;
	    pt->min = 0;
	    pt->sec = 0;

	    /*
	    ** Is this the first track on this devices play list ?
	    */

	    if ( PLAYLIST(iCdRom) == NULL ) {

		PLAYLIST(iCdRom) = pt;
		pt->nextplay = pt->prevplay = NULL;
	    }
	    else {

		/*
		** append this track to the end of the current play list
		*/

		AppendTrackToPlayList( PLAYLIST(iCdRom), pt );
	    }
	}
	else {

	    /*
	    ** Put up a message box warning the user that the given
	    ** track name is invalid and that we can't play it.
	    */

	    ;
	}

	/*
	** Remove any stray white space
	*/
	szTrackList += _tcsspn( szTrackList, g_szBlank );
    }

    /*
    ** If we have erased the play list we have to go off and reset the
    ** saved play list.
    */

    if ( fPlayListErased ) {
	    SAVELIST( iCdRom ) = CopyPlayList( PLAYLIST(iCdRom) );
    }

    return szTrackList;
}



/*****************************Private*Routine******************************\
* CopyWord
*
* Copies one from szSource to szWord - assumes that words are delimited
* by ' ' characters.  szSource MUST point to the begining of the word.
*
* Returns length of word copied.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int
CopyWord(
    TCHAR *szWord,
    TCHAR *szSource
    )
{
    int     n, nReturn;

    /*
    ** Copy the track name
    */
    if ( (*szSource == TEXT('\'')) || (*szSource == TEXT('\"')) ) {

	TCHAR ch = *szSource;

	/*
	** Remember which quote character it was
	** According to the DOCS " is invalid in a filename...
	*/

	n = 0;

	/*
	** Move over the initial quote, then copy the filename
	*/

	while ( *++szSource && *szSource != ch ) {
	    szWord[n++] = *szSource;
	}
	nReturn = n + (*szSource == ch ? 2 : 1);
    }
    else {

	n = _tcscspn( szSource, g_szBlank );
	_tcsncpy( szWord, szSource, n );
	nReturn = n;
    }

    szWord[n] = g_chNULL;

    return nReturn;
}



/*****************************Private*Routine******************************\
* IsTrackFileNameValid
*
* This function returns true if the specified filename is a valid CD track.

* On NT track filenames must be of the form:
*   d:\track(n).cda  where d: is the CD-Rom device and \track(n).cda
*                    is the index of the track to be played (starting from 1).
*
* On Chicago the track filename is actually a riff CDDA file which contains
* the track info that we require.
*
* If the filename is valid the function true and sets piCdromIndex and
* piTrackIndex to the correct values.
*
* History:
* 29-09-94 - StephenE - Created
*
\**************************************************************************/
BOOL
IsTrackFileNameValid(
    LPTSTR lpstFileName,
    int *piCdRomIndex,
    int *piTrackIndex,
    BOOL fScanningTracks,
    BOOL fQuiet
    )
{
#define RIFF_RIFF 0x46464952
#define RIFF_CDDA 0x41444443

    RIFFCDA     cda;
	HANDLE          hFile;
    TCHAR       chDriveLetter;
    int         i;
    TCHAR       szFileName[MAX_PATH];
	TCHAR           szPath[MAX_PATH];
    SHFILEINFO  shInfo;
    DWORD       cbRead;


    //
    // If we are not constructing a track play list it is valid to just specify
    // a drive letter, in which case we select that drive and start playing
    // at the first track on it.  All the tracks are played in sequential
    // order.
    //
    if ( !fScanningTracks) {

	//
	// Map the drive letter onto the internal CD-Rom index used by CDPlayer.
	//
	chDriveLetter = *lpstFileName;
	for ( i = 0; i < g_NumCdDevices; i++ ) {

	    if (g_Devices[i]->drive == chDriveLetter) {

		*piCdRomIndex = i;
		break;
	    }
	}

	//
	// If we mapped the drive OK check to see if we should play all
	// the tracks or just the current play list for that drive.  If we
	// didn't map the drive OK assume that its the first part of a
	// RIFF filename and fall through to the code below that opens the
	// RIFF file and parses its contents.
	//
	if ( i != g_NumCdDevices ) {

	    //
	    // If next character is only a colon ':' then play the
	    // the entire disk starting from the first track.
	    //
	    if ( 0 == _tcscmp(lpstFileName + 1, g_szColon) ) {

		*piTrackIndex = 0;
		return TRUE;
	    }

	    //
	    // If the next two characters are colon backslash ":\" then
	    // we seek to the specified drive and play only those tracks that
	    // are in the default playlist for the current disk in that drive.
	    // All we need to do to achive this is return FALSE.
	    //
	    if ( 0 == _tcscmp(lpstFileName + 1, g_szColonBackSlash) ) {
		return FALSE;
	    }
	}
    }


    //
    // Otherwise, open the file and read the CDA info.  The file name may be a
    // link to .cda in which case we need to get the shell to resolve the link for
    // us.  We take a copy of the file name because the ResolveLink function
    // modifies the file name string in place.
    //
    _tcscpy(szFileName, lpstFileName);
    if (0L == SHGetFileInfo( szFileName, 0L, &shInfo,
			     sizeof(shInfo), SHGFI_ATTRIBUTES)) {
	return FALSE;
    }

    if ((shInfo.dwAttributes & SFGAO_LINK) == SFGAO_LINK) {

	if (!g_fOleInitialized) {
	    g_fOleInitialized = SUCCEEDED(OleInitialize(NULL));
	}

	if (!ResolveLink(szFileName)) {
	    return FALSE;
	}
    }

	// Make sure file exists
	if (GetFileAttributes (szFileName) == ((DWORD)-1)) {
		// Get Full path to file
		if (0 == SearchPath (NULL, szFileName, NULL, 
							 MAX_PATH, szPath, NULL)) {
			return FALSE;
		}
	} else {
		lstrcpy (szPath, szFileName);
	}

	// Open file and read in CDA info
	hFile = CreateFile (szFileName, GENERIC_READ, 
						FILE_SHARE_READ, NULL, 
						OPEN_EXISTING, 0, NULL);
	if (INVALID_HANDLE_VALUE == hFile) {
		return FALSE;
	}
	
	ReadFile(hFile, &cda, sizeof(cda), &cbRead, NULL);
	CloseHandle (hFile);

    //
    // Make sure its a RIFF CDDA file
    //
    if ( (cda.dwRIFF != RIFF_RIFF) || (cda.dwCDDA != RIFF_CDDA) ) {
	return FALSE;
    }

    //
    // Make sure that we have this disc loaded.
    //
    for ( i = 0; i < g_NumCdDevices; i++ ) {

	if (g_Devices[i]->CdInfo.Id == cda.DiscID) {

	    *piCdRomIndex = i;
	    break;
	}
    }


    //
    // If we didn't map the drive OK return FALSE AND set the
    // returned CD-ROM index to -1 but only if the caller asked us
    // to complain about an incorrect CD being inserted in the drive.
    //
    if ( i == g_NumCdDevices ) {

	if (!fQuiet) {
	    AskUserToInsertCorrectDisc(cda.DiscID);
	    *piCdRomIndex = -1;
	}
	return FALSE;
    }

    *piTrackIndex = cda.wTrack - 1;

    return TRUE;
}


/*****************************Private*Routine******************************\
* AppendTrackToPlayList
*
* Appends the TRACK_PLAY record pointed to by pAppend to the end of the
* double linked list pointed to by pHead.
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
AppendTrackToPlayList(
    PTRACK_PLAY pHead,
    PTRACK_PLAY pAppend
    )
{
    PTRACK_PLAY pp = pHead;

    while (pp->nextplay != NULL) {
	pp = pp->nextplay;
    }

    pp->nextplay = pAppend;
    pAppend->prevplay = pp;
    pAppend->nextplay = NULL;

}


/*****************************Private*Routine******************************\
* FindMostSuitableDrive
*
* Tries to determine the best drive to make the current drive.  Returns the
* drive.
*
* We should choose the first disc that is playing if any are playing.
*
* Else we should choose the first disc with a music disk in it if there
* any drives with music discs in them.
*
* Else we should chose the first drive that is available if any of the
* drives are available.
*
* Else just choose the first (ie. zeroth) drive.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int
FindMostSuitableDrive(
    void
    )
{
    int     iDisc;

    /*
    ** Check for a playing drive
    */
    for ( iDisc = 0; iDisc < g_NumCdDevices; iDisc++ ) {

	if ( g_Devices[iDisc]->State & (CD_PLAYING | CD_PAUSED) ) {
	    return iDisc;
	}
    }

    /*
    ** Check for a drive with a music disk in it
    */
    for ( iDisc = 0; iDisc < g_NumCdDevices; iDisc++ ) {

	if ( g_Devices[iDisc]->State & CD_LOADED ) {
	    return iDisc;
	}
    }

    /*
    ** Check for a drive that is not in use
    */
    for ( iDisc = 0; iDisc < g_NumCdDevices; iDisc++ ) {

	if ( (g_Devices[iDisc]->State & (CD_BEING_SCANNED | CD_IN_USE)) == 0 ) {
	    return iDisc;
	}
    }

    return 0;
}


/*****************************Private*Routine******************************\
* AskUserToInsertCorrectDisc
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
AskUserToInsertCorrectDisc(
    DWORD dwID
    )
{
    TCHAR   szSection[10];
    TCHAR   szMsgBoxTitle[32];
    TCHAR   szDiskTitle[TITLE_LENGTH];
    TCHAR   szArtistName[ARTIST_LENGTH];
    TCHAR   szFormat[STR_MAX_STRING_LEN];
    TCHAR   szText[STR_MAX_STRING_LEN + TITLE_LENGTH];


    /*
    ** Try to find the disk title in the cdplayer disk database.
    */
    wsprintf( szSection, g_szSectionF, dwID );
    GetPrivateProfileString( szSection, g_szTitle, g_szNothingThere,
			     szDiskTitle, TITLE_LENGTH, g_IniFileName );

    /*
    ** If the disk title was found in the database display it.
    */
    if (_tcscmp(szDiskTitle, g_szNothingThere) != 0) {

	TCHAR szUnknown[64];

	_tcscpy( szUnknown, IdStr(STR_UNKNOWN_ARTIST) );
	GetPrivateProfileString( szSection, g_szArtist, szUnknown,
				 szArtistName, ARTIST_LENGTH, g_IniFileName );

	_tcscpy( szFormat, IdStr(STR_DISK_NOT_THERE_K) );
	wsprintf(szText, szFormat, szDiskTitle, szArtistName);
    }
    else {

	_tcscpy( szText, IdStr(STR_DISK_NOT_THERE) );
    }


    //
    // If CD Player is minimized make sure it is restored
    // before displaying the MessageBox
    //
    if (IsIconic(g_hwndApp)) {

	WINDOWPLACEMENT wndpl;

	wndpl.length = sizeof(WINDOWPLACEMENT);
	GetWindowPlacement(g_hwndApp, &wndpl);
	wndpl.showCmd = SW_RESTORE;
	SetWindowPlacement(g_hwndApp, &wndpl);
    }

    _tcscpy( szMsgBoxTitle,  IdStr(STR_CDPLAYER) );
    MessageBox( g_hwndApp, szText, szMsgBoxTitle,
		MB_SETFOREGROUND | MB_ICONINFORMATION | MB_APPLMODAL | MB_OK);
}


#ifndef USE_IOCTLS
BOOL CheckMCICDA (TCHAR chDrive)
{
    DWORD cchLen;
    DWORD dwResult;
    DWORD dwErr;
    CDHANDLE hCD;
    TCHAR szPath[MAX_PATH];
    TCHAR szText[512];
    TCHAR szTitle[MAX_PATH];

    // Make sure the mcicda.dll exists
    cchLen = NUMELEMS(szPath);
    dwResult = SearchPath (NULL, TEXT ("mcicda.dll"), NULL,
			   cchLen, szPath, NULL);
    if ((! dwResult) || 
	    (0xFFFFFFFF == GetFileAttributes (szPath)))
    {
	    // Give Missing MCICDA.DLL error message
	    GetSystemDirectory (szPath, cchLen);

	    _tcscpy( szTitle, IdStr( STR_MCICDA_MISSING ) );
	    wsprintf (szText, szTitle, szPath);
	    _tcscpy( szTitle, IdStr( STR_CDPLAYER ) );
	
	    MessageBox( NULL, szText, szTitle,
				MB_APPLMODAL | MB_ICONINFORMATION |
				MB_OK | MB_SETFOREGROUND );
	    return FALSE;
    }

    // Make sure mcicda.dll service is up and running
    hCD = OpenCdRom (chDrive, &dwErr);
    if (! hCD)
    {
	    // Error loading media device driver.
	    _tcscpy( szText, IdStr( STR_MCICDA_NOT_WORKING ) );
	    _tcscpy( szTitle, IdStr( STR_CDPLAYER ) );
    
	    MessageBox( NULL, szText, szTitle,
				MB_APPLMODAL | MB_ICONINFORMATION |
				MB_OK | MB_SETFOREGROUND );
	    return FALSE;
    }

    // Close Device
    CloseCdRom (hCD);
    return TRUE;
}
#endif // ! USE_IOCTLS


#if DBG
/******************************Public*Routine******************************\
* CDAssert
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CDAssert(
    LPSTR x,
    LPSTR file,
    int line
    )
{
    char    buff[128];

    wsprintfA( buff, "%s \nat line %d of %s", x, line, file );
    MessageBoxA( NULL, buff, "Assertion Failure:", MB_APPLMODAL | MB_OK );
}

/******************************Public*Routine******************************\
* dprintf
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
dprintf(
    char *lpszFormat,
    ...
    )
{
    char buf[512];
    UINT n;
    va_list va;
    static int iPrintOutput = -1;

    if (iPrintOutput == -1) {
	iPrintOutput = GetProfileInt( TEXT("MMDEBUG"), TEXT("CdPlayer"), 0);
    }

    if (iPrintOutput) {

	n = wsprintfA(buf, "CdPlayer: <%d>", GetCurrentThreadId() );

	va_start(va, lpszFormat);
	n += wvsprintfA(buf+n, lpszFormat, va);
	va_end(va);

	buf[n++] = '\n';
	buf[n] = 0;
	OutputDebugStringA(buf);
    }

}
#endif // End #ifdef DBG

/*****************************Private*Routine******************************\
* GetMenuLine
*
* This function returns the number of menubar lines.
*
* History:
* dd-mm-95 -
*
\**************************************************************************/
WORD
GetMenuLine(
    HWND hWnd
    )
{
    RECT    rcWindow, rcClient;
    WORD    HeightDiff;
    WORD    MenuNumLine;

    GetWindowRect(hWnd, &rcWindow);
    GetClientRect(hWnd, &rcClient);
    HeightDiff = (rcWindow.bottom - rcWindow.top) - rcClient.bottom
		- GetSystemMetrics(SM_CYCAPTION);
    MenuNumLine = (WORD)ceil((HeightDiff / GetSystemMetrics(SM_CYMENU)));
    if (MenuNumLine > 1) {
	HeightDiff -= MenuNumLine - 1;
	MenuNumLine = (WORD)ceil((HeightDiff / GetSystemMetrics(SM_CYMENU)));
    }

    return MenuNumLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\cdplayer.h ===
/******************************Module*Header*******************************\
* Module Name: cdplayer.h
*
*
*
*
* Created: dd-mm-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
//#ifdef CHICAGO
#include <shellapi.h>
//#endif


/* -------------------------------------------------------------------------
** Replace the WM_MENUSELECT message craker because it contains a bug.
** -------------------------------------------------------------------------
*/
#ifdef HANDLE_WM_MENUSELECT
#undef HANDLE_WM_MENUSELECT
#define HANDLE_WM_MENUSELECT(hwnd, wParam, lParam, fn)                  \
    ((fn)( (hwnd), (HMENU)(lParam),                                     \
           (UINT)LOWORD(wParam), NULL, (UINT)HIWORD(wParam)), 0L)
#endif

#ifndef NUMELEMS
    #define NUMELEMS(a) (sizeof((a))/sizeof((a)[0]))
#endif // NUMELEMS


#define NUM_OF_CONTROLS (IDC_CDPLAYER_LAST - IDC_CDPLAYER_FIRST + 1)
#define NUM_OF_BUTTONS  (IDC_BUTTON8 - IDC_BUTTON1 + 1)

#define INDEX( _x_ )    ((_x_) - IDC_CDPLAYER_FIRST)

#if DBG

void
dprintf(
    char *lpszFormat,
    ...
    );
void CDAssert( LPSTR x, LPSTR file, int line );
#undef ASSERT
#define ASSERT(_x_) if (!(_x_))  CDAssert( #_x_, __FILE__, __LINE__ )

#else

#undef ASSERT
#define ASSERT(_x_)

#endif

#define WM_CDPLAYER_MSG_BASE        (WM_USER + 0x1000)

#define WM_NOTIFY_CDROM_COUNT       (WM_CDPLAYER_MSG_BASE)
#define WM_NOTIFY_TOC_READ          (WM_CDPLAYER_MSG_BASE+1)

#define HEARTBEAT_TIMER_ID          0x3243
#ifdef DAYTONA
#define HEARTBEAT_TIMER_RATE        250         /* 4 times a second */
#else
#define HEARTBEAT_TIMER_RATE        500         /* 2 times a second */
#endif

#define SKIPBEAT_TIMER_ID           0x3245
#define SKIPBEAT_TIMER_RATE         200         /* 5  times a second */
#define SKIPBEAT_TIMER_RATE2        100         /* 10 times a second */
#define SKIPBEAT_TIMER_RATE3        50          /* 20 times a second */
#define SKIP_ACCELERATOR_LIMIT1     5           /* 5  seconds        */
#define SKIP_ACCELERATOR_LIMIT2     20          /* 20 seconds        */


#define FRAMES_PER_SECOND           75
#define FRAMES_PER_MINUTE           (60*FRAMES_PER_SECOND)


#define DISPLAY_UPD_LED             0x00000001
#define DISPLAY_UPD_TITLE_NAME      0x00000002
#define DISPLAY_UPD_TRACK_NAME      0x00000004
#define DISPLAY_UPD_TRACK_TIME      0x00000008
#define DISPLAY_UPD_DISC_TIME       0x00000010
#define DISPLAY_UPD_CDROM_STATE     0x00000020
#define DISPLAY_UPD_LEADOUT_TIME    0x80000000


#define INTRO_LOWER_LEN             5
#define INTRO_DEFAULT_LEN           10
#define INTRO_UPPER_LEN             15


//  Audio Play Files consist completely of this header block.  These
//  files are readable in the root of any audio disc regardless of
//  the capabilities of the drive.
//
//  The "Unique Disk ID Number" is a calculated value consisting of
//  a combination of parameters, including the number of tracks and
//  the starting locations of those tracks.
//
//  Applications interpreting CDDA RIFF files should be advised that
//  additional RIFF file chunks may be added to this header in the
//  future in order to add information, such as the disk and song title.

#define RIFF_RIFF 0x46464952
#define RIFF_CDDA 0x41444443

typedef struct {
    DWORD   dwRIFF;         // 'RIFF'
    DWORD   dwSize;         // Chunk size = (file size - 8)
    DWORD   dwCDDA;         // 'CDDA'
    DWORD   dwFmt;          // 'fmt '
    DWORD   dwCDDASize;     // Chunk size of 'fmt ' = 24
    WORD    wFormat;        // Format tag
    WORD    wTrack;         // Track number
    DWORD   DiscID;         // Unique disk id
    DWORD   lbnTrackStart;  // Track starting sector (LBN)
    DWORD   lbnTrackLength; // Track length (LBN count)
    DWORD   msfTrackStart;  // Track starting sector (MSF)
    DWORD   msfTrackLength; // Track length (MSF)
}   RIFFCDA;


BOOL
InitInstance(
    HANDLE hInstance
    );


BOOL CALLBACK
MainWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
CDPlay_OnInitDialog(
    HWND hwnd,
    HWND hwndFocus,
    LPARAM lParam
    );

void
CDPlay_OnInitMenuPopup(
    HWND hwnd,
    HMENU hMenu,
    UINT item,
    BOOL fSystemMenu
    );

#ifdef DAYTONA
void
CDPlay_OnPaint(
    HWND hwnd
    );
#endif

void
CDPlay_OnSysColorChange(
    HWND hwnd
    );

void
CDPlay_OnWinIniChange(
    HWND hwnd,
    LPCTSTR lpszSectionName
    );

LRESULT CALLBACK
SubClassedToolTips(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT
CDPlay_OnNotify(
    HWND hwnd,
    int idFrom,
    NMHDR *pnmhdr
    );

void
CDPlay_OnLButtonDown(
    HWND hwnd,
    BOOL fDoubleClick,
    int x,
    int y,
    UINT keyFlags
    );

UINT
CDPlay_OnNCHitTest(
    HWND hwnd,
    int x,
    int y
    );

BOOL
CDPlay_OnCopyData(
    HWND hwnd,
    PCOPYDATASTRUCT lpcpds
    );

BOOL
CDPlay_OnTocRead(
    int iDriveRead
    );

BOOL
CDPlay_OnDeviceChange(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam);

void
CDPlay_OnDropFiles(
    HWND hwnd,
    HDROP hdrop
    );

void
CDPlay_OnMenuSelect(
    HWND hwnd,
    HMENU hmenu,
    int item,
    HMENU hmenuPopup,
    UINT flags
    );

BOOL
CDPlay_OnDrawItem(
    HWND hwnd,
    const DRAWITEMSTRUCT *lpdis
    );

void
CDPlay_OnCommand(
    HWND hwnd,
    int id,
    HWND hwndCtl,
    UINT codeNotify
    );

void
CDPlay_OnDestroy(
    HWND hwnd
    );

BOOL
CDPlay_OnClose(
    HWND hwnd,
    BOOL fShuttingDown
    );

void
CDPlay_OnEndSession(
    HWND hwnd,
    BOOL fEnding
    );

void
CDPlay_OnSize(
    HWND hwnd,
    UINT state,
    int cx,
    int cy
    );

void
ShowStatusbar(
    void
    );

void
ShowToolbar(
    void
    );

void
ShowTrackInfo(
    void
    );

BOOL CALLBACK
ChildEnumProc(
    HWND hwndChild,
    LPARAM lp
    );

BOOL
CreateToolbarsAndStatusbar(
    HWND hwnd
    );

void
AdjustChildButtons(
    HWND hwnd
    );

void
FatalApplicationError(
    INT uIdStringResource,
    ...
    );

void
LED_ToggleDisplayFont(
    HWND hwnd,
    BOOL fFont
    );

LPTSTR
IdStr(
    int idResource
    );

void
CheckMenuItemIfTrue(
    HMENU hMenu,
    UINT idItem,
    BOOL flag
    );

void
ReadSettings(
    void
    );

void
UpdateToolbarButtons(
    void
    );

void
UpdateToolbarTimeButtons(
    void
    );

BOOL
LockTableOfContents(
    int cdrom
    );

BOOL
LockALLTableOfContents(
    void
    );

LPVOID
AllocMemory(
    UINT uSize
    );

void
SetPlayButtonsEnableState(
    void
    );

void CALLBACK
HeartBeatTimerProc(
    HWND hwnd,
    UINT uMsg,
    UINT idEvent,
    DWORD dwTime
    );

void CALLBACK
SkipBeatTimerProc(
    HWND hwnd,
    UINT uMsg,
    UINT idEvent,
    DWORD dwTime
    );

void
UpdateDisplay(
    DWORD Flags
    );

HBRUSH
Common_OnCtlColor(
    HWND hwnd,
    HDC hdc,
    HWND hwndChild,
    int type
    );

BOOL
Common_OnMeasureItem(
    HWND hwnd,
    MEASUREITEMSTRUCT *lpMeasureItem
    );

void
DrawTrackItem(
    HDC hdc,
    const RECT *r,
    DWORD item,
    BOOL selected
    );

void
DrawDriveItem(
    HDC   hdc,
    const RECT *r,
    DWORD item,
    BOOL  selected
    );

void
EnableToolTips(
    BOOL    fEnable
    );

void
CdPlayerAlreadyRunning(
    void
    );

void
CdPlayerStartUp(
    void
    );

void
CompleteCdPlayerStartUp(
    void
    );

BOOL
IsPlayOptionGiven(
    LPTSTR lpCmdLine
    );

BOOL
IsUpdateOptionGiven(
    LPTSTR lpCmdLine
    );

/* -------------------------------------------------------------------------
** Public Globals - Most of these should be treated as read only.
** -------------------------------------------------------------------------
*/
#ifndef GLOBAL
#define GLOBAL extern
#endif

GLOBAL HINSTANCE        g_hInst;
GLOBAL HWND             g_hwndApp;
GLOBAL HWND             g_hwndToolbar;
GLOBAL HWND             g_hwndStatusbar;
GLOBAL HWND             g_hwndControls[NUM_OF_CONTROLS];
GLOBAL BOOL             g_fStatusbarVisible;
GLOBAL BOOL             g_fToolbarVisible;
GLOBAL BOOL             g_fSelectedOrder;
GLOBAL BOOL             g_fSingleDisk;
GLOBAL BOOL             g_fIntroPlay;
GLOBAL BOOL             g_fContinuous;
GLOBAL BOOL             g_fSaveOnExit;
GLOBAL BOOL             g_fDisplayT;
GLOBAL BOOL             g_fDisplayTr;
GLOBAL BOOL             g_fDisplayDr;
GLOBAL BOOL             g_fMultiDiskAvailable;
GLOBAL BOOL             g_fIsIconic;
GLOBAL BOOL             g_fSmallLedFont;
GLOBAL BOOL             g_fToolTips;
GLOBAL BOOL             g_fStopCDOnExit;
GLOBAL BOOL             g_fPlay;

GLOBAL int              g_NumCdDevices;
GLOBAL int              g_LastCdrom;
GLOBAL int              g_CurrCdrom;
GLOBAL int              g_IntroPlayLength;

GLOBAL TCHAR            g_szArtistTxt[50];
GLOBAL TCHAR            g_szTitleTxt[50];
GLOBAL TCHAR            g_szUnknownTxt[50];
GLOBAL TCHAR            g_szTrackTxt[50];
GLOBAL TCHAR            g_szEmpty[];

GLOBAL BOOL             g_fFlashLed;

GLOBAL HBITMAP          g_hbmTrack;
GLOBAL HBITMAP          g_hbmInsertPoint;
GLOBAL HBITMAP          g_hbmEditBtns;

GLOBAL HFONT            g_hDlgFont;
GLOBAL HFONT            hLEDFontS;
GLOBAL HFONT            hLEDFontL;
GLOBAL LPSTR            g_lpCmdLine;

extern BOOL             g_fTrackInfoVisible;

GLOBAL CRITICAL_SECTION g_csTOCSerialize;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\commands.h ===
/******************************Module*Header*******************************\
* Module Name: commands.h
*
* Functions that execue the users commands.
*
*
* Created: dd-mm-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

void
CdPlayerEjectCmd(
    void
    );

void
CdPlayerPlayCmd(
    void
    );

void
CdPlayerPauseCmd(
    void
    );


void
CdPlayerStopCmd(
    void
    );

void
CdPlayerPrevTrackCmd(
    void
    );

void
CdPlayerNextTrackCmd(
    void
    );

void
CdPlayerSeekCmd(
    HWND    hwnd,
    BOOL    fStart,
    UINT    uDirection
    );

void
CdDiskInfoDlg(
    void
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\commands.c ===
/******************************Module*Header*******************************\
* Module Name: commands.c
*
* Executes the users commands.
*
*
* Created: 18-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE

#include <windows.h>    /* required for all Windows applications */
#include <windowsx.h>
#include <string.h>
#include <malloc.h>
#include <stdarg.h>
#include <stdio.h>


#include "resource.h"
#include "cdplayer.h"
#include "ledwnd.h"
#include "cdapi.h"
#include "scan.h"
#include "trklst.h"
#include "database.h"
#include "commands.h"
#include "diskinfo.h"


/******************************Public*Routine******************************\
* CdPlayerEjectCmd
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerEjectCmd(
    void
    )
{
    if (g_State & CD_PAUSED) {
        g_State &= (~(CD_PAUSED_AND_MOVED | CD_PAUSED));
    }

    if (g_State & CD_PLAYING) {
        g_State &= ~CD_PLAYING;
        g_State |= CD_STOPPED;
    }

    if (EjectTheCdromDisc(g_CurrCdrom)) {
        g_State = (CD_NO_CD | CD_STOPPED);
        SetPlayButtonsEnableState();
        TimeAdjustInitialize( g_CurrCdrom );
    }
}


/******************************Public*Routine******************************\
* CdPlayerPlayCmd
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerPlayCmd(
    void
    )
{
    /*
    ** If we can't lock all the cdrom devices
    ** don't do anything.  The user will have press
    ** the play button again.
    */
    if ( LockALLTableOfContents() ) {

        if (g_State & CD_LOADED ) {

            if ((g_State & CD_STOPPED) && PlayCurrTrack( g_CurrCdrom )) {

                g_State &= ~CD_STOPPED;
                g_State |= CD_PLAYING;
            }
            else if ( g_State & CD_PAUSED ) {

                if ( g_State & CD_PAUSED_AND_MOVED ) {

                    g_State &= ~CD_PAUSED_AND_MOVED;
                    g_State |= CD_PLAYING;


                    if ( SeekToCurrSecond( g_CurrCdrom ) ) {

                        g_State &= ~CD_PAUSED;
                        g_State |= CD_PLAYING;
                    }
                    else {

                        g_State &= ~CD_PLAYING;
                    }

                }
                else if ( ResumeTheCdromDrive( g_CurrCdrom ) ) {

                    g_State &= ~CD_PAUSED;
                    g_State |= CD_PLAYING;
                }

                UpdateDisplay( DISPLAY_UPD_LED );
            }
        }
        else {
#if DBG
            dprintf( "Failing play because NO disc loaded" );
#endif
        }

        SetPlayButtonsEnableState();
        SetFocus( g_hwndControls[INDEX(IDM_PLAYBAR_PAUSE)] );
    }
}


/******************************Public*Routine******************************\
* CdPlayerPauseCmd
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerPauseCmd(
    void
    )
{
    /*
    ** If we can't lock all the cdrom devices
    ** don't do anything.  The user will have press
    ** the pause button again.
    */
    if ( LockALLTableOfContents() ) {

        if ( g_State & CD_PLAYING ) {

            if ( PauseTheCdromDrive( g_CurrCdrom ) ) {

                g_State &= ~CD_PLAYING;
                g_State |= CD_PAUSED;
            }
        }
        else if ( g_State & CD_PAUSED ) {

            if ( g_State & CD_PAUSED_AND_MOVED ) {

                g_State &= ~CD_PAUSED_AND_MOVED;
                g_State |= CD_PLAYING;


                if ( SeekToCurrSecond( g_CurrCdrom ) ) {

                    g_State &= ~CD_PAUSED;
                    g_State |= CD_PLAYING;
                }
                else {

                    g_State &= ~CD_PLAYING;
                }

            }
            else if ( ResumeTheCdromDrive( g_CurrCdrom ) ) {

                g_State &= ~CD_PAUSED;
                g_State |= CD_PLAYING;
            }

            UpdateDisplay( DISPLAY_UPD_LED );
        }

        SetPlayButtonsEnableState();
        SetFocus( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)] );
    }
}


/******************************Public*Routine******************************\
* CdPlayerStopCmd
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerStopCmd(
    void
    )
{
    /*
    ** If we can't lock all the cdrom devices
    ** don't do anything.  The user will have press
    ** the stop button again.
    */
    if ( LockALLTableOfContents() ) {

        BOOL bPlaying, bPaused;

        bPlaying = g_State & CD_PLAYING;
        bPaused  = g_State & CD_PAUSED;

        if ( (bPlaying || bPaused) && StopTheCdromDrive(g_CurrCdrom) ) {

            g_State &= ~(bPlaying ? CD_PLAYING : CD_PAUSED);
            g_State |= CD_STOPPED;

            /*
            ** Stop the current play operation and seek to the first
            ** playable track.
            */
            CURRTRACK(g_CurrCdrom) = FindFirstTrack( g_CurrCdrom );
            TimeAdjustSkipToTrack( g_CurrCdrom, CURRTRACK(g_CurrCdrom) );

            UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_TIME |
                           DISPLAY_UPD_TRACK_NAME );

            SetPlayButtonsEnableState();


            // Stop it again!!!
            // This is to prevent a strange bug with NEC 4x,6x players
            // Where a SEEK command in TimeAdjustSkipToTrack causes
            // The ejection mechanism to get locked.
            StopTheCdromDrive (g_CurrCdrom);

            
            /*
            ** The lines below are to fix a strange bug whereby the first
            ** time we set the focus after starting cdplayer and cdplayer is
            ** not the foreground window at time of the SetFocus cdplayer
            ** jumps to the foreground.  Most annoying!
            */

            if (GetForegroundWindow() == g_hwndApp) {
                SetFocus( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)] );
            }
        }
    }
}

/******************************Public*Routine******************************\
* CdPlayerPrevTrackCmd
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerPrevTrackCmd(
    void
    )
{
    /*
    ** If we can't lock all the cdrom devices
    ** don't do anything.  The user will have press
    ** the previous track button again.
    */
    if ( LockALLTableOfContents() ) {

        DWORD       dwOldState;
        int         i, j;
        PTRACK_PLAY tr;

        if ( (CDTIME(g_CurrCdrom).TrackCurSec == 0)
          && (CDTIME(g_CurrCdrom).TrackCurMin == 0) ) {

            dwOldState = g_State;
            i = g_CurrCdrom;

            tr = FindPrevTrack( g_CurrCdrom, g_fContinuous );

            if ( tr == NULL ) {

                /*
                ** If we were Paused or Playing fake a press on the
                ** "stop" button
                */
                if ( g_State & (CD_PLAYING | CD_PAUSED) ) {
                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
                                 WM_LBUTTONDOWN, 0, 0L );

                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
                                 WM_LBUTTONUP, 0, 0L );
                }
            }
            else {

                TimeAdjustSkipToTrack( g_CurrCdrom, tr );

                if ( (i != g_CurrCdrom) && (dwOldState & CD_PLAYING) ) {

                    j = g_CurrCdrom;
                    g_CurrCdrom = i;
                    SwitchToCdrom( j, FALSE );

                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)],
                                 WM_LBUTTONDOWN, 0, 0L );

                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)],
                                 WM_LBUTTONUP, 0, 0L );
                }
            }
        }
        else {

            TimeAdjustSkipToTrack( g_CurrCdrom, CURRTRACK( g_CurrCdrom ) );
        }
    }
}

/******************************Public*Routine******************************\
* CdPlayerNextTrackCmd
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerNextTrackCmd(
    void
    )
{
    /*
    ** If we can't lock all the cdrom devices
    ** don't do anything.  The user will have press
    ** the next track button again.
    */
    if ( LockALLTableOfContents() ) {

        DWORD       dwOldState;
        PTRACK_PLAY tr;

        dwOldState = g_State;

        tr = FindNextTrack( g_fContinuous );
        if ( tr == NULL ) {

            /*
            ** If the CD is playing fake a press on the "stop" button
            ** otherwise call the stop function directly.
            */
            if ( g_State & (CD_PLAYING | CD_PAUSED) ) {
                SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
                             WM_LBUTTONDOWN, 0, 0L );

                SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
                             WM_LBUTTONUP, 0, 0L );
            }
            else {

                /*
                ** Seek to the first playable track.
                */
                CURRTRACK(g_CurrCdrom) = FindFirstTrack( g_CurrCdrom );
                if (CURRTRACK(g_CurrCdrom) != NULL ) {

                    TimeAdjustSkipToTrack( g_CurrCdrom,
                                           CURRTRACK(g_CurrCdrom) );
                    UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_TIME |
                                   DISPLAY_UPD_TRACK_NAME );

                    SetPlayButtonsEnableState();
                    SetFocus( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)] );
                }

            }
        }
        else {

            if ( g_LastCdrom != g_CurrCdrom) {

                SwitchToCdrom( g_CurrCdrom,FALSE);
                TimeAdjustSkipToTrack( g_CurrCdrom, tr );

                if ( dwOldState & CD_PLAYING ) {

                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)],
                                 WM_LBUTTONDOWN, 0, 0L );

                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)],
                                 WM_LBUTTONUP, 0, 0L );
                }

            }
            else {

                TimeAdjustSkipToTrack( g_CurrCdrom, tr );
            }
        }
    }
}


/******************************Public*Routine******************************\
* CdPlayerSeekCmd
*
* How Seek works.
*
* When the user presses a seek button (forwards or backwards) this function
* gets called.  The cdplayer can be in three possible states:
*
*   1. Playing
*   2. Paused
*   3. Stopped
*
* In state 1 (playing) we pause the device and alter its global state flags
* to show that it was playing (CD_WAS_PLAYING).  This is so that we can
* return to the playing state when the user stops seeking.
*
* We then start a timer.  We always call the timer function, this means
* that we will allways skip one second no matter how quickly the user
* clicks the seek button.  The timer just increments (or decrements) the
* current play position according to the currrent play list.  When the users
* releases the seek button we stop the timer and resume playing if the
* CD_WAS_PLAYING flag was set.
*
* The interesting case is when we try to seek beyond the end of the current
* play list.  We detect this by testing the state of CURRTRACK(g_CurrCdrom).
* If NULL we have come to the end of the play list.  If we were paused or
* previously playing we fake a stop command by sending a WM_LBUTTONDOWN,
* WM_LBUTTONUP message pair to the stop button.   This causes the focus
* to be moved from the currently pressed seek button, which means that
* this function will get called BEFORE the CdPlayerStopCmd function.  So
* by the time CdPlayerStopCmd gets called the correct playing state of
* the cdrom device would have been restored by the code below.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CdPlayerSeekCmd(
    HWND    hwnd,
    BOOL    fStart,
    UINT    uDirection
    )
{
    UINT        rc;
    BOOL        frc;

    if ( fStart ) {

        if (g_State & CD_PLAYING) {

            g_State &= ~CD_PLAYING;
            g_State |= CD_WAS_PLAYING;

            PauseTheCdromDrive( g_CurrCdrom );
        }
        g_State |= CD_SEEKING;

        rc = SetTimer( hwnd, uDirection, SKIPBEAT_TIMER_RATE,
                       SkipBeatTimerProc );
        ASSERT(rc != 0);

        SkipBeatTimerProc( hwnd, WM_TIMER, uDirection, 0L );
    }
    else {

        g_State &= ~CD_SEEKING;

        if (g_State & CD_WAS_PLAYING) {

            g_State &= ~CD_WAS_PLAYING;
            g_State |= CD_PLAYING;
        }

        if ( g_State & CD_PAUSED ) {
            g_State |= CD_PAUSED_AND_MOVED;
        }
        else {

           SeekToCurrSecond( g_CurrCdrom );
        }

        frc = KillTimer( hwnd, uDirection );
        ASSERT(frc != FALSE);
    }

}



/******************************Public*Routine******************************\
* CdDiskInfoDlg
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
CdDiskInfoDlg(
    void
    )
{
     if (g_State & (CD_BEING_SCANNED | CD_IN_USE | CD_NO_CD | CD_DATA_CD_LOADED)) {
         MessageBeep (MB_ICONEXCLAMATION);
     } else {
         DialogBoxParam( g_hInst, MAKEINTRESOURCE(IDR_DISCINFODLG),
                         g_hwndApp, DiskInfoDlgProc, (LPARAM)g_CurrCdrom );
     } 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\diskinfo.h ===
/******************************Module*Header*******************************\
* Module Name: diskinfo.h
*
* Support for the diskinfo dialog box.
*
*
* Created: dd-mm-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#define LIST_CHAR_WIDTH 19

BOOL
DlgDiskInfo_OnInitDialog(
    HWND hwnd,
    HWND hwndFocus,
    LPARAM lParam
    );

BOOL CALLBACK
DiskInfoDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

void
DlgDiskInfo_OnCommand(
    HWND hwnd,
    int id,
    HWND hwndCtl,
    UINT codeNotify
    );

BOOL
DlgDiskInfo_OnDrawItem(
    HWND hwnd,
    const DRAWITEMSTRUCT *lpdis
    );

void
DlgDiskInfo_OnDestroy(
    HWND hwnd
    );

void
InitForNewDrive(
    HWND hwnd
    );

void
DrawListItem(
    HDC hdc,
    const RECT *rItem,
    DWORD itemData,
    BOOL selected
    );

void
GrabTrackName(
    HWND hwnd,
    int tocindex
    );

void
UpdateTrackName(
    HWND hwnd,
    int index
    );

PTRACK_PLAY
ConstructPlayListFromListbox(
    void
    );

void
UpdateEntryFromDiskInfoDialog(
    DWORD dwDiskId,
    HWND hwnd
    );

void
WriteAllEntries(
    DWORD dwDiskId,
    HWND hwnd
    );

void
RemovePlayListSelection(
    HWND hDlg
    );

void
AddTrackListSelection(
    HWND hDlg,
    int iInsertPos
    );

void
MoveCopySelection(
    int iInsertPos,
    DWORD dwState
    );

void
CheckButtons(
    HWND hDlg
    );


BOOL
IsInListbox(
    HWND hDlg,
    HWND hwndListbox,
    POINT pt
    );

int
InsertIndex(
    HWND hDlg,
    POINT pt,
    BOOL bDragging
    );

BOOL
DlgDiskInfo_OnProcessDrop(
    HWND hwnd,
    HWND hwndDrop,
    HWND hwndSrc,
    POINT ptDrop,
    DWORD dwState
    );

BOOL
DlgDiskInfo_OnQueryDrop(
    HWND hwnd,
    HWND hwndDrop,
    HWND hwndSrc,
    POINT ptDrop,
    DWORD dwState
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\diskinfo.c ===
/******************************Module*Header*******************************\
* Module Name: diskinfo.c
*
* Support for the diskinfo dialog box.
*
*
* Created: 18-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE
#define NODRAGLIST

#include <windows.h>              /* required for all Windows applications */
#include <windowsx.h>
#include <string.h>
#include <malloc.h>
#include <stdarg.h>
#include <stdio.h>
#include <tchar.h>


#include "resource.h"
#include "cdplayer.h"
#include "ledwnd.h"
#include "cdapi.h"
#include "scan.h"
#include "trklst.h"
#include "database.h"
#include "diskinfo.h"
#include "dragdrop.h"
#include "literals.h"


/*
** This structure is used during the drag/drop copy/move operations.
*/
typedef struct {
    int     index;
    DWORD   dwData;
    TCHAR   chName[TRACK_TITLE_LENGTH];
} LIST_INFO;


int     dCdrom;         /* The ID of the physical cdrom drive being edited */
DWORD   dwDiskId;       /* The unique ID of the current disk being edited  */


HWND    hAvailWnd;      /* cached hwnd of the available tracks listbox     */
HWND    hPlayWnd;       /* cached hwnd of the play list listbox            */

int     CurrTocIndex;   /* Index into the available tracks listbox of the  */
                        /* track currently being edited.                   */

BOOL    fChanged;       /* Has the current track name changed.             */
HDC     hdcMem;         /* Temporary hdc used to draw the track bitmap.    */
BOOL    fPlaylistChanged;   /* Has the playlist been altered ?             */
BOOL    fTrackNamesChanged; /* Has the playlist been altered ?             */
UINT    g_DragMessage;      /* Message ID of drag drop interface           */
HCURSOR g_hCursorDrop;      /* Drops allowed cursor                        */
HCURSOR g_hCursorNoDrop;    /* Drops not allowed cursor                    */
HCURSOR g_hCursorDropDel;   /* Drop deletes the selection                  */
HCURSOR g_hCursorDropCpy;   /* Drop copies the selection                   */

/******************************Public*Routine******************************\
* DiskInfoDlgProc
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL CALLBACK
DiskInfoDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
#if WINVER >= 0x0400
#include "helpids.h"
    static const DWORD aIds[] = {
        IDC_STATIC_DRIVE,             IDH_CD_DRIVE_NAME,
        IDC_SJETEXT_DRIVE,            IDH_CD_DRIVE_NAME,
        IDC_STATIC_ARTIST,            IDH_CD_GET_ARTIST,
        IDC_EDIT_ARTIST,              IDH_CD_GET_ARTIST,
        IDC_STATIC_TITLE,             IDH_CD_GET_TITLE,
        IDC_EDIT_TITLE,               IDH_CD_GET_TITLE,
        IDC_STATIC_PLAY_LIST,         IDH_CD_PLAY_LISTBOX,
        IDC_LISTBOX_PLAY_LIST,        IDH_CD_PLAY_LISTBOX,
        IDC_ADD,                      IDH_CD_ADD,
        IDC_REMOVE,                   IDH_CD_REMOVE,
        IDC_CLEAR,                    IDH_CD_CLEAR,
        IDC_DEFAULT,                  IDH_CD_DEFAULT,
        IDC_STATIC_AVAILABLE_TRACKS,  IDH_CD_TRACK_LISTBOX,
        IDC_LISTBOX_AVAILABLE_TRACKS, IDH_CD_TRACK_LISTBOX,
        IDC_STATIC_TRACK,             IDH_CD_TRACK_NAME,
        IDC_EDIT_TRACK,               IDH_CD_TRACK_NAME,
        IDC_SETNAME,                  IDH_CD_SETNAME,
        0,                            0
    };
#endif

    LPDRAGMULTILISTINFO lpns;
    HWND                hwndDrop;

    /*
    ** Process any drag/drop notifications first.
    **
    ** wParam == The ID of the drag source.
    ** lParam == A pointer to a DRAGLISTINFO structure
    */
    if ( message == g_DragMessage ) {

        lpns = (LPDRAGMULTILISTINFO)lParam;
        hwndDrop = WindowFromPoint( lpns->ptCursor );

        switch ( lpns->uNotification ) {

        case DL_BEGINDRAG:
            return SetDlgMsgResult( hwnd, WM_COMMAND, TRUE );

        case DL_DRAGGING:
            return DlgDiskInfo_OnQueryDrop( hwnd, hwndDrop, lpns->hWnd,
                                            lpns->ptCursor, lpns->dwState  );

        case DL_DROPPED:
            return DlgDiskInfo_OnProcessDrop( hwnd, hwndDrop, lpns->hWnd,
                                              lpns->ptCursor, lpns->dwState );

        case DL_CANCELDRAG:
            InsertIndex( hwnd, lpns->ptCursor, FALSE );
            break;

        }
        return SetDlgMsgResult( hwnd, WM_COMMAND, FALSE );
    }

    switch ( message ) {

    HANDLE_MSG( hwnd, WM_INITDIALOG,        DlgDiskInfo_OnInitDialog );
    HANDLE_MSG( hwnd, WM_DRAWITEM,          DlgDiskInfo_OnDrawItem );
    HANDLE_MSG( hwnd, WM_COMMAND,           DlgDiskInfo_OnCommand );
    HANDLE_MSG( hwnd, WM_DESTROY,           DlgDiskInfo_OnDestroy );
    HANDLE_MSG( hwnd, WM_CTLCOLORDLG,       Common_OnCtlColor );
    HANDLE_MSG( hwnd, WM_CTLCOLORSTATIC,    Common_OnCtlColor );
    HANDLE_MSG( hwnd, WM_MEASUREITEM,       Common_OnMeasureItem );

#if WINVER >= 0x0400
    case WM_HELP:
        WinHelp( ((LPHELPINFO)lParam)->hItemHandle, g_HelpFileName,
                 HELP_WM_HELP, (DWORD)(LPVOID)aIds );
        break;

    case WM_CONTEXTMENU:
        WinHelp( (HWND)wParam, g_HelpFileName,
                 HELP_CONTEXTMENU, (DWORD)(LPVOID)aIds );
        break;
#endif

    default:
        return FALSE;
    }
}


/*****************************Private*Routine******************************\
* DlgDiskInfo_OnInitDialog
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
DlgDiskInfo_OnInitDialog(
    HWND hwnd,
    HWND hwndFocus,
    LPARAM lParam
    )
{
    HDC     hdc;
    UINT    num;

#ifdef DAYTONA
    if (g_hDlgFont) {

        /* Static edit field */
        SendDlgItemMessage( hwnd, IDC_SJETEXT_DRIVE,
                            WM_SETFONT, (WPARAM)(g_hDlgFont), 0L );
        /* Dynamic edit fields */
        SendDlgItemMessage( hwnd, IDC_EDIT_ARTIST,
                            WM_SETFONT, (WPARAM)(g_hDlgFont), 0L );
        SendDlgItemMessage( hwnd, IDC_EDIT_TITLE,
                            WM_SETFONT, (WPARAM)(g_hDlgFont), 0L );
        SendDlgItemMessage( hwnd, IDC_EDIT_TRACK,
                            WM_SETFONT, (WPARAM)(g_hDlgFont), 0L );

        /* Owner draw listboxes */
        SendDlgItemMessage( hwnd, IDC_LISTBOX_PLAY_LIST,
                            WM_SETFONT, (WPARAM)(g_hDlgFont), 0L );

        SendDlgItemMessage( hwnd, IDC_LISTBOX_AVAILABLE_TRACKS,
                            WM_SETFONT, (WPARAM)(g_hDlgFont), 0L );
    }
#endif


    dCdrom = (int)lParam;
    dwDiskId = g_Devices[ dCdrom ]->CdInfo.Id;
    g_DragMessage = InitDragMultiList();

    if (g_hCursorNoDrop == NULL) {
        g_hCursorNoDrop = LoadCursor(NULL, IDC_NO);
    }

    if (g_hCursorDrop == NULL) {
        g_hCursorDrop = LoadCursor(g_hInst, MAKEINTRESOURCE(IDR_DROP));
    }

    if (g_hCursorDropDel == NULL) {
        g_hCursorDropDel = LoadCursor(g_hInst, MAKEINTRESOURCE(IDR_DROPDEL));
    }

    if (g_hCursorDropCpy == NULL) {
        g_hCursorDropCpy = LoadCursor(g_hInst, MAKEINTRESOURCE(IDR_DROPCPY));
    }

    /*
    ** Cache the two listbox window handles.
    */
    hPlayWnd = GetDlgItem( hwnd, IDC_LISTBOX_PLAY_LIST );
    hAvailWnd = GetDlgItem( hwnd, IDC_LISTBOX_AVAILABLE_TRACKS );

    hdc = GetDC( hwnd );
    hdcMem = CreateCompatibleDC( hdc );
    ReleaseDC( hwnd, hdc );

    SelectObject( hdcMem, g_hbmTrack );
    InitForNewDrive( hwnd );

    /*
    ** Set the maximum characters allowed in the edit field to 1 less than
    ** the space available in the TRACK_INF and ENTRY structures.
    */
    SendDlgItemMessage( hwnd, IDC_EDIT_ARTIST, EM_LIMITTEXT, ARTIST_LENGTH - 1, 0 );
    SendDlgItemMessage( hwnd, IDC_EDIT_TITLE, EM_LIMITTEXT, TITLE_LENGTH - 1, 0 );
    SendDlgItemMessage( hwnd, IDC_EDIT_TRACK, EM_LIMITTEXT, TRACK_TITLE_LENGTH - 1, 0 );


    MakeMultiDragList( hPlayWnd );
    MakeMultiDragList( hAvailWnd );

    num = ListBox_GetCount( hPlayWnd );

    if ( num == 0 ) {

        EnableWindow( GetDlgItem( hwnd, IDC_CLEAR ),  FALSE );
    }

    EnableWindow( GetDlgItem( hwnd, IDC_ADD ), FALSE );
    EnableWindow( GetDlgItem( hwnd, IDC_REMOVE ), FALSE );

    fTrackNamesChanged = fPlaylistChanged = FALSE;
    return TRUE;
}


/*****************************Private*Routine******************************\
* DlgDiskInfo_OnCommand
*
* This is where most of the UI processing takes place.  Basically the dialog
* serves two purposes.
*
*   1. Track name editing
*   2. Play list selection and editing.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
DlgDiskInfo_OnCommand(
    HWND hwnd,
    int id,
    HWND hwndCtl,
    UINT codeNotify
    )
{
    int     items[100];
    int     i, num, index;
    int     iCurrTrack;
    TCHAR   s[TRACK_TITLE_LENGTH];
    DWORD   dwData;


    switch ( id ) {

    case IDC_LISTBOX_PLAY_LIST:
        if ( codeNotify == LBN_DBLCLK ) {

            RemovePlayListSelection( hwnd );
        }

        EnableWindow( GetDlgItem( hwnd, IDC_REMOVE ),
                      ListBox_GetSelItems( hwndCtl, 1, items ) == 1 );
        break;

    case IDC_LISTBOX_AVAILABLE_TRACKS:
        /*
        ** If the selection in the possible tracks listbox
        ** changes, we need to reset which track is being edited
        ** down below for the track title editbox.
        */
        if ( codeNotify == LBN_SELCHANGE ) {


            /*
            ** Update currently displayed track in track name
            ** field - also, enable/diable the add button
            ** depending on whether there are any items selected.
            */
            if ( ListBox_GetSelItems( hwndCtl, 1, items ) == 1 ) {
                UpdateTrackName( hwnd, items[0] );
                EnableWindow( GetDlgItem( hwnd, IDC_ADD ), TRUE );
            }
            else {
                EnableWindow( GetDlgItem( hwnd, IDC_ADD ), FALSE );
            }
        }
        else if ( codeNotify == LBN_DBLCLK ) {

            AddTrackListSelection( hwnd, ListBox_GetCount( hPlayWnd ) );
        }
        break;


    case IDC_EDIT_TRACK:
        switch ( codeNotify ) {

        case EN_CHANGE:
            fChanged = TRUE;
            break;

        case EN_KILLFOCUS:
            SendMessage( hwnd, DM_SETDEFID, IDOK, 0L );
            break;

        case EN_SETFOCUS:
            SendMessage( hwnd, DM_SETDEFID, IDC_SETNAME, 0L );
            break;
        }
        break;


    case IDC_SETNAME:
        if ( fChanged ) {
            fTrackNamesChanged = TRUE;
            GrabTrackName( hwnd, CurrTocIndex );
        }

        CurrTocIndex++;
        if ( CurrTocIndex >= NUMTRACKS(dCdrom) ) {
            CurrTocIndex = 0;
        }

        ListBox_SetSel( hPlayWnd, FALSE, -1 );
        EnableWindow( GetDlgItem( hwnd, IDC_REMOVE ), FALSE );

        ListBox_SetSel( hAvailWnd, FALSE, -1 );
        ListBox_SelItemRange( hAvailWnd, TRUE, CurrTocIndex, CurrTocIndex );

        /*
        ** Display correct track in track field
        */
        UpdateTrackName( hwnd, CurrTocIndex );
        break;


    case IDC_ADD:
        AddTrackListSelection( hwnd, ListBox_GetCount( hPlayWnd ) );
        break;


    case IDC_CLEAR:
        /*
        ** Just wipe out the current play list from the play listbox.
        ** Don't forget to grey out the remove and clear buttons.
        */
        ListBox_ResetContent( hPlayWnd );
        SendMessage( hwnd, DM_SETDEFID, IDOK, 0L );
        SetFocus( GetDlgItem( hwnd, IDOK ) );
        CheckButtons( hwnd );
        fPlaylistChanged = TRUE;
        break;


    case IDC_REMOVE:
        RemovePlayListSelection( hwnd );
        SetFocus( GetDlgItem( hwnd, IDOK ) );
        SendMessage( hwnd, DM_SETDEFID, IDOK, 0L );
        EnableWindow( GetDlgItem( hwnd, IDC_REMOVE ),
                      ListBox_GetSelItems( hPlayWnd, 1, items ) == 1 );
        break;


    case IDC_DEFAULT:
        /*
        ** Clear the existing play list and then add the each item from the
        ** available tracks listbox maintaing the same order as the available
        ** tracks.
        */
        SetWindowRedraw( hPlayWnd, FALSE );

        ListBox_ResetContent( hPlayWnd );
        num = ListBox_GetCount( hAvailWnd );

        for ( i = 0; i < num; i++ ) {

            ListBox_GetText( hAvailWnd, i, s );
            dwData = ListBox_GetItemData( hAvailWnd, i );

            index = ListBox_AddString( hPlayWnd, s );
            ListBox_SetItemData( hPlayWnd, index, dwData );
        }

        SetWindowRedraw( hPlayWnd, TRUE );
        CheckButtons( hwnd );
        fPlaylistChanged = TRUE;
        break;


    case IDOK:
        /*
        ** Here is where we extract the current play list and
        ** available tracks list from the two list boxes.
        **
        ** If we can't lock the toc for this drive ignore the OK button click
        ** the user user will either try again or press cancel.
        **
        */
        if ( LockTableOfContents( dCdrom ) == FALSE ) {
            break;
        }

        /*
        ** OK, we've locked the toc for this drive.  Now we have to check that
        ** it still has the original disk inside it.  If the disks match
        ** we copy the strings from the available tracks list box straight
        ** it the track info structure for this cdrom and update the
        ** playlist.
        */
        if ( g_Devices[ dCdrom ]->CdInfo.Id == dwDiskId ) {


            PTRACK_INF  pt;
            PTRACK_PLAY ppPlay;
            PTRACK_PLAY pp;
            int m, s, mtemp, stemp;

            /*
            ** Take care of the track (re)naming function of the dialog
            ** box.
            */

            GetDlgItemText( hwnd, IDC_EDIT_TITLE, TITLE(dCdrom), TITLE_LENGTH );
            GetDlgItemText( hwnd, IDC_EDIT_ARTIST, ARTIST(dCdrom), ARTIST_LENGTH );


            num = ListBox_GetCount( hAvailWnd );
            pt = ALLTRACKS( dCdrom );

            for ( i = 0; (pt != NULL) && (i < num); i++ ) {

                ListBox_GetText( hAvailWnd, i, pt->name );
                pt = pt->next;
            }

            /*
            ** make sure that we read all the tracks from the listbox.
            */
            ASSERT( i == num );


            /*
            ** Now take care of the playlist editing function of the
            ** dialog box.
            */
            if (fPlaylistChanged) {

                if ( CURRTRACK(dCdrom) != NULL ) {
                    iCurrTrack = CURRTRACK(dCdrom)->TocIndex;
                }
                else {
                    iCurrTrack = -1;
                }


                /*
                ** Get the new play list from the listbox and
                ** look for the previous track in the new play list.
                */
                ppPlay = ConstructPlayListFromListbox();
                for ( pp = ppPlay; pp != NULL; pp = pp->nextplay ) {

                    if ( pp->TocIndex == iCurrTrack ) {
                        break;
                    }
                }

                /*
                ** If the track was not found in the new track list and this
                ** cd is currently playing then stop it.
                */
                if ( (pp == NULL) && (STATE(dCdrom) & (CD_PLAYING | CD_PAUSED)) ) {

                    SendDlgItemMessage( g_hwndApp, IDM_PLAYBAR_STOP,
                                        WM_LBUTTONDOWN, 1, 0 );

                    SendDlgItemMessage( g_hwndApp, IDM_PLAYBAR_STOP,
                                        WM_LBUTTONUP, 1, 0 );
                }

                /*
                ** Swap over the playlists.
                */
                ErasePlayList( dCdrom );
                EraseSaveList( dCdrom );
                PLAYLIST(dCdrom) = ppPlay;
                SAVELIST(dCdrom) = CopyPlayList( PLAYLIST(dCdrom) );


                /*
                ** Set the current track.
                */
                if ( pp != NULL ) {

                    CURRTRACK( dCdrom ) = pp;
                }
                else {

                    CURRTRACK( dCdrom ) = PLAYLIST( dCdrom );
                }

                /*
                ** If we were previously in "Random" mode shuffle the new
                ** playlist.
                */
                if (!g_fSelectedOrder) {
                    ComputeSingleShufflePlayList( dCdrom );
                }


                /*
                ** If we were playing, we need to synchronize to make sure
                ** we are playing where we should.
                */
				SyncDisplay();
				            

                /*
                ** Compute PLAY length
                */
                m = s = 0;
                for( pp = PLAYLIST(dCdrom); pp != NULL; pp = pp->nextplay ) {

                    FigureTrackTime( dCdrom, pp->TocIndex, &mtemp, &stemp );

                    m+=mtemp;
                    s+=stemp;

                    pp->min = mtemp;
                    pp->sec = stemp;
                }


                m += (s / 60);
                s =  (s % 60);

                CDTIME(dCdrom).TotalMin = m;
                CDTIME(dCdrom).TotalSec = s;

                /*
                ** Make sure that the track time displayed in the LED and the
                ** status bar is correct.  If we have a current track and the
                ** CD is playing or paused then everything is OK.  Otherwise, we
                ** have to reset the track times.
                */
                if ( CURRTRACK( dCdrom ) != NULL ) {

                    if ( STATE(dCdrom) & CD_STOPPED ) {

                        CDTIME(g_CurrCdrom).TrackTotalMin = CURRTRACK( dCdrom )->min;
                        CDTIME(g_CurrCdrom).TrackRemMin   = CURRTRACK( dCdrom )->min;

                        CDTIME(g_CurrCdrom).TrackTotalSec = CURRTRACK( dCdrom )->sec;
                        CDTIME(g_CurrCdrom).TrackRemSec   = CURRTRACK( dCdrom )->sec;
                    }

                }
                else {

                    CDTIME(g_CurrCdrom).TrackTotalMin = 0;
                    CDTIME(g_CurrCdrom).TrackRemMin   = 0;
                    CDTIME(g_CurrCdrom).TrackTotalSec = 0;
                    CDTIME(g_CurrCdrom).TrackRemSec   = 0;
                }



                UpdateDisplay( DISPLAY_UPD_DISC_TIME );
            }


            /*
            ** Now force repaints of the relevant field in the main application
            */
            InvalidateRect(GetDlgItem(g_hwndApp, IDC_ARTIST_NAME), NULL, FALSE);
            SetDlgItemText( g_hwndApp, IDC_TITLE_NAME, TITLE(dCdrom) );
            ResetTrackComboBox( dCdrom );
        }

        /*
        ** Now save the tracks to disk.
        */
        UpdateEntryFromDiskInfoDialog( dwDiskId, hwnd );
        SetPlayButtonsEnableState();



    case IDCANCEL:
        EndDialog( hwnd, id );
        break;
    }
}


/*****************************Private*Routine******************************\
* DlgDiskInfo_OnDrawItem
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
DlgDiskInfo_OnDrawItem(
    HWND hwnd,
    const DRAWITEMSTRUCT *lpdis
    )
{
    if ( (lpdis->itemAction & ODA_DRAWENTIRE) ||
         (lpdis->itemAction & ODA_SELECT) ) {

        DrawListItem( lpdis->hDC, &lpdis->rcItem,
                      lpdis->itemData, lpdis->itemState & ODS_SELECTED );

        if ( lpdis->itemState & ODS_FOCUS ) {
            DrawFocusRect( lpdis->hDC, &lpdis->rcItem );
        }
        return TRUE;
    }
    return FALSE;
}


/*****************************Private*Routine******************************\
* DlgDiskInfo_OnDestroy
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
DlgDiskInfo_OnDestroy(
    HWND hwnd
    )
{
    if ( hdcMem ) {
        DeleteDC( hdcMem );
    }

}


/*****************************Private*Routine******************************\
* InitForNewDrive
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
InitForNewDrive(
    HWND hwnd
    )
{

    int         index;
    PTRACK_INF  t;
    PTRACK_PLAY t1;
    TCHAR       s[50];

    SetDlgItemText( hwnd, IDC_EDIT_TITLE,  TITLE(dCdrom) );
    SetDlgItemText( hwnd, IDC_EDIT_ARTIST, ARTIST(dCdrom) );
    SetDlgItemText( hwnd, IDC_EDIT_TRACK,  ALLTRACKS(dCdrom)->name );

    wsprintf( s, TEXT("\\Device\\CdRom%d  <%c:>"),
              dCdrom, g_Devices[dCdrom]->drive );
    SetDlgItemText( hwnd, IDC_SJETEXT_DRIVE, s );

    /*
    ** Fill in current tracks.  This list contains all the available tracks
    ** in the correct track order.
    */
    SetWindowRedraw( hAvailWnd, FALSE );
    ListBox_ResetContent( hAvailWnd );

    for( t = ALLTRACKS(dCdrom); t != NULL; t = t->next ) {

        index = ListBox_AddString( hAvailWnd, t->name );
        ListBox_SetItemData( hAvailWnd, index, t->TocIndex );
    }
    SetWindowRedraw( hAvailWnd, TRUE );


    /*
    ** Fill in current play list
    */
    SetWindowRedraw( hPlayWnd, FALSE );
    ListBox_ResetContent( hPlayWnd );

    for( t1 = SAVELIST(dCdrom); t1 != NULL; t1 = t1->nextplay ) {

        t = FindTrackNodeFromTocIndex( t1->TocIndex, ALLTRACKS(dCdrom) );

        if ( t != NULL ) {
            index = ListBox_AddString( hPlayWnd, t->name );
            ListBox_SetItemData( hPlayWnd, index, t->TocIndex );
        }
    }
    SetWindowRedraw( hPlayWnd, TRUE );

    /*
    ** Display correct track in track field and
    ** set CurrTocIndex to first entry in playlist listbox
    */
    UpdateTrackName( hwnd, 0 );
}



/*****************************Private*Routine******************************\
* DrawListItem
*
* This routine draws items in the PlayList and Available Tracks
* listboxes.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
DrawListItem(
    HDC hdc,
    const RECT *rItem,
    DWORD itemIndex,
    BOOL selected
    )
{
    DWORD       dwROP;
    SIZE        si;
    UINT        i;
    TCHAR       s[TRACK_TITLE_LENGTH];
    TCHAR       szDotDot[] = TEXT("... ");
    int         cxDotDot;


    /*
    ** Check selection status, and set up to draw correctly
    */
    if ( selected ) {

        SetBkColor( hdc, GetSysColor( COLOR_HIGHLIGHT ) );
        SetTextColor( hdc, GetSysColor( COLOR_HIGHLIGHTTEXT ) );
        dwROP = MERGEPAINT;

    }
    else {

        SetBkColor( hdc, GetSysColor(COLOR_WINDOW));
        SetTextColor( hdc, GetSysColor(COLOR_WINDOWTEXT));
        dwROP = SRCAND;
    }

    /*
    ** Get track string
    */
    ListBox_GetText( hAvailWnd, itemIndex, s );


    /*
    ** Do we need to munge track name (clip to listbox)?
    */
    GetTextExtentPoint( hdc, szDotDot, _tcslen( szDotDot ), &si );
    cxDotDot = si.cx;

    i = _tcslen( s ) + 1;
    do {
        GetTextExtentPoint( hdc, s, --i, &si );
    } while( si.cx > (rItem->right - cxDotDot - 20)  );


    /*
    ** Draw track name
    */
    ExtTextOut( hdc, rItem->left + 20, rItem->top, ETO_OPAQUE | ETO_CLIPPED,
                rItem, s, i, NULL );

    if ( _tcslen( s ) > i ) {

        ExtTextOut( hdc, rItem->left + si.cx + 20, rItem->top, ETO_CLIPPED,
                    rItem, szDotDot, _tcslen(szDotDot), NULL );
    }

    /*
    ** draw cd icon for each track
    */
    BitBlt( hdc, rItem->left, rItem->top, 14, 14, hdcMem, 0, 0, dwROP );
}


/*****************************Private*Routine******************************\
* GrabTrackName
*
* This routine reads the track name from the track name edit
* control and updates the screen and internal structures with the
* new track name.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
GrabTrackName(
    HWND hwnd,
    int tocindex
    )
{
    int         i, num;
    TCHAR       s[TRACK_TITLE_LENGTH];

    /*
    ** Get new title
    */
    GetDlgItemText( hwnd, IDC_EDIT_TRACK, s, TRACK_TITLE_LENGTH );


    /*
    ** Update the "track" list.
    */
    SetWindowRedraw( hAvailWnd, FALSE );
    ListBox_DeleteString( hAvailWnd, tocindex );
    ListBox_InsertString( hAvailWnd, tocindex, s );
    ListBox_SetItemData( hAvailWnd, tocindex, tocindex );
    SetWindowRedraw( hAvailWnd, TRUE );

    /*
    ** Redraw list entries with new title in playlist listbox...there
    ** can be more than one
    */
    SetWindowRedraw( hPlayWnd, FALSE );

    num = ListBox_GetCount( hPlayWnd );
    for( i = 0; i < num; i++ ) {

        if ( ListBox_GetItemData( hPlayWnd, i ) == tocindex ) {

            ListBox_DeleteString( hPlayWnd, i );
            ListBox_InsertString( hPlayWnd, i, s );
            ListBox_SetItemData( hPlayWnd, i, tocindex );
        }
    }
    SetWindowRedraw( hPlayWnd, TRUE );
    EnableWindow( GetDlgItem( hwnd, IDC_REMOVE ), FALSE );
}


/*****************************Private*Routine******************************\
* UpdateTrackName
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
UpdateTrackName(
    HWND hwnd,
    int index
    )
{
    TCHAR s[TRACK_TITLE_LENGTH];
    int iFirstTrack;


    /*
    ** Before using the FIRSTTRACK macro we have to check that we can
    ** lock the TOC and that the original disk is still in the drive.  If this
    ** is not the case "assume" that the first track is track 1.
    */
    if ( LockTableOfContents(dCdrom)
      && g_Devices[dCdrom]->CdInfo.Id == dwDiskId ) {

        iFirstTrack = FIRSTTRACK(dCdrom);
    }
    else {
        iFirstTrack = 1;
    }

    ListBox_GetText( hAvailWnd, index, s );

    SetDlgItemText( hwnd, IDC_EDIT_TRACK, s );
    wsprintf( s, IdStr( STR_TRACK1 ), index +  iFirstTrack);

    SetDlgItemText( hwnd, IDC_STATIC_TRACK, s  );
    SendMessage( GetDlgItem( hwnd, IDC_EDIT_TRACK ),
                 EM_SETSEL, 0, (LPARAM)-1 );

    CurrTocIndex = index;
    fChanged = FALSE;
}


/*****************************Private*Routine******************************\
* ConstructPlayListFromListbox
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
PTRACK_PLAY
ConstructPlayListFromListbox(
    void
    )
{
    int         num;
    int         i;
    int         mtemp, stemp;
    DWORD       dwData;
    PTRACK_PLAY t1, tend, tret;

    tret = tend = NULL;

    num = ListBox_GetCount( hPlayWnd );

    for ( i = 0; i < num; i++ ) {

        dwData = ListBox_GetItemData( hPlayWnd, i );

        t1 = AllocMemory( sizeof(TRACK_PLAY) );
        t1->TocIndex = dwData;
        t1->min = 0;
        t1->sec = 0;
        t1->nextplay = NULL;
        t1->prevplay = tend;

        if ( tret == NULL ) {

            tret = tend = t1;
        }
        else {

            tend->nextplay = t1;
            tend = t1;
        }
    }

    /*
    ** Compute play length
    */

    mtemp = stemp = 0;

    for( t1 = tret; t1 != NULL; t1 = t1->nextplay ) {

        FigureTrackTime( dCdrom, t1->TocIndex, &mtemp, &stemp );

        t1->min = mtemp;
        t1->sec = stemp;
    }


    return tret;
}



/*****************************Private*Routine******************************\
* UpdateEntryFromDiskInfoDialog
*
* Here we decide if we need to update the entire track record or just
* a portion of it.  This saves a lot of space in the cdplayer.ini file if the
* user only changes the artist name and disk title fields.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
UpdateEntryFromDiskInfoDialog(
    DWORD dwDiskId,
    HWND hwnd
    )
{
    if (fTrackNamesChanged) {
        WriteAllEntries( dwDiskId, hwnd );
    }
    else {

        TCHAR   Section[10];
        TCHAR   Buff[512];
        TCHAR   Name[128];

        wsprintf( Section, g_szSectionF, dwDiskId );

        /* Write entry type (always 1) */
        wsprintf( Buff, TEXT("%d"), 1 );
        WritePrivateProfileString(Section, g_szEntryType, Buff, g_IniFileName);

        /* Write artist name */
        GetDlgItemText( hwnd, IDC_EDIT_ARTIST, Name, ARTIST_LENGTH );
        wsprintf( Buff, TEXT("%s"), Name );
        WritePrivateProfileString(Section, g_szArtist, Buff, g_IniFileName);

        /* Write CD Title */
        GetDlgItemText( hwnd, IDC_EDIT_TITLE, Name, TITLE_LENGTH );
        wsprintf( Buff, TEXT("%s"), Name );
        WritePrivateProfileString(Section, g_szTitle, Buff, g_IniFileName);


        /* Write the number of tracks on the disc */
        wsprintf( Buff, TEXT("%d"), ListBox_GetCount( hAvailWnd ) );
        WritePrivateProfileString(Section, g_szNumTracks, Buff, g_IniFileName);


        /* Only write the playlist if it has actually changed */
        if (fPlaylistChanged) {

            LPTSTR  s, sSave;
            DWORD   dwData;
            int     i, num;

            num = ListBox_GetCount( hPlayWnd );
            sSave = s = AllocMemory( num * 4 * sizeof(TCHAR) );
            for ( i = 0; i <  num; i++ ) {

                dwData = ListBox_GetItemData( hPlayWnd, i );
                s += wsprintf( s, TEXT("%d "), dwData );

            }
            WritePrivateProfileString(Section, g_szOrder, sSave, g_IniFileName);

            /* Write number of tracks in current playlist */
            wsprintf( Buff, TEXT("%d"), num );
            WritePrivateProfileString(Section, g_szNumPlay, Buff, g_IniFileName);
            LocalFree( (HLOCAL)sSave );
        }
    }
}

/*****************************Private*Routine******************************\
* WriteAllEntries
*
*
* This monster updates the cdpayer database for the current disk it writes
* all the entries to the database.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
WriteAllEntries(
    DWORD dwDiskId,
    HWND hwnd
    )
{
    TCHAR       *Buffer;
    TCHAR       Section[10];
    TCHAR       Name[128];
    DWORD       dwData;
    LPTSTR      s;
    int         i;
    int         num;

    //
    // Construct ini file buffer, form of:
    //  EntryType = 1
    //     artist = artist name
    //      title = Title of disc
    //  numtracks = n
    //          0 = Title of track 1
    //          1 = Title of track 2
    //        n-1 = Title of track n
    //      order = 0 4 3 2 6 7 8 ... (n-1)
    //    numplay = # of entries in order list
    //

    Buffer = AllocMemory( 64000 * sizeof(TCHAR) );

    wsprintf( Section, g_szSectionF, dwDiskId );

    s = Buffer;
    num = ListBox_GetCount( hAvailWnd );

    //
    // I assume EntryType=1 means use the new hashing scheme
    //
    s += 1 + wsprintf( s, g_szEntryTypeF, 1 );


    //
    // Save the artists name.
    //
    GetDlgItemText( hwnd, IDC_EDIT_ARTIST, Name, ARTIST_LENGTH );
    s += 1 + wsprintf( s, g_szArtistF, Name );


    //
    // Save the CD Title
    //
    GetDlgItemText( hwnd, IDC_EDIT_TITLE, Name, TITLE_LENGTH );
    s += 1 + wsprintf( s, g_szTitleF, Name );

    s += 1 + wsprintf( s, g_szNumTracksF, num );


    //
    // Save each track name
    //
    for ( i = 0; i < num; i++ ) {

        ListBox_GetText( hAvailWnd, i, Name );
        dwData = ListBox_GetItemData( hAvailWnd, i );

        s += 1 + wsprintf( s, TEXT("%d=%s"), dwData, Name );
    }


    //
    //  Save the play order
    //
    num = ListBox_GetCount( hPlayWnd );
    s += wsprintf( s, g_szOrderF );
    for ( i = 0; i <  num; i++ ) {

        dwData = ListBox_GetItemData( hPlayWnd, i );
        s += wsprintf( s, TEXT("%d "), dwData );

    }
    s += 1;


    //
    // Save the number of tracks in the play list
    //
    s += 1 + wsprintf( s, g_szNumPlayF, num );


    //
    // Just make sure there are NULLs at end of buffer
    //
    wsprintf( s, g_szThreeNulls );


    //
    // Try writing buffer into ini file
    //
    WritePrivateProfileSection( Section, Buffer, g_IniFileName );

    LocalFree( (HLOCAL)Buffer );
}


/*****************************Private*Routine******************************\
* Lbox_OnQueryDrop
*
* Is a mouse drop allowed at the current mouse position.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL
DlgDiskInfo_OnQueryDrop(
    HWND hwnd,
    HWND hwndDrop,
    HWND hwndSrc,
    POINT ptDrop,
    DWORD dwState
    )
{
    int     index;

    index = InsertIndex( hwnd, ptDrop, TRUE );

    if ( index >= 0  ) {

        if ( (hwndSrc == hPlayWnd) && (dwState == DL_COPY) ) {

            SetCursor( g_hCursorDropCpy );
        }
        else {

            SetCursor( g_hCursorDrop );
        }
    }
    else if ( IsInListbox( hwnd, hAvailWnd, ptDrop ) ) {

        if ( hwndSrc == hPlayWnd ) {

            SetCursor( g_hCursorDropDel );
        }
        else {

            SetCursor( g_hCursorDrop );
        }
    }
    else {

        SetCursor( g_hCursorNoDrop );
    }

    SetWindowLong( hwnd, DWL_MSGRESULT, FALSE );
    return TRUE;
}


/*****************************Private*Routine******************************\
* Lbox_OnProcessDrop
*
* Process mouse drop(ping)s here.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL
DlgDiskInfo_OnProcessDrop(
    HWND hwnd,
    HWND hwndDrop,
    HWND hwndSrc,
    POINT ptDrop,
    DWORD dwState
    )
{

    int     index;


    /*
    ** Are we dropping on the play list window ?
    */
    if ( hwndDrop == hPlayWnd ) {

        index = InsertIndex( hwnd, ptDrop, FALSE );

        /*
        ** Is it OK to drop here ?
        */
        if ( index >= 0 ) {

            /*
            ** Is this an inter or intra window drop
            */
            if ( hwndSrc == hAvailWnd ) {

                AddTrackListSelection( hwnd, index );
            }

            /*
            ** An intra window drop !!
            */
            else if ( hwndSrc == hPlayWnd ) {

                MoveCopySelection( index, dwState );
            }
        }
    }

    /*
    ** Are we dropping on the available tracks list box and the source window
    ** was the play listbox
    */

    else if ( hwndDrop == hAvailWnd && hwndSrc == hPlayWnd ) {

        RemovePlayListSelection( hwnd );
    }

    SetWindowLong( hwnd, DWL_MSGRESULT, FALSE );
    return TRUE;
}



/*****************************Private*Routine******************************\
* InsertIndex
*
* If the mouse is over the playlist window return what would be the current
* insertion position, otherwise return -1.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
int
InsertIndex(
    HWND hDlg,
    POINT pt,
    BOOL bDragging
    )
{
    int     nItem;
    int     nCount;

    nCount = ListBox_GetCount( hPlayWnd );
    nItem = LBMultiItemFromPt( hPlayWnd, pt, bDragging );

    /*
    ** If the mouse is not over any particular list item, but it is inside
    ** the client area of the listbox just append to end of the listbox.
    */

    if ( nItem == -1 ) {

        if ( IsInListbox( hDlg, hPlayWnd, pt ) ) {
            nItem = nCount;
        }
    }

    /*
    ** Otherwise, if the mouse is over a list item and there is
    ** at least one item in the listbox determine if the inertion point is
    ** above or below the current item.
    */

    else if ( nItem > 0 && nCount > 0 ) {

        long    pt_y;
        RECT    rc;

        ListBox_GetItemRect( hPlayWnd, nItem, &rc );
        ScreenToClient( hPlayWnd, &pt );

        pt_y = rc.bottom - ((rc.bottom - rc.top) / 2);

        if ( pt.y > pt_y ) {
            nItem++;
        }
    }

    DrawMultiInsert( hDlg, hPlayWnd, bDragging ? nItem : -1 );

    return nItem;
}


/*****************************Private*Routine******************************\
* IsInListBox
*
* Is the mouse over the client area of the specified child listbox.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL
IsInListbox(
    HWND hDlg,
    HWND hwndListbox,
    POINT pt
    )
{
    RECT    rc;

    ScreenToClient(hDlg, &pt);

    if ( ChildWindowFromPoint( hDlg, pt ) == hwndListbox ) {

        GetClientRect( hwndListbox, &rc );
        MapWindowRect( hwndListbox, hDlg, &rc );

        return PtInRect( &rc, pt );
    }

    return FALSE;
}


/*****************************Private*Routine******************************\
* RemovePlayListSelection
*
* Here we remove the slected items from the play list listbox.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
RemovePlayListSelection(
    HWND hDlg
    )
{
    int     num;
    int     i;
    int     *pList;

    /*
    ** Get the number of tracks currently selected.  Return if an error
    ** occurrs or zero tracks selected.
    */
    num = ListBox_GetSelCount( hPlayWnd );
    if ( num <= 0 ) {
        return;
    }

    pList = AllocMemory( num * sizeof(int) );
    ListBox_GetSelItems( hPlayWnd, num, pList );

    SetWindowRedraw( hPlayWnd, FALSE );
    for ( i = num - 1; i >= 0; i-- ) {

        ListBox_DeleteString( hPlayWnd, pList[i] );

    }

    /*
    ** Now that we have added the above items we reset this selection
    ** and set the caret to first item in the listbox.
    */
    if ( num != 0 ) {

        ListBox_SetSel( hPlayWnd, FALSE, -1 );
        ListBox_SetCaretIndex( hPlayWnd, 0 );
    }
    SetWindowRedraw( hPlayWnd, TRUE );

    LocalFree( (HLOCAL)pList );
    CheckButtons( hDlg );
    fPlaylistChanged = TRUE;
}


/*****************************Private*Routine******************************\
* AddTrackListSelection
*
* Here we add the current selection from the tracks available listbox to
* the current play list listbox.   Try to ensure that the last track
* added to the playlist is visible in the playlist.  This aids continuity.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
AddTrackListSelection(
    HWND hDlg,
    int iInsertPos
    )
{
    int     i;
    int     num;
    int     *pList;
    TCHAR   s[TRACK_TITLE_LENGTH];

    /*
    ** Get the number of tracks currently selected.  Return if an error
    ** occurrs or zero tracks selected.
    */
    num = ListBox_GetSelCount( hAvailWnd );
    if ( num <= 0 ) {
        return;
    }

    pList = AllocMemory( num * sizeof(int) );
    ListBox_GetSelItems( hAvailWnd, num, pList );

    SetWindowRedraw( hPlayWnd, FALSE );
    for ( i = 0; i < num; i++ ) {

        DWORD   dwData;

        ListBox_GetText( hAvailWnd, pList[i], s );
        dwData = ListBox_GetItemData( hAvailWnd, pList[i] );

        ListBox_InsertString( hPlayWnd, iInsertPos + i, s );
        ListBox_SetItemData( hPlayWnd, iInsertPos + i, dwData );

    }



    /*
    ** Here we used to un-hilight the selection in the "available
    ** tracks" listbox.  Ant didn't like this and raised a bug.  Hence
    ** the next few lines are commented out.
    */

    // if ( num != 0 ) {
    //     ListBox_SetSel( hAvailWnd, FALSE, -1 );
    //     ListBox_SetCaretIndex( hAvailWnd, 0 );
    // }


    /*
    ** Make sure that the last item added to the "Play List" listbox
    ** is visible.
    */
    ListBox_SetCaretIndex( hPlayWnd, iInsertPos + num - 1 );


    SetWindowRedraw( hPlayWnd, TRUE );
    InvalidateRect( hPlayWnd, NULL, FALSE );

    LocalFree( (HLOCAL)pList );
    CheckButtons( hDlg );
    fPlaylistChanged = TRUE;
}


/*****************************Private*Routine******************************\
* CheckButtons
*
* Enables or disables the Remove and Clear buttons depending on the content
* of the play list listbox.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
CheckButtons(
    HWND hDlg
    )
{
    int     num;
    int     items[1];

    num = ListBox_GetCount( hPlayWnd );
    EnableWindow( GetDlgItem( hDlg, IDC_CLEAR ),  (num != 0) );

    EnableWindow( GetDlgItem( hDlg, IDC_REMOVE ),
                  ListBox_GetSelItems( hPlayWnd, 1, items ) == 1 );
}


/*****************************Private*Routine******************************\
* MoveCopySelection
*
* Moves or copies the selection within the play list listbox.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
MoveCopySelection(
    int iInsertPos,
    DWORD dwState
    )
{
    int         num;
    int         i;
    int         *pList;
    LIST_INFO   *pInfo;

    /*
    ** Get the number of tracks currently selected.  Return if an error
    ** occurrs or zero tracks selected.
    */
    num = ListBox_GetSelCount( hPlayWnd );
    if ( num <= 0 ) {
        return;
    }

    pList = AllocMemory( num * sizeof(int) );
    pInfo = AllocMemory( num * sizeof(LIST_INFO) );
    ListBox_GetSelItems( hPlayWnd, num, pList );


    SetWindowRedraw( hPlayWnd, FALSE );

    for ( i = num - 1; i >= 0; i-- ) {

        ListBox_GetText( hPlayWnd, pList[i], pInfo[i].chName );
        pInfo[i].dwData = ListBox_GetItemData( hPlayWnd, pList[i] );

        if ( dwState == DL_MOVE ) {
            pInfo[i].index = pList[i];
            ListBox_DeleteString( hPlayWnd, pList[i] );
        }
    }

    if ( dwState == DL_MOVE ) {

        /*
        ** for each selected item that was above the insertion point
        ** reduce the insertion point by 1.
        */
        int iTempInsertionPt = iInsertPos;

        for ( i = 0; i < num; i++ ) {
            if ( pInfo[i].index < iInsertPos ) {
                iTempInsertionPt--;
            }
        }
        iInsertPos = iTempInsertionPt;
    }


    for ( i = 0; i < num; i++ ) {

        ListBox_InsertString( hPlayWnd, iInsertPos + i, pInfo[i].chName );
        ListBox_SetItemData( hPlayWnd, iInsertPos + i, pInfo[i].dwData );
    }

    /*
    ** Now that we have added the above items we reset this selection
    ** and set the caret to first item in the listbox.
    */
    if ( num != 0 ) {

        ListBox_SetSel( hPlayWnd, FALSE, -1 );
        ListBox_SetCaretIndex( hPlayWnd, 0 );
    }

    SetWindowRedraw( hPlayWnd, TRUE );

    LocalFree( (HLOCAL)pList );
    LocalFree( (HLOCAL)pInfo );
    fPlaylistChanged = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\database.c ===
/******************************Module*Header*******************************\
* Module Name: database.c
*
* This module implements the database routines for the CD Audio app.
* The information is stored in the ini file "cdaudio.ini" which should
* be located in the nt\windows directory.
*
* Warning:
*   These functions ARE NOT THREAD safe.
*   The functions in this file MUST only be called on the UI thread.  Before
*   calling any of the functions the CALLER MUST call LockTableOfContents
*   for the specified cdrom device.
*
* Author:
*   Rick Turner (ricktu) 31-Jan-1992
*
*
* Revision History:
*
*   04-Aug-1992 (ricktu)    Incorperated routines from old cdaudio.c,
*                           and made work w/new child window framework.
*
*
* Copyright (c) 1993 - 1995 Microsoft Corporation.  All rights reserved.
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE

#include <windows.h>
#include "resource.h"
#include "cdapi.h"
#include "cdplayer.h"
#include "database.h"
#include "literals.h"


#include <string.h>
#include <stdio.h>
#include <tchar.h>


/* -------------------------------------------------------------------------
** Private entry points
** -------------------------------------------------------------------------
*/
DWORD
ComputeOldDiscId(
    int cdrom
    );


BOOL
DeleteEntry(
    DWORD Id
    );

BOOL
WriteEntry(
    int cdrom
    );

BOOL
ReadEntry(
    int cdrom,
    DWORD dwId
    );

BOOL
ReadMusicBoxEntry(
    int cdrom,
    DWORD dwId
    );


/*****************************Private*Routine******************************\
* ComputeOldDiscId
*
* This routine computes a unique ID based on the information
* in the table of contexts a given disc.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
DWORD
ComputeOldDiscId(
    int cdrom
    )
{
    int NumTracks,i;
    DWORD DiscId = 0;


    NumTracks = g_Devices[ cdrom ]->toc.LastTrack -
                g_Devices[ cdrom ]->toc.FirstTrack;

    for ( i = 0; i < NumTracks; i++ )  {
        DiscId += ( (TRACK_M(cdrom,i) << 16) +
                    (TRACK_S(cdrom,i) <<  8) +
                     TRACK_F(cdrom,i) );
    }

    return DiscId;

}


/******************************Public*Routine******************************\
* ComputeNewDiscId
*
* Just call mci to get the product ID.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
DWORD
ComputeNewDiscId(
    int cdrom
    )
{
#ifdef USE_IOCTLS
    return ComputeOrgDiscId( cdrom );
#else

    MCI_INFO_PARMS  mciInfo;
    TCHAR           szBuffer[32];
    DWORD           dwRet;

    mciInfo.lpstrReturn = szBuffer;
    mciInfo.dwRetSize   = sizeof(szBuffer)/sizeof(TCHAR);

    dwRet = mciSendCommand( g_Devices[cdrom]->hCd, MCI_INFO,
                            MCI_INFO_MEDIA_IDENTITY,
                            (DWORD)(LPVOID)&mciInfo );

    if ( dwRet != MMSYSERR_NOERROR ) {
        return 0L;
    }

    _stscanf(szBuffer, TEXT("%ld"), &dwRet );

    return dwRet;

#endif
}



/*****************************Private*Routine******************************\
* ComputeOrgDiscId
*
* This routine computes a unique ID based on the information
* in the table of contexts a given disc. This is done by taking
* the TMSF value for each track and XOR'ing it with the previous
* quantity shifted left one bit.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
DWORD
ComputeOrgDiscId(
    int cdrom
    )
{
    int NumTracks,i;
    DWORD DiscId = 0;


    NumTracks = g_Devices[ cdrom ]->toc.LastTrack -
                g_Devices[ cdrom ]->toc.FirstTrack + 1;

    for ( i = 0; i < NumTracks; i++ ) {
        DiscId = (DiscId << 1) ^
                   ((i<<24) +
                    (TRACK_M(cdrom,i) << 16) +
                    (TRACK_S(cdrom,i) <<  8) +
                     TRACK_F(cdrom,i) );
    }

    return DiscId;

}


/*****************************Private*Routine******************************\
* ErasePlayList
*
* Erases the current play list.  This includes freeing the memory
* for the nodes in the play list, and resetting the current track
* pointer to NULL.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
VOID
ErasePlayList(
    int cdrom
    )
{

    PTRACK_PLAY temp, temp1;

    //
    // Free memory for each track in play list
    //

    temp = PLAYLIST( cdrom );
    while (temp!=NULL) {

        temp1 = temp->nextplay;
        LocalFree( (HLOCAL)temp );
        temp = temp1;

    }

    //
    // Reset pointers
    //

    PLAYLIST( cdrom ) = NULL;
    CURRTRACK( cdrom ) = NULL;
}



/******************************Public*Routine******************************\
* EraseSaveList
*
* Erases the current save list.  This includes freeing the memory
* for the nodes in the save list.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
VOID
EraseSaveList(
    int cdrom
    )
{

    PTRACK_PLAY temp, temp1;

    //
    // Free memory for each track in play list
    //


    temp = SAVELIST( cdrom );
    while ( temp != NULL ) {

        temp1 = temp->nextplay;
        LocalFree( (HLOCAL)temp );
        temp = temp1;

    }

    //
    // Reset pointers
    //

    SAVELIST( cdrom ) = NULL;

}


/*****************************Private*Routine******************************\
* EraseTrackList
*
* Erases the current track list.  This includes freeing the memory
* for the nodes in the track list, and resetting the track list
* pointer to NULL.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
VOID
EraseTrackList(
    int cdrom
    )
{

    PTRACK_INF temp, temp1;

    //
    // Free memory for each track in track list
    //

    temp = ALLTRACKS( cdrom );
    while ( temp != NULL ) {

        temp1 = temp->next;
        LocalFree( (HLOCAL)temp );
        temp = temp1;
    }

    //
    // Reset pointers
    //

    ALLTRACKS( cdrom ) = NULL;

}

/******************************Public*Routine******************************\
* CopyPlayList
*
* Returns a copy of the playlist pointed to by p.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
PTRACK_PLAY
CopyPlayList(
    PTRACK_PLAY p
    )
{

    PTRACK_PLAY t,t1,tend,tret;

    tret = tend = NULL;

    //
    // Duplicate list pointed to by p.
    //

    t = p;
    while( t!=NULL ) {

        t1 = (PTRACK_PLAY)AllocMemory( sizeof(TRACK_PLAY) );
        t1->TocIndex = t->TocIndex;
        t1->min = t->min;
        t1->sec = t->sec;
        t1->nextplay = NULL;
        t1->prevplay = tend;

        if (tret==NULL) {

            tret = tend = t1;
        }
        else {

            tend->nextplay = t1;
            tend = t1;
        }

        t = t->nextplay;

    }

    return(tret);

}


/*****************************Private*Routine******************************\
* ResetPlayList
*
* Resets play order for the disc.  Used to initialize/reset
* the play list.  This is done by reseting the doubly-linked list
* of tracks in the g_Devices[...]->CdInfo.PlayList.[prevplay,nextplay]
* pointers.  All the tracks on the CD are stored in a singly linked list
* pointed to by g_Devices[...]->CdInfo.AllTracks pointer.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
VOID
ResetPlayList(
     int cdrom
    )
{
    PTRACK_INF t;
    PTRACK_PLAY temp, prev;


    //
    // Kill old play list
    //

    ErasePlayList( cdrom );
    EraseSaveList( cdrom );

    //
    // Duplicate each node in AllTracks and insert in-order
    // in SaveList list.  The SaveList is the master which is
    // used for the playlist.
    //

    t = ALLTRACKS( cdrom );
    prev = NULL;

    while (t!=NULL) {

        temp = (PTRACK_PLAY)AllocMemory( sizeof(TRACK_PLAY) );

        temp->TocIndex = t->TocIndex;
        temp->min = 0;
        temp->sec = 0;
        temp->prevplay = prev;
        temp->nextplay = NULL;

        if (prev!=NULL) {

            prev->nextplay = temp;
        }
        else {

            SAVELIST( cdrom ) = temp;
        }

        prev = temp;
        t=t->next;

    }

    PLAYLIST( cdrom ) = CopyPlayList( SAVELIST( cdrom) );
}


/*****************************Private*Routine******************************\
* DeleteEntry
*
* The ID format has changed to make the id's for the different CD's
* more unique. This routine will completely delete the old key value
* from the ini file.  We remove it by writing a NULL entry.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
BOOL
DeleteEntry(
    DWORD Id
    )
{
    TCHAR Section[80];

    wsprintf( Section, g_szSectionF, Id );
    return WritePrivateProfileSection( Section, g_szEmpty, g_IniFileName );
}




/*****************************Private*Routine******************************\
* WriteEntry
*
* Write current disc information into database ini file.
* The section for the current disc (section name is a hex
* value of the disc id) is completely rewritten.
*
* This function uses 64K of stack !!
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
BOOL
WriteEntry(
    int cdrom
    )
{
    TCHAR       *Buffer;
    LPTSTR      s;
    int         i;
    TCHAR       Section[ 10 ];
    PTRACK_INF  temp;
    PTRACK_PLAY temp1;
    BOOL        fRc;

    //
    // Construct ini file buffer, form of:
    //
    //     artist = artist name
    //      title = Title of disc
    //  numtracks = n
    //          0 = Title of track 1
    //          1 = Title of track 2
    //        n-1 = Title of track n
    //      order = 0 4 3 2 6 7 8 ... (n-1)
    //    numplay = # of entries in order list
    //

    //
    // Is it legal to save this information?
    //

    if (!g_Devices[ cdrom ]->CdInfo.save)
        return( TRUE );

    Buffer = AllocMemory( 64000 * sizeof(TCHAR) );
    // note: if the memory allocation fails, AllocMemory will terminate
    // the application

    g_Devices[ cdrom ]->CdInfo.IsVirginCd = FALSE;

    s = Buffer;

    s += 1 + wsprintf( s, g_szEntryTypeF, 1 );
    s += 1 + wsprintf( s, g_szArtistF, g_Devices[ cdrom ]->CdInfo.Artist );
    s += 1 + wsprintf( s, g_szTitleF, g_Devices[ cdrom ]->CdInfo.Title );
    s += 1 + wsprintf( s, g_szNumTracksF, g_Devices[ cdrom ]->CdInfo.NumTracks );

    for ( temp = g_Devices[ cdrom ]->CdInfo.AllTracks;
          temp!=NULL; temp = temp->next ) {

        s += 1 + wsprintf( s, TEXT("%d=%s"), temp->TocIndex, temp->name );
    }

    s += wsprintf( s, g_szOrderF );

    i = 0;
    for ( temp1 = g_Devices[ cdrom ]->CdInfo.SaveList;
          temp1!=NULL; temp1 = temp1->nextplay ) {

        s += wsprintf( s, TEXT("%d "), temp1->TocIndex );
        i++;

    }
    s += 1;

    s += 1 + wsprintf( s, g_szNumPlayF, i );

    //
    // Just make sure there are NULLs at end of buffer
    //

    wsprintf( s, g_szThreeNulls );

    wsprintf( Section, g_szSectionF, g_Devices[ cdrom ]->CdInfo.Id );

    //
    // Try writing buffer into ini file
    //

    fRc = WritePrivateProfileSection( Section, Buffer, g_IniFileName );

    LocalFree( (HLOCAL)Buffer );
    return fRc;
}



/******************************Public*Routine******************************\
* ReadMusicBoxEntry
*
* Try to parse the music box database ini file looking for the given disk
* id.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
ReadMusicBoxEntry(
    int cdrom,
    DWORD dwId
    )
{
    TCHAR       Section[32];

    TCHAR       s[TITLE_LENGTH];

    int         i;
    PTRACK_INF  temp, curr;

    g_Devices[ cdrom ]->CdInfo.iFrameOffset = NEW_FRAMEOFFSET;


    //
    // Try to read in section from ini file.  Note that music box stores
    // the key in decimal NOT hex.
    //

    wsprintf( Section, TEXT("%ld"), dwId );

    GetPrivateProfileString( Section, g_szDiscTitle, g_szNothingThere,
                             g_Devices[ cdrom ]->CdInfo.Title,
                             TITLE_LENGTH, g_szMusicBoxIni );

    //
    // Was the section found?
    //
    if ( _tcscmp(g_Devices[ cdrom ]->CdInfo.Title, g_szNothingThere) == 0 ) {

        //
        // Nope, notify caller
        //

        return FALSE;
    }


    /*
    ** Now read the track information.  Also the artists name is unknown.
    */

    _tcscpy( ARTIST(cdrom), IdStr(STR_UNKNOWN) );

    NUMTRACKS(cdrom) = LASTTRACK(cdrom) - FIRSTTRACK(cdrom) + 1;
    
    // Make sure there is at least one track!!!
    if (0 == NUMTRACKS(cdrom)) {
        return FALSE;
    }

    for ( i = 0, curr = NULL; i < NUMTRACKS(cdrom); i++ ) {

        wsprintf( s, g_szMusicBoxFormat, i + 1 );

        temp = (PTRACK_INF)AllocMemory( sizeof(TRACK_INF) );

        GetPrivateProfileString( Section, s, s, temp->name,
                                 TRACK_TITLE_LENGTH, g_szMusicBoxIni );
        temp->TocIndex = i;
        temp->next = NULL;

        if ( curr == NULL ) {

            ALLTRACKS( cdrom ) = curr = temp;
        }
        else {

            curr->next = temp;
            curr = temp;
        }
    }

    // Make sure there is at least one track in Default playlist!!!
    if (NULL == ALLTRACKS(cdrom)) {
        return FALSE;
    }

    _tcscpy( ARTIST(cdrom), IdStr(STR_UNKNOWN) );


    /*
    ** Process the play list
    */

    GetPrivateProfileString( Section, g_szPlayList, g_szNothingThere,
                             s, TITLE_LENGTH, g_szMusicBoxIni );

    /*
    ** Was the section found?
    */
    if ( _tcscmp(g_Devices[ cdrom ]->CdInfo.Title, g_szNothingThere) == 0 ) {

        /*
        ** Nope, just use the default playlist.
        */

        ResetPlayList( cdrom );

    }
    else {

        LPTSTR      lpPlayList, porder;
        PTRACK_PLAY temp1, prev;
        int         i;
        const       PLAYLEN = 8192;

        lpPlayList = AllocMemory( sizeof(TCHAR) * PLAYLEN );

        GetPrivateProfileString( Section, g_szPlayList, g_szNothingThere,
                                 lpPlayList, PLAYLEN, g_szMusicBoxIni );

        _tcscat( lpPlayList, g_szBlank );
        porder = lpPlayList;
        prev = NULL;

        while ( *porder && (_stscanf( porder, TEXT("%d"),  &i ) == 1) ) {

            i--;

            /*
            ** Assert that i is a valid index.
            **  ie 0 <= i <= (NUMTRACKS(cdrom) - 1)
            */

            i = min( (NUMTRACKS(cdrom) - 1), max( 0, i ) );

            temp1 = (PTRACK_PLAY)AllocMemory( sizeof(TRACK_PLAY) );
            temp1->TocIndex = i;
            temp1->min = 0;
            temp1->sec = 0;
            temp1->prevplay = prev;
            temp1->nextplay = NULL;

            if (prev == NULL) {

                SAVELIST( cdrom ) = temp1;
            }
            else {

                prev->nextplay  = temp1;
            }

            prev = temp1;

            porder = _tcschr( porder, TEXT(' ') ) + 1;
        }

        // Make sure there is at least one track in SAVED playlist!!!
        if (NULL == SAVELIST(cdrom)) {
            // Nope, just use the default playlist instead!!!
            ResetPlayList( cdrom );
        }

        PLAYLIST( cdrom ) = CopyPlayList( SAVELIST( cdrom ) );

        LocalFree( (HLOCAL)lpPlayList );
    }

    return TRUE;
}




/*****************************Private*Routine******************************\
* ReadEntry
*
* Try to read entry for new disc from  database ini file.
* The section name we are trying to read is a hex
* value of the disc id.  If the sections is found,
* fill in the data for the disc in the cdrom drive.
*
* This function uses over 16K of stack space !!
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
BOOL
ReadEntry(
    int cdrom,
    DWORD dwId
    )
{

    DWORD       rc;
    TCHAR       Section[10];
    TCHAR       s[100],s1[100];
    TCHAR       order[ 8192 ];
    TCHAR       torder[ 8192 ];
    int         i;
    LPTSTR      porder;
    int         numtracks, numplay;
    PTRACK_INF  temp, curr;
    PTRACK_PLAY temp1, prev;
    BOOL        OldEntry;
    BOOL        fRewriteEntry = FALSE;


    g_Devices[ cdrom ]->CdInfo.iFrameOffset = NEW_FRAMEOFFSET;


    //
    // Try to read in section from ini file
    //

    wsprintf( Section, g_szSectionF, dwId );

    rc = GetPrivateProfileString( Section, g_szTitle, g_szNothingThere,
                                  g_Devices[ cdrom ]->CdInfo.Title,
                                  TITLE_LENGTH, g_IniFileName );

    //
    // Was the section found?
    //

    if ( _tcscmp(g_Devices[ cdrom ]->CdInfo.Title, g_szNothingThere) == 0 ) {

        //
        // Nope, notify caller
        //

        return( FALSE );
    }


    //
    // We found an entry for this disc, so copy all the information
    // from the ini file entry
    //
    // Is this an old entry?
    //

    i = GetPrivateProfileInt( Section, g_szEntryType, 0, g_IniFileName );

    OldEntry = (i==0);

    numtracks = GetPrivateProfileInt( Section, g_szNumTracks,
                                      0, g_IniFileName );

    // Make sure there is at least one track!!!
    if (0 == numtracks) {
        fRewriteEntry = TRUE;
    }

    g_Devices[ cdrom ]->CdInfo.NumTracks = numtracks;

    rc = GetPrivateProfileString( Section, g_szArtist, g_szUnknownTxt,
                                  (LPTSTR)ARTIST(cdrom), ARTIST_LENGTH,
                                  g_IniFileName );

    //
    // Validate the stored track numbers
    //
    if (g_Devices[cdrom]->fIsTocValid) {

        int    maxTracks;  // validate the high point in ini file

        maxTracks = g_Devices[cdrom]->toc.LastTrack;

        if (numtracks > maxTracks) {
            // Current ini file contains invalid data
            // this can result in the CD not playing at all as the end
            // point is likely to be invalid
            g_Devices[ cdrom ]->CdInfo.NumTracks
              = numtracks
              = maxTracks;
            fRewriteEntry = TRUE;
        }
    }

    //
    // Read the track list information
    //

    for (i=0, curr = NULL; i < numtracks; i++) {

        temp = (PTRACK_INF)AllocMemory( sizeof(TRACK_INF) );
        temp->TocIndex = i;
        temp->next = NULL;
        wsprintf( s1, IdStr(STR_INIT_TRACK), i + 1 );
        wsprintf( s, TEXT("%d"), i );
        rc = GetPrivateProfileString( Section, s, s1, (LPTSTR)temp->name,
                                      TRACK_TITLE_LENGTH, g_IniFileName );

        if (curr==NULL) {

            ALLTRACKS( cdrom ) = curr = temp;

        } else {

            curr->next = temp;
            curr = temp;

        }

    }

    // Make sure there is at least one entry in TRACK list
    if (ALLTRACKS(cdrom) == NULL)
    {
        fRewriteEntry = TRUE;
    }

    //
    // if we detected a problem in the ini file, or the entry is an
    // old format, rewrite the section.
    //

    if (OldEntry || fRewriteEntry) {

        //
        // Generate generic play list (all tracks in order)
        //

        ResetPlayList( cdrom );

        //
        // Need to rewrite this entry in new format
        //

        WriteEntry( cdrom );

    }
    else {

        //
        // Read play list (order) information and construct play list doubly
        // linked list
        //

        numplay = GetPrivateProfileInt( Section, g_szNumPlay,
                                        0, g_IniFileName );

        porder = torder;
        ZeroMemory( porder, sizeof(torder) );

        //
        // construct a default play order list
        //

        for ( i = 0; i < numtracks; i++ ) {

            wsprintf( porder, TEXT("%d "), i );
            /* porder += (_tcslen( porder ) * sizeof( TCHAR )); */
            porder += _tcslen( porder );

        }

        rc = GetPrivateProfileString( Section, g_szOrder,
                                      torder, (LPTSTR)order, 8192,
                                      g_IniFileName );

        //
        // Ensure a trailing space
        //

        _tcscat( order, g_szBlank );
        porder = order;
        prev = NULL;

        while ( *porder && (_stscanf( porder, TEXT("%d"),  &i ) == 1) ) {


            /*
            ** Assert that i is a valid index.
            **  ie 0 <= i <= (numtracks - 1)
            */

            i = min( (numtracks - 1), max( 0, i ) );

            temp1 = (PTRACK_PLAY)AllocMemory( sizeof(TRACK_PLAY) );
            temp1->TocIndex = i;
            temp1->min = 0;
            temp1->sec = 0;
            temp1->prevplay = prev;
            temp1->nextplay = NULL;

            if (prev==NULL) {

                SAVELIST( cdrom ) = temp1;

            } else {

                prev->nextplay  = temp1;

            }
            prev = temp1;

            porder = _tcschr( porder, g_chBlank ) + 1;

        }

        // Make sure there is at least one entry in SAVED list
        if (SAVELIST(cdrom) == NULL)
        {
            // Nope, use default list instead
            ResetPlayList( cdrom );
            WriteEntry( cdrom );
        }

        PLAYLIST( cdrom ) = CopyPlayList( SAVELIST( cdrom ) );

    }

    return TRUE;
}


/******************************Public*Routine******************************\
* WriteSettings
*
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
BOOL
WriteSettings(
    VOID
    )
{
    WINDOWPLACEMENT wndpl;
    HKEY            hKey;
    LONG            lRet;
    DWORD           dwTmp;
    extern BOOL     g_fTitlebarShowing;     //cdplayer.c
    extern int      cyMenuCaption;          //cdplayer.c 

    lRet = RegCreateKey( HKEY_CURRENT_USER, g_szRegistryKey, &hKey );
    if ( lRet != ERROR_SUCCESS) {
        return FALSE;
    }


    // Save settings on exit
    dwTmp = (DWORD)g_fSaveOnExit;
    RegSetValueEx( hKey, g_szSaveSettingsOnExit, 0L, REG_DWORD,
                   (LPBYTE)&dwTmp, sizeof(dwTmp) );

    if ( !g_fSaveOnExit ) {

        RegCloseKey( hKey );
        return TRUE;
    }


    // Small LED font
    dwTmp = (DWORD)g_fSmallLedFont;
    RegSetValueEx( hKey, g_szSmallFont, 0L, REG_DWORD,
                   (LPBYTE)&dwTmp, sizeof(dwTmp) );

    // Enable Tooltips
    dwTmp = (DWORD)g_fToolTips;
    RegSetValueEx( hKey, g_szToolTips, 0L, REG_DWORD,
                   (LPBYTE)&dwTmp, sizeof(dwTmp) );

    // Stop CD playing on exit
    dwTmp = (DWORD)g_fStopCDOnExit;
    RegSetValueEx( hKey, g_szStopCDPlayingOnExit, 0L, REG_DWORD,
                   (LPBYTE)&dwTmp, sizeof(dwTmp) );

    // Currect track time
    dwTmp = (DWORD)g_fDisplayT;
    RegSetValueEx( hKey, g_szDisplayT, 0L, REG_DWORD,
                   (LPBYTE)&dwTmp, sizeof(dwTmp) );

    // Time remaining for this track
    dwTmp = (DWORD)g_fDisplayTr;
    RegSetValueEx( hKey, g_szDisplayTr, 0L, REG_DWORD,
                   (LPBYTE)&dwTmp, sizeof(dwTmp) );

    // Time remaining for this play list
    dwTmp = (DWORD)g_fDisplayDr;
    RegSetValueEx( hKey, g_szDisplayDr, 0L, REG_DWORD,
                   (LPBYTE)&dwTmp, sizeof(dwTmp) );

    // Play in selected order
    dwTmp = (DWORD)g_fSelectedOrder;
    RegSetValueEx( hKey, g_szInOrderPlay, 0L, REG_DWORD,
                   (LPBYTE)&dwTmp, sizeof(dwTmp) );

    // Use single disk
    dwTmp = (DWORD)!g_fSingleDisk;
    RegSetValueEx( hKey, g_szMultiDiscPlay, 0L, REG_DWORD,
                   (LPBYTE)&dwTmp, sizeof(dwTmp) );

    // Intro play ( Default 10Secs)
    dwTmp = (DWORD)g_fIntroPlay;
    RegSetValueEx( hKey, g_szIntroPlay, 0L, REG_DWORD,
                   (LPBYTE)&dwTmp, sizeof(dwTmp) );

    dwTmp = (DWORD)g_IntroPlayLength;
    RegSetValueEx( hKey, g_szIntroPlayLen, 0L, REG_DWORD,
                   (LPBYTE)&dwTmp, sizeof(dwTmp) );

    // Continuous play (loop at end)
    dwTmp = (DWORD)g_fContinuous;
    RegSetValueEx( hKey, g_szContinuousPlay, 0L, REG_DWORD,
                   (LPBYTE)&dwTmp, sizeof(dwTmp) );

    // Show toolbar
    dwTmp = (DWORD)g_fToolbarVisible;
    RegSetValueEx( hKey, g_szToolbar, 0L, REG_DWORD,
                   (LPBYTE)&dwTmp, sizeof(dwTmp) );

    // Show track information
    dwTmp = (DWORD)g_fTrackInfoVisible;
    RegSetValueEx( hKey, g_szDiscAndTrackDisplay, 0L, REG_DWORD,
                   (LPBYTE)&dwTmp, sizeof(dwTmp) );

    // Show track status bar
    dwTmp = (DWORD)g_fStatusbarVisible;
    RegSetValueEx( hKey, g_szStatusBar, 0L, REG_DWORD,
                   (LPBYTE)&dwTmp, sizeof(dwTmp) );


    // Save window position.
    wndpl.length = sizeof(WINDOWPLACEMENT);
    GetWindowPlacement(g_hwndApp,&wndpl);
    if (!g_fTitlebarShowing) {
        wndpl.rcNormalPosition.top -= cyMenuCaption;
    }

    // X pos
    dwTmp = (DWORD)wndpl.rcNormalPosition.left;
    RegSetValueEx( hKey, g_szWindowOriginX, 0L, REG_DWORD,
                   (LPBYTE)&dwTmp, sizeof(dwTmp) );

    // Y pos
    dwTmp = (DWORD)wndpl.rcNormalPosition.top;
    RegSetValueEx( hKey, g_szWindowOriginY, 0L, REG_DWORD,
                   (LPBYTE)&dwTmp, sizeof(dwTmp) );

    RegCloseKey( hKey );
    return TRUE;
}


/******************************Public*Routine******************************\
* AddFindEntry
*
* Search the database file for the current disc,  if found, read the
* information, otherwise, generate some default artist and track names etc.
* but don't store this in the database.  A new entry is only added to the
* database after the user has used the "Edit Track Titles" dialog box.
*
* The design of this function is complicated by the fact that we have to
* support two previous attempts at generating CDplayer keys.  Also, we try
* to support the MusicBox key format now that it is compatible with the
* new CDplayer format.
*
*
* History:
* 18-11-93 - ricktu - Created
*
\**************************************************************************/
VOID
AddFindEntry(
    int cdrom,
    DWORD key,
    PCDROM_TOC lpTOC
    )
{

    int         i, num;
    PTRACK_INF  temp, temp1;

    /*
    ** Kill off old PlayList, Save lists if they exists.
    */

    ErasePlayList( cdrom );
    EraseSaveList( cdrom );
    EraseTrackList( cdrom );

    /*
    ** Check ini file for an existing entry
    **
    ** First Look in cdplayer.ini using the new key, return if found
    */

    // We initialize this field early, otherwise ReadEntry will not be
    // able to save any new information (or lose invalid).
    g_Devices[ cdrom ]->CdInfo.save = TRUE;

    if ( ReadEntry(cdrom, key) ) {
        return;
    }

    /*
    ** Initialize these fields
    */
    g_Devices[ cdrom ]->CdInfo.IsVirginCd = FALSE;
    g_Devices[ cdrom ]->CdInfo.Id = key;


    /*
    ** Look again in cdplayer.ini.  This time use the original cdplayer key.
    ** If we found the original key in cdplayer.ini write the new key into
    ** cdplayer.ini and then return
    */

    if ( ReadEntry(cdrom, ComputeOrgDiscId(cdrom)) ) {

        /*
        ** If the disc was under an Original id, we need to delete the
        ** old one, convert it to the new format, and save it under
        ** its new key.
        */

        DeleteEntry( ComputeOrgDiscId(cdrom) );
        WriteEntry( cdrom );

    }


    /*
    ** Final look in cdplayer.ini.  This time use the OLD cdplayer key.
    ** If we found the OLD key in cdplayer.ini write the new key into
    ** cdplayer.ini and then return
    */

    else if ( ReadEntry(cdrom, ComputeOldDiscId(cdrom)) ) {

        /*
        ** If the disc was under an OLD id, we need to delete the
        ** old one, convert it to the new format, and save it under
        ** its new key.
        */

        DeleteEntry( ComputeOldDiscId(cdrom) );
        WriteEntry( cdrom );
    }


    /*
    ** Couldn't find it in cdplayer.ini, now look for the key in musicbox.ini
    ** If we found the key in musicbox.ini write it into cdplayer.ini and
    ** then return
    */

    else if ( ReadMusicBoxEntry(cdrom, key) ) {

        WriteEntry( cdrom );
    }


    /*
    ** This is a new entry, fill it in but don't store it in the database.
    */

    else {

        g_Devices[ cdrom ]->CdInfo.IsVirginCd = TRUE;

        wsprintf( (LPTSTR)ARTIST( cdrom ), IdStr( STR_NEW_ARTIST ) );
        wsprintf( (LPTSTR)TITLE( cdrom ), IdStr( STR_NEW_TITLE ) );

        NUMTRACKS( cdrom ) = num = lpTOC->LastTrack - lpTOC->FirstTrack + 1;


        /*
        ** Create generic playlist, which is all audio tracks
        ** played in the order they are on the CD.  First, create
        ** a singly linked list that contains all the tracks.
        ** Then, create a double linked list, using the nodes of
        ** from the single linked list for the play list.
        */


        for( i = 0; i < num; i++ ) {

            /*
            ** Create storage for track
            */

            temp = (PTRACK_INF)AllocMemory( sizeof(TRACK_INF) );

            /*
            ** Initialize information (storage already ZERO initialized)
            */

            wsprintf( (LPTSTR)temp->name, IdStr( STR_INIT_TRACK ), i+1 );
            temp->TocIndex = i;
            temp->next = NULL;

            /*
            ** Add node to singly linked list of all tracks
            */

            if (i == 0) {

                temp1 = ALLTRACKS( cdrom ) = temp;
            }
            else {

                temp1->next = temp;
                temp1 = temp;
            }
        }

        /*
        ** Generate generic play list (all tracks in order)
        */

        ResetPlayList( cdrom );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\database.h ===
/******************************Module*Header*******************************\
* Module Name: databas.h
*
* This module implements the database routines for the CD Audio app.
* The information is stored in the ini file "cdaudio.ini" which should
* be located in the nt\windows directory.
*
*
* Author:
*   Rick Turner (ricktu) 31-Jan-1992
*
*
* Revision History:
*
*   04-Aug-1992 (ricktu)    Incorperated routines from old cdaudio.c,
*                           and made work w/new child window framework.
*
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
VOID
ErasePlayList(
    int cdrom
    );

VOID
EraseSaveList(
    int cdrom
    );

VOID
EraseTrackList(
    int cdrom
    );

PTRACK_PLAY
CopyPlayList(
    PTRACK_PLAY p
    );

VOID
ResetPlayList(
    int cdrom
    );

DWORD
ComputeNewDiscId(
    int cdrom
    );

DWORD
ComputeOrgDiscId(
    int cdrom
    );

VOID
AddFindEntry(
    int cdrom,
    DWORD key,
    PCDROM_TOC lpTOC
    );

BOOL
WriteSettings(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\helpids.h ===
// CD Player Menus
#define IDH_CDPLAYER_CS_CDPLAYER_DISC_EDIT_PLAY_LIST		4285
#define IDH_CDPLAYER_CS_CDPLAYER_DISC_EXIT			4286
#define IDH_CDPLAYER_CS_CDPLAYER_VIEW_TOOLBAR			4287
#define IDH_CDPLAYER_CS_CDPLAYER_VIEW_DISC_TRACK_INFO		4288
#define IDH_CDPLAYER_CS_CDPLAYER_VIEW_STATUS_BAR		4289
#define IDH_CDPLAYER_CS_CDPLAYER_VIEW_TRACK_TIME_ELAPSED	4290
#define IDH_CDPLAYER_CS_CDPLAYER_VIEW_REMAINING_TRACK_TIME	4291
#define IDH_CDPLAYER_CS_CDPLAYER_VIEW_REMAINING_DISC_TIME	4292
#define IDH_CDPLAYER_CS_CDPLAYER_VIEW_VOLUME_CONTROL		4293
#define IDH_CDPLAYER_CS_CDPLAYER_OPTIONS_RANDOM_ORDER		4294
#define IDH_CDPLAYER_CS_CDPLAYER_OPTIONS_CONTINUOUS_PLAY	4295
#define IDH_CDPLAYER_CS_CDPLAYER_OPTIONS_INTRO_PLAY		4296
#define IDH_CDPLAYER_CS_CDPLAYER_OPTIONS_PREFERENCES		4297
#define IDH_CDPLAYER_CS_CDPLAYER_HELP_HELP_TOPICS		4298
#define IDH_CDPLAYER_CS_CDPLAYER_HELP_ABOUT			4299

// Disc Settings dialog
#define IDH_CD_DRIVE_NAME           4300
#define IDH_CD_GET_ARTIST           4301
#define IDH_CD_GET_TITLE            4302
#define IDH_CD_PLAY_LISTBOX         4303
#define IDH_CD_ADD                  4304
#define IDH_CD_REMOVE               4305
#define IDH_CD_CLEAR                4306
#define IDH_CD_DEFAULT              4307
#define IDH_CD_TRACK_LISTBOX        4308
#define IDH_CD_TRACK_NAME           4309
#define IDH_CD_SETNAME              4310

// Preferences dialog box           4311
#define IDH_CD_STOP_CD_ON_EXIT      4312
#define IDH_CD_SAVE_ON_EXIT         4313
#define IDH_CD_SHOW_TOOLTIPS        4314
#define IDH_CD_INTRO_LENGTH         4315
#define IDH_CD_DISPLAY_FONT         4316
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\dragdrop.c ===
/******************************Module*Header*******************************\
* Module Name: DragDrop.c
*
* An attempt to implement dragging and dropping between Multi-selection
* listboxes.
*
* Created: dd-mm-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#define NOOLE
#define NODRAGLIST

#include <windows.h>
#include <windowsx.h>

#include "resource.h"
#include "dragdrop.h"


#define LONG2POINT(l, pt) ((pt).x = (SHORT)LOWORD(l), \
                           (pt).y = (SHORT)HIWORD(l))



#define DF_ACTUALLYDRAG     0x0001
#define DF_DEFERRED         0x0002

#define INITLINESPERSECOND  36
#define VERTCHANGENUMLINES  25

#define TIMERID             238
#define TIMERLEN            250
#define TIMERLEN2           50

#define DX_INSERT           16
#define DY_INSERT           16


typedef struct {
   WNDPROC lpfnDefProc;
   HWND     hwndDrag;
   UINT     uFlags;
   DWORD    dwState;
} DRAGPROP, *PDRAGPROP;

UINT    uDragListMsg            = 0L;
TCHAR   szDragListMsgString[]   = TEXT(SJE_DRAGLISTMSGSTRING);
TCHAR   szDragProp[]            = TEXT("DragMultiProp");

extern HINSTANCE g_hInst;

/******************************Public*Routine******************************\
* InitDragMultiList
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
UINT WINAPI
InitDragMultiList(
    void
    )
{
    if (!uDragListMsg) {

        uDragListMsg = RegisterWindowMessage(szDragListMsgString);

        if (!uDragListMsg) {
            return 0;
        }
    }
    return uDragListMsg;
}


/******************************Public*Routine******************************\
* DragListSubclassProc
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
DragListSubclassProc(
    HWND hLB,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PDRAGPROP           pDragProp;
    DRAGMULTILISTINFO   sNotify;
    WNDPROC             lpfnDefProc;
    BOOL                bDragging;

    pDragProp = (PDRAGPROP)GetProp(hLB, szDragProp);
    bDragging = pDragProp->hwndDrag == hLB;

    // Save this in case anything happens to pDragProp before we return.

    lpfnDefProc = pDragProp->lpfnDefProc;

    switch (uMsg) {

    case WM_DESTROY:
        if (bDragging)
            SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L); // cancel drag


        // Restore the window proc just in case.

        SubclassWindow( hLB, lpfnDefProc );

        if (pDragProp) {
            LocalFree((HLOCAL)pDragProp);
            RemoveProp(hLB, szDragProp);
        }
        break;


    case WM_LBUTTONDOWN:
        {
            POINT pt;
            int nItem;


            if (bDragging)                                // nested button-down
                SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L);  // cancel drag

            SetFocus(hLB);

            LONG2POINT(lParam, pt);

            ClientToScreen(hLB, &pt);
            nItem = LBMultiItemFromPt(hLB, pt, FALSE);

            if ( nItem >= 0 ) {

                //
                // We can only allow dragging if the item is selected.
                // If the item is not selected - pass the message on.
                //
                if ( ListBox_GetSel( hLB, nItem ) <= 0 ) {
                    return CallWindowProc( lpfnDefProc, hLB, uMsg,
                                           wParam, lParam );
                }

                pDragProp->dwState = (wParam & MK_CONTROL) ? DL_COPY : DL_MOVE;
                sNotify.uNotification = DL_BEGINDRAG;
                goto QueryParent;

            }
            else {
                goto FakeDrag;
            }
        }


    case WM_TIMER:
        if (wParam != TIMERID) {
            break;
        }

        {
            POINT CursorPos;

            GetCursorPos( &CursorPos );
            ScreenToClient( hLB, &CursorPos );
            lParam = MAKELPARAM((WORD)CursorPos.x, (WORD)CursorPos.y);
        }

        // Fall through

    case WM_MOUSEMOVE:
        if (bDragging) {

            HWND hwndParent;
            DWORD dwRet;

            // We may be just simulating a drag, but not actually doing
            // anything.

            if (!(pDragProp->uFlags&DF_ACTUALLYDRAG)) {
                return(0L);
            }


            if ( pDragProp->uFlags & DF_DEFERRED ) {

                pDragProp->uFlags &= ~DF_DEFERRED;
                KillTimer(hLB, TIMERID);
                SetTimer(hLB, TIMERID, TIMERLEN2, NULL);
            }

            sNotify.uNotification = DL_DRAGGING;

QueryParent:
            hwndParent = GetParent( hLB );
            sNotify.hWnd = hLB;
            sNotify.dwState = pDragProp->dwState;

            LONG2POINT( lParam, sNotify.ptCursor );

            ClientToScreen( hLB, &sNotify.ptCursor );

            dwRet = SendMessage( hwndParent, uDragListMsg, GetDlgCtrlID(hLB),
                                 (LPARAM)(LPDRAGMULTILISTINFO)&sNotify );

            if ( uMsg == WM_LBUTTONDOWN ) {

                // Some things may not be draggable

                if (dwRet) {

                    SetTimer(hLB, TIMERID, TIMERLEN, NULL);
                    pDragProp->uFlags = DF_DEFERRED | DF_ACTUALLYDRAG;
                }
                else {
FakeDrag:
                    pDragProp->uFlags = 0;
                }

                // Set capture and change mouse cursor

                pDragProp->hwndDrag = hLB;
                SetCapture( hLB );
            }

            // Don't call the def proc, since it may try to change the
            // selection or set timers or things like that.

            return 0L;
       }
       break;


    case  WM_RBUTTONDOWN:
    case  WM_LBUTTONUP:

        // if we are capturing mouse - release it and check for an
        // acceptable place where mouse is now to decide drop or not

        if (bDragging) {

            HWND hwndParent;

            pDragProp->hwndDrag = NULL;
            KillTimer(hLB, TIMERID);
            ReleaseCapture();
            SetCursor(LoadCursor(NULL, IDC_ARROW));

            hwndParent = GetParent(hLB);

            sNotify.uNotification = (uMsg == WM_LBUTTONUP)
                                        ? DL_DROPPED : DL_CANCELDRAG;
            sNotify.hWnd = hLB;
            sNotify.dwState = pDragProp->dwState;

            LONG2POINT( lParam, sNotify.ptCursor );

            ClientToScreen( hLB, &sNotify.ptCursor );

            SendMessage( hwndParent, uDragListMsg, GetDlgCtrlID(hLB),
                         (LPARAM)(LPDRAGMULTILISTINFO)&sNotify);

            //
            // If we didn't actually do any dragging just fake a button
            // click at the current location.
            //
            if ( pDragProp->uFlags & DF_DEFERRED ) {
                CallWindowProc(lpfnDefProc, hLB, WM_LBUTTONDOWN, wParam, lParam);
                CallWindowProc(lpfnDefProc, hLB, uMsg, wParam, lParam);
            }

            // We need to make sure to return 0 in case this is from a
            // keyboard message.

            return 0L;
        }
        break;


    case WM_GETDLGCODE:
        if (bDragging)
            return (CallWindowProc(lpfnDefProc, hLB, uMsg, wParam, lParam)
                    | DLGC_WANTMESSAGE);
        break;


    case WM_KEYDOWN:
        if (wParam == VK_ESCAPE) {
            SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L);
        }
    case WM_CHAR:
    case WM_KEYUP:

        // We don't want the listbox processing this if we are dragging.

        if (bDragging)
            return 0L;
        break;

    default:
        break;
    }

    return CallWindowProc(lpfnDefProc, hLB, uMsg, wParam, lParam);
}




/******************************Public*Routine******************************\
* MakeMultiDragList
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL WINAPI
MakeMultiDragList(
    HWND hLB
    )
{
    PDRAGPROP pDragProp;

    if (!uDragListMsg) {

        return FALSE;
    }

    //
    // Check that we have not already subclassed this window.
    //

    if (GetProp(hLB, szDragProp)) {
        return TRUE;
    }

    pDragProp = (PDRAGPROP)LocalAlloc(LPTR, sizeof(DRAGPROP));
    if (pDragProp == NULL ) {

        return FALSE;
    }

    SetProp(hLB, szDragProp, (HANDLE)pDragProp);
    pDragProp->lpfnDefProc = SubclassWindow( hLB, DragListSubclassProc );

    return TRUE;
}



/******************************Public*Routine******************************\
* LBMultiItemFromPt
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
int WINAPI
LBMultiItemFromPt(
    HWND hLB,
    POINT pt,
    BOOL bAutoScroll
    )
{
    static LONG dwLastScroll = 0;

    RECT    rc;
    DWORD   dwNow;
    int     nItem;
    WORD    wScrollDelay, wActualDelay;

    ScreenToClient(hLB, &pt);
    GetClientRect(hLB, &rc);

    nItem = ListBox_GetTopIndex( hLB );

    //
    // Is the point in the LB client area?
    //

    if ( PtInRect(&rc, pt) ) {

        //
        // Check each visible item in turn.
        //

        for ( ; ; ++nItem) {

            if ( LB_ERR == ListBox_GetItemRect( hLB, nItem, &rc) ) {
                break;
            }

            if ( PtInRect(&rc, pt) ) {

                return nItem;
            }
        }
    }
    else {

        //
        // If we want autoscroll and the point is directly above or below the
        // LB, determine the direction and if it is time to scroll yet.
        //

        if ( bAutoScroll && (UINT)pt.x < (UINT)rc.right ) {

            if (pt.y <= 0) {
                --nItem;
            }
            else {

                ++nItem;
                pt.y = rc.bottom - pt.y;
            }

            wScrollDelay = (WORD)(1000 / (INITLINESPERSECOND - pt.y/VERTCHANGENUMLINES));

            dwNow = GetTickCount();
            wActualDelay = (WORD)(dwNow - dwLastScroll);

            if (wActualDelay > wScrollDelay) {

                //
                // This will the actual number of scrolls per second to be
                // much closer to the required number.
                //

                if (wActualDelay > wScrollDelay * 2)
                    dwLastScroll = dwNow;
                else
                    dwLastScroll += wScrollDelay;

                ListBox_SetTopIndex( hLB, nItem );
            }
        }
    }

    return -1;
}


/******************************Public*Routine******************************\
* DrawInsert
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
VOID WINAPI
DrawMultiInsert(
    HWND hwndParent,
    HWND hLB,
    int nItem
    )
{
    static POINT ptLastInsert;
    static INT nLastInsert = -1;

    RECT rc;

    //
    // Erase the old mark if necessary
    //

    if ( nLastInsert >= 0 && nItem != nLastInsert ) {

        rc.left   = ptLastInsert.x;
        rc.top    = ptLastInsert.y;
        rc.right  = rc.left + DX_INSERT;
        rc.bottom = rc.top + DY_INSERT;

        //
        // Need to update immediately in case the insert rects overlap.
        //

        InvalidateRect( hwndParent, &rc, TRUE );
        UpdateWindow( hwndParent );

        nLastInsert = -1;
    }

    //
    // Draw a new mark if necessary
    //

    if ( nItem != nLastInsert && nItem >= 0 ) {

        static HICON hInsert = NULL;

        if ( !hInsert ) {
            hInsert = LoadIcon( g_hInst, MAKEINTRESOURCE(IDR_INSERT));
        }

        if ( hInsert ) {

            HDC     hDC;
            int     iItemHeight;

            GetWindowRect( hLB, &rc );
            ScreenToClient( hLB, (LPPOINT)&rc );
            ptLastInsert.x = rc.left - DX_INSERT;

            iItemHeight = ListBox_GetItemHeight( hLB, nItem );
            nLastInsert = nItem;

            nItem -= ListBox_GetTopIndex( hLB );
            ptLastInsert.y = (nItem * iItemHeight) - DY_INSERT / 2;

            ClientToScreen(hLB, &ptLastInsert);
            ScreenToClient(hwndParent, &ptLastInsert);

            hDC = GetDC(hwndParent);
            DrawIcon(hDC, ptLastInsert.x, ptLastInsert.y, hInsert);
            ReleaseDC(hwndParent, hDC);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\ledwnd.c ===
/******************************Module*Header*******************************\
* Module Name: ledwnd.c
*
* Implementation of the LED window.
*
*
* Created: 18-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE

#include <windows.h>             /* required for all Windows applications */
#include <windowsx.h>

#include <string.h>
#include <tchar.h>              /* contains portable ascii/unicode macros */

#include "resource.h"
#include "cdplayer.h"
#include "cdapi.h"
#include "buttons.h"
#include "literals.h"

#define DECLARE_DATA
#include "ledwnd.h"



/* -------------------------------------------------------------------------
** Private functions for the LED class
** -------------------------------------------------------------------------
*/

BOOL
LED_OnCreate(
    HWND hwnd,
    LPCREATESTRUCT lpCreateStruct
    );

void
LED_OnPaint(
    HWND hwnd
    );

void
LED_OnLButtonUp(
    HWND hwnd,
    int x,
    int y,
    UINT keyFlags
    );

void
LED_OnRButtonUp(
    HWND hwnd,
    int x,
    int y,
    UINT keyFlags
    );

void
LED_OnSetText(
    HWND hwnd,
    LPCTSTR lpszText
    );

void
LED_DrawText(
    HWND hwnd,
    LPCTSTR s,
    int sLen
    );

void
LED_CreateLEDFonts(
    HDC hdc
    );


/******************************Public*Routine******************************\
* InitLEDClass
*
* Called to register the LED window class and create a font for the LED
* window to use.  This function must be called before the CD Player dialog
* box is created.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
InitLEDClass(
    HINSTANCE hInst
    )
{
    WNDCLASS    LEDwndclass;
    HDC         hdc;

    ZeroMemory( &LEDwndclass, sizeof(LEDwndclass) );

    /*
    ** Register the LED window.
    */
    LEDwndclass.lpfnWndProc     = LEDWndProc;
    LEDwndclass.hInstance       = hInst;
    LEDwndclass.hCursor         = LoadCursor( NULL, IDC_ARROW );
    LEDwndclass.hbrBackground   = GetStockObject( BLACK_BRUSH );
    LEDwndclass.lpszClassName   = g_szLEDClassName;
    LEDwndclass.style           = CS_OWNDC;

    hdc = GetDC( GetDesktopWindow() );
    LED_CreateLEDFonts( hdc );
    ReleaseDC( GetDesktopWindow(), hdc );

    return RegisterClass( &LEDwndclass );
}

/******************************Public*Routine******************************\
* LEDWndProc
*
* This routine handles the WM_PAINT and WM_SETTEXT messages
* for the "LED" display window.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
LEDWndProc(
    HWND hwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( message ) {

    HANDLE_MSG( hwnd, WM_CREATE,    LED_OnCreate );
    HANDLE_MSG( hwnd, WM_PAINT,     LED_OnPaint );
    HANDLE_MSG( hwnd, WM_LBUTTONUP, LED_OnLButtonUp );
    HANDLE_MSG( hwnd, WM_RBUTTONUP, LED_OnRButtonUp );
    HANDLE_MSG( hwnd, WM_SETTEXT,   LED_OnSetText );

    }

    return DefWindowProc( hwnd, message, wParam, lParam );
}


/*****************************Private*Routine******************************\
* LED_OnCreate
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
LED_OnCreate(
    HWND hwnd,
    LPCREATESTRUCT lpCreateStruct
    )
{
    HDC     hdcLed;

    hdcLed = GetDC( hwnd );
    SelectObject( hdcLed, g_fSmallLedFont ? hLEDFontS : hLEDFontL );
    SetTextColor( hdcLed, RGB(0x80,0x80,0x00) );
    ReleaseDC( hwnd, hdcLed );

    return TRUE;
}



/*****************************Private*Routine******************************\
* LED_OnPaint
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
LED_OnPaint(
    HWND hwnd
    )
{
    PAINTSTRUCT ps;
    TCHAR       s[50];
    int         sLen;
    RECT        rcLed;
    HDC         hdcLed;

    hdcLed = BeginPaint( hwnd, &ps );

#ifdef DAYTONA
    /*
    ** For some (unknown) reason Daytona does not redraw the
    ** screen correctly after the screen save has exited.  Chicago does !!
    */
    DefWindowProc( hwnd, WM_ERASEBKGND, (WPARAM)hdcLed, 0 );
#endif

    GetClientRect( hwnd, &rcLed );
    sLen = GetWindowText( hwnd, s, 50 );

    /*
    ** Draw the LED display text
    */
    LED_DrawText( hwnd, s, sLen );


    /*
    ** Draw a shaded frame around the LED display
    */
    DrawEdge( hdcLed, &rcLed, EDGE_SUNKEN, BF_RECT );

    EndPaint( hwnd, &ps );
}



/*****************************Private*Routine******************************\
* LED_OnLButtonUp
*
* Rotate the time remaing buttons and then set the display accordingly.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
LED_OnLButtonUp(
    HWND hwnd,
    int x,
    int y,
    UINT keyFlags
    )
{
    BOOL b;

    /*
    ** If this window is not the master display LED just return
    */
    if ( GetWindowLong(hwnd, GWL_ID) != IDC_LED ) {
        return;
    }

    b = g_fDisplayDr;
    g_fDisplayDr = g_fDisplayTr;
    g_fDisplayTr = g_fDisplayT;
    g_fDisplayT = b;

    UpdateToolbarTimeButtons();
    UpdateDisplay( DISPLAY_UPD_LED );
}



/*****************************Private*Routine******************************\
* LED_OnRButtonUp
*
* Determine if we should do something interesting with the LED display.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
LED_OnRButtonUp(
    HWND hwnd,
    int x,
    int y,
    UINT keyFlags
    )
{
    DWORD dwTime;
    static DWORD dwTimeSave;
    extern BOOL g_fTitlebarShowing;


    /*
    ** If we are in mini mode and there is no cd loaded and the Shift and
    ** control keys are down and it is more than 500 ms and less than 1500 ms
    ** since an identical sequence was performed then display the credits.
    */
    if ( !g_fTitlebarShowing && (g_State & CD_NO_CD) ) {

        dwTime = GetCurrentTime();

        switch ( keyFlags & (MK_SHIFT | MK_CONTROL) ) {
        case (MK_SHIFT | MK_CONTROL):
            dwTimeSave = dwTime;
            break;

        case 0:
            if ( (dwTime - dwTimeSave) > 500 && (dwTime - dwTimeSave) < 1500 ) {
                void DoC(HWND hwnd);
                DoC( hwnd );
            }
            break;
        }
    }
}


/*****************************Private*Routine******************************\
* DoC
*
* Do interesting things to the LED display
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
DoC(
    HWND hwnd
    )
{
    RECT        rc;
    RECT        rcUpdate;
    HDC         hdc;
    MSG         msg;
    int         dyLine;
    int         yLine;
    TEXTMETRIC  tm;
    DWORD       dwNextTime;
    long        lScroll;
    DWORD       rgb;
    HWND        hwndFocusSave;
    LPSTR       pchSrc, pchDst;
    char        achLine[100];
    int         iEncrypt;
    const int   dxEdge = 2, dyEdge = 2;

    #define EOFCHAR '@'     // end of stream

    pchSrc = &cr[0];

    /* we want to get all mouse and keyboard events, to make
    ** sure we stop the animation when the user clicks or
    ** hits a key
    */
    hwndFocusSave = SetFocus(hwnd);
    SetCapture(hwnd);

    /* Scroll the crs up, one pixel at a time.  pchSrc
    ** points to the encrypted data; achLine contains a decrypted
    ** line (null-terminated).  dyLine is the height of each
    ** line (constant), and yLine is between 0 and dyLine,
    ** indicating how many pixels of the line have been scrolled
    ** in vertically from the bottom
    */
    hdc = GetDC(hwnd);
    SaveDC(hdc);

    SelectObject(hdc, GetStockObject(ANSI_VAR_FONT));
    GetClientRect(hwnd, &rc);
    SetTextAlign(hdc, TA_CENTER);
    SetBkColor(hdc, RGB(0, 0, 0));
    SetRect(&rcUpdate, dxEdge, rc.bottom - (dyEdge + 1),
            rc.right - dxEdge, rc.bottom - dyEdge);
    GetTextMetrics(hdc, &tm);


    if ((dyLine = tm.tmHeight + tm.tmExternalLeading) == 0) {
        dyLine = 1;
    }

    yLine = dyLine;
    dwNextTime = GetCurrentTime();  // time to do the next scroll
    lScroll = 0;
    iEncrypt = 0;


    for ( ;; ) {

        /*
        ** If the user clicks the mouse or hits a key, exit.
        */

        if (PeekMessage( &msg, hwnd, WM_KEYFIRST, WM_KEYLAST,
                         PM_NOREMOVE | PM_NOYIELD)) {
            break;          // exit on key hit
        }

        if (PeekMessage(&msg, hwnd, WM_MOUSEFIRST, WM_MOUSELAST,
                        PM_NOREMOVE | PM_NOYIELD)) {

            if ( (msg.message == WM_MOUSEMOVE) ||
                 (msg.message == WM_NCMOUSEMOVE) ) {

                /* remove and ignore message */
                PeekMessage(&msg, hwnd, msg.message, msg.message,
                            PM_REMOVE | PM_NOYIELD);
            }
            else {
                break;      // exit on click
            }
        }

        /* scroll at a fixed no. of vertical pixels per sec. */
        if (dwNextTime > GetCurrentTime()) {
            continue;
        }

        dwNextTime += 50L;  // millseconds per scroll

        if (yLine == dyLine) {

            /* decrypt a line and copy to achLine */
            pchDst = achLine;

            while (TRUE) {
                *pchDst = (char)(*pchSrc++ ^(128 | (iEncrypt++ & 127)));

                if ((*pchDst == '\r') || (*pchDst == EOFCHAR)) {
                    break;
                }

                pchDst++;
            }

            if (*pchDst == EOFCHAR) {
                break;              // no more lines
            }

            *pchDst = 0;            // null-terminate
            pchSrc++, iEncrypt++;   // skip '\n'
            yLine = 0;
        }

        /* scroll screen up one pixel */
        BitBlt( hdc, dxEdge, dyEdge,
                rcUpdate.right - dxEdge, rcUpdate.top - dxEdge,
                hdc, dxEdge, dyEdge + 1, SRCCOPY);

        /* vary the text colors through a "rainbow" */
        switch ( (int)(lScroll++ / 4) % 5 ) {
        case 0: rgb = RGB(255,   0,   0); break;
        case 1: rgb = RGB(255, 255,   0); break;
        case 2: rgb = RGB(  0, 255,   0); break;
        case 3: rgb = RGB(  0, 255, 255); break;
        case 4: rgb = RGB(255,   0, 255); break;
        }
        SetTextColor(hdc, rgb);

        /* fill in the bottom pixel */
        SaveDC(hdc);
        yLine++;
        IntersectClipRect(hdc, rcUpdate.left, rcUpdate.top,
                          rcUpdate.right, rcUpdate.bottom);

        ExtTextOutA(hdc, rc.right / 2, rc.bottom - yLine,
                    ETO_OPAQUE, &rcUpdate,
                    achLine, lstrlenA(achLine), NULL);
        RestoreDC(hdc, -1);
    }

    RestoreDC(hdc, -1);
    ReleaseDC(hwnd, hdc);
    ReleaseCapture();
    InvalidateRect(hwnd, NULL, TRUE);
    SetFocus(hwndFocusSave);
}


/*****************************Private*Routine******************************\
* LED_ToggleDisplayFont
*
* Toggles between the large and the small display font and erases the
* background of the led display.  This removes any sign of the old font.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
LED_ToggleDisplayFont(
    HWND hwnd,
    BOOL fFont
    )
{
    RECT        rcLed;
    HDC         hdcLed;

    hdcLed = GetDC( hwnd );
    GetClientRect( hwnd, &rcLed );
    SelectObject( hdcLed, fFont ? hLEDFontS : hLEDFontL );
    ReleaseDC( hwnd, hdcLed );
    InvalidateRect(hwnd, NULL, TRUE);
    UpdateWindow(hwnd);
}


/*****************************Private*Routine******************************\
* LED_DrawText
*
* Draws the LED display screen text (quickly).  The text is centered
* vertically and horizontally.  Only the backround is drawn if the g_fFlashed
* flag is set.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
LED_DrawText(
    HWND hwnd,
    LPCTSTR s,
    int sLen
    )
{
    HDC         hdcLed;
    RECT        rc;
    RECT        rcLed;
    SIZE        sz;
    int         xOrigin;
    int         yOrigin;


    hdcLed = GetDC( hwnd );
    GetTextExtentPoint( hdcLed, s, sLen, &sz );
    GetClientRect( hwnd, &rcLed );

    xOrigin = (rcLed.right - sz.cx) / 2;
    yOrigin = (rcLed.bottom - sz.cy) / 2;

    rc.top    = yOrigin;
    rc.bottom = rc.top + sz.cy;
    rc.left   = 2;
    rc.right  = rcLed.right - 3;

    SetBkColor( hdcLed, RGB(0x00,0x00,0x00) );
    if ( g_fFlashLed ) {

        ExtTextOut( hdcLed, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    }
    else {

        ExtTextOut( hdcLed, xOrigin, yOrigin, ETO_OPAQUE, &rc, s, sLen, NULL);
    }
    ReleaseDC( hwnd, hdcLed );
}


/*****************************Private*Routine******************************\
* LED_OnSetText
*
* Change the LED display text.  Calling DefWindowProc ensures that the
* window text is saved correctly.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
LED_OnSetText(
    HWND hwnd,
    LPCTSTR lpszText
    )
{
    DefWindowProc( hwnd, WM_SETTEXT, 0,  (LPARAM)lpszText);

    LED_DrawText( hwnd, lpszText, _tcslen(lpszText) );
}


/*****************************Private*Routine******************************\
* LED_CreateLEDFonts
*
* Small font is 12pt MS Sans Serif
* Large font is 18pt MS Sans Serif
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
LED_CreateLEDFonts(
    HDC hdc
    )
{
    LOGFONT     lf;
    int         iLogPelsY;


    iLogPelsY = GetDeviceCaps( hdc, LOGPIXELSY );

    ZeroMemory( &lf, sizeof(lf) );

    lf.lfHeight = (-12 * iLogPelsY) / 72;   /* 12pt */
    lf.lfWeight = 700;                      /* bold */
    lf.lfCharSet = ANSI_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = PROOF_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_SWISS;
    _tcscpy( lf.lfFaceName, g_szAppFontName );


    hLEDFontS = CreateFontIndirect(&lf);

    lf.lfHeight = (-18 * iLogPelsY) / 72;   /* 18 pt */
    lf.lfWeight = 400;                      /* normal */
    hLEDFontL = CreateFontIndirect(&lf);


    /*
    ** If can't create either font set up some sensible defaults.
    */
    if ( hLEDFontL == NULL || hLEDFontS == NULL ) {

        if ( hLEDFontL != NULL ) {
            DeleteObject( hLEDFontL );
        }

        if ( hLEDFontS != NULL ) {
            DeleteObject( hLEDFontS );
        }

        hLEDFontS = hLEDFontL = GetStockObject( ANSI_VAR_FONT );
    }
}


/* -------------------------------------------------------------------------
** Private functions for the Text class
** -------------------------------------------------------------------------
*/
void
Text_OnPaint(
    HWND hwnd
    );

LRESULT CALLBACK
TextWndProc(
    HWND hwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam
    );

void
Text_OnSetText(
    HWND hwnd,
    LPCTSTR lpszText
    );

void
Text_OnSetFont(
    HWND hwndCtl,
    HFONT hfont,
    BOOL fRedraw
    );

/******************************Public*Routine******************************\
* Init_SJE_TextClass
*
* Called to register the text window class .
* This function must be called before the CD Player dialog box is created.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
Init_SJE_TextClass(
    HINSTANCE hInst
    )
{
    WNDCLASS    wndclass;

    ZeroMemory( &wndclass, sizeof(wndclass) );

    /*
    ** Register the Text window.
    */
    wndclass.lpfnWndProc     = TextWndProc;
    wndclass.hInstance       = hInst;
    wndclass.hCursor         = LoadCursor( NULL, IDC_ARROW );
    wndclass.hbrBackground   = (HBRUSH)(COLOR_BTNFACE + 1);
    wndclass.lpszClassName   = g_szTextClassName;

    return RegisterClass( &wndclass );
}


/******************************Public*Routine******************************\
* TextWndProc
*
* This routine handles the WM_PAINT and WM_SETTEXT messages
* for the "Text" display window.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
TextWndProc(
    HWND hwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch( message ) {

    HANDLE_MSG( hwnd, WM_PAINT,     Text_OnPaint );
    HANDLE_MSG( hwnd, WM_SETTEXT,   Text_OnSetText );
    HANDLE_MSG( hwnd, WM_SETFONT,   Text_OnSetFont );
    }

    return DefWindowProc( hwnd, message, wParam, lParam );
}


/*****************************Private*Routine******************************\
* Text_OnPaint
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
Text_OnPaint(
    HWND hwnd
    )
{
    PAINTSTRUCT ps;
    TCHAR       s[128];
    int         sLen;
    HDC         hdc;
    RECT        rc;
    HFONT       hfont;
    HFONT       hfontOrg;
    LONG        lStyle;


    hdc = BeginPaint( hwnd, &ps );

    GetWindowRect( hwnd, &rc );
    MapWindowRect( GetDesktopWindow(), hwnd, &rc );

    lStyle = GetWindowLong( hwnd, GWL_STYLE );
    if ( lStyle & SS_GRAYRECT ) {

        PatB( hdc, 0, 0, rc.right , 1, rgbShadow );
        PatB( hdc, 0, 1, rc.right , 1, rgbHilight );

    }
    else {

        sLen = GetWindowText( hwnd, s, 128 );
        hfont = (HFONT)GetWindowLong( hwnd, GWL_USERDATA );
        if ( hfont ) {
            hfontOrg = SelectObject( hdc, hfont );
        }

        /*
        ** Draw a frame around the window
        */
        DrawEdge( hdc, &rc, EDGE_SUNKEN, BF_RECT );


        /*
        ** Draw the text
        */
        SetBkColor( hdc, GetSysColor( COLOR_BTNFACE ) );
        SetTextColor( hdc, GetSysColor( COLOR_WINDOWTEXT ) );
        rc.left = 1 + (2 * GetSystemMetrics(SM_CXBORDER));

        DrawText( hdc, s, sLen, &rc,
                  DT_NOPREFIX | DT_LEFT | DT_VCENTER |
                  DT_NOCLIP | DT_SINGLELINE );

        if ( hfontOrg ) {
            SelectObject( hdc, hfontOrg );
        }
    }

    EndPaint( hwnd, &ps );
}


/*****************************Private*Routine******************************\
* Text_OnSetText
*
* Change the text.  Calling DefWindowProc ensures that the
* window text is saved correctly.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
Text_OnSetText(
    HWND hwnd,
    LPCTSTR lpszText
    )
{
    DefWindowProc( hwnd, WM_SETTEXT, 0,  (LPARAM)lpszText);
    InvalidateRect( hwnd, NULL, TRUE );
    UpdateWindow( hwnd );
}


/*****************************Private*Routine******************************\
* Text_OnSetFont
*
* Sets the windows font
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
Text_OnSetFont(
    HWND hwnd,
    HFONT hfont,
    BOOL fRedraw
    )
{
    SetWindowLong( hwnd, GWL_USERDATA, (LONG)hfont );
    if ( fRedraw ) {
        InvalidateRect( hwnd, NULL, TRUE );
        UpdateWindow( hwnd );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\ledwnd.h ===
/******************************Module*Header*******************************\
* Module Name: ledwnd.h
*
* Public interface to the LED window implementation
*
*
* Created: dd-mm-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

BOOL
InitLEDClass(
    HINSTANCE hInst
    );

LRESULT CALLBACK
LEDWndProc(
    HWND hwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
Init_SJE_TextClass(
    HINSTANCE hInst
    );


#ifdef DECLARE_DATA
BYTE cr[] = {
    0x8D, 0x8B, 0x8F, 0x89, 0xA9, 0xA5, 0xC5, 0xC3,
    0xA8, 0xD9, 0xE6, 0xEA, 0xF5, 0xE8, 0xFC, 0xAF,
    0xF4, 0xF4, 0xE4, 0xF6, 0xF8, 0xFA, 0xE6, 0xF2,
    0xFC, 0xB9, 0xF8, 0xE2, 0xBC, 0xB0, 0x93, 0x95,
    0xAD, 0xAB, 0xF1, 0xD7, 0xC1, 0xD5, 0xCE, 0xC2,
    0xC6, 0x89, 0xEF, 0xD8, 0xD8, 0xDF, 0xC1, 0xDF,
    0xBD, 0xBB, 0xBF, 0xB9, 0xB9, 0xBF, 0x9B, 0x97,
    0xCC, 0xDC, 0xC9, 0xCF, 0xD9, 0xD9, 0x9E, 0xDD,
    0xB9, 0xE1, 0xEF, 0xCE, 0xCE, 0xC8, 0xCC, 0x8D,
    0xA7, 0xA1, 0xA4, 0xEB, 0x8E, 0xBF, 0xAB, 0xBC,
    0xB5, 0xBC, 0xB3, 0xBD, 0xBA, 0xD8, 0xDC, 0x96,
    0xB6, 0xBD, 0xA8, 0xBE, 0xAB, 0xFD, 0x99, 0xAA,
    0x99, 0xEC, 0xE8, 0xA2, 0x8A, 0x91, 0x8E, 0x88,
    0x86, 0x90, 0xCA, 0xBB, 0x84, 0x84, 0x82, 0x83,
    0x99, 0x81, 0x81, 0xFE, 0xFE, 0xBF, 0x99, 0x9F,
    0x96, 0xD9, 0xAB, 0x8E, 0x95, 0x9E, 0x95, 0xF2,
    0x8A, 0xCC, 0xEB, 0xE8, 0xE1, 0xA5, 0xD2, 0xF5,
    0xE1, 0xEA, 0xE1, 0xEE, 0xFE, 0x80, 0x84, 0x82,
    0x9A, 0x9C, 0x98, 0xBE, 0xB4, 0xF8, 0xF7, 0xF9,
    0xF9, 0xFE, 0xFF, 0xFF, 0xBC, 0xFF, 0xE7, 0xBF,
    0x8D, 0xAC, 0xA8, 0xAE, 0xAE, 0xE9, 0xC7, 0xD2,
    0xDA, 0xC0, 0xCF, 0x8B, 0xEB, 0xDF, 0xC7, 0xC9,
    0xD6, 0xD8, 0xC6, 0xDB, 0xC7, 0xB8, 0xBC, 0xBA,
    0xB2, 0xB4, 0xB0, 0x96, 0x9C, 0xCD, 0xCC, 0xD0,
    0xA4, 0xB4, 0xA1, 0xB7, 0xAD, 0xAA, 0xA8, 0xE7,
    0xE5, 0xC4, 0xC0, 0xC6, 0xC6, 0x8C, 0xA2, 0xA6,
    0xA3, 0xA5, 0xB3, 0xBA, 0xA6, 0xF5, 0x94, 0xB6,
    0xB6, 0xB2, 0xA9, 0xD6, 0xD6, 0x9E, 0xAC, 0xB6,
    0x93, 0x95, 0x8B, 0x82, 0x8A, 0x8A, 0xC6, 0xB7,
    0x81, 0x8C, 0x98, 0x99, 0x95, 0xE0, 0xE4, 0xE2,
    0xFA, 0xFC, 0xF8, 0xDE, 0xD4, 0xBA, 0x84, 0x9E,
    0x9F, 0x90, 0x94, 0x9A, 0x90, 0xDD, 0xAB, 0xB6,
    0xA0, 0xC5, 0xE7, 0xF0, 0xED, 0xE2, 0xE8, 0xA7,
    0xA5, 0x84, 0x80, 0x86, 0x86, 0xDF, 0xE7, 0xEC,
    0xFB, 0xB1, 0xC6, 0xE6, 0xE6, 0xFB, 0xF3, 0xE5,
    0x95, 0x93, 0x97, 0x91, 0x91, 0x97, 0x93, 0x95,
    0x8D, 0x81, 0xC6, 0xCC, 0xC7, 0xD0, 0xCB, 0xC2,
    0xC6, 0xDD, 0xCB, 0xDF, 0xC5, 0xC2, 0xC0, 0x8F,
    0x9D, 0xBC, 0xB8, 0xBE, 0xBE, 0xF9, 0xD7, 0xC2,
    0xCA, 0xD8, 0x9A, 0xE8, 0xD4, 0xD8, 0xCE, 0xCF,
    0xA1, 0xB3, 0xA6, 0xCE, 0xCE, 0x82, 0xA7, 0xBE,
    0xA4, 0xAC, 0xEA, 0x9B, 0xA5, 0xAE, 0xA5, 0xAA,
    0xBE, 0xDC, 0xD8, 0xDE, 0xDE, 0xD8, 0xDC, 0xFA,
    0xF8, 0xB8, 0xBE, 0xB6, 0xB5, 0xB3, 0xB7, 0xAC,
    0x94, 0x93, 0x83, 0x97, 0x8D, 0x93, 0x83, 0xC7,
    0xC5, 0xE4, 0xE0, 0xE6, 0xE6, 0xA1, 0x8F, 0x9A,
    0x82, 0x98, 0x97, 0xD3, 0xB7, 0x99, 0x97, 0x8E,
    0x8C, 0x96, 0x94, 0xF6, 0xF6, 0xB7, 0x97, 0x93,
    0xEC, 0xA1, 0xCA, 0xE6, 0xE5, 0xE9, 0x8B, 0x8D,
    0x85, 0x83, 0x87, 0x81, 0xA1, 0xAD, 0xEA, 0xEA,
    0xF4, 0xF8, 0xF1, 0xF2, 0xE0, 0xF0, 0xF2, 0xB7,
    0xEC, 0xF6, 0xBA, 0xB6, 0x91, 0x97, 0x93, 0x95,
    0xF0, 0xC4, 0xCC, 0xC6, 0xC8, 0xCA, 0xD6, 0xC2,
    0x88, 0xEB, 0xD8, 0xC4, 0xC3, 0xC0, 0xCB, 0xDD,
    0xBD, 0xBB, 0xBF, 0xB9, 0xB9, 0xBF, 0xBB, 0xBD,
    0xB5, 0xB3, 0xB7, 0xB1, 0xB1, 0xB7, 0xFE, 0xB2,
    0xCA, 0xDB
};
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\dragdrop.h ===
/******************************Module*Header*******************************\
* Module Name: DragDrop.h
*
* An attempt to implement dragging and dropping between Multi-selection
* listboxes.
*
* Created: dd-mm-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#ifndef _INC_DRAGMULITLIST
#define _INC_DRAGMULTILIST

typedef struct {
    UINT    uNotification;
    HWND    hWnd;
    POINT   ptCursor;
    DWORD   dwState;
} DRAGMULTILISTINFO, FAR *LPDRAGMULTILISTINFO;

#define DL_BEGINDRAG    (LB_MSGMAX+100)
#define DL_DRAGGING     (LB_MSGMAX+101)
#define DL_DROPPED      (LB_MSGMAX+102)
#define DL_CANCELDRAG   (LB_MSGMAX+103)

#define DL_CURSORSET    0

#define DL_MOVE         0
#define DL_COPY         1


#define SJE_DRAGLISTMSGSTRING "sje_DragMultiListMsg"

/*---------------------------------------------------------------------
** Exported functions and variables
**---------------------------------------------------------------------
*/
UINT WINAPI
InitDragMultiList(
    void
    );

BOOL WINAPI
MakeMultiDragList(
    HWND hLB
    );

int WINAPI
LBMultiItemFromPt(
    HWND hLB,
    POINT pt,
    BOOL bAutoScroll
    );

VOID WINAPI
DrawMultiInsert(
    HWND hwndParent,
    HWND hLB,
    int nItem
    );

#endif  /* _INC_DRAGMULTILIST */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\preferen.c ===
/******************************Module*Header*******************************\
* Module Name: preferen.c
*
* Code to support the preferneces dialog box.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE

#include <windows.h>            /* required for all Windows applications */
#include <windowsx.h>

#include "resource.h"
#include "cdplayer.h"
#include "preferen.h"


/* --------------------------------------------------------------------
** Other stuff
** --------------------------------------------------------------------
*/
#include <commctrl.h>

WNDPROC lpfnDefBtnProc;
HWND    hwndPrefDlg;

LRESULT CALLBACK
SubClassedBtnProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );


/* -------------------------------------------------------------------------
** Private Globals
** -------------------------------------------------------------------------
*/
BOOL    fSmallFont;


/******************************Public*Routine******************************\
* PreferencesDlgProc
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL CALLBACK
PreferencesDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
#if WINVER >= 0x0400
#include "literals.h"
#include "helpids.h"
    static const DWORD aIds[] = {
        IDC_STOP_CD_ON_EXIT,    IDH_CD_STOP_CD_ON_EXIT,
        IDC_SAVE_ON_EXIT,       IDH_CD_SAVE_ON_EXIT,
        IDC_SHOW_TOOLTIPS,      IDH_CD_SHOW_TOOLTIPS,
        IDC_INTRO_PLAY_LEN,     IDH_CD_INTRO_LENGTH,
        IDC_INTRO_SPINBTN,      IDH_CD_INTRO_LENGTH,
        IDC_SMALL_FONT,         IDH_CD_DISPLAY_FONT,
        IDC_LARGE_FONT,         IDH_CD_DISPLAY_FONT,
        IDC_LED_DISPLAY,        IDH_CD_DISPLAY_FONT,
        0,                      0
    };
#endif

    switch ( message ) {

    HANDLE_MSG( hwnd, WM_INITDIALOG,        Preferences_OnInitDialog );
    HANDLE_MSG( hwnd, WM_COMMAND,           Preferences_OnCommand );

#ifdef DAYTONA
    HANDLE_MSG( hwnd, WM_CTLCOLORDLG,       Common_OnCtlColor );
    HANDLE_MSG( hwnd, WM_CTLCOLORSTATIC,    Common_OnCtlColor );
    HANDLE_MSG( hwnd, WM_CTLCOLORBTN,       Common_OnCtlColor );
#endif

#if WINVER >= 0x0400
    case WM_HELP:
        WinHelp( ((LPHELPINFO)lParam)->hItemHandle, g_HelpFileName,
                 HELP_WM_HELP, (DWORD)(LPVOID)aIds );
        break;

    case WM_CONTEXTMENU:
        WinHelp( (HWND)wParam, g_HelpFileName,
                 HELP_CONTEXTMENU, (DWORD)(LPVOID)aIds );
        break;
#endif

    default:
        return FALSE;
    }
}



/*****************************Private*Routine******************************\
* Preferences_OnInitDialog
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
Preferences_OnInitDialog(
    HWND hwnd,
    HWND hwndFocus,
    LPARAM lParam
    )
{
    fSmallFont = g_fSmallLedFont;

    if (!g_fSmallLedFont) {

        LED_ToggleDisplayFont( GetDlgItem( hwnd, IDC_LED_DISPLAY ), g_fSmallLedFont );
    }

    Button_SetCheck( GetDlgItem( hwnd, IDC_SMALL_FONT ), g_fSmallLedFont );
    Button_SetCheck( GetDlgItem( hwnd, IDC_LARGE_FONT ), !g_fSmallLedFont );

    Button_SetCheck( GetDlgItem( hwnd, IDC_STOP_CD_ON_EXIT ), g_fStopCDOnExit );
    Button_SetCheck( GetDlgItem( hwnd, IDC_SAVE_ON_EXIT ), g_fSaveOnExit );
    Button_SetCheck( GetDlgItem( hwnd, IDC_SHOW_TOOLTIPS ), g_fToolTips );

#if WINVER >= 0x400
    /*
    ** Set up the intro play length edit field
    */
    Edit_LimitText( GetDlgItem( hwnd, IDC_INTRO_PLAY_LEN ), 2 );
    SetDlgItemInt( hwnd, IDC_INTRO_PLAY_LEN, g_IntroPlayLength, TRUE );
    SendDlgItemMessage( hwnd, IDC_INTRO_SPINBTN, UDM_SETRANGE, 0,
                        MAKELPARAM( INTRO_UPPER_LEN, INTRO_LOWER_LEN) );

    /*
    ** Subclass the OK button so that we can perform validation on the
    ** intro play length.
    */
    lpfnDefBtnProc = SubclassWindow( GetDlgItem(hwnd, IDOK),
                                     SubClassedBtnProc );
    hwndPrefDlg = hwnd;
#endif

    return TRUE;
}



/*****************************Private*Routine******************************\
* Preferences_OnCommand
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
Preferences_OnCommand(
    HWND hwnd,
    int id,
    HWND hwndCtl,
    UINT codeNotify
    )
{
    switch (id) {

    case IDC_SMALL_FONT:
        if (!fSmallFont) {
            fSmallFont = TRUE;
            LED_ToggleDisplayFont( GetDlgItem( hwnd, IDC_LED_DISPLAY ), fSmallFont );
        }
        break;

    case IDC_LARGE_FONT:
        if (fSmallFont) {
            fSmallFont = FALSE;
            LED_ToggleDisplayFont( GetDlgItem( hwnd, IDC_LED_DISPLAY ), fSmallFont );
        }
        break;

    case IDOK:
        if ( fSmallFont != g_fSmallLedFont ) {

            g_fSmallLedFont = fSmallFont;
            LED_ToggleDisplayFont( g_hwndControls[INDEX(IDC_LED)], g_fSmallLedFont );
            UpdateDisplay( DISPLAY_UPD_LED );
        }

        g_fToolTips = Button_GetCheck( GetDlgItem( hwnd, IDC_SHOW_TOOLTIPS ));
        EnableToolTips( g_fToolTips );
        g_fSaveOnExit   = Button_GetCheck( GetDlgItem( hwnd, IDC_SAVE_ON_EXIT ) );
        g_fStopCDOnExit = Button_GetCheck( GetDlgItem( hwnd, IDC_STOP_CD_ON_EXIT ) );

#if WINVER >= 0x400
        {
            BOOL fSuccess;

            g_IntroPlayLength = (int)GetDlgItemInt( hwnd, IDC_INTRO_PLAY_LEN,
                                                    &fSuccess, TRUE );
            /*
            ** As the edit field has already been validated the call above
            ** should not fail.  But just make one final check...
            */

            if (!fSuccess) {
                g_IntroPlayLength = 10;
            }

            /*
            ** Make sure that the intro length is kept within its correct
            ** bounds.
            */

            g_IntroPlayLength = min(g_IntroPlayLength, INTRO_UPPER_LEN);
            g_IntroPlayLength = max(g_IntroPlayLength, INTRO_LOWER_LEN);
        }
#endif

        /* fall thru */

    case IDCANCEL:
        EndDialog( hwnd, id );
        break;
    }
}


#if WINVER >= 0x400
/*****************************Private*Routine******************************\
* SubClassedBtnProc
*
* This function is used to ensure that the Intro play length edit field
* always contains a valid integer number.  Valid numbers are between
* INTRO_LOWER_LEN and INTRO_UPPER_LEN inclusive.
* ie. INTRO_LOWER_LEN >= i >= INTRO_UPPER_LEN
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
SubClassedBtnProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    /*
    ** When the user clicks on the OK button we get a BM_SETSTATE message
    ** with wParam != 0.  When we get this message we should ensure that
    ** the Intro length edit box contains a valid integer number.
    */

    if ( (message == BM_SETSTATE) && (wParam != 0) ) {

        BOOL    fSuccess;
        int     i;

        /*
        ** Read the current edit field value.
        */
        i = (int)GetDlgItemInt( hwndPrefDlg, IDC_INTRO_PLAY_LEN,
                                &fSuccess, TRUE );


        /*
        ** if the above call failed it probably means that the users
        ** has entered junk in the edit field - so default back to the
        ** original value of g_IntroPlayLength.
        */

        if (!fSuccess) {
            i = g_IntroPlayLength;
        }


        /*
        ** Make sure that the intro length is kept within its correct
        ** bounds.
        */
        if (i < INTRO_LOWER_LEN) {
            i = INTRO_LOWER_LEN;
            fSuccess = FALSE;
        }
        else if (i > INTRO_UPPER_LEN) {
            i = INTRO_UPPER_LEN;
            fSuccess = FALSE;
        }

        /*
        ** We only update the edit field if its value has
        ** become invalid.
        */
        if (!fSuccess) {

            SetDlgItemInt( hwndPrefDlg, IDC_INTRO_PLAY_LEN, i, TRUE );
            UpdateWindow( GetDlgItem( hwndPrefDlg, IDC_INTRO_PLAY_LEN ) );
        }
    }


    /*
    ** Make sure that we pass on all messages to the buttons original
    ** window proc.
    */

    return CallWindowProc( lpfnDefBtnProc, hwnd, message, wParam, lParam);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\literals.c ===
/******************************Module*Header*******************************\
* Module Name: literals.c
*
* Global string variables that don't need converting for international builds.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/
#define NOOLE
#include <windows.h>

#include "resource.h"       // Needed to pick up correct app font.

//#ifdef CHICAGO
#include <regstr.h>
//#endif

      TCHAR     g_szEmpty[]                 = TEXT("");
      TCHAR     g_IniFileName[]             = TEXT("cdplayer.ini");
      TCHAR     g_HelpFileName[]            = TEXT("cdplayer.hlp");
      TCHAR     g_HTMLHelpFileName[]        = TEXT("cdplayer.chm");

const TCHAR     g_szBlank[]                 = TEXT(" ");
const TCHAR     g_szSJE_CdPlayerClass[]     = TEXT("SJE_CdPlayerClass");
const TCHAR     g_szSndVol32[]              = TEXT("sndvol32.exe");
const TCHAR     TRACK_TIME_FORMAT[]         = TEXT("[%02d] %02d%s%02d");
const TCHAR     TRACK_TIME_LEADOUT_FORMAT[] = TEXT("[%02d]-%02d%s%02d");
const TCHAR     TRACK_REM_FORMAT[]          = TEXT("[%02d]<%02d%s%02d>");
const TCHAR     DISC_REM_FORMAT[]           = TEXT("[--]<%02d%s%02d>");

      TCHAR     g_szSaveSettingsOnExit[]    = TEXT("SaveSettingsOnExit");
      TCHAR     g_szSmallFont[]             = TEXT("SmallFont");
      TCHAR     g_szToolTips[]              = TEXT("ToolTips");
      TCHAR     g_szStopCDPlayingOnExit[]   = TEXT("StopCDPlayingOnExit");
      TCHAR     g_szInOrderPlay[]           = TEXT("InOrderPlay");
      TCHAR     g_szMultiDiscPlay[]         = TEXT("MultiDiscPlay");
      TCHAR     g_szDisplayT[]              = TEXT("DisplayT");
      TCHAR     g_szDisplayTr[]             = TEXT("DisplayTr");
      TCHAR     g_szDisplayDr[]             = TEXT("DisplayDr");
      TCHAR     g_szIntroPlay[]             = TEXT("IntroPlay");
      TCHAR     g_szIntroPlayLen[]          = TEXT("IntroPlayLen");
      TCHAR     g_szContinuousPlay[]        = TEXT("ContinuousPlay");
      TCHAR     g_szToolbar[]               = TEXT("ToolBar");
      TCHAR     g_szDiscAndTrackDisplay[]   = TEXT("DiscAndTrackDisplay");
      TCHAR     g_szStatusBar[]             = TEXT("StatusBar");
      TCHAR     g_szWindowOriginX[]         = TEXT("WindowOriginX");
      TCHAR     g_szWindowOriginY[]         = TEXT("WindowOriginY");
      TCHAR     g_szWindowOrigin[]          = TEXT("WindowOrigin");
      TCHAR     g_szSettings[]              = TEXT("Settings");
      TCHAR     g_szRandomPlay[]            = TEXT("RandomPlay");
const TCHAR     g_szNothingThere[]          = TEXT("~~^^");
      TCHAR     g_szEntryTypeF[]            = TEXT("EntryType=%d");
      TCHAR     g_szArtistF[]               = TEXT("artist=%s");
      TCHAR     g_szTitleF[]                = TEXT("title=%s");
      TCHAR     g_szNumTracksF[]            = TEXT("numtracks=%d");
      TCHAR     g_szOrderF[]                = TEXT("order=");
      TCHAR     g_szNumPlayF[]              = TEXT("numplay=%d");

      TCHAR     g_szEntryType[]             = TEXT("EntryType");
      TCHAR     g_szArtist[]                = TEXT("artist");
      TCHAR     g_szTitle[]                 = TEXT("title");
      TCHAR     g_szNumTracks[]             = TEXT("numtracks");
      TCHAR     g_szOrder[]                 = TEXT("order");
      TCHAR     g_szNumPlay[]               = TEXT("numplay");

      TCHAR     g_szThreeNulls[]            = TEXT("\0\0\0");
      TCHAR     g_szSectionF[]              = TEXT("%lX");

const TCHAR     g_szMusicBoxIni[]           = TEXT("musicbox.ini");
const TCHAR     g_szMusicBoxFormat[]        = TEXT("Track%d");
const TCHAR     g_szPlayList[]              = TEXT("PlayList");
const TCHAR     g_szDiscTitle[]             = TEXT("DiscTitle");

const TCHAR     g_szTextClassName[]         = TEXT("SJE_TextClass");
const TCHAR     g_szLEDClassName[]          = TEXT("SJE_LEDClass");
const TCHAR     g_szAppFontName[]           = TEXT(APP_FONT);
const TCHAR     g_szPlay[]                  = TEXT("PLAY");
const TCHAR     g_szTrack[]                 = TEXT("TRACK");
const TCHAR     g_szCDA[]                   = TEXT("CDA");
const TCHAR     g_szTrackFormat[]           = TEXT("%d");
const TCHAR     g_szNumbers[]               = TEXT("0123456789");
const TCHAR     g_szColon[]                 = TEXT(":");
const TCHAR     g_szColonBackSlash[]        = TEXT(":\\");

const TCHAR     g_szPlayOption[]            = TEXT("-PLAY ");
const TCHAR     g_szTrackOption[]           = TEXT("-TRACK ");
const TCHAR     g_szCdplayer[]              = TEXT("CDPLAYER ");

const TCHAR     g_chBlank                   = TEXT(' ');
const TCHAR     g_chOptionSlash             = TEXT('/');
const TCHAR     g_chOptionHyphen            = TEXT('-');
const TCHAR     g_chNULL                    = TEXT('\0');

const TCHAR     g_szRegistryKey[]           = REGSTR_PATH_WINDOWSAPPLETS TEXT("\\CdPlayer\\Settings");
const TCHAR     g_szUpdate[]                = TEXT("UPDATE");
const TCHAR     g_szUpdateOption[]          = TEXT(" -UPDATE ");

const TCHAR     g_szCdPlayerMutex[]         = TEXT("CdPlayerThereCanOnlyBeOne");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\literals.h ===
/******************************Module*Header*******************************\
* Module Name: literals.c
*
* Global string variables that don't need converting for international builds.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/
#define NOUSER
#define NOGDI
#define NOOLE
#include <windows.h>


extern       TCHAR     g_szEmpty[];
extern       TCHAR     g_IniFileName[];
extern       TCHAR     g_HelpFileName[];
extern       TCHAR     g_HTMLHelpFileName[];

extern const TCHAR     g_szBlank[];
extern const TCHAR     g_szSJE_CdPlayerClass[];
extern const TCHAR     g_szSndVol32[];
extern const TCHAR     TRACK_TIME_FORMAT[];
extern const TCHAR     TRACK_TIME_LEADOUT_FORMAT[];
extern const TCHAR     TRACK_REM_FORMAT[];
extern const TCHAR     DISC_REM_FORMAT[];

extern       TCHAR     g_szSaveSettingsOnExit[];
extern       TCHAR     g_szSmallFont[];
extern       TCHAR     g_szToolTips[];
extern       TCHAR     g_szStopCDPlayingOnExit[];
extern       TCHAR     g_szInOrderPlay[];
extern       TCHAR     g_szMultiDiscPlay[];
extern       TCHAR     g_szDisplayT[];
extern       TCHAR     g_szDisplayTr[];
extern       TCHAR     g_szDisplayDr[];
extern       TCHAR     g_szIntroPlay[];
extern       TCHAR     g_szIntroPlayLen[];
extern       TCHAR     g_szContinuousPlay[];
extern       TCHAR     g_szToolbar[];
extern       TCHAR     g_szDiscAndTrackDisplay[];
extern       TCHAR     g_szStatusBar[];
extern       TCHAR     g_szWindowOriginX[];
extern       TCHAR     g_szWindowOriginY[];
extern       TCHAR     g_szWindowOrigin[];
extern       TCHAR     g_szSettings[];
extern       TCHAR     g_szRandomPlay[];
extern const TCHAR     g_szNothingThere[];
extern       TCHAR     g_szEntryTypeF[];
extern       TCHAR     g_szArtistF[];
extern       TCHAR     g_szTitleF[];
extern       TCHAR     g_szNumTracksF[];
extern       TCHAR     g_szOrderF[];
extern       TCHAR     g_szNumPlayF[];

extern       TCHAR     g_szEntryType[];
extern       TCHAR     g_szArtist[];
extern       TCHAR     g_szTitle[];
extern       TCHAR     g_szNumTracks[];
extern       TCHAR     g_szOrder[];
extern       TCHAR     g_szNumPlay[];

extern       TCHAR     g_szThreeNulls[];
extern       TCHAR     g_szSectionF[];

extern const TCHAR     g_szMusicBoxIni[];
extern const TCHAR     g_szMusicBoxFormat[];
extern const TCHAR     g_szPlayList[];
extern const TCHAR     g_szDiscTitle[];

extern const TCHAR     g_szTextClassName[];
extern const TCHAR     g_szLEDClassName[];
extern const TCHAR     g_szAppFontName[];
extern const TCHAR     g_szPlay[];
extern const TCHAR     g_szTrack[];
extern const TCHAR     g_szCDA[];
extern const TCHAR     g_szTrackFormat[];
extern const TCHAR     g_szNumbers[];
extern const TCHAR     g_szColon[];
extern const TCHAR     g_szColonBackSlash[];

extern const TCHAR     g_szPlayOption[];
extern const TCHAR     g_szTrackOption[];
extern const TCHAR     g_szCdplayer[];

extern const TCHAR     g_chBlank;
extern const TCHAR     g_chOptionSlash;
extern const TCHAR     g_chOptionHyphen;
extern const TCHAR     g_chNULL;

extern const TCHAR     g_szRegistryKey[];

extern const TCHAR     g_szUpdate[];
extern const TCHAR     g_szUpdateOption[];

extern const TCHAR     g_szCdPlayerMutex[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\preferen.h ===
/******************************Module*Header*******************************\
* Module Name: preferen.h
*
* Code to support the preferneces dialog box.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/


BOOL CALLBACK
PreferencesDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
Preferences_OnInitDialog(
    HWND hwnd,
    HWND hwndFocus,
    LPARAM lParam
    );

void
Preferences_OnCommand(
    HWND hwnd,
    int id,
    HWND hwndCtl,
    UINT codeNotify
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by TOOLBAR.RC
//

#ifdef DAYTONA
#define APP_FONT "MS Shell Dlg"
#else
#define APP_FONT "MS Sans Serif"
#endif



//
// These are indexes used by the toolbar.
//
#define IDX_1                           0
#define IDX_2                           1
#define IDX_3                           2
#define IDX_4                           3
#define IDX_5                           4
#define IDX_6                           5
#define IDX_7                           6
#define IDX_8                           7
#define IDX_9                           8
#define IDX_10                          9

#define DEFAULT_TBAR_SIZE               11
#define NUMBER_OF_BITMAPS               8

#define PLAYBAR_BITMAPS                 8

#define ID_STATUSBAR                    8
#define ID_TOOLBAR                      9

//
// These are resource ID's
//
#define IDR_TOOLBAR                     101
#define IDR_MAINMENU                    102
#define IDR_DISCINFODLG                 103
#define IDR_CDPLAYER                    104
#define IDR_PLAYBAR                     105
#define IDR_SCANNING                    106
#define IDR_CDPLAYER_ICON               107
#define IDR_TRACK                       108
#define IDR_DROP                        109
#define IDR_SHELLICON                   110
#define IDR_DROPDEL                     111
#define IDR_DROPCPY                     112
#define IDR_PREFERENCES                 113
#define IDR_INSERT                      114
#define IDR_TOOLBAR_SM                  115
#define IDR_TOOLBAR_L                   116
#define IDR_TOOLBAR_LM                  117
#define IDR_ACCELTABLE                  118

//
// These are menu command ID
//
#define DISC_MENU_BASE                  300
#define IDM_DATABASE_EDIT               300
#define IDM_DATABASE_EXIT               301

#define VIEW_MENU_BASE                  400
#define IDM_VIEW_TOOLBAR                400
#define IDM_VIEW_TRACKINFO              401
#define IDM_VIEW_STATUS                 402
#define IDM_TIME_REMAINING              403
#define IDM_TRACK_REMAINING             404
#define IDM_DISC_REMAINING              405
#define IDM_VIEW_VOLUME                 406

#define OPTIONS_MENU_BASE               500
#define IDM_OPTIONS_RANDOM              501
#define IDM_OPTIONS_MULTI               502
#define IDM_OPTIONS_CONTINUOUS          503
#define IDM_OPTIONS_INTRO               504
#define IDM_OPTIONS_PREFERENCES         505

#define HELP_MENU_BASE                  600
#define IDM_HELP_CONTENTS               600
#define IDM_HELP_USING                  601
#define IDM_HELP_ABOUT                  602
#define IDM_HELP_TOPICS                 603


//
// These are accelerator key ID's (I think !!)
//
#define IDK_SKIPF                       700
#define IDK_SKIPB                       701
#define IDK_PLAY                        702
#define IDK_STOP                        703
#define IDK_PAUSE                       704
#define IDK_EJECT                       705
#define IDK_RESCAN                      706


//
// These are the ID's of the controls on the
// IDR_CDPLAYER resource (dialog box)
//
#define IDC_CDPLAYER_FIRST              1000
#define IDC_BUTTON1                     1000
#define IDC_BUTTON2                     1001

#define IDC_BUTTON3                     1002
#define IDC_BUTTON4                     1003
#define IDC_BUTTON5                     1004
#define IDC_BUTTON6                     1005
#define IDC_BUTTON7                     1006
#define IDC_BUTTON8                     1007
#define IDC_LED                         1008

#define IDC_TRACKINFO_FIRST             1009
#define IDC_COMBO1                      1009
#define IDC_COMBO1_TEXT                 1010
#define IDC_EDIT1                       1011
#define IDC_EDIT1_TEXT                  1012
#define IDC_COMBO2                      1013
#define IDC_COMBO2_TEXT                 1014
#define IDC_CDPLAYER_LAST               1014

//
// Toolbar command ID's
//
// #define IDM_OPTIONS_SELECTED            550
// #define IDM_OPTIONS_SINGLE              551
#define IDM_PLAYBAR_PLAY                IDC_BUTTON1
#define IDM_PLAYBAR_PAUSE               IDC_BUTTON2
#define IDM_PLAYBAR_STOP                IDC_BUTTON3
#define IDM_PLAYBAR_PREVTRACK           IDC_BUTTON4
#define IDM_PLAYBAR_SKIPBACK            IDC_BUTTON5
#define IDM_PLAYBAR_SKIPFORE            IDC_BUTTON6
#define IDM_PLAYBAR_NEXTTRACK           IDC_BUTTON7
#define IDM_PLAYBAR_EJECT               IDC_BUTTON8
#define IDM_PLAYBAR_RESUME              1999



//
// These are ID's of controls on the edit play list dialog box.
//
#define IDC_CLOSE                       2001
#define IDC_DEFAULT                     2002
#define IDC_DISC_HELP                   2003
#define IDC_ADD                         2006
#define IDC_REMOVE                      2007
#define IDC_CLEAR                       2008
#define IDC_SETNAME                     2009

#define IDC_ARTIST_NAME                 IDC_COMBO1
#define IDC_TITLE_NAME                  IDC_EDIT1
#define IDC_TRACK_LIST                  IDC_COMBO2

#define IDC_STATIC_DRIVE                2011
#define IDC_SJETEXT_DRIVE               2012
#define IDC_STATIC_ARTIST               2013
#define IDC_EDIT_ARTIST                 2014
#define IDC_STATIC_TITLE                2015
#define IDC_EDIT_TITLE                  2016

#define IDC_STATIC_PLAY_LIST            2017
#define IDC_LISTBOX_PLAY_LIST           2018
#define IDC_STATIC_AVAILABLE_TRACKS     2019
#define IDC_LISTBOX_AVAILABLE_TRACKS    2020
#define IDC_STATIC_TRACK                2021
#define IDC_EDIT_TRACK                  2022


//
// These are ID's of controls on the Preference dialog dox.
//
#define IDC_STOP_CD_ON_EXIT     3000
#define IDC_SAVE_ON_EXIT        3001
#define IDC_SHOW_TOOLTIPS       3002
#define IDC_SMALL_FONT          3003
#define IDC_LARGE_FONT          3004
#define IDC_LED_DISPLAY         3005
#define IDC_INTRO_PLAY_LEN      3006
#define IDC_INTRO_SPINBTN       3007


#define IDX_SEPARATOR           -1
#define IDC_STATIC              -1




/********** String ID's for stringtable in .rc file **********/
#define STR_MAX_STRING_LEN      255

#define STR_REGISTRY_KEY        3100
#define STR_CDPLAYER            3101
#define STR_TERMINATE           3102
#define STR_FAIL_INIT           3103
#define STR_NO_CDROMS           3104
#define STR_FATAL_ERROR         3105
#define STR_SCANNING            3106
#define STR_INITIALIZATION      3107
#define STR_TRACK1              3108
#define STR_SAVE_CHANGES        3109
#define STR_SAVE_INFO           3110
#define STR_CANCEL_PLAY         3111
#define STR_RESCAN              3112
#define STR_READING_TOC         3113
#define STR_CHANGE_CDROM        3114
#define STR_CDPLAYER_TIME       3115
#define STR_NO_RES              3116
#define STR_INSERT_DISC         3117
#define STR_DATA_NO_DISC        3118
#define STR_ERR_GEN             3119
#define STR_CDPLAYER_PAUSED     3120

#ifdef USE_IOCTLS
#define STR_ERR_NO_MEDIA        3220
#define STR_ERR_UNREC_MEDIA     3221
#define STR_ERR_NO_DEVICE       3222
#define STR_ERR_INV_DEV_REQ     3223
#define STR_ERR_NOT_READY       3224
#define STR_ERR_BAD_SEC         3225
#define STR_ERR_IO_ERROR        3226
#define STR_ERR_DEFAULT         3227
#define STR_DISC_INSERT         3228
#define STR_DISC_EJECT          3229
#endif

#define STR_INIT_TOTAL_PLAY     3330
#define STR_INIT_TRACK_PLAY     3331
#define STR_TOTAL_PLAY          3332
#define STR_TRACK_PLAY          3333
#define STR_NEW_ARTIST          3334
#define STR_NEW_TITLE           3335
#define STR_INIT_TRACK          3336
#define STR_HDR_ARTIST          3337
#define STR_HDR_TRACK           3338
#define STR_HDR_TITLE           3339
#define STR_UNKNOWN             3340
#define STR_BAD_DISC            3341
#define STR_CDROM_INUSE         3342
#define STR_DISC_INUSE          3343
#define STR_WAITING             3344
#define STR_EXIT_MESSAGE        3345
#define STR_NOT_IN_PLAYLIST     3346
#define STR_BEING_SCANNED       3347
#define STR_DISK_NOT_THERE_K    3348
#define STR_DISK_NOT_THERE      3349
#define STR_UNKNOWN_ARTIST      3350

#define STR_MCICDA_MISSING      3452
#define STR_MCICDA_NOT_WORKING  3453

#define MENU_STRING_BASE        1000
	// Disc
#define STR_DATABASE_EDIT       IDM_DATABASE_EDIT + MENU_STRING_BASE
#define STR_DATABASE_EXIT       IDM_DATABASE_EXIT + MENU_STRING_BASE


	// View Menu
#define STR_VIEW_TOOLBAR        IDM_VIEW_TOOLBAR + MENU_STRING_BASE
#define STR_VIEW_TRACKINFO      IDM_VIEW_TRACKINFO + MENU_STRING_BASE
#define STR_VIEW_STATUS         IDM_VIEW_STATUS + MENU_STRING_BASE
#define STR_TIME_REMAINING      IDM_TIME_REMAINING + MENU_STRING_BASE
#define STR_TRACK_REMAINING     IDM_TRACK_REMAINING + MENU_STRING_BASE
#define STR_DISC_REMAINING      IDM_DISC_REMAINING + MENU_STRING_BASE
#define STR_VIEW_VOLUME         IDM_VIEW_VOLUME + MENU_STRING_BASE


	// Options Menu         OPTIONS_MENU_BASE
#define STR_OPTIONS_RANDOM      IDM_OPTIONS_RANDOM + MENU_STRING_BASE
#define STR_OPTIONS_MULTI       IDM_OPTIONS_MULTI + MENU_STRING_BASE
#define STR_OPTIONS_INTRO       IDM_OPTIONS_CONTINUOUS + MENU_STRING_BASE
#define STR_OPTIONS_CONTINUOUS  IDM_OPTIONS_INTRO + MENU_STRING_BASE
#define STR_OPTIONS_PREFERENCES IDM_OPTIONS_PREFERENCES + MENU_STRING_BASE

	// Help Menu            HELP_MENU_BASE
#define STR_HELP_CONTENTS       IDM_HELP_CONTENTS + MENU_STRING_BASE
#define STR_HELP_USING          IDM_HELP_USING + MENU_STRING_BASE
#define STR_HELP_ABOUT          IDM_HELP_ABOUT + MENU_STRING_BASE
#define STR_HELP_TOPICS         IDM_HELP_TOPICS + MENU_STRING_BASE

	// System Menu
#define STR_SYSMENU_RESTORE     1800
#define STR_SYSMENU_MOVE        1801
#define STR_SYSMENU_SIZE        1802
#define STR_SYSMENU_MINIMIZE    1803
#define STR_SYSMENU_MAXIMIZE    1804
#define STR_SYSMENU_CLOSE       1805
#ifdef DAYTONA
#define STR_SYSMENU_SWITCH      1806
#endif


// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\scan.h ===
/******************************Module*Header*******************************\
* Module Name: scan.h
*
*
*
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#define TRACK_TYPE_MASK 0x04
#define AUDIO_TRACK     0x00
#define DATA_TRACK      0x04


typedef struct {
    HWND    hwndNotify;
    int     cdrom;
} TOC_THREAD_PARMS;

int
ScanForCdromDevices(
    void
    );

void
ScanningThread(
    HWND hwndDlg
    );

BOOL CALLBACK
ScaningDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

void RescanDevice(
    HWND hwndNotify,
    int cdrom
    );

void
ReadTableOfContents(
    TOC_THREAD_PARMS *pTocThrdParms
    );

void
TableOfContentsThread(
    TOC_THREAD_PARMS *pTocThrdParms
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\scan.c ===
/******************************Module*Header*******************************\
* Module Name: scan.c
*
* Code for scanning the available CD Rom devices.
*
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE

#include <windows.h>    /* required for all Windows applications */
#include <windowsx.h>

#include <string.h>
#include <tchar.h>              /* contains portable ascii/unicode macros */

#include "resource.h"
#include "cdplayer.h"
#include "cdapi.h"
#include "scan.h"
#include "trklst.h"
#include "database.h"



/*****************************Private*Routine******************************\
* ScanForCdromDevices
*
* Returns the number of CD-ROM devices installed in the system.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
int
ScanForCdromDevices(
    void
    )
{
    DWORD   dwDrives;
    TCHAR   chDrive[] = TEXT("A:\\");
    int     iNumDrives;

    iNumDrives  = 0;

    for (dwDrives = GetLogicalDrives(); dwDrives != 0; dwDrives >>= 1 ) {

        /*
        ** Is there a logical drive ??
        */
        if (dwDrives & 1) {

            if ( GetDriveType(chDrive) == DRIVE_CDROM ) {

                g_Devices[iNumDrives] = AllocMemory( sizeof(CDROM) );

                g_Devices[iNumDrives]->drive = chDrive[0];
                g_Devices[iNumDrives]->State = CD_BEING_SCANNED;

                iNumDrives++;
            }
        }

        /*
        ** Go look at the next drive
        */
        chDrive[0] = chDrive[0] + 1;
    }

    return iNumDrives;
}


/******************************Public*Routine******************************\
* RescanDevice
*
*
* This routine is called to scan the disc in a given cdrom by
* reading its table of contents.  If the cdrom is playing the user is
* notified that the music will stop.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void RescanDevice(
    HWND hwndNotify,
    int cdrom
    )
{
    TOC_THREAD_PARMS    *ptoc;
    HWND                hwndButton;
    int                 iMsgBoxRtn;

    if ( g_Devices[cdrom]->State & CD_PLAYING ) {

        TCHAR   s1[256];
        TCHAR   s2[256];

        _tcscpy( s1, IdStr( STR_CANCEL_PLAY ) );
        _tcscpy( s2, IdStr( STR_RESCAN ) );

        iMsgBoxRtn = MessageBox( g_hwndApp, s1, s2,
                                 MB_APPLMODAL | MB_DEFBUTTON1 |
                                 MB_ICONQUESTION | MB_YESNO);

        if ( iMsgBoxRtn == IDYES ) {

            hwndButton = g_hwndControls[INDEX(IDM_PLAYBAR_STOP)];

            SendMessage( hwndButton, WM_LBUTTONDOWN, 0, 0L );
            SendMessage( hwndButton, WM_LBUTTONUP, 0, 0L );
        }
        else {

            return;
        }
    }


    /*
    ** Attempt to read table of contents of disc in this drive.  We
    ** now spawn off a separate thread to do this.  Note that the child
    ** thread frees the storage allocated below.
    */
    ptoc = AllocMemory( sizeof(TOC_THREAD_PARMS) );
    ptoc->hwndNotify = hwndNotify;
    ptoc->cdrom = cdrom;
    ReadTableOfContents( ptoc );

}


/*****************************Private*Routine******************************\
* ReadTableofContents
*
* This function reads in the table of contents (TOC) for the specified cdrom.
* All TOC's are read on a worker thread.  The hi-word of thread_info variable
* is a boolean that states if the display should been updated after the TOC
* has been reads.  The lo-word of thread_info is the id of the cdrom device
* to be read.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ReadTableOfContents(
    TOC_THREAD_PARMS *ptoc
    )
{
    DWORD   dwThreadId;
    int     cdrom;

    cdrom = ptoc->cdrom;
    g_Devices[ cdrom ]->fIsTocValid = FALSE;
    g_Devices[cdrom]->fShowLeadIn = FALSE;
    g_Devices[cdrom]->fProcessingLeadIn = FALSE;

    if (g_Devices[ cdrom ]->hThreadToc != NULL) {

        /*
        ** We have a thread TOC handle see if the thread is
        ** still running.  If so just return, otherwise
        */
        switch ( WaitForSingleObject(g_Devices[ cdrom ]->hThreadToc, 0L) ) {

        /*
        ** Thread has finished to continue
        */
        case WAIT_OBJECT_0:
            break;

        /*
        ** The thread is still running so just return
        */
        case WAIT_TIMEOUT:
        default:
            return;
        }

        CloseHandle( g_Devices[ cdrom ]->hThreadToc );
    }

    g_Devices[ cdrom ]->hThreadToc = CreateThread(
        NULL, 0L, (LPTHREAD_START_ROUTINE)TableOfContentsThread,
        (LPVOID)ptoc, 0L, &dwThreadId );

    /*
    ** For now I will kill the app if I cannot create the
    ** ReadTableOfContents thread.  This is probably a bit
    ** harsh.
    */

    if (g_Devices[ cdrom ]->hThreadToc == NULL) {
        FatalApplicationError( STR_NO_RES, GetLastError() );
    }

}

/*****************************Private*Routine******************************\
* TableOfContentsThread
*
* This is the worker thread that reads the table of contents for the
* specified cdrom.
*
* Before the thread exits we post a message to the UI threads main window to
* notify it that the TOC for this cdrom has been updated.  It then  examines the
* database to determine if this cdrom is known and updates the screen ccordingly.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
TableOfContentsThread(
    TOC_THREAD_PARMS *ptoc
    )
{
    DWORD   status;
    UCHAR   num, numaudio;
    int     cdrom;
    HWND    hwndNotify;

    //  This serializes access to this function 
    //  between multiple threads and the CDPlayer_OnTocRead
    //  function on the main thread. 
    //  This prevents resource contention on CDROM Multi-changers
    EnterCriticalSection (&g_csTOCSerialize);

    cdrom = ptoc->cdrom;
    hwndNotify = ptoc->hwndNotify;

    LocalFree( ptoc );

    /*
    ** Try to read the TOC from the drive.
    */

#ifdef USE_IOCTLS

    status = GetCdromTOC( g_Devices[cdrom]->hCd, &(g_Devices[cdrom]->toc) );
    num = g_Devices[cdrom]->toc.LastTrack - g_Devices[cdrom]->toc.FirstTrack+1;
    {
        int     i;

        numaudio = 0;

        /*
        ** Look for audio tracks...
        */
        for( i = 0; i < num; i++ ) {

            if ( (g_Devices[cdrom]->toc.TrackData[i].Control &
                  TRACK_TYPE_MASK ) == AUDIO_TRACK ) {

                numaudio++;
            }

        }
    }

    /*
    ** Need to check if we got data tracks or audio
    ** tracks back...if there is a mix, strip out
    ** the data tracks...
    */
    if (status == ERROR_SUCCESS) {


        /*
        ** If there aren't any audio tracks, then we (most likely)
        ** have a data CD loaded.
        */

        if (numaudio == 0) {

            status == ERROR_UNRECOGNIZED_MEDIA;
            g_Devices[cdrom]->State = CD_DATA_CD_LOADED | CD_STOPPED;

        }
        else {

            g_Devices[cdrom]->State = CD_LOADED | CD_STOPPED;
        }
    }
    else {

        g_Devices[cdrom]->State = CD_NO_CD | CD_STOPPED;
    }

#else
    {
        MCIDEVICEID wDeviceID;
        DWORD       dwCDPlayerMode = 0L;

#ifdef CHICAGO
        if (g_Devices[cdrom]->hCd == 0) {
            g_Devices[cdrom]->hCd = OpenCdRom( g_Devices[cdrom]->drive,
                                               &status );
        }
        wDeviceID = g_Devices[cdrom]->hCd;
#else
        wDeviceID = OpenCdRom( g_Devices[cdrom]->drive, &status );
#endif

        if ( wDeviceID != 0 ) {

            int     i;

            numaudio = 0;
            status = GetCdromTOC( wDeviceID, &(g_Devices[cdrom]->toc) );

            /*
            ** Need to check if we got data tracks or audio
            ** tracks back...if there is a mix, strip out
            ** the data tracks...
            */
            if ( status == ERROR_SUCCESS) {
                num = g_Devices[cdrom]->toc.LastTrack -
                      g_Devices[cdrom]->toc.FirstTrack + 1;

                for( i = 0; i < num; i++ ) {

                    if ( IsCdromTrackAudio(wDeviceID, i) ) {

                        numaudio++;
                    }
                }
            }

            dwCDPlayerMode = GetCdromMode( wDeviceID );

#ifdef DAYTONA
            CloseCdRom( wDeviceID );
#endif
        }

        /*
        ** Need to check if we got data tracks or audio
        ** tracks back...if there is a mix, strip out
        ** the data tracks...
        */
        if (status == ERROR_SUCCESS) {

            /*
            ** If there aren't any audio tracks, then we (most likely)
            ** have a data CD loaded.
            */

            if (numaudio == 0) {

                g_Devices[cdrom]->State = CD_DATA_CD_LOADED | CD_STOPPED;
            }
            else {

                g_Devices[cdrom]->State = CD_LOADED;

                switch (dwCDPlayerMode) {

                case MCI_MODE_PAUSE:
                    g_Devices[cdrom]->State |= CD_PAUSED;
                    break;

                case MCI_MODE_PLAY:
                    g_Devices[cdrom]->State |= CD_PLAYING;
                    break;

                default:
                    g_Devices[cdrom]->State |= CD_STOPPED;
                    break;
                }
            }

        }
        else {

            if (status == MCIERR_MUST_USE_SHAREABLE) {
                g_Devices[cdrom]->State = CD_IN_USE;
            }

            if (g_Devices[cdrom]->State != CD_IN_USE) {
                g_Devices[cdrom]->State = CD_NO_CD | CD_STOPPED;
            }
        }
    }
#endif

    /*
    ** Notify the UI thread that a TOC has been read and then terminate the
    ** thread.
    */

    PostMessage( hwndNotify, WM_NOTIFY_TOC_READ,
                 (WPARAM)cdrom, (LPARAM)numaudio );

    LeaveCriticalSection (&g_csTOCSerialize);
    
    ExitThread( 1L );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdnet\cdnet.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Contains CD Networking Interfaces and Prototypes
//
//	Copyright (c) Microsoft Corporation	1998
//    
//	1/6/98 David Stewart / dstewart
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _CDNET_PUBLICINTEFACES_
#define _CDNET_PUBLICINTEFACES_

#include <objbase.h>
#include "..\cdopt\cdopt.h"

#ifdef __cplusplus
extern "C" {
#endif

#define WM_NET_DONE                     (WM_USER+1000) //wparam = unused, lparam = discid or status
#define WM_NET_STATUS                   (WM_USER+1001) //wparam = hinst, lparam = string id
#define WM_NET_CHANGEPROVIDER           (WM_USER+1002) //wparam = num to download, lparam = LPCDPROVIDER
#define WM_NET_INCMETER                 (WM_USER+1003) //wparam = hinst, lparam = discid
#define WM_NET_DB_FAILURE               (WM_USER+1004) //wparam = unused, lparam = unused
#define WM_NET_DB_UPDATE_BATCH          (WM_USER+1005) //no params, called to update batch with added disc
#define WM_NET_DB_UPDATE_DISC           (WM_USER+1006) //lparam = punit, called to update disc info in playlist
#define WM_NET_NET_FAILURE              (WM_USER+1007) //wparam = unused, lparam = unused

#define UPLOAD_STATUS_CANCELED          0
#define UPLOAD_STATUS_NO_PROVIDERS      1
#define UPLOAD_STATUS_SOME_PROVIDERS    2
#define UPLOAD_STATUS_ALL_PROVIDERS     3

const CLSID CLSID_CDNet = {0xE5927147,0x521E,0x11D1,{0x9B,0x97,0x00,0xC0,0x4F,0xA3,0xB6,0x0F}};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface Definitions 
//
// Defines the GUIDs / IIDs for this project:
//
// IID_IMMFWNotifySink, IMMComponent, IMMComponentAutomation
//
// These are the three interfaces for Framework / Component communications.
// All other interfaces should be private to the specific project.
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#define lCDNETIIDFirst			    0xb2cd5bbc
#define DEFINE_CDNETIID(name, x)	DEFINE_GUID(name, lCDNETIIDFirst + x, 0x5221,0x11d1,0x9b,0x97,0x0,0xc0,0x4f,0xa3,0xb6,0xc)

DEFINE_CDNETIID(IID_ICDNet,	0);

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface Typedefs
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef interface ICDNet	    	ICDNet;
typedef ICDNet*	    			    LPCDNET;

#ifndef LPUNKNOWN
typedef IUnknown*   						LPUNKNOWN;
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface Definitions
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#undef INTERFACE
#define INTERFACE ICDNet
DECLARE_INTERFACE_(ICDNet, IUnknown)
{
    //---  IUnknown methods--- 
    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;

    //---  ICDNet methods--- 
	STDMETHOD (SetOptionsAndData)		(THIS_	void* pOpt, void* pData) PURE;
	STDMETHOD (Download)				(THIS_	DWORD dwDeviceHandle, TCHAR chDrive, DWORD dwMSID, LPCDTITLE pTitle, BOOL fManual, HWND hwndParent) PURE;
	STDMETHOD_(BOOL,IsDownloading)		(THIS_) PURE;
    STDMETHOD (CancelDownload)          (THIS_) PURE;
	STDMETHOD (Upload)  				(THIS_	LPCDTITLE pTitle, HWND hwndParent) PURE;
	STDMETHOD_(BOOL,CanUpload)			(THIS_) PURE;
};

#ifdef __cplusplus
};
#endif

#endif  //_MMFRAMEWORK_PUBLICINTEFACES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\trklst.c ===
/******************************Module*Header*******************************\
* Module Name: trklst.c
*
* This module manipulates the cdrom track list.  The table of contents MUST
* be locked for ALL cdrom devices before calling any functions in this module.
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
#pragma warning( once : 4201 4214 )

#define NOOLE

#include <windows.h>             /* required for all Windows applications */
#include <windowsx.h>

#include <stdlib.h>
#include <string.h>
#include <tchar.h>              /* contains portable ascii/unicode macros */


#include "resource.h"
#include "cdplayer.h"
#include "cdapi.h"
#include "scan.h"
#include "database.h"
#include "trklst.h"


/******************************Public*Routine******************************\
* ComputeDriveComboBox
*
* This routine deletes and then reads all the drive (artist) selections
* to the drive combobox.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ComputeDriveComboBox(
    void
    )
{
    int i,index;
    HWND hwnd;

    hwnd = g_hwndControls[INDEX(IDC_ARTIST_NAME)];

    SetWindowRedraw( hwnd, FALSE );
    ComboBox_ResetContent( hwnd );

    index = 0;
    for( i = 0; i < g_NumCdDevices; i++ ) {

        ComboBox_InsertString( hwnd, -1, i );

        if ( i == g_CurrCdrom ) {

            index = i;
        }

    }

    SetWindowRedraw( hwnd, TRUE );
    ComboBox_SetCurSel( hwnd, index );

    RedrawWindow( hwnd, NULL, NULL, RDW_INVALIDATE );
    UpdateWindow( hwnd );
}



/*****************************Private*Routine******************************\
* SwitchToCdrom
*
* This routine is called when the used selects a new cdrom device
* to access.  It handles reset the state of both the "old" and "new"
* chosen cdroms.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
SwitchToCdrom(
    int NewCdrom,
    BOOL prompt
    )
{
    int oldState, oldState2;
    TCHAR   s1[256], s2[256];

    oldState = g_Devices[g_LastCdrom]->State;
    oldState2 = g_Devices[g_CurrCdrom]->State;

    if (NewCdrom != g_LastCdrom) {

        if (prompt) {

            if (g_Devices[g_CurrCdrom]->State & CD_PLAYING) {

                _tcscpy( s1, IdStr( STR_CANCEL_PLAY ) );
                _tcscpy( s2, IdStr( STR_CHANGE_CDROM ) );

                if ( MessageBox( g_hwndApp, s1, s2,
                                MB_APPLMODAL | MB_DEFBUTTON1 |
                                MB_ICONQUESTION | MB_YESNO) != IDYES ) {
                    return;
                }
            }
        }


        /*
        ** stop the drive we're leaving
        */

        g_CurrCdrom = g_LastCdrom;

        if (prompt && (g_State & (CD_PLAYING | CD_PAUSED)) ) {

            HWND hwndButton;

            hwndButton = g_hwndControls[INDEX(IDM_PLAYBAR_STOP)];

            SendMessage( hwndButton, WM_LBUTTONDOWN, 0, 0L );
            SendMessage( hwndButton, WM_LBUTTONUP, 0, 0L );

        } else {

            if ( StopTheCdromDrive( g_LastCdrom ) ) {

                g_State &= (~(CD_PLAYING | CD_PAUSED));
                g_State |= CD_STOPPED;
            }
        }

        /*
        ** Set new cdrom drive and initialize time fields
        */

        g_LastCdrom = g_CurrCdrom = NewCdrom;

        TimeAdjustInitialize( g_CurrCdrom );

        if ( (oldState & CD_PAUSED) || (oldState2 & CD_PAUSED) ) {

            SendMessage( g_hwndApp, WM_COMMAND, IDM_PLAYBAR_PLAY, 0L );
            SendMessage( g_hwndApp, WM_COMMAND, IDM_PLAYBAR_PAUSE, 0L );
        }
    }
}


/*****************************Private*Routine******************************\
* FindTrackNodeFromTocIndex
*
* This routine returns the node in the listed pointed to by listhead which
* has the TocIndex equal to tocindex.  NULL is returned if it is not
* found.  Returning NULL can easily bomb out the program -- but we should
* never be calling this routine with an invalid tocindex, and thus really
* never SHOULD return NULL.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
PTRACK_INF
FindTrackNodeFromTocIndex(
    int tocindex,
    PTRACK_INF listhead
    )
{
    PTRACK_INF t;

    for( t = listhead; ((t!=NULL) && (t->TocIndex!=tocindex)); t=t->next );
    return t;
}


/*****************************Private*Routine******************************\
* FindFirstTrack
*
* This routine computes the first "playable" track on a disc by
* scanning the the play order of the tracks
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
PTRACK_PLAY
FindFirstTrack(
    int cdrom
    )
{
    if ( (g_Devices[cdrom]->State & CD_NO_CD) ||
         (g_Devices[cdrom]->State & CD_DATA_CD_LOADED) ) {

        return NULL;
    }

    return PLAYLIST(cdrom);
}



/*****************************Private*Routine******************************\
* FindLastTrack
*
* This routine computes the last "playable" track on a disc by
* scanning the the play order of the tracks
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
PTRACK_PLAY
FindLastTrack(
    IN INT cdrom
    )
{
    PTRACK_PLAY tr;

    if ( PLAYLIST(cdrom) == NULL ) {
        return NULL;
    }

    for( tr = PLAYLIST(cdrom); tr->nextplay != NULL; tr = tr->nextplay );

    return tr;
}


/*****************************Private*Routine******************************\
* AllTracksPlayed
*
* This routine searches the play lists for all cdrom drives and
* returns a flag as to whether all tracks on all cdrom drives have
* been played.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
AllTracksPlayed(
    void
    )
{

    INT i;
    BOOL result = TRUE;

    for( i = 0; i < g_NumCdDevices; i++ ) {

        result &= (CURRTRACK(i) == NULL);
    }

    return result;
}


/*****************************Private*Routine******************************\
* FindNextTrack
*
* This routine computes the next "playable" track.  This is a
* one way door...i.e., the structures are manipulated.  It uses
* the following algorithms:
*
* Single Disc Play:
*
*     * if next track is not NULL, return next track
*     * If next track is NULL, and wrap==TRUE, return
*       first track
*     * return NULL
*
* Multi-Disc Play:
*
*     * if we're in random play, select a random drive to play from.
*     * if next track on current cdrom != NULL, return next track
*     * if it is NULL:
*
*         * check next cdrom device, if current track is not NULL
*           return CURRTRACK for that device and set gCurrCdrom to
*           that device
*         * if NULL, go to next drive
*         * last drive, check wrap
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
PTRACK_PLAY
FindNextTrack(
    BOOL wrap
    )
{
    int i;

    /*
    ** First, bump current track pointer
    */

    if ( CURRTRACK(g_CurrCdrom) != NULL ) {

        CURRTRACK(g_CurrCdrom) = CURRTRACK(g_CurrCdrom)->nextplay;
    }
    else {

        if ( g_fSingleDisk ) {

            return NULL;
        }
    }

    /*
    ** Do we need to switch drives?
    */

    if ( (!g_fSelectedOrder) && (!g_fSingleDisk) ) {

        /*
        ** Need to random to new cdrom
        */

        g_CurrCdrom = rand() % g_NumCdDevices;

    }

    /*
    ** Is chosen track playable?
    */

    if ( CURRTRACK(g_CurrCdrom) != NULL ) {

        /*
        ** Yep, so this is the easy case
        */

        return CURRTRACK(g_CurrCdrom);
    }

    /*
    ** Ok, CURRENT track on this device is not defined,
    ** so are we in multi-disc mode?
    */
    if ( !g_fSingleDisk ) {

        /*
        ** have all tracks played?
        */

        if ( AllTracksPlayed() ) {

            /*
            ** if wrap, reset all drives to front of their playlist
            */

            if ( wrap ) {

                /*
                ** If we are in random play mode we need to re-shuffle the
                ** track list so that people don't get the same tracks repeated
                ** again.
                */
                if (!g_fSelectedOrder) {
                    RestorePlayListsFromShuffleLists();
                    ComputeAndUseShufflePlayLists();
                }

                for ( i = 0; i < g_NumCdDevices; i++ )  {

                    CURRTRACK(i) = FindFirstTrack(i);
                }
            }
            else {

                /*
                ** All tracks on all drives have played, and we are NOT
                ** in continuous mode, so we are done playing.  Signify
                ** this by returning NULL (no playable tracks left).
                */

                return NULL;
            }
        }


        /*
        ** We're in mulit-disc play mode, and all the play lists should
        ** be reset now.  Cycle through cdrom drives looking for a playable
        ** track.
        */

        i = g_CurrCdrom;
        do {

            g_CurrCdrom++;
            if ( g_CurrCdrom >= g_NumCdDevices ) {

                /*
                ** We hit the end of the list of devices, if we're
                ** in continuous play mode, we need to wrap to the
                ** first cdrom drive.  Otherwise, we are done playing
                ** as there are no tracks left to play.
                */

                if ( wrap || (!g_fSelectedOrder) ) {

                    g_CurrCdrom = 0;

                }
                else {

                    g_CurrCdrom--;
                    return NULL;
                }
            }

        } while( (CURRTRACK(g_CurrCdrom) == NULL) && (i != g_CurrCdrom) );

        /*
        ** At this point we either have a playable track, or we
        ** are back where we started from and we're going to return
        ** NULL because there are no playable tracks left.
        */

        return CURRTRACK(g_CurrCdrom);

    }
    else {

        /*
        ** We're in single disc mode, and current track is NULL,
        ** which means we hit the end of the playlist.  So, check
        ** to see if we should wrap back to the first track, or
        ** return NULL to show that we're done playing.
        */

        if (wrap) {

            /*
            ** If we are in random play mode we need to re-shuffle the
            ** track list so that people don't get the same tracks repeated
            ** again.
            */
            if (!g_fSelectedOrder) {
                RestorePlayListsFromShuffleLists();
                ComputeAndUseShufflePlayLists();
            }

            /*
            ** wrap to start of the play list
            */

            CURRTRACK(g_CurrCdrom) = FindFirstTrack(g_CurrCdrom);
        }

        return CURRTRACK(g_CurrCdrom);
    }
}


/*****************************Private*Routine******************************\
* FindPrevTrack
*
* This routine computes the previous "playable" track on a disc by
* scanning the play order of the tracks from the current
* track to the start of the play list.  If we are at the start
* of the play list, then move to the end of the list if we
* are in "wrap" (i.e., continuous) play mode, otherwise return
* the current track.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
PTRACK_PLAY
FindPrevTrack(
    int cdrom,
    BOOL wrap
    )
{
    /*
    ** Is current track valid?
    */

    if ( CURRTRACK(cdrom) == NULL ) {

        return NULL;
    }



    /*
    ** If we're in multi disc play && random, the previous track
    ** is undefined since we could be jumping around on
    ** multiple discs.
    **
    ** Should Fix -- do we want to allow users to back up in the random
    **           list of a particular drive?
    */

    if ((!g_fSingleDisk) && (!g_fSelectedOrder)) {

        return CURRTRACK(cdrom);
    }


    /*
    ** Did we hit the start of the play list?
    */

    if ( CURRTRACK(cdrom)->prevplay == NULL ) {

        /*
        ** We hit the start of the list, check to see if we should
        ** wrap to end of list or not...
        */

        if ( wrap && g_fSingleDisk ) {

            return FindLastTrack(cdrom);
        }
        else {
            return CURRTRACK(cdrom);
        }
    }

    return CURRTRACK(cdrom)->prevplay;
}


/*****************************Private*Routine******************************\
* FindContiguousEnd
*
* This routine returns the node of the track within PlayList which makes
* the largest contiguous block of tracks starting w/the track pointed
* to by "tr."  It is used to play multiple tracks at as one track
* when they are programmed to be played in sequence.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
int
FindContiguousEnd(
    int cdrom,
    PTRACK_PLAY tr
    )
{
    int i;
    PTRACK_PLAY trend;

    /*
    ** If we're in muti-disc random play, we only play
    ** one track at a time, so just return next track.
    */

    if ( (!g_fSelectedOrder) && (!g_fSingleDisk) ) {

        return tr->TocIndex + 1;
    }

    /*
    ** go forward in the play list looking for contiguous blocks
    ** of tracks to play together.  We need to check the TocIndex
    ** of each track to see if they are in a "run" [ like 2-5, etc. ]
    */

    i= tr->TocIndex + 1;
    trend = tr;

    while ( (trend->nextplay != NULL) && (trend->nextplay->TocIndex == i) ) {

        trend = trend->nextplay;
        i++;
    }

    return trend->TocIndex + 1;
}


/*****************************Private*Routine******************************\
* FlipBetweenShuffleAndOrder
*
* This routine handles going from ordered play to shuffle play and vica\versa.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
FlipBetweenShuffleAndOrder(
    void
    )
{
    if ( (!g_fSelectedOrder) ) {

        /*
        ** Transitioning from Random to Ordered Play
        */

        RestorePlayListsFromShuffleLists();
    }
    else {
        /*
        ** Transitioning from Ordered to Random Play
        */

        ComputeAndUseShufflePlayLists();
    }

    /*
    ** If we were playing, we need to restart the play to make sure
    ** we don't play past where we should.
    */

    if ( g_State & CD_PLAYING ) {

        SeekToCurrSecond( g_CurrCdrom );
    }

    ResetTrackComboBox( g_CurrCdrom);
}


/*****************************Private*Routine******************************\
* ComputeAndUseShufflePlayLists
*
* This routine computes shuffled play lists for each drive, and sets
* the current PLAYLIST for erach drive to the newly computed shuffled
* PLAYLIST.  The old PLAYLIST for each drive is saved in SAVELIST.
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ComputeAndUseShufflePlayLists(
    void
    )
{
    int i;

    for ( i = 0; i < g_NumCdDevices; i++ ) {

        ComputeSingleShufflePlayList( i );
    }
}


/*****************************Private*Routine******************************\
* ComputeSingleShufflePlayList
*
* This routine computes shuffled play lists for drive i, and sets
* the current PLAYLIST for it the newly computed shuffled
* PLAYLIST.  The old PLAYLIST is saved in SAVELIST.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ComputeSingleShufflePlayList(
    int i
    )
{
    int j, index, numnodes;
    PTRACK_PLAY temp, temp1, duplist, prev, OldPlayList;

    /*
    ** First, delete the existing playlist
    */
    OldPlayList = PLAYLIST(i);
    PLAYLIST(i) = NULL;

    /*
    ** Now, go through each drive and create a shuffled play list
    ** First step is to duplicate the old play list, then we will
    ** randomly pick off nodes and put them on the shuffle play list.
    */

    duplist = prev = NULL;
    numnodes = 0;
    for( temp = SAVELIST(i); temp != NULL; temp = temp->nextplay ) {

        temp1 = AllocMemory( sizeof(TRACK_PLAY) );
        *temp1 = *temp;
        temp1->nextplay = NULL;
        if (duplist) {

            temp1->prevplay = prev;
            prev->nextplay = temp1;
            prev = temp1;
        }
        else {

            duplist = temp1;
            temp1->prevplay = NULL;
            prev = temp1;
        }

        numnodes++;
    }

    /*
    ** Now, randomly pick off nodes
    */

    prev = NULL;
    for( j = 0; j < numnodes; j++ ) {

        index = rand() % (numnodes - j + 1);
        temp = duplist;
        while( --index>0 ) {
            temp = temp->nextplay;
        }

        /*
        ** Got the node to transfer to playlist (temp),
        ** so we need to detach it from duplist so we
        ** can tack it onto the end of the playlist.
        */

        if ( temp != NULL ) {

            /*
            ** Detach temp from playlist.
            */

            if ( temp == duplist ) {

                duplist = temp->nextplay;
            }

            if ( temp->nextplay ) {

                temp->nextplay->prevplay = temp->prevplay;
            }

            if ( temp->prevplay ) {

                temp->prevplay->nextplay = temp->nextplay;
            }

            /*
            ** Now, tack it onto the end of the PLAYLIST
            */

            if ( PLAYLIST(i) ) {

                prev->nextplay = temp;
                temp->prevplay = prev;
                temp->nextplay = NULL;
                prev = temp;
            }
            else {

                PLAYLIST(i) = temp;
                temp->prevplay = NULL;
                prev = temp;
                temp->nextplay = NULL;
            }
        }
    }

    /*
    ** we need to reset the CURRTRACK pointer so
    ** that it points to a node in PLAYLIST instead of SAVELIST
    */

    if ( (g_Devices[i]->State & CD_PLAYING) && (CURRTRACK(i) != NULL) ) {

        index = CURRTRACK(i)->TocIndex;
        for( temp = PLAYLIST(i); temp->TocIndex!=index; temp=temp->nextplay );
        CURRTRACK(i) = temp;
    }
    else {

        CURRTRACK(i) = PLAYLIST(i);

        if ( PLAYLIST(i) != NULL ) {

            CDTIME(i).TrackTotalMin = PLAYLIST(i)->min;
            CDTIME(i).TrackTotalSec = PLAYLIST(i)->sec;
            CDTIME(i).TrackRemMin   = PLAYLIST(i)->min;
            CDTIME(i).TrackRemSec   = PLAYLIST(i)->sec;
        }


    }

    /*
    ** if this is the current drive, we need to redo the tracks in
    ** the track list combobox.
    */

    if ( i == g_CurrCdrom ) {

        ResetTrackComboBox( i );

    }

    /*
    ** Finally, free up the memory from the old playlist.
    */
    temp = OldPlayList;
    while ( temp != NULL ) {

        temp1 = temp->nextplay;
        LocalFree( (HLOCAL)temp );
        temp = temp1;
    }
}


/*****************************Private*Routine******************************\
* RestorePlayListsFromShuffleLists
*
* This routine restores the PLAYLIST for each drive to it's "pre-shuffled"
* state.  This should be stored in SAVELIST.  Once the restoration is done,
* un-needed node are released.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
RestorePlayListsFromShuffleLists(
    void
    )
{
    int i,index;
    PTRACK_PLAY temp;

    for ( i = 0; i < g_NumCdDevices; i++ ) {

        if ( SAVELIST(i) ) {

            if ( CURRTRACK(i) != NULL ) {

                index = CURRTRACK(i)->TocIndex;
            }
            else {

                index = -1;
            }

            ErasePlayList(i);
            PLAYLIST(i) = CopyPlayList( SAVELIST(i) );

            /*
            ** Reset CURRTRACK pointer
            */

            if ( (g_Devices[i]->State & CD_PLAYING) && (index != -1) ) {

                for( temp = PLAYLIST(i);
                     temp->TocIndex != index; temp=temp->nextplay );

                CURRTRACK(i) = temp;
            }
            else {

                CURRTRACK(i) = PLAYLIST(i);

                if ( PLAYLIST(i) != NULL ) {
                    CDTIME(i).TrackRemMin   = PLAYLIST(i)->min;
                    CDTIME(i).TrackRemSec   = PLAYLIST(i)->sec;
                    CDTIME(i).TrackTotalMin = PLAYLIST(i)->min;
                    CDTIME(i).TrackTotalSec = PLAYLIST(i)->sec;
                }
            }
        }

        if ( i == g_CurrCdrom ) {

            ResetTrackComboBox( i );
        }
    }
}



/*****************************Private*Routine******************************\
* FigureTrackTime
*
* This routine computes the length of a given track, in terms
* of minutes and seconds.
*
*   cdrom - supplies an index into the global structure gDevices
*
*   index - supplies an index to the track which should have its
*           length computed.  This is an index into the
*           gDevices[cdrom]->CdInfo.Tracks[...] structure
*
*   min   - supplies a pointer to an INT which will hold the minute
*           portion of the track length.
*
*   sec   - supplies a pointer to an INT which will hold the seconds
*           portion of the track length.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
FigureTrackTime(
    int cdrom,
    int index,
    int * min,
    int * sec
    )
{

    DWORD start, end, diff;

    start = ((TRACK_M(cdrom,index) * FRAMES_PER_MINUTE) +
             (TRACK_S(cdrom,index) * FRAMES_PER_SECOND) +
              TRACK_F(cdrom,index));

    end   = ((TRACK_M(cdrom,index+1) * FRAMES_PER_MINUTE) +
             (TRACK_S(cdrom,index+1) * FRAMES_PER_SECOND) +
              TRACK_F(cdrom,index+1));

    diff = end - start;

    (*min)   = (diff / FRAMES_PER_MINUTE);
    (*sec)   = (diff % FRAMES_PER_MINUTE) / FRAMES_PER_SECOND;

}



/*****************************Private*Routine******************************\
* TimeAdjustInitialize
*
*   Initializes the time, track, and title fields of a given
*   disc.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
TimeAdjustInitialize(
    int cdrom
    )
{
    int m, s, mtemp, stemp, ts, tm;
    PTRACK_PLAY tr;


    /*
    ** Is there even a cd loaded?
    */

    if (g_Devices[cdrom]->State &
        (CD_BEING_SCANNED | CD_IN_USE | CD_NO_CD | CD_DATA_CD_LOADED)) {

        /*
        ** Fake some information
        */

        g_Devices[cdrom]->CdInfo.NumTracks = 0;
        g_Devices[cdrom]->toc.FirstTrack = 0;
        g_Devices[cdrom]->CdInfo.Id = 0;

        if (g_Devices[cdrom]->State & CD_IN_USE) {
            _tcscpy( (LPTSTR)TITLE(cdrom),  IdStr(STR_WAITING) );
            _tcscpy( (LPTSTR)ARTIST(cdrom), IdStr(STR_DISC_INUSE) );
        }
        else if (g_Devices[cdrom]->State & CD_BEING_SCANNED) {
            _tcscpy( (LPTSTR)TITLE(cdrom),  IdStr(STR_WAITING) );
            _tcscpy( (LPTSTR)ARTIST(cdrom), IdStr(STR_BEING_SCANNED) );
        }
        else {
            _tcscpy( (LPTSTR)TITLE(cdrom),  IdStr(STR_INSERT_DISC) );
            _tcscpy( (LPTSTR)ARTIST(cdrom), IdStr(STR_DATA_NO_DISC) );
        }

        /*
        ** Kill off play list
        */

        ErasePlayList( cdrom );
        EraseSaveList( cdrom );
        EraseTrackList( cdrom );

        tr = NULL;
    }
    else {

        /*
        ** Find track to use as first track
        */

        tr = FindFirstTrack( cdrom );
    }

    /*
    ** Set current position information
    */

    CURRTRACK(cdrom) = tr;
    CDTIME(cdrom).TrackCurMin = 0;
    CDTIME(cdrom).TrackCurSec = 0;

    /*
    ** Compute PLAY length
    */

    mtemp = stemp = m = s = ts = tm =0;

    for( tr = PLAYLIST(cdrom); tr != NULL; tr = tr->nextplay ) {

        FigureTrackTime( cdrom, tr->TocIndex, &mtemp, &stemp );

        m+=mtemp;
        s+=stemp;

        tr->min = mtemp;
        tr->sec = stemp;
    }

    /*
    ** to be safe, recalculate the SAVE list each time as well.
    */
    for( tr = SAVELIST(cdrom); tr != NULL; tr = tr->nextplay ) {

        FigureTrackTime( cdrom, tr->TocIndex, &mtemp, &stemp );

        tr->min = mtemp;
        tr->sec = stemp;
    }


    m += (s / 60);
    s =  (s % 60);

    CDTIME(cdrom).TotalMin = m;
    CDTIME(cdrom).TotalSec = s;
    CDTIME(cdrom).RemMin = m;
    CDTIME(cdrom).RemSec = s;

    /*
    ** Fill in track length and information
    */

    if ( CURRTRACK(cdrom) != NULL ) {

        CDTIME(cdrom).TrackTotalMin = CDTIME(cdrom).TrackRemMin =
            CURRTRACK(cdrom)->min;

        CDTIME(cdrom).TrackTotalSec = CDTIME(cdrom).TrackRemSec =
            CURRTRACK(cdrom)->sec;
    }
    else {

        CDTIME(cdrom).TrackTotalMin = CDTIME(cdrom).TrackRemMin = 0;
        CDTIME(cdrom).TrackTotalSec = CDTIME(cdrom).TrackRemSec = 0;
    }

    /*
    ** Fill in track list combo box
    */

    if ( cdrom == g_CurrCdrom ) {

        ResetTrackComboBox( cdrom );

        /*
        ** Update display if this is the disc currently
        ** being displayed.
        */

        UpdateDisplay( DISPLAY_UPD_LED        |
                       DISPLAY_UPD_DISC_TIME  |
                       DISPLAY_UPD_TRACK_TIME |
                       DISPLAY_UPD_TITLE_NAME |
                       DISPLAY_UPD_TRACK_NAME );
    }

}



/*****************************Private*Routine******************************\
* TimeAdjustIncSecond
*
* Adds one second onto current position ("time") of disc
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
TimeAdjustIncSecond(
    int cdrom
    )
{

    PTRACK_PLAY tr;

    /*
    ** If there is no current track just return
    */
    if ( CURRTRACK(g_CurrCdrom) == NULL ) {
        return;
    }

    /*
    ** Update current track time
    */

    CDTIME(cdrom).TrackCurSec++;
    if ( CDTIME(cdrom).TrackCurSec > 59 ) {

        CDTIME(cdrom).TrackCurMin++;
        CDTIME(cdrom).TrackCurSec = 0;
    }

    /*
    ** Now, check to see if we skipped any track boundaries
    */

    if (
        ((CDTIME(cdrom).TrackCurMin >= CDTIME(cdrom).TrackTotalMin) &&
         (CDTIME(cdrom).TrackCurSec >= CDTIME(cdrom).TrackTotalSec))

        ||

        ((g_fIntroPlay) &&
        ((CDTIME(cdrom).TrackCurMin >  0) ||
         (CDTIME(cdrom).TrackCurSec > g_IntroPlayLength)) )

       ) {

        /*
        ** We did, so skip to next track
        */

        /*
        ** Should Fix for new FindNextTrack
        */

        tr = FindNextTrack( g_fContinuous );

        if ( tr == NULL ) {

            /*
            ** Hit end of playlist, so stay at end of current
            ** track.
            */

            if (!g_fIntroPlay) {

                CDTIME(cdrom).TrackCurMin = CDTIME(cdrom).TrackTotalMin;
                CDTIME(cdrom).TrackCurSec = CDTIME(cdrom).TrackTotalSec;
            }
            else {

                CDTIME(cdrom).TrackCurMin = 0;
                CDTIME(cdrom).TrackCurSec = g_IntroPlayLength;
            }

            return;

        }

        if ( g_CurrCdrom != g_LastCdrom) {

            SwitchToCdrom(g_CurrCdrom, FALSE );
        }

        TimeAdjustSkipToTrack( cdrom, tr );
    }
    else {

        /*
        ** Update current track remaining time
        */

        CDTIME(cdrom).TrackRemSec--;
        if ( CDTIME(cdrom).TrackRemSec < 0 ) {

            CDTIME(cdrom).TrackRemMin--;
            CDTIME(cdrom).TrackRemSec = 59;
        }

        /*
        ** Update total remaining time
        */

        CDTIME(cdrom).RemSec--;
        if ( CDTIME(cdrom).RemSec < 0 ) {

            CDTIME(cdrom).RemMin--;
            CDTIME(cdrom).RemSec = 59;
        }
    }

    /*
    ** Update Display
    */

    UpdateDisplay( DISPLAY_UPD_LED );
}


/*****************************Private*Routine******************************\
* TimeAdjustDecSecond
*
* Subtracts one second from current position ("time") of disc
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
TimeAdjustDecSecond(
    int cdrom
    )
{

    int min,sec;
    PTRACK_PLAY prev,tr;

    /*
    ** If there is no current track, just return
    */
    if ( CURRTRACK(g_CurrCdrom) == NULL ) {
        return;
    }

    /*
    ** Update current track
    */

    CDTIME(cdrom).TrackCurSec--;
    if ( CDTIME(cdrom).TrackCurSec < 0 ) {

        CDTIME(cdrom).TrackCurMin--;
        CDTIME(cdrom).TrackCurSec = 59;
    }

    /*
    ** Update current track remaining
    */

    CDTIME(cdrom).TrackRemSec++;
    if ( CDTIME(cdrom).TrackRemSec > 59 ) {

        CDTIME(cdrom).TrackRemMin++;
        CDTIME(cdrom).TrackRemSec = 0;
    }

    /*
    ** Update total remaining time
    */

    CDTIME(cdrom).RemSec++;
    if ( CDTIME(cdrom).RemSec > 59 ) {

        CDTIME(cdrom).RemMin++;
        CDTIME(cdrom).RemSec = 0;
    }

    /*
    ** Now, check to see if we skipped any boundaries we shouldn't have!
    */

    if ( CDTIME(cdrom).TrackCurMin < 0 ) {

        /*
        ** We went "off" the front end of the track,
        ** so we need to see what to do now.  Options
        ** are:
        **
        ** (1) Go to end of track before us.
        ** (2) If intro play, go to 0:10 of
        **     track before us.
        ** (3) If not in continuous play, and
        **     this is the first track, then
        **     just sit at 0:00
        */

        prev = FindPrevTrack( cdrom, g_fContinuous );

        if ( prev == CURRTRACK(cdrom) ) {

            /*
            ** We are on the first track, and not in
            ** continuous mode, so just go to 0:00
            */

            CDTIME(cdrom).TrackCurSec = 0;
            CDTIME(cdrom).TrackCurMin = 0;
            CDTIME(cdrom).TrackRemMin = CDTIME(cdrom).TrackTotalMin;
            CDTIME(cdrom).TrackRemSec = CDTIME(cdrom).TrackTotalSec;
            min = sec = 0;

            for( tr = PLAYLIST( cdrom ); tr != NULL; tr = tr->nextplay ) {

                min += tr->min;
                sec += tr->sec;
            }

            min += (sec / 60);
            sec  = (sec % 60);

            CDTIME(cdrom).RemMin = min;
            CDTIME(cdrom).RemSec = sec;

            UpdateDisplay( DISPLAY_UPD_LED );

        }
        else {

            /*
            ** Valid previous track
            */

            if ( !g_fIntroPlay ) {

                /*
                ** We need to place the current play position
                ** at the end of the previous track.
                */

                CDTIME(cdrom).TrackCurMin = CDTIME(cdrom).TrackTotalMin = prev->min;
                CDTIME(cdrom).TrackCurSec = CDTIME(cdrom).TrackTotalSec = prev->sec;
                CDTIME(cdrom).TrackRemMin = CDTIME(cdrom).TrackRemSec = 0;

                min = sec = 0;
                for( tr = prev->nextplay; tr != NULL; tr = tr->nextplay ) {

                    min += tr->min;
                    sec += tr->sec;
                }

                min += (sec / 60);
                sec  = (sec % 60);

                CDTIME(cdrom).RemMin = min;
                CDTIME(cdrom).RemSec = sec;
            }
            else {

                /*
                ** Intro play -- instead of end of track,
                **               jump to 00:10...
                */

                CDTIME(cdrom).TrackCurMin = 0;
                CDTIME(cdrom).TrackCurSec =
                    min( g_IntroPlayLength, prev->sec );

                CDTIME(cdrom).TrackTotalMin = prev->min;
                CDTIME(cdrom).TrackTotalSec = prev->sec;

                CDTIME(cdrom).TrackRemMin = CDTIME(cdrom).TrackTotalMin;
                CDTIME(cdrom).TrackRemSec = CDTIME(cdrom).TrackTotalSec -
                                        min( g_IntroPlayLength, prev->sec );

                if ( CDTIME(cdrom).TrackRemSec < 0 ) {

                    CDTIME(cdrom).TrackRemSec += 60;
                    CDTIME(cdrom).TrackRemMin--;
                }

                min = sec = 0;
                for( tr = prev; tr != NULL; tr = tr->nextplay ) {

                    min += tr->min;
                    sec += tr->sec;
                }

                sec -= min( g_IntroPlayLength, prev->sec );
                if ( sec < 0 ) {
                    sec+=60;
                    min--;
                }

                min += (sec / 60);
                sec  = (sec % 60);

                CDTIME(cdrom).RemMin = min;
                CDTIME(cdrom).RemSec = sec;
            }

            CURRTRACK(cdrom) = prev;

            UpdateDisplay( DISPLAY_UPD_LED        |
                           DISPLAY_UPD_TRACK_NAME |
                           DISPLAY_UPD_TRACK_TIME );

        }
    }
    else {

        UpdateDisplay( DISPLAY_UPD_LED );
    }
}


/*****************************Private*Routine******************************\
* InitializeNewTrackTime
*
* Updates track/time information for gDevices array.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
InitializeNewTrackTime(
    int cdrom,
    PTRACK_PLAY tr,
    BOOL fUpdateDisplay
    )
{
    int min,sec;

    /*
    ** Update time information in gDevices structure
    */

    CDTIME(cdrom).CurrTrack = tr;
    CDTIME(cdrom).TrackCurMin = 0;
    CDTIME(cdrom).TrackCurSec = 0;

    if (tr == NULL) {

        CDTIME(cdrom).TrackTotalMin = 0;
        CDTIME(cdrom).TrackTotalSec = 0;

    }
    else {

        CDTIME(cdrom).TrackTotalMin = CDTIME(cdrom).TrackRemMin = tr->min;
        CDTIME(cdrom).TrackTotalSec = CDTIME(cdrom).TrackRemSec = tr->sec;

    }

    min = sec = 0;
    for( tr = PLAYLIST(cdrom); tr!=NULL; tr = tr->nextplay ) {

        min += tr->min;
        sec += tr->sec;
    }

    min += (sec / 60);
    sec  = (sec % 60);

    CDTIME(cdrom).RemMin = min;
    CDTIME(cdrom).RemSec = sec;

    /*
    ** Update LED box
    */
    if (fUpdateDisplay) {
        UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_NAME |
                       DISPLAY_UPD_TRACK_TIME );
    }
}




/*****************************Private*Routine******************************\
* TimeAdjustSkipToTrack
*
*   Updates time/track information for gDevices array and then
*   issues skip to track commands to cdrom device.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
TimeAdjustSkipToTrack(
    int cdrom,
    PTRACK_PLAY tr
    )
{

    /*
    ** Update time information in gDevices structure
    */

    InitializeNewTrackTime( cdrom, tr, TRUE );

    /*
    ** Actually seek to the track, and play it if appropriate
    */

    if ((g_Devices[cdrom]->State & CD_PLAYING) ||
        (g_Devices[cdrom]->State & CD_PAUSED)) {

        PlayCurrTrack( cdrom );
        if (g_Devices[cdrom]->State & CD_PAUSED) {
            PauseTheCdromDrive( cdrom );
        }
    }
    else if (tr) {
        SeekToTrackAndHold( cdrom, tr->TocIndex );
    }
}


/*****************************Private*Routine******************************\
* SyncDisplay
*
* Queries the cdrom device for its current position, and then
* updates the display accordingly.  Also, detects when a track has
* finished playing, or when intro segment is over, and skips to the
* next track.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
SyncDisplay(
    void
    )
{
    int m,s;
    PTRACK_PLAY next;
    CURRPOS cp;
    PCURRPOS pCurr = &cp;


    /*
    ** If there isn't a disc in the drive, ignore this
    ** request
    */

    if ( (g_Devices[g_CurrCdrom]->State & CD_NO_CD) ||
         (g_Devices[g_CurrCdrom]->State & CD_DATA_CD_LOADED) ) {
       return;
    }

    /*
    ** Query cdrom device for current position
    */

    if ( !GetCurrPos( g_CurrCdrom, pCurr ) ) {

        /*
        ** If there was an error, it will already have been
        ** reported in CheckStatus of cdapi.c...so, we don't need
        ** to tell anything more here.  When an error occurs, the
        ** fields of the pCurr structure are zeroed, so we don't
        ** need to clean those up either
        */

        return;
    }

    /*
    ** Has the current play selection finished playing?
    */
#ifdef USE_IOCTLS
    if ((pCurr->AudioStatus == AUDIO_STATUS_PLAY_COMPLETE) &&
        ( !(g_State & CD_SEEKING) )) {
#else

    if ((pCurr->AudioStatus == MCI_MODE_STOP) &&
        ( !(g_State & CD_SEEKING) )) {
#endif

Play_Complete:

        /*
        ** Yep, so skip to the next track.
        */
        next = FindNextTrack( g_fContinuous );

        if ( next == NULL ) {

            /*
            ** There are no more tracks to play, so
            ** fake a press on the "stop" button.  But,
            ** we want to set gCurrCdrom back to the "playing"
            ** drive 'cause it may have changed in our call
            ** to FindNextTrack.
            */

            g_CurrCdrom = g_LastCdrom;
            SendMessage( g_hwndApp, WM_COMMAND, IDM_PLAYBAR_STOP, 0L );
        }
        else {

            if ( g_CurrCdrom != g_LastCdrom ) {

                SwitchToCdrom( g_CurrCdrom, FALSE );

                /*
                ** We use to start the disc play by sending the play command.
                ** SendMessage( g_hwndApp, WM_COMMAND, IDM_PLAYBAR_PLAY, 0L );
                ** However, all we realy need to put the drives state into
                ** playing and let TimeAdjustSkipToTrack take care of starting
                ** playing.  If we don't do this when the app is in multi-disc
                ** random play mode, we get a fraction of a second of the
                ** first track in the playlist played before we seek to the
                ** the correct track and start playing it.  This sounds really
                ** bad.
                */

                g_State &= ~CD_STOPPED;
                g_State |= CD_PLAYING;

            }

            TimeAdjustSkipToTrack( g_CurrCdrom, next );
        }

        return;
    }

    /*
    ** Check to see if we need to update the display
    */

    if ( (pCurr->Track < 100) && ( pCurr->Track >
         (CURRTRACK(g_CurrCdrom)->TocIndex + FIRSTTRACK(g_CurrCdrom)) )) {

        /*
        ** We got to the next track in a multi-track
        ** play, so mark per track information for
        ** new track
        */
        if ((CURRTRACK(g_CurrCdrom)->nextplay != NULL) &&
             ((CURRTRACK(g_CurrCdrom)->TocIndex + 1) ==
              CURRTRACK(g_CurrCdrom)->nextplay->TocIndex)) {

            next = FindNextTrack( g_fContinuous );
            if ( next == NULL ) {

                /*
                ** There are no more tracks to play, so
                ** fake a press on the "stop" button.  But,
                ** we want to set gCurrCdrom back to the "playing"
                ** drive 'cause it may have changed in our call
                ** to FindNextTrack.
                */

                g_CurrCdrom = g_LastCdrom;

                SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
                             WM_LBUTTONDOWN, 0, 0L );

                SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_STOP)],
                             WM_LBUTTONUP, 0, 0L );

            }
            else {

                if ( g_CurrCdrom != g_LastCdrom ) {

                    SwitchToCdrom( g_CurrCdrom, FALSE );
                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)],
                                 WM_LBUTTONDOWN, 0, 0L );

                    SendMessage( g_hwndControls[INDEX(IDM_PLAYBAR_PLAY)],
                                 WM_LBUTTONUP, 0, 0L );
                }

                InitializeNewTrackTime( g_CurrCdrom, next, FALSE );
                UpdateDisplay( DISPLAY_UPD_TRACK_NAME | DISPLAY_UPD_TRACK_TIME );
            }
        }
        else {

            /*
            ** If we get here it is probably the result of starting
            ** CD Player whislt the current disc was still playing.
            ** We look for the currently playing track in the current
            ** playlist.
            */

            next = FindFirstTrack(g_CurrCdrom);
            while ( (next != NULL)
                 && (pCurr->Track != (next->TocIndex + 1)) ) {

#if DBG
                dprintf("trying track %d", (next->TocIndex + 1));
#endif
                next = next->nextplay;
            }

            /*
            ** If next is NULL it means that we are playing a track that
            ** is currently not on the users playlist.  So, we put up a
            ** message box informing the user of this fact and that we are
            ** going to temporarily add the track to the current playlist
            ** as the first track.  Otherwise, we found the track in the
            ** playlist so just update the track time for this track.
            */
            if (next == NULL) {

				//<mwetzel:08.28.97> Removed this line of code, so that tracks don't get
				//accidentally added. After a track is played, the STOP state is sensed,
				//and this function (see above) advances the track. However, under a rare 
				//(about 1-5% of time) circumstance, this thread will sense that the cd's
				//time value means it's on the next track, and the cd is still in play mode. 
				//This code used to interpret that as a new play command, and added the track
				//to the playlist. Hence, I commented out the following line. If the actual
				//case where a new play command is received, the new track is added to the 
				//playlist in the HandlePassedCommandLine() call.

				//AddTemporaryTrackToPlayList(pCurr);
            }
            else {

                InitializeNewTrackTime( g_CurrCdrom, next, TRUE );
            }
        }
        return;
    }

    if ( pCurr->Track <
         (CURRTRACK(g_CurrCdrom)->TocIndex + FIRSTTRACK(g_CurrCdrom)) )
        return;

    if ( (pCurr->Index != 0)
      && (pCurr->m <= CDTIME(g_CurrCdrom).TrackCurMin)
      && (pCurr->s <= CDTIME(g_CurrCdrom).TrackCurSec) )

        return;

    /*
    ** Set track elapsed time
    */

    CDTIME(g_CurrCdrom).TrackCurMin = pCurr->m;
    CDTIME(g_CurrCdrom).TrackCurSec = pCurr->s;

    /*
    ** Set track remaining time
    */

    m = pCurr->m;

    if ( (pCurr->s) <= CDTIME(g_CurrCdrom).TrackTotalSec ) {

        s = CDTIME(g_CurrCdrom).TrackTotalSec - pCurr->s;
    }
    else {

        s = 60 - (pCurr->s - CDTIME(g_CurrCdrom).TrackTotalSec);
        m++;
    }

    CDTIME(g_CurrCdrom).TrackRemMin = CDTIME(g_CurrCdrom).TrackTotalMin - m;
    CDTIME(g_CurrCdrom).TrackRemSec = s;

    /*
    ** Set disc remaining time
    **
    ** Should Fix -- for now, just decrement by 1 second
    */

    CDTIME(g_CurrCdrom).RemSec--;
    if (CDTIME(g_CurrCdrom).RemSec < 0) {

        CDTIME(g_CurrCdrom).RemSec = 59;
        CDTIME(g_CurrCdrom).RemMin--;
    }


    /*
    ** Update LED box
    */

    if ( (pCurr->Index != 0) || ((pCurr->m == 0) && (pCurr->s == 0)) ) {

        UpdateDisplay( DISPLAY_UPD_LED );
    }
    else {

        UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_LEADOUT_TIME );
    }

    /*
    ** Check to see if we are intro play and have played
    ** intro segment...if so, skip to next track
    */

    if ( ((pCurr->s >= (g_IntroPlayLength + 1)) || (pCurr->m > 0))
      && g_fIntroPlay ) {

        goto Play_Complete;
    }
}




/*****************************Private*Routine******************************\
* ValidatePosition
*
* Checks the current position on the CD, then verifies that the
* relative offset in the track + the beginning of the track's
* position is the same as the absolute position on the CD.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
ValidatePosition(
    int cdrom
    )
{
    int Mult, Frames;
    CURRPOS cp;
    PCURRPOS pCurr = &cp;
    LPTSTR s1,s2;


    if (!GetCurrPos( cdrom, pCurr ))

        /*
        ** If there was an error, it will already have been
        ** reported in CheckStatus of cdapi.c...so, we don't need
        ** to tell anything more here.  When an error occurs, the
        ** fields of the pCurr structure are zeroed, so we don't
        ** need to clean those up either
        */

        return;


    /*
    ** Make sure the position returned is consistent with
    ** what we know about the CD. By comparing the relative time
    ** on this track to the absolute time on the CD, we should be
    ** able to make sure we're still on the right disc.  This is
    ** a failsafe for when polling fails to notice an ejected
    ** disc.
    */

    if ((cp.Track > 0)&&(cp.Track < 101)) {

        Frames = cp.ab_m * 60 * 75;
        Frames += cp.ab_s * 75;
        Frames += cp.ab_f;

        Frames -= TRACK_M(cdrom,cp.Track-1) * 60 * 75;
        Frames -= TRACK_S(cdrom,cp.Track-1) * 75;
        Frames -= TRACK_F(cdrom,cp.Track-1);
        if (pCurr->Index) {

            Mult = 1;
        }
        else {

            Mult = -1;
        }

        Frames -= Mult*cp.m * 60 * 75;
        Frames -= Mult*cp.s * 75;
        Frames -= Mult*cp.f;

        if (g_Devices[cdrom]->CdInfo.iFrameOffset ==  NEW_FRAMEOFFSET) {

            g_Devices[cdrom]->CdInfo.iFrameOffset = Frames;
        }

        if ((ABS(Frames - g_Devices[ cdrom ]->CdInfo.iFrameOffset) > 4) &&
            (ABS(Frames) > 4)) {

            HWND hwndStop;

            hwndStop = g_hwndControls[INDEX(IDM_PLAYBAR_STOP)];

            s1 = AllocMemory( _tcslen(IdStr(STR_BAD_DISC)) + 1 );
            _tcscpy( s1, IdStr(STR_BAD_DISC) );

            s2 = AllocMemory( _tcslen(IdStr(STR_CDPLAYER)) + 1);
            _tcscpy(s2,IdStr(STR_CDPLAYER));

            MessageBox( g_hwndApp, s1, s2, MB_APPLMODAL|MB_ICONSTOP|MB_OK );

            SendMessage( hwndStop,WM_LBUTTONDOWN, 1,0L );
            SendMessage( hwndStop,WM_LBUTTONUP, 1, 0L );

            RescanDevice(g_hwndApp, cdrom );

            LocalFree( (HLOCAL)s1 );
            LocalFree( (HLOCAL)s2 );

            return;
        }
    }
}



/*****************************Private*Routine******************************\
* ResetTrackComboBox
*
* This routine deletes and then resets the track name combobox based
* on the contents of the PLAYLIST for the specified cdrom drive.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
VOID
ResetTrackComboBox(
    int cdrom
    )
{
    int j,index;
    PTRACK_PLAY temp;
    HWND    hwnd;

    hwnd = g_hwndControls[INDEX(IDC_TRACK_LIST)];

    SetWindowRedraw( hwnd, FALSE );
    ComboBox_ResetContent( hwnd );

    /*
    ** Add new playlist, and select correct entry for current track
    */

    j = index = 0;
    for( temp = PLAYLIST(cdrom); temp != NULL; temp = temp->nextplay ) {

        ComboBox_InsertString( hwnd, -1, temp->TocIndex );

        if ( temp == CURRTRACK(cdrom) ) {

            index = j;
        }

        j++;

    }

    ComboBox_SetCurSel( hwnd, index );
    SetWindowRedraw( hwnd, TRUE );

    RedrawWindow( hwnd, NULL, NULL, RDW_INVALIDATE );
    UpdateWindow( hwnd );

    UpdateDisplay( DISPLAY_UPD_LED | DISPLAY_UPD_TRACK_TIME );

}

/******************************Public*Routine******************************\
* PlayListMatchesAvailList
*
* Compares the current play list with the default play list to if they match.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
PlayListMatchesAvailList(
    void
    )
{

    PTRACK_PLAY pl = SAVELIST(g_CurrCdrom);
    int i = 0;

    while (pl && i < NUMTRACKS(g_CurrCdrom)) {

        if ( pl->TocIndex != i) {
            return FALSE;
        }
        pl = pl->nextplay;
        i++;
    }

    return pl == NULL && i == NUMTRACKS(g_CurrCdrom);
}


/*****************************Private*Routine******************************\
* AddTemporaryTrackToPlayList
*
* This functions adds the currently playing track to the playlist.
* pCurr contains the toc index of the track that is required to be added.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
AddTemporaryTrackToPlayList(
    PCURRPOS pCurr
    )
{
    // LPTSTR lpstrTitle;
    // LPTSTR lpstrText;
    PTRACK_PLAY tr;
    int m, s;


    /*
    ** Add track to the current playlist.
    */
    tr = AllocMemory( sizeof(TRACK_PLAY) );
    tr->TocIndex = pCurr->Track - 1;
    FigureTrackTime(g_CurrCdrom, tr->TocIndex, &tr->min, &tr->sec);

    tr->nextplay = PLAYLIST(g_CurrCdrom);
    tr->prevplay = NULL;

    PLAYLIST(g_CurrCdrom)->prevplay = tr;
    PLAYLIST(g_CurrCdrom) = tr;

    /*
    ** Update the display.
    */
    InitializeNewTrackTime( g_CurrCdrom, tr, TRUE );
    ResetTrackComboBox( g_CurrCdrom );

    m = CDTIME(g_CurrCdrom).TotalMin + tr->min;
    s = CDTIME(g_CurrCdrom).TotalSec + tr->sec;

    m += (s / 60);
    s =  (s % 60);

    CDTIME(g_CurrCdrom).TotalMin = m;
    CDTIME(g_CurrCdrom).TotalSec = s;
    UpdateDisplay(DISPLAY_UPD_DISC_TIME);


    /*
    ** Now modify the current saved playlist.  We do this so that transitions
    ** from/to random mode work correctly.
    */
    tr = AllocMemory( sizeof(TRACK_PLAY) );
    tr->TocIndex = pCurr->Track - 1;
    FigureTrackTime(g_CurrCdrom, tr->TocIndex, &tr->min, &tr->sec);

    tr->nextplay = SAVELIST(g_CurrCdrom);
    tr->prevplay = NULL;

    SAVELIST(g_CurrCdrom)->prevplay = tr;
    SAVELIST(g_CurrCdrom) = tr;

#if 0
    /*
    ** Now, tell the user what we have just done.  Note that we disable the
    ** the Heart beat timer so that we don't renenter ourselves.
    */
    lpstrTitle = AllocMemory( STR_MAX_STRING_LEN * sizeof(TCHAR) );
    lpstrText  = AllocMemory( STR_MAX_STRING_LEN * sizeof(TCHAR) );

    _tcscpy( lpstrText, IdStr(STR_NOT_IN_PLAYLIST) );
    _tcscpy( lpstrTitle, IdStr(STR_CDPLAYER) );

    KillTimer( g_hwndApp, HEARTBEAT_TIMER_ID );

    MessageBox( NULL, lpstrText, lpstrTitle,
                MB_APPLMODAL | MB_ICONINFORMATION | MB_OK );

    SetTimer( g_hwndApp, HEARTBEAT_TIMER_ID, HEARTBEAT_TIMER_RATE,
              HeartBeatTimerProc );
    LocalFree( (HLOCAL)lpstrText );
    LocalFree( (HLOCAL)lpstrTitle );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdnet\condlg.h ===
/******************************Module*Header*******************************\
* Module Name: condlg.h
*
* Author:  David Stewart [dstewart]
*
* Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
\**************************************************************************/

#ifndef _CONDLG_
#define _CONDLG_

#define CONNECTION_DONOTHING      0
#define CONNECTION_BATCH          1
#define CONNECTION_GETITNOW       2

BOOL _InternetGetConnectedState(DWORD* pdwHow, DWORD dwReserved, BOOL fConnect);
int ConnectionCheck(HWND hwndParent, void* pPassedOpt, TCHAR chDrive);

#endif //_CONDLG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\cdplayer\trklst.h ===
/******************************Module*Header*******************************\
* Module Name: trklst.h
*
* This module manipulates the cdrom track list.  The table of contents MUST
* be locked for ALL cdrom devices before calling any functions in this module.
*
* Created: 02-11-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

void
ComputeDriveComboBox(
    void
    );

void
SwitchToCdrom(
    int NewCdrom,
    BOOL prompt
    );

PTRACK_INF
FindTrackNodeFromTocIndex(
    int tocindex,
    PTRACK_INF listhead
    );

PTRACK_PLAY
FindFirstTrack(
    int cdrom
    );

PTRACK_PLAY
FindLastTrack(
    IN INT cdrom
    );

BOOL
AllTracksPlayed(
    void
    );

PTRACK_PLAY
FindNextTrack(
    BOOL wrap
    );

PTRACK_PLAY
FindPrevTrack(
    int cdrom,
    BOOL wrap
    );

int
FindContiguousEnd(
    int cdrom,
    PTRACK_PLAY tr
    );

void
FlipBetweenShuffleAndOrder(
    void
    );

void
ComputeAndUseShufflePlayLists(
    void
    );

void
ComputeSingleShufflePlayList(
    int i
    );

void
RestorePlayListsFromShuffleLists(
    void
    );

void
FigureTrackTime(
    int cdrom,
    int index,
    int * min,
    int * sec
    );

void
TimeAdjustInitialize(
    int cdrom
    );

void
TimeAdjustIncSecond(
    int cdrom
    );

void
TimeAdjustDecSecond(
    int cdrom
    );

void
InitializeNewTrackTime(
    int cdrom,
    PTRACK_PLAY tr,
    BOOL fUpdateDisplay
    );

void
TimeAdjustSkipToTrack(
    int cdrom,
    PTRACK_PLAY tr
    );

void
SyncDisplay(
    void
    );

void
ValidatePosition(
    int cdrom
    );

VOID
ResetTrackComboBox(
    int cdrom
    );

BOOL
PlayListMatchesAvailList(
    void
    );

void
AddTemporaryTrackToPlayList(
    PCURRPOS pCurr
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdnet\condlg.cpp ===
/******************************Module*Header*******************************\
* Module Name: condlg.cpp
*
* Author:  David Stewart [dstewart]
*
* Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
\**************************************************************************/

#include "windows.h"
#include "condlg.h"
#include "netres.h"
#include "..\cdopt\cdopt.h"
#include <htmlhelp.h>
#include "icwcfg.h"

extern HINSTANCE g_dllInst;
TCHAR g_Drive;

BOOL InternetConnectionWizardHasRun()
{
    HKEY hKey;
    DWORD dwICWCompleted = 0;

    if (RegOpenKey(HKEY_CURRENT_USER, TEXT(ICW_REGPATHSETTINGS), &hKey) == ERROR_SUCCESS)
    {
        DWORD dwSize = sizeof(dwICWCompleted);
        RegQueryValueEx(hKey, TEXT(ICW_REGKEYCOMPLETED), NULL, NULL, (LPBYTE)&dwICWCompleted, &dwSize);
        RegCloseKey(hKey);
    }

    if (dwICWCompleted > 0)
    {
        return TRUE;
    }
    
    return FALSE;
}

void LaunchICW()
{
    HINSTANCE hInetCfgDll = LoadLibrary(TEXT("inetcfg.dll"));

    if (hInetCfgDll)
    {
        PFNCHECKCONNECTIONWIZARD fp = (PFNCHECKCONNECTIONWIZARD)GetProcAddress(hInetCfgDll, "CheckConnectionWizard");
        if (fp)
        {
            DWORD dwRet;
            DWORD dwFlags = ICW_LAUNCHFULL | ICW_LAUNCHMANUAL | ICW_FULL_SMARTSTART;

            // Launch ICW full or manual path, whichever is available
            // NOTE: the ICW code makes sure only a single instance is up
            fp(dwFlags, &dwRet);
        }
        FreeLibrary(hInetCfgDll);
    }
}

BOOL _InternetGetConnectedState(DWORD* pdwHow, DWORD dwReserved, BOOL fConnect)
{
    //note: to make this work on Win95 machines, set retval to true by default
    BOOL retval = FALSE;

    //check to see if we have configured the connection already
    if (!InternetConnectionWizardHasRun())
    {
        //nope, so we need to run the ICW and return FALSE here
        LaunchICW();
        return FALSE;
    }

    HMODULE hNet = LoadLibrary(TEXT("WININET.DLL"));
    if (hNet!=NULL)
    {
	    typedef BOOL (PASCAL *CONPROC)(DWORD*, DWORD);
	    CONPROC conProc = (CONPROC)GetProcAddress(hNet,"InternetGetConnectedState");
	    if (conProc)
	    {
	        retval = conProc(pdwHow,dwReserved);

            if ((!retval) && (*pdwHow &1)) //INTERNET_CONNECTION_MODEM
            {
                if (fConnect)
                {
    	            typedef BOOL (PASCAL *DIALPROC)(DWORD, DWORD);
                    DIALPROC dialProc = (DIALPROC)GetProcAddress(hNet,"InternetAutodial");
                    if (dialProc)
                    {
                        retval = dialProc(1,0); //INTERNET_AUTODIAL_FORCE_ONLINE
                    }
                } //end if connect
            } //end if not online, but with a modem
	    } //end if connection proc available
	    FreeLibrary(hNet);
    }

    return (retval);
}

INT_PTR CALLBACK ConDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static LPCDOPTDATA pOptionData = NULL;

    switch (message)
    {
        case WM_INITDIALOG :
        {
            pOptionData = (LPCDOPTDATA)lParam;

            SendDlgItemMessage(hwnd,IDC_RADIO_DOWNLOAD_ONE,BM_SETCHECK,1,0);

            RECT rectDialog;
            GetWindowRect(hwnd,&rectDialog);

            SetWindowPos(hwnd,
                         GetParent(hwnd),
                         (GetSystemMetrics(SM_CXSCREEN)/2) - ((rectDialog.right - rectDialog.left) /2),
                         (GetSystemMetrics(SM_CYSCREEN)/2) - ((rectDialog.bottom - rectDialog.top) /2),
                         0,
                         0,
                         SWP_NOSIZE);

            //title of dialog is a "format string" with room for a single char drive letter
            TCHAR szFormat[MAX_PATH];
            TCHAR szTitle[MAX_PATH];
            GetWindowText(hwnd,szFormat,sizeof(szFormat)/sizeof(TCHAR));
            wsprintf(szTitle,szFormat,g_Drive);
            SetWindowText(hwnd,szTitle);
        }
        break;
    
        case WM_COMMAND :
        {
            switch (LOWORD(wParam))
            {
                case (IDOK) :
                {
                    if (SendDlgItemMessage(hwnd,IDC_RADIO_DOWNLOAD_ALL,BM_GETCHECK,0,0))
                    {
                        pOptionData->fDownloadPrompt = FALSE;
                    }

                    EndDialog(hwnd,CONNECTION_GETITNOW);
                }
                break;

                case (IDCANCEL) :
                {                      
                    if (pOptionData->fBatchEnabled)
                    {
                        EndDialog(hwnd,CONNECTION_BATCH);
                    }
                    else
                    {
                        EndDialog(hwnd,CONNECTION_DONOTHING);
                    } 
                }
                break;

                case (IDC_DOWNLOAD_HELP) :
                { 
                    #ifndef DEBUG
                    HtmlHelp(hwnd, TEXT("deluxcd.chm>main"), HH_DISPLAY_TOPIC, (DWORD_PTR) TEXT("CDX_overview.htm"));
                    #endif
                }
                break;
            } // end switch on WM_COMMAND
        } //end case WM_COMMAND
        break;
    }

    return FALSE;
}

int ConnectionCheck(HWND hwndParent, void* pPassedOpt, TCHAR chDrive)
{
    if (!pPassedOpt)
    {
        return CONNECTION_DONOTHING;
    }

    LPCDOPT pOpt = (LPCDOPT)pPassedOpt;

    LPCDOPTIONS pOptions = pOpt->GetCDOpts();
    LPCDOPTDATA pOptionData = pOptions->pCDData;

    if ((pOptionData->fDownloadPrompt) && (pOptionData->fDownloadEnabled))
    {
        //set global drive letter for dialog box
        g_Drive = chDrive;

        //no options selected, so prompt instead
        int nSelection = (int)DialogBoxParam(g_dllInst, MAKEINTRESOURCE(IDD_DIALOG_DOWNLOAD),
                   hwndParent, ConDlgProc, (LPARAM)pOptionData );

        pOpt->UpdateRegistry();

        return nSelection;
    }

    if (pOptionData->fDownloadEnabled)
    {
        return CONNECTION_GETITNOW;
    }

    if (pOptionData->fBatchEnabled)
    {
        return CONNECTION_BATCH;
    }

    return CONNECTION_DONOTHING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdnet\dllmain.cpp ===
// MMComp.cpp : Implementation of DLL Exports.


#include "windows.h"
#include "netres.h"
#include "tchar.h"
#include "getinfo.h"
#include "cdnet.h"

HINSTANCE g_dllInst = NULL;
HINSTANCE g_hURLMon = NULL;
CRITICAL_SECTION g_Critical;
CRITICAL_SECTION g_BatchCrit;

extern "C"
HRESULT WINAPI CDNET_CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, void ** ppvObj)
{
    CCDNet* pObj;
    HRESULT hr = E_OUTOFMEMORY;

    *ppvObj = NULL;

    if (NULL!=pUnkOuter && IID_IUnknown!=riid)
    {
        return CLASS_E_NOAGGREGATION;
    }

    pObj = new CCDNet();

    if (NULL==pObj)
    {
        return hr;
    }

    hr = pObj->QueryInterface(riid, ppvObj);

    if (FAILED(hr))
    {
        delete pObj;
    }

    return hr;
}


extern "C"
void WINAPI CDNET_Init(HINSTANCE hInst)
{
    g_dllInst = hInst;
    InitializeCriticalSection(&g_Critical);
    InitializeCriticalSection(&g_BatchCrit);
}

extern "C"
void WINAPI CDNET_Uninit()
{
    if (g_hURLMon)
    {
        FreeLibrary(g_hURLMon);
    }
    DeleteCriticalSection(&g_Critical);
    DeleteCriticalSection(&g_BatchCrit);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdnet\getinfo.h ===
/******************************Module*Header*******************************\
* Module Name: getinfo.h
*
* Author:  David Stewart [dstewart]
*
* Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
\**************************************************************************/

#if !defined(AFX_CDNETDLG_H__903DF404_39B8_11D1_BA31_00A0C913D47E__INCLUDED_)
#define AFX_CDNETDLG_H__903DF404_39B8_11D1_BA31_00A0C913D47E__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "cdnet.h"
#include "wininet.h"

/////////////////////////////////////////////////////////////////////////////
// CGetInfoFromNet

class CCDNet : public ICDNet
{
public:
	CCDNet();
    ~CCDNet();

public:
// IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();
// ICDNet
    STDMETHOD(SetOptionsAndData)(void* pOpt, void* pData);
    STDMETHOD(Download)(DWORD dwDeviceHandle, TCHAR chDrive, DWORD dwMSID, LPCDTITLE pTitle, BOOL fManual, HWND hwndParent);
    STDMETHOD_(BOOL,IsDownloading)();
    STDMETHOD(CancelDownload)();
    STDMETHOD(Upload)(LPCDTITLE pTitle, HWND hwndParent);
    STDMETHOD_(BOOL,CanUpload)();

private:
    DWORD m_dwRef;
};

class CGetInfoFromNet
{
public:
	// Construction
	CGetInfoFromNet(DWORD cdrom, DWORD dwMSID, HWND hwndParent);	// standard constructor
    ~CGetInfoFromNet();

	//main call
	BOOL DoIt(BOOL fManual, LPCDTITLE pTitle, TCHAR chDrive);
    void AddToBatch(int nNumTracks, TCHAR* szQuery);

// Implementation
private:
	//functions
	void BuildQuery();
	int readtoc();

	//data
	unsigned long m_toc[101];
	unsigned long m_TotalLength;
    TCHAR   m_Query[INTERNET_MAX_PATH_LENGTH-INTERNET_MAX_HOST_NAME_LENGTH];
	DWORD m_MS;
	DWORD DevHandle;
    int     m_Tracks;
};

#endif // !defined(AFX_CDNETDLG_H__903DF404_39B8_11D1_BA31_00A0C913D47E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdnet\getinfo.cpp ===
/******************************Module*Header*******************************\
* Module Name: getinfo.cpp
*
* Author:  David Stewart [dstewart]
*
* Copyright (c) 1998 Microsoft Corporation.  All rights reserved.
\**************************************************************************/

#include <TCHAR.H>
#include <objbase.h>
#include <mmsystem.h> //for mci commands
#include <urlmon.h>
#include <hlguids.h>  //for IID_IBindStatusCallback
#include "getinfo.h"
#include "netres.h"
#include "wininet.h"
#include "condlg.h"
#include "..\main\mmfw.h"
#include "..\cdopt\cdopt.h"
#include "mapi.h"
#include <stdio.h>

extern HINSTANCE g_dllInst;

#define MODE_OK 0
#define MODE_MULTIPLE 1
#define MODE_NOT_FOUND 2

#define FRAMES_PER_SECOND           75
#define FRAMES_PER_MINUTE           (60*FRAMES_PER_SECOND)
#define MAX_UPLOAD_URL_LENGTH       1500

#ifdef UNICODE
#define URLFUNCTION "URLOpenStreamW"
#define CANONFUNCTION "InternetCanonicalizeUrlW"
#else
#define URLFUNCTION "URLOpenStreamA"
#define CANONFUNCTION "InternetCanonicalizeUrlA"
#endif

HWND    g_hwndParent = NULL;
extern HINSTANCE g_hURLMon;
LPCDOPT g_pNetOpt = NULL;
LPCDDATA g_pNetData = NULL;
BOOL g_fCancelDownload = FALSE;     //ANY ACCESS MUST BE SURROUNDED by Enter/Leave g_Critical
IBinding* g_pBind = NULL;           //ANY ACCESS MUST BE SURROUNDED by Enter/Leave g_Critical
long g_lNumDownloadingThreads = 0;  //MUST USE InterlockedIncrement/Decrement
BOOL g_fDownloadDone = FALSE;
BOOL g_fDBWriteFailure = FALSE;
extern CRITICAL_SECTION g_Critical;
extern CRITICAL_SECTION g_BatchCrit;

DWORD WINAPI SpawnSingleDownload(LPVOID pParam);
DWORD WINAPI SpawnBatchDownload(LPVOID pParam);
DWORD WINAPI DoBatchDownload(LPCDBATCH pBatchList, HWND hwndParent);
BOOL DoDownload(TCHAR* url, TCHAR* szFilename, HWND hwndParent);

CCDNet::CCDNet()
{
    m_dwRef = 0;
}

CCDNet::~CCDNet()
{
}

STDMETHODIMP CCDNet::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;
    if (IID_IUnknown == riid || IID_ICDNet == riid)
    {  
        *ppv = this;
    }

    if (NULL==*ppv)
    {
        return E_NOINTERFACE;
    }

    AddRef();

    return S_OK;
}

STDMETHODIMP_(ULONG) CCDNet::AddRef(void)
{
    return ++m_dwRef;
}

STDMETHODIMP_(ULONG) CCDNet::Release(void)
{
    if (0!=--m_dwRef)
        return m_dwRef;

    delete this;
    return 0;
}

STDMETHODIMP CCDNet::SetOptionsAndData(void* pOpts, void* pData)
{
    g_pNetOpt = (LPCDOPT)pOpts;
    g_pNetData = (LPCDDATA)pData;

    return S_OK;
}

//this is a start to implementing the "upload via http" case rather than the
//upload via mail case
BOOL UploadToProvider(LPCDPROVIDER pProvider, LPCDTITLE pTitle, HWND hwndParent)
{
    TCHAR szURL[INTERNET_MAX_URL_LENGTH];
    TCHAR szMainURL[INTERNET_MAX_URL_LENGTH];
    TCHAR szFilename[MAX_PATH];

    //get the InternetCanonicalizeURL function
	typedef BOOL (PASCAL *CANPROC)(LPCTSTR, LPTSTR, LPDWORD, DWORD);
    CANPROC canProc = NULL;

    HMODULE hNet = LoadLibrary(TEXT("WININET.DLL"));
    if (hNet!=NULL)
    {
	    canProc = (CANPROC)GetProcAddress(hNet,CANONFUNCTION);
    }
    else
    {
        return FALSE;
    }
    
    if (pProvider && pTitle && canProc)
    {
        //check for provider URL
        if (_tcslen(pProvider->szProviderUpload)>0)
        {
            TCHAR szTempCan[MAX_PATH*2];

            //create the URL to send
            wsprintf(szMainURL,TEXT("%s%s"),pProvider->szProviderUpload,pTitle->szTitleQuery);
            _tcscpy(szURL,szMainURL);

            //add title
            _tcscat(szURL,TEXT("&t="));
            DWORD dwSize = sizeof(szTempCan);
            canProc(pTitle->szTitle,szTempCan,&dwSize,0);
            _tcscat(szURL,szTempCan);

            //add artist
            _tcscat(szURL,TEXT("&a="));
            dwSize = sizeof(szTempCan);
            canProc(pTitle->szArtist,szTempCan,&dwSize,0);
            _tcscat(szURL,szTempCan);
        
            //add tracks
            TCHAR szTrack[MAX_PATH];
            for (DWORD i = 0; i < pTitle->dwNumTracks; i++)
            {
                wsprintf(szTrack,TEXT("&%u="),i+1);

                dwSize = sizeof(szTempCan);
                canProc(pTitle->pTrackTable[i].szName,szTempCan,&dwSize,0);

                if ((_tcslen(szURL) + _tcslen(szTrack) + _tcslen(szTempCan)) > 
                    MAX_UPLOAD_URL_LENGTH-sizeof(TCHAR))
                {
                    //we're coming close to the limit.  Send what we have and start rebuilding
                    if (!g_fCancelDownload)
                    {
                        if (DoDownload(szURL,szFilename, hwndParent))
                        {
                            DeleteFile(szFilename);
                        } //end if "upload" successful
                        else
                        {
                            //bad upload, don't bother sending the rest
                            //probably a timeout
                            return FALSE;
                        }
                    }

                    //reset the URL to just the provider + toc
                    _tcscpy(szURL,szMainURL);
                } //end if length

                _tcscat(szURL,szTrack);
                _tcscat(szURL,szTempCan);
            } //end for track

            //send it
            if (!g_fCancelDownload)
            {
                if (DoDownload(szURL,szFilename, hwndParent))
                {
                    DeleteFile(szFilename);
                } //end if "upload" successful
                else
                {
                    return FALSE;
                }
            }
        } //end if url exists
    } //end if state OK

    if (hNet)
    {
        FreeLibrary(hNet);
    }

    return TRUE;
}

DWORD WINAPI UploadThread(LPVOID pParam)
{
    InterlockedIncrement((LONG*)&g_lNumDownloadingThreads);

    //this will block us against the batch download happening, too
	EnterCriticalSection(&g_BatchCrit);

    LPCDTITLE pTitle = (LPCDTITLE)pParam;
    HWND hwndParent = g_hwndParent;
    
    int nTries = 0;
    int nSuccessful = 0;

    if (pTitle)
    {
        LPCDOPTIONS pOptions = g_pNetOpt->GetCDOpts();             // Get the options, needed for provider list

        if (pOptions && pOptions->pCurrentProvider)             // Make sure we have providers
        {        
            LPCDPROVIDER pProviderList = NULL;
            LPCDPROVIDER pProvider = NULL;
        
            g_pNetOpt->CreateProviderList(&pProviderList);       // Get the sorted provider list
            pProvider = pProviderList;                          // Get the head of the list

            while ((pProvider) && (!g_fCancelDownload))
            {
                nTries++;
                if (UploadToProvider(pProvider,pTitle,hwndParent))
                {
                    nSuccessful++;
                }
                pProvider = pProvider->pNext;
            }

            g_pNetOpt->DestroyProviderList(&pProviderList);
        } //end if providers
    }

    //addref'ed before thread was created
    g_pNetOpt->Release();
    g_pNetData->Release();
    
    long status = UPLOAD_STATUS_NO_PROVIDERS;
    
    if ((nSuccessful != nTries) && (nSuccessful > 0))
    {
        status = UPLOAD_STATUS_SOME_PROVIDERS;
    }

    if ((nSuccessful == nTries) && (nSuccessful > 0))
    {
        status = UPLOAD_STATUS_ALL_PROVIDERS;
    }

    if (g_fCancelDownload)
    {
        status = UPLOAD_STATUS_CANCELED;
    }

	LeaveCriticalSection(&g_BatchCrit);
    InterlockedDecrement((LONG*)&g_lNumDownloadingThreads);

    //post message saying we're done
    PostMessage(hwndParent,WM_NET_DONE,(WPARAM)g_dllInst,status);

    return 0;
}

STDMETHODIMP CCDNet::Upload(LPCDTITLE pTitle, HWND hwndParent)
{
    HRESULT hr = E_FAIL;
    DWORD   dwHow;
    BOOL    fConnected;

    if (g_pNetOpt && g_pNetData && pTitle)                                      // Make sure we are in a valid state
    {
        fConnected = _InternetGetConnectedState(&dwHow,0,TRUE);     // Make sure we are connected to net

        if (fConnected)                                             // Make sure we are in a valid state
        {
            EnterCriticalSection(&g_Critical);
            g_fCancelDownload = FALSE;
            LeaveCriticalSection(&g_Critical);

            DWORD dwThreadID;
            HANDLE hNetThread = NULL;

            g_hwndParent = hwndParent;
            g_pNetOpt->AddRef();
            g_pNetData->AddRef();
            hNetThread = CreateThread(NULL,0,UploadThread,(void*)pTitle,0,&dwThreadID);
            if (hNetThread)
            {
                CloseHandle(hNetThread);
                hr = S_OK;
            }
        } //end if connected
    } //end if options and data ok

    return (hr);
}

STDMETHODIMP_(BOOL) CCDNet::CanUpload()
{
    BOOL retcode = FALSE;

    if (g_pNetOpt && g_pNetData)                                      // Make sure we are in a valid state
    {
        //check all providers to be sure at least one has upload capability
        LPCDOPTIONS pOptions = g_pNetOpt->GetCDOpts();             // Get the options, needed for provider list

        if (pOptions && pOptions->pCurrentProvider)             // Make sure we have providers
        {        
            LPCDPROVIDER pProviderList = NULL;
            LPCDPROVIDER pProvider = NULL;
    
            g_pNetOpt->CreateProviderList(&pProviderList);       // Get the sorted provider list
            pProvider = pProviderList;                          // Get the head of the list

            while (pProvider)
            {
                if (_tcslen(pProvider->szProviderUpload) > 0)
                {
                    retcode = TRUE;
                }
                pProvider = pProvider->pNext;
            } //end while

            g_pNetOpt->DestroyProviderList(&pProviderList);
        } //end if providers
    } //end if set up properly

    return (retcode);
}

STDMETHODIMP CCDNet::Download(DWORD dwDeviceHandle, TCHAR chDrive, DWORD dwMSID, LPCDTITLE pTitle, BOOL fManual, HWND hwndParent)
{
    if (g_pNetOpt==NULL)
    {
        return E_FAIL;
    }

    if (g_pNetData==NULL)
    {
        return E_FAIL;
    }

    if (FAILED(g_pNetData->CheckDatabase(hwndParent)))
    {
        return E_FAIL;
    }

	CGetInfoFromNet netinfo(dwDeviceHandle, 
                            dwMSID, 
                            hwndParent);

    EnterCriticalSection(&g_Critical);
    g_fCancelDownload = FALSE;
    LeaveCriticalSection(&g_Critical);
    
	BOOL fResult = netinfo.DoIt(fManual, pTitle, chDrive);

    return fResult ? S_OK : E_FAIL;
}

STDMETHODIMP_(BOOL) CCDNet::IsDownloading()
{
    BOOL retcode = FALSE;

    if (g_lNumDownloadingThreads > 0)
    {
        retcode = TRUE;
    }

    return (retcode);
}

STDMETHODIMP CCDNet::CancelDownload()
{
    EnterCriticalSection(&g_Critical);
    if (g_pBind)
    {
        g_pBind->Abort();
    }
    g_fCancelDownload = TRUE;
    LeaveCriticalSection(&g_Critical);
    while (IsDownloading())
    {
        Sleep(10);
    }

    return S_OK;
}

struct CBindStatusCallback : IBindStatusCallback
{
///// object state
    ULONG           m_cRef;         // object reference count
	BOOL            m_fAbort;       // set to true if we want this to abort
    HWND            m_hMessage;     // callback window
	IStream*	    m_pStream;	// holds downloaded data

///// construction and destruction
    CBindStatusCallback(IStream* pStream, HWND hwndParent);
    ~CBindStatusCallback();

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

///// IBindStatusCallback methods
    STDMETHODIMP OnStartBinding(DWORD dwReserved, IBinding *pib);
    STDMETHODIMP GetPriority(LONG *pnPriority);
    STDMETHODIMP OnLowResource(DWORD reserved);
    STDMETHODIMP OnProgress(ULONG ulProgress, ULONG ulProgressMax,
	ULONG ulStatusCode, LPCWSTR szStatusText);
    STDMETHODIMP OnStopBinding(HRESULT hresult, LPCWSTR szError);
    STDMETHODIMP GetBindInfo(DWORD *grfBINDF, BINDINFO *pbindinfo);
    STDMETHODIMP OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
	FORMATETC *pformatetc, STGMEDIUM *pstgmed);
    STDMETHODIMP OnObjectAvailable(REFIID riid, IUnknown *punk);
};

/////////////////////////////////////////////////////////////////////////////
// CBindStatusCallback Creation & Destruction
//
CBindStatusCallback::CBindStatusCallback(IStream* pStream, HWND hwndParent)
{
    HRESULT hr = S_OK;
    m_cRef = 0;
    m_fAbort = FALSE;
    m_pStream = pStream;
    m_pStream->AddRef();
    m_hMessage = hwndParent;

    PostMessage(m_hMessage,WM_NET_STATUS,(WPARAM)g_dllInst,IDS_STRING_CONNECTING);
}


CBindStatusCallback::~CBindStatusCallback()
{
    EnterCriticalSection(&g_Critical);
    if (g_pBind)
    {
        g_pBind->Release();
        g_pBind = NULL;
    }
    LeaveCriticalSection(&g_Critical);

	if( m_pStream )
	{
		m_pStream->Release();
		m_pStream = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CBindStatusCallback IUnknown Methods
//

STDMETHODIMP CBindStatusCallback::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IBindStatusCallback))
    {
	    *ppvObj = (IBindStatusCallback *) this;
	    AddRef();
	    return NOERROR;
    }
    else
    {
    	*ppvObj = NULL;
	    return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CBindStatusCallback::AddRef()
{
    InterlockedIncrement((LONG*)&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CBindStatusCallback::Release()
{
    ULONG cRef = m_cRef;
    if (InterlockedDecrement((LONG*)&m_cRef) == 0)
    {
    	delete this;
	    return 0;
    }
    else
	return cRef-1;
}


/////////////////////////////////////////////////////////////////////////////
// CBindStatusCallback IBindStatusCallback Methods
//

STDMETHODIMP CBindStatusCallback::OnStartBinding(DWORD dwReserved, IBinding *pib)
{
    EnterCriticalSection(&g_Critical);
    g_pBind = pib;
    g_pBind->AddRef();
    LeaveCriticalSection(&g_Critical);
    return S_OK;
}

STDMETHODIMP CBindStatusCallback::GetPriority(LONG *pnPriority)
{
    return S_OK;
}

STDMETHODIMP CBindStatusCallback::OnLowResource(DWORD reserved)
{
    return S_OK;
}

STDMETHODIMP CBindStatusCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
    ULONG ulStatusCode, LPCWSTR szStatusText)
{
	int nResID = 0;

    switch (ulStatusCode)
    {
        case (BINDSTATUS_FINDINGRESOURCE) : nResID = IDS_STRING_FINDINGRESOURCE; break;
        case (BINDSTATUS_CONNECTING) : nResID = IDS_STRING_CONNECTING; break;
        case (BINDSTATUS_REDIRECTING) : nResID = IDS_STRING_REDIRECTING; break;
        case (BINDSTATUS_BEGINDOWNLOADDATA) : nResID = IDS_STRING_BEGINDOWNLOAD; break;
        case (BINDSTATUS_DOWNLOADINGDATA) : nResID = IDS_STRING_DOWNLOAD; break;
        case (BINDSTATUS_ENDDOWNLOADDATA) : nResID = IDS_STRING_ENDDOWNLOAD; break;
        case (BINDSTATUS_SENDINGREQUEST) : nResID = IDS_STRING_SENDINGREQUEST; break;
    } //end switch
        
    if (nResID > 0)
    {
        PostMessage(m_hMessage,WM_NET_STATUS,(WPARAM)g_dllInst,nResID);
    }

    if (( m_fAbort ) || (g_fCancelDownload))
	{
        EnterCriticalSection(&g_Critical);
        g_fCancelDownload = TRUE;
        g_fDownloadDone = TRUE;
        LeaveCriticalSection(&g_Critical);
		return E_ABORT;
	}
    return S_OK;
}

STDMETHODIMP CBindStatusCallback::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    EnterCriticalSection(&g_Critical);
    if (g_pBind)
    {
        g_pBind->Release();
        g_pBind = NULL;
    }
    LeaveCriticalSection(&g_Critical);
    return S_OK;
}


STDMETHODIMP CBindStatusCallback::GetBindInfo(DWORD *pgrfBINDF, BINDINFO *pbindinfo)
{
    *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE;
    pbindinfo->cbSize = sizeof(BINDINFO);
    pbindinfo->szExtraInfo = NULL;
    ZeroMemory(&pbindinfo->stgmedData, sizeof(STGMEDIUM));
    pbindinfo->grfBindInfoF = 0;
    pbindinfo->dwBindVerb = BINDVERB_GET;
    pbindinfo->szCustomVerb = NULL;

    return S_OK;
}

STDMETHODIMP CBindStatusCallback::OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
    FORMATETC *pformatetc, STGMEDIUM *pstgmed)
{
	// fill our stream with the data from the stream passed to us
	if( m_pStream )
	{
		ULARGE_INTEGER cb;

		cb.LowPart = dwSize;
		cb.HighPart = 0;
		if( pstgmed && pstgmed->pstm )
		{
			pstgmed->pstm->CopyTo( m_pStream, cb, NULL, NULL );
		}
	}

    // Notify owner when download is complete
	if( grfBSCF & BSCF_LASTDATANOTIFICATION )
	{
        g_fDownloadDone = TRUE;

		if( m_pStream )
		{
			m_pStream->Release();
			m_pStream = NULL;
		}
	}
    return S_OK;
}

STDMETHODIMP CBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CGetInfoFromNet

CGetInfoFromNet::CGetInfoFromNet(DWORD cdrom, DWORD dwMSID, HWND hwndParent)
{
	DevHandle = cdrom;
	m_MS = dwMSID;
    g_hwndParent = hwndParent;
}

CGetInfoFromNet::~CGetInfoFromNet()
{
}

BOOL CGetInfoFromNet::DoIt(BOOL fManual, LPCDTITLE pTitle, TCHAR chDrive) 
{
	BOOL fRet = FALSE;

    int nMode = CONNECTION_GETITNOW;
    
    if (!fManual)
    {
        if (g_lNumDownloadingThreads == 0)
        {
            //if no threads are running already,
            //check the connection, possibly prompting the user
            nMode = ConnectionCheck(g_hwndParent,g_pNetOpt, chDrive);
        }
    }

    if (nMode == CONNECTION_DONOTHING)
    {
        return FALSE;
    }

	//if passed-in ID is not > 0, then we don't want to scan current disc
    if ((m_MS > 0) && (pTitle == NULL))
    {
        m_Tracks = readtoc();

	    if (m_Tracks > 0)
	    {
		    BuildQuery();
	    }
    } //if msid is greater than 0

    if (nMode == CONNECTION_BATCH)
    {
        if (m_MS > 0)
        {
            AddToBatch(m_Tracks,m_Query);
        }
        return FALSE;
    }

    //we need to determine now whether we spawn a batching thread or a single-item downloader
    g_fDBWriteFailure = FALSE;
    DWORD dwThreadID;
    HANDLE hNetThread = NULL;

    //addref the global pointers before entering the thread
    g_pNetOpt->AddRef();
    g_pNetData->AddRef();
    
    if (m_MS > 0)
    {
        //need to create a batch item for this thread to use
        LPCDBATCH pBatch = new CDBATCH;
        pBatch->fRemove = FALSE;
        pBatch->fFresh = TRUE;
        pBatch->pNext = NULL;

        if (!pTitle)
        {
            pBatch->dwTitleID = m_MS;
            pBatch->dwNumTracks = m_Tracks;
            pBatch->szTitleQuery = new TCHAR[_tcslen(m_Query)+1];
            _tcscpy(pBatch->szTitleQuery,m_Query);
        }
        else
        {
            pBatch->dwTitleID = pTitle->dwTitleID;
            pBatch->dwNumTracks = pTitle->dwNumTracks;
            if (pTitle->szTitleQuery)
            {
                pBatch->szTitleQuery = new TCHAR[_tcslen(pTitle->szTitleQuery)+1];
                _tcscpy(pBatch->szTitleQuery,pTitle->szTitleQuery);
            }
            else
            {
                pBatch->szTitleQuery = new TCHAR[_tcslen(m_Query)+1];
                _tcscpy(pBatch->szTitleQuery,m_Query);
            }
        }

        hNetThread = CreateThread(NULL,0,SpawnSingleDownload,(void*)pBatch,0,&dwThreadID);
    }
    else
    {
        hNetThread = CreateThread(NULL,0,SpawnBatchDownload,(void*)NULL,0,&dwThreadID);
    }

    if (hNetThread)
    {
        CloseHandle(hNetThread);
        fRet = TRUE;
    }

	return (fRet);
}

int CGetInfoFromNet::readtoc()
{
	DWORD dwRet;
    MCI_SET_PARMS   mciSet;

    ZeroMemory( &mciSet, sizeof(mciSet) );

    mciSet.dwTimeFormat = MCI_FORMAT_MSF;
    mciSendCommand( DevHandle, MCI_SET, MCI_SET_TIME_FORMAT, (DWORD_PTR)(LPVOID)&mciSet );

    MCI_STATUS_PARMS mciStatus;
    long lAddress, lStartPos, lDiskLen;
    int i;

    ZeroMemory( &mciStatus, sizeof(mciStatus) );
    mciStatus.dwItem = MCI_STATUS_NUMBER_OF_TRACKS;

    //
    // NOTE: none of the mciSendCommand calls below bother to check the
    //       return code.  This is asking for trouble... but if the
    //       commands fail we cannot do much about it.
    //
    dwRet = mciSendCommand( DevHandle, MCI_STATUS,
		    MCI_STATUS_ITEM, (DWORD_PTR)(LPVOID)&mciStatus);

	int tracks = -1;
	tracks = (UCHAR)mciStatus.dwReturn;

    mciStatus.dwItem = MCI_STATUS_POSITION;
    for ( i = 0; i < tracks; i++ )
    {

	    mciStatus.dwTrack = i + 1;
	    dwRet = mciSendCommand( DevHandle, MCI_STATUS,
			    MCI_STATUS_ITEM | MCI_TRACK,
			    (DWORD_PTR)(LPVOID)&mciStatus);

	    lAddress = (long)mciStatus.dwReturn;

        //converts "packed" time into pure frames
        lAddress =  (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
					(MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
					(MCI_MSF_FRAME( lAddress));

		m_toc[i] = lAddress;

		if (i==0)
		{
			lStartPos = lAddress;
		}
    }

    mciStatus.dwItem = MCI_STATUS_LENGTH;
    dwRet = mciSendCommand( DevHandle, MCI_STATUS,
		    MCI_STATUS_ITEM, (DWORD_PTR)(LPVOID)&mciStatus);

    /*
    ** Convert the total disk length into frames
    */
    lAddress  = (long)mciStatus.dwReturn;
    lDiskLen =  (MCI_MSF_MINUTE(lAddress) * FRAMES_PER_MINUTE) +
				(MCI_MSF_SECOND(lAddress) * FRAMES_PER_SECOND) +
				(MCI_MSF_FRAME( lAddress));

    /*
    ** Now, determine the absolute start position of the sentinel
    ** track.  That is, the special track that marks the end of the
    ** disk.
    */
    lAddress = lStartPos + lDiskLen + 1; //dstewart: add one for true time

	m_toc[i] = lAddress;

	return (tracks);
}

void CGetInfoFromNet::BuildQuery()
{
    wsprintf(m_Query,TEXT("cd=%X"),m_Tracks);
	
	//add each frame stattime to query, include end time of disc
	TCHAR tempstr[MAX_PATH];
	for (int i = 0; i < m_Tracks+1; i++)
	{
		wsprintf(tempstr,TEXT("+%X"),m_toc[i]);
		_tcscat(m_Query,tempstr);
	}
}

void CGetInfoFromNet::AddToBatch(int nNumTracks, TCHAR* szQuery)
{
    if ((g_pNetData) && (g_pNetOpt))
    {
        g_pNetData->AddToBatch(m_MS, szQuery, nNumTracks);
        LPCDOPTIONS pOptions = g_pNetOpt->GetCDOpts();
        if (pOptions)
        {
            pOptions->dwBatchedTitles = g_pNetData->GetNumBatched();
            g_pNetOpt->DownLoadCompletion(0,NULL);
        }
    }
}    

void CopyStreamToFile( IStream* pStream, HANDLE hFile )
{
	TCHAR	achBuf[512];
	ULONG	cb = 1;
	DWORD	dwWritten;
	LARGE_INTEGER	dlib;

	dlib.LowPart = 0;
	dlib.HighPart = 0;
	pStream->Seek( dlib, STREAM_SEEK_SET, NULL );
	pStream->Read( achBuf, 512, &cb );
	while( cb )
	{
		if( FALSE == WriteFile( hFile, achBuf, cb, &dwWritten, NULL ))
		{
			break;
		}
		pStream->Read( achBuf, 512, &cb );
	}
}

BOOL DoDownload(TCHAR* url, TCHAR* szFilename, HWND hwndParent)
{
	TCHAR szPath[_MAX_PATH];
	TCHAR    sz[_MAX_PATH];
	BOOL fGotFileName = FALSE;

	// Get a file name
	if(GetTempPath(_MAX_PATH, szPath))
	{
		if(GetTempFileName(szPath, TEXT("cdd"), 0, sz))
		{
		    fGotFileName = TRUE;
	    }
	}

    if (!fGotFileName)
    {
	    return FALSE;
    }

    IStream* pStream = NULL;

    g_fDownloadDone = FALSE;
    if (FAILED(CreateStreamOnHGlobal( NULL, TRUE, &pStream )))
    {
        return FALSE;
    }
    //pStream was addref'ed by createstreamonhgobal

	CBindStatusCallback* pCDC = new CBindStatusCallback(pStream, hwndParent);
	if(!pCDC)
	{
        pStream->Release();
		return FALSE;
	}
	pCDC->AddRef();

    HRESULT hr = E_NOTIMPL;

    if (g_hURLMon == NULL)
    {
        g_hURLMon = LoadLibrary(TEXT("URLMON.DLL"));
    }

    if (g_hURLMon!=NULL)
    {
	    typedef BOOL (PASCAL *URLDOWNLOADPROC)(LPUNKNOWN, LPCTSTR, DWORD, LPBINDSTATUSCALLBACK);
	    URLDOWNLOADPROC URLDownload = (URLDOWNLOADPROC)GetProcAddress(g_hURLMon,URLFUNCTION);

        if (URLDownload!=NULL)
        {
            #ifdef DBG
	        OutputDebugString(url);
            OutputDebugString(TEXT("\n"));
            #endif
            hr = URLDownload(NULL, url, 0, pCDC);
        }
    }

	if(FAILED(hr))
	{
		pCDC->Release();
        pStream->Release();
        return FALSE;
	}

    pCDC->Release();

    if (g_fCancelDownload)
    {
        return FALSE;
    }

	// Create the file for writing
	HANDLE hFileWrite = CreateFile(sz, GENERIC_READ | GENERIC_WRITE, 
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY, NULL);
	if( hFileWrite != INVALID_HANDLE_VALUE )
	{
		CopyStreamToFile( pStream, hFileWrite );
		CloseHandle( hFileWrite );
	}

    pStream->Release();

    _tcscpy(szFilename,sz);

    return TRUE;
}

//dialog box handler for multiple hits
INT_PTR CALLBACK MultiHitDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG :
        {
            TCHAR* szFilename = (TCHAR*)lParam;
            TCHAR szTemp[MAX_PATH];
            TCHAR szArtist[MAX_PATH];
            TCHAR szTitle[MAX_PATH];
            int i = 1;

            _tcscpy(szTitle,TEXT("."));
            
            while (_tcslen(szTitle)>0)
            {
                wsprintf(szTemp,TEXT("Title%i"),i);
       	        GetPrivateProfileString(TEXT("CD"),szTemp,TEXT(""),szTitle,sizeof(szTitle)/sizeof(TCHAR),szFilename);
                wsprintf(szTemp,TEXT("Artist%i"),i);
    	        GetPrivateProfileString(TEXT("CD"),szTemp,TEXT(""),szArtist,sizeof(szArtist)/sizeof(TCHAR),szFilename);
                i++;

                if (_tcslen(szTitle)>0)
                {
                    wsprintf(szTemp,TEXT("%s (%s)"),szTitle,szArtist);
                    SendDlgItemMessage(hwnd,IDC_LIST_DISCS,LB_ADDSTRING,0,(LPARAM)szTemp);
                }
            }

            SendDlgItemMessage(hwnd,IDC_LIST_DISCS,LB_SETCURSEL,0,0);
        }
        break;

        case WM_COMMAND :
        {
            if (LOWORD(wParam)==IDCANCEL)
            {
                EndDialog(hwnd,-1);
            }

            if (LOWORD(wParam)==IDOK)
            {
                LRESULT nSel = SendDlgItemMessage(hwnd,IDC_LIST_DISCS,LB_GETCURSEL,0,0);
                EndDialog(hwnd,nSel+1);
            }
        }
        break;
    }

    return FALSE;
}

BOOL ResolveMultiples(TCHAR* szFilename, BOOL fCurrent, HWND hwndParent)
{
    //special case ... sometimes, this comes back with <2 hits!!!
    //in this case, go ahead and ask for URL1

    TCHAR sznewurl[INTERNET_MAX_URL_LENGTH];
    GetPrivateProfileString(TEXT("CD"),TEXT("URL2"),TEXT(""),sznewurl,sizeof(sznewurl)/sizeof(TCHAR),szFilename);

    INT_PTR nSelection = 0;

    if (_tcslen(sznewurl)==0)
    {
        nSelection = 1;
    }
    else
    {
        if (fCurrent)
        {
            nSelection = DialogBoxParam(g_dllInst, MAKEINTRESOURCE(IDD_MULTIPLE_HITS),
                       hwndParent, MultiHitDlgProc, (LPARAM)szFilename );
        }
    }

    if (nSelection > 0)
    {
        TCHAR szSelected[MAX_PATH];
        wsprintf(szSelected,TEXT("URL%i"),nSelection);

        GetPrivateProfileString(TEXT("CD"),szSelected,TEXT(""),sznewurl,sizeof(sznewurl)/sizeof(TCHAR),szFilename);

        DeleteFile(szFilename);

        if (DoDownload(sznewurl,szFilename, hwndParent))
        {
            return TRUE;
        }
    }

    return FALSE;
}

//no more cover art in first version
#if 0
void TranslateTempCoverToFinal(TCHAR* szCurrent, TCHAR* szFinal, long discid, TCHAR* extension)
{
    //we want to put the cover art in a "coverart" subdir relative to whereever CD player is
    TCHAR szPath[MAX_PATH];
    GetModuleFileName(NULL,szPath,sizeof(szPath));

    TCHAR* szPathEnd;
    szPathEnd = _tcsrchr(szPath, TEXT('\\'))+sizeof(TCHAR);
    _tcscpy(szPathEnd,TEXT("coverart\\"));

    CreateDirectory(szPath,NULL); //create the coverart subdir

    wsprintf(szFinal,TEXT("%s%08X%s"),szPath,discid,extension);
}
#endif

DWORD GetNextDisc(long lOriginal, LPCDBATCH* ppBatch)
{
    DWORD discid = (DWORD)-1;

    //only do the batch if no discid was passed in originally to thread
    if (lOriginal < 1)
    {
        if (*ppBatch!=NULL)
        {
            *ppBatch = (*ppBatch)->pNext;
            if (*ppBatch != NULL)
            {
                discid = (*ppBatch)->dwTitleID;
            }
        }
    }

    return (discid);
}       

LPCDPROVIDER GetNewProvider(LPCDPROVIDER pList, LPCDPROVIDER pCurrent, LPCDPROVIDER pDefault)
{
    //find the next provider that isn't the current
    if (pCurrent == pDefault)
    {
        //we've just done the current provider, so go to the head of the list next
        pCurrent = pList;
        if (pCurrent == pDefault)
        {
            //if the default was also the head of the list, go to the next and return
            pCurrent = pCurrent->pNext;
        }
        return (pCurrent);
    }

    //get the next entry on the list
    pCurrent = pCurrent->pNext;

    //is the next entry the same as the default entry?  if so, move on one more
    if (pCurrent == pDefault)
    {
        pCurrent = pCurrent->pNext;
    }

    return (pCurrent);
}

//if szProvider is NULL, szURL is filled in with "just the query" ...
//if szProvider is not NULL, it is prepended to the query in szURL
int GetTracksAndQuery(LPCDBATCH pBatch, TCHAR* szURL, TCHAR* szProvider)
{
    if (pBatch == NULL)
    {
        return 0;
    }
    
    int nReturn = pBatch->dwNumTracks;

    if (szProvider != NULL)
    {
        wsprintf(szURL,TEXT("%s%s"),szProvider,pBatch->szTitleQuery);
    }
    else
    {
        _tcscpy(szURL,pBatch->szTitleQuery);
    }

    return nReturn;
}

void WINAPI AddTitleToDatabase(DWORD dwDiscID, DWORD dwTracks, TCHAR *szURL, TCHAR *szTempFile)
{
    LPCDTITLE   pCDTitle = NULL;
    TCHAR       tempstr[CDSTR];
    BOOL        fContinue = TRUE;
    DWORD       dwMenus = 0;

    while (fContinue)
    {
        TCHAR szMenuIndex[10];
        TCHAR szMenuEntry[INTERNET_MAX_URL_LENGTH];
        wsprintf(szMenuIndex,TEXT("MENU%i"),dwMenus+1);

		GetPrivateProfileString( TEXT("CD"), szMenuIndex, TEXT(""),
						         szMenuEntry, sizeof(szMenuEntry)/sizeof(TCHAR), szTempFile );

        if (_tcslen(szMenuEntry)>0)
        {
            dwMenus++;
        }
        else
        {
            fContinue = FALSE;
        }
    }

    if (SUCCEEDED(g_pNetData->CreateTitle(&pCDTitle, dwDiscID, dwTracks, dwMenus)))
    {
        GetPrivateProfileString(TEXT("CD"),TEXT("TITLE"),TEXT(""),tempstr,sizeof(tempstr)/sizeof(TCHAR),szTempFile);
        _tcscpy(pCDTitle->szTitle,tempstr);

        GetPrivateProfileString(TEXT("CD"),TEXT("ARTIST"),TEXT(""),tempstr,sizeof(tempstr)/sizeof(TCHAR),szTempFile);
        _tcscpy(pCDTitle->szArtist,tempstr);

        GetPrivateProfileString(TEXT("CD"),TEXT("LABEL"),TEXT(""),tempstr,sizeof(tempstr)/sizeof(TCHAR),szTempFile);
        _tcscpy(pCDTitle->szLabel,tempstr);

        GetPrivateProfileString(TEXT("CD"),TEXT("COPYRIGHT"),TEXT(""),tempstr,sizeof(tempstr)/sizeof(TCHAR),szTempFile);
        _tcscpy(pCDTitle->szCopyright,tempstr);

        GetPrivateProfileString(TEXT("CD"),TEXT("RELEASEDATE"),TEXT(""),tempstr,sizeof(tempstr)/sizeof(TCHAR),szTempFile);
        _tcscpy(pCDTitle->szDate,tempstr);

        g_pNetData->SetTitleQuery(pCDTitle, szURL); 

        for (int i = 1; i < (int) dwTracks + 1; i++)
        {
	        TCHAR tempstrtrack[10];
	        TCHAR tempstrtitle[CDSTR];
	        wsprintf(tempstrtrack,TEXT("TRACK%i"),i);
	        GetPrivateProfileString(TEXT("CD"),tempstrtrack,TEXT(""),tempstrtitle,sizeof(tempstrtitle)/sizeof(TCHAR),szTempFile);

            if (_tcslen(tempstrtitle) == 0)
            {
                TCHAR strFormat[CDSTR];
                LoadString(g_dllInst,IDS_STRING_DEFAULTTRACK,strFormat,sizeof(strFormat)/sizeof(TCHAR));
                wsprintf(tempstrtitle,strFormat,i);
            }

            _tcscpy(pCDTitle->pTrackTable[i-1].szName,tempstrtitle);
        }

        for (i = 1; i < (int) (dwMenus + 1); i++)
        {
	        TCHAR tempstrmenu[10];
	        TCHAR tempstrmenuvalue[CDSTR+INTERNET_MAX_URL_LENGTH+(3*sizeof(TCHAR))]; //3 = two colons and a terminating null
	        wsprintf(tempstrmenu,TEXT("MENU%i"),i);
	        GetPrivateProfileString(TEXT("CD"),tempstrmenu,TEXT(""),tempstrmenuvalue,sizeof(tempstrmenuvalue)/sizeof(TCHAR),szTempFile);

            //need to split menu into its component parts
            if (_tcslen(tempstrmenuvalue)!=0)
            {
                TCHAR* szNamePart;
                szNamePart = _tcsstr(tempstrmenuvalue,URL_SEPARATOR);

                TCHAR* szURLPart;
                szURLPart = _tcsstr(tempstrmenuvalue,URL_SEPARATOR);
                if (szURLPart!=NULL)
                {
                    //need to move past two colons
                    szURLPart = _tcsinc(szURLPart);
                    szURLPart = _tcsinc(szURLPart);
                }

                if (szNamePart!=NULL)
                {
                    *szNamePart = '\0';
                }

                if (tempstrmenuvalue)
                {
                    if (_tcslen(tempstrmenuvalue) >= sizeof(pCDTitle->pMenuTable[i-1].szMenuText)/sizeof(TCHAR))
                    {
                        tempstrmenuvalue[sizeof(pCDTitle->pMenuTable[i-1].szMenuText)/sizeof(TCHAR) - 1] = TEXT('\0');  // Trunc string to max len
                    }
                    _tcscpy(pCDTitle->pMenuTable[i-1].szMenuText,tempstrmenuvalue);
                }

                if (szURLPart)
                { 
                    g_pNetData->SetMenuQuery(&(pCDTitle->pMenuTable[i-1]), szURLPart); 
                }
            }
        }

        g_pNetData->UnlockTitle(pCDTitle,TRUE);

        //at this point, if the title is not in the database, we have a major problem
        if (!g_pNetData->QueryTitle(dwDiscID))
        {
            g_fDBWriteFailure = TRUE;
        }
        else
        {
            g_fDBWriteFailure = FALSE;
        }
    }
}


BOOL IsCertifiedProvider(LPCDPROVIDER pProvider, TCHAR *szTempFile)
{
    BOOL    fCertified = TRUE;
    TCHAR   szCert[MAX_PATH];
    
    GetPrivateProfileString(TEXT("CD"),TEXT("CERTIFICATE"),TEXT(""),szCert,sizeof(szCert)/sizeof(TCHAR),szTempFile);

    fCertified = g_pNetOpt->VerifyProvider(pProvider,szCert);

    return(fCertified);
}

void UpdatePropertyPage(DWORD dwDiscID, BOOL fDownloading, HWND hwndParent)
{
    if (g_pNetOpt)
    {
        LPCDUNIT pUnit = g_pNetOpt->GetCDOpts()->pCDUnitList;

        while (pUnit!=NULL)
        {
            if (pUnit->dwTitleID == dwDiscID)
            {
                pUnit->fDownLoading = fDownloading;
                PostMessage(hwndParent,WM_NET_DB_UPDATE_DISC,0,(LPARAM)pUnit); //Tell the UI we changed status of disc
                break;
            }
            pUnit = pUnit->pNext;
        }
    }
}

BOOL WINAPI DownloadBatch(LPCDBATCH pBatch, LPCDPROVIDER pProvider, LPDWORD pdwMultiHit, LPBOOL pfTimeout, HWND hwndParent)
{
    BOOL    fSuccess = FALSE;
    DWORD   dwTracks;
    TCHAR   szURL[INTERNET_MAX_URL_LENGTH];
    TCHAR   szTempFile[MAX_PATH];
    DWORD   dwDiscID;

    dwTracks = GetTracksAndQuery(pBatch, szURL, pProvider->szProviderURL);
    dwDiscID = pBatch->dwTitleID;
    *pfTimeout = FALSE;

    UpdatePropertyPage(pBatch->dwTitleID, TRUE, hwndParent); //tell prop page ui that disc is downloading

    if (dwTracks > 0 && dwDiscID != 0)
    {
        if (DoDownload(szURL,szTempFile,hwndParent))
        {
            if (IsCertifiedProvider(pProvider, szTempFile))
            {
	            int nMode = GetPrivateProfileInt(TEXT("CD"),TEXT("MODE"),MODE_NOT_FOUND,szTempFile);

                if (nMode == MODE_NOT_FOUND)
                {
                    DeleteFile(szTempFile);
                }
                else if (nMode == MODE_MULTIPLE)
                {
                    if (pdwMultiHit)
                    {
                        (*pdwMultiHit)++;
                    }

                    if (!ResolveMultiples(szTempFile,TRUE,hwndParent))
                    {
                        DeleteFile(szTempFile);
                    }
                    else
                    {
                        nMode = MODE_OK;
                    }
                }
                
                if (nMode == MODE_OK)
                {
                    GetTracksAndQuery(pBatch,szURL,NULL); //reset szURL to lose the provider
                    AddTitleToDatabase(dwDiscID, dwTracks, szURL, szTempFile);
                    DeleteFile(szTempFile);
                    fSuccess = TRUE;
                } //end if mode ok
            } //end if certified provider
        } //end if download ok
        else
        {
            *pfTimeout = TRUE;
        }
    } //end if valid query
    
    UpdatePropertyPage(pBatch->dwTitleID, FALSE, hwndParent); //tell prop page ui that disc is no longer downloading

    return(fSuccess);
}

DWORD WINAPI SpawnSingleDownload(LPVOID pParam)
{
    InterlockedIncrement((LONG*)&g_lNumDownloadingThreads);

    LPCDBATCH pBatch = (LPCDBATCH)pParam;
    HWND hwndParent = g_hwndParent;
    
    if (pBatch)
    {
        DoBatchDownload(pBatch,hwndParent);

        //if download failed, add to batch if not already in db
        //but only do this if batching is turned on
        LPCDOPTIONS pOptions = g_pNetOpt->GetCDOpts();
        if (pOptions)
        {
            LPCDOPTDATA pOptionData = pOptions->pCDData;
            if (pOptionData)
            {
                if (pOptionData->fBatchEnabled)
                {
                    if (!g_pNetData->QueryTitle(pBatch->dwTitleID))
                    {
                        g_pNetData->AddToBatch(pBatch->dwTitleID, pBatch->szTitleQuery, pBatch->dwNumTracks);
                        pOptions->dwBatchedTitles = g_pNetData->GetNumBatched();
                        PostMessage(hwndParent,WM_NET_DB_UPDATE_BATCH,0,0); //Tell the UI we changed number in batch
                    } //end if not in db
                } //if batching is on
            } //end if option data
        } //end if poptions

        delete [] pBatch->szTitleQuery;
        delete pBatch;
    }

    //addref'ed before thread was created
    g_pNetOpt->Release();
    g_pNetData->Release();
    
    InterlockedDecrement((LONG*)&g_lNumDownloadingThreads);
    return 0;
}

DWORD WINAPI SpawnBatchDownload(LPVOID pParam)
{
    InterlockedIncrement((LONG*)&g_lNumDownloadingThreads);

    LPCDBATCH pBatchList = NULL;
    HWND hwndParent = g_hwndParent;

    if (g_pNetData)
    {
        if (SUCCEEDED(g_pNetData->LoadBatch(NULL,&pBatchList)))
        {
            DoBatchDownload(pBatchList,hwndParent);
            g_pNetData->UnloadBatch(pBatchList);
        }
    }

    //addref'ed before thread was created
    g_pNetOpt->Release();
    g_pNetData->Release();
    
    InterlockedDecrement((LONG*)&g_lNumDownloadingThreads);
    return 0;
}

DWORD WINAPI DoBatchDownload(LPCDBATCH pBatchList, HWND hwndParent)
{
	EnterCriticalSection(&g_BatchCrit);

    BOOL    retcode = FALSE;
    DWORD   dwHow;
    BOOL    fConnected;
    DWORD   dwCurrent = 0;
    DWORD   dwOther = 0;
    DWORD   dwMultiHit = 0;
    DWORD   dwTimedOut = 0;

    fConnected = _InternetGetConnectedState(&dwHow,0,TRUE);     // Make sure we are connected to net

    if (fConnected && g_pNetOpt && g_pNetData)                        // Make sure we are in a valid state
    {
        LPCDOPTIONS pOptions = g_pNetOpt->GetCDOpts();             // Get the options, needed for provider list

        if (pOptions && pOptions->pCurrentProvider)             // Make sure we have providers
        {        
            LPCDPROVIDER pProviderList = NULL;
            LPCDPROVIDER pProvider = NULL;
            
            g_pNetOpt->CreateProviderList(&pProviderList);       // Get the sorted provider list
            pProvider = pProviderList;                          // Get the head of the list

            LPCDBATCH pBatch;
                      
            if (pBatchList)
            {
                while (pProvider && !g_fCancelDownload)                 // loop thru providers, but check current first and only once.
                {
                    BOOL fNotifiedUIProvider = FALSE;
                    pBatch = pBatchList;
                
                    while (pBatch && !g_fCancelDownload && !pProvider->fTimedOut)  // We will loop thru each batched title
                    {
                        BOOL fAttemptDownload = TRUE;                   // Assume we are going to try to download all in batch
                        if (pBatch->fRemove)
                        {
                            fAttemptDownload = FALSE; //we've already tried this disc on one provider and got it
                        }

                        if (fAttemptDownload)
                        {
                            if (!fNotifiedUIProvider)
                            {
                                PostMessage(hwndParent,WM_NET_CHANGEPROVIDER,0,(LPARAM)pProvider); //Tell the UI who the provider is
                                fNotifiedUIProvider = TRUE;
                            }

                            BOOL fTimeout = FALSE;

                            if (DownloadBatch(pBatch, pProvider, &dwMultiHit, &fTimeout, hwndParent))  // attempt to download this batch
                            {
                                pBatch->fRemove = TRUE;                         // This batch download succeeded, mark for termination from batch

                                if (pProvider == pOptions->pCurrentProvider)
                                {
                                    dwCurrent++;
                                }
                                else
                                {
                                    dwOther++;
                                }
                            }
                            else
                            {
                                pProvider->fTimedOut = fTimeout;
                            }

                            //check to see if db write failed
                            if (g_fDBWriteFailure)
                            {
                                //let the UI know
                                PostMessage(hwndParent,WM_NET_DB_FAILURE,0,0);

                                //get out of the batch loop
                                break;
                            }
                        
                            //let ui know that something happened with this disc
                            PostMessage(hwndParent,WM_NET_DONE,(WPARAM)g_dllInst,pBatch->dwTitleID);

                            //increment the meter if we know this is the last time we're
                            //visiting this particular disc ... either it was found, or
                            //we are out of possible places to look
                            if ((pBatch->fRemove) || (pProvider->pNext == NULL))
                            {
                                PostMessage(hwndParent,WM_NET_INCMETER,(WPARAM)g_dllInst,pBatch->dwTitleID);
                            }

                        } //end attempt on disc

                        pBatch = pBatch->pNext;
                    } //end batch
                
                    if (g_fDBWriteFailure)
                    {
                        //get out of the provider loop
                        break;
                    }

                    pProvider = pProvider->pNext; //providers are "in order"
                } //end while cycling providers

            } //end if load batch OK

            //check to see if ALL providers timed out ... possible net problem
            BOOL fAllFailed = TRUE;
            pProvider = pProviderList;
            while (pProvider!=NULL)
            {
                if (!pProvider->fTimedOut)
                {
                    fAllFailed = FALSE;
                    break;
                }
                pProvider = pProvider->pNext;
            }

            if (fAllFailed)
            {
                //let the UI know
                PostMessage(hwndParent,WM_NET_NET_FAILURE,0,0);
            }

            g_pNetOpt->DestroyProviderList(&pProviderList);
        } //end if pointers ok

#ifdef DBG
        // Ok, output some interesting stat's about what happened.
        {
            TCHAR str[255];
            wsprintf(str, TEXT("current = %d, other = %d, multihits = %d\n"), dwCurrent, dwOther, dwMultiHit);
            OutputDebugString(str);
        }
#endif
    } //end if connected to net and pointers ok

    if (!fConnected)
    {
        //may be a net problem
        if ((dwHow & (INTERNET_CONNECTION_MODEM|INTERNET_CONNECTION_LAN)) == 0)
        {
            PostMessage(hwndParent,WM_NET_NET_FAILURE,0,0);
        }
    }

    PostMessage(hwndParent,WM_NET_DONE,(WPARAM)g_dllInst,(LPARAM) 0); //fBadGuy ? -1 : 0);

	LeaveCriticalSection(&g_BatchCrit);

    return (retcode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdnet\netres.h ===
// Used by cdnet.rc
//
#define IDC_STATIC_FUNCTION             1000
#define IDD_MULTIPLE_HITS               301
#define IDD_DIALOG_DOWNLOAD             302
#define IDC_LIST_DISCS                  1001
#define IDC_STATIC                      -1

#define IDC_RADIO_DOWNLOAD_ONE          100
#define IDC_RADIO_DOWNLOAD_ALL          101
#define IDC_DOWNLOAD_HELP               102
#define IDI_NEWDISC                     103

#define IDS_STRING_FINDINGRESOURCE      55001
#define IDS_STRING_CONNECTING           55002
#define IDS_STRING_REDIRECTING          55003
#define IDS_STRING_BEGINDOWNLOAD        55004
#define IDS_STRING_DOWNLOAD             55005
#define IDS_STRING_ENDDOWNLOAD          55006
#define IDS_STRING_SENDINGREQUEST       55007

#define IDS_STRING_DEFAULTTRACK         55010
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\deluxe2\cdopt\cdopt.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Contains CD Options Interface
//
//	Copyright (c) Microsoft Corpor