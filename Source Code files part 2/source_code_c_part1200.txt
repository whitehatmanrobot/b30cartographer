ROM configuration. Set fields in ASC_DVC_VAR and
 * ASC_DVC_CFG based on the EEPROM settings. The chip is stopped while
 * all of this is done.
 *
 * On failure set the ASC_DVC_VAR field 'err_code' and return ADV_ERROR.
 *
 * For a non-fatal error return a warning code. If there are no warnings
 * then 0 is returned.
 *
 * Note: Chip is stopped on entry.
 */
static int
AscInitFromEEP(ASC_DVC_VAR WinBiosFar *asc_dvc)
{
    PortAddr            iop_base;
    ushort              warn_code;
    ASCEEP_CONFIG       eep_config;
    int                 i;

    iop_base = asc_dvc->iop_base;

    warn_code = 0;

    /*
     * Read the board's EEPROM configuration.
     *
     * Set default values if a bad checksum is found.
     */
    if (AdvGetEEPConfig(iop_base, &eep_config) != eep_config.check_sum)
    {
#if ADV_BIG_ENDIAN
        /* Need to swap some of the words before writing to the EEPROM. */
        ASCEEP_CONFIG  eep_config_mac;
#endif /* ADV_BIG_ENDIAN */

#ifndef ADV_OS_MAC
        warn_code |= ASC_WARN_EEPROM_CHKSUM;
#endif /* ADV_OS_MAC */

        /*
         * Set EEPROM default values.
         */
        for (i = 0; i < sizeof(ASCEEP_CONFIG); i++)
        {
            *((uchar *) &eep_config + i) =
#if ADV_BIG_ENDIAN
            *((uchar *) &eep_config_mac + i) =
#endif /* ADV_BIG_ENDIAN */
            *((uchar *) &Default_EEPROM_Config + i);
        }

        /*
         * Assume the 6 byte board serial number that was read
         * from EEPROM is correct even if the EEPROM checksum
         * failed.
         */
        eep_config.serial_number_word3 =
#if ADV_BIG_ENDIAN
        eep_config_mac.serial_number_word3 =
#endif /* ADV_BIG_ENDIAN */
            AscReadEEPWord(iop_base, ASC_EEP_DVC_CFG_END - 1);

        eep_config.serial_number_word2 =
#if ADV_BIG_ENDIAN
        eep_config_mac.serial_number_word2 =
#endif /* ADV_BIG_ENDIAN */
            AscReadEEPWord(iop_base, ASC_EEP_DVC_CFG_END - 2);

        eep_config.serial_number_word1 =
#if ADV_BIG_ENDIAN
        eep_config_mac.serial_number_word1 =
#endif /* ADV_BIG_ENDIAN */
            AscReadEEPWord(iop_base, ASC_EEP_DVC_CFG_END - 3);

#if !ADV_BIG_ENDIAN
        AdvSetEEPConfig(iop_base, &eep_config);
#else /* ADV_BIG_ENDIAN */
        /* swap every two bytes from word 9 to 15 before write to eep */
        for ( i = 9 ; i < 16 ; i ++ )
        {
            /* no need to swap word 12, 13 and 14 */
            if ( i == 12 ) { i = 15 ;}
            *((ushort *) &eep_config_mac + i) =
                EndianSwap16Bit(*((ushort *) &eep_config_mac + i));
        }
        AdvSetEEPConfig(iop_base, &eep_config_mac);
#endif /* ADV_BIG_ENDIAN */
    }
#if ADV_BIG_ENDIAN
    else
    {
        /* swap every two bytes from word 9 to 15 before write to eep */
        for ( i = 9 ; i < 16 ; i ++ )
        {
            /* no need to swap word 12, 13 and 14 */
            if ( i == 12 ) { i = 15 ;}
            *((ushort *) &eep_config + i) =
                EndianSwap16Bit(*((ushort *) &eep_config + i));
        }
    }
#endif /* ADV_BIG_ENDIAN */
    /*
     * Set ASC_DVC_VAR and ASC_DVC_CFG variables from the
     * EEPROM configuration that was read.
     *
     * This is the mapping of EEPROM fields to Adv Library fields.
     */
    asc_dvc->wdtr_able = eep_config.wdtr_able;
    asc_dvc->sdtr_able = eep_config.sdtr_able;
    asc_dvc->ultra_able = eep_config.ultra_able;
    asc_dvc->tagqng_able = eep_config.tagqng_able;
    asc_dvc->cfg->disc_enable = eep_config.disc_enable;
    asc_dvc->max_host_qng = eep_config.max_host_qng;
    asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;
    asc_dvc->chip_scsi_id = (eep_config.adapter_scsi_id & ASC_MAX_TID);
    asc_dvc->start_motor = eep_config.start_motor;
    asc_dvc->scsi_reset_wait = eep_config.scsi_reset_delay;
    asc_dvc->bios_ctrl = eep_config.bios_ctrl;
#ifdef ADV_OS_BIOS
    asc_dvc->cfg->bios_scan = eep_config.bios_scan;
    asc_dvc->cfg->bios_delay = eep_config.bios_boot_delay;
    asc_dvc->cfg->bios_id_lun = eep_config.bios_id_lun;
#endif /* ADV_OS_BIOS */
    asc_dvc->no_scam = eep_config.scam_tolerant;

    /*
     * Set the host maximum queuing (max. 253, min. 16) and the per device
     * maximum queuing (max. 63, min. 4).
     */
    if (eep_config.max_host_qng > ASC_DEF_MAX_HOST_QNG)
    {
        eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
    } else if (eep_config.max_host_qng < ASC_DEF_MIN_HOST_QNG)
    {
        /* If the value is zero, assume it is uninitialized. */
        if (eep_config.max_host_qng == 0)
        {
            eep_config.max_host_qng = ASC_DEF_MAX_HOST_QNG;
        } else
        {
            eep_config.max_host_qng = ASC_DEF_MIN_HOST_QNG;
        }
    }

    if (eep_config.max_dvc_qng > ASC_DEF_MAX_DVC_QNG)
    {
        eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
    } else if (eep_config.max_dvc_qng < ASC_DEF_MIN_DVC_QNG)
    {
        /* If the value is zero, assume it is uninitialized. */
        if (eep_config.max_dvc_qng == 0)
        {
            eep_config.max_dvc_qng = ASC_DEF_MAX_DVC_QNG;
        } else
        {
            eep_config.max_dvc_qng = ASC_DEF_MIN_DVC_QNG;
        }
    }

    /*
     * If 'max_dvc_qng' is greater than 'max_host_qng', then
     * set 'max_dvc_qng' to 'max_host_qng'.
     */
    if (eep_config.max_dvc_qng > eep_config.max_host_qng)
    {
        eep_config.max_dvc_qng = eep_config.max_host_qng;
    }

    /*
     * Set ASC_DVC_VAR 'max_host_qng' and ASC_DVC_CFG 'max_dvc_qng'
     * values based on possibly adjusted EEPROM values.
     */
    asc_dvc->max_host_qng = eep_config.max_host_qng;
    asc_dvc->max_dvc_qng = eep_config.max_dvc_qng;


    /*
     * If the EEPROM 'termination' field is set to automatic (0), then set
     * the ASC_DVC_CFG 'termination' field to automatic also.
     *
     * If the termination is specified with a non-zero 'termination'
     * value check that a legal value is set and set the ASC_DVC_CFG
     * 'termination' field appropriately.
     */
    if (eep_config.termination == 0)
    {
        asc_dvc->cfg->termination = 0;    /* auto termination */
    } else
    {
        /* Enable manual control with low off / high off. */
        if (eep_config.termination == 1)
        {
            asc_dvc->cfg->termination = TERM_CTL_SEL;

        /* Enable manual control with low off / high on. */
        } else if (eep_config.termination == 2)
        {
            asc_dvc->cfg->termination = TERM_CTL_SEL | TERM_CTL_H;

        /* Enable manual control with low on / high on. */
        } else if (eep_config.termination == 3)
        {
            asc_dvc->cfg->termination = TERM_CTL_SEL | TERM_CTL_H | TERM_CTL_L;
        } else
        {
            /*
             * The EEPROM 'termination' field contains a bad value. Use
             * automatic termination instead.
             */
            asc_dvc->cfg->termination = 0;
            warn_code |= ASC_WARN_EEPROM_TERMINATION;
        }
    }

    return warn_code;
}

/*
 * Read EEPROM configuration into the specified buffer.
 *
 * Return a checksum based on the EEPROM configuration read.
 */
ushort
AdvGetEEPConfig(PortAddr iop_base,
                ASCEEP_CONFIG dosfar *cfg_buf)
{
    ushort              wval, chksum;
    ushort dosfar       *wbuf;
    int                 eep_addr;

    wbuf = (ushort dosfar *) cfg_buf;
    chksum = 0;

    for (eep_addr = ASC_EEP_DVC_CFG_BEGIN;
         eep_addr < ASC_EEP_DVC_CFG_END;
         eep_addr++, wbuf++)
    {
        wval = AscReadEEPWord(iop_base, eep_addr);
        chksum += wval;
        *wbuf = wval;
    }
    *wbuf = AscReadEEPWord(iop_base, eep_addr);
    wbuf++;
    for (eep_addr = ASC_EEP_DVC_CTL_BEGIN;
         eep_addr < ASC_EEP_MAX_WORD_ADDR;
         eep_addr++, wbuf++)
    {
        *wbuf = AscReadEEPWord(iop_base, eep_addr);
    }
    return chksum;
}

/*
 * Read the EEPROM from specified location
 */
static ushort
AscReadEEPWord(PortAddr iop_base, int eep_word_addr)
{
    AscWriteWordRegister(iop_base, IOPW_EE_CMD,
        ASC_EEP_CMD_READ | eep_word_addr);
    AscWaitEEPCmd(iop_base);
    return AscReadWordRegister(iop_base, IOPW_EE_DATA);
}

/*
 * Wait for EEPROM command to complete
 */
static void
AscWaitEEPCmd(PortAddr iop_base)
{
    int eep_delay_ms;

    for (eep_delay_ms = 0; eep_delay_ms < ASC_EEP_DELAY_MS; eep_delay_ms++)
    {
        if (AscReadWordRegister(iop_base, IOPW_EE_CMD) & ASC_EEP_CMD_DONE)
        {
            break;
        }
        DvcSleepMilliSecond(1);
    }
    if ((AscReadWordRegister(iop_base, IOPW_EE_CMD) & ASC_EEP_CMD_DONE) == 0)
    {
        /* XXX - since the command timed-out an error should be returned. */
        ADV_ASSERT(0);
    }
    return;
}

/*
 * Write the EEPROM from 'cfg_buf'.
 */
void
AdvSetEEPConfig(PortAddr iop_base, ASCEEP_CONFIG dosfar *cfg_buf)
{
    ushort dosfar       *wbuf;
    ushort              addr, chksum;

    wbuf = (ushort dosfar *) cfg_buf;
    chksum = 0;

    AscWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_ABLE);
    AscWaitEEPCmd(iop_base);

    /*
     * Write EEPROM from word 0 to word 15
     */
    for (addr = ASC_EEP_DVC_CFG_BEGIN;
         addr < ASC_EEP_DVC_CFG_END; addr++, wbuf++)
    {
        chksum += *wbuf;
        AscWriteWordRegister(iop_base, IOPW_EE_DATA, *wbuf);
        AscWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
        AscWaitEEPCmd(iop_base);
        DvcSleepMilliSecond(ASC_EEP_DELAY_MS);
    }

    /*
     * Write EEPROM checksum at word 18
     */
    AscWriteWordRegister(iop_base, IOPW_EE_DATA, chksum);
    AscWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
    AscWaitEEPCmd(iop_base);
    wbuf++;        /* skip over check_sum */

    /*
     * Write EEPROM OEM name at words 19 to 26
     */
    for (addr = ASC_EEP_DVC_CTL_BEGIN;
         addr < ASC_EEP_MAX_WORD_ADDR; addr++, wbuf++)
    {
        AscWriteWordRegister(iop_base, IOPW_EE_DATA, *wbuf);
        AscWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE | addr);
        AscWaitEEPCmd(iop_base);
    }
    AscWriteWordRegister(iop_base, IOPW_EE_CMD, ASC_EEP_CMD_WRITE_DISABLE);
    AscWaitEEPCmd(iop_base);
    return;
}

/*
 * This function resets the chip and SCSI bus
 *
 * It is up to the caller to add a delay to let the bus settle after
 * calling this function.
 *
 * The SCSI_CFG0, SCSI_CFG1, and MEM_CFG registers are set-up in
 * AdvInitAsc3550Driver(). Here when doing a write to one of these
 * registers read first and then write.
 *
 * Note: A SCSI Bus Reset can not be done until after the EEPROM
 * configuration is read to determine whether SCSI Bus Resets
 * should be performed.
 */
void
AdvResetChip(ASC_DVC_VAR WinBiosFar *asc_dvc)
{
    PortAddr    iop_base;
    ushort      word;
    uchar       byte;

    iop_base = asc_dvc->iop_base;

    /*
     * Reset Chip.
     */
    AscWriteWordRegister(iop_base, IOPW_CTRL_REG, ADV_CTRL_REG_CMD_RESET);
    DvcSleepMilliSecond(100);
    AscWriteWordRegister(iop_base, IOPW_CTRL_REG, ADV_CTRL_REG_CMD_WR_IO_REG);

    /*
     * Initialize Chip registers.
     *
     * Note: Don't remove the use of a temporary variable in the following
     * code, otherwise the Microsoft C compiler will turn the following lines
     * into a no-op.
     */
    byte = AscReadByteRegister(iop_base, IOPB_MEM_CFG);
    byte |= RAM_SZ_8KB;
    AscWriteByteRegister(iop_base, IOPB_MEM_CFG, byte);

    word = AscReadWordRegister(iop_base, IOPW_SCSI_CFG1);
    word &= ~BIG_ENDIAN;
    AscWriteWordRegister(iop_base, IOPW_SCSI_CFG1, word);

    /*
     * Setting the START_CTL_EMFU 3:2 bits sets a FIFO threshold
     * of 128 bytes. This register is only accessible to the host.
     */
    AscWriteByteRegister(iop_base, IOPB_DMA_CFG0,
        START_CTL_EMFU | READ_CMD_MRM);
}


#if ADV_DISP_INQUIRY
void
AscDispInquiry(uchar tid, uchar lun, ASC_SCSI_INQUIRY dosfar *inq)
{
    int                 i;
    uchar               strbuf[18];
    uchar dosfar        *strptr;
    uchar               numstr[12];

    strptr = (uchar dosfar *) strbuf;
    DvcDisplayString((uchar dosfar *) " SCSI ID #");
    DvcDisplayString(todstr(tid, numstr));

    if (lun != 0)
    {
        DvcDisplayString((uchar dosfar *) " LUN #");
        DvcDisplayString(todstr(lun, numstr));
    }
    DvcDisplayString((uchar dosfar *) "  Type: ");
    DvcDisplayString(todstr(inq->peri_dvc_type, (uchar dosfar *) numstr));
    DvcDisplayString((uchar dosfar *) "  ");

    for (i = 0; i < 8; i++)
    {
        strptr[i] = inq->vendor_id[i];
    }
    strptr[i] = EOS;
    DvcDisplayString(strptr);

    DvcDisplayString((uchar dosfar *) " ");
    for (i = 0; i < 16; i++)
    {
        strptr[i] = inq->product_id[i];
    }
    strptr[i] = EOS;
    DvcDisplayString(strptr);

    DvcDisplayString((uchar dosfar *) " ");
    for (i = 0; i < 4; i++)
    {
        strptr[i] = inq->product_rev_level[i];
    }
    strptr[i] = EOS;
    DvcDisplayString(strptr);
    DvcDisplayString((uchar dosfar *) "\r\n");
    return;
}
#endif /* ADV_DISP_INQUIRY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\a_mcode.c ===
/*
 * a_mcode.c - Adv Library Microcode C Source File
 *
 * Copyright (c) 1997-1998 Advanced System Products, Inc.
 * All Rights Reserved.
 */

#include "a_qswap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\a_scsi.h ===
/*
 * a_scsi.h - Adv Library SCSI Include File
 *
 * Copyright (c) 1997-1998 Advanced System Products, Inc.
 * All Rights Reserved.
 */

#ifndef __A_SCSI_H_
#define __A_SCSI_H_

#define ASC_MAX_SENSE_LEN   32
#define ASC_MIN_SENSE_LEN   14

#define ASC_MAX_CDB_LEN     12 /* maximum command descriptor block */

/*
 * SCSI Bus Reset Hold Time - 60 microseconds.
 *
 * The minimum SCSI Bus Reset Hold Time defined in the SCSI Spec. is
 * 25 microseconds. The spec. does not define a maximum Hold Time. It
 * has been found that some devices will not operate after a SCSI Bus
 * Reset Hold Time of greater than 400 microseconds.
 *
 */
#define ASC_SCSI_RESET_HOLD_TIME_US  60

/*
 * SCSI Command Codes
 */
#define SCSICMD_TestUnitReady     0x00
#define SCSICMD_Rewind            0x01
#define SCSICMD_Rezero            0x01
#define SCSICMD_RequestSense      0x03
#define SCSICMD_Format            0x04
#define SCSICMD_FormatUnit        0x04
#define SCSICMD_Read6             0x08
#define SCSICMD_Write6            0x0A
#define SCSICMD_Seek6             0x0B
#define SCSICMD_Inquiry           0x12
#define SCSICMD_Verify6           0x13
#define SCSICMD_ModeSelect6       0x15
#define SCSICMD_ModeSense6        0x1A

#define SCSICMD_StartStopUnit     0x1B
#define SCSICMD_LoadUnloadTape    0x1B
#define SCSICMD_ReadCapacity      0x25
#define SCSICMD_Read10            0x28
#define SCSICMD_Write10           0x2A
#define SCSICMD_Seek10            0x2B
#define SCSICMD_Erase10           0x2C
#define SCSICMD_WriteAndVerify10  0x2E
#define SCSICMD_Verify10          0x2F

#define SCSICMD_WriteBuffer       0x3B
#define SCSICMD_ReadBuffer        0x3C
#define SCSICMD_ReadLong          0x3E
#define SCSICMD_WriteLong         0x3F

#define SCSICMD_ReadTOC           0x43
#define SCSICMD_ReadHeader        0x44

#define SCSICMD_ModeSelect10      0x55
#define SCSICMD_ModeSense10       0x5A

/*
 * Inquiry Data Peripheral Device Qualifier
 */
#define SCSI_QUAL_NODVC 0x03 /* LUN not supported. Device Type must be 0x1F */


/*
 * Inqury Data Peripheral Device Types
 */
#define SCSI_TYPE_DASD     0x00
#define SCSI_TYPE_SASD     0x01
#define SCSI_TYPE_PRN      0x02
#define SCSI_TYPE_PROC     0x03 /* Processor (some HP scanners) */
#define SCSI_TYPE_WORM     0x04 /* Write Once Read Many (some CD-Rs) */
#define SCSI_TYPE_CDROM    0x05
#define SCSI_TYPE_SCANNER  0x06
#define SCSI_TYPE_OPTMEM   0x07
#define SCSI_TYPE_MED_CHG  0x08
#define SCSI_TYPE_COMM     0x09
#define SCSI_TYPE_UNKNOWN  0x1F

#define SCSI_TYPE_NO_DVC   (SCSI_QUAL_NODVC | SCSI_TYPE_UNKNOWN)


#define ASC_SCSIDIR_NOCHK    0x00
        /* Direction determined by SCSI command, length not check */
#define ASC_SCSIDIR_T2H      0x08
        /* Transfer from SCSI Target to Host adapter, length check */
#define ASC_SCSIDIR_H2T      0x10
        /* Transfer from Host adapter to Target, length check  */
#define ASC_SCSIDIR_NODATA   0x18
        /* No data transfer */

#define ASC_SRB_HOST( x )  ( ( uchar )( ( uchar )( x ) >> 4 ) )
#define ASC_SRB_TID( x )   ( ( uchar )( ( uchar )( x ) & ( uchar )0x0F ) )
#define ASC_SRB_LUN( x )   ( ( uchar )( ( uint )( x ) >> 13 ) )

/* take high byte of unit number put it into CDB block index 1 */
#define PUT_CDB1( x )   ( ( uchar )( ( uint )( x ) >> 8 ) )


/*
 * SCSI Command Status Byte Values
 */
#define SS_GOOD              0x00 /* target successfully completed command  */
#define SS_CHK_CONDITION     0x02 /* contingent allegiance condition        */
#define SS_CONDITION_MET     0x04 /* requested operation is satisfied       */
#define SS_TARGET_BUSY       0x08 /* target is busy                         */
#define SS_INTERMID          0x10 /* intermediate                           */
#define SS_INTERMID_COND_MET 0x14 /* intermediate-condition met - the       */
                                  /* combination of condition-met (0x04)    */
                                  /* and intermediate (0x10) statuses       */
#define SS_RSERV_CONFLICT    0x18 /* reservation conflict                   */
#define SS_CMD_TERMINATED    0x22 /* command terminated                     */
                                  /* by terminated I/O process message or   */
                                  /* contingent allegiance condition        */
#define SS_QUEUE_FULL        0x28 /* queue full                             */


/*
 * Sense Keys
 *
 * Sense keys are returned in the Request Sense Command Data Structure.
 */
#define SCSI_SENKEY_NO_SENSE      0x00
#define SCSI_SENKEY_NOT_READY     0x02
#define SCSI_SENKEY_MEDIUM_ERR    0x03
#define SCSI_SENKEY_HW_ERR        0x04
#define SCSI_SENKEY_ILLEGAL       0x05
#define SCSI_SENKEY_ATTENTION     0x06
#define SCSI_SENKEY_PROTECTED     0x07
#define SCSI_SENKEY_BLANK         0x08
#define SCSI_SENKEY_ABORT         0x0B
#define SCSI_SENKEY_EQUAL         0x0C
#define SCSI_SENKEY_VOL_OVERFLOW  0x0D


/*
 * (ASC) Additional Sense Codes
 */
#define SCSI_ASC_NOTRDY         0x04
#define SCSI_ASC_POWERUP        0x29
#define SCSI_ASC_NOMEDIA        0x3A

/*
 * (ASCQ) Additional Sense Code Qualifiers
 */
#define SCSI_ASCQ_COMINGRDY     0x01

/*
 * SCSI messages
 */
#define MS_CMD_DONE    0x00 /* command completed            */
#define MS_EXTEND      0x01 /* first byte of extend message */
#define MS_SDTR_LEN    0x03 /* SDTR message length          */
#define MS_SDTR_CODE   0x01 /* extended message code of SDTR */

/*
 * One byte messages, 0x02 - 0x1F
 * 0x12 - 0x1F: reserved for one-byte messages
 *                                     I T, I-initiator T-target support
 *                                          O: Optional, M:mandatory
 * One byte Messages
 */
#define M1_SAVE_DATA_PTR        0x02 /*; O O save data pointer               */
#define M1_RESTORE_PTRS         0x03 /*; O O restore pointers                */
#define M1_DISCONNECT           0x04 /*; O O disconnect                      */
#define M1_INIT_DETECTED_ERR    0x05 /*; M M initiator detected error        */
#define M1_ABORT                0x06 /*; O M abort                           */
#define M1_MSG_REJECT           0x07 /*; M M message reject                  */
#define M1_NO_OP                0x08 /*; M M no operation                    */
#define M1_MSG_PARITY_ERR       0x09 /*; M M message parity error            */
#define M1_LINK_CMD_DONE        0x0A /*; O O link command completed          */
#define M1_LINK_CMD_DONE_WFLAG  0x0B /*; O O link command completed with flag*/
#define M1_BUS_DVC_RESET        0x0C /*; O M bus device reset                */
#define M1_ABORT_TAG            0x0D /*; O O abort tag                       */
#define M1_CLR_QUEUE            0x0E /*; O O clear queue                     */
#define M1_INIT_RECOVERY        0x0F /*; O O initiate recovery               */
#define M1_RELEASE_RECOVERY     0x10 /*; O O release recovery                */
#define M1_KILL_IO_PROC         0x11 /*; O O terminate i/o process           */

/*
 * First byte of two-byte queue tag messages, 0x20 - 0x2F
 * queue tag messages, 0x20 - 0x22
 */
#define M2_QTAG_MSG_SIMPLE      0x20 /* O O simple queue tag     */
#define M2_QTAG_MSG_HEAD        0x21 /* O O head of queue tag    */
#define M2_QTAG_MSG_ORDERED     0x22 /* O O ordered queue tag    */

#define M2_IGNORE_WIDE_RESIDUE  0x23 /* O O ignore wide residue  */


/*
 * Inquiry Data Structure
 */
#if !ADV_BIG_ENDIAN
typedef struct {
  uchar peri_dvc_type   : 5;    /* peripheral device type */
  uchar peri_qualifier  : 3;    /* peripheral qualifier */
  uchar dvc_type_modifier : 7;  /* device type modifier (for SCSI I) */
  uchar rmb      : 1;           /* RMB - removable medium bit */
  uchar ansi_apr_ver : 3;       /* ANSI approved version */
  uchar ecma_ver : 3;           /* ECMA version */
  uchar iso_ver  : 2;           /* ISO version */
  uchar rsp_data_fmt : 4;       /* response data format */
                                /* 0 SCSI 1 */
                                /* 1 CCS */
                                /* 2 SCSI-2 */
                                /* 3-F reserved */
  uchar res      : 2;           /* reserved */
  uchar TemIOP   : 1;           /* terminate I/O process bit (see 5.6.22) */
  uchar aenc     : 1;           /* asynch. event notification (processor) */
  uchar  add_len;               /* additional length */
  uchar  res1;                  /* reserved */
  uchar  res2;                  /* reserved */
  uchar StfRe   : 1;            /* soft reset implemented */
  uchar CmdQue  : 1;            /* command queuing */
  uchar Reserved: 1;            /* reserved */
  uchar Linked  : 1;            /* linked command for this logical unit */
  uchar Sync    : 1;            /* synchronous data transfer */
  uchar WBus16  : 1;            /* wide bus 16 bit data transfer */
  uchar WBus32  : 1;            /* wide bus 32 bit data transfer */
  uchar RelAdr  : 1;            /* relative addressing mode */
  uchar vendor_id[8];           /* vendor identification */
  uchar product_id[16];         /* product identification */
  uchar product_rev_level[4];   /* product revision level */
} ASC_SCSI_INQUIRY; /* 36 bytes */
#else /* ADV_BIG_ENDIAN */
typedef struct {
  uchar peri_qualifier  : 3;    /* peripheral qualifier */
  uchar peri_dvc_type   : 5;    /* peripheral device type */
  uchar rmb      : 1;           /* RMB - removable medium bit */
  uchar dvc_type_modifier : 7;  /* device type modifier (for SCSI I) */
  uchar iso_ver  : 2;           /* ISO version */
  uchar ecma_ver : 3;           /* ECMA version */
  uchar ansi_apr_ver : 3;       /* ANSI approved version */
  uchar aenc     : 1;           /* asynch. event notification (processor) */
  uchar TemIOP   : 1;           /* terminate I/O process bit (see 5.6.22) */
  uchar res      : 2;           /* reserved */
  uchar rsp_data_fmt : 4;       /* response data format */
                                /* 0 SCSI 1 */
                                /* 1 CCS */
                                /* 2 SCSI-2 */
                                /* 3-F reserved */
  uchar  add_len;               /* additional length */
  uchar  res1;                  /* reserved */
  uchar  res2;                  /* reserved */
  uchar RelAdr  : 1;            /* relative addressing mode */
  uchar WBus32  : 1;            /* wide bus 32 bit data transfer */
  uchar WBus16  : 1;            /* wide bus 16 bit data transfer */
  uchar Sync    : 1;            /* synchronous data transfer */
  uchar Linked  : 1;            /* linked command for this logical unit */
  uchar Reserved: 1;            /* reserved */
  uchar CmdQue  : 1;            /* command queuing */
  uchar StfRe   : 1;            /* soft reset implemented */
  uchar vendor_id[8];           /* vendor identification */
  uchar product_id[16];         /* product identification */
  uchar product_rev_level[4];   /* product revision level */
} ASC_SCSI_INQUIRY; /* 36 bytes */
#endif /* ADV_BIG_ENDIAN */
/*
 * Request Sense Data Structure
 */
#if !ADV_BIG_ENDIAN
typedef struct adv_req_sense {
  uchar err_code: 7 ;         /* 0  bit 0 to 6, if code 70h or 71h           */
  uchar info_valid: 1 ;       /*    bit 7, info1[] information is valid      */

  uchar segment_no ;          /* 1, segment number                           */

  uchar sense_key: 4 ;        /* 2, bit 3 - 0: sense key                     */
  uchar reserved_bit: 1 ;     /*    bit 4 reserved bit                       */
  uchar sense_ILI: 1 ;        /*    bit 5 EOM( end of medium encountered )   */
  uchar sense_EOM: 1 ;        /*    bit 6 ILI( length error )                */
  uchar file_mark: 1 ;        /*    bit 7 file mark encountered              */

  uchar info1[ 4 ] ;          /* 3-6, information                            */
  uchar add_sense_len ;       /* 7, additional sense length                  */
  uchar cmd_sp_info[ 4 ] ;    /* 8-11, command specific information          */
  uchar asc ;                 /* 12, additional sense code                   */
  uchar ascq ;                /* 13, additional sense code qualifier         */
  /* Minimum request sense length ends here. */

  uchar fruc ;                /* 14, field replaceable unit code             */

  uchar sks_byte0: 7 ;        /* 15,                                         */
  uchar sks_valid : 1 ;       /* 15, SKSV: sense key specific valid          */

  uchar sks_bytes[2] ;        /* 16-17, sense key specific, MSB is SKSV      */
  uchar notused[ 2 ] ;        /* 18-19,                                      */
  uchar ex_sense_code ;       /* 20, extended additional sense code          */
  uchar info2[ 5 ] ;          /* 21-25, additional sense bytes               */
} ASC_REQ_SENSE ;             /* 26 bytes - must be even number of bytes */
#else /* ADV_BIG_ENDIAN */
typedef struct adv_req_sense {
  uchar info_valid: 1 ;       /*    bit 7, info1[] information is valid      */
  uchar err_code: 7 ;         /* 0  bit 0 to 6, if code 70h or 71h           */

  uchar segment_no ;          /* 1, segment number                           */
  uchar file_mark: 1 ;        /*    bit 7 file mark encountered              */
  uchar sense_EOM: 1 ;        /*    bit 6 ILI( length error )                */
  uchar sense_ILI: 1 ;        /*    bit 5 EOM( end of medium encountered )   */
  uchar reserved_bit: 1 ;     /*    bit 4 reserved bit                       */
  uchar sense_key: 4 ;        /* 2, bit 3 - 0: sense key                     */

  uchar info1[ 4 ] ;          /* 3-6, information                            */
  uchar add_sense_len ;       /* 7, additional sense length                  */
  uchar cmd_sp_info[ 4 ] ;    /* 8-11, command specific information          */
  uchar asc ;                 /* 12, additional sense code                   */
  uchar ascq ;                /* 13, additional sense code qualifier         */
  /* Minimum request sense length ends here. */

  uchar fruc ;                /* 14, field replaceable unit code             */

  uchar sks_valid : 1 ;       /* 15, SKSV: sense key specific valid          */
  uchar sks_byte0: 7 ;        /* 15,                                         */

  uchar sks_bytes[2] ;        /* 16-17, sense key specific, MSB is SKSV      */
  uchar notused[ 2 ] ;        /* 18-19,                                      */
  uchar ex_sense_code ;       /* 20, extended additional sense code          */
  uchar info2[ 5 ] ;          /* 21-25, additional sense bytes               */
} ASC_REQ_SENSE ;             /* 26 bytes - must be even number of bytes */
#endif /* ADV_BIG_ENDIAN */

#endif /* #ifndef __A_SCSI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\d_os_dep.h ===
/*
 * AdvanSys 3550 Windows NT SCSI Miniport Driver - d_os_dep.h
 *
 * Copyright (c) 1994-1997  Advanced System Products, Inc.
 * All Rights Reserved.
 */

#ifndef _D_OS_DEP_H
#define _D_OS_DEP_H

#define ADV_OS_WINNT

/*
 * Include driver required files.
 */
/* Windows NT Include Files */
#include "miniport.h"
#include "scsi.h"

/*
 * Define Adv Library compile-time options. Refer to a_advlib.h for
 * more information about Adv Library compile-time options.
 */

#define ADV_GETSGLIST           1     /* Use AscGetSGList() */
#define ADV_NEW_BOARD           1     /* Use new Condor board */
#define ADV_PCI_MEMORY          1     /* Use registers mapped to PCI memory */
#define ADV_DISP_INQUIRY        0     /* Don't use AscDispInquiry() */
#define ADV_INITSCSITARGET      0     /* Don't use AdvInitScsiTarget() */
#define ADV_RETRY               0     /* Don't let Adv Library do retries */
#define ADV_SCAM                0     /* Don't use AscScam() */
#define ADV_CRITICAL            0     /* Don't have critical sections. */
#define ADV_UCODEDEFAULT        1     /* Use default microcode variables. */
#define ADV_BIG_ENDIAN          0     /* Use Little Endian ordering. */


/*
 * Define Adv Library required general types.
 */
typedef unsigned char   uchar;
typedef unsigned short  ushort;
typedef unsigned int    uint;
typedef unsigned long   ulong;

/*
 * Define Adv Library required special types.
 */
#if ADV_PCI_MEMORY
#define PortAddr  unsigned long         /* virtual memory address size */
#else /* ADV_PCI_MEMORY */
#define PortAddr  unsigned short        /* port address size */
#endif /* ADV_PCI_MEMORY */
#define Ptr2Func  ulong                 /* size of a function pointer */
#define dosfar
#define WinBiosFar

/*
 * Define Adv Library required I/O port macros.
 */
#define inp(addr) \
    ScsiPortReadPortUchar((uchar *) (addr))
#define inpw(addr) \
    ScsiPortReadPortUshort((ushort *) (addr))
#define outp(addr, byte) \
    ScsiPortWritePortUchar((uchar *) (addr) , (uchar) (byte))
#define outpw(addr, word) \
    ScsiPortWritePortUshort((ushort *) (addr), (ushort) (word))

#if ADV_PCI_MEMORY
/*
 * Define Adv Library required memory access macros.
 */
#define ADV_MEM_READB(addr) \
    ScsiPortReadRegisterUchar((uchar *) (addr))
#define ADV_MEM_READW(addr) \
    ScsiPortReadRegisterUshort((ushort *) (addr))
#define ADV_MEM_WRITEB(addr, byte) \
    ScsiPortWriteRegisterUchar((uchar *) (addr) , (uchar) (byte))
#define ADV_MEM_WRITEW(addr, word) \
    ScsiPortWriteRegisterUshort((ushort *) (addr), (ushort) (word))
#endif /* ADV_PCI_MEMORY */

/*
 * Define Adv Library required scatter-gather limit definition.
 *
 * The driver returns NumberOfPhysicalBreaks to Windows NT which is 1
 * less then the maximum scatter-gather count. But Windows NT incorrectly
 * set MaximumPhysicalPages, the parameter class drivers use, to the value
 * of NumberOfPhsysicalBreaks.
 *
 * For Windows NT set ADV_MAX_SG_LIST to 64 for 256 KB requests (64 * 4KB).
 * This value shouldn't be set too high otherwise under heavy load NT will
 * be unable to allocate non-paged memory and blue-screen.
 *
 * WINNT_SGADD is added to insure the driver won't be broken if Microsoft
 * decides to fix NT in the future and set MaximumPhysicalPages to
 * NumberOfPhsyicalBreaks + 1. The driver sets the limit 1 higher than
 * it has to be to support a certain number of scatter-gather elements.
 * If NT is ever changed to use 1 more, the driver will have already
 * reserved space for it.
 */
#define WINNT_SGADD           1

#define ADV_MAX_SG_LIST         (64 + WINNT_SGADD)

#define ADV_ASSERT(a) \
    { \
        if (!(a)) { \
            DebugPrint((1, "ADv_ASSERT() Failure: file %s, line %d\n", \
                __FILE__, __LINE__)); \
        } \
    }

#endif /* _D_OS_DEP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\adapinit.c ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

    Adapinit.c

Abstract:

    This is the Adapter Initialize entry point for the Agilent
    PCI to Fibre Channel Host Bus Adapter (HBA).

Authors:

    MB - Michael Bessire
    DL - Dennis Lindfors FC Layer support
    IW - Ie Wei Njoo
    LP - Leopold Purwadihardja
    KR - Kanna Rajagopal

Environment:

    kernel mode only

Notes:

Version Control Information:

    $Archive: /Drivers/Win2000/Trunk/OSLayer/C/ADAPINIT.C $


Revision History:

    $Revision: 4 $
    $Date: 10/23/00 5:35p $
    $Modtime:: 10/18/00 6:08p           $

Notes:


--*/


#include "buildop.h"
#include "osflags.h"
#include "TLStruct.H"
#if defined(HP_PCI_HOT_PLUG)
   #include "HotPlug4.h"    // NT 4.0 PCI Hot-Plug header file
#endif

extern ULONG gGlobalIOTimeout;

/*++

Routine Description:

    Initialize HBA.
    HwScsiInitialize
 
    NOTE: Interrupts are available before completion of this routine !
 
Arguments:
 
    pCard - HBA miniport driver's data adapter storage

Return Value:

    TRUE  - if initialization successful.
    FALSE - if initialization unsuccessful.

--*/

BOOLEAN
HPFibreInitialize(
    IN PCARD_EXTENSION pCard
    )
{
    agRoot_t * hpRoot=&pCard->hpRoot;
    ULONG return_value;
    ULONG num_devices=0;
    UCHAR PathId,TargID,Lun,x;
    PLU_EXTENSION plunExtension = NULL;
 
    pCard->State |= CS_DURING_DRV_INIT;
 
    osDEBUGPRINT((ALWAYS_PRINT,"IN HPFibreInitialize %lx @ %x\n", hpRoot, osTimeStamp(0) ));
 
#if DBG > 2
    dump_pCard( pCard);
#endif

    pCard->External_ResetCount=0;
    pCard->Internal_ResetCount=0;
    
    #ifdef _DEBUG_LOSE_IOS_
    pCard->Srb_IO_Count=0;
    pCard->Last_Srb_IO_Count=0;
    #endif

    pCard->Number_interrupts=0;
    
    #ifdef _DEBUG_PERF_DATA_
    pCard->Perf_ptr = &pCard->perf_data[0];
    pCard->usecsPerTick = 1000000;
    #endif
    
    pCard->SingleThreadCount = 0;

    osDEBUGPRINT((ALWAYS_PRINT,"Zero Cache Memory %lx Length %x\n",
        pCard->cachedMemoryPtr, pCard->cachedMemoryNeeded ));

    osZero( pCard->cachedMemoryPtr, pCard->cachedMemoryNeeded );

    osDEBUGPRINT((DMOD,"Zero DMA Memory %lx Length %x\n",
            pCard->dmaMemoryPtr, pCard->dmaMemoryNeeded ));

    osZero( pCard->dmaMemoryPtr, pCard->dmaMemoryNeeded );

    osDEBUGPRINT((ALWAYS_PRINT,"Calling fcInitializeChannel with the following parameters:\n"));
    osDEBUGPRINT((ALWAYS_PRINT,"   cachedMemoryPtr    = %x\n   cachedMemoryNeeded = %x\n",
                               pCard->cachedMemoryPtr,
                               pCard->cachedMemoryNeeded));
    osDEBUGPRINT((ALWAYS_PRINT,"   dmaMemoryUpper32   = %x\n   dmaMemoryLower32   = %x\n",
                               pCard->dmaMemoryUpper32,
                               pCard->dmaMemoryLower32));
    osDEBUGPRINT((ALWAYS_PRINT,"   dmaMemoryPtr       = %x\n   dmaMemoryNeeded    = %x\n",
                               pCard->dmaMemoryPtr,
                               pCard->dmaMemoryNeeded));
    osDEBUGPRINT((ALWAYS_PRINT,"   nvMemoryNeeded     = %x\n   cardRamUpper       = %x\n",
                               pCard->nvMemoryNeeded,
                               pCard->cardRamUpper));
    osDEBUGPRINT((ALWAYS_PRINT,"   cardRamLower       = %x\n   RamLength          = %x\n",
                               pCard->cardRamLower,
                               pCard->RamLength));
    osDEBUGPRINT((ALWAYS_PRINT,"   cardRomUpper       = %x\n   cardRomLower       = %x\n",
                               pCard->cardRomUpper,
                               pCard->cardRomLower));
    osDEBUGPRINT((ALWAYS_PRINT,"   RomLength          = %x\n   usecsPerTick       = %x\n",
                               pCard->RomLength,
                               pCard->usecsPerTick ));
    

    return_value = fcInitializeChannel( hpRoot,
                                       fcSyncInit,
#ifdef OSLayer_Stub
                                       agFALSE, // sysIntsActive
#else
                                       agTRUE, // sysIntsActive
#endif
                                       pCard->cachedMemoryPtr,
                                       pCard->cachedMemoryNeeded,
                                       pCard->dmaMemoryUpper32,
                                       pCard->dmaMemoryLower32,
                                       pCard->dmaMemoryPtr,
                                       pCard->dmaMemoryNeeded,
                                       pCard->nvMemoryNeeded,
                                       pCard->cardRamUpper,
                                       pCard->cardRamLower,
                                       pCard->RamLength ,
                                       pCard->cardRomUpper,
                                       pCard->cardRomLower,
                                       pCard->RomLength,
                                       pCard->usecsPerTick );

    if (return_value != fcInitializeSuccess) 
    {
        osDEBUGPRINT((ALWAYS_PRINT, "HPFibreInitialize: fcInitializeChannel FAILED\n"));
        
        #ifdef _DEBUG_EVENTLOG_
        LogEvent(   pCard, 
                  NULL,
                  HPFC_MSG_INITIALIZECHANNELFAILED,
                  NULL, 
                  0, 
                  "%xx", return_value);
        #endif
        
        pCard->State &= ~CS_DURING_DRV_INIT;
        osLogBit32 (hpRoot, __LINE__);
        return FALSE;
    }

    #ifdef _DEBUG_EVENTLOG_
    {
        LogHBAInformation(pCard);
    }
    #endif
      
    #ifndef YAM2_1
    for(x=0; x < MAX_FC_DEVICES; x++)
    {
    #else
    for(x=0; x < gMaxPaDevices; x++)
    {
    #endif
        pCard->hpFCDev[x]= NULL;
    }

    GetNodeInfo (pCard);

#if DBG > 2
    dump_pCard( pCard);
#endif

    //WIN64 compliant
    #ifndef YAM2_1
    osDEBUGPRINT((ALWAYS_PRINT,"Card Ext %p to %p\n",pCard,
                            (((char*)pCard)+sizeof(CARD_EXTENSION) +
                            pCard->cachedMemoryNeeded +
                            pCard->cachedMemoryAlign)));
    #else
    osDEBUGPRINT((ALWAYS_PRINT,"Card Ext %p to %p\n",pCard,
                            (((char*)pCard)+gDeviceExtensionSize) ));
   
    #endif
    osDEBUGPRINT((ALWAYS_PRINT,"OUT HPFibreInitialize %lx return_value %x\n",hpRoot,  return_value));
    pCard->State &= ~CS_DURING_DRV_INIT;

    // osChipIOUpWriteBit32(hpRoot, ChipIOUp_TachLite_Control, 0x8); // Clear trigger for finsar

    if(pCard->usecsPerTick > 100 )
    {
        HPFibreTimerTick ( pCard );
    }

    //ScsiPortNotification (RequestTimerCall, pCard,
    //                    (PHW_TIMER) HPFibreTimerTick, pCard->usecsPerTick);

#if defined(HP_PCI_HOT_PLUG)

    // Set Hot Plug flag to indicate timer is running.
    pCard->controlFlags |= LCS_HBA_TIMER_ACTIVE;

    // Clear Hot Plug state flag to indicate cache is NOT used.
    pCard->stateFlags &= ~PCS_HBA_CACHE_IN_USE;
   
    // Compute how many iterations should the StartIO() return Busy during 
    // hot plug. The time limit is set to default to 30 seconds.

    pCard->IoHeldRetMaxIter = RET_VAL_MAX_ITER;     // Default, assume 1 second timer.
    if (pCard->usecsPerTick)
    {
        pCard->IoHeldRetMaxIter = (RET_VAL_MAX_ITER * 1000000) / pCard->usecsPerTick;
    }
#endif    

    return TRUE;
} // end HPFibreInitialize()

/*++

Routine Description:

    This routine is a call back from FC layer when we call fcInitializeChannel. 
    NT layer do nothing.

Arguments:

    hpRoot                  - common card structure
    hpInitializeStatus      - status

Return Value:

    void

--*/
osGLOBAL void osInitializeChannelCallback(
                                          agRoot_t *hpRoot,
                                          os_bit32  hpInitializeStatus
                                        )
{
    PCARD_EXTENSION pCard;
    pCard   = (PCARD_EXTENSION)hpRoot->osData;
    osDEBUGPRINT((DLOW,"IN osInitializeChannelCallback %lx status %lx\n",hpRoot,hpInitializeStatus));
}

// extern ULONG  HPDebugFlag;
extern ULONG  Global_Print_Level;

/*++

Routine Description:

    This routine is part of the Qing routine

Arguments:

    pSrbExt        - current Srb extension

Return Value:

    next SrbExt or NULL

--*/
PSRB_EXTENSION  Get_next_Srbext( PSRB_EXTENSION pSrbExt)
{
    if(pSrbExt->pNextSrbExt)
    {
        if(pSrbExt == pSrbExt->pNextSrbExt )
        {
            osDEBUGPRINT((ALWAYS_PRINT,"IN Out standing Q screwed up ! Cur %lx == next %lx\n",pSrbExt, pSrbExt->pNextSrbExt));
        }
    return pSrbExt->pNextSrbExt;
    }
    else
        return NULL;
}

/*++

Routine Description:

    This routine is part of the Qing routine. Debug Purpose only

Arguments:

    pSrbExt        - current Srb extension

Return Value:

    next SrbExt or NULL

--*/
void display_srbext( agIORequest_t *hpIORequest )
{
    PSRB_EXTENSION pSrbExt= hpIORequest->osData;
    PSCSI_REQUEST_BLOCK pSrb;
    agIORequestBody_t * phpReqBody;

    if(IS_VALID_PTR(pSrbExt))
    {
        pSrb = pSrbExt->pSrb;
        if(IS_VALID_PTR(pSrb))
        {
            phpReqBody = &pSrbExt->hpRequestBody;
            osDEBUGPRINT((ALWAYS_PRINT,"phpRoot            %lx\n", pSrbExt->phpRoot        ));
            osDEBUGPRINT((ALWAYS_PRINT,"pCard              %lx\n", pSrbExt->pCard          ));
            osDEBUGPRINT((ALWAYS_PRINT,"AbortSrb           %lx\n", pSrbExt->AbortSrb       ));
            osDEBUGPRINT((ALWAYS_PRINT,"pSrb               %lx\n", pSrbExt->pSrb           ));
            osDEBUGPRINT((ALWAYS_PRINT,"CDB  %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
                pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9] ));
            osDEBUGPRINT((ALWAYS_PRINT,"pNextSrb           %lx\n", pSrbExt->pNextSrb       ));
            osDEBUGPRINT((ALWAYS_PRINT,"SglVirtAddr        %lx\n", pSrbExt->SglVirtAddr    ));
            osDEBUGPRINT((ALWAYS_PRINT,"SglDataLen         %8x\n", pSrbExt->SglDataLen     ));
            osDEBUGPRINT((ALWAYS_PRINT,"SglElements         %x\n", pSrbExt->SglElements    ));
            osDEBUGPRINT((ALWAYS_PRINT,"SRB_State          %08x\n", pSrbExt->SRB_State     ));
            osDEBUGPRINT((ALWAYS_PRINT,"SRB_StartTime      %08x\n", pSrbExt->SRB_StartTime ));
            #ifdef _DEBUG_LOSE_IOS_
            osDEBUGPRINT((ALWAYS_PRINT,"SRB_SRB_IO_COUNT   %8x\n",pSrbExt->SRB_IO_COUNT  ));
            #endif
            osDEBUGPRINT((ALWAYS_PRINT,"pLunExt            %lx\n", pSrbExt->pLunExt        ));
            osDEBUGPRINT((ALWAYS_PRINT,"hpIORequest        %lx\n", &pSrbExt->hpIORequest   ));
            osDEBUGPRINT((ALWAYS_PRINT,"FcpCntl %02x %02x %02x %02x\n",
                phpReqBody->CDBRequest.FcpCmnd.FcpCntl[0],phpReqBody->CDBRequest.FcpCmnd.FcpCntl[1],
                phpReqBody->CDBRequest.FcpCmnd.FcpCntl[2],phpReqBody->CDBRequest.FcpCmnd.FcpCntl[3] ));

            osDEBUGPRINT((ALWAYS_PRINT,"hpRequestBody      %lx\n", &pSrbExt->hpRequestBody ));
        }
        else
            osDEBUGPRINT((ALWAYS_PRINT,"Bad SRB     %lx\n",pSrbExt->pSrb ));
    }
    else
        osDEBUGPRINT((ALWAYS_PRINT,"Bad SRBext  %lx hpIORequest %lx\n",pSrbExt,hpIORequest ));
}

/*++

Routine Description:

    *** HwScsiTimer entry point for the OS layer. ***
    NT kernel mode drivers design guide specifies that
    ScsiPortNotification synchronizes calls to the HwScsiTimer
    routine with those to the HwScsiInterrupt routine so that
    it can not execute concurrently while the HwScsiTimer
    routine is running. But it does not specify any thing
    about port driver synchronizing calls to other miniport
    driver entry points like HwScsiStartIo with the HwScsiTimer
    routine.
    Excluding the initialization specific entry points and the interrupt
    specific entry points the only entry points that we use are
    HwScsiStartIo and HwScsiResetBus. In order to synchronize calls
    to HwScsiTimer with these routines we make use of
    pCard->inDriver and pCard->inTimer variables.

Arguments:

    pCard          - Device Extension specifying a specific card instance
   
Return Value:

    none

--*/
void
HPFibreTimerTick (
    IN PCARD_EXTENSION pCard
    )
{
    agRoot_t *hpRoot = &pCard->hpRoot;

    pCard->inTimer = TRUE;

    // Sequencialize entry
    if (pCard->inDriver == TRUE) 
    {
        ScsiPortNotification (RequestTimerCall, pCard,
                          (PHW_TIMER) HPFibreTimerTick, pCard->usecsPerTick);
        pCard->inTimer = FALSE;
        return;
    }

//----------------------------------------------------------------------------
#if defined(HP_PCI_HOT_PLUG)
    //
    // If there is any PCI Hot Plug related task need to be done, do it here
    // and skip normal timer task.
    //
    if ( HotPlugTimer(pCard) == TRUE)
    {
        ScsiPortNotification (RequestTimerCall, pCard,
                          (PHW_TIMER) HPFibreTimerTick, pCard->usecsPerTick);
        pCard->inTimer = FALSE;
        return;
    }

#endif
//----------------------------------------------------------------------------

    // notify FClayer
    fcTimerTick (hpRoot);

    // process our own reset command
    if (pCard->flags & OS_DO_SOFT_RESET) 
    {
        pCard->LostDevTickCount--;
        if (pCard->LostDevTickCount == 0) 
        {
            pCard->flags &= ~OS_DO_SOFT_RESET;
            pCard->OldNumDevices = 0;
            osDEBUGPRINT((ALWAYS_PRINT, ".............................................\n"));
            osDEBUGPRINT((ALWAYS_PRINT, "HPFibreTimerTick: Resetting channel\n"));

            fcResetChannel (hpRoot, fcSyncReset);

            if (pCard->LinkState != LS_LINK_UP) 
            {
                GetNodeInfo (pCard);
                if (pCard->Num_Devices != 0) 
                {
                    FixDevHandlesForLinkUp (pCard);
                    pCard->LinkState = LS_LINK_UP;
                } 
                else
                    pCard->LinkState = LS_LINK_DOWN;
                ScsiPortNotification (NextRequest, pCard, NULL, NULL, NULL);
            }
        }
    }

    // move all IOs from RetryQ to AdapterQ
    RetryQToAdapterQ (pCard);

    // if Link is UP, rethread all pending IOs
    if (pCard->LinkState == LS_LINK_UP && pCard->AdapterQ.Head)
        Startio (pCard);

    // if link is DOWN, retries any Inquiry commands by reporting ResetDetected so that 
    // we don't get ID 9 events during ScsiPort scanning phase
    if (pCard->LinkState == LS_LINK_DOWN) 
    {
        pCard->TicksSinceLinkDown++;
        /* Issue a resetdetected, so that the port driver
        * re-issues all its IOs, and there will be no timeouts
        */
        if((pCard->SrbStatusFlag) && (pCard->TicksSinceLinkDown <= gGlobalIOTimeout))
        {
            ScsiPortNotification (ResetDetected, pCard, NULL);
        }
        
        if (pCard->TicksSinceLinkDown >= TICKS_FOR_LINK_DEAD) 
        {
            pCard->LinkState = LS_LINK_DEAD;
            pCard->TicksSinceLinkDown = 0;
        }
    } 
    else
        pCard->TicksSinceLinkDown = 0;

    // Restart Timer
    ScsiPortNotification (RequestTimerCall, pCard,
                          (PHW_TIMER) HPFibreTimerTick, pCard->usecsPerTick);

    pCard->inTimer = FALSE;
}

/*++

Routine Description:

   This routine filled up the FC device array and Node Info.

Arguments:

   pCard        - card instance

Return Value:

   none

--*/
void
GetNodeInfo (PCARD_EXTENSION pCard)
{
    agRoot_t       *hpRoot = &pCard->hpRoot;
    agFCDevInfo_t  devinfo;
    ULONG          x;

    // clear existing array
    ClearDevHandleArray (pCard);

    // call FC layer to get all the FC handles
    #ifndef YAM2_1
    pCard->Num_Devices = fcGetDeviceHandles (hpRoot, &pCard->hpFCDev[0], MAX_FC_DEVICES);
    #else
    pCard->Num_Devices = fcGetDeviceHandles (hpRoot, &pCard->hpFCDev[0], gMaxPaDevices);
    #endif

    osDEBUGPRINT((ALWAYS_PRINT,"GetNodeInfo: fcGetDeviceHandles returned %d\n", pCard->Num_Devices));
    pCard->Num_Devices = 0;

    // fill the Device Info array
    #ifndef YAM2_1
    for (x=0; x < MAX_FC_DEVICES; x++) 
    {
    #else
    for (x=0; x < gMaxPaDevices; x++) 
    {
    #endif
        if (pCard->hpFCDev[x]) 
        {
            fcGetDeviceInfo (hpRoot, pCard->hpFCDev[x], &devinfo );

            pCard->nodeInfo[x].DeviceType = devinfo.DeviceType;

            if (devinfo.DeviceType & agDevSelf) 
            {
                pCard->cardHandleIndex = x;
            }

            // count the number of 'scsi' devices
            if (devinfo.DeviceType & agDevSCSITarget)
                pCard->Num_Devices++;

            osDEBUGPRINT((ALWAYS_PRINT,"GetNodeInfo: Slot = %d handle = 0x%lx\n", x, pCard->hpFCDev[x]));
            osDEBUGPRINT((ALWAYS_PRINT,"GetNodeInfo: WWN 0x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                                 devinfo.NodeWWN[0],devinfo.NodeWWN[1],
                                 devinfo.NodeWWN[2],devinfo.NodeWWN[3],
                                 devinfo.NodeWWN[4],devinfo.NodeWWN[5],
                                 devinfo.NodeWWN[6],devinfo.NodeWWN[7] ));
            osDEBUGPRINT((ALWAYS_PRINT,"GetNodeInfo: PortWWN 0x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                                 devinfo.PortWWN[0],devinfo.PortWWN[1],
                                 devinfo.PortWWN[2],devinfo.PortWWN[3],
                                 devinfo.PortWWN[4],devinfo.PortWWN[5],
                                 devinfo.PortWWN[6],devinfo.PortWWN[7] ));
            osDEBUGPRINT((ALWAYS_PRINT,"GetNodeInfo: Alpa = 0x%02x\n",devinfo.CurrentAddress.AL_PA));
            
            #ifndef YAM2_1          
            #ifdef _DEBUG_EVENTLOG_
            if (!pCard->Old_hpFCDev[x]) 
            {
                LogEvent(pCard, NULL, HPFC_MSG_FOUND_DEVICE, NULL, 0,
                     "%02x%02x%02x%02x %02x%02x%02x%02x",
                     devinfo.NodeWWN[0],devinfo.NodeWWN[1],
                     devinfo.NodeWWN[2],devinfo.NodeWWN[3],
                     devinfo.NodeWWN[4],devinfo.NodeWWN[5],
                     devinfo.NodeWWN[6],devinfo.NodeWWN[7] );
            }
            #endif
            #endif               

        } 
        else 
        {
            pCard->nodeInfo[x].DeviceType = agDevUnknown;
        }
    }

    #ifndef YAM2_1
    #ifdef _DEBUG_EVENTLOG_
    for (x=0; x < MAX_FC_DEVICES; x++) 
        pCard->Old_hpFCDev[x] = pCard->hpFCDev[x];
    #endif
    #endif
    osDEBUGPRINT((ALWAYS_PRINT,"GetNodeInfo: Number of SCSI target ports = %d\n", pCard->Num_Devices));
    
    // update YAM Peripheral mode (PA) device table
    #ifdef YAM2_1
    FillPaDeviceTable(pCard);
    #endif            
}

/*++

Routine Description:

    Move all pending IOs in the retryQ to the adapterQ. 
    Note: Any retries MUST not be added to the AdapterQ directly. It must be added to the RetryQ and 
    processed by this routine (for synch purpose).
   
Arguments:

    pCard        - card instance

Return Value:

    none

--*/
void
RetryQToAdapterQ (PCARD_EXTENSION pCard)
{
    PSCSI_REQUEST_BLOCK pSrb;

    while ((pSrb = SrbDequeueHead (&pCard->RetryQ)) != NULL)
      SrbEnqueueTail (&pCard->AdapterQ, pSrb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\a_ver.h ===
/*
 * a_ver.h - Adv Library Version and Revision History File
 *
 * Copyright (c) 1997-1998  Advanced System Products, Inc.
 * All Rights Reserved.
 */

/*
 * Adv Library Version Number - Increment the major number for major
 * changes and the minor number for minor changes.
 */
#define ASC_LIB_VERSION_MAJOR  3
#define ASC_LIB_VERSION_MINOR  52
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\buildop.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   buildop.h

Abstract:

Authors:

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/buildop.h $


Revision History:

   $Revision: 8 $
   $Date: 11/10/00 5:51p $
   $Modtime:: 10/30/00 5:02p           $

Notes:


--*/

#ifndef __BUILDOP_H_
#define __BUILDOP_H_

#ifndef UNDEF__REGISTERFORSHUTDOWN__
#define __REGISTERFORSHUTDOWN__	
#endif

#ifndef UNDEF_ENABLE_LARGELUN_
#define	 _ENABLE_LARGELUN_		
#endif

#ifdef HP_NT50				          // Compaq Hot Plug support NT4 only
	#undef	HP_PCI_HOT_PLUG		
#else
	#define	HP_PCI_HOT_PLUG		
#endif

#ifndef UNDEF_YAM2_1
#define	YAM2_1
#endif

// #define _DEBUG_READ_REGISTRY_
// #define _DEBUG_EVENTLOG_


#ifndef UNDEF_ENABLE_PSEUDO_DEVICE_
#define _ENABLE_PSEUDO_DEVICE_		     /* reserve Bus 4 TID 0 Lun 0 for IOCTL */
#endif

//#define UNDEF_FCCI_SUPPORT
#ifndef UNDEF_FCCI_SUPPORT
#define _FCCI_SUPPORT				     /* Enable Transoft IOCTL */
#endif


//#define UNDEF_SAN_IOCTL_
#ifndef UNDEF_SAN_IOCTL_
#define	_SAN_IOCTL_					/* Enable Agilent Technologies SNIA Ioctl support */
#endif

/* Add FCLayer switches here */
#ifndef _AGILENT_HBA 
#ifndef _ADAPTEC_HBA 
#define _GENERIC_HBA			/* r35 and up requires this 
								/* or #define _ADAPTEC_HBA
								/* or #define _AGILENT_HBA		
								*/
#endif
#endif


/** DEBUG Options **/
#define DOUBLE_BUFFER_CRASHDUMP         /* Used to enable Double Buffering during Dump writes */

//#define _Partial_Log_Debug_String_	/* enable to print out FCLayer debug messages */

#if DBG > 0
//#define _DEBUG_STALL_ISSUE_             /* Used to debug Stall issue only of I386*/
#endif

#ifdef YAM2_1
#if DBG > 0
#define     DBGPRINT_IO			          // enable to dbgpriunt IOs
#define     _DEBUG_REPORT_LUNS_
#define     _DEBUG_SCSIPORT_NOTIFICATION_		// enable to debug ScsiPortNotification
#endif
#endif

// #define _DEBUG_PERR_				     /* Debug Parity Error Issue */

//#define _DEBUG_LOSE_IOS_				// enable to simulate loosing IOs

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\advansys\asc3550\a_qswap.h ===
/*
 * Copyright (c) 1994-1998 Advanced System Products, Inc.
 * All Rights Reserved.
 *
 * Original object file: QSWAP.OAS
 * Converted C file: A_QSWAP.H
 * Date: 08-11-1998
 * Time: 16:14:43.51
 */

unsigned char _adv_mcode_buf[] = {
  0x9C,  0xF0,  0x80,  0x01,  0x00,  0xF0,  0x34,  0x0A,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x72,  0x01,  0xBA,  0x11,  0x00,  0x00,  0x70,  0x01,
  0x30,  0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x0B,  0x11,  0x33,  0x03,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x48,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,  0x01,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x78,  0x56,  0x34,  0x12,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
  0x00,  0x00,  0x04,  0xF7,  0x70,  0x01,  0x0C,  0x1C,  0x06,  0xF7,  0x02,  0x00,  0x00,  0xF2,  0xC6,  0x0A,
  0x04,  0xF7,  0x70,  0x01,  0x06,  0xF7,  0x02,  0x00,  0x3E,  0x57,  0x3C,  0x56,  0x0C,  0x1C,  0x00,  0xFC,
  0xA6,  0x00,  0x01,  0x58,  0xAA,  0x13,  0x20,  0xF0,  0xA2,  0x03,  0x06,  0xEC,  0xB9,  0x00,  0x0E,  0x47,
  0x03,  0xE6,  0x10,  0x00,  0xCE,  0x45,  0x02,  0x13,  0x3E,  0x57,  0x06,  0xEA,  0xB9,  0x00,  0x47,  0x4B,
  0x03,  0xF6,  0xE0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x01,  0x48,  0x4E,  0x12,  0x03,  0xF6,  0xC0,  0x00,
  0x00,  0xF2,  0x58,  0x0A,  0x41,  0x58,  0x03,  0xF6,  0xD0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x49,  0x44,
  0x59,  0xF0,  0x0A,  0x02,  0x03,  0xF6,  0xE0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x44,  0x58,  0x00,  0xF2,
  0xB6,  0x0D,  0x02,  0xCC,  0x4A,  0xE4,  0x01,  0x00,  0x55,  0xF0,  0x08,  0x03,  0x45,  0xF4,  0x02,  0x00,
  0x83,  0x5A,  0x04,  0xCC,  0x01,  0x4A,  0x12,  0x12,  0x00,  0xF2,  0xB6,  0x0D,  0x00,  0xCD,  0x48,  0xE4,
  0x01,  0x00,  0xE9,  0x13,  0x00,  0xF2,  0x9A,  0x0F,  0xFA,  0x10,  0x0E,  0x47,  0x03,  0xE6,  0x10,  0x00,
  0xCE,  0x45,  0x02,  0x13,  0x3E,  0x57,  0xCE,  0x47,  0x97,  0x13,  0x04,  0xEC,  0xB4,  0x00,  0x00,  0xF2,
  0xB6,  0x0D,  0x00,  0xCD,  0x48,  0xE4,  0x00,  0x00,  0x12,  0x12,  0x3E,  0x57,  0x06,  0xCC,  0x45,  0xF4,
  0x02,  0x00,  0x83,  0x5A,  0x00,  0xCC,  0x00,  0xEA,  0xB4,  0x00,  0x92,  0x10,  0x00,  0xF0,  0x8C,  0x01,
  0x43,  0xF0,  0x5C,  0x02,  0x44,  0xF0,  0x60,  0x02,  0x45,  0xF0,  0x64,  0x02,  0x46,  0xF0,  0x68,  0x02,
  0x47,  0xF0,  0x6E,  0x02,  0x48,  0xF0,  0x9E,  0x02,  0xB9,  0x54,  0x62,  0x10,  0x00,  0x1C,  0x5A,  0x10,
  0x02,  0x1C,  0x56,  0x10,  0x1E,  0x1C,  0x52,  0x10,  0x00,  0xF2,  0xF4,  0x10,  0x50,  0x10,  0x06,  0xFC,
  0xA8,  0x00,  0x03,  0xF6,  0xBE,  0x00,  0x00,  0xF2,  0x3E,  0x0A,  0x8C,  0x10,  0x01,  0xF6,  0x01,  0x00,
  0x01,  0xFA,  0xA8,  0x00,  0x00,  0xF2,  0x1C,  0x0B,  0x06,  0x10,  0xB9,  0x54,  0x01,  0xFA,  0xA8,  0x00,
  0x03,  0xF6,  0xBE,  0x00,  0x00,  0xF2,  0x48,  0x0A,  0x01,  0xFC,  0xA8,  0x00,  0x20,  0x10,  0x58,  0x1C,
  0x00,  0xF2,  0x0C,  0x0B,  0x5A,  0x1C,  0x01,  0xF6,  0x01,  0x00,  0x38,  0x54,  0x00,  0xFA,  0xA6,  0x00,
  0x01,  0xFA,  0xA8,  0x00,  0x20,  0x1C,  0x00,  0xF0,  0x72,  0x01,  0x01,  0xF6,  0x01,  0x00,  0x38,  0x54,
  0x00,  0xFA,  0xA6,  0x00,  0x01,  0xFA,  0xA8,  0x00,  0x20,  0x1C,  0x00,  0xF0,  0x80,  0x01,  0x03,  0xF6,
  0xE0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x01,  0x48,  0x0A,  0x13,  0x00,  0xF2,  0x0C,  0x10,  0x00,  0xF2,
  0x28,  0x0F,  0x24,  0x10,  0x03,  0xF6,  0xC0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x02,  0xF6,  0xD0,  0x00,
  0x02,  0x57,  0x03,  0x59,  0x01,  0xCC,  0x49,  0x44,  0x5B,  0xF0,  0x04,  0x03,  0x00,  0xF2,  0x70,  0x0F,
  0x00,  0xF0,  0x80,  0x01,  0x00,  0xF2,  0xE8,  0x0F,  0x0C,  0x1C,  0x02,  0x4B,  0xBF,  0x57,  0x9E,  0x43,
  0x77,  0x57,  0x07,  0x4B,  0x20,  0xF0,  0xA2,  0x03,  0x40,  0x1C,  0x1E,  0xF0,  0x30,  0x03,  0x26,  0xF0,
  0x2C,  0x03,  0xA0,  0xF0,  0x1A,  0x03,  0x11,  0xF0,  0xA2,  0x03,  0x12,  0x10,  0x9F,  0xF0,  0x3E,  0x03,
  0x46,  0x1C,  0x82,  0xE7,  0x05,  0x00,  0x9E,  0xE7,  0x11,  0x00,  0x00,  0xF0,  0xF6,  0x09,  0x0C,  0x1C,
  0x48,  0x1C,  0x46,  0x1C,  0x38,  0x54,  0x00,  0xEC,  0xBA,  0x00,  0x08,  0x44,  0x00,  0xEA,  0xBA,  0x00,
  0x03,  0xF6,  0xC0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x08,  0x44,  0x00,  0x4C,  0x82,  0xE7,  0x02,  0x00,
  0x00,  0xF2,  0xAC,  0x11,  0xB1,  0xF0,  0x64,  0x03,  0x85,  0xF0,  0x70,  0x03,  0x00,  0xF2,  0x50,  0x0B,
  0x06,  0xF0,  0x80,  0x03,  0x09,  0xF0,  0x14,  0x09,  0x1E,  0xF0,  0xEC,  0x09,  0x00,  0xF0,  0xF2,  0x09,
  0x00,  0xFC,  0xBE,  0x00,  0x98,  0x57,  0x55,  0xF0,  0xA0,  0x04,  0x01,  0xE6,  0x0C,  0x00,  0x00,  0xF2,
  0x20,  0x0D,  0x00,  0xF2,  0x92,  0x11,  0x00,  0xF2,  0x9E,  0x11,  0x01,  0xF0,  0x7C,  0x02,  0x00,  0xF0,
  0x8A,  0x02,  0x46,  0x1C,  0x0C,  0x1C,  0x67,  0x1B,  0xBF,  0x57,  0x77,  0x57,  0x02,  0x4B,  0x48,  0x1C,
  0x32,  0x1C,  0x00,  0xF2,  0x66,  0x0D,  0x30,  0x1C,  0x96,  0xF0,  0xB8,  0x03,  0xB1,  0xF0,  0xBC,  0x03,
  0x1E,  0xF0,  0xEC,  0x09,  0x85,  0xF0,  0xF2,  0x09,  0x00,  0xFC,  0xBE,  0x00,  0x98,  0x57,  0x10,  0x12,
  0x01,  0xE6,  0x0C,  0x00,  0x00,  0xF2,  0x20,  0x0D,  0x01,  0xF0,  0x7C,  0x02,  0x00,  0xF0,  0x8A,  0x02,
  0x03,  0xF6,  0xE0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x01,  0x48,  0x55,  0xF0,  0x8C,  0x04,  0x03,  0x82,
  0x03,  0xFC,  0xA0,  0x00,  0x9B,  0x57,  0x40,  0x12,  0x69,  0x08,  0x00,  0xF2,  0xE6,  0x10,  0x85,  0xF0,
  0x3A,  0x04,  0x69,  0x08,  0x00,  0xF2,  0xE6,  0x10,  0x85,  0xF0,  0xF2,  0x09,  0x68,  0x08,  0x4C,  0x44,
  0x28,  0x12,  0x44,  0x48,  0x03,  0xF6,  0xE0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x45,  0x58,  0x00,  0xF2,
  0xCA,  0x0D,  0x00,  0xCC,  0x01,  0x48,  0x55,  0xF0,  0x8C,  0x04,  0x4C,  0x44,  0xEF,  0x13,  0x00,  0xF2,
  0x9A,  0x0F,  0x00,  0xF2,  0xE8,  0x0F,  0x08,  0x10,  0x68,  0x08,  0x45,  0x5A,  0x00,  0xF2,  0xCA,  0x0D,
  0x04,  0x80,  0x18,  0xE4,  0x10,  0x00,  0x24,  0x12,  0x01,  0xE6,  0x06,  0x00,  0x04,  0x80,  0x18,  0xE4,
  0x01,  0x00,  0x04,  0x12,  0x01,  0xE6,  0x0D,  0x00,  0x00,  0xF2,  0x20,  0x0D,  0x04,  0xE6,  0x02,  0x00,
  0x9E,  0xE7,  0x15,  0x00,  0x01,  0xF0,  0x0C,  0x0A,  0x00,  0xF0,  0xF2,  0x09,  0x3E,  0x1C,  0x05,  0x80,
  0x48,  0xE4,  0x00,  0x00,  0x0C,  0x12,  0x00,  0xE6,  0x11,  0x00,  0x00,  0xEA,  0xB8,  0x00,  0x00,  0xF2,
  0x8A,  0x10,  0x82,  0xE7,  0x02,  0x00,  0x1C,  0x90,  0x40,  0x5C,  0x00,  0x16,  0x01,  0xE6,  0x06,  0x00,
  0x00,  0xF2,  0x20,  0x0D,  0x01,  0xF0,  0x80,  0x01,  0x1E,  0xF0,  0x80,  0x01,  0x00,  0xF0,  0x94,  0x04,
  0x42,  0x5B,  0x06,  0xF7,  0x03,  0x00,  0x46,  0x59,  0xBF,  0x57,  0x77,  0x57,  0x01,  0xE6,  0x80,  0x00,
  0x07,  0x80,  0x31,  0x44,  0x04,  0x80,  0x18,  0xE4,  0x20,  0x00,  0x56,  0x13,  0x20,  0x80,  0x48,  0xE4,
  0x03,  0x00,  0x4E,  0x12,  0x00,  0xFC,  0xA2,  0x00,  0x98,  0x57,  0x55,  0xF0,  0x10,  0x05,  0x31,  0xE4,
  0x40,  0x00,  0x00,  0xFC,  0xA0,  0x00,  0x98,  0x57,  0x36,  0x12,  0x4C,  0x1C,  0xB1,  0xF0,  0xDC,  0x04,
  0x89,  0x48,  0x00,  0xF2,  0xE6,  0x10,  0x86,  0xF0,  0x22,  0x05,  0x82,  0xE7,  0x06,  0x00,  0x1B,  0x80,
  0x48,  0xE4,  0x22,  0x00,  0x5B,  0xF0,  0x00,  0x05,  0x48,  0xE4,  0x20,  0x00,  0x59,  0xF0,  0x04,  0x05,
  0x00,  0xE6,  0x20,  0x00,  0x09,  0x48,  0x00,  0xF2,  0xE6,  0x10,  0x86,  0xF0,  0x22,  0x05,  0x83,  0x80,
  0x04,  0x10,  0x00,  0xF2,  0x76,  0x0D,  0x00,  0xE6,  0x01,  0x00,  0x00,  0xEA,  0x26,  0x01,  0x01,  0xEA,
  0x27,  0x01,  0x04,  0x80,  0x18,  0xE4,  0x10,  0x00,  0x32,  0x12,  0xB9,  0x54,  0x00,  0xF2,  0xCA,  0x0E,
  0x01,  0xE6,  0x06,  0x00,  0x04,  0x80,  0x18,  0xE4,  0x01,  0x00,  0x04,  0x12,  0x01,  0xE6,  0x0D,  0x00,
  0x00,  0xF2,  0x20,  0x0D,  0x00,  0xF2,  0x92,  0x11,  0x00,  0xF2,  0x9E,  0x11,  0x04,  0xE6,  0x02,  0x00,
  0x9E,  0xE7,  0x15,  0x00,  0x01,  0xF0,  0x0C,  0x0A,  0x00,  0xF0,  0xF2,  0x09,  0x00,  0xFC,  0x20,  0x01,
  0x98,  0x57,  0x34,  0x12,  0x00,  0xFC,  0x24,  0x01,  0x98,  0x57,  0x2C,  0x13,  0xB9,  0x54,  0x00,  0xF2,
  0xCA,  0x0E,  0x86,  0xF0,  0x98,  0x05,  0x03,  0xF6,  0x01,  0x00,  0x00,  0xF2,  0x60,  0x0E,  0x85,  0xF0,
  0x8E,  0x05,  0x82,  0xE7,  0x03,  0x00,  0x00,  0xF2,  0x50,  0x0B,  0x82,  0xE7,  0x02,  0x00,  0x00,  0xFC,
  0x24,  0x01,  0xB0,  0x57,  0x00,  0xFA,  0x24,  0x01,  0x00,  0xFC,  0x9E,  0x00,  0x98,  0x57,  0x5A,  0x12,
  0x00,  0xFC,  0xB6,  0x00,  0x98,  0x57,  0x52,  0x13,  0x03,  0xE6,  0x0C,  0x00,  0x00,  0xFC,  0x9C,  0x00,
  0x98,  0x57,  0x04,  0x13,  0x03,  0xE6,  0x19,  0x00,  0x05,  0xE6,  0x08,  0x00,  0x00,  0xF6,  0x00,  0x01,
  0x00,  0x57,  0x00,  0x57,  0x03,  0x58,  0x00,  0xDC,  0x18,  0xF4,  0x00,  0x80,  0x04,  0x13,  0x05,  0xE6,
  0x0F,  0x00,  0xB9,  0x54,  0x00,  0xF2,  0xCA,  0x0E,  0x86,  0xF0,  0xFA,  0x05,  0x00,  0xF2,  0x8E,  0x0E,
  0x85,  0xF0,  0xF0,  0x05,  0x82,  0xE7,  0x03,  0x00,  0x00,  0xF2,  0x50,  0x0B,  0x82,  0xE7,  0x02,  0x00,
  0x00,  0xFC,  0xB6,  0x00,  0xB0,  0x57,  0x00,  0xFA,  0xB6,  0x00,  0x01,  0xF6,  0x01,  0x00,  0x00,  0xF2,
  0xCA,  0x0E,  0x9C,  0x32,  0x4E,  0x1C,  0x32,  0x1C,  0x00,  0xF2,  0x66,  0x0D,  0x30,  0x1C,  0x82,  0xE7,
  0x04,  0x00,  0xB1,  0xF0,  0x12,  0x06,  0x0A,  0xF0,  0x2E,  0x06,  0x05,  0xF0,  0xC6,  0x06,  0x06,  0xF0,
  0xCC,  0x06,  0x09,  0xF0,  0x14,  0x09,  0x1E,  0xF0,  0xEC,  0x09,  0x00,  0xF0,  0xF2,  0x09,  0x04,  0x80,
  0x18,  0xE4,  0x20,  0x00,  0x30,  0x12,  0x09,  0xE7,  0x03,  0x00,  0x00,  0xF2,  0xE6,  0x10,  0x21,  0x80,
  0x18,  0xE4,  0xE0,  0x00,  0x09,  0x48,  0x00,  0xF2,  0xE6,  0x10,  0x09,  0xE7,  0x00,  0x00,  0x00,  0xF2,
  0xE6,  0x10,  0x09,  0xE7,  0x00,  0x00,  0x00,  0xF2,  0xE6,  0x10,  0x99,  0xA4,  0x00,  0xF2,  0xE6,  0x10,
  0x09,  0xE7,  0x00,  0x00,  0x9A,  0x10,  0x04,  0x80,  0x18,  0xE4,  0x02,  0x00,  0x34,  0x12,  0x09,  0xE7,
  0x1B,  0x00,  0x00,  0xF2,  0xE6,  0x10,  0x21,  0x80,  0x18,  0xE4,  0xE0,  0x00,  0x09,  0x48,  0x00,  0xF2,
  0xE6,  0x10,  0x09,  0xE7,  0x00,  0x00,  0x00,  0xF2,  0xE6,  0x10,  0x09,  0xE7,  0x00,  0x00,  0x00,  0xF2,
  0xE6,  0x10,  0x09,  0xE7,  0x01,  0x00,  0x00,  0xF2,  0xE6,  0x10,  0x09,  0xE7,  0x00,  0x00,  0x00,  0xF0,
  0xFC,  0x08,  0xBB,  0x55,  0x9A,  0x81,  0x03,  0xF7,  0x20,  0x00,  0x09,  0x6F,  0x93,  0x45,  0x55,  0xF0,
  0xD2,  0x06,  0xB1,  0xF0,  0xB2,  0x06,  0x0A,  0xF0,  0xAA,  0x06,  0x09,  0xF0,  0x14,  0x09,  0x1E,  0xF0,
  0xEC,  0x09,  0x00,  0xF0,  0xF2,  0x09,  0x00,  0xF2,  0x50,  0x0B,  0x47,  0x10,  0x09,  0xE7,  0x08,  0x00,
  0x41,  0x10,  0x05,  0x80,  0x48,  0xE4,  0x00,  0x00,  0x1E,  0x12,  0x00,  0xE6,  0x11,  0x00,  0x00,  0xEA,
  0xB8,  0x00,  0x00,  0xF2,  0x8A,  0x10,  0x2C,  0x90,  0xAE,  0x90,  0x08,  0x50,  0x8A,  0x50,  0x38,  0x54,
  0x1F,  0x40,  0x00,  0xF2,  0x88,  0x0D,  0x08,  0x10,  0x08,  0x90,  0x8A,  0x90,  0x30,  0x50,  0xB2,  0x50,
  0x9C,  0x32,  0x0C,  0x92,  0x8E,  0x92,  0x38,  0x54,  0x04,  0x80,  0x30,  0xE4,  0x08,  0x00,  0x04,  0x40,
  0x0C,  0x1C,  0x00,  0xF6,  0x05,  0x00,  0xB1,  0xF0,  0x16,  0x07,  0x9E,  0xF0,  0x2A,  0x07,  0x01,  0x48,
  0x55,  0xF0,  0xEC,  0x09,  0x0C,  0x1C,  0x10,  0x44,  0xED,  0x10,  0x0B,  0xF0,  0x4E,  0x07,  0x0C,  0xF0,
  0x52,  0x07,  0x05,  0xF0,  0x42,  0x07,  0x06,  0xF0,  0x48,  0x07,  0x09,  0xF0,  0x14,  0x09,  0x00,  0xF0,
  0xF2,  0x09,  0x00,  0xF2,  0x50,  0x0B,  0xCF,  0x10,  0x09,  0xE7,  0x08,  0x00,  0xC9,  0x10,  0x2E,  0x1C,
  0x02,  0x10,  0x2C,  0x1C,  0xAA,  0xF0,  0x54,  0x07,  0xAC,  0xF0,  0x62,  0x07,  0x40,  0x10,  0x34,  0x1C,
  0xF3,  0x10,  0xAD,  0xF0,  0x6C,  0x07,  0xC8,  0x10,  0x36,  0x1C,  0xE9,  0x10,  0x2B,  0xF0,  0x72,  0x08,
  0x6B,  0x18,  0x18,  0xF4,  0x00,  0xFE,  0x20,  0x12,  0x01,  0x58,  0xD2,  0xF0,  0x72,  0x08,  0x76,  0x18,
  0x18,  0xF4,  0x03,  0x00,  0xEC,  0x12,  0x00,  0xFC,  0x22,  0x01,  0x18,  0xF4,  0x01,  0x00,  0xE2,  0x12,
  0x0B,  0xF0,  0x54,  0x07,  0x0C,  0xF0,  0x54,  0x07,  0x36,  0x1C,  0x34,  0x1C,  0xB7,  0x10,  0x38,  0x54,
  0xB9,  0x54,  0x84,  0x80,  0x19,  0xE4,  0x20,  0x00,  0xB2,  0x13,  0x85,  0x80,  0x81,  0x48,  0x66,  0x12,
  0x04,  0x80,  0x18,  0xE4,  0x08,  0x00,  0x58,  0x13,  0x1F,  0x80,  0x08,  0x44,  0xC8,  0x44,  0x9F,  0x12,
  0x1F,  0x40,  0x34,  0x91,  0xB6,  0x91,  0x44,  0x55,  0xE5,  0x55,  0x02,  0xEC,  0xB8,  0x00,  0x02,  0x49,
  0xBB,  0x55,  0x82,  0x81,  0xC0,  0x55,  0x48,  0xF4,  0x0F,  0x00,  0x5A,  0xF0,  0x0A,  0x08,  0x4A,  0xE4,
  0x17,  0x00,  0xD5,  0xF0,  0xEA,  0x07,  0x02,  0xF6,  0x0F,  0x00,  0x02,  0xF4,  0x02,  0x00,  0x02,  0xEA,
  0xB8,  0x00,  0x04,  0x91,  0x86,  0x91,  0x02,  0x4B,  0x2C,  0x90,  0x08,  0x50,  0x2E,  0x90,  0x0A,  0x50,
  0x2C,  0x51,  0xAE,  0x51,  0x00,  0xF2,  0x8A,  0x10,  0x38,  0x54,  0x00,  0xF2,  0x88,  0x0D,  0x56,  0x10,
  0x34,  0x91,  0xB6,  0x91,  0x0C,  0x10,  0x04,  0x80,  0x18,  0xE4,  0x08,  0x00,  0x41,  0x12,  0x0C,  0x91,
  0x8E,  0x91,  0x04,  0x80,  0x18,  0xE4,  0xF7,  0x00,  0x04,  0x40,  0x30,  0x90,  0xB2,  0x90,  0x36,  0x10,
  0x02,  0x80,  0x48,  0xE4,  0x10,  0x00,  0x31,  0x12,  0x82,  0xE7,  0x10,  0x00,  0x84,  0x80,  0x19,  0xE4,
  0x20,  0x00,  0x10,  0x13,  0x0C,  0x90,  0x8E,  0x90,  0x5D,  0xF0,  0x68,  0x07,  0x0C,  0x58,  0x8D,  0x58,
  0x00,  0xF0,  0x54,  0x07,  0x38,  0x54,  0xB9,  0x54,  0x19,  0x80,  0xF1,  0x10,  0x3A,  0x55,  0x19,  0x81,
  0xBB,  0x55,  0x10,  0x90,  0x92,  0x90,  0x10,  0x58,  0x91,  0x58,  0x14,  0x59,  0x95,  0x59,  0x00,  0xF0,
  0x54,  0x07,  0x04,  0x80,  0x18,  0xE4,  0x20,  0x00,  0x06,  0x12,  0x6C,  0x19,  0x19,  0x41,  0x7C,  0x10,
  0x6C,  0x19,  0x0C,  0x51,  0xED,  0x19,  0x8E,  0x51,  0x6B,  0x18,  0x18,  0xF4,  0x00,  0xFF,  0x02,  0x13,
  0x6A,  0x10,  0x01,  0x58,  0xD2,  0xF0,  0xB0,  0x08,  0x76,  0x18,  0x18,  0xF4,  0x03,  0x00,  0x0A,  0x12,
  0x00,  0xFC,  0x22,  0x01,  0x18,  0xF4,  0x01,  0x00,  0x06,  0x13,  0x9E,  0xE7,  0x16,  0x00,  0x4C,  0x10,
  0xD1,  0xF0,  0xBA,  0x08,  0x9E,  0xE7,  0x17,  0x00,  0x42,  0x10,  0xD0,  0xF0,  0xC4,  0x08,  0x9E,  0xE7,
  0x19,  0x00,  0x38,  0x10,  0xCF,  0xF0,  0xCE,  0x08,  0x9E,  0xE7,  0x20,  0x00,  0x2E,  0x10,  0xCE,  0xF0,
  0xD8,  0x08,  0x9E,  0xE7,  0x21,  0x00,  0x24,  0x10,  0xCD,  0xF0,  0xE2,  0x08,  0x9E,  0xE7,  0x22,  0x00,
  0x1A,  0x10,  0xCC,  0xF0,  0xF4,  0x08,  0x84,  0x80,  0x19,  0xE4,  0x04,  0x00,  0x06,  0x12,  0x9E,  0xE7,
  0x12,  0x00,  0x08,  0x10,  0xCB,  0xF0,  0xFC,  0x08,  0x9E,  0xE7,  0x24,  0x00,  0xB1,  0xF0,  0xFC,  0x08,
  0x05,  0xF0,  0x0E,  0x09,  0x09,  0xF0,  0x14,  0x09,  0x1E,  0xF0,  0xEC,  0x09,  0xE4,  0x10,  0x00,  0xF2,
  0x50,  0x0B,  0xE9,  0x10,  0x9C,  0x32,  0x82,  0xE7,  0x20,  0x00,  0x32,  0x1C,  0xE9,  0x09,  0x00,  0xF2,
  0xE6,  0x10,  0x85,  0xF0,  0xF2,  0x09,  0x69,  0x08,  0x01,  0xF0,  0x34,  0x09,  0x1E,  0xF0,  0xEC,  0x09,
  0x00,  0xF0,  0x28,  0x09,  0x30,  0x44,  0x06,  0x12,  0x9E,  0xE7,  0x42,  0x00,  0xB8,  0x10,  0x04,  0xF6,
  0x01,  0x00,  0xB3,  0x45,  0x74,  0x12,  0x04,  0x80,  0x18,  0xE4,  0x20,  0x00,  0x22,  0x13,  0x4B,  0xE4,
  0x02,  0x00,  0x36,  0x12,  0x4B,  0xE4,  0x28,  0x00,  0xAC,  0x13,  0x00,  0xF2,  0x92,  0x11,  0x00,  0xF2,
  0x9E,  0x11,  0x03,  0xF6,  0xD0,  0x00,  0xFA,  0x14,  0x82,  0xE7,  0x01,  0x00,  0x00,  0xF0,  0x80,  0x01,
  0x9E,  0xE7,  0x44,  0x00,  0x4B,  0xE4,  0x02,  0x00,  0x06,  0x12,  0x03,  0xE6,  0x02,  0x00,  0x76,  0x10,
  0x00,  0xF2,  0x76,  0x0D,  0x03,  0xE6,  0x02,  0x00,  0x6C,  0x10,  0x00,  0xF2,  0x76,  0x0D,  0x19,  0x82,
  0x34,  0x46,  0x0A,  0x13,  0x03,  0xE6,  0x02,  0x00,  0x9E,  0xE7,  0x43,  0x00,  0x68,  0x10,  0x04,  0x80,
  0x30,  0xE4,  0x20,  0x00,  0x04,  0x40,  0x00,  0xF2,  0x92,  0x11,  0x00,  0xF2,  0x9E,  0x11,  0x82,  0xE7,
  0x01,  0x00,  0x06,  0xF7,  0x02,  0x00,  0x00,  0xF0,  0x08,  0x03,  0x04,  0x80,  0x18,  0xE4,  0x20,  0x00,
  0x06,  0x12,  0x03,  0xE6,  0x02,  0x00,  0x3E,  0x10,  0x04,  0x80,  0x18,  0xE4,  0x02,  0x00,  0x3A,  0x12,
  0x04,  0x80,  0x18,  0xE4,  0xFD,  0x00,  0x04,  0x40,  0x1C,  0x1C,  0x9D,  0xF0,  0xDA,  0x09,  0x1C,  0x1C,
  0x9D,  0xF0,  0xE0,  0x09,  0xC1,  0x10,  0x9E,  0xE7,  0x13,  0x00,  0x0A,  0x10,  0x9E,  0xE7,  0x41,  0x00,
  0x04,  0x10,  0x9E,  0xE7,  0x24,  0x00,  0x00,  0xFC,  0xBE,  0x00,  0x98,  0x57,  0xD5,  0xF0,  0x8A,  0x02,
  0x04,  0xE6,  0x04,  0x00,  0x06,  0x10,  0x04,  0xE6,  0x04,  0x00,  0x9D,  0x41,  0x1C,  0x42,  0x9F,  0xE7,
  0x00,  0x00,  0x06,  0xF7,  0x02,  0x00,  0x03,  0xF6,  0xE0,  0x00,  0x3C,  0x14,  0x44,  0x58,  0x45,  0x58,
  0x00,  0xF2,  0xCA,  0x0D,  0x00,  0xF2,  0x52,  0x10,  0x00,  0xF2,  0x9A,  0x0F,  0x3C,  0x14,  0x1E,  0x1C,
  0x00,  0xF0,  0x80,  0x01,  0x12,  0x1C,  0x22,  0x1C,  0xD2,  0x14,  0x00,  0xF0,  0x72,  0x01,  0x83,  0x59,
  0x03,  0xDC,  0x73,  0x57,  0x80,  0x5D,  0x00,  0x16,  0x83,  0x59,  0x03,  0xDC,  0x38,  0x54,  0x70,  0x57,
  0x33,  0x54,  0x3B,  0x54,  0x80,  0x5D,  0x00,  0x16,  0x03,  0x57,  0x83,  0x59,  0x38,  0x54,  0x00,  0xCC,
  0x00,  0x16,  0x03,  0x57,  0x83,  0x59,  0x00,  0x4C,  0x00,  0x16,  0x02,  0x80,  0x48,  0xE4,  0x01,  0x00,
  0x0E,  0x12,  0x48,  0xE4,  0x05,  0x00,  0x08,  0x12,  0x00,  0xF2,  0x92,  0x11,  0x00,  0xF2,  0x9E,  0x11,
  0xC1,  0x5A,  0x3A,  0x55,  0x02,  0xEC,  0xB5,  0x00,  0x45,  0x59,  0x00,  0xF2,  0xCA,  0x0D,  0x83,  0x58,
  0x30,  0xE7,  0x00,  0x00,  0x10,  0x4D,  0x30,  0xE7,  0x40,  0x00,  0x10,  0x4F,  0x38,  0x90,  0xBA,  0x90,
  0x10,  0x5C,  0x80,  0x5C,  0x83,  0x5A,  0x10,  0x4E,  0x04,  0xEA,  0xB5,  0x00,  0x43,  0x5B,  0x03,  0xF4,
  0xE0,  0x00,  0x83,  0x59,  0x04,  0xCC,  0x01,  0x4A,  0x0A,  0x12,  0x45,  0x5A,  0x00,  0xF2,  0xCA,  0x0D,
  0x00,  0xF2,  0x0C,  0x10,  0x00,  0x16,  0x08,  0x1C,  0x00,  0xFC,  0xAC,  0x00,  0x06,  0x58,  0x67,  0x18,
  0x18,  0xF4,  0x8F,  0xE1,  0x01,  0xFC,  0xAE,  0x00,  0x19,  0xF4,  0x70,  0x1E,  0xB0,  0x54,  0x07,  0x58,
  0x00,  0xFC,  0xB0,  0x00,  0x08,  0x58,  0x00,  0xFC,  0xB2,  0x00,  0x09,  0x58,  0x0A,  0x1C,  0x00,  0xE6,
  0x0F,  0x00,  0x00,  0xEA,  0xB9,  0x00,  0x38,  0x54,  0x00,  0xFA,  0x24,  0x01,  0x00,  0xFA,  0xB6,  0x00,
  0x18,  0x1C,  0x14,  0x1C,  0x10,  0x1C,  0x32,  0x1C,  0x12,  0x1C,  0x00,  0x16,  0x3E,  0x57,  0x0C,  0x14,
  0x0E,  0x47,  0x07,  0xE6,  0x10,  0x00,  0xCE,  0x47,  0xF5,  0x13,  0x00,  0x16,  0x00,  0xF2,  0x76,  0x0D,
  0x02,  0x4B,  0x03,  0xF6,  0xE0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x01,  0x48,  0x20,  0x12,  0x44,  0x58,
  0x45,  0x58,  0x9E,  0xE7,  0x15,  0x00,  0x9C,  0xE7,  0x04,  0x00,  0x00,  0xF2,  0xCA,  0x0D,  0x00,  0xF2,
  0x52,  0x10,  0x00,  0xF2,  0x9A,  0x0F,  0x00,  0xF2,  0x6A,  0x0A,  0x1E,  0x1C,  0xD5,  0x10,  0x00,  0x16,
  0x68,  0x08,  0x48,  0xE4,  0x04,  0x00,  0x3E,  0x12,  0x48,  0xE4,  0x02,  0x00,  0x22,  0x12,  0x48,  0xE4,
  0x03,  0x00,  0x1C,  0x12,  0x48,  0xE4,  0x08,  0x00,  0x16,  0x12,  0x48,  0xE4,  0x01,  0x00,  0xCC,  0x12,
  0x48,  0xE4,  0x07,  0x00,  0x16,  0x12,  0x01,  0xE6,  0x07,  0x00,  0x00,  0xF2,  0x20,  0x0D,  0x02,  0x10,
  0x3E,  0x1C,  0x00,  0xF2,  0xE6,  0x10,  0x05,  0xF0,  0x50,  0x0B,  0x00,  0x16,  0x00,  0xE6,  0x01,  0x00,
  0x00,  0xEA,  0x99,  0x00,  0xEB,  0x10,  0x3E,  0x1C,  0x02,  0x80,  0x48,  0xE4,  0x10,  0x00,  0x1C,  0x12,
  0x82,  0xE7,  0x08,  0x00,  0x3C,  0x56,  0x03,  0x82,  0x00,  0xF2,  0xB6,  0x0D,  0x30,  0xE7,  0x08,  0x00,
  0x04,  0xF7,  0x70,  0x01,  0x06,  0xF7,  0x02,  0x00,  0x00,  0xF0,  0x80,  0x01,  0x6C,  0x19,  0xED,  0x19,
  0x5D,  0xF0,  0xA0,  0x0B,  0x44,  0x55,  0xE5,  0x55,  0x59,  0xF0,  0x1E,  0x0C,  0x04,  0x55,  0xA5,  0x55,
  0x1F,  0x80,  0x01,  0xEC,  0xB8,  0x00,  0x82,  0x48,  0x82,  0x80,  0x49,  0x44,  0x2E,  0x13,  0x01,  0xEC,
  0xB8,  0x00,  0x41,  0xE4,  0x02,  0x00,  0x01,  0xEA,  0xB8,  0x00,  0x49,  0xE4,  0x11,  0x00,  0x59,  0xF0,
  0xFA,  0x0B,  0x01,  0xE6,  0x17,  0x00,  0x01,  0xEA,  0xB8,  0x00,  0x02,  0x4B,  0x88,  0x90,  0xAC,  0x50,
  0x8A,  0x90,  0xAE,  0x50,  0x01,  0xEC,  0xB8,  0x00,  0x82,  0x48,  0x82,  0x80,  0x10,  0x44,  0x02,  0x4B,
  0x1F,  0x40,  0xC0,  0x44,  0x00,  0xF2,  0x88,  0x0D,  0x04,  0x55,  0xA5,  0x55,  0x9F,  0x10,  0x0C,  0x51,
  0x8E,  0x51,  0x30,  0x90,  0xB2,  0x90,  0x00,  0x56,  0xA1,  0x56,  0x30,  0x50,  0xB2,  0x50,  0x34,  0x90,
  0xB6,  0x90,  0x40,  0x56,  0xE1,  0x56,  0x34,  0x50,  0xB6,  0x50,  0x65,  0x10,  0x3E,  0x1C,  0x00,  0xF2,
  0xE6,  0x10,  0x85,  0xF0,  0x8A,  0x0B,  0xE9,  0x09,  0x4B,  0xE4,  0x03,  0x00,  0x7E,  0x12,  0x4B,  0xE4,
  0x02,  0x00,  0x23,  0x13,  0xB1,  0xF0,  0x54,  0x0C,  0x85,  0xF0,  0x8A,  0x0B,  0x69,  0x08,  0x48,  0xE4,
  0x03,  0x00,  0xD5,  0xF0,  0x76,  0x0B,  0x00,  0xF2,  0xE6,  0x10,  0x85,  0xF0,  0x8A,  0x0B,  0xE8,  0x09,
  0x3C,  0x56,  0x00,  0xFC,  0x20,  0x01,  0x98,  0x57,  0x02,  0x13,  0xBB,  0x45,  0x4B,  0xE4,  0x00,  0x00,
  0x08,  0x12,  0x03,  0xE6,  0x01,  0x00,  0x04,  0xF6,  0x00,  0x80,  0xAE,  0x14,  0xD8,  0x14,  0x30,  0x1C,
  0x02,  0x80,  0x48,  0xE4,  0x03,  0x00,  0x16,  0x13,  0x00,  0xFC,  0x9E,  0x00,  0x98,  0x57,  0x0A,  0x12,
  0x00,  0xFC,  0xB6,  0x00,  0x98,  0x57,  0x02,  0x13,  0x4C,  0x1C,  0x00,  0xF0,  0x80,  0x0B,  0x00,  0xFC,
  0x24,  0x01,  0xB0,  0x57,  0x00,  0xFA,  0x24,  0x01,  0x4C,  0x1C,  0x3E,  0x1C,  0x00,  0xF2,  0xE6,  0x10,
  0x86,  0xF0,  0x82,  0x0B,  0x00,  0xF2,  0x60,  0x0E,  0x00,  0xF0,  0x82,  0x0B,  0xB1,  0xF0,  0xCC,  0x0C,
  0x85,  0xF0,  0x76,  0x0B,  0x69,  0x08,  0x48,  0xE4,  0x01,  0x00,  0xD5,  0xF0,  0x76,  0x0B,  0xFC,  0x14,
  0x42,  0x58,  0x6C,  0x14,  0x80,  0x14,  0x30,  0x1C,  0x4A,  0xF4,  0x02,  0x00,  0x55,  0xF0,  0x76,  0x0B,
  0x4A,  0xF4,  0x01,  0x00,  0x0C,  0x12,  0x02,  0x80,  0x48,  0xE4,  0x03,  0x00,  0x04,  0x13,  0x00,  0xF0,
  0x80,  0x0B,  0x00,  0xFC,  0xB6,  0x00,  0xB0,  0x57,  0x00,  0xFA,  0xB6,  0x00,  0x4C,  0x1C,  0x3E,  0x1C,
  0x00,  0xF2,  0xE6,  0x10,  0x86,  0xF0,  0x82,  0x0B,  0x00,  0xF2,  0x8E,  0x0E,  0x00,  0xF0,  0x82,  0x0B,
  0x86,  0xF0,  0x2C,  0x0D,  0x4E,  0x1C,  0x89,  0x48,  0x4E,  0x1C,  0x00,  0x16,  0x85,  0xF0,  0x28,  0x0D,
  0x4C,  0x1C,  0x3E,  0x1C,  0x00,  0xF2,  0xE6,  0x10,  0xE7,  0x10,  0x00,  0xF6,  0x00,  0x01,  0x00,  0x57,
  0x00,  0x57,  0x03,  0x58,  0x00,  0xDC,  0x18,  0xF4,  0xFF,  0x7F,  0x30,  0x56,  0x00,  0x5C,  0x00,  0x16,
  0x00,  0xF6,  0x00,  0x01,  0x00,  0x57,  0x00,  0x57,  0x03,  0x58,  0x00,  0xDC,  0x18,  0xF4,  0x00,  0x80,
  0x30,  0x56,  0x00,  0x5C,  0x00,  0x16,  0x00,  0xF6,  0x00,  0x01,  0x00,  0x57,  0x00,  0x57,  0x03,  0x58,
  0x00,  0xDC,  0x0B,  0x58,  0x00,  0x16,  0x03,  0xF6,  0x24,  0x01,  0x00,  0xF2,  0x48,  0x0A,  0x03,  0xF6,
  0xB6,  0x00,  0x00,  0xF2,  0x48,  0x0A,  0x00,  0x16,  0x02,  0xEC,  0xB8,  0x00,  0x02,  0x49,  0x18,  0xF4,
  0xFF,  0x00,  0x00,  0x54,  0x00,  0x54,  0x00,  0x54,  0x00,  0xF4,  0x08,  0x00,  0xE1,  0x18,  0x80,  0x54,
  0x03,  0x58,  0x00,  0xDD,  0x01,  0xDD,  0x02,  0xDD,  0x03,  0xDC,  0x02,  0x4B,  0x30,  0x50,  0xB2,  0x50,
  0x34,  0x51,  0xB6,  0x51,  0x00,  0x16,  0x45,  0x5A,  0x1D,  0xF4,  0xFF,  0x00,  0x85,  0x56,  0x85,  0x56,
  0x85,  0x56,  0x05,  0xF4,  0x02,  0x12,  0x83,  0x5A,  0x00,  0x16,  0x1D,  0xF4,  0xFF,  0x00,  0x85,  0x56,
  0x85,  0x56,  0x85,  0x56,  0x05,  0xF4,  0x00,  0x12,  0x83,  0x5A,  0x00,  0x16,  0x38,  0x54,  0xBB,  0x55,
  0x3C,  0x56,  0xBD,  0x56,  0x00,  0xF2,  0xE6,  0x10,  0x85,  0xF0,  0x56,  0x0E,  0xE9,  0x09,  0xC1,  0x59,
  0x00,  0xF2,  0xE6,  0x10,  0x85,  0xF0,  0x56,  0x0E,  0xE8,  0x0A,  0x83,  0x55,  0x83,  0x55,  0x4B,  0xF4,
  0x90,  0x01,  0x5C,  0xF0,  0x0A,  0x0E,  0xBD,  0x56,  0x40,  0x10,  0x4B,  0xF4,  0x30,  0x00,  0x59,  0xF0,
  0x1C,  0x0E,  0x01,  0xF6,  0x0C,  0x00,  0x00,  0xF6,  0x01,  0x00,  0x2E,  0x10,  0x02,  0xFC,  0x9C,  0x00,
  0x9A,  0x57,  0x14,  0x13,  0x4B,  0xF4,  0x64,  0x00,  0x59,  0xF0,  0x38,  0x0E,  0x03,  0xF6,  0x64,  0x00,
  0x01,  0xF6,  0x19,  0x00,  0x00,  0xF6,  0x01,  0x00,  0x43,  0xF4,  0x33,  0x00,  0x56,  0xF0,  0x4A,  0x0E,
  0x04,  0xF4,  0x00,  0x01,  0x43,  0xF4,  0x19,  0x00,  0xF3,  0x10,  0xB4,  0x56,  0xC3,  0x58,  0x02,  0xFC,
  0x9E,  0x00,  0x9A,  0x57,  0x08,  0x13,  0x3C,  0x56,  0x00,  0xF6,  0x02,  0x00,  0x00,  0x16,  0x00,  0x16,
  0x09,  0xE7,  0x01,  0x00,  0x00,  0xF2,  0xE6,  0x10,  0x86,  0xF0,  0x8C,  0x0E,  0x09,  0xE7,  0x02,  0x00,
  0x00,  0xF2,  0xE6,  0x10,  0x86,  0xF0,  0x8C,  0x0E,  0x09,  0xE7,  0x03,  0x00,  0x00,  0xF2,  0xE6,  0x10,
  0x86,  0xF0,  0x8C,  0x0E,  0x4E,  0x1C,  0x89,  0x49,  0x00,  0xF2,  0xE6,  0x10,  0x00,  0x16,  0x09,  0xE7,
  0x01,  0x00,  0x00,  0xF2,  0xE6,  0x10,  0x86,  0xF0,  0xC6,  0x0E,  0x09,  0xE7,  0x03,  0x00,  0x00,  0xF2,
  0xE6,  0x10,  0x86,  0xF0,  0xC6,  0x0E,  0x09,  0xE7,  0x01,  0x00,  0x00,  0xF2,  0xE6,  0x10,  0x86,  0xF0,
  0xC6,  0x0E,  0x89,  0x49,  0x00,  0xF2,  0xE6,  0x10,  0x86,  0xF0,  0xC6,  0x0E,  0x4E,  0x1C,  0x89,  0x4A,
  0x00,  0xF2,  0xE6,  0x10,  0x00,  0x16,  0x3C,  0x56,  0x00,  0x16,  0x00,  0xEC,  0x26,  0x01,  0x48,  0xE4,
  0x01,  0x00,  0x1E,  0x13,  0x38,  0x44,  0x00,  0xEA,  0x26,  0x01,  0x49,  0xF4,  0x00,  0x00,  0x04,  0x12,
  0x4E,  0x1C,  0x02,  0x10,  0x4C,  0x1C,  0x01,  0xEC,  0x27,  0x01,  0x89,  0x48,  0x00,  0xF2,  0xE6,  0x10,
  0x02,  0x14,  0x00,  0x16,  0x85,  0xF0,  0x26,  0x0F,  0x38,  0x54,  0x00,  0xEA,  0x99,  0x00,  0x00,  0xF2,
  0x50,  0x0B,  0x02,  0x80,  0x48,  0xE4,  0x06,  0x00,  0x1C,  0x13,  0x00,  0xEC,  0x99,  0x00,  0x48,  0xE4,
  0x01,  0x00,  0x0A,  0x12,  0x04,  0x80,  0x30,  0xE4,  0x01,  0x00,  0x04,  0x40,  0x08,  0x10,  0x04,  0x80,
  0x18,  0xE4,  0xFE,  0x00,  0x04,  0x40,  0x00,  0x16,  0x02,  0xF6,  0xE0,  0x00,  0x02,  0x57,  0x03,  0x59,
  0x01,  0xCC,  0x81,  0x48,  0x22,  0x12,  0x00,  0x4E,  0x83,  0x5A,  0x90,  0x4C,  0x20,  0xE7,  0x00,  0x00,
  0xC3,  0x58,  0x1B,  0xF4,  0xFF,  0x00,  0x83,  0x55,  0x83,  0x55,  0x83,  0x55,  0x03,  0xF4,  0x00,  0x12,
  0x8B,  0x55,  0x83,  0x59,  0x00,  0x4E,  0x00,  0x16,  0x00,  0x4E,  0x02,  0xF6,  0xF0,  0x00,  0x02,  0x57,
  0x03,  0x59,  0x00,  0x4E,  0x83,  0x5A,  0x30,  0xE7,  0x00,  0x00,  0x20,  0xE7,  0x00,  0x00,  0x00,  0x16,
  0x02,  0xF6,  0xF0,  0x00,  0x02,  0x57,  0x03,  0x59,  0x01,  0xCC,  0x00,  0x4E,  0x83,  0x5A,  0x30,  0xE7,
  0x00,  0x00,  0x80,  0x4C,  0xC3,  0x58,  0x1B,  0xF4,  0xFF,  0x00,  0x83,  0x55,  0x83,  0x55,  0x83,  0x55,
  0x03,  0xF4,  0x00,  0x12,  0x83,  0x59,  0x00,  0x4E,  0x00,  0x16,  0x03,  0xF6,  0xE0,  0x00,  0x03,  0x57,
  0x83,  0x59,  0x3A,  0x55,  0x02,  0xCC,  0x45,  0x5A,  0x00,  0xF2,  0xCA,  0x0D,  0xC0,  0x5A,  0x40,  0x5C,
  0x38,  0x54,  0x00,  0xCD,  0x01,  0xCC,  0x4A,  0x46,  0x0A,  0x13,  0x83,  0x59,  0x00,  0x4C,  0x01,  0x48,
  0x16,  0x13,  0x0C,  0x10,  0xC5,  0x58,  0x00,  0xF2,  0xCA,  0x0D,  0x00,  0x4C,  0x01,  0x48,  0x08,  0x13,
  0x05,  0xF6,  0xF0,  0x00,  0x05,  0x57,  0x08,  0x10,  0x45,  0x58,  0x00,  0xF2,  0xCA,  0x0D,  0x8D,  0x56,
  0x83,  0x5A,  0x80,  0x4C,  0x05,  0x17,  0x00,  0x16,  0x02,  0x4B,  0x06,  0xF7,  0x04,  0x00,  0x62,  0x0B,
  0x03,  0x82,  0x00,  0xF2,  0xB6,  0x0D,  0x02,  0x80,  0x00,  0x4C,  0x45,  0xF4,  0x02,  0x00,  0x52,  0x14,
  0x06,  0xF7,  0x02,  0x00,  0x06,  0x14,  0x00,  0xF2,  0x28,  0x0F,  0x00,  0x16,  0x02,  0x4B,  0x01,  0xF6,
  0xFF,  0x00,  0x38,  0x1C,  0x05,  0xF4,  0x04,  0x00,  0x83,  0x5A,  0x18,  0xDF,  0x19,  0xDF,  0x1D,  0xF7,
  0x3C,  0x00,  0xB8,  0xF0,  0x22,  0x10,  0x9C,  0x14,  0x01,  0x48,  0x1C,  0x13,  0x0E,  0xF7,  0x3C,  0x00,
  0x03,  0xF7,  0x04,  0x00,  0xAF,  0x19,  0x03,  0x42,  0x45,  0xF4,  0x02,  0x00,  0x83,  0x5A,  0x02,  0xCC,
  0x02,  0x41,  0x45,  0xF4,  0x02,  0x00,  0x00,  0x16,  0x91,  0x44,  0xD5,  0xF0,  0x12,  0x10,  0x00,  0xF0,
  0x9E,  0x02,  0x01,  0xF6,  0xFF,  0x00,  0x38,  0x1C,  0x05,  0xF4,  0x04,  0x00,  0x83,  0x5A,  0x18,  0xDF,
  0x19,  0xDF,  0x0E,  0xF7,  0x3C,  0x00,  0x03,  0xF7,  0x04,  0x00,  0x0F,  0x79,  0x1C,  0xF7,  0x3C,  0x00,
  0xB8,  0xF0,  0x70,  0x10,  0x4E,  0x14,  0x01,  0x48,  0x06,  0x13,  0x45,  0xF4,  0x04,  0x00,  0x00,  0x16,
  0x91,  0x44,  0xD5,  0xF0,  0x56,  0x10,  0x00,  0xF0,  0x9E,  0x02,  0x02,  0xF6,  0xFF,  0x00,  0x38,  0x1C,
  0x2C,  0xBC,  0xAE,  0xBC,  0xE2,  0x08,  0x00,  0xEC,  0xB8,  0x00,  0x02,  0x48,  0x1D,  0xF7,  0x80,  0x00,
  0xB8,  0xF0,  0xA0,  0x10,  0x1E,  0x14,  0x01,  0x48,  0x0E,  0x13,  0x0E,  0xF7,  0x80,  0x00,  0x38,  0x54,
  0x03,  0x58,  0xAF,  0x19,  0x82,  0x48,  0x00,  0x16,  0x82,  0x48,  0x12,  0x45,  0xD5,  0xF0,  0x8E,  0x10,
  0x00,  0xF0,  0x9E,  0x02,  0x39,  0xF0,  0xCC,  0x10,  0x38,  0x44,  0x00,  0x16,  0x7E,  0x18,  0x18,  0xF4,
  0x03,  0x00,  0x04,  0x13,  0x61,  0x18,  0x00,  0x16,  0x38,  0x1C,  0x00,  0xFC,  0x22,  0x01,  0x18,  0xF4,
  0x01,  0x00,  0xF1,  0x12,  0xE3,  0x10,  0x1E,  0xF0,  0xEE,  0x10,  0x14,  0xF0,  0xE6,  0x10,  0xB1,  0xF0,
  0xEE,  0x10,  0x00,  0x16,  0x3E,  0x57,  0x03,  0xF6,  0xE0,  0x00,  0x03,  0x57,  0x83,  0x59,  0x04,  0xCC,
  0x01,  0x4A,  0x6A,  0x12,  0x45,  0x5A,  0x00,  0xF2,  0xCA,  0x0D,  0x02,  0x4B,  0x70,  0x14,  0x34,  0x13,
  0x02,  0x80,  0x48,  0xE4,  0x08,  0x00,  0x18,  0x12,  0x9C,  0xE7,  0x02,  0x00,  0x9E,  0xE7,  0x15,  0x00,
  0x00,  0xF2,  0x9A,  0x0F,  0x00,  0xF2,  0x6A,  0x0A,  0x1E,  0x1C,  0x01,  0xF6,  0x01,  0x00,  0x00,  0x16,
  0x30,  0xE4,  0x10,  0x00,  0x04,  0x40,  0x00,  0xF2,  0xB6,  0x0D,  0x20,  0xE7,  0x01,  0x00,  0x01,  0xF6,
  0x01,  0x00,  0x00,  0x16,  0x04,  0xDC,  0x01,  0x4A,  0x24,  0x12,  0x45,  0x5A,  0x00,  0xF2,  0xCA,  0x0D,
  0x43,  0x5B,  0x06,  0xEC,  0x98,  0x00,  0x00,  0xF2,  0x0C,  0x10,  0xC6,  0x59,  0x20,  0x14,  0x0A,  0x13,
  0x00,  0xF2,  0x9A,  0x0F,  0x00,  0xF2,  0xE8,  0x0F,  0xA7,  0x10,  0x83,  0x5A,  0xD7,  0x10,  0x0E,  0x47,
  0x07,  0xE6,  0x10,  0x00,  0xCE,  0x47,  0x5A,  0xF0,  0xF6,  0x10,  0xB9,  0x54,  0x00,  0x16,  0x14,  0x90,
  0x96,  0x90,  0x02,  0xFC,  0xA8,  0x00,  0x03,  0xFC,  0xAA,  0x00,  0x48,  0x55,  0x02,  0x13,  0xC9,  0x55,
  0x00,  0x16,  0x00,  0xEC,  0xBA,  0x00,  0x10,  0x44,  0x00,  0xEA,  0xBA,  0x00,  0x00,  0x16,  0x03,  0xF6,
  0xC0,  0x00,  0x00,  0xF2,  0x58,  0x0A,  0x10,  0x44,  0x00,  0x4C,  0x00,  0x16,  0x00,  0xF6,  0x02,  0x00,
  0x00,  0x10,  0x00,  0x10,  0x10,  0x54,  0xF9,  0x13,  0x00,  0x16,};

unsigned short _adv_mcode_size = sizeof(_adv_mcode_buf); /* 0x11BA */
unsigned long  _adv_mcode_chksum = 0x03406FC9UL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\cdbsetup.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/CDBSetup.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 9/20/00 5:02p   $ (Last Modified)

Purpose:

  This file implements CDB Support Functions for the FC Layer.

--*/

#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/memmap.h"
#include "../h/tlstruct.h"
#include "../h/fcmain.h"
#include "../h/cdbsetup.h"

#else /* _New_Header_file_Layout_ */

#include "globals.h"
#include "state.h"
#include "memmap.h"
#include "tlstruct.h"
#include "fcmain.h"
#include "cdbsetup.h"

#endif  /* _New_Header_file_Layout_ */

/*+
  Function: fiFillInFCP_CMND

   Purpose: Generic inCardRam or inDmaMemory version to fill in FCP command payload
 Called By: none
     Calls: fiFillInFCP_CMND_OnCard 
            fiFillInFCP_CMND_OffCard
-*/
void fiFillInFCP_CMND(
                       CDBThread_t *CDBThread
                     )
{
    if (CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.FCP_CMND.memLoc == inCardRam)
    {
        fiFillInFCP_CMND_OnCard(
                                 CDBThread
                               );
    }
    else /* CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.FCP_CMND.memLoc == inDmaMemory */
    {
        fiFillInFCP_CMND_OffCard(
                                  CDBThread
                                );
    }
}

/*+
  Function: fiFillInFCP_CMND_OnCard

   Purpose: inCardRam  version to fill in FCP command payload, copies 
            from precalculated image of FCP header.
 Called By: CThread->FuncPtrs.fiFillInFCP_CMND
     Calls: osCardRamWriteBlock
            osCardRamWriteBit32
-*/
void fiFillInFCP_CMND_OnCard(
                              CDBThread_t *CDBThread
                            )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t    *hpRoot          = CDBThread->thread_hdr.hpRoot;
    DevThread_t *DevThread       = CDBThread->Device;
    X_ID_t       Masked_OX_ID;
    os_bit32     FCP_CMND_Offset = CDBThread->FCP_CMND_Offset;

    if (CDBThread->ReadWrite == CDBThread_Read)
    {
        Masked_OX_ID = (X_ID_t)(CDBThread->X_ID | X_ID_Read);
    }
    else /* CDBThread->ReadWrite == CDBThread_Write */
    {
        Masked_OX_ID = (X_ID_t)(CDBThread->X_ID | X_ID_Write);
    }

    osCardRamWriteBlock(
                         hpRoot,
                         FCP_CMND_Offset,
                         (os_bit8 *)&(DevThread->Template_FCHS),
                         sizeof(FCHS_t)
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_CMND_Offset + hpFieldOffset(
                                                          FCHS_t,
                                                          OX_ID__RX_ID
                                                        ),
                         (  (Masked_OX_ID << FCHS_OX_ID_SHIFT)
                          | (0xFFFF << FCHS_RX_ID_SHIFT)      )
                       );

    osCardRamWriteBlock(
                         hpRoot,
                         FCP_CMND_Offset + sizeof(FCHS_t),
                         (os_bit8 *)&(CDBThread->CDBRequest->FcpCmnd),
                         sizeof(agFcpCmnd_t)
                       );

#ifndef Performance_Debug
    fiLogDebugString(hpRoot,
                    CStateLogConsoleShowSEST,
                    "FCP_CMND_Offset %08X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL, agNULL,
                    FCP_CMND_Offset,
                    0,0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleShowSEST,
                    "FCP_CMND_Offset DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL, agNULL,
                    osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 0),
                    osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 4),
                    osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 8),
                    osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 12),
                    osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 16),
                    osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 20),
                    osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 24),
                    osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 28));

#endif /* Performance_Debug */

#endif /* __MemMap_Force_Off_Card__ was not defined */
}

/*+
  Function: fiFillInFCP_CMND_OffCard

   Purpose: inDmaMemory  version to fill in FCP command payload, copies 
            from precalculated image of FCP header.
 Called By: CThread->FuncPtrs.fiFillInFCP_CMND
     Calls: none
-*/
void fiFillInFCP_CMND_OffCard(
                               CDBThread_t *CDBThread
                             )
{
#ifndef __MemMap_Force_On_Card__
    DevThread_t * DevThread    = CDBThread->Device;
    X_ID_t        Masked_OX_ID;
    FCHS_t      * FCHS         = CDBThread->FCP_CMND_Ptr;
#ifndef Performance_Debug
    agRoot_t    *hpRoot        = CDBThread->thread_hdr.hpRoot;
    os_bit32    *FCHSbit_32    = (os_bit32 * )FCHS;
#endif /* Performance_Debug */
    agFcpCmnd_t * hpFcpCmnd    = (agFcpCmnd_t *)((os_bit8 *)FCHS + sizeof(FCHS_t));
    if (CDBThread->ReadWrite == CDBThread_Read)
    {
        Masked_OX_ID = (X_ID_t)(CDBThread->X_ID | X_ID_Read);
    }
    else /* CDBThread->ReadWrite == CDBThread_Write */
    {
        Masked_OX_ID = (X_ID_t)(CDBThread->X_ID | X_ID_Write);
    }

    *FCHS              = DevThread->Template_FCHS;

    FCHS->OX_ID__RX_ID =   (Masked_OX_ID << FCHS_OX_ID_SHIFT)
                         | (0xFFFF << FCHS_RX_ID_SHIFT);

    *hpFcpCmnd         = CDBThread->CDBRequest->FcpCmnd;

#ifndef Performance_Debug
    fiLogDebugString(hpRoot,
                    CStateLogConsoleShowSEST,
                    "FCP_CMND_ptr %p",
                    (char *)agNULL,(char *)agNULL,
                    FCHSbit_32, agNULL,
                    0,0,0,0,0,0,0,0);
 
    fiLogDebugString(hpRoot,
                    CStateLogConsoleShowSEST,
                    "FCP_CMND_ptr DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL, agNULL,
                    * (FCHSbit_32 + 0),
                    * (FCHSbit_32 + 4),
                    * (FCHSbit_32 + 8),
                    * (FCHSbit_32 + 12),
                    * (FCHSbit_32 + 16),
                    * (FCHSbit_32 + 20),
                    * (FCHSbit_32 + 24),
                    * (FCHSbit_32 + 28));

#endif /* Performance_Debug */

#endif /* __MemMap_Force_On_Card__ was not defined */
}

/*+
   Function: fiFillInFCP_RESP

    Purpose: Generic inCardRam or inDmaMemory version to zero FCP response buffer
  Called By: none
      Calls: fiFillInFCP_RESP_OnCard 
             fiFillInFCP_RESP_OffCard
-*/
void fiFillInFCP_RESP(
                       CDBThread_t *CDBThread
                     )
{
    if (CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.FCP_RESP.memLoc == inCardRam)
    {
        fiFillInFCP_RESP_OnCard(
                                 CDBThread
                               );
    }
    else /* CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.FCP_RESP.memLoc == inDmaMemory */
    {
        fiFillInFCP_RESP_OffCard(
                                  CDBThread
                                );
    }
}

/*+
  Function: fiFillInFCP_RESP_OnCard

   Purpose: inCardRam version to zero FCP response buffer,
 Called By: CThread->FuncPtrs.fiFillInFCP_RESP
     Calls: osCardRamWriteBit32
-*/
void fiFillInFCP_RESP_OnCard(
                              CDBThread_t *CDBThread
                            )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t *hpRoot                  = CDBThread->thread_hdr.hpRoot;
    os_bit32     FCP_RESP_Payload_Offset = CDBThread->FCP_RESP_Offset + sizeof(FC_Frame_Header_t);

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_RESP_Payload_Offset + hpFieldOffset(
                                                                  FC_FCP_RSP_Payload_t,
                                                                  FCP_STATUS
                                                                ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         FCP_RESP_Payload_Offset + hpFieldOffset(
                                                                  FC_FCP_RSP_Payload_t,
                                                                  FCP_RESID
                                                                ),
                         0
                       );
    
    osCardRamWriteBit32(
                         hpRoot,
                         FCP_RESP_Payload_Offset + hpFieldOffset(
                                                                  FC_FCP_RSP_Payload_t,
                                                                  FCP_SNS_LEN
                                                                ),
                         0
                       );

#endif /* __MemMap_Force_Off_Card__ was not defined */
}

/*+
  Function: fiFillInFCP_RESP_OffCard

   Purpose: inDmaMemory version to zero FCP response buffer,
 Called By: CThread->FuncPtrs.fiFillInFCP_RESP
     Calls: none
-*/
void fiFillInFCP_RESP_OffCard(
                               CDBThread_t *CDBThread
                             )
{
#ifndef __MemMap_Force_On_Card__
    FC_FCP_RSP_Payload_t *FCP_RESP_Payload = (FC_FCP_RSP_Payload_t *)((os_bit8 *)CDBThread->FCP_RESP_Ptr + sizeof(FC_Frame_Header_t));

    *(os_bit32 *)(&(FCP_RESP_Payload->FCP_STATUS)) = 0;
    FCP_RESP_Payload->FCP_RESID                 = 0;
    FCP_RESP_Payload->FCP_SNS_LEN               = 0;
#endif /* __MemMap_Force_On_Card__ was not defined */
}

/*+
  Function: fiFillInFCP_SEST

   Purpose: Generic inCardRam or inDmaMemory version to fill in SEST entry for FCP commands
 Called By: none
     Calls: fiFillInFCP_SEST_OnCard 
            fiFillInFCP_SEST_OffCard
-*/
void fiFillInFCP_SEST(
                       CDBThread_t *CDBThread
                     )
{
    if (CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SEST.memLoc == inCardRam)
    {
        fiFillInFCP_SEST_OnCard(
                                 CDBThread
                               );
    }
    else /* CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SEST.memLoc == inDmaMemory */
    {
        fiFillInFCP_SEST_OffCard(
                                  CDBThread
                                );
    }
}

/*+
  Function: fiFillInFCP_SEST_OnCard

   Purpose: inCardRam version to fill in SEST entry for FCP commands, copies 
            from precalculated image of SEST entry.
 Called By: CThread->FuncPtrs.fiFillInFCP_SEST
     Calls: osCardRamWriteBlock
            osCardRamWriteBit32
-*/
void fiFillInFCP_SEST_OnCard(
                              CDBThread_t *CDBThread
                            )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t    *hpRoot      = CDBThread->thread_hdr.hpRoot;
     DevThread_t *DevThread   = CDBThread->Device;
    os_bit32        SEST_Offset = CDBThread->SEST_Offset;

    if (CDBThread->ReadWrite == CDBThread_Read)
    {
        osCardRamWriteBlock(
                             hpRoot,
                             SEST_Offset,
                             (os_bit8 *)&(DevThread->Template_SEST_IRE), /* NW BUG */
                             sizeof(IRE_t)
                           );

        osCardRamWriteBit32(
                             hpRoot,
                             SEST_Offset + hpFieldOffset(
                                                          SEST_t,
                                                          IRE.RSP_Addr
                                                        ),
                             CDBThread->FCP_RESP_Lower32
                           );

        osCardRamWriteBit32(
                             hpRoot,
                             SEST_Offset + hpFieldOffset(
                                                          SEST_t,
                                                          IRE.Exp_Byte_Cnt
                                                        ),
                             CDBThread->DataLength
                           );
    }
    else /* CDBThread->ReadWrite == CDBThread_Write */
    {
        osCardRamWriteBlock(
                             hpRoot,
                             SEST_Offset,
                             (os_bit8 *)&(DevThread->Template_SEST_IWE),/* NW BUG */
                             sizeof(IWE_t)
                           );

        osCardRamWriteBit32(
                             hpRoot,
                             SEST_Offset + hpFieldOffset(
                                                          SEST_t,
                                                          IWE.Hdr_Addr
                                                        ),
                             CDBThread->FCP_CMND_Lower32
                           );

        osCardRamWriteBit32(
                             hpRoot,
                             SEST_Offset + hpFieldOffset(
                                                          SEST_t,
                                                          IWE.RSP_Addr
                                                        ),
                             CDBThread->FCP_RESP_Lower32
                           );

        osCardRamWriteBit32(
                             hpRoot,
                             SEST_Offset + hpFieldOffset(
                                                          SEST_t,
                                                          IWE.Data_Len
                                                        ),
                             CDBThread->DataLength
                           );

        osCardRamWriteBit32(
                             hpRoot,
                             SEST_Offset + hpFieldOffset(
                                                          SEST_t,
                                                          IWE.Exp_Byte_Cnt
                                                        ),
                             CDBThread->DataLength
                           );
    }
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

/*+
  Function: fiFillInFCP_SEST_OffCard

   Purpose: inDmaMemory version to fill in SEST entry for FCP commands, copies 
            from precalculated image of SEST entry.
 Called By: CThread->FuncPtrs.fiFillInFCP_SEST
     Calls: none
-*/
void fiFillInFCP_SEST_OffCard(
                               CDBThread_t *CDBThread
                             )
{
#ifndef __MemMap_Force_On_Card__
    DevThread_t *DevThread = CDBThread->Device;
    SEST_t      *SEST      = CDBThread->SEST_Ptr;

    if (CDBThread->ReadWrite == CDBThread_Read)
    {
        *((IRE_t *)SEST)       = DevThread->Template_SEST_IRE;
        SEST->IRE.RSP_Addr     = CDBThread->FCP_RESP_Lower32;
        SEST->IRE.Exp_Byte_Cnt = CDBThread->DataLength;
    }
    else /* CDBThread->ReadWrite == CDBThread_Write */
    {
        *((IWE_t *)SEST)       = DevThread->Template_SEST_IWE;
        SEST->IWE.Hdr_Addr     = CDBThread->FCP_CMND_Lower32;
        SEST->IWE.RSP_Addr     = CDBThread->FCP_RESP_Lower32;
        SEST->IWE.Data_Len     = CDBThread->DataLength;
        SEST->IWE.Exp_Byte_Cnt = CDBThread->DataLength;
    }
#endif /* __MemMap_Force_On_Card__ was not defined */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\cdbsetup.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/CDBSetup.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 7/20/00 2:33p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/CDBSetup.C

--*/

#ifndef __CDBSetup_H__
#define __CDBSetup_H__

osGLOBAL void fiFillInFCP_CMND(
                              CDBThread_t *CDBThread
                            );

osGLOBAL void fiFillInFCP_CMND_OnCard(
                                     CDBThread_t *CDBThread
                                   );

osGLOBAL void fiFillInFCP_CMND_OffCard(
                                      CDBThread_t *CDBThread
                                    );

osGLOBAL void fiFillInFCP_RESP(
                              CDBThread_t *CDBThread
                            );

osGLOBAL void fiFillInFCP_RESP_OnCard(
                                     CDBThread_t *CDBThread
                                   );

osGLOBAL void fiFillInFCP_RESP_OffCard(
                                      CDBThread_t *CDBThread
                                    );

osGLOBAL void fiFillInFCP_SEST(
                              CDBThread_t *CDBThread
                            );

osGLOBAL void fiFillInFCP_SEST_OnCard(
                                     CDBThread_t *CDBThread
                                   );

osGLOBAL void fiFillInFCP_SEST_OffCard(
                                      CDBThread_t *CDBThread
                                    );

#endif /* __CDBSetup_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\cfinit.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/CFINIT.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 10/05/00 3:57p  $

Purpose:

  This file implements Initialize functions called by the FC Layer Card
  State Machine.

--*/

#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/state.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/fcstruct.h"
#include "../h/linksvc.h"
#include "../h/cmntrans.h"
#include "../h/sf_fcp.h"
#include "../h/flashsvc.h"
#include "../h/timersvc.h"

#include "../h/cstate.h"
#include "../h/cfunc.h"
#include "../h/devstate.h"
#include "../h/cdbstate.h"
#include "../h/sfstate.h"
#include "../h/tgtstate.h"

#ifdef _DvrArch_1_30_
#include "../h/ipstate.h"
#include "../h/pktstate.h"
#endif /* _DvrArch_1_30_ was defined */

#include "../h/queue.h"
#include "../h/cdbsetup.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"

#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"
#include "fcstruct.h"
#include "linksvc.h"
#include "cmntrans.h"
#include "sf_fcp.h"
#include "flashsvc.h"
#include "timersvc.h"

#include "cstate.h"
#include "cfunc.h"
#include "devstate.h"
#include "cdbstate.h"
#include "sfstate.h"
#include "tgtstate.h"

#ifdef _DvrArch_1_30_
#include "ipstate.h"
#include "pktstate.h"
#endif /* _DvrArch_1_30_ was defined */

#include "queue.h"
#include "cdbsetup.h"
#endif  /* _New_Header_file_Layout_ */


#ifndef __State_Force_Static_State_Tables__
extern actionUpdate_t noActionUpdate;
#endif /* __State_Force_Static_State_Tables__ was not defined */

extern os_bit8 Alpa_Index[256];


void CFuncInitERQ_Registers( agRoot_t *hpRoot )
{
    CThread_t  * pCThread= CThread_ptr(hpRoot);
    os_bit32        reg_value = 0;

    switch (pCThread->Calculation.MemoryLayout.ERQ.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
            reg_value = pCThread->Calculation.MemoryLayout.ERQ.addr.DmaMemory.dmaMemoryLower32;
            break;

        case inCardRam:
             fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
            reg_value = pCThread->Calculation.MemoryLayout.ERQ.addr.CardRam.cardRamLower32;
            break;

        default: Fc_ERROR(hpRoot);
    }

    osChipIOLoWriteBit32(hpRoot, ChipIOLo_ERQ_Base, reg_value);
    osChipIOLoWriteBit32(hpRoot, ChipIOLo_ERQ_Length,
        pCThread->Calculation.MemoryLayout.ERQ.elements - 1 );

    pCThread->HostCopy_ERQProdIndex=0;

    switch (pCThread->Calculation.MemoryLayout.ERQConsIndex.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.ERQConsIndex OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);


            reg_value                          = pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryLower32;
            *(ERQConsIndex_t *)(pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryPtr) = 0;
            break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.ERQConsIndex OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

            reg_value                          = pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamLower32;
            osCardRamWriteBit32(hpRoot,
                    pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamOffset,
                    0
                    );

            break;

        default: Fc_ERROR(hpRoot);
    }

    osChipIOLoWriteBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index_Address, reg_value);

}

os_bit32 CFuncInitChip( agRoot_t *hpRoot )
{

    CThread_t  * pCThread= CThread_ptr(hpRoot);
    os_bit32        reg_value = 0;
    os_bit32 * pInitIMQ,x;
    /* ERQ Entries */

    switch (pCThread->Calculation.MemoryLayout.ERQ.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
#ifdef _DvrArch_1_30_
            pCThread->FuncPtrs.Pkt_IRB_Init = &PktFuncIRB_OffCardInit;
#endif /* _DvrArch_1_30_ was defined */
            pCThread->FuncPtrs.SF_IRB_Init = &SFFuncIRB_OffCardInit;
            pCThread->FuncPtrs.CDBFuncIRB_Init = &CDBFuncIRB_offCardInit;
            reg_value = pCThread->Calculation.MemoryLayout.ERQ.addr.DmaMemory.dmaMemoryLower32;
            break;

        case inCardRam:
             fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
            pCThread->FuncPtrs.SF_IRB_Init = &SFFuncIRB_OnCardInit;
            pCThread->FuncPtrs.CDBFuncIRB_Init = &CDBFuncIRB_onCardInit;
            reg_value = pCThread->Calculation.MemoryLayout.ERQ.addr.CardRam.cardRamLower32;
            break;

        default: Fc_ERROR(hpRoot);
    }

    osChipIOLoWriteBit32(hpRoot, ChipIOLo_ERQ_Base, reg_value);
    osChipIOLoWriteBit32(hpRoot, ChipIOLo_ERQ_Length,
        pCThread->Calculation.MemoryLayout.ERQ.elements - 1 );

    pCThread->HostCopy_ERQProdIndex=0;

    switch (pCThread->Calculation.MemoryLayout.ERQConsIndex.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.ERQConsIndex OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);


            reg_value                          = pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryLower32;
            pCThread->FuncPtrs.GetERQConsIndex = &CFuncGetDmaMemERQConsIndex;
            pCThread->FuncPtrs.WaitForERQ      = &WaitForERQ_ConsIndexOffCard;
            pCThread->FuncPtrs.WaitForERQEmpty = &WaitForERQEmpty_ConsIndexOffCard;
            *(ERQConsIndex_t *)(pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryPtr) = 0;
            break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.ERQConsIndex OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

            reg_value                          = pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamLower32;
            pCThread->FuncPtrs.GetERQConsIndex = &CFuncGetCardRamERQConsIndex;
            pCThread->FuncPtrs.WaitForERQ      = &WaitForERQ_ConsIndexOnCard;
            pCThread->FuncPtrs.WaitForERQEmpty = &WaitForERQEmpty_ConsIndexOnCard;
            osCardRamWriteBit32(hpRoot,
                    pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamOffset,
                    0
                    );

            break;

        default: Fc_ERROR(hpRoot);
    }

    osChipIOLoWriteBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index_Address, reg_value);

    /* SFQ Entries */

    switch (pCThread->Calculation.MemoryLayout.SFQ.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "SFQ.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

             reg_value                              = pCThread->Calculation.MemoryLayout.SFQ.addr.DmaMemory.dmaMemoryLower32;
             pCThread->FuncPtrs.fiLinkSvcProcessSFQ = &fiLinkSvcProcessSFQ_OffCard;
             pCThread->FuncPtrs.fiCTProcessSFQ      = &fiCTProcessSFQ_OffCard;
             pCThread->FuncPtrs.fiSF_FCP_ProcessSFQ = &fiSF_FCP_ProcessSFQ_OffCard;
             break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "SFQ.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
             reg_value                              = pCThread->Calculation.MemoryLayout.SFQ.addr.CardRam.cardRamLower32;
             pCThread->FuncPtrs.fiLinkSvcProcessSFQ = &fiLinkSvcProcessSFQ_OnCard;
             pCThread->FuncPtrs.fiCTProcessSFQ      = &fiCTProcessSFQ_OnCard;
             pCThread->FuncPtrs.fiSF_FCP_ProcessSFQ = &fiSF_FCP_ProcessSFQ_OnCard;
             break;

        default: Fc_ERROR(hpRoot);
    }

    osChipIOLoWriteBit32(hpRoot,ChipIOLo_SFQ_Base , reg_value);
    osChipIOLoWriteBit32(hpRoot, ChipIOLo_SFQ_Length,
        pCThread->Calculation.MemoryLayout.SFQ.elements - 1 );


    /* IMQ Entries */
    pCThread->HostCopy_IMQConsIndex=0;

    switch( pCThread->Calculation.MemoryLayout.IMQ.memLoc)
    {
        case inDmaMemory:

            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "IMQ.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

            reg_value = pCThread->Calculation.MemoryLayout.IMQ.addr.DmaMemory.dmaMemoryLower32;
            pCThread->FuncPtrs.Proccess_IMQ    =&CFuncOffCardProcessIMQ;

            pInitIMQ = pCThread->Calculation.MemoryLayout.IMQ.addr.DmaMemory.dmaMemoryPtr;
            for(x=0; x < pCThread->Calculation.MemoryLayout.IMQ.elements - 1; x++)
            {
               * pInitIMQ = CM_Unknown_CM_Type_InvalidType;
                 pInitIMQ += 8;
            }
            break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "IMQ.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
            reg_value = pCThread->Calculation.MemoryLayout.IMQ.addr.CardRam.cardRamLower32;
            pCThread->FuncPtrs.Proccess_IMQ    = &CFuncOnCardProcessIMQ;
            break;

        default: Fc_ERROR(hpRoot);
    }

    osChipIOLoWriteBit32(hpRoot,ChipIOLo_IMQ_Base, reg_value);

    osChipIOLoWriteBit32(hpRoot, ChipIOLo_IMQ_Length,
        pCThread->Calculation.MemoryLayout.IMQ.elements - 1 );

    switch (pCThread->Calculation.MemoryLayout.IMQProdIndex.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "IMQProdIndex.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

             reg_value                          = pCThread->Calculation.MemoryLayout.IMQProdIndex.addr.DmaMemory.dmaMemoryLower32;
             pCThread->FuncPtrs.GetIMQProdIndex = &CFuncGetDmaMemIMQProdIndex;
             break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "IMQProdIndex.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
             reg_value                          = pCThread->Calculation.MemoryLayout.IMQProdIndex.addr.CardRam.cardRamLower32;
             pCThread->FuncPtrs.GetIMQProdIndex = &CFuncGetCardRamIMQProdIndex;
             osCardRamWriteBit32(hpRoot,
                    pCThread->Calculation.MemoryLayout.IMQProdIndex.addr.CardRam.cardRamOffset,
                    0
                    );
             break;

        default: Fc_ERROR(hpRoot);
    }

    osChipIOLoWriteBit32(hpRoot,ChipIOLo_IMQ_Producer_Index_Address, reg_value);


    /* SEST Entries */

    switch (pCThread->Calculation.MemoryLayout.SEST.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "SEST.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

            reg_value                           = pCThread->Calculation.MemoryLayout.SEST.addr.DmaMemory.dmaMemoryLower32;
            pCThread->FuncPtrs.fiFillInFCP_SEST = &fiFillInFCP_SEST_OffCard;
            pCThread->FuncPtrs.fillLocalSGL     = &fill_Loc_SGL_offCard;

            pCThread->FuncPtrs.FCP_Completion = &CFuncSEST_offCard_FCPCompletion;
            if(pCThread->Calculation.MemoryLayout.ESGL.memLoc == inDmaMemory)
            {
                pCThread->FuncPtrs.upSEST           = &fillptr_SEST_offCard_ESGL_offCard;

            }
            else
            {
                pCThread->FuncPtrs.upSEST           = &fillptr_SEST_offCard_ESGL_onCard;
            }

            break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "SEST.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
             pCThread->FuncPtrs.FCP_Completion = &CFuncSEST_onCard_FCPCompletion;

             reg_value                           = pCThread->Calculation.MemoryLayout.SEST.addr.CardRam.cardRamLower32;
             pCThread->FuncPtrs.fiFillInFCP_SEST = &fiFillInFCP_SEST_OnCard;
             pCThread->FuncPtrs.fillLocalSGL     = &fill_Loc_SGL_onCard;
            if(pCThread->Calculation.MemoryLayout.ESGL.memLoc == inDmaMemory)
            {
                 pCThread->FuncPtrs.upSEST           = &fillptr_SEST_onCard_ESGL_offCard;

            }
            else
            {
                 pCThread->FuncPtrs.upSEST           = &fillptr_SEST_onCard_ESGL_onCard;
            }
            break;

        default: Fc_ERROR(hpRoot);
    }

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_SEST_Base, reg_value);

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_SEST_Length, pCThread->Calculation.MemoryLayout.SEST.elements );

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_SEST_Linked_List_Head_Tail, 0xffffffff  );


    /* ESGL */
    osChipIOUpWriteBit32( hpRoot, ChipIOUp_ScatterGather_List_Page_Length, pCThread->Calculation.MemoryLayout.ESGL.elementSize/sizeof(SG_Element_t) - 1 );

    /*TL Config Register */

#ifdef __Implement_The_Advise_About_OB_Thresh_In_The_Users_Manual__
    reg_value = osChipIOUpReadBit32(hpRoot,
                ChipIOUp_PCIMCTR__ROMCTR__Reserved_8__Reserved_9);

    if(reg_value &  ChipIOUp_PCIMCTL_P64 )
    {
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_TachLite_Configuration,
                        ChipIOUp_TachLite_Configuration_M66EN |
                        ChipIOUp_TachLite_Configuration_OB_Thresh_264);
    }
    else
    {
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_TachLite_Configuration,
                        ChipIOUp_TachLite_Configuration_M66EN |
                        ChipIOUp_TachLite_Configuration_OB_Thresh_132);

    }
#endif /* __Implement_The_Advise_About_OB_Thresh_In_The_Users_Manual__ was not defined */

    /* This will break the Gadzoox  Gibraltar GS  Hub 
        pCThread->TimeOutValues.LP_Tov = 1000;
    */
/* Now set from osAdjustParm.....
    pCThread->TimeOutValues.ED_Tov = 2000;
    pCThread->TimeOutValues.LP_Tov = pCThread->TimeOutValues.ED_Tov;
*/
    CFuncWriteTimeoutValues( hpRoot, &pCThread->TimeOutValues  );

    return agTRUE;
}

void CFuncInitFM_Registers( agRoot_t *hpRoot,agBOOLEAN SendInit )
{
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    agFCChanInfo_t *Self_info = &(pCThread->ChanInfo);
    os_bit32 Init_FM_Value = 0;


    if(! pCThread->PreviouslyAquiredALPA)
    {
        CFuncGetHaInfoFromNVR(hpRoot);
    }
    fiLinkSvcInit(hpRoot);

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "%s FM Status %08X FM Cfg %08x Self ALPA %x",
                    "CFuncInitFM_Registers",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration),
                    Self_info->CurrentAddress.AL_PA,
                    0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "F  %s HA %x CA %x FA %x",
                    "CFuncInitFM_Registers",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)(Self_info->HardAddress.AL_PA),
                    (os_bit32)(Self_info->CurrentAddress.AL_PA),
                    fiFlash_Card_Unassigned_Loop_Address,0,0,0,0,0);


#ifdef NPORT_STUFF
    if (!(pCThread->InitAsNport))
    {
#endif /* NPORT_STUFF */

    if (Self_info->CurrentAddress.AL_PA == fiFlash_Card_Unassigned_Loop_Address)
    {

#ifdef _BYPASSLOOPMAP
        if(pCThread->PreviouslyAquiredALPA)
        {
            Init_FM_Value = (  ChipIOUp_Frame_Manager_Configuration_AQ  |
                               ChipIOUp_Frame_Manager_Configuration_BLM |
                               ( ((os_bit32)(Self_info->HardAddress.AL_PA))
                                  << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 

        }
        else
        {
            Init_FM_Value = (  ChipIOUp_Frame_Manager_Configuration_SA  |
                               ChipIOUp_Frame_Manager_Configuration_BLM |
                               ( ((os_bit32)(Self_info->HardAddress.AL_PA))
                                  << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 
        }
#else /* NOT _BYPASSLOOPMAP */
        if(pCThread->PreviouslyAquiredALPA)
        {

        Init_FM_Value  = ( ChipIOUp_Frame_Manager_Configuration_AQ    |
                           ( ((os_bit32)(Self_info->HardAddress.AL_PA))
                              << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 

        }
        else
        {
        Init_FM_Value  = ( ChipIOUp_Frame_Manager_Configuration_SA    |
                           ( ((os_bit32)(Self_info->HardAddress.AL_PA))
                              << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 

        }
#endif /* _BYPASSLOOPMAP */

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,  Init_FM_Value );

        fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "A %s Frame Manager Configuration %08X",
                    "CFuncInitFM_Registers",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration),
                    0,0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                        CFuncLogConsoleERROR,
                        "G %s HA %x CA %x FA %x",
                        "CFuncInitFM_Registers",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)(Self_info->HardAddress.AL_PA),
                        (os_bit32)(Self_info->CurrentAddress.AL_PA),
                        fiFlash_Card_Unassigned_Loop_Address,0,0,0,0,0);

    }
    else /* Self_info->CurrentAddress.AL_PA != fiFlash_Card_Unassigned_Loop_Address */
    {

#ifdef _BYPASSLOOPMAP
        Init_FM_Value = (  ChipIOUp_Frame_Manager_Configuration_HA  |
                           ChipIOUp_Frame_Manager_Configuration_BLM |
                           ( ((os_bit32)(Self_info->CurrentAddress.AL_PA))
                              << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 
#else /* _BYPASSLOOPMAP */
        Init_FM_Value  = ( ChipIOUp_Frame_Manager_Configuration_HA|
                           ( ((os_bit32)(Self_info->CurrentAddress.AL_PA))
                              << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 
#endif /* _BYPASSLOOPMAP */

        fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "B %s Frame Manager Configuration %08X",
                    "CFuncInitFM_Registers",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration),
                    0,0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "H %s HA %x CA %x FA %x",
                    "CFuncInitFM_Registers",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)(Self_info->HardAddress.AL_PA),
                    (os_bit32)(Self_info->CurrentAddress.AL_PA),
                    fiFlash_Card_Unassigned_Loop_Address,
                    0,0,0,0,0);

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration, Init_FM_Value );

    }
#ifdef NPORT_STUFF
    }
    else /* NPORT_STUFF */
    {
         /* TachyonTL Errata 3.21 - Need to set the
          * ENP bit first and then set the rest of the
          * bits needed to initialize as NPORT. Infact,
          * it does not work if we do not set the ENP
          * bit AGAIN.
          */

         osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration, ChipIOUp_Frame_Manager_Configuration_ENP);

         osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
                              ChipIOUp_Frame_Manager_Configuration_NPI |
                              ChipIOUp_Frame_Manager_Configuration_ENP |
                              /* BB Credit of 1 for NPORT */
                              pCThread->AquiredCredit_Shifted);


        fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "C %s Frame Manager Configuration %08X",
                    "CFuncInitFM_Registers",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration),
                    0,0,0,0,0,0,0);

    }
#endif /* NPORT_STUFF */


    CFuncDisable_Interrupts(hpRoot,ChipIOUp_INTEN_INT);

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Writing High WWN %08X to %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32(*(os_bit32*) &(Self_info->PortWWN[0])),
                    ChipIOUp_Frame_Manager_World_Wide_Name_High,
                    0,0,0,0,0,0);


    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_World_Wide_Name_High, hpSwapBit32(*(os_bit32*) &(Self_info->PortWWN[0])));

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Writing Low  WWN %08X to %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32(*(os_bit32*)&(Self_info->PortWWN[4])),
                    ChipIOUp_Frame_Manager_World_Wide_Name_Low,
                    0,0,0,0,0,0);


    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_World_Wide_Name_Low, hpSwapBit32(*(os_bit32*) &(Self_info->PortWWN[4])));

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Frame Manager Initialize FM Cfg %08X FM Stat %08X  TL Stat %08X Self ALPA %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Configuration),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    0,0,0,0);
    osChipIOUpWriteBit32( hpRoot,ChipIOUp_Frame_Manager_Status, osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ));

    if( SendInit )
    {
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Initialize );

    }

}

/*****************************************************************************************************/

void CFuncInit_DevThread(agRoot_t * hpRoot, DevThread_t * pDevThread   )
{
    CThread_t  *                pCThread        = CThread_ptr(hpRoot);

    fiInitializeThread(&pDevThread->thread_hdr,
            hpRoot,
            threadType_DevThread,
            DevStateHandleEmpty,
#ifdef __State_Force_Static_State_Tables__
            &DevStateTransitionMatrix,
            &DevStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
            pCThread->Calculation.MemoryLayout.DevTransitions.addr.CachedMemory.cachedMemoryPtr,
            pCThread->Calculation.MemoryLayout.DevActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
            );

    Device_IO_Throttle_Initialize

    pDevThread->pollingCount                    = 0;
    pDevThread->Failed_Reset_Count              = 0;

    pDevThread->In_Verify_ALPA_FLAG = agFALSE;
    pDevThread->Prev_Active_Device_FLAG = agFALSE;

    pDevThread->Lun_Active_Bitmask = 0x000000FF;

    fiListInitHdr(&(pDevThread->Active_CDBLink_0));
    fiListInitHdr(&(pDevThread->Active_CDBLink_1));
    fiListInitHdr(&(pDevThread->Active_CDBLink_2));
    fiListInitHdr(&(pDevThread->Active_CDBLink_3));
    fiListInitHdr(&(pDevThread->TimedOut_CDBLink));
    fiListInitHdr(&(pDevThread->Send_IO_CDBLink));
    fiListInitHdr(&(pDevThread->Awaiting_Login_CDBLink));

    fiListInitElement(&(pDevThread->DevLink));

    fiListEnqueueAtTail(&pDevThread->DevLink,&pCThread->Prev_Unknown_Slot_DevLink);


    /*
    Not during  CStateReInitFM or CStateInitDataStructs CStateInitFM
    */


}

void CFuncInit_DirectoryDevThread(agRoot_t   *    hpRoot )
{
    CThread_t  *                pCThread        = CThread_ptr(hpRoot);
    DevThread_t                *pDevThread      = &(pCThread->DirDevThread);



    fiInitializeThread(&pDevThread->thread_hdr,
            hpRoot,
            threadType_DevThread,
            DevStateHandleEmpty,
#ifdef __State_Force_Static_State_Tables__
            &DevStateTransitionMatrix,
            &DevStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
            pCThread->Calculation.MemoryLayout.DevTransitions.addr.CachedMemory.cachedMemoryPtr,
            pCThread->Calculation.MemoryLayout.DevActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
            );

    fiListInitHdr(&(pDevThread->Active_CDBLink_0));
    fiListInitHdr(&(pDevThread->Active_CDBLink_1));
    fiListInitHdr(&(pDevThread->Active_CDBLink_2));
    fiListInitHdr(&(pDevThread->Active_CDBLink_3));
    fiListInitHdr(&(pDevThread->TimedOut_CDBLink));
    fiListInitHdr(&(pDevThread->Send_IO_CDBLink));
    fiListInitHdr(&(pDevThread->Awaiting_Login_CDBLink));

    fiListInitElement(&(pDevThread->DevLink));

    Device_IO_Throttle_Initialize
    pDevThread->pollingCount                    = 0;
    pDevThread->Failed_Reset_Count              = 0;
#ifdef BROCADE_BUG
    pDevThread->DevInfo.CurrentAddress.Domain   = 0xff;
    pDevThread->DevInfo.CurrentAddress.Area     = 0xfc;

    pDevThread->DevInfo.CurrentAddress.AL_PA    = 0x41;
#else /* BROCADE_BUG */
    pDevThread->DevInfo.CurrentAddress.Domain   = 0xff;
    pDevThread->DevInfo.CurrentAddress.Area     = 0xff;

    pDevThread->DevInfo.CurrentAddress.AL_PA    = 0xfc;
#endif /* BROCADE_BUG */


    pDevThread->In_Verify_ALPA_FLAG = agFALSE;


    if( pCThread->thread_hdr.currentState ==  CStateInitialize )
    {
       /*
         Not during  CStateReInitFM or CStateInitDataStructs CStateInitFM
        */
        pDevThread->Prev_Active_Device_FLAG = agFALSE;

     }
     pDevThread->Lun_Active_Bitmask = 0x000000FF;


}
/*****************************************************************************************************/

void CFuncInit_CDBThreads(agRoot_t   *    hpRoot )
{
    CThread_t                  *pCThread                   = CThread_ptr(hpRoot);
    os_bit32                       CDBThread_cnt              = 0;
    fiMemMapMemoryDescriptor_t *CDBThread_MemoryDescriptor = &(pCThread->Calculation.MemoryLayout.CDBThread);
    os_bit32                       CDBThread_size             = CDBThread_MemoryDescriptor->elementSize;
    CDBThread_t                *pCDBThread                 = CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;

#ifndef __State_Force_Static_State_Tables__
    fiInstallStateMachine(
        &CDBStateTransitionMatrix,
        &CDBStateActionScalar,
        pCThread->Calculation.MemoryLayout.CDBTransitions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.CDBActions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.On_Card_MASK,
        &noActionUpdate
        );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    CDBThread_cnt = pCThread->Calculation.MemoryLayout.CDBThread.elements;

    while(CDBThread_cnt-- > 0)
    {
        fiInitializeThread(&pCDBThread->thread_hdr,
            hpRoot,
            threadType_CDBThread,
            CDBStateThreadFree,
#ifdef __State_Force_Static_State_Tables__
            &CDBStateTransitionMatrix,
            &CDBStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
            pCThread->Calculation.MemoryLayout.CDBTransitions.addr.CachedMemory.cachedMemoryPtr,
            pCThread->Calculation.MemoryLayout.CDBActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
            );
        pCDBThread = (CDBThread_t *)((os_bit8 *)pCDBThread + CDBThread_size);
        }
}

void CFuncInit_TgtThreads(  agRoot_t *  hpRoot )
{
    CThread_t               *   pCThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *TgtThread_MemoryDescriptor = &(pCThread->Calculation.MemoryLayout.TgtThread);
    TgtThread_t                *pTgtThread                  = TgtThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;
    os_bit32                       TgtThread_cnt   = TgtThread_MemoryDescriptor->elements;
    os_bit32                       TgtThread_size  = TgtThread_MemoryDescriptor->elementSize;

#ifndef __State_Force_Static_State_Tables__
    fiInstallStateMachine(&SFStateTransitionMatrix,
        &TgtStateActionScalar,
        pCThread->Calculation.MemoryLayout.TgtTransitions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.TgtActions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.On_Card_MASK,
        &noActionUpdate
        );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    while(TgtThread_cnt-- > 0)
    {

        fiInitializeThread(&pTgtThread->thread_hdr,
            hpRoot,
            threadType_TgtThread,
            TgtStateIdle,
#ifdef __State_Force_Static_State_Tables__
            &TgtStateTransitionMatrix,
            &TgtStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
            pCThread->Calculation.MemoryLayout.TgtTransitions.addr.CachedMemory.cachedMemoryPtr,
            pCThread->Calculation.MemoryLayout.TgtActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
            );

        pTgtThread = (TgtThread_t *)((os_bit8 *)pTgtThread + TgtThread_size);

    }

}


void CFuncInit_SFThreads(agRoot_t   *    hpRoot )
{
    CThread_t  *    pCThread        = CThread_ptr(hpRoot);
    SFThread_t            *pSFThread;
    os_bit32                  SFThread_cnt          = 0;
    pSFThread = pCThread->Calculation.MemoryLayout.SFThread.addr.CachedMemory.cachedMemoryPtr;

#ifndef __State_Force_Static_State_Tables__
    fiInstallStateMachine(&SFStateTransitionMatrix,
        &SFStateActionScalar,
        pCThread->Calculation.MemoryLayout.SFTransitions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.SFActions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.On_Card_MASK,
        &noActionUpdate
        );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    SFThread_cnt = pCThread->Calculation.MemoryLayout.SFThread.elements;
    while(SFThread_cnt-- > 0)
    {
        fiInitializeThread(&pSFThread->thread_hdr,
            hpRoot,
            threadType_SFThread,
            SFStateFree,
#ifdef __State_Force_Static_State_Tables__
            &SFStateTransitionMatrix,
            &SFStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
            pCThread->Calculation.MemoryLayout.SFTransitions.addr.CachedMemory.cachedMemoryPtr,
            pCThread->Calculation.MemoryLayout.SFActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
            );

        pSFThread->QueuedEvent = 0;

        pSFThread++;
        }

}

#ifdef _DvrArch_1_30_
void CFuncInit_IPThread(agRoot_t   *    hpRoot )
{
    CThread_t             *pCThread              = CThread_ptr(hpRoot);
    IPThread_t            *pIPThread;
    os_bit32               IPThread_cnt          = 0;

    pIPThread = pCThread->Calculation.MemoryLayout.IPThread.addr.CachedMemory.cachedMemoryPtr;

    pCThread->IP = pIPThread;

#ifndef __State_Force_Static_State_Tables__
    fiInstallStateMachine(&IPStateTransitionMatrix,
        &IPStateActionScalar,
        pCThread->Calculation.MemoryLayout.IPTransitions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.IPActions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.On_Card_MASK,
        &noActionUpdate
        );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    IPThread_cnt = pCThread->Calculation.MemoryLayout.IPThread.elements;

    fiInitializeThread(&pIPThread->thread_hdr,
        hpRoot,
        threadType_IPThread,
        IPStateIdle,
#ifdef __State_Force_Static_State_Tables__
        &IPStateTransitionMatrix,
        &IPStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
        pCThread->Calculation.MemoryLayout.IPTransitions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.IPActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
    );

    pIPThread->BroadcastDevice = (DevThread_t *)agNULL;
    pIPThread->LinkStatus.osData = (void *)agNULL;
    pIPThread->LinkStatus.LastReported = pIPThread->LinkStatus.MostRecent = 0;

    fiListInitHdr(&(pIPThread->OutgoingLink));
    fiListInitHdr(&(pIPThread->IncomingBufferLink));

    pIPThread->CompletedPkt = (PktThread_t *)agNULL;
}

void CFuncInit_PktThreads(agRoot_t   *    hpRoot )
{
    CThread_t  *    pCThread        = CThread_ptr(hpRoot);
    PktThread_t            *pPktThread;
    os_bit32                  PktThread_cnt          = 0;
    pPktThread = pCThread->Calculation.MemoryLayout.PktThread.addr.CachedMemory.cachedMemoryPtr;

#ifndef __State_Force_Static_State_Tables__
    fiInstallStateMachine(&PktStateTransitionMatrix,
        &PktStateActionScalar,
        pCThread->Calculation.MemoryLayout.PktTransitions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.PktActions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.On_Card_MASK,
        &noActionUpdate
        );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    PktThread_cnt = pCThread->Calculation.MemoryLayout.PktThread.elements;
    while(PktThread_cnt-- > 0)
    {
        fiInitializeThread(&pPktThread->thread_hdr,
            hpRoot,
            threadType_PktThread,
            PktStateReady,
#ifdef __State_Force_Static_State_Tables__
            &PktStateTransitionMatrix,
            &PktStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
            pCThread->Calculation.MemoryLayout.PktTransitions.addr.CachedMemory.cachedMemoryPtr,
            pCThread->Calculation.MemoryLayout.PktActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
            );

        pPktThread++;
    }
}
#endif /* _DvrArch_1_30_ was defined */

void CFuncInit_Threads(agRoot_t   *    hpRoot )
{
    CFuncInit_TgtThreads(  hpRoot );

    CFuncInit_CDBThreads(  hpRoot );

    CFuncInit_DirectoryDevThread( hpRoot);

    CFuncInit_SFThreads(  hpRoot );
#ifdef _DvrArch_1_30_
    CFuncInit_IPThread( hpRoot );
    CFuncInit_PktThreads( hpRoot );
#endif /* _DvrArch_1_30_ was defined */
}

void CFuncInit_DevLists(agRoot_t   *    hpRoot )
{
    CThread_t  *    pCThread        = CThread_ptr(hpRoot);

    fiListInitHdr(&(pCThread->Active_DevLink));
    fiListInitHdr(&(pCThread->Unknown_Slot_DevLink));
    fiListInitHdr(&(pCThread->Slot_Searching_DevLink));
    fiListInitHdr(&(pCThread->Prev_Active_DevLink));
    fiListInitHdr(&(pCThread->Prev_Unknown_Slot_DevLink));
    fiListInitHdr(&(pCThread->DevSelf_NameServer_DevLink));
    fiListInitHdr(&(pCThread->AWaiting_Login_DevLink));
    fiListInitHdr(&(pCThread->AWaiting_ADISC_DevLink));

    fiListInitHdr(&(pCThread->QueueFrozenWaitingSFLink));
    fiListInitHdr(&(pCThread->RSCN_Recieved_NameServer_DevLink));
  
  /* "Special list only reinit at initialize and reinitialize
    ** fiListInitHdr(&(pCThread->TimedOut_Slot_DevLink));
    */

}

void CFuncInit_FunctionPointers(agRoot_t   *    hpRoot )
{
    CThread_t  *    pCThread        = CThread_ptr(hpRoot);

    if (pCThread->Calculation.MemoryLayout.FCP_CMND.memLoc == inCardRam)
    {
        fiLogDebugString(pCThread->thread_hdr.hpRoot,
                                CFuncLogConsoleERROR,
                                "FCP_CMND.memLoc OnCard",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);

        pCThread->FuncPtrs.fiFillInFCP_CMND = &fiFillInFCP_CMND_OnCard;
    }
    else /* pCThread->Calculation.MemoryLayout.FCP_CMND.memLoc == inDmaMemory */
    {
        fiLogDebugString(pCThread->thread_hdr.hpRoot,
                                CFuncLogConsoleERROR,
                                "FCP_CMND.memLoc OffCard",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);
        pCThread->FuncPtrs.fiFillInFCP_CMND = &fiFillInFCP_CMND_OffCard;
    }

    if (pCThread->Calculation.MemoryLayout.FCP_RESP.memLoc == inCardRam)
    {
        fiLogDebugString(pCThread->thread_hdr.hpRoot,
                                CFuncLogConsoleERROR,
                                "FCP_RESP.memLoc OnCard",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);
        pCThread->FuncPtrs.fiFillInFCP_RESP = &fiFillInFCP_RESP_OnCard;
    }
    else /* pCThread->Calculation.MemoryLayout.FCP_RESP.memLoc == inDmaMemory */
    {
        fiLogDebugString(pCThread->thread_hdr.hpRoot,
                                CFuncLogConsoleERROR,
                                "FCP_RESP.memLoc OffCard",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);
        pCThread->FuncPtrs.fiFillInFCP_RESP = &fiFillInFCP_RESP_OffCard;
    }

    if (pCThread->Calculation.MemoryLayout.ESGL.memLoc == inCardRam)
    {
        fiLogDebugString(pCThread->thread_hdr.hpRoot,
                                CFuncLogConsoleERROR,
                                "ESGL.memLoc OnCard",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);

        pCThread->FuncPtrs.ESGLAlloc       = &ESGLAlloc_OnCard;
        pCThread->FuncPtrs.ESGLAllocCancel = &ESGLAllocCancel_OnCard;
        pCThread->FuncPtrs.ESGLFree        = &ESGLFree_OnCard;
        pCThread->FuncPtrs.fillESGL        = &fill_ESGL_onCard;
    }
    else /* pCThread->Calculation.MemoryLayout.ESGL.memLoc == inDmaMemory */
    {
        fiLogDebugString(pCThread->thread_hdr.hpRoot,
                                CFuncLogConsoleERROR,
                                "ESGL.memLoc OffCard",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);

        pCThread->FuncPtrs.ESGLAlloc       = &ESGLAlloc_OffCard;
        pCThread->FuncPtrs.ESGLAllocCancel = &ESGLAllocCancel_OffCard;
        pCThread->FuncPtrs.ESGLFree        = &ESGLFree_OffCard;
        pCThread->FuncPtrs.fillESGL        = &fill_ESGL_offCard;
    }

    if (pCThread->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        fiLogDebugString(pCThread->thread_hdr.hpRoot,
                                CFuncLogConsoleERROR,
                                "SF_CMND.memLoc OnCard",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);

        pCThread->FuncPtrs.fiFillInPLOGI = &fiFillInPLOGI_OnCard;
        pCThread->FuncPtrs.fiFillInFLOGI = &fiFillInFLOGI_OnCard;
        pCThread->FuncPtrs.fiFillInLOGO  = &fiFillInLOGO_OnCard;
        pCThread->FuncPtrs.fiFillInPRLI  = &fiFillInPRLI_OnCard;
        pCThread->FuncPtrs.fiFillInPRLO  = &fiFillInPRLO_OnCard;
        pCThread->FuncPtrs.fiFillInADISC = &fiFillInADISC_OnCard;
        pCThread->FuncPtrs.fiFillInSCR   = &fiFillInSCR_OnCard;
        pCThread->FuncPtrs.fiFillInSRR   = &fiFillInSRR_OnCard;
        pCThread->FuncPtrs.fiFillInREC   = &fiFillInREC_OnCard;
    }
    else /* pCThread->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        fiLogDebugString(pCThread->thread_hdr.hpRoot,
                                CFuncLogConsoleERROR,
                                "SF_CMND.memLoc OffCard",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);
        pCThread->FuncPtrs.fiFillInPLOGI = &fiFillInPLOGI_OffCard;
        pCThread->FuncPtrs.fiFillInFLOGI = &fiFillInFLOGI_OffCard;
        pCThread->FuncPtrs.fiFillInLOGO  = &fiFillInLOGO_OffCard;
        pCThread->FuncPtrs.fiFillInPRLI  = &fiFillInPRLI_OffCard;
        pCThread->FuncPtrs.fiFillInPRLO  = &fiFillInPRLO_OffCard;
        pCThread->FuncPtrs.fiFillInADISC = &fiFillInADISC_OffCard;
        pCThread->FuncPtrs.fiFillInSCR   = &fiFillInSCR_OffCard;
        pCThread->FuncPtrs.fiFillInSRR   = &fiFillInSRR_OffCard;
        pCThread->FuncPtrs.fiFillInREC   = &fiFillInREC_OffCard;
    }


    /* ERQ Entries */

    switch (pCThread->Calculation.MemoryLayout.ERQ.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
#ifdef _DvrArch_1_30_
            pCThread->FuncPtrs.Pkt_IRB_Init = &PktFuncIRB_OffCardInit;
#endif /* _DvrArch_1_30_ was defined */
            pCThread->FuncPtrs.SF_IRB_Init = &SFFuncIRB_OffCardInit;
            pCThread->FuncPtrs.CDBFuncIRB_Init = &CDBFuncIRB_offCardInit;
            break;

        case inCardRam:
             fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
            pCThread->FuncPtrs.SF_IRB_Init = &SFFuncIRB_OnCardInit;
            pCThread->FuncPtrs.CDBFuncIRB_Init = &CDBFuncIRB_onCardInit;
            break;

        default: Fc_ERROR(hpRoot);
    }


    switch (pCThread->Calculation.MemoryLayout.ERQConsIndex.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.ERQConsIndex OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);


            pCThread->FuncPtrs.GetERQConsIndex = &CFuncGetDmaMemERQConsIndex;
            pCThread->FuncPtrs.WaitForERQ      = &WaitForERQ_ConsIndexOffCard;
            pCThread->FuncPtrs.WaitForERQEmpty = &WaitForERQEmpty_ConsIndexOffCard;
            *(ERQConsIndex_t *)(pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryPtr) = 0;
            break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "ERQ.ERQConsIndex OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

            pCThread->FuncPtrs.GetERQConsIndex = &CFuncGetCardRamERQConsIndex;
            pCThread->FuncPtrs.WaitForERQ      = &WaitForERQ_ConsIndexOnCard;
            pCThread->FuncPtrs.WaitForERQEmpty = &WaitForERQEmpty_ConsIndexOnCard;
            osCardRamWriteBit32(hpRoot,
                    pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamOffset,
                    0
                    );

            break;

        default: Fc_ERROR(hpRoot);
    }


    /* SFQ Entries */

    switch (pCThread->Calculation.MemoryLayout.SFQ.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "SFQ.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

             pCThread->FuncPtrs.fiLinkSvcProcessSFQ = &fiLinkSvcProcessSFQ_OffCard;
             pCThread->FuncPtrs.fiCTProcessSFQ      = &fiCTProcessSFQ_OffCard;
             pCThread->FuncPtrs.fiSF_FCP_ProcessSFQ = &fiSF_FCP_ProcessSFQ_OffCard;
             break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "SFQ.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
             pCThread->FuncPtrs.fiLinkSvcProcessSFQ = &fiLinkSvcProcessSFQ_OnCard;
             pCThread->FuncPtrs.fiCTProcessSFQ      = &fiCTProcessSFQ_OnCard;
             pCThread->FuncPtrs.fiSF_FCP_ProcessSFQ = &fiSF_FCP_ProcessSFQ_OnCard;
             break;

        default: Fc_ERROR(hpRoot);
    }

    /* IMQ Entries */
    pCThread->HostCopy_IMQConsIndex=0;

    switch( pCThread->Calculation.MemoryLayout.IMQ.memLoc)
    {
        case inDmaMemory:

            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "IMQ.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

            pCThread->FuncPtrs.Proccess_IMQ    =&CFuncOffCardProcessIMQ;

            break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "IMQ.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
            pCThread->FuncPtrs.Proccess_IMQ    = &CFuncOnCardProcessIMQ;
            break;

        default: Fc_ERROR(hpRoot);
    }

    switch (pCThread->Calculation.MemoryLayout.IMQProdIndex.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "IMQProdIndex.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

             pCThread->FuncPtrs.GetIMQProdIndex = &CFuncGetDmaMemIMQProdIndex;
             break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "IMQProdIndex.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
             pCThread->FuncPtrs.GetIMQProdIndex = &CFuncGetCardRamIMQProdIndex;
             osCardRamWriteBit32(hpRoot,
                    pCThread->Calculation.MemoryLayout.IMQProdIndex.addr.CardRam.cardRamOffset,
                    0
                    );
             break;

        default: Fc_ERROR(hpRoot);
    }

    /* SEST Entries */

    switch (pCThread->Calculation.MemoryLayout.SEST.memLoc)
    {
        case inDmaMemory:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "SEST.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

            pCThread->FuncPtrs.fiFillInFCP_SEST = &fiFillInFCP_SEST_OffCard;
            pCThread->FuncPtrs.fillLocalSGL     = &fill_Loc_SGL_offCard;

            pCThread->FuncPtrs.FCP_Completion = &CFuncSEST_offCard_FCPCompletion;
            if(pCThread->Calculation.MemoryLayout.ESGL.memLoc == inDmaMemory)
            {
                pCThread->FuncPtrs.upSEST           = &fillptr_SEST_offCard_ESGL_offCard;

            }
            else
            {
                pCThread->FuncPtrs.upSEST           = &fillptr_SEST_offCard_ESGL_onCard;
            }

            break;

        case inCardRam:
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CFuncLogConsoleERROR,
                    "SEST.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
             pCThread->FuncPtrs.FCP_Completion = &CFuncSEST_onCard_FCPCompletion;

             pCThread->FuncPtrs.fiFillInFCP_SEST = &fiFillInFCP_SEST_OnCard;
             pCThread->FuncPtrs.fillLocalSGL     = &fill_Loc_SGL_onCard;
            if(pCThread->Calculation.MemoryLayout.ESGL.memLoc == inDmaMemory)
            {
                 pCThread->FuncPtrs.upSEST           = &fillptr_SEST_onCard_ESGL_offCard;

            }
            else
            {
                 pCThread->FuncPtrs.upSEST           = &fillptr_SEST_onCard_ESGL_onCard;
            }
            break;

        default: Fc_ERROR(hpRoot);
    }


}

void CFuncCoreReset(agRoot_t   *    hpRoot ){
    os_bit32 Reset_Reg;

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "CFuncCoreReset (%p)",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    0,0,0,0,0,0,0,0);

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Exit_Loop);

    osStallThread(hpRoot,1009);

    Reset_Reg = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control);

    Reset_Reg |=  ChipIOUp_TachLite_Control_CRS;
    Reset_Reg &= ~ ChipIOUp_TachLite_Control_GP4; /* GP04 Always Low for Janus */

    CFuncWriteTL_ControlReg( hpRoot, Reset_Reg);

    osStallThread(hpRoot,1008);

    Reset_Reg &=  ~ ChipIOUp_TachLite_Control_CRS;
    Reset_Reg &= ~ ChipIOUp_TachLite_Control_GP4; /* GP04 Always Low for Janus */

    CFuncWriteTL_ControlReg( hpRoot, Reset_Reg);

}


agBOOLEAN CFuncNewInitFM(agRoot_t   *    hpRoot )
{
    CThread_t         *pCThread = CThread_ptr(hpRoot);
    os_bit32 AL_PA_Register = 0;
    os_bit32 FM_Status = 0;
    FC_Port_ID_t    Port_ID;
    agFCChanInfo_t *Self_info = &(pCThread->ChanInfo);

    AL_PA_Register =  (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 0xFF000000 )
                                    >>  ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT;

    if (pCThread->InitAsNport)
    {
        FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
        

        if( (FM_Status & ChipIOUp_Frame_Manager_Status_PSM_MASK) ==
                                 ChipIOUp_Frame_Manager_Status_PSM_ACTIVE )
        {
            pCThread->ChanInfo.CurrentAddress.AL_PA = 0;

            Port_ID.Struct_Form.reserved = 0;
            Port_ID.Struct_Form.Domain = pCThread->ChanInfo.CurrentAddress.Domain;
            Port_ID.Struct_Form.Area   = pCThread->ChanInfo.CurrentAddress.Area;
            Port_ID.Struct_Form.AL_PA  = pCThread->ChanInfo.CurrentAddress.AL_PA;

            if (FM_Status & ChipIOUp_Frame_Manager_Status_LF ||
                    FM_Status & ChipIOUp_Frame_Manager_Status_OLS)
            {
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Detected NOS/OLS or Link Failure %08X FM Config %08X ALPA %08X",
                            (char *)agNULL,(char *)agNULL,
                            agNULL,agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                            osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                            0,0,0,0,0);

                    /* Since we are not going to be polling and reading the IMQ, we better
                       clear the FM status register so that when we do read the frame manager
                       as a result of the interrupt, we do not process this LF or OLS again.
                     */

                    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, (ChipIOUp_Frame_Manager_Status_LF | ChipIOUp_Frame_Manager_Status_OLS));
                    
           }


            pCThread->DeviceSelf =  DevThreadAlloc( hpRoot,Port_ID );
            fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Clear FM DevSelf %x FM_Status %x",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    FM_Status,
                    0,
                    0,0,0,0,0);

            pCThread->DeviceSelf->DevSlot = DevThreadFindSlot(hpRoot,
                                                      Self_info->CurrentAddress.Domain,
                                                      Self_info->CurrentAddress.Area,
                                                      Self_info->CurrentAddress.AL_PA,
                                                      (FC_Port_Name_t *)(&Self_info->PortWWN));

            fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
            fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);

            return (agTRUE);
        }

        return (agFALSE);
    }
    else /* NOT InitAsNport */
    {
        if( pCThread->DeviceSelf == agNULL)
        {
            return agFALSE;
        }

        if (AL_PA_Register != 0x00 &&  AL_PA_Register != 0xFF)
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "%s FM Status %08X FM Config %08X",
                        "CFuncNewInitFM",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                        0,0,0,0,0,0);

            fiLogDebugString(hpRoot,
                        CFuncLogConsoleERROR,
                        "F  %s HA %x CA %x FA %x AL_PA_Register %x",
                        "CFuncNewInitFM",(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)(pCThread->ChanInfo.HardAddress.AL_PA),
                        (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                        AL_PA_Register,0,0,0,0,0);
            return agTRUE;

        }
        else
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "%s FAILED  FM Status %08X FM Config %08X",
                        "CFuncNewInitFM",(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                        0,0,0,0,0,0);
           fiLogDebugString(hpRoot,
                        CFuncLogConsoleERROR,
                        "F  %s HA %x CA %x FA %x AL_PA_Register %x",
                        "CFuncNewInitFM",(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)(pCThread->ChanInfo.HardAddress.AL_PA),
                        (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                        AL_PA_Register,0,0,0,0,0);

            return agFALSE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\cfimq.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/CFIMQ.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 10/31/00 10:39a $

Purpose:

  This file implements IMQ functions called by the FC Layer Card State Machine.

--*/

#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/fcstruct.h"
#include "../h/state.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/linksvc.h"
#include "../h/cmntrans.h"
#ifdef _DvrArch_1_30_
#include "../h/ip.h"
#include "../h/ipstate.h"
#endif /* _DvrArch_1_30_ was defined */

#include "../h/flashsvc.h"
#include "../h/timersvc.h"

#include "../h/cstate.h"
#include "../h/cfunc.h"
#include "../h/devstate.h"
#include "../h/cdbstate.h"
#include "../h/sf_fcp.h"
#include "../h/sfstate.h"

#include "../h/queue.h"
#include "../h/cdbsetup.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "fcstruct.h"
#include "state.h"

#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"
#include "linksvc.h"
#include "cmntrans.h"
#ifdef _DvrArch_1_30_
#include "ip.h"
#include "ipstate.h"
#endif /* _DvrArch_1_30_ was defined */

#include "flashsvc.h"
#include "timersvc.h"

#include "cstate.h"
#include "cfunc.h"
#include "devstate.h"
#include "cdbstate.h"
#include "sf_fcp.h"
#include "sfstate.h"

#include "queue.h"
#include "cdbsetup.h"
#endif  /* _New_Header_file_Layout_ */


#ifndef __State_Force_Static_State_Tables__
extern actionUpdate_t noActionUpdate;
#endif /* __State_Force_Static_State_Tables__ was not defined */

extern os_bit8 Alpa_Index[256];

/*+
  Function: CFuncInterruptPoll
   Purpose: Called when pollingCount number of events need to be completed.
 Called By: fiResetDevice
            CActionVerify_AL_PA
            CActionDoFlogi
            CActionNormal
            CActionLoopFail
            CActionFindDeviceUseAllALPAs
            CActionFindDeviceUseLoopMap
            CActionFindPtToPtDevice
            CActionFindDeviceUseNameServer
            CActionFindDeviceUseNameServer
            CActionExternalLogoutRecovery
            CActionDoExternalDeviceReset
            CActionDoRFT_ID
            CActionDoDiPlogi
            CActionDoGID_FT
            CActionDoSCR
            CActionSCRSuccess
            fcInitializeChannel
            fcStartIO

     Calls: CFunc_Always_Enable_Queues
            osChipIOUpReadBit32
            CFuncFMCompletion
            osStallThread
            fiTimerTick
            Proccess_IMQ
-*/
agBOOLEAN CFuncInterruptPoll(
                         agRoot_t *hpRoot,
                         os_bit32 * pollingCount
                       )
{
    CThread_t           * CThread         = CThread_ptr(hpRoot);
    os_bit32              PollingCalls    = 0;
    agBOOLEAN             TimeoutOccured  = agFALSE;    
    os_bit32              Original_CState = CThread->thread_hdr.currentState;

    fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "Enter pollingCount %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        *pollingCount,
                        0,0,0,0,0,0,0);


    while ( *pollingCount > 0)
    {
        PollingCalls++;
        if( CThread->thread_hdr.currentState == CStateLIPEventStorm         ||
            CThread->thread_hdr.currentState == CStateElasticStoreEventStorm   )
        {
            return(agTRUE);
        }

        if(Original_CState != CThread->thread_hdr.currentState  )
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "State Change during Poll Was %d Now %d FDCCnt %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Original_CState,
                    CThread->thread_hdr.currentState ,
                    CThread->FindDEV_pollingCount,
                    0,0,0,0,0);
            return(agTRUE);
        }
/*
        if( (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) &
                                        ChipIOUp_Frame_Manager_Status_LSM_MASK) ==
                                        ChipIOUp_Frame_Manager_Status_LSM_Loop_Fail )
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "LSM Loop Fail FM Status %08X FM Config %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);

            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Loop Fail TL Status %08X TL Control %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0,0);
            return(agTRUE);
        }
*/
        if ( CFunc_Always_Enable_Queues(hpRoot ) )
        {
/*
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) %s Loop Fail Queues Frozen after Enable",
                        "CFuncInterruptPoll",(char *)agNULL,
                        hpRoot,agNULL,
                        0,0,0,0,0,0,0,0);
*/
        }


        if(PollingCalls > 2 * ( SF_EDTOV / Interrupt_Polling_osStallThread_Parameter)){

               fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "PollingCalls  TIMEOUT Polling Count %x FM %08X InIMQ %x TL status %08X Qf %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    *pollingCount,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    CThread->ProcessingIMQ,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    CFunc_Queues_Frozen( hpRoot ),
                    0,0,0);

            PollingCalls=0;
            return(agTRUE);
        }

        if( ! PollingCalls > (100000 / Interrupt_Polling_osStallThread_Parameter) )
        {
            TimeoutOccured = agTRUE;
        }

        if( ! PollingCalls % 1000 )
        {

            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "PollingCalls  Queues FROZEN Polling Count %x FM %08X InIMQ %x TL status %08X Qf %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    *pollingCount,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    CThread->ProcessingIMQ,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    CFunc_Queues_Frozen( hpRoot ),
                    0,0,0);

            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "CFuncIMQ_Interrupt_Pending %x Int %08X  Hc IMQ Con %x IMQ Prod %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CFuncIMQ_Interrupt_Pending( hpRoot ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                    CThread->HostCopy_IMQConsIndex,
                    CThread->FuncPtrs.GetIMQProdIndex(hpRoot),
                    0,0,0,0);


           if(osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) &
                   (~ ( ChipIOUp_Frame_Manager_Status_LP      |
                        ChipIOUp_Frame_Manager_Status_LSM_MASK   )) )
            {
                if (CThread->HostCopy_IMQConsIndex == CThread->FuncPtrs.GetIMQProdIndex(hpRoot))
                {
                    CFuncFMCompletion(hpRoot);
                }
                else
                {
                    continue;
                }
            }
            else
            {
                PollingCalls=0;
                return(agTRUE);
            }
        }

        osStallThread(
                       hpRoot,
                       Interrupt_Polling_osStallThread_Parameter
                     );

        fiTimerTick(
                       hpRoot,
                       Interrupt_Polling_osStallThread_Parameter
                     );

        if( !CThread->FuncPtrs.Proccess_IMQ(hpRoot))
        {
            if(osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) &
                   (~ ( ChipIOUp_Frame_Manager_Status_LP      |
                        ChipIOUp_Frame_Manager_Status_LSM_MASK   )) )
            {
                if (CThread->HostCopy_IMQConsIndex == CThread->FuncPtrs.GetIMQProdIndex(hpRoot))
                {
                    CFuncFMCompletion(hpRoot);
                }
            }
        }
    }
    fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Leave pollingCount %x PollingCalls %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    *pollingCount,
                    PollingCalls,
                    0,0,0,0,0,0);
    if( TimeoutOccured )
    {
        fiLogString(hpRoot,
                    "%s Long Time %x PC %x",
                    "CFuncInterruptPoll",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    *pollingCount,
                    PollingCalls,
                    0,0,0,0,0,0);

    }

    return(agFALSE);

}


/*****************************************************************************************************************/

/*+
  Function: CFuncOffCardProcessIMQ
   Purpose: Proccess inbound message queue for inDmaMemory located message queue.
            Accessed via CThread->FuncPtrs.Proccess_IMQ
 Called By: CFuncInterruptPoll
            CFuncInteruptDelay
            CFuncLoopDownPoll
            CFuncFreezeQueuesPoll
            CFuncAll_clear
            CFuncTakeOffline
            CFuncWaitForFCP
            CActionInitFM
            CActionVerify_AL_PA
            CActionFreeSFthread
            CActionSuccess
            CActionLoopFail
            CActionReInitFM
            CActionInitializeFailed
            CActionFindDeviceUseAllALPAs
            DevActionDoPlogi
            DevActionDoPrli
            DevActionPrliDone
            DevActionLogout
            DevActionDeviceResetSoft
            DevActionDeviceResetHard
            fcDelayedInterruptHandler
            fcInitializeChannel
            fcResetDevice
            fcStartIO
            fcTimerTick
            SFActionDoPlogi
            SFActionDoPrli
     Calls: FuncPtrs.GetIMQProdIndex
            FuncPtrs.FCP_Completion
            CFuncFMCompletion
            CFuncOutBoundCompletion
            CFuncErrorIdle
            CFuncErrorFCP_Frozen
            osChipIOLoWriteBit
-*/
agBOOLEAN CFuncOffCardProcessIMQ(
                agRoot_t *hpRoot
                )
{
#ifndef __MemMap_Force_On_Card__
    /*
        Returns agTRUE if there was a problem  agFALSE if there was something to do

    */

    CThread_t  * pCThread = CThread_ptr(hpRoot);

    os_bit32 tempIMQProdIndex;
    os_bit32 tempCMType;
    os_bit32 tempCMWord1;

    os_bit32 num_IMQel;

    CM_Unknown_t * pGenericCM;

#ifdef OSLayer_Stub_USESTATEMACROS

    fiList_t            * pList;
    SFThread_Request_t  * pSFreq;
    SFThread_t          * pSFThread;

#endif /*OSLayer_Stub_USESTATEMACROS*/

    if (pCThread->ProcessingIMQ == agTRUE)
    {
        return agFALSE;
    }
    pCThread->ProcessingIMQ = agTRUE;

    tempIMQProdIndex= pCThread->FuncPtrs.GetIMQProdIndex(hpRoot);

    if (pCThread->HostCopy_IMQConsIndex == tempIMQProdIndex)
    {
#ifndef Performance_Debug
        fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "pCThread->HostCopy_IMQConsIndex == tempIMQProdIndex CDBCnt %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->CDBpollingCount,
                        0,0,0,0,0,0,0);
#endif /* Performance_Debug */

        pCThread->ProcessingIMQ = agFALSE;
        return agFALSE;
    }

    /*
    ** an INT (IMQ entry received) interrupt occured. Interrupt cleared by
    ** updating the IMQ consumer index register.
    */

    /*
    ** while there are IMQ completion messages to process
    */

    num_IMQel = pCThread->Calculation.MemoryLayout.IMQ.elements;

    while (pCThread->HostCopy_IMQConsIndex != pCThread->FuncPtrs.GetIMQProdIndex(hpRoot))
    {
        /* Big_Endian_Code */
        AFTERIO(hpRoot);
        pGenericCM  = pCThread->Calculation.MemoryLayout.IMQ.addr.DmaMemory.dmaMemoryPtr;
        pGenericCM += pCThread->HostCopy_IMQConsIndex;
        tempCMType  = pGenericCM->INT__CM_Type & CM_Unknown_CM_Type_MASK;
       /*
       ** get the completion message type
       */

#ifndef Performance_Debug
       fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "tempCMType %08X IMQ Consumer %X Temp IMQ %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    tempCMType,
                    pCThread->HostCopy_IMQConsIndex,
                    tempIMQProdIndex,0,0,0,0,0);
#endif /* Performance_Debug */

        switch (tempCMType) {

            case  CM_Unknown_CM_Type_Inbound_FCP_Exchange:
                tempCMWord1 = pGenericCM->Unused_DWord_1;
#ifndef Performance_Debug
                fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot (%p) Inbound_FCP_Exchange %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        tempCMWord1,
                        0,0,0,0,0,0);
#endif /* Performance_Debug */

#ifdef __FC_Layer_Loose_IOs
                pCThread->IOsTotalCompleted += 1;
#endif /*  __FC_Layer_Loose_IOs  */

                pCThread->FuncPtrs.FCP_Completion(hpRoot,tempCMWord1);
                break;

            case  CM_Unknown_CM_Type_Frame_Manager:
/*
                fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot(%p) Frame_Manager %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        pGenericCM->Unused_DWord_1,
                        0,0,0,0,0,0);
*/
                CFuncFMCompletion(hpRoot);
                break;

            case  CM_Unknown_CM_Type_Inbound:
                fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot(%p) Inbound %08X  %08X %08X %08X HC %3x RI %3x",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        pGenericCM->Unused_DWord_1,
                        pGenericCM->Unused_DWord_2,
                        pGenericCM->Unused_DWord_3,
                        pCThread->HostCopy_IMQConsIndex,
                        pCThread->FuncPtrs.GetIMQProdIndex(hpRoot),
                        0,0);

                CFuncInBoundCompletion(hpRoot,pGenericCM->Unused_DWord_1,pGenericCM->Unused_DWord_2,pGenericCM->Unused_DWord_3);

                break;

            case  CM_Unknown_CM_Type_Outbound:

                fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot(%p) Outbound %08X  %08X %08X %08X HC %3x RI %3x",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        pGenericCM->Unused_DWord_1,
                        pGenericCM->Unused_DWord_2,
                        pGenericCM->Unused_DWord_3,
                        pCThread->HostCopy_IMQConsIndex,
                        pCThread->FuncPtrs.GetIMQProdIndex(hpRoot),
                        0,0);

                CFuncOutBoundCompletion(hpRoot,
                        pGenericCM->Unused_DWord_2,
                        pGenericCM->Unused_DWord_3);

                /* Add SF Error code here */
                break;

            case  CM_Unknown_CM_Type_Error_Idle:

                fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot(%p) Error_Idle %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        pGenericCM->Unused_DWord_1,
                        0,0,0,0,0,0);

                CFuncErrorIdle(hpRoot);

                break;

            case  CM_Unknown_CM_Type_ERQ_Frozen:

                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) ERQ_Frozen: %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        pGenericCM->Unused_DWord_1,
                        0,0,0,0,0,0);

                CFuncErrorERQFrozen(hpRoot);

                break;

            case  CM_Unknown_CM_Type_FCP_Assists_Frozen:

                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) FCP_Assists_Frozen %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        pGenericCM->Unused_DWord_1,
                        0,0,0,0,0,0);

                CFuncErrorFCP_Frozen(hpRoot);

                break;

            case  CM_Unknown_CM_Type_Class_2_Frame_Header:

                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "Class_2_Frame_Header %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        tempCMType,
                        pGenericCM->Unused_DWord_1,
                        0,0,0,0,0,0);
                break;

            case  CM_Unknown_CM_Type_Class_2_Sequence_Received:
                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "Class_2_Sequence_Received %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        tempCMType,
                        pGenericCM->Unused_DWord_1,
                        0,0,0,0,0,0);
                break;

            default:    fiLogDebugString(hpRoot,
                            CStateLogConsoleLevel,
                            "Unknown IMQ Completion Type %08X %08X %08X %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            tempCMType,
                            pGenericCM->Unused_DWord_1,
                            pGenericCM->Unused_DWord_2,
                            pGenericCM->Unused_DWord_3,
                            pGenericCM->Unused_DWord_4,
                            0,0,0);
                        fiLogDebugString(hpRoot,
                            CStateLogConsoleLevel,
                            "IMQ Empty ? %X  Prod %X Cons %X ELM %X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            0 /* IMQ_EMPTY(pCThread->FuncPtrs.GetIMQProdIndex(hpRoot), pCThread->HostCopy_IMQConsIndex ,num_IMQel ) */,
                            pCThread->FuncPtrs.GetIMQProdIndex(hpRoot),
                            pCThread->HostCopy_IMQConsIndex ,
                            num_IMQel,
                            0,0,0,0);
                        /* Leave it alone since it is not reinitialized
                            pCThread->HostCopy_IMQConsIndex = pCThread->FuncPtrs.GetIMQProdIndex(hpRoot);
                        */
                        /*Prod index has a value  ? set consumer equal to producer ?*/
            }
            ROLL(pCThread->HostCopy_IMQConsIndex,num_IMQel);
        }
    osChipIOLoWriteBit32(hpRoot, ChipIOLo_IMQ_Consumer_Index, pCThread->HostCopy_IMQConsIndex);
    pCThread->ProcessingIMQ = agFALSE;

#ifdef ENABLE_INTERRUPTS_IN_IMQ
    if( ! (pCThread->thread_hdr.currentState == CStateLIPEventStorm         ||
            pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm   ))
    {
        CFuncEnable_Interrupts(hpRoot,ChipIOUp_INTEN_INT);
    }
#endif /* ENABLE_INTERRUPTS_IN_IMQ */
#endif /* __MemMap_Force_Off_Card__ was not defined */
    return agTRUE;

}

/*+
  Function: CFuncOnCardProcessIMQ
   Purpose: Proccess inbound message queue for inCardRam located message queue.
            Accessed via CThread->FuncPtrs.Proccess_IMQ
 Called By: CFuncInterruptPoll
            CFuncInteruptDelay
            CFuncLoopDownPoll
            CFuncFreezeQueuesPoll
            CFuncAll_clear
            CFuncTakeOffline
            CFuncWaitForFCP
            CActionInitFM
            CActionVerify_AL_PA
            CActionFreeSFthread
            CActionSuccess
            CActionLoopFail
            CActionReInitFM
            CActionInitializeFailed
            CActionFindDeviceUseAllALPAs
            DevActionDoPlogi
            DevActionDoPrli
            DevActionPrliDone
            DevActionLogout
            DevActionDeviceResetSoft
            DevActionDeviceResetHard
            fcDelayedInterruptHandler
            fcInitializeChannel
            fcResetDevice
            fcStartIO
            fcTimerTick
            SFActionDoPlogi
            SFActionDoPrli
     Calls: FuncPtrs.GetIMQProdIndex
            osCardRamReadBit32
            FuncPtrs.FCP_Completion
            CFuncFMCompletion
            CFuncOutBoundCompletion
            CFuncErrorIdle
            CFuncErrorFCP_Frozen
            osChipIOLoWriteBit
-*/
agBOOLEAN CFuncOnCardProcessIMQ(
                agRoot_t *hpRoot
                )
{
#ifndef __MemMap_Force_Off_Card__
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    os_bit32 tempIMQProdIndex;
    os_bit32 tempCMType;
    os_bit32 tempCMWord1;

    os_bit32 num_IMQel;

    os_bit32 GenericCM_offset;

    if (pCThread->ProcessingIMQ == agTRUE)
    {
        return agFALSE;
    }
    pCThread->ProcessingIMQ = agTRUE;

    tempIMQProdIndex= pCThread->FuncPtrs.GetIMQProdIndex(hpRoot);

    if (pCThread->HostCopy_IMQConsIndex == tempIMQProdIndex)
    {
#ifndef Performance_Debug
        fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "pCThread->HostCopy_IMQConsIndex == tempIMQProdIndex CDBCnt %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->CDBpollingCount,
                        0,0,0,0,0,0,0);
#endif /* Performance_Debug */
        pCThread->ProcessingIMQ = agFALSE;
        return agFALSE;
    }

    /*
    ** an INT (IMQ entry received) interrupt occured. Interrupt cleared by
    ** updating the IMQ consumer index register.
    */

    /*
    ** while there are IMQ completion messages to process
    */

    num_IMQel = pCThread->Calculation.MemoryLayout.IMQ.elements;

    while (pCThread->HostCopy_IMQConsIndex != pCThread->FuncPtrs.GetIMQProdIndex(hpRoot))
    {
        /* Big_Endian_Code */
        AFTERIO(hpRoot);
        GenericCM_offset = pCThread->Calculation.MemoryLayout.IMQ.addr.CardRam.cardRamOffset;
        GenericCM_offset += (pCThread->HostCopy_IMQConsIndex * sizeof(CM_Unknown_t));
        tempCMType  = osCardRamReadBit32(hpRoot,GenericCM_offset ) & CM_Unknown_CM_Type_MASK;

       /*
       ** get the completion message type
       */

        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "tempCMType %08X IMQ Consumer %X Temp IMQ %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    tempCMType,
                    pCThread->HostCopy_IMQConsIndex,
                    pCThread->FuncPtrs.GetIMQProdIndex(hpRoot),0,0,0,0,0);


        switch (tempCMType) {

            case  CM_Unknown_CM_Type_Inbound_FCP_Exchange:
                tempCMWord1 = osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1));
#ifndef Performance_Debug
                fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot(%p) Inbound_FCP_Exchange %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        tempCMWord1,
                        0,0,0,0,0,0);
#endif /* Performance_Debug */
                pCThread->FuncPtrs.FCP_Completion(hpRoot,tempCMWord1);
                break;
            case  CM_Unknown_CM_Type_Frame_Manager:
/*
                fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot(%p) Frame_Manager %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        0,0,0,0,0,0);
*/
                CFuncFMCompletion(hpRoot);
                break;

            case  CM_Unknown_CM_Type_Inbound:
                fiLogDebugString(hpRoot,
                        CSTATE_NOISE(hpRoot,CStateNormal),
                        "hpRoot(%p) Inbound %08X  %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_2)),
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_3)),
                        0,0,0,0);

                CFuncInBoundCompletion(hpRoot,
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_2)),
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_3)));

                break;
            case  CM_Unknown_CM_Type_Outbound:
                fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot(%p) Outbound %08X   %08X %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_2)),
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_3)),
                        0,0,0,0);

                CFuncOutBoundCompletion(hpRoot,
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_2)),
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_3)) );

                /* Add SF Error code here */

                break;
            case  CM_Unknown_CM_Type_Error_Idle:

                fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot(%p) Error_Idle %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        0,0,0,0,0,0);

                CFuncErrorIdle(hpRoot);

                break;

            case  CM_Unknown_CM_Type_ERQ_Frozen:

                  fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) ERQ_Frozen: %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        0,0,0,0,0,0);

                CFuncErrorERQFrozen(hpRoot);

                break;
            case  CM_Unknown_CM_Type_FCP_Assists_Frozen:

                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) FCP_Assists_Frozen %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        tempCMType,
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        0,0,0,0,0,0);

                CFuncErrorFCP_Frozen(hpRoot);

                break;
            case  CM_Unknown_CM_Type_Class_2_Frame_Header:

                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "Class_2_Frame_Header CM type  %08X %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        tempCMType,
                        osCardRamReadBit32(hpRoot,GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        0,0,0,0,0,0);
                break;
            case  CM_Unknown_CM_Type_Class_2_Sequence_Received:
                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "Class_2_Sequence_Received CM type  %08X Dword_1 %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        tempCMType,
                        osCardRamReadBit32(hpRoot,
                            GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        0,0,0,0,0,0);

                break;
            default:
                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "Unknown  CM type  %08X Dword_1 %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        tempCMType,
                        osCardRamReadBit32(hpRoot,
                           GenericCM_offset+hpFieldOffset(CM_Unknown_t,Unused_DWord_1)),
                        0,0,0,0,0,0);

            }
            ROLL(pCThread->HostCopy_IMQConsIndex,num_IMQel);
        }
    osChipIOLoWriteBit32(hpRoot, ChipIOLo_IMQ_Consumer_Index, pCThread->HostCopy_IMQConsIndex);
    pCThread->ProcessingIMQ = agFALSE;

#ifdef ENABLE_INTERRUPTS_IN_IMQ
    if( ! (pCThread->thread_hdr.currentState == CStateLIPEventStorm         ||
            pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm   ))
    {
        CFuncEnable_Interrupts(hpRoot,ChipIOUp_INTEN_INT);
    }
#endif /* ENABLE_INTERRUPTS_IN_IMQ */

#endif /* __MemMap_Force_Off_Card__ was not defined */
    return agTRUE;
}

/*+
  Function: CFuncProcessNportFMCompletion
   Purpose: Handles Frame manager completion messages when chip is using port state machine.
            That is when InitAsNport is true.  
            If Link reset is required it is done in this routine (LF_1 of LF_2).

 Called By: CFuncFMCompletion.
     Calls: osChipIOUpReadBit32
            osChipIOUpWriteBit32
            CEventGoToInitializeFailed
            CEventAsyncLoopEventDetected
-*/
agBOOLEAN  CFuncProcessNportFMCompletion(agRoot_t * hpRoot, os_bit32 fmStatus)
{
    CThread_t * pCThread    = CThread_ptr(hpRoot);
    agBOOLEAN   Credit_Error= agFALSE;

    os_bit32    FMIntStatus = fmStatus & 0x00FFFF00;


    if (!((fmStatus & ChipIOUp_Frame_Manager_Status_LSM_MASK) == ChipMem_Frame_Manager_Status_LSM_Old_Port))
    {

        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) LSM is not Old Port, maybe Loop - In IMQ",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    0,0,0,0,0,0,0,0);
        return (agFALSE);

    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_CE)
    {
        Credit_Error = agTRUE;
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Credit Error (BB) FM cfg %08X FMIntStatus %08X FM Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                    FMIntStatus,
                    fmStatus,
                    0,0,0,0,0);
    }


    if(((fmStatus & ChipIOUp_Frame_Manager_Status_PSM_MASK) ==
                                 ChipIOUp_Frame_Manager_Status_PSM_ACTIVE ))
    {
        /* The port state machine is going to be checked or has
           already been checked in the FM_DelayDone function. So, ignore
           this FM message */

 
        /* Apparently the BB_Credit is Zeroed ( a bug in tachlite), so need
         * to rewrite the BB Credit register.
         */

        /* BB Credit of 1 for NPORT */
        /* WAS          osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, 0x00010000); 
        */

        if( osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ) & pCThread->AquiredCredit_Shifted && (! Credit_Error))
        {
            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, fmStatus);
            return (agTRUE);
        }
        else
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p)  PSM Active - In IMQ FMcfg %08X fmStatus %08X Credit %d",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                        fmStatus,
                        Credit_Error,
                        0,0,0,0,0);

            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
                              ChipIOUp_Frame_Manager_Configuration_NPI |
                             ChipIOUp_Frame_Manager_Configuration_ENP |
                              /* BB Credit of 1 for NPORT */
                              pCThread->AquiredCredit_Shifted);

            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Link_Reset); 

            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, fmStatus);
                      

        return (agTRUE);

        }
    }

    fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "hpRoot(%p) LSM is IN Old Port, Nport Maybe...fmStatus %08X fmcfg %08X",
                (char *)agNULL,(char *)agNULL,
                hpRoot,agNULL,
                fmStatus,
                osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                0,0,0,0,0,0);

/* WAS     if (((fmStatus & fmStatus & ChipIOUp_Frame_Manager_Status_PSM_MASK) ==
                                (ChipIOUp_Frame_Manager_Status_PSM_LF1 | ChipIOUp_Frame_Manager_Status_PSM_LF2)))
*/
    if ( ( 
        ( ( fmStatus & ChipIOUp_Frame_Manager_Status_PSM_MASK) == ChipIOUp_Frame_Manager_Status_PSM_LF1 )
         || ( fmStatus & ChipIOUp_Frame_Manager_Status_PSM_MASK) == ChipIOUp_Frame_Manager_Status_PSM_LF2 ))

        {
        /* Clear the LF bit in the FM Control Register
         * and reread the FM Status register to check if the
         * Nport has come back up.
         */
        /* The port state machine is going to be checked or has
         * already been checked in the FM_DelayDone function. So, ignore
         * this FM message
         */

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, 
                                ChipIOUp_Frame_Manager_Control_CMD_Clear_LF );

        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p)  LF1 or LF2 Recvd while in OLD Port fmStatus:%08X fmcfg %08X CState %d Credit_Error %d",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    fmStatus,
                    osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                    pCThread->thread_hdr.currentState,
                    Credit_Error,0,0,0,0);

        if(( osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ) & \
                pCThread->AquiredCredit_Shifted ) && (! Credit_Error))
        {
            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Link_Reset); 

            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, fmStatus);
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "  LF1 or LF2 Update credit fmStatus:%08X fmcfg %08X CState %d",
                        (char *)agNULL,(char *)agNULL,
                        agNULL,agNULL,
                        fmStatus,
                        osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                        pCThread->thread_hdr.currentState,
                        0,0,0,0,0);

        }


        /*WAS  pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded; */
        if( CThread_ptr(hpRoot)->thread_hdr.currentState   != CStateInitFM  )
        {
            if( fmStatus & ChipIOUp_Frame_Manager_Status_OS)
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Sending Event CEventGoToInitializeFailed fmStatus:%08X fmcfg %08X CState %d",
                            (char *)agNULL,(char *)agNULL,
                            agNULL,agNULL,
                            fmStatus,
                            osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                            pCThread->thread_hdr.currentState,
                            0,0,0,0,0);
                pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventGoToInitializeFailed);
            }
            else
            {
               fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) NOT OS  LF1 or LF2 Recvd fmStatus:%08X fmcfg %08X CState %d",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            fmStatus,
                            osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                            pCThread->thread_hdr.currentState,
                            0,0,0,0,0);

                osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, 
                                        ChipIOUp_Frame_Manager_Control_CMD_Clear_LF );

                osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, fmStatus);
                pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);
            }
        }
        else
        {
                osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, 
                                        ChipIOUp_Frame_Manager_Control_CMD_Clear_LF );

                osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, fmStatus);
        }

        return (agTRUE);

    }

    /* Take care of the NOS/OLS and the link failure in the NPORT case.
     *
     */
    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_OLS)
    {


        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) NPort OLS/NOS received FMcfg %08X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0,0);

        /* was pCThread->Loop_Reset_Event_to_Send = CEventLoopNeedsReinit;
        */
         osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
                              ChipIOUp_Frame_Manager_Configuration_NPI |
                             ChipIOUp_Frame_Manager_Configuration_ENP |
                              /* BB Credit of 1 for NPORT */
                              pCThread->AquiredCredit_Shifted);

        if(pCThread->ChanInfo.NOSCountLower + 1 < pCThread->ChanInfo.NOSCountLower )
        {
            pCThread->ChanInfo.NOSCountUpper ++;
        }
        pCThread->ChanInfo.NOSCountLower += 1;


        pCThread->Loop_Reset_Event_to_Send = CEventLoopNeedsReinit;
        /* pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;
        */
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                     "hpRoot(%p) OLS/NOS Reinit as Nport Loop_Reset_Event_to_Send %d FMcfg %08X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    pCThread->Loop_Reset_Event_to_Send,
                    osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);


        /* if inimq and in reset needed don't clear nos/los */

        if( pCThread->ProcessingIMQ )
        {        

            if( pCThread->thread_hdr.currentState   == CStateResetNeeded )
            {
                FMIntStatus &= ~ChipIOUp_Frame_Manager_Status_OLS;
            }
        }

        if (((fmStatus & ChipIOUp_Frame_Manager_Status_PSM_MASK) & (ChipIOUp_Frame_Manager_Status_PSM_LF1 | ChipIOUp_Frame_Manager_Status_PSM_LF2)))
        {
            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) LF detected %08X FMcfg %08X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            fmStatus,
                            osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                            0,0,0,0,0,0);

      
            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Clear_LF );
        }

        /* WAS osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, FMIntStatus);*/
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status,0xffffffff );

        /* Take the Cthread to ResetIfNeeded State waiting for the Reinit during the
         * the timer tick.
         */

/*WAS         if( pCThread->thread_hdr.currentState == CStateInitFM                   ||
            pCThread->thread_hdr.currentState == CStateInitFM_DelayDone         ||
            pCThread->thread_hdr.currentState == CStateDoFlogi                     )
WAS */
        if( pCThread->thread_hdr.currentState == CStateInitFM_DelayDone         ||
            pCThread->thread_hdr.currentState == CStateDoFlogi                     )
        {

        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                     "hpRoot(%p)Sending CEventAsyncLoopEventDetected LRES %d FMStatus %08X CState %d",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    pCThread->Loop_Reset_Event_to_Send,
                    FMIntStatus,
                    pCThread->thread_hdr.currentState,0,0,0,0,0);

            fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);
        }

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status,0xffffffff );

        return (agTRUE);
    }


    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LF)
    {

        if( pCThread->Link_Failures_In_tick < FC_MAX_LINK_FAILURES_ALLOWED )
        {

            if(!(FMIntStatus & ChipIOUp_Frame_Manager_Status_LPF))
            {
                /* This shouldn't be the mechanism to tell us that an NPORT
                 * is connected but currently this is what Tachlite
                 * sometimes does - instead of setting NOS/OLS bit.
                 * They should set both NOS/OLS bit and Link Failure
                 * bit when we are NPort and we had initialized as
                 * LPORT. We also check to see if LIPf was recieved for yet another
                 * indication that we are connected to loop.
                 */

                pCThread->Loop_Reset_Event_to_Send = CEventLoopNeedsReinit;

                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Sending Reinit event from Link Failure to initialize as NPORT () CState %d",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            pCThread->Loop_Reset_Event_to_Send,
                            pCThread->thread_hdr.currentState,0,0,0,0,0,0);


                osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, FMIntStatus);

                /* Take the Cthread to ResetIfNeeded State waiting for the Reinit during the
                 * the timer tick.
                 */
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);
                return (agTRUE);
            }

           fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) Link Failure with LipF set ....",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        pCThread->Loop_Reset_Event_to_Send,
                        0,0,0,0,0,0,0);

           return (agFALSE); /* In Case of LF with a LipF recvd set */
        }
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status,0xffffffff );
        return (agTRUE);
    }

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status,0xffffffff );
    return (agTRUE);
}

/*+
  Function: CFuncFMCompletion
   Purpose: Handles Frame manager completion messages when chip is using loop state machine.
            That is when InitAsNport is false. Channel ALPA  change is detected in this routine. 
            LinkDownTime is set in this routine - used to determine if timedout IO's may have failed.       
 Called By: CFuncInterruptPoll
            CFuncLoopDownPoll
            CFuncFreezeQueuesPoll
            CFuncTakeOffline

     Calls: osChipIOUpReadBit32
            CFuncProcessNportFMCompletion
            osStallThread
            CEventInitalizeFailure
            CFuncShowActiveCDBThreads
            CFuncMatchALPAtoThread
            DevThreadFree
            CEventLoopNeedsReinit
            CEventResetIfNeeded
            CFuncQuietShowWhereDevThreadsAre
            CEventDoInitalize
            CEventAsyncLoopEventDetected
-*/
void CFuncFMCompletion(agRoot_t * hpRoot)
{
    os_bit32    fmStatus;
    agBOOLEAN   ResetLOOP           = agFALSE;
    agBOOLEAN   LOOP_Cameback       = agFALSE;
    agBOOLEAN   Credit_Error        = agFALSE;

    os_bit32    FMIntStatus;
    os_bit32    LoopStatus;
    os_bit32    LoopStateMachine;

    os_bit32        ClearInt        = 0;
    os_bit32        Link_UP_AL_PA   = 0;
    FC_Port_ID_t    Port_ID;
    CThread_t      *pCThread        = CThread_ptr(hpRoot);
/*
    DevThread_t       *pDevThread;
*/
    SFThread_t    * pSFThread;
    fiList_t      * pList;
    fiList_t      * pDevList;

    pCThread->From_IMQ_Frame_Manager_Status = fmStatus = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );


#ifdef NPORT_STUFF
    if (pCThread->InitAsNport)
    {
        CFuncProcessNportFMCompletion(hpRoot, fmStatus);

        return;
    }
#endif /* NPORT_STUFF */

    /* From here on, We are probably in a Loop topology */
    if(fmStatus & ~(ChipIOUp_Frame_Manager_Status_BA | ChipIOUp_Frame_Manager_Status_LP | ChipIOUp_Frame_Manager_Status_OS) )
    {
        if( (fmStatus & FRAMEMGR_LINK_DOWN) != FRAMEMGR_LINK_DOWN)
        {
            if(!( pCThread->thread_hdr.currentState == CStateInitFM   ) )
            {
                if(pCThread->Last_IMQ_Frame_Manager_Status_Message != fmStatus)
                {
                    pCThread->Last_IMQ_Frame_Manager_Status_Message = fmStatus;
                    fiLogString(hpRoot,
                                  "%s FM %08X St %d",
                                  "CFuncFMCompletion",(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  pCThread->From_IMQ_Frame_Manager_Status,
                                  pCThread->thread_hdr.currentState,
                                  0,0,0,0,0,0);
                }
            }
        }
    }

    LoopStatus  = fmStatus & 0xFF000000;

    FMIntStatus  = fmStatus & 0x00FFFF00;

    LoopStateMachine = fmStatus & ChipIOUp_Frame_Manager_Status_LSM_MASK;

    if(LoopStateMachine < 80 )
    {

        if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LUP || FMIntStatus & ChipIOUp_Frame_Manager_Status_LDN)
        {
            Link_UP_AL_PA = ((osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA )  &
                                              ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) >>
                                               ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT);

            if(  Link_UP_AL_PA !=  pCThread->ChanInfo.CurrentAddress.AL_PA)
            {
                fiLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                "G F * Self ALPA %x  FM cfg %08X",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCThread->ChanInfo.CurrentAddress.AL_PA,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                                0,0,0,0,0,0);
            }
        }
    }

    Link_UP_AL_PA = ((osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA )  &
                                      ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) >>
                                       ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT);

    if(  Link_UP_AL_PA !=  0 &&  Link_UP_AL_PA !=  pCThread->ChanInfo.CurrentAddress.AL_PA)
    {
        if( pCThread->ChanInfo.CurrentAddress.AL_PA != 0xff && Link_UP_AL_PA != 0xff )
        {
            fiLogString(hpRoot,
                            "ALPA Change MY ALPA %X New ALPA %X FM cfg %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->ChanInfo.CurrentAddress.AL_PA,
                            Link_UP_AL_PA,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                            0,0,0,0,0);
        }
    }
    /* Take care of the NOS/OLS. We shouldn't be getting this if we are not
     * in an NPort mode but the fabric may have not yet transitioned....
     */

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_OLS)
    {
        if(pCThread->ChanInfo.NOSCountLower + 1 < pCThread->ChanInfo.NOSCountLower )
        {
            pCThread->ChanInfo.NOSCountUpper ++;
        }
        pCThread->ChanInfo.NOSCountLower += 1;

        ResetLOOP=agTRUE;
        ClearInt |= ChipIOUp_Frame_Manager_Status_OLS;
        osStallThread(hpRoot, 2000);

    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LF)
    {

        if( pCThread->Link_Failures_In_tick < FC_MAX_LINK_FAILURES_ALLOWED )
        {
            ClearInt |= ChipIOUp_Frame_Manager_Status_LF ;
/*
            if( ! pCThread->Link_Failures_In_tick )
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Link Failure LSM %X FMIntStatus %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,FMIntStatus,0,0,0,0,0,0);
            }

            pCThread->Link_Failures_In_tick++;
*/
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventInitalizeFailure);
            }

            ResetLOOP=agFALSE;

        }

    }


    if(LoopStatus & ChipIOUp_Frame_Manager_Status_LP )
    {

        ClearInt |= ChipIOUp_Frame_Manager_Status_LP;

        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "hpRoot(%p) Loop Good LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,
                    0,0,0,0,0,0,0);
    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_TP )
    {
        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
        pCThread->LinkDownTime = pCThread->TimeBase;
        ResetLOOP=agTRUE;
        ClearInt |=  ChipIOUp_Frame_Manager_Status_TP ;
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Transmit PE LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
/*
        if( pCThread->Transmit_PE_In_tick < FC_MAX_TRANSMIT_PE_ALLOWED )
        {
            ResetLOOP=agTRUE;
            ClearInt |=  ChipIOUp_Frame_Manager_Status_TP ;
            if( ! pCThread->Transmit_PE_In_tick )
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Transmit PE LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Transmit_PE_In_tick++;
        }
        else
        {
            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }

            ResetLOOP=agFALSE;

        }
*/
    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_NP )
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_NP;
        ResetLOOP=agTRUE;
        osStallThread(hpRoot, 200 );
        if(pCThread->Last_IMQ_Frame_Manager_Status_Message != fmStatus)
        {
            fiLogString(hpRoot,
                            "NP MY ALPA %X New ALPA %X FM cfg %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->ChanInfo.CurrentAddress.AL_PA,
                            Link_UP_AL_PA,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                            0,0,0,0,0);

        }
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p)fmStatus %08X Non Particapating LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    fmStatus,
                    LoopStateMachine,
                    0,0,0,0,0,0);
    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_BYP)
    {
        ResetLOOP=agTRUE;
        ClearInt |= ChipIOUp_Frame_Manager_Status_BYP;
        fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Node Bypassed LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
/*
        if( pCThread->Node_By_Passed_In_tick < FC_MAX_NODE_BY_PASSED_ALLOWED )
        {
            ClearInt |= ChipIOUp_Frame_Manager_Status_BYP;
            ResetLOOP=agTRUE;
            if( ! pCThread->Node_By_Passed_In_tick )
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Node Bypassed LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Node_By_Passed_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }

            ResetLOOP=agFALSE;

        }
*/
    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_FLT)
    {
        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
        pCThread->LinkDownTime = pCThread->TimeBase;
        ClearInt |=  ChipIOUp_Frame_Manager_Status_FLT;
        ResetLOOP=agTRUE;
/*
        if( pCThread->Lost_sync_In_tick < FC_MAX_LINK_FAULTS_ALLOWED )
        {
            ClearInt |=  ChipIOUp_Frame_Manager_Status_FLT;
            ResetLOOP=agTRUE;
            if( ! pCThread->Link_Fault_In_tick )
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Link Fault LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Link_Fault_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }

            ResetLOOP=agFALSE;

        }
*/
    }
    if(LoopStatus & ChipIOUp_Frame_Manager_Status_OS )
    {
        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
        pCThread->LinkDownTime = pCThread->TimeBase;
        ClearInt |=  ChipIOUp_Frame_Manager_Status_OS;
        ResetLOOP=agTRUE;

        if( (fmStatus & FRAMEMGR_LINK_DOWN) != FRAMEMGR_LINK_DOWN)
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) Loop Out of Sync LSM %X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        LoopStateMachine,0,0,0,0,0,0,0);
        }

/*
        if( pCThread->Lost_sync_In_tick < FC_MAX_LOSE_OF_SYNC_ALLOWED )
        {
            ClearInt |=  ChipIOUp_Frame_Manager_Status_OS;
            ResetLOOP=agTRUE;
            if( ! pCThread->Lost_sync_In_tick )
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Loop Out of Sync LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Lost_sync_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }
            ResetLOOP=agFALSE;

        }
*/

    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_LS )
    {
        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
        pCThread->LinkDownTime = pCThread->TimeBase;
        ClearInt |=  ChipIOUp_Frame_Manager_Status_LS;
        ResetLOOP=agTRUE;
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Loop Lost Signal LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
/*
        if( pCThread->Lost_Signal_In_tick < FC_MAX_LOST_SIGNALS_ALLOWED )
        {
            ClearInt |=  ChipIOUp_Frame_Manager_Status_LS;
            ResetLOOP=agTRUE;
            if( ! pCThread->Lost_Signal_In_tick )
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Loop Lost Signal LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Lost_Signal_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }
            ResetLOOP=agFALSE;

        }
*/

    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LPE)
    {
        /* ResetLOOP=agTRUE; */
        /* Ignore LPE */
        ClearInt |=ChipIOUp_Frame_Manager_Status_LPE;
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) LPE received LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
    }


    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LPB)
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_LPB;
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Loop ByPass Primitive received LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
    }


    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LST)
    {
        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
        pCThread->LinkDownTime = pCThread->TimeBase;
        ClearInt |= ChipIOUp_Frame_Manager_Status_LST;
        ResetLOOP = agTRUE;
        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) Loop State Timeout received LSM %X Cstate %d FMIntStatus %X TL Status %08X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        LoopStateMachine,
                        pCThread->thread_hdr.currentState,
                        FMIntStatus,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        0,0,0,0);
/*
        pCThread->Loop_State_TimeOut_In_tick++;
        if( pCThread->Loop_State_TimeOut_In_tick < FC_MAX_LST_ALLOWED )
        {
            if( ! pCThread->Loop_State_TimeOut_In_tick )
            {
                fiLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "hpRoot(%p) Loop State Timeout received LSM %X Cstate %d FMIntStatus %X TL Status %08X",
                                (char *)agNULL,(char *)agNULL,
                                hpRoot,agNULL,
                                LoopStateMachine,
                                pCThread->thread_hdr.currentState,
                                FMIntStatus,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                                0,0,0,0);
            }

        }
        else
        {
*/
            /* ResetLOOP = agTRUE; */
/*
            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Loop State Timeout Cstate %d FMIntStatus %X TL Status %08X LST count %d",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->thread_hdr.currentState,
                            FMIntStatus,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                            pCThread->Loop_State_TimeOut_In_tick,
                            0,0,0,0);

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ))
            {
                if( pCThread->thread_hdr.currentState == CStateNormal  )
                {
                    pCThread->Loop_Reset_Event_to_Send = CEventInitalizeFailure;
                    fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventLoopEventDetected);
                }
                else
                {
                    if( pCThread->thread_hdr.currentState == CStateInitializeFailed  )
                    {
                        ResetLOOP=agFALSE;
                    }
                    else
                    {
                        fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
                        return;
                    }
                }
            }
            else
            {
                ResetLOOP=agFALSE;
            }
        }
*/
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LPF)
    {
        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
        pCThread->LinkDownTime = pCThread->TimeBase;
        ResetLOOP=agTRUE;
        ClearInt |= ChipIOUp_Frame_Manager_Status_LPF;

        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) LIPf received LSM %X Rec ALPA Reg %08X Cstate %d FMIntStatus %X",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        LoopStateMachine,
                        osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                        pCThread->thread_hdr.currentState,
                        FMIntStatus,0,0,0,0);

/*
        if( pCThread->Lip_F7_In_tick < FC_MAX_LIP_F7_ALLOWED )
        {
            if( ! pCThread->Lip_F7_In_tick )
            {
                fiLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "hpRoot(%p) LIPf received LSM %X Rec ALPA Reg %08X Cstate %d FMIntStatus %X",
                                (char *)agNULL,(char *)agNULL,
                                hpRoot,agNULL,
                                LoopStateMachine,
                                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                                pCThread->thread_hdr.currentState,
                                FMIntStatus,0,0,0,0);
            }

            if( 0xF7 ==  (osChipIOUpReadBit32(hpRoot,
                                            ChipIOUp_Frame_Manager_Received_ALPA) &
                                  ChipIOUp_Frame_Manager_Received_ALPA_LIPf_ALPA_MASK ))
            {
                ClearInt |= ChipIOUp_Frame_Manager_Status_LPF;
            }

            ClearInt |= ChipIOUp_Frame_Manager_Status_LPF;

            pCThread->Lip_F7_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateInitFM_DelayDone        ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                    fiLogDebugString(hpRoot,
                                    CFuncCheckCstateErrorLevel,
                                    "%s sends %s FM_Status %08X FM_IMQ_Status %08X ",
                                    "CFuncFMCompletion","CEventLIPEventStorm",
                                    (void *)agNULL,(void *)agNULL,
                                    FMIntStatus,
                                    pCThread->From_IMQ_Frame_Manager_Status,
                                    0,0,0,0,0,0);

                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventLIPEventStorm);
            }

            ResetLOOP=agFALSE;

         }
*/


    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_BA)
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_BA;

        if(pCThread->thread_hdr.currentState == CStateNormal)
        {
            FC_Port_ID_t  BadAL_PA;
            BadAL_PA.Struct_Form.AL_PA = 0;
            BadAL_PA.Struct_Form.Area = 0;
            BadAL_PA.Struct_Form.Domain = 0;
            BadAL_PA.Struct_Form.reserved = 0;

            BadAL_PA.Struct_Form.AL_PA = (os_bit8)((osChipIOUpReadBit32(hpRoot,
                                ChipIOUp_Frame_Manager_Received_ALPA)  >>
                                ChipIOUp_Frame_Manager_Received_ALPA_Bad_ALPA_SHIFT) &
                                0x000000FF);

            if(BadAL_PA.Bit32_Form )
            {
                DevThread_t   * pDevThread = agNULL;
                pDevThread = CFuncMatchALPAtoThread(hpRoot, BadAL_PA );
                if( pDevThread != agNULL )
                {
                    fiLogString(hpRoot,
                                    "%s %x",
                                    "Status_BA",(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    BadAL_PA.Bit32_Form,
                                    0,0,0,0,0,0,0);
                    fiSendEvent(&(pDevThread->thread_hdr),DevEvent_Device_Gone);
                }
                ResetLOOP=agTRUE;
            }
        }
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_PRX)
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_PRX;

        pCThread->PrimitiveReceived = agTRUE;

        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Primitive received LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_PTX)
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_PTX;
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Primitive Sent LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
    }


    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LG)
    {
        pCThread->FabricLoginRequired = agTRUE;
        ClearInt |= ChipIOUp_Frame_Manager_Status_LG ;
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) FLOGi Required LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);

        if (!(FMIntStatus & ~ChipIOUp_Frame_Manager_Status_LG))
        {
            /* We are not acting on this since it is not a reliable mechanism
             * of detecting a fabric yet.
             */
           osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status,ClearInt);
           return;
        }
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_CE)
    {
        Credit_Error = agTRUE;
        ResetLOOP=agTRUE;
        ClearInt |= ChipIOUp_Frame_Manager_Status_CE;
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Credit Error (BB) LSM %X FMIntStatus %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,FMIntStatus,0,0,0,0,0,0);
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_EW)
    {
        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
        pCThread->LinkDownTime = pCThread->TimeBase;
        if( pCThread->Elastic_Store_ERROR_Count < FC_MAX_ELASTIC_STORE_ERRORS_ALLOWED )
        {
            ClearInt |= ChipIOUp_Frame_Manager_Status_EW;
            pCThread->Elastic_Store_ERROR_Count++;
        }
        else
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Elastic Store Error LSM %X FMIntStatus %X Cstate %d Count %d",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,FMIntStatus,
                    pCThread->thread_hdr.currentState,
                    pCThread->Elastic_Store_ERROR_Count,0,0,0,0);


                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventInitalizeFailure);
    
                ResetLOOP=agTRUE;

                pCThread->Elastic_Store_ERROR_Count=0;

        }

    }

    if( FMIntStatus & ChipIOUp_Frame_Manager_Status_LDN )
    {
        pCThread->LOOP_DOWN = agTRUE;
        pCThread->ChanInfo.LinkUp = agFALSE;
        pCThread->IDLE_RECEIVED = agFALSE;

        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "F HostCopy ERQ_PROD %x ERQ Cons %x ",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Producer_Index),
                        osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index),
                        0,0,0,0,0,0);
        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
        pCThread->LinkDownTime = pCThread->TimeBase;

        osChipIOLoWriteBit32(hpRoot,ChipIOLo_ERQ_Consumer_Index , 
                        osChipIOLoReadBit32(hpRoot,ChipIOLo_ERQ_Producer_Index ));

        ResetLOOP = agTRUE; /* If this is not here after a lip we will not be logged in */

        ClearInt |= ChipIOUp_Frame_Manager_Status_LDN;

        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) Link Down LSM %X Cstate %d CDBCnt %x",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        LoopStateMachine,
                        pCThread->thread_hdr.currentState,
                        pCThread->CDBpollingCount,
                        0,0,0,0,0);


        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "TimeBase %8X %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->TimeBase.Hi,
                        pCThread->TimeBase.Lo,
                        0,0,0,0,0,0);

    }

    if( FMIntStatus & ChipIOUp_Frame_Manager_Status_LUP )
    {
        LOOP_Cameback = agTRUE;
        ResetLOOP = agTRUE; /* If this is not here after a lip we will not be logged in */
        ClearInt |= ChipIOUp_Frame_Manager_Status_LUP;
        fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Link Up LSM %X Cstate %d LD %x IR %x CDBCnt %x",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,
                            pCThread->thread_hdr.currentState,
                            pCThread->LOOP_DOWN,
                            pCThread->IDLE_RECEIVED,
                            pCThread->CDBpollingCount,
                            0,0,0);
        if ( pCThread->FM_pollingCount > 0 )  pCThread->FM_pollingCount --;
        pCThread->LOOP_DOWN = agFALSE;
        pCThread->ChanInfo.LinkUp = agTRUE;
/************************************/
        pCThread->LoopMapLIRP_Received = agFALSE;
        pCThread->DeviceDiscoveryMethod = DDiscoveryScanAllALPAs;


        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Loop Good LSM %X ALPA %x Self ALPA %x CFG %08X Rec AL_PA %08X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,
                    Link_UP_AL_PA,
                    pCThread->ChanInfo.CurrentAddress.AL_PA,
                    (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 0xFFFFFF) |
                        ( Link_UP_AL_PA <<  ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA ),
                    0,0,0);

        if( (Link_UP_AL_PA !=  pCThread->ChanInfo.CurrentAddress.AL_PA) || (pCThread->DeviceSelf == agNULL))
        {

            if(pCThread->DeviceSelf == agNULL)
            {
                fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s hpRoot(%p) LSM %X ALPA %x Self ALPA %x CFG %08X",
                            "DeviceSelf == agNULL",(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,
                            Link_UP_AL_PA,
                            pCThread->ChanInfo.CurrentAddress.AL_PA,
                            (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 0xFFFFFF) |
                                ( Link_UP_AL_PA <<  ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ),
                            0,0,0,0);
            }
            else
            {
                pCThread->ALPA_Changed_OnLinkEvent = agTRUE;
                fiLogDebugString(hpRoot,
                                FCMainLogErrorLevel,
                                "hpRoot(%p) Self %p LSM %X ALPA %x Self ALPA %x CFG %08X",
                                (char *)agNULL,(char *)agNULL,
                                hpRoot,pCThread->DeviceSelf,
                                LoopStateMachine,
                                Link_UP_AL_PA,
                                pCThread->ChanInfo.CurrentAddress.AL_PA,
                                (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 0xFFFFFF) |
                                    ( Link_UP_AL_PA <<  ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ),
                                0,0,0,0);
            }

            if(Link_UP_AL_PA  != 0 && Link_UP_AL_PA != 0xff)
            {
                osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, Link_UP_AL_PA);

                osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
                        (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 0xFFFFFF) |
                        ( Link_UP_AL_PA <<  ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ));

                fiLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                "AF * Self ALPA %x  FM cfg %08X",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCThread->ChanInfo.CurrentAddress.AL_PA,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                                0,0,0,0,0,0);
                if(pCThread->DeviceSelf != agNULL)
                {

                    fiLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    "pCThread->DeviceSelf != agNULL Empty ? %x On list ? %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    fiListNotEmpty(&pCThread->DevSelf_NameServer_DevLink ),
                                    fiListElementOnList(&(pCThread->DevSelf_NameServer_DevLink), &(pCThread->DeviceSelf->DevLink)), 
                                    0,0,0,0,0,0);

                    if(fiListNotEmpty(&pCThread->DevSelf_NameServer_DevLink ))
                    {
                        fiListDequeueFromHead(&pDevList, &pCThread->DevSelf_NameServer_DevLink );
                    }
                    fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
                    DevThreadFree(hpRoot,pCThread->DeviceSelf);
                    pCThread->DeviceSelf = agNULL;
                    CFuncQuietShowWhereDevThreadsAre( hpRoot);

                }

                Port_ID.Struct_Form.reserved = 0;
                Port_ID.Struct_Form.Domain = 0;
                Port_ID.Struct_Form.Area   = 0;
                Port_ID.Struct_Form.AL_PA  = (os_bit8)Link_UP_AL_PA;

                pCThread->DeviceSelf = DevThreadAlloc( hpRoot,Port_ID );

                pCThread->DeviceSelf->DevSlot = DevThreadFindSlot(hpRoot,
                                                            Port_ID.Struct_Form.Domain,
                                                            Port_ID.Struct_Form.Area,
                                                            Port_ID.Struct_Form.AL_PA,
                                                           (FC_Port_Name_t *)(&pCThread->ChanInfo.PortWWN));

                fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
                fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);

                pCThread->ChanInfo.CurrentAddress.AL_PA = (os_bit8)Link_UP_AL_PA;

                ResetLOOP=agTRUE;

                fiLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                " F * Self ALPA %x  FM cfg %08X",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCThread->ChanInfo.CurrentAddress.AL_PA,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                                0,0,0,0,0,0);

            }
        }


/*****************************************/
        if(pCThread->IDLE_RECEIVED)
        {

            if( CFunc_Always_Enable_Queues(hpRoot ))
            {
                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) FM Queues Frozen after enable !",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        0,0,0,0,0,0,0,0);

            }
            else
            {

                pCThread->IDLE_RECEIVED = agFALSE;
                if(fiListNotEmpty(&pCThread->QueueFrozenWaitingSFLink))
                {
                    fiListDequeueFromHeadFast(&pList,
                                        &pCThread->QueueFrozenWaitingSFLink );
                    pSFThread = hpObjectBase(SFThread_t,
                                              SFLink,pList );
                    fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "hpRoot(%p) Starting frozen SFThread %p Event %d",
                                    (char *)agNULL,(char *)agNULL,
                                    hpRoot,pSFThread,
                                    pSFThread->QueuedEvent,
                                    0,0,0,0,0,0,0);

                    if(pSFThread->QueuedEvent )
                    {
                        fiSendEvent(&pSFThread->thread_hdr,(event_t)pSFThread->QueuedEvent);
                    }
                }
            }
        }
    }

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status,ClearInt);

    if( pCThread->thread_hdr.currentState == CStateInitFM                   ||
        pCThread->thread_hdr.currentState == CStateInitFM_DelayDone         ||
        pCThread->thread_hdr.currentState == CStateResetNeeded              ||
        pCThread->thread_hdr.currentState == CStateLIPEventStorm            ||
        pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm   ||
        pCThread->thread_hdr.currentState == CStateInitializeFailed         ||
        pCThread->thread_hdr.currentState == CStateReInitFM                 ||
        pCThread->thread_hdr.currentState == CStateSendPrimitive                )
    {

        if( ! ( pCThread->thread_hdr.currentState == CStateInitializeFailed &&
                LOOP_Cameback == agTRUE                                           ))
        {
                ResetLOOP = agFALSE;
        }


    }

    if( pCThread->thread_hdr.currentState == CStateInitializeFailed )
    {

        if( (fmStatus & FRAMEMGR_LINK_DOWN) == FRAMEMGR_LINK_DOWN)
        {
                ResetLOOP = agFALSE;
        }

    }

    if (ResetLOOP)
    {
        fmStatus = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );

        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "About to ResetLOOP FM Status %08X TL Status %08X CState %d",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fmStatus,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        pCThread->thread_hdr.currentState,
                        0,0,0,0,0);


        if(pCThread->LoopPreviousSuccess)
        {
            if (Credit_Error)
            {
                pCThread->Loop_Reset_Event_to_Send = CEventLoopNeedsReinit;
            }
            else
            {
                pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
            }

        }
        else
        {
            if( CFuncAll_clear( hpRoot ) )
            {
                pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;

                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) ResetLOOP LSM %X Cstate %d sends %s (%d)",
                        "CEventLoopNeedsReinit",(char *)agNULL,
                        hpRoot,agNULL,
                        LoopStateMachine,
                        pCThread->thread_hdr.currentState,
                        CEventAsyncLoopEventDetected,0,0,0,0,0);

            }
            else
            {
                if( pCThread->thread_hdr.currentState == CStateLoopFailedReInit )
                {

                    pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;
                }
                else
                {
                    /* WAS pCThread->Loop_Reset_Event_to_Send = CEventLoopNeedsReinit; */
                    pCThread->Loop_Reset_Event_to_Send = CEventLoopEventDetected;

                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) ResetLOOP LSM %X Cstate %d sends %s (%d)",
                            "CEventLoopNeedsReinit",(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,
                            pCThread->thread_hdr.currentState,
                            CEventLoopNeedsReinit,0,0,0,0,0);
                }
            }
        }

        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) ResetLOOP LSM %X Cstate %d sends (%d) Event to send %d",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        LoopStateMachine,
                        pCThread->thread_hdr.currentState,
                        CEventAsyncLoopEventDetected,
                        pCThread->Loop_Reset_Event_to_Send,
                        0,0,0,0);

        fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);

    }
}

/*+
  Function: CFuncSEST_offCard_FCPCompletion
   Purpose: Handles  inDMAmemory FCP completions
     
 Called By: FuncPtrs.FCP_Completion

     Calls: osChipIOUpReadBit32
            CFuncProcessNportFMCompletion
            osStallThread
            CEventInitalizeFailure
            CFuncShowActiveCDBThreads
            CFuncMatchALPAtoThread
            DevThreadFree
            CEventLoopNeedsReinit
            CEventResetIfNeeded
            CFuncQuietShowWhereDevThreadsAre
            CEventDoInitalize
            CEventAsyncLoopEventDetected
-*/
void CFuncSEST_offCard_FCPCompletion(agRoot_t * hpRoot,os_bit32 status)
{
    CDBThread_t             * pCDBThread;
    fiMemMapMemoryDescriptor_t * CDBThread_MemoryDescriptor = &(CThread_ptr(hpRoot)->Calculation.MemoryLayout.CDBThread);
    X_ID_t                    X_ID;
    USE_t                   * SEST;
    FCHS_t                  * pFCHS;
    event_t                   event_to_send                 = CDBEventIoSuccess;
    FC_FCP_RSP_Payload_t    * fcprsp;
    os_bit32                  error;

    agIORequestBody_t       * hpRequestBody;


#ifdef __FC_Layer_Loose_IOs
    if(pCThread->IOsTotalCompleted  > 100000 )
    {
        pCThread->IOsFailedCompeted += 1;
        if(pCThread->IOsFailedCompeted  > 45 )
        {
            pCThread->IOsFailedCompeted = 0;
            pCThread->IOsTotalCompleted = 0;
        }
        else
        {
            return;
        }

    }

#endif /*  __FC_Layer_Loose_IOs  */

    X_ID =(X_ID_t)( status & CM_Inbound_FCP_Exchange_SEST_Index_MASK);

    error = status & ~CM_Inbound_FCP_Exchange_SEST_Index_MASK;


    pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                 + (X_ID * CDBThread_MemoryDescriptor->elementSize));

    if (!(pCDBThread->ExchActive))
    {
        fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Found a cbdthread that is not active... %p State %d Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread,agNULL,
                    pCDBThread->thread_hdr.currentState,
                    status,
                    0,0,0,0,0,0);

/*
         fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);
*/
        return;
    }


/*
    if (pCDBThread->FC_Tape_Active)
    {
        fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Found a FC_Tape_Active cbdthread ... %p State %d Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread,agNULL,
                    pCDBThread->thread_hdr.currentState,
                    status,
                    0,0,0,0,0,0);

         fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);
    }
*/
    hpRequestBody =(agIORequestBody_t *)&pCDBThread->CDBRequest;

    SEST = (USE_t *)pCDBThread->SEST_Ptr;

#ifndef Performance_Debug
    if(SEST)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Sest DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    SEST->Bits,
                    SEST->Unused_DWord_1,
                    SEST->Unused_DWord_2,
                    SEST->Unused_DWord_3,
                    SEST->LOC,
                    SEST->Unused_DWord_5,
                    SEST->Unused_DWord_6,
                    SEST->Unused_DWord_7);

        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Sest DWORD 8 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    SEST->Unused_DWord_8,
                    SEST->Unused_DWord_9,
                    SEST->First_SG.U32_Len,
                    SEST->First_SG.L32,
                    SEST->Second_SG.U32_Len,
                    SEST->Second_SG.L32,
                    SEST->Third_SG.U32_Len,
                    SEST->Third_SG.L32);
    }
    else
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Sest Pointer BAD",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
    }
#endif /* Performance_Debug */

    if(error & CM_Inbound_FCP_Exchange_LKF)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "InboundLink Failure %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,0,0,0,0,0,0,0);
        event_to_send = CDBEventFailNoRSP;
    }

    if(error & CM_Inbound_FCP_Exchange_CNT)
    {

        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Count Error %08X Byte Count %08X Exp %08X %s",
                    pCDBThread->ReadWrite ? "Write" : "Read",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,
                    SEST->Unused_DWord_7,
                    SEST->Unused_DWord_9,
                    0,0,0,0,0);
        event_to_send = CDBEventIoOver;
    }

    if(error & CM_Inbound_FCP_Exchange_CNT && error & CM_Inbound_FCP_Exchange_OVF)
    {

        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "OVF Count Error %08X Byte Count %08X Exp %08X %s",
                    pCDBThread->ReadWrite ? "Write" : "Read",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,
                    SEST->Unused_DWord_7,
                    SEST->Unused_DWord_9,
                    pCDBThread->ReadWrite,
                    0,0,0,0);
        event_to_send = CDBEventIoFailed;
    }

    if( error & CM_Inbound_FCP_Exchange_RPC && error & CM_Inbound_FCP_Exchange_OVF )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Overflow %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,0,0,0,0,0,0,0);
        event_to_send = CDBEventIoFailed;

        }

    if(error & CM_Inbound_FCP_Exchange_RPC)
    {

#ifndef Performance_Debug
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Response Phase Complete %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,0,0,0,0,0,0,0);
#endif /* Performance_Debug */

        /* If Response detect is enabled and we have an XL controller, send a success
           right away, else wait for the SFQ to deliver the response buffer.
         */
#ifdef __TACHYON_XL_NO_RSP
        if (pCThread->ResponseDetectEnabled) && 
            (!pCDBThread->WaitForFcpRsp) )
        {
            if (!(error & CM_Inbound_FCP_Exchange_FEE))
            {

#ifndef Performance_Debug
                fiLogDebugString(hpRoot,
                            CStateLogConsoleLevel,
                            StateLogTraceLevel,
                            "Response Detect Enabled, No Errors %08X",
                            (char *)NULL,(char *)NULL,
                            error,0,0,0,0,0,0,0);
#endif /* Performance_Debug */
                fiSendEvent(&pCDBThread->thread_hdr, CDBEventIoSuccess);
                return;
            }
            else
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleLevel,
                            StateLogTraceLevel,
                            "Response Detect Enabled, Error Exists Wait for message %08X",
                            (char *)NULL,(char *)NULL,
                            error,0,0,0,0,0,0,0);
                /*FEE set, wait for an unassisted frame to give the response buffer */
                pCDBThread->WaitForFcpRsp = agTRUE;
                return;
            }

        }

        else
#endif /* __TACHYON_XL_NO_RSP */
        {
            event_to_send = CFuncProcessFcpRsp(hpRoot, pCDBThread, event_to_send);
            fcprsp = (FC_FCP_RSP_Payload_t  * )(((os_bit8 *)pCDBThread->FCP_RESP_Ptr) + sizeof(FCHS_t));
        } /* Non XL or XL without RDE Enabled */
    }

    if(event_to_send == CDBEventIoOver )
    {

        if( pCDBThread->DataLength == 0 )
        {   
            /* Complete Datalength Zero commands with good status ??? Why does chip report CNT error ? */
            fiLogDebugString(hpRoot,
                                FCMainLogErrorLevel,
                                "X_ID %X BC %X Ex %X L %X %s stat %X",
                                pCDBThread->ReadWrite == CDBThread_Read ? "Write" :"Read" ,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCDBThread->X_ID,
                                pCDBThread->SEST_Ptr->IRE.Byte_Count,
                                pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt,
                                pCDBThread->DataLength,
                                status,
                                0,0,0);
            fiSendEvent(&pCDBThread->thread_hdr, CDBEventIoSuccess);
            return;
        }


#ifdef FULL_FC_TAPE_DBG

        if (pCDBThread->ReadWrite == CDBThread_Read)
        {
            fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "CDBEventIoOver X_ID %X BC %08X E %08X L %08X %s stat %X",
                        "Read",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCDBThread->X_ID,
                        pCDBThread->SEST_Ptr->IRE.Byte_Count,
                        pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt,
                        pCDBThread->DataLength,
                        status,
                        0,0,0);
        }
        else
        {
            fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "Over BC %08X Exp %08X Len %08X %s stat %X",
                        "Write",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCDBThread->SEST_Ptr->IWE.Data_Len,
                        pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt,
                        pCDBThread->DataLength,
                        status,
                        0,0,0,0);

        }

        fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "Before ValidityStatusIndicators %x scsi stat %x sense len %x resid %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)fcprsp->FCP_STATUS.ValidityStatusIndicators,
                    (os_bit32)fcprsp->FCP_STATUS.SCSI_status_byte,
                    (os_bit32)fcprsp->FCP_SNS_LEN,
                    (os_bit32)fcprsp->FCP_RESID,
                    0,0,0,0);

#endif /* FULL_FC_TAPE_DBG */

        /* Copy and compare errors under NT */
        /* We got underrun completion but response buffer empty fill in underrun  */
        fcprsp = (FC_FCP_RSP_Payload_t  * )(((os_bit8 *)pCDBThread->FCP_RESP_Ptr) + sizeof(FCHS_t));
        if( fcprsp->FCP_STATUS.ValidityStatusIndicators == 0 )
        {
            if( fcprsp->FCP_STATUS.SCSI_status_byte == 0 )
            {
                if( fcprsp->FCP_RESID == 0   )
                {
                    pFCHS = ( FCHS_t * )pCDBThread->FCP_RESP_Ptr;
                    if (pCDBThread->ReadWrite == CDBThread_Read)
                    {

                        fiLogDebugString(hpRoot,
                                    FCMainLogErrorLevel,
                                    "Before ValidityStatusIndicators %x scsi stat %x sense len %x resid %08X",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    (os_bit32)fcprsp->FCP_STATUS.ValidityStatusIndicators,
                                    (os_bit32)fcprsp->FCP_STATUS.SCSI_status_byte,
                                    (os_bit32)fcprsp->FCP_SNS_LEN,
                                    (os_bit32)fcprsp->FCP_RESID,
                                    0,0,0,0);

                        /* Check for negative value*/
                        if(  pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt > pCDBThread->SEST_Ptr->IRE.Byte_Count )
                        {
                            fcprsp->FCP_RESID = hpSwapBit32((pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt- pCDBThread->SEST_Ptr->IRE.Byte_Count ));
                            fcprsp->FCP_STATUS.ValidityStatusIndicators = FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RESID_UNDER;
                        }
                        else
                        {
                            /* */
                            fcprsp->FCP_RESID = hpSwapBit32((pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt));
                            fcprsp->FCP_STATUS.ValidityStatusIndicators = FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RESID_OVER;
                        }


                        fiLogDebugString(hpRoot,
                                    FCMainLogErrorLevel,
                                    "pFCHS %08X %08X %08X %08X %08X %08X %08X",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    pFCHS->CS_CTL__S_ID,
                                    pFCHS->MBZ1,
                                    pFCHS->OX_ID__RX_ID,
                                    pFCHS->R_CTL__D_ID,
                                    pFCHS->RO,
                                    pFCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                                    pFCHS->TYPE__F_CTL,
                                    0 );
                    }
                    else /* CDBThread_Write */
                    {
                        /* Check for negative value*/
                        if( pCDBThread->DataLength > pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt  )
                        {
                            fcprsp->FCP_RESID = hpSwapBit32((pCDBThread->DataLength - pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt ));
                            fcprsp->FCP_STATUS.ValidityStatusIndicators = FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RESID_UNDER;
                        }
                        else
                        {
                            /* */
                            fcprsp->FCP_RESID = hpSwapBit32((pCDBThread->DataLength));
                            fcprsp->FCP_STATUS.ValidityStatusIndicators = FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RESID_OVER;
                        }
                        fiLogDebugString(hpRoot,
                                    FCMainLogErrorLevel,
                                    "status %08X Byte Count %08X Exp %08X %s DataLength %X",
                                    "Write",(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    status,
                                    pCDBThread->SEST_Ptr->IWE.Data_Len,
                                    pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt,
                                    pCDBThread->DataLength,
                                    0,0,0,0);
                    } /* End CDBThread_Write */
                } /* fcprsp->FCP_RESID != 0 */
            }/*fcprsp->FCP_STATUS.SCSI_status_byte != 0 */

        
         fiLogDebugString(hpRoot,
                        CStateLogConsoleErrorOverRun,
                        "After valid %x scsi stat %x sense len %x resid %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)fcprsp->FCP_STATUS.ValidityStatusIndicators,
                        (os_bit32)fcprsp->FCP_STATUS.SCSI_status_byte,
                        (os_bit32)fcprsp->FCP_SNS_LEN,
                        (os_bit32)fcprsp->FCP_RESID,
                        0,0,0,0);

        }

        if( fcprsp->FCP_STATUS.ValidityStatusIndicators == 0    &&
            fcprsp->FCP_RESID != 0                               )
        {
            fcprsp->FCP_STATUS.ValidityStatusIndicators =
                            FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RESID_UNDER;

             fiLogDebugString(hpRoot,
                            CStateLogConsoleErrorOverRun,
                            "After valid %x scsi stat %x sense len %x resid %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            (os_bit32)fcprsp->FCP_STATUS.ValidityStatusIndicators,
                            (os_bit32)fcprsp->FCP_STATUS.SCSI_status_byte,
                            (os_bit32)fcprsp->FCP_SNS_LEN,
                            (os_bit32)fcprsp->FCP_RESID,
                            0,0,0,0);

        }
    }

    if(event_to_send != CDBEventIoSuccess )
    {
        fcprsp = (FC_FCP_RSP_Payload_t  * )(((os_bit8 *)pCDBThread->FCP_RESP_Ptr) + sizeof(FCHS_t));
        fiLogDebugString(hpRoot,
                            CStateLogConsoleErrorOverRun,
                            "CDBEvent Error Event %x Byte Count %08X Exp %08X %s status %08X",
                            pCDBThread->ReadWrite ? "Write" : "Read",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            event_to_send,
                            SEST->Unused_DWord_7,
                            SEST->Unused_DWord_9,
                            status,
                            0,0,0,0);

         fiLogDebugString(hpRoot,
                            CStateLogConsoleErrorOverRun,
                            "Before valid %x scsi stat %x sense len %x resid %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            (os_bit32)fcprsp->FCP_STATUS.ValidityStatusIndicators,
                            (os_bit32)fcprsp->FCP_STATUS.SCSI_status_byte,
                            (os_bit32)fcprsp->FCP_SNS_LEN,
                            (os_bit32)fcprsp->FCP_RESID,
                            0,0,0,0);

    }

    fiSendEvent(&pCDBThread->thread_hdr, event_to_send);

}

void CFuncSEST_onCard_FCPCompletion(agRoot_t * hpRoot,os_bit32 status)
{
#ifndef __MemMap_Force_Off_Card__
    CDBThread_t                * pCDBThread;
    fiMemMapMemoryDescriptor_t * CDBThread_MemoryDescriptor = &(CThread_ptr(hpRoot)->Calculation.MemoryLayout.CDBThread);
    X_ID_t                       X_ID;
    event_t                      event_to_send              = CDBEventIoSuccess;
    os_bit32                     SEST_Offset;

    os_bit32                     error;

    X_ID =(X_ID_t)( status & CM_Inbound_FCP_Exchange_SEST_Index_MASK);

    error = status & ~CM_Inbound_FCP_Exchange_SEST_Index_MASK;

    pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                 + (X_ID * CDBThread_MemoryDescriptor->elementSize));

    if (!(pCDBThread->ExchActive))
    {
        fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Found a cbdthread that is not active... %p State %d Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread,agNULL,
                    pCDBThread->thread_hdr.currentState,
                    status,
                    0,0,0,0,0,0);
/*
         fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);
*/
        return;
    }
/*
    if (pCDBThread->FC_Tape_Active)
    {
        fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Found a FC_Tape_Active cbdthread ... %p X_ID %X State %d Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread,agNULL,
                    X_ID,                    
                    pCDBThread->thread_hdr.currentState,
                    status,
                    0,0,0,0,0);

         fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);
    }
*/
    SEST_Offset = pCDBThread->SEST_Offset;

    fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "SEST_Offset %08X X_ID %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    SEST_Offset,
                    X_ID,
                    0,0,0,0,0,0);


    fiLogDebugString(hpRoot,
                    CStateLogConsoleShowSEST,
                    "Sest DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Bits))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_1))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_2))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_3))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,LOC))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_5))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_6))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_7))));


    fiLogDebugString(hpRoot,
                    CStateLogConsoleShowSEST,
                    "Sest DWORD 8 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_8))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_9))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,First_SG))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,First_SG))+4),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Second_SG))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Second_SG))+4),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Third_SG))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Third_SG))+4));


    if(error & CM_Inbound_FCP_Exchange_LKF)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Inbound Link Failure %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,0,0,0,0,0,0,0);
        event_to_send = CDBEventFailNoRSP;
    }

    if(error & CM_Inbound_FCP_Exchange_CNT)
    {

        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Inbound Count Error %08X Byte Count %08X Exp %08X %s",
                    pCDBThread->ReadWrite ? "Write" : "Read",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_7))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_9))),
                    0,0,0,0,0);
        event_to_send = CDBEventIoOver;
    }

    if(error & CM_Inbound_FCP_Exchange_CNT && error & CM_Inbound_FCP_Exchange_OVF)
    {

        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Count Error %08X Byte Count %08X Exp %08X %s",
                    pCDBThread->ReadWrite ? "Write" : "Read",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_7))),
                    osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_9))),
                    pCDBThread->ReadWrite,
                    0,0,0,0);
        event_to_send = CDBEventIoFailed;
    }

    if( error & CM_Inbound_FCP_Exchange_RPC && error & CM_Inbound_FCP_Exchange_OVF )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Overflow %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,0,0,0,0,0,0,0);
        event_to_send = CDBEventIoFailed;

    }

    if(error & CM_Inbound_FCP_Exchange_RPC)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Response Phase Complete %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    error,0,0,0,0,0,0,0);
    }

    fiSendEvent(&pCDBThread->thread_hdr, event_to_send);
#endif /* __MemMap_Force_Off_Card__ was not defined */

}


void CFuncInBoundCompletion(agRoot_t * hpRoot,os_bit32 SFQ_Index,os_bit32 Frame_Len, os_bit32 type)
{
    CThread_t       *   pCThread            = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *    SFQ_MemoryDescriptor = &(pCThread->Calculation.MemoryLayout.SFQ);

    os_bit32 SFQ_Num_entry;
    os_bit32 SFQ_Start_index;


    if(Frame_Len % 64) SFQ_Num_entry = (Frame_Len / 64) + 1;
    else SFQ_Num_entry = (Frame_Len / 64);

    SFQ_Start_index = SFQ_Index - SFQ_Num_entry;

    if (SFQ_Start_index > SFQ_MemoryDescriptor->elements)
                SFQ_Start_index += SFQ_MemoryDescriptor->elements;

    SFQ_Index &= CM_Inbound_SFQ_Prod_Index_MASK;
    fiLogDebugString(hpRoot,
                        DEVSTATE_NOISE(hpRoot,CStateNormal),
                        "InBoundCompletion SFQ_Index %08X,Frame_len %X, type %X  Queues %x LD %x IR %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SFQ_Index,Frame_Len,
                        type,
                        CFunc_Queues_Frozen( hpRoot ),
                        pCThread->LOOP_DOWN,
                        pCThread->IDLE_RECEIVED,
                        0,0);


    if(type & CM_Inbound_LKF)
    {
        fiLogDebugString(hpRoot,
            CStateLogConsoleERROR,
            "Inbound Link Failure !",
            (char *)agNULL,(char *)agNULL,
            (void *)agNULL,(void *)agNULL,
            0,0,0,0,0,0,0,0);
    }

    type &= CM_Inbound_Type_MASK;
    switch(type)
    {
        /* DR ?? */
        case CM_Inbound_Type_Unassisted_FCP:
            fiLogDebugString(hpRoot,
                CStateLogConsoleHideInboundErrors,
                "CM_Inbound_Type_Unassisted_FCP ! SFQ_Index %x SFQ start %x TL %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                SFQ_Index,
                SFQ_Start_index,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                0,0,0,0,0);

/*
            fiLogString(hpRoot,
                          "%s",
                          "CM_Inbound_Type_Unassisted_FCP",(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0);
*/

            CFuncReadSFQ(hpRoot,Frame_Len, SFQ_Index);

            break;
        case CM_Inbound_Type_Bad_FCP:
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "CM_Inbound_Type_Bad_FCP ! SFQ_Index %x SFQ start %x TL Status %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SFQ_Index,
                        SFQ_Start_index,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        0,0,0,0,0);

/*
            fiLogString(hpRoot,
                          "%s Len %X",
                          "CM_Inbound_Type_Bad_FCP",(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          Frame_Len,0,0,0,0,0,0,0
                        );

*/
            CFuncReadSFQ(hpRoot,Frame_Len, SFQ_Index);
/*
            fiLogString(hpRoot,
                          "%s Len %X",
                          "CM_Inbound_Type_Bad_FCP",(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          Frame_Len,0,0,0,0,0,0,0
                        );
*/
            break;
        case CM_Inbound_Type_Unknown_Frame:
            fiLogDebugString(hpRoot,
                DEVSTATE_NOISE(hpRoot,CStateNormal),
                "CM_Inbound_Type_Unknown_Frame ! TL Status %08X CCnt %x SFCnt %x",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                pCThread->CDBpollingCount,
                pCThread->SFpollingCount,
                0,0,0,0,0);

/*
            fiLogString(hpRoot,
                          "%s SF Thread ?",
                          "CM_Inbound_Type_Unknown_Frame",(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );
*/
            CFuncReadSFQ(hpRoot,Frame_Len, SFQ_Index);

            break;

        default:
            fiLogDebugString(hpRoot,
                  CStateLogConsoleERROR,
                  "Unknown Type !",
                  (char *)agNULL,(char *)agNULL,
                  (void *)agNULL,(void *)agNULL,
                  0,0,0,0,0,0,0,0);

    }


    osChipIOLoWriteBit32(hpRoot, ChipIOLo_SFQ_Consumer_Index, SFQ_Index);

}

void  CFuncReadSFQ(agRoot_t * hpRoot, os_bit32 Frame_Len, os_bit32 SFQ_Index )
{

    SFThread_t                  * pSFThread             =( SFThread_t *) agNULL;
    CDBThread_t                 * pCDBThread            =( CDBThread_t *) agNULL;
    CThread_t                   * pCThread              = CThread_ptr(hpRoot);
    DevThread_t                 * pDevThread;

    fiMemMapMemoryDescriptor_t  *   SFQ_MemoryDescriptor = &(pCThread->Calculation.MemoryLayout.SFQ);
    os_bit32  fi_status;
    os_bit32 SFQ_Num_entry;
    os_bit32 SFQ_Start_index;
    os_bit32 ELS_Status;
    os_bit32 CT_Status;

    if(Frame_Len % 64) SFQ_Num_entry = (Frame_Len / 64) + 1;
    else SFQ_Num_entry = (Frame_Len / 64);

    SFQ_Start_index = SFQ_Index - SFQ_Num_entry;

    if (SFQ_Start_index > SFQ_MemoryDescriptor->elements)
                SFQ_Start_index += SFQ_MemoryDescriptor->elements;


    fi_status =  Find_SF_Thread( hpRoot, SFQ_Start_index, Frame_Len, &pSFThread );
    if( fi_status ==  0xBAD0BAD1)
    {
        return;
    }
    pCDBThread = ( CDBThread_t *)pSFThread;

    if(pSFThread != ( SFThread_t *)agNULL)
    {

        if( pSFThread->thread_hdr.threadType == threadType_SFThread)
        {

            fiLogDebugString(hpRoot,
                        CStateLogConsoleLevelLip,
                        "Find_SF_Thread Thread %p fi_status %x  SF_CMND_Class %x Type %x State %x",
                        (char *)agNULL,(char *)agNULL,
                        pSFThread,agNULL,
                        fi_status,
                        pSFThread->SF_CMND_Class,
                        pSFThread->SF_CMND_Type,
                        pSFThread->SF_CMND_State,
                        0,0,0,0);
#ifdef NAME_SERVICES
            /* Check for the CMD_Class CT. Find_SF_Thread does all the processing
             * and returns the SF Thread. This part of the code is just to send the
             * the appropriate events to the SF thread based on the results */

            if (pSFThread->SF_CMND_Class    == SFThread_SF_CMND_Class_CT)
            {
                CT_Status = pSFThread->SF_CMND_State;
                switch(pSFThread->SF_CMND_Type)

                {
                    case SFThread_SF_CMND_CT_Type_RFT_ID:

                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleLevelLip -  2,
                                    "RFT_ID SF_CMND_State %x SFQ_Index %x fi_status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    CT_Status,
                                    SFQ_Start_index,
                                    fi_status,
                                    0,0,0,0,0);

                            switch(fi_status)
                            {
                                case fiCT_Cmd_Status_ACC:
                                    fiSendEvent(&pSFThread->thread_hdr,SFEventRFT_IDAccept);
                                    break;
                                case fiCT_Cmd_Status_RJT:
                                    fiSendEvent(&pSFThread->thread_hdr,SFEventRFT_IDRej);
                                    break;
                                default:
                                    fiLogDebugString(hpRoot,
                                            CFuncLogConsoleERROR,
                                            "Unknown Status %x",
                                            (char *)agNULL,(char *)agNULL,
                                            (void *)agNULL,(void *)agNULL,
                                            fi_status,
                                            0,0,0,0,0,0,0);

                            }
                    break;

                    case  SFThread_SF_CMND_CT_Type_GID_FT:

                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleLevelLip -  2,
                                    "GID_FT SF_CMND_State %x SFQ_Index %x fi_status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    CT_Status,
                                    SFQ_Start_index,
                                    fi_status,
                                    0,0,0,0,0);

                            switch(fi_status)
                            {
                                case fiCT_Cmd_Status_ACC:
                                    if (!(pCThread->ExpectMoreNSFrames))
                                        fiSendEvent(&pSFThread->thread_hdr,SFEventGID_FTAccept);
                                    else
                                    {
                                        fiLogDebugString(hpRoot,
                                        CStateLogConsoleLevelLip -  2,
                                        "More Name Server database frames to follow !!!",
                                        (char *)agNULL,(char *)agNULL,
                                        (void *)agNULL,(void *)agNULL,
                                        0,0,0,0,0,0,0,0);
                                   }
                                    break;
                                case fiCT_Cmd_Status_RJT:
                                    fiSendEvent(&pSFThread->thread_hdr,SFEventGID_FTRej);
                                    break;
                                default:
                                    fiLogDebugString(hpRoot,
                                            CFuncLogConsoleERROR,
                                            "Unknown Status %x",
                                            (char *)agNULL,(char *)agNULL,
                                            (void *)agNULL,(void *)agNULL,
                                            fi_status,
                                            0,0,0,0,0,0,0);

                            }
                    break;

                    default:
                            fiLogDebugString(hpRoot,
                                        CFuncLogConsoleERROR,
                                        "Unknown Sent CT Command  ",
                                        (char *)agNULL, (char *)agNULL,
                                        (void *)agNULL,(void *)agNULL,
                                         0,0,0,0,0,0,0,0);
                }
            }
#endif  /* NAME_SERVICES */

            if(pSFThread->SF_CMND_Class == SFThread_SF_CMND_Class_LinkSvc)
            {
                ELS_Status = pSFThread->SF_CMND_State;
                switch(pSFThread->SF_CMND_Type)

                {
                    case SFThread_SF_CMND_LinkSvc_Type_PLOGI:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleLevelLip,
                                    "FC_ELS_Type_PLOGI SF_CMND_State %x SFQ_Index %x fi_status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status,
                                    SFQ_Start_index,
                                    fi_status,
                                    0,0,0,0,0);

                            switch(fi_status)
                            {
                                case fiLinkSvc_Cmd_Status_ACC:
                                    fiSendEvent(&pSFThread->thread_hdr,SFEventPlogiAccept);
                                    break;
                                case fiLinkSvc_Cmd_Status_RJT:
                                    fiSendEvent(&pSFThread->thread_hdr,SFEventPlogiRej);
                                    break;
                                case fiLinkSvc_Cmd_Status_PLOGI_From_Self:
                                    fiSendEvent(&pSFThread->thread_hdr,SFEventPlogiAccept);
                                    break;

                                default:
                                    fiLogDebugString(hpRoot,
                                            CFuncLogConsoleERROR,
                                            "Unknown Status %x",
                                            (char *)agNULL,(char *)agNULL,
                                            (void *)agNULL,(void *)agNULL,
                                            fi_status,
                                            0,0,0,0,0,0,0);

                           }
                           break;

                    case SFThread_SF_CMND_LinkSvc_Type_FLOGI:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "FC_ELS_Type_FLOGI ELS_Status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,0,0,0,0,0,0,0);
                            if( fi_status == fiLinkSvc_Cmd_Status_RJT )
                            fiSendEvent(&pSFThread->thread_hdr,SFEventFlogiRej);
                            else
                            fiSendEvent(&pSFThread->thread_hdr,SFEventFlogiAccept);
                            break;

                    case SFThread_SF_CMND_LinkSvc_Type_ABTS:
                           fiLogDebugString(hpRoot,
                                    CDBStateAbortPathLevel,
                                    "FC_ELS_Type_ABTS ELS_Status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,0,0,0,0,0,0,0);
                            if( fi_status == fiLinkSvc_Cmd_Status_RJT )
                            fiSendEvent(&pSFThread->thread_hdr,SFEventAbortRej);
                            else
                            fiSendEvent(&pSFThread->thread_hdr,SFEventAbortAccept);
                            break;

                    case SFThread_SF_CMND_LinkSvc_Type_LOGO:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "FC_ELS_Type_LOGO ELS_Status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,0,0,0,0,0,0,0);
                            if( fi_status == fiLinkSvc_Cmd_Status_RJT )
                            fiSendEvent(&pSFThread->thread_hdr,SFEventLogoRej);
                            else
                            fiSendEvent(&pSFThread->thread_hdr,SFEventLogoAccept);
                            break;
                    case SFThread_SF_CMND_LinkSvc_Type_SRR:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "FC_ELS_Type_SRR ELS_Status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,0,0,0,0,0,0,0);

                            if( fi_status == fiLinkSvc_Cmd_Status_RJT )
                            fiSendEvent(&pSFThread->thread_hdr,SFEventSRRRej);
                            else
                            fiSendEvent(&pSFThread->thread_hdr,SFEventSRRAccept);
                            break;

                    case SFThread_SF_CMND_LinkSvc_Type_REC:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "FC_ELS_Type_REC ELS_Status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,0,0,0,0,0,0,0);

                            if( fi_status == fiLinkSvc_Cmd_Status_RJT )
                            fiSendEvent(&pSFThread->thread_hdr,SFEventRECRej);
                            else
                            fiSendEvent(&pSFThread->thread_hdr,SFEventRECAccept);
                            break;

                    case SFThread_SF_CMND_LinkSvc_Type_PRLI:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleLevelLip,
                                    "FC_ELS_Type_PRLI ELS_Status %x SFQ_Index %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,SFQ_Start_index,0,0,0,0,0,0);
                            if( fi_status == fiLinkSvc_Cmd_Status_RJT )
                            fiSendEvent(&pSFThread->thread_hdr,SFEventPrliRej);
                            else
                            fiSendEvent(&pSFThread->thread_hdr,SFEventPrliAccept);
                            break;
                    case SFThread_SF_CMND_LinkSvc_Type_PRLO:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleLevelLip -  2,
                                    "FC_ELS_Type_PRLO ELS_Status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,0,0,0,0,0,0,0);
                            if( fi_status == fiLinkSvc_Cmd_Status_RJT )
                            fiSendEvent(&pSFThread->thread_hdr,SFEventPrloRej);
                            else
                            fiSendEvent(&pSFThread->thread_hdr,SFEventPrloAccept);
                            break;
                    case SFThread_SF_CMND_LinkSvc_Type_ADISC:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "FC_ELS_Type_ADISC ELS_Status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,0,0,0,0,0,0,0);
                            if( fi_status == fiLinkSvc_Cmd_Status_RJT )
                            fiSendEvent(&pSFThread->thread_hdr,SFEventAdiscRej);
                            else
                            fiSendEvent(&pSFThread->thread_hdr,SFEventAdiscAccept);
                            break;
                   case SFThread_SF_CMND_LinkSvc_Type_SCR:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "FC_ELS_Type_SCR ELS_Status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,0,0,0,0,0,0,0);
                            if( fi_status == fiLinkSvc_Cmd_Status_RJT )
                            fiSendEvent(&pSFThread->thread_hdr,SFEventSCRRej);
                            else
                            fiSendEvent(&pSFThread->thread_hdr,SFEventSCRAccept);
                            break;

#ifdef _DvrArch_1_30_
                   case SFThread_SF_CMND_LinkSvc_Type_FARP_REQ:
                           fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "FC_ELS_Type_FARP_REQ ELS_Status %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    ELS_Status ,0,0,0,0,0,0,0);
                            if( fi_status == fiLinkSvc_Cmd_Status_ACC )
                                fiSendEvent(&pSFThread->thread_hdr,SFEventFarpReplied);
                            break;
#endif /* _DvrArch_1_30_ was defined */

                    default:
                        fiLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            "UnKnown ELS type %x",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pSFThread->SF_CMND_Type,
                            0,0,0,0,0,0,0);
                    }

            }
            else
            {
                if( pSFThread->SF_CMND_Type == SFThread_SF_CMND_SF_FCP_Type_TargetReset)
                {
                    if(fi_status ==  fiSF_FCP_Cmd_Status_Success)
                    {
                        fiSendEvent(&pSFThread->thread_hdr,SFEventResetDeviceAccept);
                    }
                    else
                    {
                        fiSendEvent(&pSFThread->thread_hdr,SFEventResetDeviceRej);
                    }

                }
            }
        }
        else /* CDB THREAD */
        {
             pDevThread = pCDBThread->Device;

            if( pCDBThread->thread_hdr.currentState != CDBStateThreadFree)
            {
                fiLogString(hpRoot,
                            "%s CDB %p X_ID %X CDBa %X state %d",
                            "CFuncReadSFQ",(char *)agNULL,
                            pCDBThread,agNULL,
                            pCDBThread->X_ID,
                            pCDBThread->ExchActive,
                            pCDBThread->thread_hdr.currentState,
                            0,0,0,0,0);
            }

/*
             fiLogString(hpRoot,
                        "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                        pCDBThread->CDB_CMND_Class,
                        pCDBThread->CDB_CMND_Type,
                        pCDBThread->CDB_CMND_State,
                        pCDBThread->CDB_CMND_Status,
                        0,0,0);
*/
            if(pCDBThread->CDB_CMND_Class == SFThread_SF_CMND_Class_FC_Tape)
            {
                if( pCDBThread->CDB_CMND_Type == SFThread_SF_CMND_Type_CDB_FC_Tape)
                {
                    if( pCDBThread->CDB_CMND_State == SFThread_SF_CMND_State_CDB_FC_Tape_ReSend)
                    {
/*
                         fiLogString(hpRoot,
                                    "%s Device %02X %s IO X_ID %X",
                                    "CFuncReadSFQ","CDBEventREC_TOV",
                                    (void *)agNULL,(void *)agNULL,
                                    pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                                    pCDBThread->X_ID,
                                    0,0,0,0,0,0);
*/
                        fiSendEvent(&pCDBThread->thread_hdr,CDBEventREC_TOV);
                    }
                    if( pCDBThread->CDB_CMND_State == SFThread_SF_CMND_State_CDB_FC_Tape_GotXRDY)
                    {
                        if( pCDBThread->CDB_CMND_Status == SFThread_SF_CMND_Status_CDB_FC_TapeInitiatorReSend_Data)
                        {
                            if(! fiListElementOnList(  &(pCDBThread->CDBLink), &(pCThread->Free_CDBLink)))
                            {
/*
                                 fiLogString(hpRoot,
                                            "Device %02X Resend IO X_ID %X",
                                            (char *)agNULL,(char *)agNULL,
                                            (void *)agNULL,(void *)agNULL,
                                            pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                                            pCDBThread->X_ID,
                                            0,0,0,0,0,0);
*/
                                fiSendEvent(&(pCDBThread->thread_hdr),CDBEvent_ResendIO);
                            }
                            else
                            {
/*
                                 fiLogDebugString(hpRoot,
                                            CDBStateLogErrorLevel,
                                            "Not Free !! Device %02X Resend IO X_ID %X",
                                            (char *)agNULL,(char *)agNULL,
                                            (void *)agNULL,(void *)agNULL,
                                            pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                                            pCDBThread->X_ID,
                                            0,0,0,0,0,0);
*/
                            }
                        }

                    }

                }
                else /* pCDBThread->CDB_CMND_Type != SFThread_SF_CMND_Type_CDB_FC_Tape */
                {

                    if((pCDBThread->thread_hdr.currentState == CDBStateSendIo) && (pCDBThread->ExchActive))
                    {
                        pCThread->LinkDownTime = pCThread->TimeBase;
                        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);

                        fiLogDebugString(hpRoot,
                                        FCMainLogErrorLevel,
                                        "%s CDB %X  Start %X Ldt %X",
                                        "CFuncReadSFQ",(char *)agNULL,
                                        (void *)agNULL,(void *)agNULL,
                                        pCDBThread->X_ID,
                                        pCDBThread->CDBStartTimeBase.Lo,
                                        pCThread->LinkDownTime.Lo,
                                        0,0,0,0,0);

                        pCDBThread->CompletionStatus = osIOAborted;
                        fiSendEvent(&(pCDBThread->thread_hdr),CDBEvent_PrepareforAbort);
                        if(! fiListElementOnList(  &(pCDBThread->CDBLink), &(pCThread->Free_CDBLink)))
                        {
                            fiSendEvent(&(pCDBThread->thread_hdr),CDBEventAlloc_Abort);
                        }
                    }

                    fiLogDebugString(hpRoot,
                                CStateLogConsoleHideInboundErrors,
                                "AL_PA %X  FC_Tape %X",
                                (char *)agNULL,(char *)agNULL,
                                agNULL,agNULL,
                                fiComputeDevThread_D_ID(pDevThread),
                                pDevThread->FC_TapeDevice,
                                0,0,0,0,0,0);


                }
            }/* end fctape */
            else /* pCDBThread->CDB_CMND_Class != SFThread_SF_CMND_Class_FC_Tape */
            {
                if(! fiListElementOnList(  &(pCDBThread->CDBLink), &(pCThread->Free_CDBLink)))
                {
                    fiSendEvent(&(pCDBThread->thread_hdr),CDBEventIODeviceReset);
                }
                else
                {
                    if( pCDBThread->thread_hdr.currentState != CDBStateThreadFree)
                    {
                        fiLogString(hpRoot,
                                        "%s X_ID %X IO Failed Device %X On Free %x State %d",
                                        "CFuncReadSFQ",(char *)agNULL,
                                        (void *)agNULL,(void *)agNULL,
                                        pCDBThread->X_ID,
                                        fiComputeDevThread_D_ID(pDevThread),
                                        fiListElementOnList(  &(pCDBThread->CDBLink), &(pCThread->Free_CDBLink)),
                                        pCDBThread->thread_hdr.currentState,
                                        0,0,0,0);
                    }
                }
            }
        }/* End CDB THREAD */
    }
    else /* No thread associated with this entry  */
    {
       switch ( fi_status )
	{
          case fiLinkSvc_Cmd_Status_PLOGI_From_Twin:
            fiLogDebugString(hpRoot,
                        CFuncLogConsoleERROR,
                        "PLOGI With same AL_PA !!!!",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

            fiLogString(hpRoot,
                            "PLOGI With same AL_PA !!!!",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            0,0,0,0,0,0,0,0);

            fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);


            break;

          case fiLinkSvc_Cmd_Status_PLOGI_From_Other:
           fiLogDebugString(hpRoot,
                        CStateLogConsoleLevelLip,
                        "PLOGI from someone  !!!!",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

            break;

          case fiLinkSvc_Cmd_Status_Position_Map:
            {
                FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t * AL_PA_Position_Map   = (FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *)(CThread_ptr(hpRoot)->Calculation.MemoryLayout.LOOPDeviceMAP.addr.CachedMemory.cachedMemoryPtr);
    
                pCThread->LoopMapLIRP_Received = agTRUE;
                pCThread->DeviceDiscoveryMethod = DDiscoveryLoopMapReceived;
                CFuncLoopMapRecieved(hpRoot,agFALSE);

                fiLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            "%s Flags %8X Index %02X",
                            "fiLinkSvc_Cmd_Status_Position_Map",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            AL_PA_Position_Map->Code_Flags,
                            (os_bit32)AL_PA_Position_Map->AL_PA_Index,
                            0,0,0,0,0,0);

                break;
            }
#ifdef _DvrArch_1_30_
          case fiLinkSvc_Cmd_Status_FARP_From_Twin:
            fiLogDebugString(hpRoot,
                        CFuncLogConsoleERROR,
                        "FARP With same AL_PA !!!!",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

            fiLogString(hpRoot,
                            "FARP With same AL_PA !!!!",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            0,0,0,0,0,0,0,0);

            fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);


            break;

          case fiLinkSvc_Cmd_Status_FARP_From_Other:
            fiLogDebugString(hpRoot,
                        CStateLogConsoleLevelLip,
                        "FARP from someone  !!!!",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

            break;

          case fiIP_Cmd_Status_Incoming:
           fiLogDebugString(hpRoot,
                        CStateLogConsoleLevelLip,
                        "IP Data from someone  !!!!",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
	   break;

#endif /* _DvrArch_1_30_ was defined */

        }
    }
}

os_bit32     Find_SF_Thread(  agRoot_t        *hpRoot,
                           SFQConsIndex_t   SFQConsIndex,
                           os_bit32            Frame_Length,
                           SFThread_t     **SFThread_to_return
                         )
{
    os_bit32 fi_status;
    CDBThread_t * pCDBThread;

#ifdef _DvrArch_1_30_
    fi_status = fiIPProcessSFQ( hpRoot, SFQConsIndex, Frame_Length, (fi_thread__t **) SFThread_to_return );
    if(fi_status != fiIP_Cmd_Status_Confused)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevelLip,
                    "Find_SF_Thread IP match ! fi_status %x thread %p",
                    (char *)agNULL,(char *)agNULL,
                    *SFThread_to_return,agNULL,
                    fi_status,
                    0,0,0,0,0,0,0);

        return fi_status;
    }
#endif /* _DvrArch_1_30_ was defined */

#ifdef NAME_SERVICES

    fi_status= fiCTProcessSFQ( hpRoot, SFQConsIndex, Frame_Length, (fi_thread__t **)SFThread_to_return );
    if(fi_status != fiCT_Cmd_Status_Confused)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevelLip,
                    "Find_SF_Thread CT match ! fi_status %x thread %p",
                    (char *)agNULL,(char *)agNULL,
                    *SFThread_to_return,agNULL,
                    fi_status,
                    0,0,0,0,0,0,0);

        return fi_status;
    }
#endif  /* NAME_SERVICES */

    fi_status= fiLinkSvcProcessSFQ( hpRoot, SFQConsIndex, Frame_Length, (fi_thread__t **)SFThread_to_return );

    if(fi_status != fiLinkSvc_Cmd_Status_Confused)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevelLip,
                    "Find_SF_Thread LinkSvc match ! fi_status %x thread %p",
                    (char *)agNULL,(char *)agNULL,
                    *SFThread_to_return,agNULL,
                    fi_status,
                    0,0,0,0,0,0,0);

        return fi_status;
    }

    fi_status = fiSF_FCP_ProcessSFQ( hpRoot, SFQConsIndex, Frame_Length, (fi_thread__t **)SFThread_to_return );

    if(fi_status != fiSF_FCP_Cmd_Status_Confused)
    {
        pCDBThread = (CDBThread_t *) *SFThread_to_return;
        if(pCDBThread)
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleLevelLip,
                        "Find_SF_Thread SF_FCP match ! fi_status %x thread %p State %d X_ID %X @ %d",
                        (char *)agNULL,(char *)agNULL,
                        *SFThread_to_return,agNULL,
                        fi_status,
                        (os_bit32)pCDBThread->thread_hdr.currentState,
                        pCDBThread->X_ID,
                        pCDBThread->TimeStamp,
                        0,0,0,0);
        }
        else
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleLevelLip,
                        "Find_SF_Thread SF_FCP match ! fi_status %x thread %p",
                        (char *)agNULL,(char *)agNULL,
                        *SFThread_to_return,agNULL,
                        fi_status,
                        0,0,0,0,0,0,0);
        }
        return fi_status;
    }

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Find_SF_Thread Failed to match !",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fi_status,0,0,0,0,0,0,0);


    return 0xBAD0BAD1;

}

void CFuncOutBoundCompletion(agRoot_t * hpRoot,
         os_bit32 Bits__SEST_Index__Trans_ID,
         os_bit32 More_Bits
)
{
    CThread_t       *  pCThread     = CThread_ptr(hpRoot);
    CDBThread_t     *  pCDBThread;
    SFThread_t      *  pSFThread;
    os_bit32          X_ID;
    USE_t           * SEST;
    event_t           event_to_send = 0;

#ifdef _DvrArch_1_30_
    os_bit32       X_ID_Offset;
    PktThread_t     *pPktThread;

    fiMemMapMemoryDescriptor_t * PktThread_MemoryDescriptor = &(CThread_ptr(hpRoot)->Calculation.MemoryLayout.PktThread);
#endif /* _DvrArch_1_30_ was defined */

    fiMemMapMemoryDescriptor_t * CDBThread_MemoryDescriptor = &(CThread_ptr(hpRoot)->Calculation.MemoryLayout.CDBThread);
    fiMemMapMemoryDescriptor_t * SFThread_MemoryDescriptor  = &(CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFThread);

    X_ID =(Bits__SEST_Index__Trans_ID  & CM_Outbound_SEST_Index_MASK);

#ifdef _DvrArch_1_30_
    X_ID_Offset = (X_ID_t)(CDBThread_MemoryDescriptor->elements + SFThread_MemoryDescriptor->elements);
    if( X_ID >= X_ID_Offset)
    {
        X_ID -= (X_ID_t)(X_ID_Offset);
        pPktThread = (PktThread_t *)((os_bit8 *)(PktThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                 + (X_ID * sizeof(PktThread_t)));
	pPktThread->status = FC_CMND_STATUS_SUCCESS;
        pCThread->IP->CompletedPkt = pPktThread;
        fiSendEvent(&(pCThread->IP->thread_hdr),IPEventOutgoingComplete);
	return;
    }
    else
#endif /* _DvrArch_1_30_ was defined */
    if( X_ID >= CDBThread_MemoryDescriptor->elements)
    {

        X_ID -= (X_ID_t)(CDBThread_MemoryDescriptor->elements);

        pSFThread = (SFThread_t *)((os_bit8 *)(SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                 + (X_ID * sizeof(SFThread_t)));

        if(pSFThread->SF_CMND_Class == SFThread_SF_CMND_Class_LinkSvc)
        {

            switch(pSFThread->SF_CMND_Type)
            {

/*
                case SFThread_SF_CMND_LinkSvc_Type_BA_RJT:
                    event_to_send = ;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_RRQ:
                    event_to_send = ;
                    break;
*/
                case SFThread_SF_CMND_LinkSvc_Type_ABTS:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoAbort )
                    {
                        event_to_send = SFStateAbortRej;
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_PLOGI:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPlogi )
                    {
                        event_to_send = SFEventPlogiBadALPA;
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_FLOGI:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoFlogi )
                    {
                        if(More_Bits & CM_Outbound_FTO )
                        {
                            event_to_send = SFEventFlogiBadALPA;
                        }
                        else
                        {
                            event_to_send = SFEventFlogiRej;
                        }
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_LOGO:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoLogo )
                    {
                        event_to_send = SFEventLogoRej;
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_SRR:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoSRR )
                    {
                        event_to_send = SFEventSRRRej;
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_REC:
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Outbound SF %s Bits %8X X_ID %08X",
                            "SFEventRECRej",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            More_Bits,
                            Bits__SEST_Index__Trans_ID,
                            0,0,0,0,0,0);

                    if ( pSFThread->thread_hdr.currentState == SFStateDoREC )
                    {
                        event_to_send = SFEventRECRej;
                    }
                    break;

               case SFThread_SF_CMND_LinkSvc_Type_PRLI:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPrli )
                    {
                        pSFThread->parent.Device->PRLI_rejected = agTRUE;
                    }
                    event_to_send = SFEventPrliRej;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_PRLO:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPrlo )
                    {
                        event_to_send = SFEventPrloRej;
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_ADISC:
                    if ( pSFThread->thread_hdr.currentState ==  SFStateDoAdisc)
                    {
                        event_to_send = SFEventAdiscRej;
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_SCR:
                    if ( pSFThread->thread_hdr.currentState ==  SFStateDoSCR)
                    {
                        event_to_send = SFEventSCRRej;
                    }
                    break;
                /* Target Mode response */

                case SFThread_SF_CMND_LinkSvc_Type_LS_RJT:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoLS_RJT )
                    {
                        event_to_send = SFEventLS_RJT_Done;
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_PLOGI_ACC:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPlogiAccept )
                    {
                        event_to_send = SFEventPlogiAccept_Done;
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_PRLI_ACC:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPrliAccept )
                    {
                        event_to_send = SFEventPrliAccept_Done;
                    }
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_ELS_ACC:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoELSAccept )
                    {
                        event_to_send = SFEventELSAccept_Done;
                    }
                    break;
                case SFThread_SF_CMND_LinkSvc_Type_ADISC_ACC:
                    if ( pSFThread->thread_hdr.currentState == SFEventDoADISCAccept )
                    {
                        event_to_send = SFEventADISCAccept_Done;
                    }
                    break;
#ifdef _DvrArch_1_30_
                case SFThread_SF_CMND_LinkSvc_Type_FARP_REPLY:
                    if ( pSFThread->thread_hdr.currentState == SFEventDoFarpReply )
                    {
                        event_to_send = SFEventFarpReplyDone;
                    }
                    break;
#endif /* _DvrArch_1_30_ was defined */

                default:
                    event_to_send = 0;
                /* ELS Command == 0 Reset device SFthread */
            }
        }
        else
        {
            switch(pSFThread->SF_CMND_Type)
            {

                case SFThread_SF_CMND_SF_FCP_Type_FCP_RSP_IU:
                    event_to_send = SFStateFCP_DR_ACC_Reply_Done;
                    break;

                case SFThread_SF_CMND_SF_FCP_Type_TargetReset:
                    event_to_send = SFEventResetDeviceBadALPA;
                    break;

                default:
                    event_to_send = 0;
            }


        }

        if(More_Bits & CM_Outbound_LKF)
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Outbound SF Link Failure  Bits %8X X_ID %08X Event %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    More_Bits,
                    Bits__SEST_Index__Trans_ID,
                    event_to_send,
                    0,0,0,0,0);

           if( !(pCThread->thread_hdr.currentState == CStateInitFM            ||
                 pCThread->thread_hdr.currentState == CStateInitFM_DelayDone  ||
                 pCThread->thread_hdr.currentState == CStateResetNeeded       ||
                 pCThread->thread_hdr.currentState == CStateReInitFM            ))
            {
                if ((pCThread->DEVID == ChipConfig_DEVID_TachyonTL) && (pCThread->REVID < ChipConfig_REVID_2_2))
                {
                    fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);
                }
            }
        }

        if(More_Bits & CM_Outbound_HPE)
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Outbound SF Host Programing Error  Bits %8X X_ID %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    More_Bits,
                    Bits__SEST_Index__Trans_ID,
                    0,0,0,0,0,0);

            if( !(pCThread->thread_hdr.currentState == CStateInitFM            ||
                  pCThread->thread_hdr.currentState == CStateInitFM_DelayDone  ||
                  pCThread->thread_hdr.currentState == CStateResetNeeded       ||
                  pCThread->thread_hdr.currentState == CStateReInitFM             ))
            {
/*
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);
*/            }
        }

        if(More_Bits & CM_Outbound_ASN)
        {
            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Outbound SF Abort Sequence Notification Bits %8X X_ID %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            More_Bits,
                            Bits__SEST_Index__Trans_ID,
                            0,0,0,0,0,0);
            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "ASN Failed FM %08X TL status %08X Qf %d CState %d",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                            CFunc_Queues_Frozen( hpRoot ),
                            pCThread->thread_hdr.currentState,
                            0,0,0,0);

            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            CThread_ptr(hpRoot)->LOOP_DOWN,
                            CThread_ptr(hpRoot)->IDLE_RECEIVED,
                            CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                            CThread_ptr(hpRoot)->ERQ_FROZEN,
                            CThread_ptr(hpRoot)->FCP_FROZEN,
                            CThread_ptr(hpRoot)->ProcessingIMQ,
                            0,0);


            if( !(pCThread->thread_hdr.currentState == CStateInitFM            ||
                  pCThread->thread_hdr.currentState == CStateInitFM_DelayDone  ||
                  pCThread->thread_hdr.currentState == CStateResetNeeded       ||
                  pCThread->thread_hdr.currentState == CStateReInitFM             ))
            {
                if( pCThread->thread_hdr.currentState == CStateInitializeFailed  )
                {
                    return;
                }
                else
                {
/*
                    fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);
*/
                }
            }

        }

        if(More_Bits & CM_Outbound_FTO)
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Outbound SF Frame TimeOut Bits %8X X_ID %08X Class %X Type %X State %X Thread State %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    More_Bits,
                    Bits__SEST_Index__Trans_ID,
                    pSFThread->SF_CMND_Class,
                    pSFThread->SF_CMND_Type,
                    pSFThread->SF_CMND_State,
                    pSFThread->thread_hdr.currentState,
                    0,0);
/*
            if( !(pCThread->thread_hdr.currentState == CStateInitFM            ||
                  pCThread->thread_hdr.currentState == CStateInitFM_DelayDone  ||
                  pCThread->thread_hdr.currentState == CStateResetNeeded       ||
                  pCThread->thread_hdr.currentState == CStateReInitFM             ))
            {
                if ((pCThread->DEVID == ChipConfig_DEVID_TachyonTL) && (pCThread->REVID < ChipConfig_REVID_2_2))
                {
                    fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);
                }
            }
*/
        }
        if(event_to_send != 0)
        {
            fiSendEvent(&pSFThread->thread_hdr, event_to_send);
        }
        else
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "SF Frame Thread %p NOT VALID Bits %8x X_ID %08X Class %X Type %X CmdState %X SFState %d",
                    (char *)agNULL,(char *)agNULL,
                    pSFThread,agNULL,
                    More_Bits,
                    Bits__SEST_Index__Trans_ID,
                    pSFThread->SF_CMND_Class,
                    pSFThread->SF_CMND_Type,
                    pSFThread->SF_CMND_State,
                    pSFThread->thread_hdr.currentState,
                    0,0);
            /* fiSendEvent(&pSFThread->thread_hdr, SFEventReset);
               pCThread->SFpollingCount--;
            */
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Cleared SF Thread  SFState %d CCnt %x",
                    "CFuncOutBoundCompletion",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pSFThread->thread_hdr.currentState,
                    pCThread->SFpollingCount,
                    0,0,0,0,0,0);
 
        }
    }
    else
    {
        event_to_send = CDBEventIODeviceReset;

        pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                  + (X_ID * CDBThread_MemoryDescriptor->elementSize));

        SEST = (USE_t *)pCDBThread->SEST_Ptr;

        if(SEST)
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "Sest DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Bits,
                        SEST->Unused_DWord_1,
                        SEST->Unused_DWord_2,
                        SEST->Unused_DWord_3,
                        SEST->LOC,
                        SEST->Unused_DWord_5,
                        SEST->Unused_DWord_6,
                        SEST->Unused_DWord_7);

            fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "Sest DWORD 8 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Unused_DWord_8,
                        SEST->Unused_DWord_9,
                        SEST->First_SG.U32_Len,
                        SEST->First_SG.L32,
                        SEST->Second_SG.U32_Len,
                        SEST->Second_SG.L32,
                        SEST->Third_SG.U32_Len,
                        SEST->Third_SG.L32);
        }

        if(More_Bits & CM_Outbound_LKF)
        {
            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Outbound CDB Link Failure %08X %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            More_Bits,Bits__SEST_Index__Trans_ID,0,0,0,0,0,0);

            /*event_to_send = CDBEventIODeviceReset;*/
        }

        if(More_Bits & CM_Outbound_HPE)
        {
            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Outbound CDB Host Programing Error %08X %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            More_Bits,Bits__SEST_Index__Trans_ID,0,0,0,0,0,0);
            /*event_to_send = CDBEventFailNoRSP;*/
        }

        if(More_Bits & CM_Outbound_ASN)
        {
            pCThread->Loop_State_TimeOut_In_tick++;
            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Outbound CDB Abort Sequence Notification %08X %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            More_Bits,Bits__SEST_Index__Trans_ID,0,0,0,0,0,0);
            /*event_to_send = CDBEventIODeviceReset;*/
        }

        if(More_Bits & CM_Outbound_FTO)
        {
            pCThread->Loop_State_TimeOut_In_tick++;
            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Outbound CDB Frame TimeOut %08X %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            More_Bits,Bits__SEST_Index__Trans_ID,0,0,0,0,0,0);
            /*event_to_send = CDBEventIODeviceReset;*/
        }
/*
        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "Outbound CDB Sends event %d X_ID %X State %d",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        event_to_send,
                        X_ID,
                        pCDBThread->thread_hdr.currentState,
                        0,0,0,0,0);
*/
        if( pCDBThread->thread_hdr.currentState == CDBStateSendIo )
        {
            if (!(pCDBThread->ExchActive))
            {
                fiLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            "Outbound Found a cbdthread that is not active... %p State %d",
                            (char *)agNULL,(char *)agNULL,
                            pCDBThread,agNULL,
                            pCDBThread->thread_hdr.currentState,0,0,0,0,0,0,0);
/*
                 fiLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                            (os_bit32)pCDBThread->CDB_CMND_Class,
                            (os_bit32)pCDBThread->CDB_CMND_Type,
                            (os_bit32)pCDBThread->CDB_CMND_State,
                            (os_bit32)pCDBThread->CDB_CMND_Status,
                            0,0,0);
*/
                return;
            }
            if(! pCDBThread->ActiveDuringLinkEvent)
            {
                fiSendEvent(&pCDBThread->thread_hdr, event_to_send);
            }
        }
    }

    if(! pCThread->LOOP_DOWN )
    {
       /* Clear IDLE_RECEIVED if we clear Queues
        */
        if ( CFunc_Always_Enable_Queues(hpRoot ) )
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) OB Queues Frozen after enable !",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        0,0,0,0,0,0,0,0);
        }
    }
    else
    {
        pCThread->OUTBOUND_RECEIVED = agTRUE;
    }


    if(CFunc_Queues_Frozen( hpRoot ))
    {
        fiLogDebugString(hpRoot,
                        CSTATE_NOISE(hpRoot,CStateFindDevice),
                        "Outbound CFunc_Queues_Frozen LD %x IR %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->LOOP_DOWN,
                        pCThread->IDLE_RECEIVED,
                        0,0,0,0,0,0);

    }

}

void CFunc_LOGO_Completion(agRoot_t * hpRoot,  os_bit32 X_ID)
{
    CThread_t       *  pCThread     = CThread_ptr(hpRoot);
    CDBThread_t     *  pCDBThread;
    SFThread_t      *  pSFThread;
    USE_t           * SEST;
    event_t           event_to_send = 0;

    fiMemMapMemoryDescriptor_t * CDBThread_MemoryDescriptor = &(CThread_ptr(hpRoot)->Calculation.MemoryLayout.CDBThread);
    fiMemMapMemoryDescriptor_t * SFThread_MemoryDescriptor  = &(CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFThread);

    fiLogString(hpRoot,
            "%s Cleared X_ID %X CDBCnt %x",
            "CFunc_LOGO_Completion",(char *)agNULL,
            (void *)agNULL,(void *)agNULL,
            X_ID,
            pCThread->CDBpollingCount,
            0,0,0,0,0,0);

    if( X_ID >= CDBThread_MemoryDescriptor->elements)
    {

        if( X_ID >= CDBThread_MemoryDescriptor->elements + SFThread_MemoryDescriptor->elements)
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s X_ID Invalid !!!! %x",
                    "CFunc_LOGO_Completion",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    X_ID,
                    0,0,0,0,0,0,0);
            return;
        }

        X_ID -= (CDBThread_MemoryDescriptor->elements);

        pSFThread = (SFThread_t *)((os_bit8 *)(SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                 + (X_ID * sizeof(SFThread_t)));

        if(pSFThread->SF_CMND_Class == SFThread_SF_CMND_Class_LinkSvc)
        {

            switch(pSFThread->SF_CMND_Type)
            {

/*
                case SFThread_SF_CMND_LinkSvc_Type_BA_RJT:
                    event_to_send = ;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_RRQ:
                    event_to_send = ;
                    break;
*/
                case SFThread_SF_CMND_LinkSvc_Type_ABTS:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoAbort )
                    event_to_send = SFStateAbortRej;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_PLOGI:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPlogi )
                    event_to_send = SFEventPlogiBadALPA;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_FLOGI:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoFlogi )
                     event_to_send = SFEventFlogiRej;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_LOGO:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoLogo )
                    event_to_send = SFEventLogoRej;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_SRR:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoSRR )
                    event_to_send = SFEventSRRRej;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_REC:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoREC )
                    event_to_send = SFEventRECRej;
                    break;

               case SFThread_SF_CMND_LinkSvc_Type_PRLI:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPrli )
                    event_to_send = SFEventPrliRej;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_PRLO:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPrlo )
                    event_to_send = SFEventPrloRej;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_ADISC:
                    if ( pSFThread->thread_hdr.currentState ==  SFStateDoAdisc)
                    event_to_send = SFEventAdiscRej;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_SCR:
                    if ( pSFThread->thread_hdr.currentState ==  SFStateDoSCR)
                    event_to_send = SFEventSCRRej;
                    break;
                /* Target Mode response */

                case SFThread_SF_CMND_LinkSvc_Type_LS_RJT:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoLS_RJT )
                    event_to_send = SFEventLS_RJT_Done;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_PLOGI_ACC:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPlogiAccept )
                    event_to_send = SFEventPlogiAccept_Done;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_PRLI_ACC:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoPrliAccept )
                    event_to_send = SFEventPrliAccept_Done;
                    break;

                case SFThread_SF_CMND_LinkSvc_Type_ELS_ACC:
                    if ( pSFThread->thread_hdr.currentState == SFStateDoELSAccept )
                    event_to_send = SFEventELSAccept_Done;
                    break;

                default:
                    event_to_send = 0;
                /* ELS Command == 0 Reset device SFthread */
            }
        }
        else
        {
            switch(pSFThread->SF_CMND_Type)
            {

                case SFThread_SF_CMND_SF_FCP_Type_FCP_RSP_IU:
                    event_to_send = SFStateFCP_DR_ACC_Reply_Done;
                    break;

                case SFThread_SF_CMND_SF_FCP_Type_TargetReset:
                    event_to_send = SFEventResetDeviceBadALPA;
                    break;

                default:
                    event_to_send = 0;
            }


        }

        if(event_to_send != 0)
        {
            fiSendEvent(&pSFThread->thread_hdr, event_to_send);
            return;
        }
        else
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "SF Frame Thread %p NOT VALID X_ID %08X Class %X Type %X CmdState %X SFState %d",
                    (char *)agNULL,(char *)agNULL,
                    pSFThread,agNULL,
                    X_ID,
                    pSFThread->SF_CMND_Class,
                    pSFThread->SF_CMND_Type,
                    pSFThread->SF_CMND_State,
                    pSFThread->thread_hdr.currentState,
                    0,0,0);
            fiSendEvent(&pSFThread->thread_hdr, SFEventReset);

            /* pCThread->CDBpollingCount--; */

            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Cleared SF Thread  SFState %d CCnt %x",
                    "CFunc_LOGO_Completion",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pSFThread->thread_hdr.currentState,
                    pCThread->CDBpollingCount,
                    0,0,0,0,0,0);
 
        }
    }
    else
    {
        event_to_send = CDBEventIODeviceReset;

        pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                  + (X_ID * CDBThread_MemoryDescriptor->elementSize));

        SEST = (USE_t *)pCDBThread->SEST_Ptr;

        if(SEST)
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "Sest DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Bits,
                        SEST->Unused_DWord_1,
                        SEST->Unused_DWord_2,
                        SEST->Unused_DWord_3,
                        SEST->LOC,
                        SEST->Unused_DWord_5,
                        SEST->Unused_DWord_6,
                        SEST->Unused_DWord_7);

            fiLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "Sest DWORD 8 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Unused_DWord_8,
                        SEST->Unused_DWord_9,
                        SEST->First_SG.U32_Len,
                        SEST->First_SG.L32,
                        SEST->Second_SG.U32_Len,
                        SEST->Second_SG.L32,
                        SEST->Third_SG.U32_Len,
                        SEST->Third_SG.L32);
        }


        if( pCDBThread->thread_hdr.currentState == CDBStateSendIo )
        {
            if (!(pCDBThread->ExchActive))
            {
                fiLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            "CFunc_LOGO_Completion Found a cbdthread that is not active... %p State %d",
                            (char *)agNULL,(char *)agNULL,
                            pCDBThread,agNULL,
                            pCDBThread->thread_hdr.currentState,0,0,0,0,0,0,0);
/*
                 fiLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                            pCDBThread->CDB_CMND_Class,
                            pCDBThread->CDB_CMND_Type,
                            pCDBThread->CDB_CMND_State,
                            pCDBThread->CDB_CMND_Status,
                            0,0,0);
*/
                return;
            }

            fiSendEvent(&pCDBThread->thread_hdr, event_to_send);
        }
    }
}


void CFuncErrorERQFrozen(agRoot_t * hpRoot)
{
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    pCThread->ERQ_FROZEN = agTRUE;

    fiLogDebugString(hpRoot,
                      CStateLogConsoleLevelLip,
                      "ERQ Frozen Status %08X",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                      0,0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LOOP_DOWN,
                    CThread_ptr(hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(hpRoot)->ERQ_FROZEN,
                    CThread_ptr(hpRoot)->FCP_FROZEN,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0);

}


void CFuncErrorIdle(agRoot_t * hpRoot)
{
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    osStallThread(hpRoot, 200 );

    pCThread->IDLE_RECEIVED = agTRUE;

    if(( ! pCThread->LOOP_DOWN ) )
    {
        if( CFunc_Always_Enable_Queues(hpRoot ) )
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) IDLE Queues Frozen after enable !",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        0,0,0,0,0,0,0,0);

            if( pCThread->thread_hdr.currentState != CStateResetNeeded  )
            {
                if(pCThread->LoopPreviousSuccess)
                {
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "IDLE Previous hpRoot(%p) ResetLOOP Cstate %d sends %s (%d)",
                            "CEventAsyncLoopEventDetected",(char *)agNULL,
                            hpRoot,agNULL,
                            pCThread->thread_hdr.currentState,
                            CEventAsyncLoopEventDetected,0,0,0,0,0,0);

                    fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);
                }
                else
                {
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "IDLE hpRoot(%p) ResetLOOP Cstate %d sends %s (%d)",
                            "CEventLoopNeedsReinit",(char *)agNULL,
                            hpRoot,agNULL,
                            pCThread->thread_hdr.currentState,
                            CEventLoopNeedsReinit,0,0,0,0,0,0);

                    fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventLoopNeedsReinit);
                }
            }

        }
    }
}

void CFuncErrorFCP_Frozen(agRoot_t * hpRoot)
{
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    pCThread->FCP_FROZEN = agTRUE;

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "CFuncErrorFCP_Frozen Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0,0,0);
    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LOOP_DOWN,
                    CThread_ptr(hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(hpRoot)->ERQ_FROZEN,
                    CThread_ptr(hpRoot)->FCP_FROZEN,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0);

}


/*+
  Function: cfimq
   Purpose: When compiled updates browser info file for VC 5.0 / 6.0
   Returns: none
 Called By: none
     Calls: none
-*/
/* void cfimq(void){} */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\cfunc.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/CFUNC.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 10/14/00 12:59p $

Purpose:

  This file defines the macros, types, and data structures
  used by ../C/Cfunc.C

--*/

#ifndef __CFunc_H__
#define __CFunc_H__

#define POWER_ON_RESET_OR_BUS_DEVICE_RESET_OCCURRED     0x29
#define Interrupt_Polling_osStallThread_Parameter 21

#define SENSE_KEY_OFFSET 2
#define SENSE_ASC_OFFSET 12
#define SENSE_ASQ_OFFSET 13

#define ShowActive 1
#define ShowERQ    0


agBOOLEAN CFuncInitFM( agRoot_t *hpRoot );
os_bit32 CFuncInitChip( agRoot_t *hpRoot );

void CFuncInitFM_Registers( agRoot_t *hpRoot ,agBOOLEAN SendInit);
void CFuncInitFM_Initialize( agRoot_t *hpRoot );
agBOOLEAN CFuncInitFM_Clear_FM( agRoot_t *hpRoot );
event_t CFuncProcessFcpRsp(agRoot_t * hpRoot, CDBThread_t * pCDBThread, event_t event_to_send);

DevThread_t * CFuncMatchALPAtoThread( agRoot_t * hpRoot, FC_Port_ID_t  Port_ID);
DevThread_t * CFuncMatchPortWWNtoThread(agRoot_t * hpRoot, os_bit8 *PortWWN );
ERQConsIndex_t CFuncGetDmaMemERQConsIndex(  agRoot_t *hpRoot);
ERQConsIndex_t CFuncGetCardRamERQConsIndex( agRoot_t *hpRoot);
IMQProdIndex_t CFuncGetDmaMemIMQProdIndex(  agRoot_t *hpRoot);
IMQProdIndex_t CFuncGetCardRamIMQProdIndex( agRoot_t *hpRoot);

/* Big_Endian_Code */
void CFuncSwapDmaMemBeforeIoSent(fi_thread__t *thread, os_bit32 DoFunc);
void CFuncSwapDmaMemAfterIoDone(agRoot_t *hpRoot);

void CFuncGetHaInfoFromNVR(agRoot_t *hpRoot);

void CFuncSEST_offCard_FCPCompletion(agRoot_t * hpRoot,os_bit32 status);
void CFuncSEST_onCard_FCPCompletion(agRoot_t * hpRoot,os_bit32 status);

void CFuncFMCompletion(agRoot_t * hpRoot);
agBOOLEAN CFuncProcessNportFMCompletion(agRoot_t * hpRoot, os_bit32 fmStatus);

agBOOLEAN CFuncOffCardProcessIMQ( agRoot_t *hpRoot );
agBOOLEAN CFuncOnCardProcessIMQ(agRoot_t *hpRoot );

agBOOLEAN CFuncInterruptPoll(
                         agRoot_t *hpRoot,
                         os_bit32 * pollingCount
                       );


agBOOLEAN CFuncEnable_Queues(agRoot_t * hpRoot );


void CFuncSoftResetAdapter(agRoot_t * hpRoot);
void CFuncSoftResetAdapterNoStall(agRoot_t * hpRoot);

void CFuncDisable_Interrupts(agRoot_t * hpRoot, os_bit32 Mask);
void CFuncEnable_Interrupts(agRoot_t * hpRoot, os_bit32 Mask);

void CFuncInBoundCompletion(agRoot_t * hpRoot,os_bit32 SFQ_Index,os_bit32 Frame_len, os_bit32 Type);

void CFuncReadSFQ(agRoot_t * hpRoot, os_bit32 Frame_len,  os_bit32 SFQ_Index);
void Fc_ERROR(agRoot_t *hpRoot);

os_bit32 CFuncRead_Interrupts(agRoot_t * hpRoot);

void CFuncGreenLed(agRoot_t * hpRoot, agBOOLEAN On_or_Off);
void CFuncYellowLed(agRoot_t * hpRoot, agBOOLEAN On_or_Off);

agBOOLEAN CFuncIMQ_Interrupt_Pending(agRoot_t * hpRoot);

agBOOLEAN CFuncLoopNeedsInitializing(agRoot_t * hpRoot);

void CFuncInitializeSEST(agRoot_t * hpRoot);
void CFuncInitializeERQ(agRoot_t * hpRoot);

agBOOLEAN CFuncReInitFM( agRoot_t *hpRoot );
agBOOLEAN  CFuncClearFrameManager( agRoot_t *hpRoot, os_bit32 * Acquired_Alpa );

void CFuncInit_Lists(agRoot_t *hpRoot );

void CFuncInit_Threads(agRoot_t *hpRoot );

void  CFuncInit_DevLists( agRoot_t *hpRoot );

void  CFuncInit_TgtThreads( agRoot_t * hpRoot );

void  CFuncInit_DevThreads( agRoot_t *hpRoot );
void  CFuncInit_DirectoryDevThread(agRoot_t *hpRoot );
void CFuncInit_DevThread(agRoot_t * hpRoot, DevThread_t * pDevThread );

void  CFuncInit_CDBThreads( agRoot_t *hpRoot  );

void  CFuncInit_SFThreads( agRoot_t *hpRoot  );

void  CFuncInit_FunctionPointers(  agRoot_t *hpRoot);

void CFuncReInitializeSEST(agRoot_t * hpRoot);

void CFuncCoreReset(agRoot_t   *    hpRoot );

void CFuncOutBoundCompletion(agRoot_t * hpRoot,
         os_bit32 Bits__SEST_Index__Trans_ID,
         os_bit32 More_Bits
);

agBOOLEAN CFunc_Queues_Frozen(agRoot_t * hpRoot );

void CFuncErrorIdle(agRoot_t * hpRoot);
void CFuncErrorERQFrozen(agRoot_t * hpRoot);
void CFuncErrorFCP_Frozen(agRoot_t * hpRoot);

os_bit32 fiResetAllDevices( agRoot_t *hpRoot,  os_bit32     hpResetType );

os_bit32 fiResetDevice(
                     agRoot_t  *hpRoot,
                     agFCDev_t  hpFCDev,
                     os_bit32      hpResetType,
                     agBOOLEAN    retry,
                     agBOOLEAN  resetotherhost
                   );


os_bit32     Find_SF_Thread(  agRoot_t        *hpRoot,
                           SFQConsIndex_t   SFQConsIndex,
                           os_bit32            Frame_Length,
                           SFThread_t     **SFThread_to_return
                         );

DevSlot_t CFuncALPA_To_Slot( os_bit8 AL_PA);

agBOOLEAN CFuncLoopDownPoll( agRoot_t *hpRoot );

agBOOLEAN CFunc_Always_Enable_Queues(agRoot_t * hpRoot );

agBOOLEAN CFuncFreezeQueuesPoll( agRoot_t *hpRoot );

void CFuncInitERQ_Registers( agRoot_t *hpRoot );

agBOOLEAN CFuncAll_clear( agRoot_t *hpRoot );
agBOOLEAN CFuncTakeOffline( agRoot_t *hpRoot );
agBOOLEAN CFuncToReinit( os_bit32 FM_Status);
event_t CFuncCheckCstate(agRoot_t * hpRoot);

agBOOLEAN CFuncReadGBICSerEprom(agRoot_t * hpRoot);

agBOOLEAN CFuncShowWhereDevThreadsAre( agRoot_t * hpRoot);
agBOOLEAN CFuncShowWhereTgtThreadsAre( agRoot_t * hpRoot);
agBOOLEAN CFuncShowWhereCDBThreadsAre( agRoot_t * hpRoot);
void CFuncWhatStateAreDevThreads(agRoot_t   *    hpRoot );

void CFuncInteruptDelay(agRoot_t * hpRoot, agBOOLEAN On_or_Off);

void CFuncCompleteAllActiveCDBThreads( agRoot_t * hpRoot,os_bit32 CompletionStatus, event_t event_to_send );

agBOOLEAN CFuncCheckForTimeouts(agRoot_t *hpRoot, fiList_t * pCheckDevList);

void CFuncCompleteActiveCDBThreadsOnDevice(DevThread_t   * pDevThread ,os_bit32 CompletionStatus, event_t event_to_send );

void CFuncCompleteAwaitingLoginCDBThreadsOnDevice(DevThread_t   * pDevThread ,os_bit32 CompletionStatus, event_t event_to_send );

agBOOLEAN CFuncCheckIfPortActive( agRoot_t     *hpRoot, FC_Port_ID_t  Port_ID);
agBOOLEAN CFuncCheckIfPortPrev_Active( agRoot_t     *hpRoot, FC_Port_ID_t  Port_ID);
void CFunc_LOGO_Completion(agRoot_t * hpRoot, os_bit32 X_ID);
agBOOLEAN CFuncQuietShowWhereDevThreadsAre( agRoot_t * hpRoot);
void CFunc_Check_SEST(agRoot_t * hpRoot);
void CFunc_Check_ERQ_Registers( agRoot_t *hpRoot );
os_bit32 CFunc_Get_ERQ_Entry( agRoot_t *hpRoot, os_bit32 Search_X_ID );

void CFuncWhatStateAreCDBThreads(agRoot_t   *    hpRoot );

os_bit32 CFuncShowActiveCDBThreads( agRoot_t * hpRoot, os_bit32 Mode);
os_bit32 CFuncShowActiveCDBThreadsOnQ( agRoot_t * hpRoot, fiList_t * pShowList, os_bit32 ERQ, os_bit32 Mode );

void CFuncWriteTL_ControlReg( agRoot_t *hpRoot, os_bit32 Value_To_Write );
os_bit32 CFuncCountFC4_Devices( agRoot_t * hpRoot );

agBOOLEAN CFuncNewInitFM(agRoot_t   *    hpRoot );

void CFuncWriteTimeoutValues( agRoot_t *hpRoot, agTimeOutValue_t * TOV );

void CFuncFC_Tape( agRoot_t * hpRoot, fiList_t * pShowList , DevThread_t * DevThread );
agBOOLEAN CFuncCheckActiveDuringLinkEvent( agRoot_t * hpRoot, fiList_t * pShowList, agBOOLEAN * Sent_Abort , DevThread_t * DevThread);

void CFuncFreezeFCP( agRoot_t *hpRoot );
void CFuncWaitForFCP( agRoot_t *hpRoot );

void internSingleThreadedEnter(agRoot_t   *    hproot,os_bit32  Caller );
void internSingleThreadedLeave(agRoot_t   *    hpRoot,os_bit32  Caller );

void internAsyncSingleThreadedEnter(agRoot_t   *    hproot,os_bit32  Caller );
void internAsyncSingleThreadedLeave(agRoot_t   *    hpRoot,os_bit32  Caller );

void CFuncShowDevThreadActive( agRoot_t     *hpRoot);

agBOOLEAN CFuncCheckForDuplicateDevThread( agRoot_t     *hpRoot);

agBOOLEAN CFuncShowWhereSFThreadsAre( agRoot_t * hpRoot);
void CFuncWhatStateAreSFThreads(agRoot_t   *    hpRoot );
agBOOLEAN CFuncDoLinkSpeedNegotiation(agRoot_t * hpRoot);

void CFuncDoADISC(agRoot_t * hpRoot);
void CFuncShowNonEmptyLists(agRoot_t *hpRoot, fiList_t * pCheckDevList);

os_bit32 CFuncCheckFabricMap(agRoot_t * hpRoot, agBOOLEAN Check_Active );
os_bit32 CFuncLoopMapRecieved(agRoot_t * hpRoot, agBOOLEAN Check_Active );
os_bit32 CFunc_MAX_XL2_Payload( agRoot_t *hpRoot );

void CFuncTEST_GPIO(agRoot_t * hpRoot);
void CFuncReadBiosParms(agRoot_t * hpRoot);

#endif /*  __CFunc_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\cfunc.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/CFUNC.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 10/29/00 1:06p  $

Purpose:

  This file implements functions called by the FC Layer Card State Machine.

--*/

#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/fcstruct.h"
#include "../h/state.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/linksvc.h"
#include "../h/cmntrans.h"
#include "../h/flashsvc.h"
#include "../h/timersvc.h"

#include "../h/cstate.h"
#include "../h/cfunc.h"
#include "../h/devstate.h"
#include "../h/cdbstate.h"
#include "../h/sfstate.h"

#include "../h/queue.h"
#include "../h/cdbsetup.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "fcstruct.h"
#include "state.h"

#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"
#include "linksvc.h"
#include "cmntrans.h"
#include "flashsvc.h"
#include "timersvc.h"

#include "cstate.h"
#include "cfunc.h"
#include "devstate.h"
#include "cdbstate.h"
#include "sfstate.h"

#include "queue.h"
#include "cdbsetup.h"
#endif  /* _New_Header_file_Layout_ */


#ifndef __State_Force_Static_State_Tables__
extern actionUpdate_t noActionUpdate;
#endif /* __State_Force_Static_State_Tables__ was not defined */

extern os_bit8 Alpa_Index[256];

extern void Fc_ERROR(agRoot_t *hpRoot){
static int tmp=0;
    tmp++;
    fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "%s (%p) Error count %d FM Status %08X TL Status %08X",
                    "Fc_ERROR",(char *)agNULL,
                    hpRoot,agNULL,
                    tmp,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0);

        }

#ifdef _DvrArch_1_30_
DevThread_t * CFuncMatchPortWWNtoThread(agRoot_t * hpRoot, os_bit8 *PortWWN)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread  = (DevThread_t *)agNULL;
    fiList_t      * pList;
    FC_Port_ID_t    Port_ID;

    os_bit32 i;

    for (i = 0; i < sizeof(FC_N_Port_Name_t); i++)
    {
        if (PortWWN[i] != 0xff)
             break;
    }
    if (i == 8)
    {
        fiLogDebugString(hpRoot,
                    PktStateLogConsoleLevel,
                    "WWN matched broadcast device D_ID",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

        pDevThread = pCThread->IP->BroadcastDevice;
        if (pDevThread == (DevThread_t *)agNULL)
    {
        if (pCThread->ChanInfo.CurrentAddress.Domain || pCThread->ChanInfo.CurrentAddress.Area)
        {
                Port_ID.Struct_Form.Domain = 0xff;
                Port_ID.Struct_Form.Area   = 0xff;
        }
        else
        {
                Port_ID.Struct_Form.Domain = 0;
                Port_ID.Struct_Form.Area   = 0;
        }

            Port_ID.Struct_Form.AL_PA  = 0xff;

            pCThread->IP->BroadcastDevice = pDevThread = DevThreadAlloc( hpRoot, Port_ID );

            for (i = 0; i < sizeof(FC_N_Port_Name_t); i++)
            {
                pDevThread->DevInfo.NodeWWN[i] = 0xff;
                pDevThread->DevInfo.PortWWN[i] = 0xff;
            }
    }
        pDevThread->NewIPExchange = agTRUE;

        return(pDevThread);
    }

    pList = &pCThread->Prev_Unknown_Slot_DevLink;
    pList = pList->flink;
    while((&pCThread->Prev_Unknown_Slot_DevLink) != pList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                                    DevLink,pList );
        if( pDevThread )
        {
            for (i = 0; i < sizeof(FC_N_Port_Name_t); i++)
            {
                if(pDevThread->DevInfo.PortWWN[i] != PortWWN[i])
                     break;
            }
        if (i == 8)
            break;
        }
        else
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "pDevThread agNULL",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

        }
        pList = pList->flink;
        pDevThread = (DevThread_t *)agNULL;
    }

    if( pDevThread )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Prev_Unknown_Slot_DevLink pDevThread Match %p - AL_PA = %X",
                    (char *)agNULL,(char *)agNULL,
                    pDevThread,agNULL,
                    pDevThread->DevInfo.CurrentAddress.AL_PA,
                    0,0,0,0,0,0,0);
         return(pDevThread);
    }

    pList = &pCThread->Slot_Searching_DevLink;
    pList = pList->flink;
    while((&pCThread->Slot_Searching_DevLink) != pList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                                      DevLink,pList );
        for (i = 0; i < sizeof(FC_N_Port_Name_t); i++)
        {
           if(pDevThread->DevInfo.PortWWN[i] != PortWWN[i])
               break;
        }
        if (i == 8)
            break;

        pList = pList->flink;
        pDevThread = (DevThread_t *)agNULL;
    }

    if( pDevThread )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Slot_Searching_DevLink pDevThread Match %p - AL_PA = %X",
                    (char *)agNULL,(char *)agNULL,
                    pDevThread,agNULL,
                    pDevThread->DevInfo.CurrentAddress.AL_PA,
                    0,0,0,0,0,0,0);
         return(pDevThread);
    }

    pList = &pCThread->Active_DevLink;
    pList = pList->flink;
    while((&pCThread->Active_DevLink) != pList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                                        DevLink,pList );

        for (i = 0; i < sizeof(FC_N_Port_Name_t); i++)
        {
           if(pDevThread->DevInfo.PortWWN[i] != PortWWN[i])
               break;
        }
        if (i == 8)
            break;

        pList = pList->flink;
        pDevThread = (DevThread_t *)agNULL;
    }

    if( pDevThread )
    {
        fiLogDebugString(hpRoot,
                    /* CStateLogConsoleLevel, */ FCMainLogErrorLevel,
                    "Active_DevLink pDevThread Match %p - AL_PA = %X",
                    (char *)agNULL,(char *)agNULL,
                    pDevThread,agNULL,
                    pDevThread->DevInfo.CurrentAddress.AL_PA,
                    0,0,0,0,0,0,0);
        return(pDevThread);
    }

    fiLogDebugString(hpRoot,
               CStateLogConsoleLevel,
               "NO Match 0n thread ALL Queues searched agNULL returned !",
               (char *)agNULL,(char *)agNULL,
               (void *)agNULL,(void *)agNULL,
               0,0,0,0,0,0,0,0);

    return(pDevThread);
}
#endif /* _DvrArch_1_30_ was defined */


DevThread_t * CFuncMatchALPAtoThread( agRoot_t * hpRoot, FC_Port_ID_t  Port_ID)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread  = (DevThread_t *)agNULL;
    fiList_t      * pList;
    os_bit8         Domain = Port_ID.Struct_Form.Domain;
    os_bit8         Area   = Port_ID.Struct_Form.Area;
    os_bit8         AL_PA  = Port_ID.Struct_Form.AL_PA;

   agBOOLEAN        UseDomainArea = (Domain || Area) ? agTRUE : agFALSE;

    pList = &pCThread->Prev_Unknown_Slot_DevLink;
    pList = pList->flink;
    while((&pCThread->Prev_Unknown_Slot_DevLink) != pList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                                    DevLink,pList );
        if( pDevThread )
        {
            if (UseDomainArea)
            {
                if((pDevThread->DevInfo.CurrentAddress.Domain) &&
                  (pDevThread->DevInfo.CurrentAddress.Area == Area) &&
                  (pDevThread->DevInfo.CurrentAddress.AL_PA == AL_PA))
                     break;
            }
            else
            {
                if (pDevThread->DevInfo.CurrentAddress.AL_PA == AL_PA)
                break;
            }
        }
        else
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "pDevThread agNULL",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

        }
        pList = pList->flink;
        pDevThread = (DevThread_t *)agNULL;
    }

    if( pDevThread )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Prev_Unknown_Slot_DevLink pDevThread Match %p - AL_PA = %X",
                    (char *)agNULL,(char *)agNULL,
                    pDevThread,agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0,0);
         return(pDevThread);
    }

    pList = &pCThread->Slot_Searching_DevLink;
    pList = pList->flink;
    while((&pCThread->Slot_Searching_DevLink) != pList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                                      DevLink,pList );
        if (UseDomainArea)
        {
            if((pDevThread->DevInfo.CurrentAddress.Domain) &&
              (pDevThread->DevInfo.CurrentAddress.Area == Area) &&
              (pDevThread->DevInfo.CurrentAddress.AL_PA == AL_PA))
                 break;
        }
        else
        {
            if (pDevThread->DevInfo.CurrentAddress.AL_PA == AL_PA)
            break;
        }

        pList = pList->flink;
        pDevThread = (DevThread_t *)agNULL;
    }

    if( pDevThread )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Slot_Searching_DevLink pDevThread Match %p - AL_PA = %X",
                    (char *)agNULL,(char *)agNULL,
                    pDevThread,agNULL,
                    pDevThread->DevInfo.CurrentAddress.AL_PA,
                    0,0,0,0,0,0,0);
         return(pDevThread);
    }

    pList = &pCThread->Active_DevLink;
    pList = pList->flink;
    while((&pCThread->Active_DevLink) != pList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                                        DevLink,pList );

        if (UseDomainArea)
        {
            if((pDevThread->DevInfo.CurrentAddress.Domain) &&
              (pDevThread->DevInfo.CurrentAddress.Area == Area) &&
              (pDevThread->DevInfo.CurrentAddress.AL_PA == AL_PA))
                 break;
        }
        else
        {
            if (pDevThread->DevInfo.CurrentAddress.AL_PA == AL_PA)
            break;
        }
        pList = pList->flink;
        pDevThread = (DevThread_t *)agNULL;
    }

    if( pDevThread )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Active_DevLink pDevThread Match %p - AL_PA = %X",
                    (char *)agNULL,(char *)agNULL,
                    pDevThread,agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0,0);
        return(pDevThread);
    }


    pList = &pCThread->Prev_Active_DevLink;
    pList = pList->flink;
    while((&pCThread->Prev_Active_DevLink) != pList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                                        DevLink,pList );

        if (UseDomainArea)
        {
            if((pDevThread->DevInfo.CurrentAddress.Domain) &&
              (pDevThread->DevInfo.CurrentAddress.Area == Area) &&
              (pDevThread->DevInfo.CurrentAddress.AL_PA == AL_PA))
                 break;
        }
        else
        {
            if (pDevThread->DevInfo.CurrentAddress.AL_PA == AL_PA)
            break;
        }
        pList = pList->flink;
        pDevThread = (DevThread_t *)agNULL;
    }

    if( pDevThread )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "Prev_Active_DevLink pDevThread Match %p - AL_PA = %X",
                    (char *)agNULL,(char *)agNULL,
                    pDevThread,agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0,0);
        return(pDevThread);
    }

    fiLogDebugString(hpRoot,
               CStateLogConsoleLevel,
               "NO Match 0n thread ALL Queues searched agNULL returned !",
               (char *)agNULL,(char *)agNULL,
               (void *)agNULL,(void *)agNULL,
               0,0,0,0,0,0,0,0);


    return(pDevThread);
}


void CFuncGetHaInfoFromNVR(agRoot_t *hpRoot)
{
    os_bit8                 Hard_Domain_Address;
    os_bit8                 Hard_Area_Address;
    os_bit8                 Hard_Loop_Address;
    fiFlash_Card_WWN_t   Card_WWN;
    agFCChanInfo_t     * Self_info = &(CThread_ptr(hpRoot)->ChanInfo);

    fiFlashGet_Hard_Address(hpRoot,
                            &Hard_Domain_Address,
                            &Hard_Area_Address,
                            &Hard_Loop_Address);

    Self_info->CurrentAddress.Domain = (os_bit8)(Hard_Domain_Address == fiFlash_Card_Unassigned_Domain_Address
                                        ? 0x00
                                        : Hard_Domain_Address);
    Self_info->CurrentAddress.Area   = (os_bit8)(Hard_Area_Address == fiFlash_Card_Unassigned_Area_Address
                                        ? 0x00
                                        : Hard_Area_Address);

    if( CThread_ptr(hpRoot)->InitAsNport)
    {
        Self_info->CurrentAddress.AL_PA  = 0;
    }
    else
    {
        Self_info->CurrentAddress.AL_PA  = Hard_Loop_Address;
    }

    Self_info->HardAddress.Domain    = (os_bit8)(Hard_Domain_Address == fiFlash_Card_Unassigned_Domain_Address
                                        ? 0x00
                                        : Hard_Domain_Address);
    Self_info->HardAddress.Area      = (os_bit8)(Hard_Area_Address == fiFlash_Card_Unassigned_Area_Address
                                        ? 0x00
                                        : Hard_Area_Address);
    Self_info->HardAddress.AL_PA     = (os_bit8)(Hard_Loop_Address == fiFlash_Card_Unassigned_Loop_Address
                                        ? 0xBA
                                        : Hard_Loop_Address);

    fiFlashGet_Card_WWN(hpRoot,
                        &Card_WWN);

    }

ERQConsIndex_t CFuncGetDmaMemERQConsIndex(
                                             agRoot_t *hpRoot
                                             )
{
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    /* Big_Endian_Code */
    return osSwapBit32TachLiteToSystemEndian(
        * ((ERQConsIndex_t * )pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.DmaMemory.dmaMemoryPtr)
                                            );
    }


ERQConsIndex_t CFuncGetCardRamERQConsIndex(
                                             agRoot_t *hpRoot
                                             )
{

    CThread_t  * pCThread = CThread_ptr(hpRoot);

    return( osCardRamReadBit32(hpRoot,
        pCThread->Calculation.MemoryLayout.ERQConsIndex.addr.CardRam.cardRamOffset  )
        );
    }


IMQProdIndex_t CFuncGetDmaMemIMQProdIndex(
                                             agRoot_t *hpRoot
                                           ){
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    /* Big_Endian_Code */
    return osSwapBit32TachLiteToSystemEndian(
        * ((IMQProdIndex_t * )pCThread->Calculation.MemoryLayout.IMQProdIndex.addr.DmaMemory.dmaMemoryPtr)
                                            );
}


IMQProdIndex_t CFuncGetCardRamIMQProdIndex(
                                             agRoot_t *hpRoot
                                             ){
    CThread_t  * pCThread;
    pCThread = CThread_ptr(hpRoot);

    return( osCardRamReadBit32(hpRoot,
    pCThread->Calculation.MemoryLayout.IMQProdIndex.addr.CardRam.cardRamOffset ));
}



void CFuncSoftResetAdapter(agRoot_t * hpRoot)
{
    os_bit32 Reset_Reg,x;
    CThread_t *CThread                 = CThread_ptr(hpRoot);
    if(CThread) CThread->InterruptsDelayed = agFALSE;

    Reset_Reg = osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST );
    Reset_Reg &= ~ChipIOUp_SOFTRST_MASK;
    Reset_Reg |=  ChipIOUp_SOFTRST_RST;

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST, Reset_Reg );

    osStallThread(hpRoot,100);
    for(x=0; x < 8; x++)
    {
         Reset_Reg = osChipIOUpReadBit32(hpRoot,
             ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST );
    }

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST, 0);

    for(x=0; x < 2000; x++)
    {
        osStallThread(hpRoot,200);
    }

/*
     osStallThread(hpRoot,200 * 2000);

     fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "CFuncSoftResetAdapter LARGE TIME DELAY !!!",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
*/
}

void CFuncSoftResetAdapterNoStall(agRoot_t * hpRoot)
{
    os_bit32 Reset_Reg,x;
    CThread_t *CThread                 = CThread_ptr(hpRoot);

    if(CThread) CThread->InterruptsDelayed = agFALSE;

    Reset_Reg = osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST );
    Reset_Reg &= ~ChipIOUp_SOFTRST_MASK;
    Reset_Reg |=  ChipIOUp_SOFTRST_RST;


    osChipIOUpWriteBit32( hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST, Reset_Reg );

    osStallThread(hpRoot,100);
    for(x=0; x < 8; x++)
    {
         Reset_Reg = osChipIOUpReadBit32(hpRoot,
             ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST );
    }

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST, 0);

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "%s",
                    "CFuncSoftResetAdapterNoStall",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

}


void CFuncDisable_Interrupts(agRoot_t * hpRoot, os_bit32 Mask)
{
    CThread_t *CThread                 = CThread_ptr(hpRoot);
    os_bit32      sysIntsLogicallyEnabled = CThread->sysIntsLogicallyEnabled & ~Mask;
    os_bit32      INTEN_Reg;

    if (CThread->sysIntsActive == agTRUE)
    {
        INTEN_Reg = ((  osChipIOUpReadBit32(hpRoot,ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST)
                      & ~ChipIOUp_INTEN_MASK                                              )
                     | sysIntsLogicallyEnabled                                             );
    }
    else /* CThread->sysIntsActive == agFALSE */
    {
        INTEN_Reg = (  osChipIOUpReadBit32(hpRoot,ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST)
                     & ~ChipIOUp_INTEN_MASK                                              );
    }

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST, INTEN_Reg );

    CThread->sysIntsLogicallyEnabled = sysIntsLogicallyEnabled;
/* Called during interrupt
    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "In - %s Interrupts %08X sysInts - Active %x LogicallyEnabled %x",
                    "CFuncDisable_Interrupts",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                    CThread_ptr(hpRoot)->sysIntsActive,
                    CThread_ptr(hpRoot)->sysIntsLogicallyEnabled,
                    0,0,0,0,0);
*/
    }

os_bit32 CFuncRead_Interrupts(agRoot_t * hpRoot)
{

    return (osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ));
    }


agBOOLEAN CFuncIMQ_Interrupt_Pending(agRoot_t * hpRoot)
{

    return (
    osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST )
        &       ChipIOUp_INTSTAT_INT      ? agTRUE : agFALSE);
}



void CFuncEnable_Interrupts(agRoot_t * hpRoot, os_bit32 Mask)
{
    CThread_t *CThread                 = CThread_ptr(hpRoot);
    os_bit32      sysIntsLogicallyEnabled = CThread->sysIntsLogicallyEnabled | Mask;
    os_bit32      INTEN_Reg;

    if (CThread->sysIntsActive ) /* CThread->sysIntsActive == agTRUE */
    {
        INTEN_Reg = ((  osChipIOUpReadBit32(hpRoot,ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST)
                      & ~ChipIOUp_INTEN_MASK                                              )
                     | sysIntsLogicallyEnabled                                             );
    }
    else /* CThread->sysIntsActive == agFALSE */
    {
        INTEN_Reg = (  osChipIOUpReadBit32(hpRoot,ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST)
                     & ~ChipIOUp_INTEN_MASK                                              );
    }

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST, INTEN_Reg );

    CThread->sysIntsLogicallyEnabled = sysIntsLogicallyEnabled;
/*  Called during interrupt
    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "In - %s Interrupts %08X sysInts - Active %x LogicallyEnabled %x",
                    "CFuncEnable_Interrupts",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                    CThread_ptr(hpRoot)->sysIntsActive,
                    CThread_ptr(hpRoot)->sysIntsLogicallyEnabled,
                    0,0,0,0,0);
*/
    }

agBOOLEAN CFuncEnable_Queues(agRoot_t * hpRoot )
{
#ifdef OSLayer_Stub
    return agFALSE;
#else /* OSLayer_Stub was not defined */
    os_bit32 Status = 0;
    Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status );
    /* Micron 64 bit slot..... */
    if(Status == ChipIOUp_TachLite_Status )
    {
        Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status );
        if(Status == ChipIOUp_TachLite_Status )
        {
            fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "CFuncEnable_Queues Chip BAD !!!! TL Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Status,
                    0,0,0,0,0,0,0);
            return(agFALSE);
        }

      }


    if(CFunc_Queues_Frozen(hpRoot ))
    {


        if(Status & ChipIOUp_TachLite_Status_OFF )
        {
            CFuncWriteTL_ControlReg( hpRoot,
                                   (ChipIOUp_TachLite_Control_ROF |
                                    ((osChipIOUpReadBit32(hpRoot,
                                        ChipIOUp_TachLite_Control) &
                                        ChipIOUp_TachLite_Control_GPIO_0_3_MASK) &
                                        ~ ChipIOUp_TachLite_Control_GP4)));
        }

        if(Status & ChipIOUp_TachLite_Status_IFF )
        {
            CFuncWriteTL_ControlReg( hpRoot,
                                    (ChipIOUp_TachLite_Control_RIF  |
                                    ((osChipIOUpReadBit32(hpRoot,
                                        ChipIOUp_TachLite_Control) &
                                        ChipIOUp_TachLite_Control_GPIO_0_3_MASK) &
                                        ~ ChipIOUp_TachLite_Control_GP4)));
        }

        if(Status & ChipIOUp_TachLite_Status_EQF )
        {
            CFuncWriteTL_ControlReg( hpRoot,
                                   ( ChipIOUp_TachLite_Control_REQ  |
                                    ((osChipIOUpReadBit32(hpRoot,
                                        ChipIOUp_TachLite_Control) &
                                        ChipIOUp_TachLite_Control_GPIO_0_3_MASK) &
                                        ~ ChipIOUp_TachLite_Control_GP4)));
        }


        if(CFunc_Queues_Frozen(hpRoot ))
        {
/*
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "CFuncEnable_Queues Frozen ! Return Status %08X TL Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Status,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0,0);
*/
            return agTRUE;
        }
        else
        {
            fiLogDebugString(hpRoot,
                    CSTATE_NOISE(hpRoot,CStateFindDevice),
                    "CFuncEnable_Queues Cleared Return Status %08X TL Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Status,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0,0);
         return agFALSE;
        }
    }
    return agFALSE;
#endif  /* OSLayer_Stub */

}

agBOOLEAN CFunc_Always_Enable_Queues(agRoot_t * hpRoot )
{
#ifdef OSLayer_Stub
    return agFALSE;
#else /* OSLayer_Stub was not defined */
    os_bit32 Status = 0;

    Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status );

    if(CFunc_Queues_Frozen(hpRoot ))
    {
        CFuncWriteTL_ControlReg( hpRoot,
                                    (ChipIOUp_TachLite_Control_ROF |
                                    Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK &
                                            ~ ChipIOUp_TachLite_Control_GP4));

        CFuncWriteTL_ControlReg( hpRoot,
                                    (ChipIOUp_TachLite_Control_RIF  |
                                    Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK &
                                            ~ ChipIOUp_TachLite_Control_GP4));

        CFuncWriteTL_ControlReg( hpRoot,
                                    (ChipIOUp_TachLite_Control_REQ  |
                                    Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK &
                                            ~ ChipIOUp_TachLite_Control_GP4));

    }
    CThread_ptr(hpRoot)->ERQ_FROZEN = agFALSE;
    CThread_ptr(hpRoot)->FCP_FROZEN = agFALSE;
    CThread_ptr(hpRoot)->IDLE_RECEIVED = agFALSE;

    if(CFunc_Queues_Frozen(hpRoot ))
    {
/*
         fiLogDebugString(hpRoot,
                    CSTATE_NOISE(hpRoot,CStateFindDevice),
                    "CFunc_Always_Enable_Queues Frozen ! Return Status %08X TL Status %08X FM %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Status,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    0,0,0,0,0);
*/
            return agTRUE;
    }
    else
    {

/*
        fiLogDebugString(hpRoot,
                    CStateLogConsoleLevelLip,
                    "CFunc_Always_Enable_Queues Cleared Return Status %08X TL Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Status,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0,0);
*/
         return agFALSE;
    }

#endif  /* OSLayer_Stub */

}

agBOOLEAN CFunc_Queues_Frozen(agRoot_t * hpRoot )
{
#ifndef OSLayer_Stub
    os_bit32 Status = 0;
    Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status );

    if(Status & (   ChipIOUp_TachLite_Status_OFF |
                    ChipIOUp_TachLite_Status_IFF |
                    ChipIOUp_TachLite_Status_EQF ))

    {
        return(agTRUE);
    }
#endif /* OSLayer_Stub was not defined */
    return(agFALSE);
}

void CFuncGreenLed(agRoot_t * hpRoot, agBOOLEAN On_or_Off)
{   /* Green Led - Is one by default at power up */
    os_bit32 Reg_Mask;
    Reg_Mask = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control );

    if( CThread_ptr(hpRoot)->JANUS)
    {
        if( On_or_Off) Reg_Mask &= ~ ChipIOUp_TachLite_Control_GP3;
        else Reg_Mask |= ChipIOUp_TachLite_Control_GP3; /* Link LED */
    }
    else
    {
        if( On_or_Off) Reg_Mask &= ~ ChipIOUp_TachLite_Control_GP2;
        else Reg_Mask |= ChipIOUp_TachLite_Control_GP2; /* Green LED */
    }
    /* GP04 Always Low for Leds */
    CFuncWriteTL_ControlReg( hpRoot, Reg_Mask & ~ ChipIOUp_TachLite_Control_GP4);

}


void CFuncYellowLed(agRoot_t * hpRoot, agBOOLEAN On_or_Off)
{
    os_bit32 Reg_Mask;
    Reg_Mask = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control );

    if( CThread_ptr(hpRoot)->JANUS)
    {
        if( On_or_Off) Reg_Mask |= ChipIOUp_TachLite_Control_GP2;
        else Reg_Mask &= ~ ChipIOUp_TachLite_Control_GP2; /* Active LED */
    }
    else
    {
        if( On_or_Off)
        {
            CThread_ptr(hpRoot)->Yellow_LED_State = agTRUE;
            Reg_Mask |= ChipIOUp_TachLite_Control_GP3;
        }
        else
        {
            CThread_ptr(hpRoot)->Yellow_LED_State = agFALSE;
            Reg_Mask &= ~ ChipIOUp_TachLite_Control_GP3; /* Yellow LED */
        }
    }
    /* GP04 Always Low for Leds */
    CFuncWriteTL_ControlReg( hpRoot, Reg_Mask & ~ ChipIOUp_TachLite_Control_GP4);

}

void CFuncWriteTL_ControlReg( agRoot_t *hpRoot, os_bit32 Value_To_Write )
{
    CThread_t * pCThread= CThread_ptr(hpRoot);
    /* Set GP4 High Always */
    if(pCThread->LaserEnable)
    {
        Value_To_Write |= ChipIOUp_TachLite_Control_GP4;
    }
    else
    {
        Value_To_Write &= ~ChipIOUp_TachLite_Control_GP4;

    }
    if( Value_To_Write & ChipIOUp_TachLite_Control_GP3 )
    {
        if( !CThread_ptr(hpRoot)->Yellow_LED_State)
        {
            Value_To_Write &= ~ ChipIOUp_TachLite_Control_GP3; /* Yellow LED */
        }
    }
    osChipIOUpWriteBit32(hpRoot, ChipIOUp_TachLite_Control, Value_To_Write);
}



/**/

void CFuncInteruptDelay(agRoot_t * hpRoot, agBOOLEAN On_or_Off)
{
    os_bit32    Reg_Mask = 0;
    os_bit32    GPIO_REG = 0;
    CThread_t * CThread = CThread_ptr(hpRoot);

#ifdef USE_XL_Delay_Register
    os_bit32    Delay_val = ChipIOUp_Interrupt_Delay_Timer_1ms;

    Delay_val = ChipIOUp_Interrupt_Delay_Timer_250;
    if (CThread->DEVID == ChipConfig_DEVID_TachyonXL2)
    {
/*         fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "CFuncInteruptDelay %s (%x) %s Addr %p %x",
                    "ChipConfig_DEVID_TachyonXL2",On_or_Off ? "On " : "Off",
                    &Delay_val,(void *)agNULL,
                    ChipIOLo_Interrupt_Delay_Timer,
                    Delay_val,0,0,0,0,0,0);
*/
        if( On_or_Off)
        {
            CThread_ptr(hpRoot)->XL2DelayActive = agTRUE;
            osChipIOLoWriteBit32( hpRoot, ChipIOLo_Interrupt_Delay_Timer, Delay_val  );
        }
        else
        {
            CThread_ptr(hpRoot)->XL2DelayActive = agFALSE;
            osChipIOLoWriteBit32( hpRoot, ChipIOLo_Interrupt_Delay_Timer, ChipIOUp_Interrupt_Delay_Timer_Immediate );
            CThread->FuncPtrs.Proccess_IMQ(hpRoot);
        }
        return;
    }
#endif /* USE_XL_Delay_Register */
    if( CThread_ptr(hpRoot)->JANUS)
    {   /* 1 millisecond delay */
        Reg_Mask = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control );
        if( On_or_Off)
        {
            CFuncWriteTL_ControlReg( hpRoot,
                        ChipIOUp_TachLite_Control_GP3 |
                        ChipIOUp_TachLite_Control_GP4);

            CFuncWriteTL_ControlReg( hpRoot,
                        ChipIOUp_TachLite_Control_GP3 |
                        ChipIOUp_TachLite_Control_GP4);

            CFuncWriteTL_ControlReg( hpRoot,
                        ChipIOUp_TachLite_Control_GP3 );
        }
        else
        {
            /*Delay off */
            CFuncWriteTL_ControlReg( hpRoot,
                                ChipIOUp_TachLite_Control_GP4   );

            CFuncWriteTL_ControlReg( hpRoot,
                                ChipIOUp_TachLite_Control_GP4   );

            CFuncWriteTL_ControlReg( hpRoot,
                                0   );
        }
        /* Restore Leds */
        CFuncWriteTL_ControlReg( hpRoot, Reg_Mask & ~ ChipIOUp_TachLite_Control_GP4);

    }
    else
    {
        if( On_or_Off)
        {/* 1 millisecond delay */

            GPIO_REG = osChipIOUpReadBit32( hpRoot, ChipIOUp_TachLite_Control);

            GPIO_REG = (GPIO_REG & ~MemMap_GPIO_BITS_MASK) | CThread->Calculation.Parameters.IntDelayAmount;
/*
            GPIO_REG = (GPIO_REG & ~MemMap_GPIO_BITS_MASK) | (ChipIOUp_TachLite_Control_GP0    );
*/
            CFuncWriteTL_ControlReg( hpRoot, GPIO_REG );
        }
        else
        {
            GPIO_REG = osChipIOUpReadBit32( hpRoot, ChipIOUp_TachLite_Control );

            GPIO_REG = (GPIO_REG & ~MemMap_GPIO_BITS_MASK) | MemMap_GPIO_BITS_PAL_Delay_0_00_ms;

            CFuncWriteTL_ControlReg( hpRoot, GPIO_REG );
        }
    }

/*
     fiLogString(hpRoot,
                    "%s %s %08X",
                    "CFuncInteruptDelay",On_or_Off ? "On " : "Off",
                    (void *)agNULL,(void *)agNULL,
                    GPIO_REG,
                    0,0,0,0,0,0,0);
*/

}

void CFuncReInitializeSEST(agRoot_t * hpRoot){
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    os_bit32 num_sest_entry = pCThread->Calculation.MemoryLayout.SEST.elements - 1;
    os_bit32 x;
    os_bit32 sest_offset;
    USE_t                     *SEST;


    if(pCThread->Calculation.MemoryLayout.SEST.memLoc ==  inDmaMemory)
    {

        fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "SEST.memLoc OffCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

        SEST = (USE_t *)pCThread->Calculation.MemoryLayout.SEST.addr.DmaMemory.dmaMemoryPtr;
        for(x= 0; x < num_sest_entry; x++, SEST++)
        {
            SEST->Bits =0;
        }

    }
    else
    {   /* inCardRam */
            fiLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "SEST.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

             sest_offset  = pCThread->Calculation.MemoryLayout.SEST.addr.CardRam.cardRamOffset;

        for(x= 0; x < num_sest_entry; x++ )
        {

            osCardRamWriteBit32(
                                 hpRoot,
                                 sest_offset + (sizeof(USE_t) * x),
                                 0);

        }

    }

}

os_bit32 fiResetDevice(
                     agRoot_t  *hpRoot,
                     agFCDev_t  hpFCDev,
                     os_bit32   hpResetType,
                     agBOOLEAN  retry,
                     agBOOLEAN  resetotherhost
                   )
{
    CThread_t *pCThread= CThread_ptr(hpRoot);
    DevThread_t * pDevThread = (DevThread_t *)hpFCDev;

    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "In fiResetDevice %p Alpa %X CCnt %x DCnt %x",
                    (char *)agNULL,(char *)agNULL,
                    hpFCDev,agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCThread->CDBpollingCount,
                    pDevThread->pollingCount,
                    resetotherhost,0,0,0,0);

    if ( hpFCDev == agNULL )
    {
        return fcResetFailure;
    }

    pCThread->thread_hdr.subState = CSubStateResettingDevices;

    if ((hpResetType & fcHardSoftResetMask) == fcSoftReset)
    {
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);
    }
    else
    {
        Retry_Reset:
        if( pCThread->thread_hdr.currentState != CStateNormal )
        {
            return fcResetFailure;
        }

       fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Device current state %d DEVReset_pollingCount %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pDevThread->thread_hdr.currentState,
                    pCThread->DEVReset_pollingCount,
                    0,0,0,0,0,0);

        fiSendEvent(&pDevThread->thread_hdr, DevEventAllocDeviceResetHard);
        if(CFuncInterruptPoll( hpRoot,&pCThread->DEVReset_pollingCount ))
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Reset Dev Fail Poll (%x )Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->DEVReset_pollingCount,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0);
        }

       fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Device current state %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pDevThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

        if(  (pDevThread->thread_hdr.currentState == DevStateHandleAvailable ) &&
             (pDevThread->Failed_Reset_Count))
        {
            pDevThread->Failed_Reset_Count              = 0;
            goto Retry_Reset;
        }


        if(  pDevThread->thread_hdr.currentState != DevStateHandleAvailable )
        {
            if(retry)
            {
                Login_Retry:
                fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);
                if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
                {
                    fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "Reset Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                                    0,0,0,0);
                }

                pDevThread->Failed_Reset_Count += 1;

                if(pDevThread->thread_hdr.currentState == DevStateHandleAvailable )
                {
                    if( pDevThread->Failed_Reset_Count < FC_MAX_RESET_RETRYS )
                    {
                        goto Retry_Reset;
                    }
                }
                else
                {
                    if( pDevThread->Failed_Reset_Count < FC_MAX_RESET_RETRYS )
                    {
                        goto Login_Retry;
                    }
                }
            }
        }
    }

    pCThread->thread_hdr.subState = CSubStateInitialized;

    return fcResetSuccess;
}


os_bit32 fiResetAllDevices( agRoot_t *hpRoot,  os_bit32     hpResetType )
{
    CThread_t *pCThread = CThread_ptr(hpRoot);

    DevThread_t   * pDevThread;
    fiList_t      * pList;

    agFCDev_t  hpFCDev[127];
    os_bit32 numDevs,x,ResetStatus;

    pList = &pCThread->Active_DevLink;
    pList = pList->flink;
    numDevs=0;

    CFuncCompleteAllActiveCDBThreads( hpRoot, osIODevReset,CDBEventIODeviceReset );

    while((&pCThread->Active_DevLink) != pList)
    {
        hpFCDev[numDevs] = hpObjectBase(DevThread_t, DevLink,pList );
        numDevs ++;
        pList = pList->flink;
        pDevThread = (DevThread_t *)agNULL;  /*What ?*/
    }
    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "num Devs %d TO reset",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    numDevs,
                    0,0,0,0,0,0,0);

    if(numDevs)
    {
        for(x= 0; x < numDevs; x++)
        {
            if( pCThread->thread_hdr.currentState != CStateNormal )
            {
                return fcResetFailure;
            }

            if( ((DevThread_t *)hpFCDev[x])->DevInfo.DeviceType & agDevSCSITarget)
            {
                pDevThread = (DevThread_t *)hpFCDev[x];
                fiLogDebugString(hpRoot,
                                FCMainLogErrorLevel,
                                "agDevSCSITarget ID %X",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                fiComputeDevThread_D_ID(pDevThread),
                                0,0,0,0,0,0,0);

                ResetStatus = fiResetDevice( hpRoot, hpFCDev[x],hpResetType, agTRUE, agFALSE );
            }
        }
    }
    else
    {
/*
        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s Sending Shutdown !",
                        "fiResetAllDevices",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
        fiSendEvent(&(pCThread->thread_hdr),CEventShutdown);
        fiSendEvent(&(pCThread->thread_hdr),CEventDoInitalize);
*/

        /* Maybe send Device resets ????
        if( pCThread->thread_hdr.currentState == CStateNormal )
        */


    }

    return fcResetSuccess;

}


/* Returns true if Loop stays down */
agBOOLEAN CFuncLoopDownPoll( agRoot_t *hpRoot )
{
    CThread_t       *   CThread      = CThread_ptr(hpRoot);
    os_bit32               PollingCalls = 0;

    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "CFuncLoopDownPoll LD %x IR %x InIMQ %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread->LOOP_DOWN,
                        CThread->IDLE_RECEIVED,
                        CThread->ProcessingIMQ,
                        0,0,0,0,0);
    if (CThread->InitAsNport)
    {/* Does not make sense to wait for this when Nport */
        return(agTRUE);
    }



    while( CThread->LOOP_DOWN )
    {
        PollingCalls++;

        if( CThread->thread_hdr.currentState == CStateLIPEventStorm         ||
            CThread->thread_hdr.currentState == CStateElasticStoreEventStorm   ) return(agTRUE);

        if( (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) &
                                        ChipIOUp_Frame_Manager_Status_LSM_MASK) ==
                                        ChipIOUp_Frame_Manager_Status_LSM_Loop_Fail )
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "LSM Loop Fail FM Status %08X FM Config %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);

            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Loop Fail TL Status %08X TL Control %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0,0);
            return(agTRUE);
        }


        if(PollingCalls > 2 * ( SF_EDTOV / Interrupt_Polling_osStallThread_Parameter))
        {
               fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "CFuncLoopDownPoll  TIMEOUT FM %08X InIMQ %x TL status %08X Qf %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    CThread->ProcessingIMQ,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    CFunc_Queues_Frozen( hpRoot ),
                    0,0,0,0);


            return(agTRUE);
        }
        if( ! CThread->FuncPtrs.Proccess_IMQ( hpRoot ))
        {
            if(osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) &
                   (~ ( ChipIOUp_Frame_Manager_Status_LP      |
                        ChipIOUp_Frame_Manager_Status_LSM_MASK   )) )
            {
                if (CThread->HostCopy_IMQConsIndex == CThread->FuncPtrs.GetIMQProdIndex(hpRoot))
                {
                    CFuncFMCompletion(hpRoot);
                }
                else
                {
                    continue;
                }
            }
        }
        osStallThread(
                       hpRoot,
                       Interrupt_Polling_osStallThread_Parameter
                     );

        fiTimerTick(
                       hpRoot,
                       Interrupt_Polling_osStallThread_Parameter
                     );

    }
    return(agFALSE);
}

/* Returns true if Queues Don't Freeze */
agBOOLEAN CFuncFreezeQueuesPoll( agRoot_t *hpRoot )
{
    CThread_t       *   CThread      = CThread_ptr(hpRoot);
    os_bit32            PollingCalls = 0;

    os_bit32 Status = 0;

    Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status );
    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "CFuncFreezeQueuesPoll LD %x IR %x  IMQ %x Queues %x TL Status %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread->LOOP_DOWN,
                        CThread->IDLE_RECEIVED,
                        CThread->ProcessingIMQ,
                        CFunc_Queues_Frozen( hpRoot ),
                        Status,
                        0,0,0);


    if(CFunc_Queues_Frozen( hpRoot ))
    {

        fiLogString(hpRoot,
                        "%s FROZEN Already FM %08X TL %08X",
                        "CFFQPoll",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        0,0,0,0,0,0);
/*
        CFuncWriteTL_ControlReg( hpRoot,
                                    ChipIOUp_TachLite_Control_FFA |
                                    Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK &
                                            ~ ChipIOUp_TachLite_Control_GP4);

        CFuncWriteTL_ControlReg( hpRoot,
                                    ChipIOUp_TachLite_Control_FEQ |
                                    Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK &
                                            ~ ChipIOUp_TachLite_Control_GP4);

        return(agTRUE);
*/
    }

    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "TL Setting %s %08X",
                        "ChipIOUp_TachLite_Control_FEQ",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (ChipIOUp_TachLite_Control_FEQ |
                                (Status & ( ChipIOUp_TachLite_Control_GPIO_0_3_MASK &
                                        ~ ChipIOUp_TachLite_Control_GP4))),
                        0,0,0,0,0,0,0);

    CFuncWriteTL_ControlReg( hpRoot,
                               ( ChipIOUp_TachLite_Control_FEQ |
                               (( Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK )&
                                        ~ ChipIOUp_TachLite_Control_GP4)));

    while( ! CThread_ptr(hpRoot)->ERQ_FROZEN  )
    {
        if( CThread->thread_hdr.currentState == CStateLIPEventStorm         ||
            CThread->thread_hdr.currentState == CStateElasticStoreEventStorm   ) return(agTRUE);

        PollingCalls++;

        if(PollingCalls > 2 * ( SF_EDTOV / Interrupt_Polling_osStallThread_Parameter))
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "ERQ CFuncFreezeQueuesPoll  TIMEOUT FM %08X InIMQ %x TL status %08X Qf %d",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        CThread->ProcessingIMQ,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        CFunc_Queues_Frozen( hpRoot ),
                        0,0,0,0);

            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "LD %x IR %x OR %x ERQ %x FCP %x Queues %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread_ptr(hpRoot)->LOOP_DOWN,
                        CThread_ptr(hpRoot)->IDLE_RECEIVED,
                        CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                        CThread_ptr(hpRoot)->ERQ_FROZEN,
                        CThread_ptr(hpRoot)->FCP_FROZEN,
                        CFunc_Queues_Frozen( hpRoot ),
                        0,0);

            return(agTRUE);
        }
        if( ! CThread->FuncPtrs.Proccess_IMQ( hpRoot ))
        {
            if(osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) &
                   (~ ( ChipIOUp_Frame_Manager_Status_LP      |
                        ChipIOUp_Frame_Manager_Status_LSM_MASK   )) )
            {
                if (CThread->HostCopy_IMQConsIndex == CThread->FuncPtrs.GetIMQProdIndex(hpRoot))
                {
                    CFuncFMCompletion(hpRoot);
                }
                else
                {
                    continue;
                }
            }
        }

        CFuncWriteTL_ControlReg( hpRoot,
                                   (ChipIOUp_TachLite_Control_FFA |
                                   (( Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK) &
                                            ~ ChipIOUp_TachLite_Control_GP4)));

        CFuncWriteTL_ControlReg( hpRoot,
                                   ( ChipIOUp_TachLite_Control_FEQ |
                                   (( Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK) &
                                            ~ ChipIOUp_TachLite_Control_GP4)));

        osStallThread(
                       hpRoot,
                       Interrupt_Polling_osStallThread_Parameter
                     );

        fiTimerTick(
                       hpRoot,
                       Interrupt_Polling_osStallThread_Parameter
                     );
    }


    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "TL Setting %s %08X",
                        "ChipIOUp_TachLite_Control_FFA",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        ChipIOUp_TachLite_Control_FFA |
                                Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK &
                                        ~ ChipIOUp_TachLite_Control_GP4,
                        0,0,0,0,0,0,0);

    CFuncWriteTL_ControlReg( hpRoot,
                               ( ChipIOUp_TachLite_Control_FFA |
                               (( Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK) &
                                        ~ ChipIOUp_TachLite_Control_GP4)));

    while( ! CThread_ptr(hpRoot)->FCP_FROZEN )
   {
        if( CThread->thread_hdr.currentState == CStateLIPEventStorm         ||
            CThread->thread_hdr.currentState == CStateElasticStoreEventStorm   ) return(agTRUE);

        PollingCalls++;

        if(PollingCalls > 2 * ( SF_EDTOV / Interrupt_Polling_osStallThread_Parameter))
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "FCP CFuncFreezeQueuesPoll  TIMEOUT FM %08X InIMQ %x TL status %08X Qf %d",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        CThread->ProcessingIMQ,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        CFunc_Queues_Frozen( hpRoot ),
                        0,0,0,0);

            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "LD %x IR %x OR %x ERQ %x FCP %x Queues %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread_ptr(hpRoot)->LOOP_DOWN,
                        CThread_ptr(hpRoot)->IDLE_RECEIVED,
                        CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                        CThread_ptr(hpRoot)->ERQ_FROZEN,
                        CThread_ptr(hpRoot)->FCP_FROZEN,
                        CFunc_Queues_Frozen( hpRoot ),
                        0,0);

            return(agTRUE);
        }
        if( ! CThread->FuncPtrs.Proccess_IMQ( hpRoot ))
        {
            if(osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) &
                   (~ ( ChipIOUp_Frame_Manager_Status_LP      |
                        ChipIOUp_Frame_Manager_Status_LSM_MASK   )) )
            {
                if (CThread->HostCopy_IMQConsIndex == CThread->FuncPtrs.GetIMQProdIndex(hpRoot))
                {
                    CFuncFMCompletion(hpRoot);
                }
                else
                {
                    continue;
                }
            }
        }
        CFuncWriteTL_ControlReg( hpRoot,
                                   ( ChipIOUp_TachLite_Control_FFA |
                                    ((Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK) &
                                            ~ ChipIOUp_TachLite_Control_GP4)));

        CFuncWriteTL_ControlReg( hpRoot,
                                   ( ChipIOUp_TachLite_Control_FEQ |
                                   (( Status &  ChipIOUp_TachLite_Control_GPIO_0_3_MASK) &
                                            ~ ChipIOUp_TachLite_Control_GP4)));

        osStallThread(
                       hpRoot,
                       Interrupt_Polling_osStallThread_Parameter
                     );

        fiTimerTick(
                       hpRoot,
                       Interrupt_Polling_osStallThread_Parameter
                     );
    }

    return(agFALSE);
}


agBOOLEAN CFuncAll_clear( agRoot_t *hpRoot )
{
/* If chip is IO ready these are true */
    CThread_t       *   pCThread      = CThread_ptr(hpRoot);

    os_bit32 FM_Status;

    FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
#ifdef NPORT_STUFF
    /* For now, we are not going to be as proactive as the LOOP to
     * check if the nport link is up. Need to modify this latter.
     */
    if (pCThread->InitAsNport)
    {
        if((FM_Status & FRAMEMGR_NPORT_OK ) == FRAMEMGR_NPORT_OK )
        {
            if(! CFunc_Queues_Frozen( hpRoot ))
            {
                return agTRUE;
            }
        }
        return agFALSE;
    }

#endif  /* NPORT_STUFF */

    FM_Status &=  ~  ChipIOUp_Frame_Manager_Status_LSM_MASK;

    FM_Status &=  ~ ChipIOUp_Frame_Manager_Status_BA;

    FM_Status &=  ~ ChipIOUp_Frame_Manager_Status_OLS;


    if(FM_Status ==  ChipIOUp_Frame_Manager_Status_LP   &&
                    ! CFunc_Queues_Frozen( hpRoot )         )

    {
        return agTRUE;
    }

#ifdef OSLayer_Stub
    return agTRUE;
#else  /* OSLayer_Stub was not defined */

    pCThread->FuncPtrs.Proccess_IMQ(hpRoot);

    FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );

    FM_Status &=  ~ ChipIOUp_Frame_Manager_Status_LSM_MASK;

    FM_Status &=  ~ ChipIOUp_Frame_Manager_Status_BA;

    FM_Status &=  ~ ChipIOUp_Frame_Manager_Status_OLS;

    if(FM_Status ==  ChipIOUp_Frame_Manager_Status_LP &&
                    ! CFunc_Queues_Frozen( hpRoot )         )

    {
        return agTRUE;
    }

    if((FM_Status ==  0) && (! CFunc_Queues_Frozen( hpRoot )) )

    {
        return agTRUE;
    }


    FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
    if( FM_Status & ChipIOUp_Frame_Manager_Status_BA && CFunc_Queues_Frozen( hpRoot ) )
    {
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, ~ ChipIOUp_Frame_Manager_Status_BA);
        if( ! CFunc_Always_Enable_Queues( hpRoot ))
        return agTRUE;

    }

    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "CFuncAll_clear(Org %08X) Fail FM %08X TL %08X Qf %d CState %d",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        FM_Status,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        CFunc_Queues_Frozen( hpRoot ),
                        pCThread->thread_hdr.currentState,
                        0,0,0);

    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread_ptr(hpRoot)->LOOP_DOWN,
                        CThread_ptr(hpRoot)->IDLE_RECEIVED,
                        CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                        CThread_ptr(hpRoot)->ERQ_FROZEN,
                        CThread_ptr(hpRoot)->FCP_FROZEN,
                        CThread_ptr(hpRoot)->ProcessingIMQ,
                        0,0);

    return agFALSE;
#endif /* OSLayer_Stub was not defined */
}

agBOOLEAN CFuncTakeOffline( agRoot_t *hpRoot )
{
    CThread_t       *   pCThread      = CThread_ptr(hpRoot);
    os_bit32 TimeOut =0;
    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "CFuncTakeOffline",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);


    if(pCThread->LoopPreviousSuccess)
    {

        CFuncFreezeQueuesPoll( hpRoot);

        CFuncDisable_Interrupts(hpRoot,ChipIOUp_INTEN_INT);

/*
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration, 0 );
*/

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Exit_Loop );

        osStallThread(hpRoot,1006);

        pCThread->FuncPtrs.Proccess_IMQ(hpRoot);

/*
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ));

*/
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Primitive, 0x15F7F7);


        pCThread->PrimitiveReceived = agFALSE;
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control,
                                   ChipIOUp_Frame_Manager_Control_CMD_Host_Control   |
                                   ChipIOUp_Frame_Manager_Control_SP                 |
                                   ChipIOUp_Frame_Manager_Control_SQ                   );


        TimeOut = 0;
        while( ! pCThread->PrimitiveReceived)
        {
            osStallThread(hpRoot,1005);

            CFuncFMCompletion(hpRoot);

            if( TimeOut > 10 )
            {
                fiLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                "After CFuncTakeOffline Timed Out !",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);
            break;
            }
            TimeOut++;

        }

    }
    else
    {
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Exit_Loop );

        osStallThread(hpRoot,1006);

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Primitive, 0x15F7F7);

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control,
                               ChipIOUp_Frame_Manager_Control_CMD_Host_Control   |
                               ChipIOUp_Frame_Manager_Control_SP                 |
                               ChipIOUp_Frame_Manager_Control_SQ                   );


        for (TimeOut = 0; TimeOut < 10; TimeOut++) {
            osStallThread(hpRoot,1000);
        }

    }

    osStallThread(hpRoot,1004);

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Exit_Host_Control );

    osStallThread(hpRoot,1003);

    CFuncFMCompletion(hpRoot);



return(agTRUE);
}

agBOOLEAN CFuncToReinit( os_bit32 FM_Status)
{

    if(FM_Status & ChipIOUp_Frame_Manager_Status_LS)
        return (agFALSE);
    else
        return (agTRUE);

}

/* Begin: Big_Endian_Code */


void CFuncSwapDmaMemBeforeIoSent(fi_thread__t *thread, os_bit32 DoFunc)
{
    agRoot_t        * hpRoot        = thread->hpRoot;
    CThread_t       * pCThread      = CThread_ptr(hpRoot);
    CDBThread_t     * pCDBThread;
    SFThread_t      * pSFThread;
#ifdef _DvrArch_1_30_
    PktThread_t     * pPktThread;
#endif /* _DvrArch_1_30_ was defined */

    SG_Element_t    * pESGL;
    SG_Element_t    * pESGLNext;

    SEST_t          * SEST;
    IRB_t           * pIrb;
    FCHS_t          * FCHS;
    void            * CmndPayload;
    fiMemMapMemoryDescriptor_t * ERQ;
    fiMemMapMemoryDescriptor_t * ESGLs;
    ERQProdIndex_t  tempERQ_index = 0;

    os_bit32             Payload_len;
    os_bit32             ChunksPerESGL ;

    ESGLs         = &(pCThread->Calculation.MemoryLayout.ESGL);
    ChunksPerESGL = pCThread->Calculation.Parameters.SizeSGLs;

    ERQ     = &(pCThread->Calculation.MemoryLayout.ERQ);
    pIrb    = (IRB_t *)ERQ->addr.DmaMemory.dmaMemoryPtr;
    /*
    **  The ERQ index has already been incremented, so what we
    **  want here is what it *used* to be.
    **  RSB/Orca 7/3/99
    */
    if (pCThread->HostCopy_ERQProdIndex != 0)
    {
        tempERQ_index = pCThread->HostCopy_ERQProdIndex - 1;
    }
    else
    {
        tempERQ_index = pCThread->Calculation.MemoryLayout.ERQ.elements - 1;
    }
    pIrb   += tempERQ_index;

    if (DoFunc == DoFuncCdbCmnd)
    {
        pCDBThread    = (CDBThread_t *)thread;
        SEST          = pCDBThread->SEST_Ptr;
        FCHS          = pCDBThread->FCP_CMND_Ptr;
        CmndPayload   = (void *)((os_bit8 *)FCHS + sizeof(FCHS_t));
        Payload_len   = sizeof(agFcpCmnd_t)/4;

        if (!(((USE_t *)SEST)->LOC & USE_LOC))/* Detect ESGL use */
        {
            pESGL         = (SG_Element_t *)((os_bit8 *)(ESGLs->addr.DmaMemory.dmaMemoryPtr) + (SEST->USE.First_SG.L32 - ESGLs->addr.DmaMemory.dmaMemoryLower32));
            while (pESGL)
            {
                pESGLNext = (SG_Element_t *)((os_bit8 *)(ESGLs->addr.DmaMemory.dmaMemoryPtr) + ((pESGL + ChunksPerESGL - 1)->L32 - ESGLs->addr.DmaMemory.dmaMemoryLower32));
                osSwapDownwardNonPayloadToTachLiteEndian((void *)pESGL, (ChunksPerESGL*sizeof(SG_Element_t)/sizeof(os_bit32)));
                pESGL     = pESGLNext;
            }
        }

        osSwapDownwardNonPayloadToTachLiteEndian((void *)SEST, sizeof(SEST_t)/4);
    }
    else if (DoFunc == DoFuncSfCmnd)
    {
        pSFThread     = (SFThread_t * )thread;
        FCHS          = pSFThread->SF_CMND_Ptr;
        CmndPayload   = (void *)((os_bit8 *)FCHS + sizeof(FCHS_t));
        Payload_len   = ((pIrb->Req_A.Bits__SFS_Len & 0xfff)-sizeof(FCHS_t))/4;
    }
#ifdef _DvrArch_1_30_
    else /* DoFuncPktCmnd */
    {
        pPktThread    = (PktThread_t * )thread;
        FCHS          = pPktThread->Pkt_CMND_Ptr;
        CmndPayload   = (void *)((os_bit8 *)FCHS + sizeof(FCHS_t));
        Payload_len   = ((pIrb->Req_A.Bits__SFS_Len & 0xfff)-sizeof(FCHS_t))/4;
    }
#endif /* _DvrArch_1_30_ was defined */

    osSwapDownwardNonPayloadToTachLiteEndian((void *)FCHS, sizeof(FCHS_t)/4);
    osSwapDownwardPayloadToTachLiteEndian(CmndPayload, Payload_len);
    osSwapDownwardNonPayloadToTachLiteEndian((void *)pIrb, sizeof(IRB_t)/4);

    osChipIOLoWriteBit32(hpRoot, ChipIOLo_ERQ_Producer_Index,
                          (os_bit32)pCThread->HostCopy_ERQProdIndex);

    return;
}


void CFuncSwapDmaMemAfterIoDone(agRoot_t *hpRoot)
{
    CThread_t       * pCThread     = CThread_ptr(hpRoot);
    CDBThread_t     * pCDBThread;

    os_bit32                         tempCMType;
    os_bit32                         tempBit32;

    os_bit32                         SFQ_Num_entry;
    os_bit32                         SFQ_Start_index;
    os_bit32                         Frame_Len;
    os_bit32                         SFQ_Index;
    os_bit32                         SFQ_Ele_Size;

    X_ID_t                        X_ID;
    SEST_t *                      SEST;
    FCHS_t *                      FCHS;
    FC_FCP_RSP_Payload_t *        fcprsp;
    FC_ELS_Unknown_Payload_t *    Payload;

    CM_Unknown_t *                pGenericCM;
    fiMemMapMemoryDescriptor_t *  SFQ_MemoryDescriptor;
    fiMemMapMemoryDescriptor_t *  CDBThread_MemoryDescriptor;
    fiMemMapMemoryDescriptor_t *  ESGLs;
    os_bit32                      ChunksPerESGL ;
    SG_Element_t               *  pESGL;

    pGenericCM  = pCThread->Calculation.MemoryLayout.IMQ.addr.DmaMemory.dmaMemoryPtr;
    pGenericCM += pCThread->HostCopy_IMQConsIndex;
    osSwapUpwardNonPayloadToSystemEndian((void *)pGenericCM, (os_bit32) sizeof(CM_Unknown_t)/sizeof(os_bit32));

    tempCMType  = pGenericCM->INT__CM_Type & CM_Unknown_CM_Type_MASK;
    switch (tempCMType)
    {
        case  CM_Unknown_CM_Type_Inbound_FCP_Exchange:
            X_ID =(X_ID_t)(pGenericCM->Unused_DWord_1 & CM_Inbound_FCP_Exchange_SEST_Index_MASK);
/*            pCDBThread = (CDBThread_t *)((os_bit8 *)(pCThread->CDBThread_Base)  */
/*                                      + (X_ID * pCThread->CDBThread_Size));  */
            CDBThread_MemoryDescriptor = &(pCThread->Calculation.MemoryLayout.CDBThread);
            pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                               + (X_ID * CDBThread_MemoryDescriptor->elementSize));
            fcprsp = (FC_FCP_RSP_Payload_t *)(((os_bit8 *)pCDBThread->FCP_RESP_Ptr) + sizeof(FCHS_t));
            osSwapUpwardPayloadToFcLinkEndian((void *)fcprsp, (os_bit32) 6);
            /* Doesn't matter 'RPC bit set or not', doing it won't hurt. */

            if((pGenericCM->Unused_DWord_1 &             /* error ststus and Sest Index */
                        (CM_Inbound_FCP_Exchange_LKF
                        +CM_Inbound_FCP_Exchange_CNT
                        +CM_Inbound_FCP_Exchange_OVF
                        +CM_Inbound_FCP_Exchange_RPC)) == CM_Inbound_FCP_Exchange_RPC)
            {
                if (!fcprsp->FCP_STATUS.SCSI_status_byte)
                    break;
            }

            tempBit32 = pCThread->Calculation.MemoryLayout.FCP_RESP.elementSize/4 - 6;
            osSwapUpwardPayloadToFcLinkEndian((void *)(((os_bit8 *)fcprsp)+6*4), tempBit32);
            SEST = (SEST_t *)pCDBThread->SEST_Ptr;
            ESGLs         = &(pCThread->Calculation.MemoryLayout.ESGL);
            ChunksPerESGL = pCThread->Calculation.Parameters.SizeSGLs;
            osSwapUpwardNonPayloadToSystemEndian((void *)SEST, (os_bit32) sizeof(SEST_t)/sizeof(os_bit32));
            if (!(((USE_t *)SEST)->LOC & USE_LOC))/* Detect ESGL use */
            {
                pESGL     = (SG_Element_t *)((os_bit8 *)(ESGLs->addr.DmaMemory.dmaMemoryPtr) + (SEST->USE.First_SG.L32 - ESGLs->addr.DmaMemory.dmaMemoryLower32));
                while (pESGL)
                {
                    osSwapUpwardNonPayloadToSystemEndian((void *)pESGL, (ChunksPerESGL*sizeof(SG_Element_t)/sizeof(os_bit32)));
                    pESGL = (SG_Element_t *)((os_bit8 *)(ESGLs->addr.DmaMemory.dmaMemoryPtr) + ((pESGL + ChunksPerESGL - 1)->L32 - ESGLs->addr.DmaMemory.dmaMemoryLower32));
                }
            }

            break;

        case  CM_Unknown_CM_Type_Inbound:
            SFQ_MemoryDescriptor = &(pCThread->Calculation.MemoryLayout.SFQ);
            SFQ_Ele_Size = SFQ_MemoryDescriptor->elementSize;

            SFQ_Index = pGenericCM->Unused_DWord_1 & CM_Inbound_SFQ_Prod_Index_MASK;

            Frame_Len = pGenericCM->Unused_DWord_2;

            if(Frame_Len % 64) SFQ_Num_entry = (Frame_Len / 64) + 1;
            else SFQ_Num_entry = (Frame_Len / 64);

            SFQ_Start_index = SFQ_Index - SFQ_Num_entry;

            if (SFQ_Start_index > SFQ_MemoryDescriptor->elements)
                SFQ_Start_index += SFQ_MemoryDescriptor->elements;

            FCHS =    (FCHS_t *)((os_bit8 *)(SFQ_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr)
                                        +(SFQ_Start_index * SFQ_Ele_Size));
            Payload = (FC_ELS_Unknown_Payload_t *)((os_bit8 *)FCHS + sizeof(FCHS_t));

            /* first SFQ entry, 64 bytes */
            osSwapUpwardNonPayloadToSystemEndian((void *)FCHS,    (os_bit32) (sizeof(FCHS_t)/sizeof(os_bit32)));
            osSwapUpwardPayloadToFcLinkEndian((void *)Payload, (os_bit32) ((SFQ_Ele_Size-sizeof(FCHS_t))/sizeof(os_bit32)));

            while (--SFQ_Num_entry)
            {
                if (++SFQ_Start_index >= SFQ_MemoryDescriptor->elements)
                {
                  Payload = (FC_ELS_Unknown_Payload_t *)((os_bit8 *)(SFQ_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr));
                  SFQ_Start_index = 0;
                }
                else
                  Payload = (FC_ELS_Unknown_Payload_t *)((os_bit8 *)Payload + SFQ_Ele_Size);

                osSwapUpwardPayloadToFcLinkEndian((void *)Payload, (os_bit32) (SFQ_Ele_Size/4));
            }
            break;

        case  CM_Unknown_CM_Type_Frame_Manager:
        case  CM_Unknown_CM_Type_Outbound:
        case  CM_Unknown_CM_Type_Error_Idle:
        case  CM_Unknown_CM_Type_ERQ_Frozen:
        default:
        break;
    }

    return;
}

/* End: Big_Endian_Code */


event_t CFuncCheckCstate(agRoot_t * hpRoot)
{
    CThread_t       *  CThread      = CThread_ptr(hpRoot);
    event_t            event_to_send = 0;
    os_bit32           FM_Status       = 0;

    if( ! CThread->ProcessingIMQ )
    {
        if( CThread->thread_hdr.currentState != CStateNormal )
        {

            FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
            switch( CThread->thread_hdr.currentState )
            {
                case CStateResetNeeded:
                            if (CThread->InitAsNport )
                            {
                                if((FM_Status & FRAMEMGR_NPORT_OK ) == FRAMEMGR_NPORT_OK )
                                {
                                    if( CFuncAll_clear( hpRoot ))
                                    {
                                        if(CThread->NumberOfFLOGITimeouts >= MAX_FLOGI_TIMEOUTS )
                                        {
                                            event_to_send = (event_t) CEventGoToInitializeFailed;
                                        }
                                        else
                                        {
                                            event_to_send = (event_t) CEventResetIfNeeded;
                                        }
                                    }
                                    else
                                    {
                                         event_to_send = (event_t) CEventDoInitalize;
                                    }
                                    break;
                                }
                                 if((FM_Status & FRAMEMGR_NPORT_LINK_FAIL ) == FRAMEMGR_NPORT_LINK_FAIL )
                                {
                                    event_to_send = (event_t) CEventGoToInitializeFailed;
                                    break;
                                }

                                if(CThread->Loop_Reset_Event_to_Send == CEventInitalizeSuccess )
                                {
                                    CThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
                                }
                                else
                                {
                                    event_to_send = (event_t) CThread->Loop_Reset_Event_to_Send;
                                }
                                break;
                            }
                            else
                            {
                                if((FM_Status & FRAMEMGR_LINK_DOWN ) == FRAMEMGR_LINK_DOWN )
                                {
                                    if((FM_Status & ChipIOUp_Frame_Manager_Status_LSM_MASK ) == ChipIOUp_Frame_Manager_Status_LSM_Loop_Fail )
                                    {/*This helps to get out of FM storms */
                                        event_to_send = (event_t) CEventGoToInitializeFailed;
                                    }
                                    else
                                    {
                                        event_to_send = (event_t) 0;
                                    }
                                }
                                else
                                {
                                    if((FM_Status & ChipIOUp_Frame_Manager_Status_LP ) == ChipIOUp_Frame_Manager_Status_LP )
                                    {
                                        event_to_send = CEventResetIfNeeded;
                                    }
                                    else
                                    {
                                        if((FM_Status & ChipIOUp_Frame_Manager_Status_LUP ) == ChipIOUp_Frame_Manager_Status_LUP )
                                        {
                                            event_to_send = CEventResetIfNeeded;
                                        }
                                        else
                                        {
                                            event_to_send = (event_t) CThread->Loop_Reset_Event_to_Send;
                                        }
                                    }
                                }
                            }

                            break;
                case CStateExternalLogout:
                            event_to_send = CEventResetIfNeeded;
                            break;
                case CStateExternalDeviceReset:
                            event_to_send = CEventDoExternalDeviceReset;
                            break;
                case CStateLoopFailedReInit:
                            event_to_send = CEventDoInitalize;
                            fiLogDebugString(hpRoot,
                                            CFuncCheckCstateErrorLevel,
                                            "%s %s FM_Status %08X ",
                                            "CFuncCheckCstate","CStateLoopFailedReInit",
                                            (void *)agNULL,(void *)agNULL,
                                            FM_Status,
                                            0,0,
                                            0,0,0,0,0);
                            if( FM_Status &  ~ChipIOUp_Frame_Manager_Status_LSM_MASK  )
                            {
                                if( CThread->LoopPreviousSuccess)
                                {
                                    event_to_send = CEventLoopConditionCleared;
                                }
                                else
                                {
                                    event_to_send = CEventDoInitalize;
                                }
                            }
                            else
                            {
                                event_to_send = CEventDoInitalize;
                            }
                            break;

                case CStateInitializeFailed:

                            fiLogDebugString(hpRoot,
                                            CFuncCheckCstateErrorLevel,
                                            "%s %s FM_Status %08X FM_IMQ_Status %08X ",
                                            "CFuncCheckCstate","CStateInitializeFailed",
                                            (void *)agNULL,(void *)agNULL,
                                            FM_Status,
                                            CThread->From_IMQ_Frame_Manager_Status,
                                            0,0,0,0,0,0);
#ifdef NPORT_STUFF
                            if (CThread->InitAsNport )
                            {
                                if (CFuncToReinit( FM_Status))
                                {
                                    if((FM_Status &  FRAMEMGR_NPORT_OK) == FRAMEMGR_NPORT_OK )
                                    {
                                        CThread->Loop_Reset_Event_to_Send = CEventResetDetected;
                                        if(CThread->DeviceSelf)
                                        {
                                            event_to_send = CEventAllocFlogiThread;
                                        }
                                        else
                                        {
                                            event_to_send = CEventInitChipSuccess;
                                        }


                                        if(CThread->FlogiRcvdFromTarget )
                                        {
                                            event_to_send = 0;
                                        }

                                            fiLogDebugString(hpRoot,
                                                        CFuncCheckCstateErrorLevel,
                                                       "%s My_ID %08X Self %p ETS %d FM %08X",
                                                        "CFCS",(char *)agNULL,
                                                        CThread->DeviceSelf,(void *)agNULL,
                                                        fiComputeCThread_S_ID(CThread),
                                                        event_to_send,
                                                        FM_Status,
                                                        0,0,0,0,0);

                                        break;

                                    }
                                    if((FM_Status & FRAMEMGR_NPORT_NO_CABLE ) == FRAMEMGR_NPORT_NO_CABLE )
                                    {
                                        if((FM_Status & ChipIOUp_Frame_Manager_Status_PSM_LF2 ) == ChipIOUp_Frame_Manager_Status_PSM_LF2 )
                                        {
                                            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Clear_LF );

                                            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, FM_Status);

                                        }

                                        event_to_send = (event_t) 0;
                                    }
                                    else
                                    {
                                        fiLogDebugString(hpRoot,
                                                        CFuncCheckCstateErrorLevel,
                                                        "%s CFuncToReinit Failed %s FM_Status %08X FM_IMQ_Status %08X ",
                                                        "CFuncCheckCstate","CEventLIPEventStorm",
                                                        (void *)agNULL,(void *)agNULL,
                                                        FM_Status,
                                                        CThread->From_IMQ_Frame_Manager_Status,0,
                                                        0,0,0,0,0);
                                        /* CThread->TwoGigSuccessfull = CFuncDoLinkSpeedNegotiation( hpRoot); */
                                        event_to_send = CEventLIPEventStorm;
                                    }
                                }
                                else
                                {
                                    event_to_send = 0;
                                }

                                return (event_to_send);
                            }
#endif /* NPORT_STUFF */

                            if(  FM_Status  &  ChipIOUp_Frame_Manager_Status_OLS      )
                            {
                                if(CThread->NOS_DetectedInIMQ > 12)
                                {
                                    CThread->NOS_DetectedInIMQ =0;
                                    event_to_send = CEventDoInitalize;
                                }
                                CThread->NOS_DetectedInIMQ ++;
                                break;
                            }
                            if( FM_Status == ChipIOUp_Frame_Manager_Status_LP)
                            {
                                if( CThread->DeviceSelf != agNULL)
                                {
                                    fiLogDebugString(hpRoot,
                                                    FCMainLogErrorLevel,
                                                    "%s %s FM_Status %08X ",
                                                    "CFuncCheckCstate","Recover NO LIP",
                                                    (void *)agNULL,(void *)agNULL,
                                                    FM_Status,
                                                    0,0,0,0,0,0,0);
                                    if( CFuncShowWhereDevThreadsAre( hpRoot))
                                    {
                                        event_to_send = 0;
                                        break;
                                    }
                                    if(CThread->NumberOfFLOGITimeouts >= MAX_FLOGI_TIMEOUTS )
                                    {
                                        event_to_send = (event_t) 0;
                                        break;
                                    }
                                    CThread->Loop_Reset_Event_to_Send = CEventResetDetected;
                                    event_to_send = CEventAsyncLoopEventDetected;
                                    break;
                                }
                                break;
                            }

                            if( ( FM_Status & ChipIOUp_Frame_Manager_Status_LSM_MASK ) == ChipIOUp_Frame_Manager_Status_LSM_Loop_Fail)
                            {
                                if( CThread->TwoGigSuccessfull )
                                {
                                    CThread->NumberTwoGigFailures++;
                                    if(CThread->NumberTwoGigFailures % 30 )
                                    {
                                        event_to_send = 0;
                                    }
                                    else /* Retry every 30 seconds */
                                    {
                                        fiLogString(hpRoot,
                                                    "%s FM %08X %d",
                                                    "Check BIOS 2 gig setting",(char *)agNULL,
                                                    (void *)agNULL,(void *)agNULL,
                                                    FM_Status,
                                                    CThread->NumberTwoGigFailures,
                                                    0,0,0,0,0,0);

                                        event_to_send = CEventDoInitalize;
                                    }
                                }
                                break;
                            }
                            else
                            {

                                if( ! ( FM_Status & ~ ( ChipIOUp_Frame_Manager_Status_LSM_MASK |
                                                        ChipIOUp_Frame_Manager_Status_BYP)       ) )
                                {
                                    event_to_send = CEventDoInitalize;
                                }
                                else
                                {

                                    if(!( FM_Status & ~ ChipIOUp_Frame_Manager_Status_LP ))
                                    {
                                        event_to_send = CEventDoInitalize;
                                    }
                                    else
                                    {
                                        if( FM_Status &  ChipIOUp_Frame_Manager_Status_LUP  )
                                        {
                                            event_to_send = CEventDoInitalize;
                                        }
                                        else
                                        {
                                            if( FM_Status &  ChipIOUp_Frame_Manager_Status_BYP  )
                                            {
                                                event_to_send = 0;
                                            }
                                            else
                                            {
                                                if( FM_Status &  ChipIOUp_Frame_Manager_Status_LPF  )
                                                {
                                                    /* Check this
                                                    osChipIOUpWriteBit32(hpRoot, ChipIOUp_Frame_Manager_Status,FM_Status );
                                                    event_to_send = 0;
                                                    */
                                                }
                                                else
                                                {
                                                    if(( FM_Status &  ~ChipIOUp_Frame_Manager_Status_LSM_MASK ) > ChipIOUp_Frame_Manager_Status_LSM_Initialize)
                                                    {
                                                        event_to_send = 0;
                                                    }
                                                    else
                                                    {
                                                        /* event_to_send = CEventLIPEventStorm;
                                                        */

                                                        CThread->Loop_Reset_Event_to_Send = CEventResetDetected;
                                                        event_to_send = CEventAsyncLoopEventDetected;

                                                        fiLogDebugString(hpRoot,
                                                                        FCMainLogErrorLevel,
                                                                        "%s sends %s FM_Status %08X real FM %08X Result %08X",
                                                                        "CFuncCheckCstate","CEventLIPEventStorm",
                                                                        (void *)agNULL,(void *)agNULL,
                                                                        FM_Status,
                                                                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                                                                        ( ! ( FM_Status & ~ ( ChipIOUp_Frame_Manager_Status_LSM_MASK |
                                                                              ChipIOUp_Frame_Manager_Status_BYP)  ) ),
                                                                        0,0,0,0,0);

                                                        fiLogDebugString(hpRoot,
                                                                        FCMainLogErrorLevel,
                                                                        "IntStat %08X Logical Ints %08X",
                                                                        (char *)agNULL,(char *)agNULL,
                                                                        (void *)agNULL,(void *)agNULL,
                                                                        CFuncRead_Interrupts(hpRoot),
                                                                        CThread->sysIntsLogicallyEnabled,
                                                                        0,0,0,0,0,0);

                                                        fiLogDebugString(hpRoot,
                                                                        SFStateLogErrorLevel,
                                                                        "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                                                                        (char *)agNULL,(char *)agNULL,
                                                                        (void *)agNULL,(void *)agNULL,
                                                                        CThread_ptr(hpRoot)->LOOP_DOWN,
                                                                        CThread_ptr(hpRoot)->IDLE_RECEIVED,
                                                                        CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                                                                        CThread_ptr(hpRoot)->ERQ_FROZEN,
                                                                        CThread_ptr(hpRoot)->FCP_FROZEN,
                                                                        CThread_ptr(hpRoot)->ProcessingIMQ,
                                                                        0,0);

                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            break;
                            }
                            break;
                case CStateRSCNErrorBackIOs:
                            break;


                default: break;
            }

            if ( event_to_send != 0 )
            {
                fiLogDebugString(hpRoot,
                                FCMainLogErrorLevel,
                                "%s Not CStateNormal %d Send event %d FM_Status %08X Lrsts %d",
                                "CFuncCheckCstate",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                CThread->thread_hdr.currentState,
                                event_to_send,
                                FM_Status,
                                CThread->Loop_Reset_Event_to_Send,0,0,0,0);

/*
                if( CThread->thread_hdr.currentState == CStateInitializeFailed )
                {
                    CThread->TwoGigSuccessfull = CFuncDoLinkSpeedNegotiation( hpRoot);
                }
*/
            }
        }
        else
        {
            if (CThread->InitAsNport )
            {
                FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
                if((FM_Status & ChipIOUp_Frame_Manager_Status_PSM_MASK) != ChipIOUp_Frame_Manager_Status_PSM_ACTIVE)
                {
                fiLogDebugString(hpRoot,
                                FCMainLogErrorLevel,
                                "%s FM_Status %08X ",
                                "CFuncCheckCstate",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                FM_Status,
                                0,0,
                                0,0,0,0,0);

                }

            }
        }
    }
    return(event_to_send);
}

void CFuncCompleteAllActiveCDBThreads( agRoot_t * hpRoot,os_bit32 CompletionStatus, event_t event_to_send )
{
    CThread_t     * pCThread      = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread;
    CDBThread_t   * pCDBThread;
    fiList_t      * pCdbList;
    fiList_t      * pDevList;

    pDevList = &pCThread->Active_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->Active_DevLink) != pDevList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );

        if (fiListNotEmpty( &pDevThread->Active_CDBLink_0  ))
        {

            pCdbList = &pDevThread->Active_CDBLink_0;
            pCdbList = pCdbList->flink;

            while((&pDevThread->Active_CDBLink_0) != pCdbList)
            {
                pCDBThread = hpObjectBase(CDBThread_t,
                                          CDBLink,pCdbList );

                pCdbList = pCdbList->flink;

                fiLogDebugString(hpRoot,
                                CStateLogConsoleLevelLip,
                                "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                                "CfuncCompleteAllActiveCDBThreads",(char *)agNULL,
                                pDevThread,pCDBThread,
                                event_to_send,
                                pCDBThread->thread_hdr.currentState,
                                pCDBThread->TimeStamp,
                                0,0,0,0,0);

                pCDBThread->CompletionStatus =  CompletionStatus;
                fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
            }
        }
        if (fiListNotEmpty( &pDevThread->Active_CDBLink_1  ))
        {

            pCdbList = &pDevThread->Active_CDBLink_1;
            pCdbList = pCdbList->flink;

            while((&pDevThread->Active_CDBLink_1) != pCdbList)
            {
                pCDBThread = hpObjectBase(CDBThread_t,
                                          CDBLink,pCdbList );

                pCdbList = pCdbList->flink;

                fiLogDebugString(hpRoot,
                                CStateLogConsoleLevelLip,
                                "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                                "CfuncCompleteAllActiveCDBThreads",(char *)agNULL,
                                pDevThread,pCDBThread,
                                event_to_send,
                                pCDBThread->thread_hdr.currentState,
                                pCDBThread->TimeStamp,
                                0,0,0,0,0);

                pCDBThread->CompletionStatus =  CompletionStatus;

                fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
            }
        }
        if (fiListNotEmpty( &pDevThread->Active_CDBLink_2  ))
        {

            pCdbList = &pDevThread->Active_CDBLink_2;
            pCdbList = pCdbList->flink;

            while((&pDevThread->Active_CDBLink_2) != pCdbList)
            {
                pCDBThread = hpObjectBase(CDBThread_t,
                                          CDBLink,pCdbList );

                pCdbList = pCdbList->flink;

                fiLogDebugString(hpRoot,
                                CStateLogConsoleLevelLip,
                                "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                                "CfuncCompleteAllActiveCDBThreads",(char *)agNULL,
                                pDevThread,pCDBThread,
                                event_to_send,
                                pCDBThread->thread_hdr.currentState,
                                pCDBThread->TimeStamp,
                                0,0,0,0,0);

                pCDBThread->CompletionStatus =  CompletionStatus;

                fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
            }
        }
        if (fiListNotEmpty( &pDevThread->Active_CDBLink_3  ))
        {

            pCdbList = &pDevThread->Active_CDBLink_3;
            pCdbList = pCdbList->flink;

            while((&pDevThread->Active_CDBLink_3) != pCdbList)
            {
                pCDBThread = hpObjectBase(CDBThread_t,
                                          CDBLink,pCdbList );

                pCdbList = pCdbList->flink;

                fiLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                                "CfuncCompleteAllActiveCDBThreads",(char *)agNULL,
                                pDevThread,pCDBThread,
                                event_to_send,
                                pCDBThread->thread_hdr.currentState,
                                pCDBThread->TimeStamp,
                                0,0,0,0,0);

                pCDBThread->CompletionStatus =  CompletionStatus;

                fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
            }
        }
        if (fiListNotEmpty( &pDevThread->TimedOut_CDBLink  ))
        {

            pCdbList = &pDevThread->TimedOut_CDBLink;
            pCdbList = pCdbList->flink;

            while((&pDevThread->TimedOut_CDBLink) != pCdbList)
            {
                pCDBThread = hpObjectBase(CDBThread_t,
                                          CDBLink,pCdbList );

                pCdbList = pCdbList->flink;

                fiLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                                "CfuncCompleteAllActiveCDBThreads",(char *)agNULL,
                                pDevThread,pCDBThread,
                                event_to_send,
                                pCDBThread->thread_hdr.currentState,
                                pCDBThread->TimeStamp,
                                0,0,0,0,0);

                pCDBThread->CompletionStatus =  CompletionStatus;

                fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
            }
        }

        pDevList = pDevList->flink;

    }

    if(pCThread->CDBpollingCount)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Ccnt Non Zero Ccnt %x",
                    "CFuncCompleteAllActiveCDBThreads",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->CDBpollingCount,
                    0,0,0,0,0,0,0);
    }

}

void CFuncCompleteAwaitingLoginCDBThreadsOnDevice(DevThread_t   * pDevThread ,os_bit32 CompletionStatus, event_t event_to_send )
{
    CDBThread_t   * pCDBThread;
    fiList_t      * pCdbList;

    if (fiListNotEmpty( &pDevThread->Awaiting_Login_CDBLink  ))
    {

        pCdbList = &pDevThread->Awaiting_Login_CDBLink;
        pCdbList = pCdbList->flink;

        while((&pDevThread->Awaiting_Login_CDBLink) != pCdbList)
        {
            pCDBThread = hpObjectBase(CDBThread_t,
                                      CDBLink,pCdbList );

            pCdbList = pCdbList->flink;

            fiLogDebugString(pDevThread->thread_hdr.hpRoot,
                            CStateLogConsoleLevelLip,
                            "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                            "CFuncCompleteAwaitingLoginCDBThreadsOnDevice",(char *)agNULL,
                            pDevThread,pCDBThread,
                            event_to_send,
                            pCDBThread->thread_hdr.currentState,
                            pCDBThread->TimeStamp,
                            0,0,0,0,0);

            pCDBThread->CompletionStatus =  CompletionStatus;

            fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
        }
    }

}

void CFuncCompleteActiveCDBThreadsOnDevice(DevThread_t * pDevThread ,os_bit32 CompletionStatus, event_t event_to_send )
{
    agRoot_t      * hpRoot        = pDevThread->thread_hdr.hpRoot;
    CThread_t     * pCThread      = CThread_ptr(hpRoot);
    CDBThread_t   * pCDBThread;
    fiList_t      * pCdbList;

    if (fiListNotEmpty( &pDevThread->Active_CDBLink_0  ))
    {

        pCdbList = &pDevThread->Active_CDBLink_0;
        pCdbList = pCdbList->flink;

        while((&pDevThread->Active_CDBLink_0) != pCdbList)
        {
            pCDBThread = hpObjectBase(CDBThread_t,
                                      CDBLink,pCdbList );

            pCdbList = pCdbList->flink;

            fiLogDebugString(hpRoot,
                            CStateLogConsoleLevelLip,
                            "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                            "CFuncCompleteActiveCDBThreadsOnDevice",(char *)agNULL,
                            pDevThread,pCDBThread,
                            event_to_send,
                            pCDBThread->thread_hdr.currentState,
                            pCDBThread->TimeStamp,
                            0,0,0,0,0);

            pCDBThread->CompletionStatus =  CompletionStatus;

            fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
        }
    }
    if (fiListNotEmpty( &pDevThread->Active_CDBLink_1  ))
    {

        pCdbList = &pDevThread->Active_CDBLink_1;
        pCdbList = pCdbList->flink;

        while((&pDevThread->Active_CDBLink_1) != pCdbList)
        {
            pCDBThread = hpObjectBase(CDBThread_t,
                                      CDBLink,pCdbList );

            pCdbList = pCdbList->flink;

            fiLogDebugString(hpRoot,
                            CStateLogConsoleLevelLip,
                            "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                            "CFuncCompleteActiveCDBThreadsOnDevice",(char *)agNULL,
                            pDevThread,pCDBThread,
                            event_to_send,
                            pCDBThread->thread_hdr.currentState,
                            pCDBThread->TimeStamp,
                            0,0,0,0,0);

            pCDBThread->CompletionStatus =  CompletionStatus;

            fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
        }
    }
    if (fiListNotEmpty( &pDevThread->Active_CDBLink_2  ))
    {

        pCdbList = &pDevThread->Active_CDBLink_2;
        pCdbList = pCdbList->flink;

        while((&pDevThread->Active_CDBLink_2) != pCdbList)
        {
            pCDBThread = hpObjectBase(CDBThread_t,
                                      CDBLink,pCdbList );

            pCdbList = pCdbList->flink;

            fiLogDebugString(hpRoot,
                            CStateLogConsoleLevelLip,
                            "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                            "CFuncCompleteActiveCDBThreadsOnDevice",(char *)agNULL,
                            pDevThread,pCDBThread,
                            event_to_send,
                            pCDBThread->thread_hdr.currentState,
                            pCDBThread->TimeStamp,
                            0,0,0,0,0);

            pCDBThread->CompletionStatus =  CompletionStatus;

            fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
        }
    }
    if (fiListNotEmpty( &pDevThread->Active_CDBLink_3  ))
    {

        pCdbList = &pDevThread->Active_CDBLink_3;
        pCdbList = pCdbList->flink;

        while((&pDevThread->Active_CDBLink_3) != pCdbList)
        {
            pCDBThread = hpObjectBase(CDBThread_t,
                                      CDBLink,pCdbList );

            pCdbList = pCdbList->flink;

            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                            "CFuncCompleteActiveCDBThreadsOnDevice",(char *)agNULL,
                            pDevThread,pCDBThread,
                            event_to_send,
                            pCDBThread->thread_hdr.currentState,
                            pCDBThread->TimeStamp,
                            0,0,0,0,0);

            pCDBThread->CompletionStatus =  CompletionStatus;

            fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
        }
    }
    if (fiListNotEmpty( &pDevThread->TimedOut_CDBLink  ))
    {

        pCdbList = &pDevThread->TimedOut_CDBLink;
        pCdbList = pCdbList->flink;

        while((&pDevThread->TimedOut_CDBLink) != pCdbList)
        {
            pCDBThread = hpObjectBase(CDBThread_t,
                                      CDBLink,pCdbList );

            pCdbList = pCdbList->flink;

            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                            "CFuncCompleteActiveCDBThreadsOnDevice",(char *)agNULL,
                            pDevThread,pCDBThread,
                            event_to_send,
                            pCDBThread->thread_hdr.currentState,
                            pCDBThread->TimeStamp,
                            0,0,0,0,0);

            pCDBThread->CompletionStatus =  CompletionStatus;

            fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
        }
    }

    if (fiListNotEmpty( &pDevThread->Send_IO_CDBLink  ))
    {

        pCdbList = &pDevThread->Send_IO_CDBLink;
        pCdbList = pCdbList->flink;

        while((&pDevThread->Send_IO_CDBLink) != pCdbList)
        {
            pCDBThread = hpObjectBase(CDBThread_t,
                                      CDBLink,pCdbList );

            pCdbList = pCdbList->flink;

            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s Device %p Sending Event (%d) CDBthread %p State %d @ %d",
                            "CFuncCompleteActiveCDBThreadsOnDevice",(char *)agNULL,
                            pDevThread,pCDBThread,
                            event_to_send,
                            pCDBThread->thread_hdr.currentState,
                            pCDBThread->TimeStamp,
                            0,0,0,0,0);

            pCDBThread->CompletionStatus =  CompletionStatus;

            fiSendEvent(&pCDBThread->thread_hdr,event_to_send);
        }
    }

    if(pCThread->CDBpollingCount)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Ccnt Non Zero Ccnt %x",
                    "CFuncCompleteActiveCDBThreadsOnDevice",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->CDBpollingCount,
                    0,0,0,0,0,0,0);
    }

}

agBOOLEAN CFuncCheckForDuplicateDevThread( agRoot_t     *hpRoot)
{
    FC_Port_ID_t  Port_ID;
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread  = (DevThread_t *)agNULL;
    fiList_t      * pList;

/*
    CFuncShowDevThreadActive( hpRoot);
*/
    if(  fiListNotEmpty(&pCThread->Active_DevLink ) )
    {

        pList = &pCThread->Active_DevLink;
        pList = pList->flink;
        while((&pCThread->Active_DevLink) != pList)
        {
            pDevThread = hpObjectBase(DevThread_t, DevLink,pList );
            pList = pList->flink;

            Port_ID.Struct_Form.Domain = pDevThread->DevInfo.CurrentAddress.Domain;
            Port_ID.Struct_Form.Area   = pDevThread->DevInfo.CurrentAddress.Area;
            Port_ID.Struct_Form.AL_PA  = pDevThread->DevInfo.CurrentAddress.AL_PA;

            if( ! CFuncCheckIfPortActive(hpRoot, Port_ID))
            {
                fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "Called %s %s Device NOT Found D %x A %x ALPA %x != D %x A %x ALPA %x",
                        "CFuncCheckIfDevThreadActive","FAILED",
                        pDevThread,agNULL,
                        Port_ID.Struct_Form.Domain,
                        Port_ID.Struct_Form.Area,
                        Port_ID.Struct_Form.AL_PA,
                        pDevThread->DevInfo.CurrentAddress.Domain,
                        pDevThread->DevInfo.CurrentAddress.Area,
                        pDevThread->DevInfo.CurrentAddress.AL_PA,
                        0,0);

            }
        }
    }
    return(agFALSE);
}


agBOOLEAN CFuncCheckIfPortActive( agRoot_t     *hpRoot, FC_Port_ID_t  Port_ID)
{ /* Searches Active_DevLink if Port_ID found returns agTRUE */
    CThread_t     * pCThread        = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread      = (DevThread_t *)agNULL;
    DevThread_t   * pDevThreadFound[3];

    fiList_t      * pList;
    os_bit32        Num_Devices = 0;

    pDevThreadFound[0] = (DevThread_t *)agNULL;
    pDevThreadFound[1] = (DevThread_t *)agNULL;
    pDevThreadFound[2] = (DevThread_t *)agNULL;

    if(  fiListNotEmpty(&pCThread->Active_DevLink ) )
    {
        pList = &pCThread->Active_DevLink;
        pList = pList->flink;
        while((&pCThread->Active_DevLink) != pList)
        {
            pDevThread = hpObjectBase(DevThread_t, DevLink,pList );
            pList = pList->flink;

            if(pDevThread->DevInfo.CurrentAddress.Domain != Port_ID.Struct_Form.Domain )
            {
                continue;
            }
            if(pDevThread->DevInfo.CurrentAddress.Area   != Port_ID.Struct_Form.Area)
            {
                continue;
            }
            if(pDevThread->DevInfo.CurrentAddress.AL_PA  != Port_ID.Struct_Form.AL_PA)
            {
                continue;
            }

            pDevThreadFound[Num_Devices] = pDevThread;

            if(Num_Devices++ > 3)Num_Devices=0;
/*
            fiLogString(hpRoot,
                    "%s %d %s %p Domain %x Area %x AL_PA %x",
                    "CFuncCheckIfDevThreadActive","Found",
                    pDevThread,agNULL,
                    Num_Devices,
                    Port_ID.Struct_Form.Domain,
                    Port_ID.Struct_Form.Area,
                    Port_ID.Struct_Form.AL_PA,
                    0,0,0,0);
*/
        }
    }
    else
    {
/*
        fiLogString(hpRoot,
                "%s %d %s D %x A %x ALPA %x",
                "CFuncCheckIfDevThreadActive","fiListNotEmpty(&pCThread->Active_DevLink )",
                ,agNULL,agNULL,
                Num_Devices,
                Port_ID.Struct_Form.Domain,
                Port_ID.Struct_Form.Area,
                Port_ID.Struct_Form.AL_PA,
                0,0,0,0);
*/
    }


    if(Num_Devices > 1 )
    {
        fiLogString(hpRoot,
                "%s %d %s Found %p Dup %p Domain %x Area %x AL_PA %x",
                "CFuncCheckIfDevThreadActive","Duplicates",
                pDevThreadFound[0],
                pDevThreadFound[1],
                Num_Devices,
                Port_ID.Struct_Form.Domain,
                Port_ID.Struct_Form.Area,
                Port_ID.Struct_Form.AL_PA,
                0,0,0,0);
    }

    if( Num_Devices != 0  )
    {
        return(agTRUE);
    }
    else
    {
/*
        fiLogString(hpRoot,
                "%s %d %s %p Domain %x Area %x AL_PA %x",
                "CFuncCheckIfDevThreadActive","NOT Found",
                pDevThread,agNULL,
                Num_Devices,
                Port_ID.Struct_Form.Domain,
                Port_ID.Struct_Form.Area,
                Port_ID.Struct_Form.AL_PA,
                0,0,0,0);
*/
        return(agFALSE);
    }
}

agBOOLEAN CFuncCheckIfPortPrev_Active( agRoot_t     *hpRoot, FC_Port_ID_t  Port_ID)
{ /* Searches Prev_Active_DevLink if Port_ID found returns agTRUE */
    CThread_t     * pCThread        = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread      = (DevThread_t *)agNULL;
    DevThread_t   * pDevThreadFound[3];

    fiList_t      * pList;
    os_bit32        Num_Devices = 0;

    pDevThreadFound[0] = (DevThread_t *)agNULL;
    pDevThreadFound[1] = (DevThread_t *)agNULL;
    pDevThreadFound[2] = (DevThread_t *)agNULL;

    if(  fiListNotEmpty(&pCThread->Prev_Active_DevLink) )
    {
        pList = &pCThread->Prev_Active_DevLink;
        pList = pList->flink;
        while((&pCThread->Prev_Active_DevLink) != pList)
        {
            pDevThread = hpObjectBase(DevThread_t, DevLink,pList );
            pList = pList->flink;

            if(pDevThread->DevInfo.CurrentAddress.Domain != Port_ID.Struct_Form.Domain )
            {
                continue;
            }
            if(pDevThread->DevInfo.CurrentAddress.Area   != Port_ID.Struct_Form.Area)
            {
                continue;
            }
            if(pDevThread->DevInfo.CurrentAddress.AL_PA  != Port_ID.Struct_Form.AL_PA)
            {
                continue;
            }

            pDevThreadFound[Num_Devices] = pDevThread;

            if(Num_Devices++ > 3)Num_Devices=0;
/*
            fiLogString(hpRoot,
                    "%s %d %s %p Domain %x Area %x AL_PA %x",
                    "CFuncCheckIfDevThreadPrevActive","Found",
                    pDevThread,agNULL,
                    Num_Devices,
                    Port_ID.Struct_Form.Domain,
                    Port_ID.Struct_Form.Area,
                    Port_ID.Struct_Form.AL_PA,
                    0,0,0,0);
*/
        }
    }
    else
    {
/*
        fiLogString(hpRoot,
                "%s %d %s D %x A %x ALPA %x",
                "CFuncCheckIfDevThreadPrevActive","fiListNotEmpty(&pCThread->Prev_Active_DevLink )",
                ,agNULL,agNULL,
                Num_Devices,
                Port_ID.Struct_Form.Domain,
                Port_ID.Struct_Form.Area,
                Port_ID.Struct_Form.AL_PA,
                0,0,0,0);
*/
    }


    if(Num_Devices > 1 )
    {
        fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "%s %d %s Found %p Dup %p Domain %x Area %x AL_PA %x",
                    "CFuncCheckIfDevThreadPrevActive","Duplicates",
                    pDevThreadFound[0],
                    pDevThreadFound[1],
                    Num_Devices,
                    Port_ID.Struct_Form.Domain,
                    Port_ID.Struct_Form.Area,
                    Port_ID.Struct_Form.AL_PA,
                    0,0,0,0);
    }

    if( Num_Devices != 0  )
    {
        return(agTRUE);
    }
    else
    {
/*
        fiLogString(hpRoot,
                "%s %d %s %p Domain %x Area %x AL_PA %x",
                "CFuncCheckIfDevThreadPrevActive","NOT Found",
                pDevThread,agNULL,
                Num_Devices,
                Port_ID.Struct_Form.Domain,
                Port_ID.Struct_Form.Area,
                Port_ID.Struct_Form.AL_PA,
                0,0,0,0);
*/
        return(agFALSE);
    }
}

void CFuncShowDevThreadActive( agRoot_t     *hpRoot)
{ /* Searches Active_DevLink if Port_ID found returns agTRUE */
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread  = (DevThread_t *)agNULL;
    fiList_t      * pList;

    if(  fiListNotEmpty(&pCThread->Active_DevLink ) )
    {

        pList = &pCThread->Active_DevLink;
        pList = pList->flink;
        while((&pCThread->Active_DevLink) != pList)
        {
            pDevThread = hpObjectBase(DevThread_t, DevLink,pList );
            pList = pList->flink;
            fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s Found %p Domain %x Area %x AL_PA %x",
                        "CFuncShowDevThreadActive",(char *)agNULL,
                        pDevThread,agNULL,
                        pDevThread->DevInfo.CurrentAddress.Domain,
                        pDevThread->DevInfo.CurrentAddress.Area,
                        pDevThread->DevInfo.CurrentAddress.AL_PA,
                        0,0,0,0,0);

        }
    }

}


agBOOLEAN CFuncShowWhereDevThreadsAre( agRoot_t * hpRoot)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);

    os_bit32           Active_DevLink_Count             = 0;
    os_bit32           Unknown_Slot_DevLink_Count       = 0;
    os_bit32           AWaiting_Login_DevLink_Count     = 0;
    os_bit32           AWaiting_ADISC_DevLink_Count     = 0;
    os_bit32           Slot_Searching_DevLink_Count     = 0;
    os_bit32           Prev_Active_DevLink_Count        = 0;
    os_bit32           Prev_Unknown_Slot_DevLink_Count  = 0;
    os_bit32           DevSelf_NameServer_DevLink_Count = 0;
    os_bit32           Free_DevLink_Count               = 0;

    Active_DevLink_Count                = fiNumElementsOnList(&pCThread->Active_DevLink);
    Unknown_Slot_DevLink_Count          = fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink);
    AWaiting_Login_DevLink_Count        = fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink);
    AWaiting_ADISC_DevLink_Count        = fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink);
    Slot_Searching_DevLink_Count        = fiNumElementsOnList(&pCThread->Slot_Searching_DevLink);
    Prev_Active_DevLink_Count           = fiNumElementsOnList(&pCThread->Prev_Active_DevLink);
    Prev_Unknown_Slot_DevLink_Count     = fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink);
    DevSelf_NameServer_DevLink_Count    = fiNumElementsOnList(&pCThread->DevSelf_NameServer_DevLink);
    Free_DevLink_Count                  = fiNumElementsOnList(&pCThread->Free_DevLink);


    if( pCThread->Calculation.MemoryLayout.DevThread.elements !=
        Active_DevLink_Count             +
        Unknown_Slot_DevLink_Count       +
        AWaiting_Login_DevLink_Count     +
        AWaiting_ADISC_DevLink_Count     +
        Slot_Searching_DevLink_Count     +
        Prev_Active_DevLink_Count        +
        Prev_Unknown_Slot_DevLink_Count  +
        DevSelf_NameServer_DevLink_Count +
        Free_DevLink_Count
      )
    {
            fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "Total Count Should be %d is %d",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->Calculation.MemoryLayout.DevThread.elements,
                        Active_DevLink_Count             +
                        Unknown_Slot_DevLink_Count       +
                        Slot_Searching_DevLink_Count     +
                        Prev_Active_DevLink_Count        +
                        Prev_Unknown_Slot_DevLink_Count  +
                        Free_DevLink_Count               +
                        DevSelf_NameServer_DevLink_Count +
                        AWaiting_Login_DevLink_Count     +
                        AWaiting_ADISC_DevLink_Count,
                        0,0,0,0,0,0);

            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s Count %d",
                            "Active_DevLink",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            Active_DevLink_Count,
                            0,0,0,0,0,0,0
                            );
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s Count %d",
                            "Unknown_Slot_DevLink",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            Unknown_Slot_DevLink_Count,
                            0,0,0,0,0,0,0
                            );
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s Count %d",
                            "Slot_Searching_DevLink",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            Slot_Searching_DevLink_Count,
                            0,0,0,0,0,0,0
                            );
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s Count %d",
                            "Prev_Active_DevLink",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            Prev_Active_DevLink_Count,
                            0,0,0,0,0,0,0
                            );
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s Count %d",
                            "Prev_Unknown_Slot_DevLink",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            Prev_Unknown_Slot_DevLink_Count,
                            0,0,0,0,0,0,0
                            );
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s Count %d",
                            "Free_DevLink",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            Free_DevLink_Count,
                            0,0,0,0,0,0,0
                            );
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s Count %d",
                            "DevSelf_NameServer_DevLink",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            DevSelf_NameServer_DevLink_Count,
                            0,0,0,0,0,0,0
                            );

            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s Count %d",
                            "AWaiting_Login_DevLink",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            AWaiting_Login_DevLink_Count,
                            0,0,0,0,0,0,0
                            );
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s Count %d",
                            "AWaiting_ADISC_DevLink",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            AWaiting_ADISC_DevLink_Count,
                            0,0,0,0,0,0,0
                            );

        return agTRUE;
    }
    return agFALSE;

}

agBOOLEAN CFuncQuietShowWhereDevThreadsAre( agRoot_t * hpRoot)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);

    os_bit32           Active_DevLink_Count             = 0;
    os_bit32           Unknown_Slot_DevLink_Count       = 0;
    os_bit32           AWaiting_Login_DevLink_Count     = 0;
    os_bit32           AWaiting_ADISC_DevLink_Count     = 0;
    os_bit32           Slot_Searching_DevLink_Count     = 0;
    os_bit32           Prev_Active_DevLink_Count        = 0;
    os_bit32           Prev_Unknown_Slot_DevLink_Count  = 0;
    os_bit32           DevSelf_NameServer_DevLink_Count = 0;
    os_bit32           Free_DevLink_Count               = 0;

    Active_DevLink_Count                = fiNumElementsOnList(&pCThread->Active_DevLink);
    Unknown_Slot_DevLink_Count          = fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink);
    AWaiting_Login_DevLink_Count        = fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink);
    AWaiting_ADISC_DevLink_Count        = fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink);
    Slot_Searching_DevLink_Count        = fiNumElementsOnList(&pCThread->Slot_Searching_DevLink);
    Prev_Active_DevLink_Count           = fiNumElementsOnList(&pCThread->Prev_Active_DevLink);
    Prev_Unknown_Slot_DevLink_Count     = fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink);
    DevSelf_NameServer_DevLink_Count    = fiNumElementsOnList(&pCThread->DevSelf_NameServer_DevLink);
    Free_DevLink_Count                  = fiNumElementsOnList(&pCThread->Free_DevLink);


    if( pCThread->Calculation.MemoryLayout.DevThread.elements !=
        Active_DevLink_Count             +
        Unknown_Slot_DevLink_Count       +
        AWaiting_Login_DevLink_Count     +
        AWaiting_ADISC_DevLink_Count     +
        Slot_Searching_DevLink_Count     +
        Prev_Active_DevLink_Count        +
        Prev_Unknown_Slot_DevLink_Count  +
        DevSelf_NameServer_DevLink_Count +
        Free_DevLink_Count
      )
    {
        return agTRUE;
    }
    return agFALSE;

}

os_bit32 CFuncCountFC4_Devices( agRoot_t * hpRoot )
{
    CThread_t     * pCThread      = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread;
    os_bit32        Num_FC4_Devices = 0;
    fiList_t      * pDevList;

    pDevList = &pCThread->Active_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->Active_DevLink) != pDevList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );

        pDevList = pDevList->flink;
        if( pDevThread->DevInfo.DeviceType & agDevSCSITarget)
        {
            Num_FC4_Devices++;
        }

    }
return( Num_FC4_Devices );
}

void CFuncWhatStateAreDevThreads(agRoot_t   *    hpRoot )
{

    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *DevThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.DevThread);
    DevThread_t                *DevThread                  = DevThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;
    os_bit32                    DevThread_size             = DevThread_MemoryDescriptor->elementSize;
    os_bit32                    total_DevThreads           = DevThread_MemoryDescriptor->elements;
    os_bit32                    DevThread_index;


    for (DevThread_index = 0;
         DevThread_index < total_DevThreads;
         DevThread_index++)
    {

        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "DevThread %p State %d EL %3d  Cnt %d",
                (char *)agNULL,(char *)agNULL,
                DevThread,agNULL,
                DevThread->thread_hdr.currentState,
                fiNumElementsOnList(&DevThread->DevLink),
                DevThread_index,
                0,0,0,0,0);

        DevThread = (DevThread_t *)((os_bit8 *)DevThread + DevThread_size);
    }

}

agBOOLEAN CFuncShowWhereSFThreadsAre( agRoot_t * hpRoot)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    os_bit32        Free_SFLink_Count;

    Free_SFLink_Count                = fiNumElementsOnList(&pCThread->Free_SFLink);

    if( pCThread->Calculation.MemoryLayout.SFThread.elements != Free_SFLink_Count)
    {
        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s %s Count %d",
                        "CFuncShowWhereSFThreadsAre","Free_SFLink",
                        (void *)agNULL,(void *)agNULL,
                        Free_SFLink_Count,
                        0,0,0,0,0,0,0
                        );
        return agTRUE;
    }
    return agFALSE;

}

void CFuncWhatStateAreSFThreads(agRoot_t   *    hpRoot )
{

    CThread_t                  * CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t * SFThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.SFThread);
    SFThread_t                 * SFThread                  = SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;
    os_bit32                     SFThread_size             = SFThread_MemoryDescriptor->elementSize;
    os_bit32                     total_SFThreads           = SFThread_MemoryDescriptor->elements;
    os_bit32                     SFThread_index;


    for (SFThread_index = 0;
         SFThread_index < total_SFThreads;
         SFThread_index++)
    {
        if( SFThread->thread_hdr.currentState != SFStateFree || fiNumElementsOnList(&SFThread->SFLink) > total_SFThreads )
        {
            fiLogDebugString(hpRoot,
                       FCMainLogErrorLevel,
                       "%s SFThread %p State %d EL %3d  Cnt %d",
                       "CFuncWhatStateAreSFThreads",(char *)agNULL,
                       SFThread,agNULL,
                       SFThread->thread_hdr.currentState,
                       fiNumElementsOnList(&SFThread->SFLink),
                       SFThread_index,
                       0,0,0,0,0);

        }
        SFThread = (SFThread_t *)((os_bit8 *)SFThread + SFThread_size);
    }

}


void CFuncWhatStateAreCDBThreads(agRoot_t   *    hpRoot )
{

    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *CDBThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.CDBThread);
    CDBThread_t                *CDBThread                  = CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr;
    os_bit32                    CDBThread_size             = CDBThread_MemoryDescriptor->elementSize;
    os_bit32                    total_CDBThreads           = CDBThread_MemoryDescriptor->elements;
    os_bit32                    CDBThread_index;

    for (CDBThread_index = 0;
         CDBThread_index < total_CDBThreads;
         CDBThread_index++)
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "CDBThread %p State %d EL %3d Index %X X_ID %3X",
                (char *)agNULL,(char *)agNULL,
                CDBThread,agNULL,
                CDBThread->thread_hdr.currentState,
                fiNumElementsOnList(&CDBThread->CDBLink),
                CDBThread_index,
                CDBThread->X_ID,
                0,0,0,0);

        CDBThread = (CDBThread_t *)((os_bit8 *)CDBThread + CDBThread_size);
    }

}



agBOOLEAN CFuncShowWhereTgtThreadsAre( agRoot_t * hpRoot)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    os_bit32           Free_TgtLink_Count;

    Free_TgtLink_Count                = fiNumElementsOnList(&pCThread->Free_TgtLink);

    if( pCThread->Calculation.MemoryLayout.TgtThread.elements != Free_TgtLink_Count)
    {
        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s Count %d",
                        "Free_TgtLink",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Free_TgtLink_Count,
                        0,0,0,0,0,0,0
                        );
        return agTRUE;
    }
    return agFALSE;

}



agBOOLEAN CFuncShowWhereCDBThreadsAre( agRoot_t * hpRoot)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * DevThread;
    fiList_t      * pDevList;

    os_bit32           Free_CDBLink_Count    =0;
    os_bit32           Initial_Free_CDBLink_Count    =0;

    os_bit32           Awaiting_Login_CDBLink_Count    =0;

    os_bit32           Send_IO_CDBLink_Count   =0;
    os_bit32           Active_CDBLink_0_Count  =0;
    os_bit32           Active_CDBLink_1_Count  =0;
    os_bit32           Active_CDBLink_2_Count  =0;
    os_bit32           Active_CDBLink_3_Count  =0;
    os_bit32           TimedOut_CDBLink_Count  =0;

    Initial_Free_CDBLink_Count                = fiNumElementsOnList(&pCThread->Free_CDBLink);

    pDevList = &pCThread->Active_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->Active_DevLink) != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );
        if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
        {
            Send_IO_CDBLink_Count   += fiNumElementsOnList(&DevThread->Send_IO_CDBLink);
        }

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            TimedOut_CDBLink_Count  += fiNumElementsOnList(&DevThread->TimedOut_CDBLink);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            Active_CDBLink_3_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_3);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            Active_CDBLink_2_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_2);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
            Active_CDBLink_1_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_1);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
            Active_CDBLink_0_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_0);
        }

        if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
        {
            Awaiting_Login_CDBLink_Count += fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink);
        }
        pDevList = pDevList->flink;
    }

    pDevList = &pCThread->AWaiting_Login_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->AWaiting_Login_DevLink) != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );
        if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
        {
            Send_IO_CDBLink_Count   += fiNumElementsOnList(&DevThread->Send_IO_CDBLink);
        }

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            TimedOut_CDBLink_Count  += fiNumElementsOnList(&DevThread->TimedOut_CDBLink);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            Active_CDBLink_3_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_3);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            Active_CDBLink_2_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_2);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
            Active_CDBLink_1_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_1);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
            Active_CDBLink_0_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_0);
        }

        if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
        {
            Awaiting_Login_CDBLink_Count += fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink);
        }
        pDevList = pDevList->flink;
    }

    pDevList = &pCThread->AWaiting_ADISC_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->AWaiting_ADISC_DevLink) != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );
        if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
        {
            Send_IO_CDBLink_Count   += fiNumElementsOnList(&DevThread->Send_IO_CDBLink);
        }

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            TimedOut_CDBLink_Count  += fiNumElementsOnList(&DevThread->TimedOut_CDBLink);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            Active_CDBLink_3_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_3);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            Active_CDBLink_2_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_2);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
            Active_CDBLink_1_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_1);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
            Active_CDBLink_0_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_0);
        }

        if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
        {
            Awaiting_Login_CDBLink_Count += fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink);
        }
        pDevList = pDevList->flink;
    }

    pDevList = &pCThread->Prev_Active_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->Prev_Active_DevLink) != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );
        if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
        {
            Send_IO_CDBLink_Count   += fiNumElementsOnList(&DevThread->Send_IO_CDBLink);
        }

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            TimedOut_CDBLink_Count  += fiNumElementsOnList(&DevThread->TimedOut_CDBLink);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            Active_CDBLink_3_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_3);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            Active_CDBLink_2_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_2);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
            Active_CDBLink_1_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_1);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
            Active_CDBLink_0_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_0);
        }

        if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
        {
            Awaiting_Login_CDBLink_Count += fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink);
        }
        pDevList = pDevList->flink;
    }

    pDevList = &pCThread->Unknown_Slot_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->Unknown_Slot_DevLink) != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );
        if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
        {
            Send_IO_CDBLink_Count   += fiNumElementsOnList(&DevThread->Send_IO_CDBLink);
        }

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            TimedOut_CDBLink_Count  += fiNumElementsOnList(&DevThread->TimedOut_CDBLink);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            Active_CDBLink_3_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_3);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            Active_CDBLink_2_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_2);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
            Active_CDBLink_1_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_1);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
            Active_CDBLink_0_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_0);
        }

        if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
        {
            Awaiting_Login_CDBLink_Count += fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink);
        }
        pDevList = pDevList->flink;
    }

    pDevList = &pCThread->Slot_Searching_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->Slot_Searching_DevLink) != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );
        if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
        {
            Send_IO_CDBLink_Count   += fiNumElementsOnList(&DevThread->Send_IO_CDBLink);
        }

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            TimedOut_CDBLink_Count  += fiNumElementsOnList(&DevThread->TimedOut_CDBLink);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            Active_CDBLink_3_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_3);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            Active_CDBLink_2_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_2);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
            Active_CDBLink_1_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_1);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
            Active_CDBLink_0_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_0);
        }

        if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
        {
            Awaiting_Login_CDBLink_Count += fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink);
        }
        pDevList = pDevList->flink;
    }
    pDevList = &pCThread->Prev_Unknown_Slot_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->Prev_Unknown_Slot_DevLink) != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );
        if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
        {
            Send_IO_CDBLink_Count   += fiNumElementsOnList(&DevThread->Send_IO_CDBLink);
        }

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            TimedOut_CDBLink_Count  += fiNumElementsOnList(&DevThread->TimedOut_CDBLink);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            Active_CDBLink_3_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_3);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            Active_CDBLink_2_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_2);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
            Active_CDBLink_1_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_1);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
            Active_CDBLink_0_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_0);
        }

        if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
        {
            Awaiting_Login_CDBLink_Count += fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink);
        }
        pDevList = pDevList->flink;
    }
    pDevList = &pCThread->DevSelf_NameServer_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->DevSelf_NameServer_DevLink) != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );
        if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
        {
            Send_IO_CDBLink_Count   += fiNumElementsOnList(&DevThread->Send_IO_CDBLink);
        }

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            TimedOut_CDBLink_Count  += fiNumElementsOnList(&DevThread->TimedOut_CDBLink);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            Active_CDBLink_3_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_3);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            Active_CDBLink_2_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_2);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
            Active_CDBLink_1_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_1);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
            Active_CDBLink_0_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_0);
        }

        if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
        {
            Awaiting_Login_CDBLink_Count += fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink);
        }
        pDevList = pDevList->flink;
    }
    pDevList = &pCThread->RSCN_Recieved_NameServer_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->RSCN_Recieved_NameServer_DevLink) != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );
        if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
        {
            Send_IO_CDBLink_Count   += fiNumElementsOnList(&DevThread->Send_IO_CDBLink);
        }

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            TimedOut_CDBLink_Count  += fiNumElementsOnList(&DevThread->TimedOut_CDBLink);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            Active_CDBLink_3_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_3);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            Active_CDBLink_2_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_2);
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
            Active_CDBLink_1_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_1);
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
            Active_CDBLink_0_Count  += fiNumElementsOnList(&DevThread->Active_CDBLink_0);
        }

        if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
        {
            Awaiting_Login_CDBLink_Count += fiNumElementsOnList(&DevThread->Awaiting_Login_CDBLink);
        }
        pDevList = pDevList->flink;
    }

    Free_CDBLink_Count                = fiNumElementsOnList(&pCThread->Free_CDBLink);

    if( Initial_Free_CDBLink_Count != Free_CDBLink_Count)
    {
        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s Count Free count WRONG was %d IS now %d",
                        "CDBThread",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Initial_Free_CDBLink_Count,
                        Free_CDBLink_Count,
                        0,0,0,0,0,0 );
    }

    if( pCThread->Calculation.MemoryLayout.CDBThread.elements !=
            Free_CDBLink_Count +
            Send_IO_CDBLink_Count +
            Active_CDBLink_0_Count +
            Active_CDBLink_1_Count +
            Active_CDBLink_2_Count +
            Active_CDBLink_3_Count +
            Awaiting_Login_CDBLink_Count +
            TimedOut_CDBLink_Count          )
    {
        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s Count WRONG Should be %d IS %d",
                        "CDBThread",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->Calculation.MemoryLayout.CDBThread.elements,
                        Free_CDBLink_Count +
                        Send_IO_CDBLink_Count +
                        Active_CDBLink_0_Count +
                        Active_CDBLink_1_Count +
                        Active_CDBLink_2_Count +
                        Active_CDBLink_3_Count +
                        Awaiting_Login_CDBLink_Count +
                        TimedOut_CDBLink_Count,
                        0,0,0,0,0,0
                        );

         fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "Free %x Send %x A0 %x A1 %x A2 %x A3 %x A login %x TO %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Free_CDBLink_Count,
                        Send_IO_CDBLink_Count,
                        Active_CDBLink_0_Count,
                        Active_CDBLink_1_Count,
                        Active_CDBLink_2_Count,
                        Active_CDBLink_3_Count,
                        Awaiting_Login_CDBLink_Count,
                        TimedOut_CDBLink_Count );

         fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "Free %x Active %x Un %x Login %x ADISC %x SS %x PrevA login %x Prev Un %x",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&pCThread->Free_DevLink),
                        fiNumElementsOnList(&pCThread->Active_DevLink),
                        fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
                        fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                        fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
                        fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
                        fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
                        fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink) );



        return agTRUE;
    }
    return agFALSE;

}

/*+
  Function: CFuncCheckForTimeouts
   Purpose: Moves IO lists from ealier (start ) queues to later queues
            once an IO gets to TimedOut_CDBLink it is checked for timeouts
   Returns: Directly TimeOutDetected  Indirectly Sent_Abort if IO's were aborted
 Called By: 
     Calls: CFuncCheckActiveDuringLinkEvent
CFuncFC_Tape
fiListNotEmpty
fiListEnqueueListAtTailFast            
-*/
agBOOLEAN CFuncCheckForTimeouts(agRoot_t *hpRoot, fiList_t * pCheckDevList)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * DevThread;
    fiList_t      * pDevList;
    agBOOLEAN returnvalue = agFALSE;
    agBOOLEAN SentAbort = agFALSE;

    pDevList = pCheckDevList;
    pDevList = pDevList->flink;

    while(pCheckDevList != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );


        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {

            CFuncFC_Tape( hpRoot, &(DevThread->TimedOut_CDBLink) ,DevThread );
            returnvalue =  CFuncCheckActiveDuringLinkEvent( hpRoot, &(DevThread->TimedOut_CDBLink) ,&SentAbort,DevThread );

        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {

            CFuncFC_Tape( hpRoot, &(DevThread->Active_CDBLink_3),DevThread  );

            fiListEnqueueListAtTailFast( &(DevThread->Active_CDBLink_3), &(DevThread->TimedOut_CDBLink));
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {

/*
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s %s Not Empty ! ALPA %X Ccnt %x Dcnt %x EL %x",
                            "CFCFT","Active_CDBLink_2",
                            (void *)agNULL,(void *)agNULL,
                            DevThread->DevInfo.CurrentAddress.AL_PA,
                            pCThread->CDBpollingCount,
                            DevThread->pollingCount,
                            fiNumElementsOnList(&(DevThread->Active_CDBLink_2)),
                            0,0,0,0 );
*/
            CFuncFC_Tape( hpRoot, &(DevThread->Active_CDBLink_2) ,DevThread );
            fiListEnqueueListAtTailFast( &(DevThread->Active_CDBLink_2), &(DevThread->Active_CDBLink_3))
        }

        if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
        {
/*
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s %s Not Empty ! ALPA %X Ccnt %x Dcnt %x EL %x",
                            "CFCFT","Active_CDBLink_1",
                            (void *)agNULL,(void *)agNULL,
                            DevThread->DevInfo.CurrentAddress.AL_PA,
                            pCThread->CDBpollingCount,
                            DevThread->pollingCount,
                            fiNumElementsOnList(&(DevThread->Active_CDBLink_1)),
                            0,0,0,0 );
*/
            CFuncFC_Tape( hpRoot, &(DevThread->Active_CDBLink_1) ,DevThread );

            fiListEnqueueListAtTailFast( &(DevThread->Active_CDBLink_1), &(DevThread->Active_CDBLink_2));
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
        {
/*
            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s %s Not Empty ! ALPA %X Ccnt %x Dcnt %x EL %x",
                            "CFCFT","Active_CDBLink_0",
                            (void *)agNULL,(void *)agNULL,
                            DevThread->DevInfo.CurrentAddress.AL_PA,
                            pCThread->CDBpollingCount,
                            DevThread->pollingCount,
                            fiNumElementsOnList(&(DevThread->Active_CDBLink_0)),
                            0,0,0,0 );
*/
            fiListEnqueueListAtTailFast( &(DevThread->Active_CDBLink_0), &(DevThread->Active_CDBLink_1));
        }

        if(fiListNotEmpty(&(DevThread->Send_IO_CDBLink)))
        {

            fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s %s Not Empty ! ALPA %X Ccnt %x Dcnt %x EL %x",
                            "CFCFT","Send_IO_CDBLink",
                            (void *)agNULL,(void *)agNULL,
                            DevThread->DevInfo.CurrentAddress.AL_PA,
                            pCThread->CDBpollingCount,
                            DevThread->pollingCount,
                            fiNumElementsOnList(&(DevThread->Send_IO_CDBLink)),
                            0,0,0,0 );

            fiSendEvent( &(DevThread->thread_hdr), DevEventSendIO );
        }

        pDevList = pDevList->flink;
    }
/*
    CFuncShowWhereDevThreadsAre(hpRoot);
    CFuncShowWhereTgtThreadsAre(hpRoot);

    if( CFuncShowWhereSFThreadsAre(hpRoot))
    {
        CFuncWhatStateAreSFThreads(hpRoot);
    }
*/

    if(SentAbort)
    {
        fiLogString(hpRoot,
                        "%s %s agTRUE !",
                        "CFCFT","SentAbort",
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s %s agTRUE !",
                        "CFCFT","SentAbort",
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0 );
    }
    return( returnvalue);
}

/*+
  Function: CFuncCheckActiveDuringLinkEvent
   Purpose: Checks ActiveDuringLinkEvent flag for given list on given device
            Only passed TimedOut_CDBLink If link is not empty a timeout is detected
   Returns: Directly TimeOutDetected  Indirectly Sent_Abort if IO's were aborted
 Called By: CFuncCheckForTimeouts
     Calls: CDBEventAlloc_Abort
            CDBEvent_PrepareforAbort
-*/
agBOOLEAN CFuncCheckActiveDuringLinkEvent( agRoot_t * hpRoot, fiList_t * pShowList,  agBOOLEAN * Sent_Abort , DevThread_t * DevThread )
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    CDBThread_t   * pCDBThread;
    fiList_t      * pCdbList;
    agBOOLEAN TimeOutDetected = agFALSE;

    pCdbList = pShowList;
    pCdbList = pCdbList->flink;

    while((pShowList) != pCdbList)
    {
        pCDBThread = hpObjectBase(CDBThread_t,
                                  CDBLink,pCdbList );

        pCdbList = pCdbList->flink;

        if(pCDBThread->thread_hdr.threadType == threadType_CDBThread)
        {
            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s Dev %2X X_ID %3X State %d D %X Rd %d TAPE %x",
                            "CFCADLE",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            DevThread->DevInfo.CurrentAddress.AL_PA,
                            pCDBThread->X_ID,
                            pCDBThread->thread_hdr.currentState,
                            pCDBThread->CDBStartTimeBase.Lo - pCThread->LinkDownTime.Lo,
                            osTimeStamp(hpRoot) -  pCDBThread->TimeStamp,
                            DevThread->FC_TapeDevice,
                            0,0);

            TimeOutDetected = agTRUE;

            if( pCDBThread->ActiveDuringLinkEvent)
            {
               * Sent_Abort = agTRUE;
                pCDBThread->CompletionStatus = osIODevReset;
                fiSendEvent(&(pCDBThread->thread_hdr),CDBEvent_PrepareforAbort);
                if(! fiListElementOnList(  &(pCDBThread->CDBLink), &(pCThread->Free_CDBLink)))
                {
                    fiSendEvent(&(pCDBThread->thread_hdr),CDBEventAlloc_Abort);
                }
            }
            else
            {

                if(pCDBThread->CDBStartTimeBase.Hi == pCThread->LinkDownTime.Hi )
                {
                    if(pCDBThread->CDBStartTimeBase.Lo >= pCThread->LinkDownTime.Lo )
                    {
                        if(pCDBThread->CDBStartTimeBase.Lo - pCThread->LinkDownTime.Lo  < 11000000  )
                        {
                            * Sent_Abort = agTRUE;
                            pCDBThread->CompletionStatus = osIODevReset;
                            fiSendEvent(&(pCDBThread->thread_hdr),CDBEvent_PrepareforAbort);
                            if(! fiListElementOnList(  &(pCDBThread->CDBLink), &(pCThread->Free_CDBLink)))
                            {
                                fiSendEvent(&(pCDBThread->thread_hdr),CDBEventAlloc_Abort);
                            }
                        }
                    }
                }
                else
                {
                    fiLogDebugString(hpRoot,
                                    FCMainLogErrorLevel,
                                    "%s %s  ALPA %X Start %X Ldt %X EL %x",
                                    "CFCADLE","IO Taking long time",
                                    (void *)agNULL,(void *)agNULL,
                                    DevThread->DevInfo.CurrentAddress.AL_PA,
                                    pCDBThread->CDBStartTimeBase.Lo,
                                    pCThread->LinkDownTime.Lo,
                                    fiNumElementsOnList(&(DevThread->TimedOut_CDBLink)),
                                    0,0,0,0 );
                }
            }
        }
    }

return(TimeOutDetected);
}

void CFuncShowNonEmptyLists(agRoot_t *hpRoot, fiList_t * pCheckDevList)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * DevThread;
    fiList_t      * pDevList;

    pDevList = pCheckDevList;
    pDevList = pDevList->flink;

    while(pCheckDevList != pDevList)
    {
        DevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );

        if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
        {
            fiLogString(hpRoot,
                    "%s %s ! ALPA %X Ccnt %x Dcnt %x EL %x A %d",
                    "CFSNEL","TimedOut",
                    (void *)agNULL,(void *)agNULL,
                    DevThread->DevInfo.CurrentAddress.AL_PA,
                    pCThread->CDBpollingCount,
                    DevThread->pollingCount,
                    fiNumElementsOnList(&(DevThread->TimedOut_CDBLink)),
                    pCThread->IOsActive,0,0,0 );
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
        {
            fiLogString(hpRoot,
                    "%s %s ! ALPA %X Ccnt %x Dcnt %x EL %x A %d",
                    "CFSNEL","CDBLink_3",
                    (void *)agNULL,(void *)agNULL,
                    DevThread->DevInfo.CurrentAddress.AL_PA,
                    pCThread->CDBpollingCount,
                    DevThread->pollingCount,
                    fiNumElementsOnList(&(DevThread->Active_CDBLink_3)),
                    pCThread->IOsActive,0,0,0 );
        }
        if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
        {
            fiLogString(hpRoot,
                    "%s %s ! ALPA %X Ccnt %x Dcnt %x EL %x",
                    "CFSNEL","CDBLink_2",
                    (void *)agNULL,(void *)agNULL,
                    DevThread->DevInfo.CurrentAddress.AL_PA,
                    pCThread->CDBpollingCount,
                    DevThread->pollingCount,
                    fiNumElementsOnList(&(DevThread->Active_CDBLink_2)),
                    0,0,0,0 );
        }
        pDevList = pDevList->flink;
    }

}

void CFuncFC_Tape( agRoot_t * hpRoot, fiList_t * pShowList, DevThread_t * DevThread )
{

    CDBThread_t   * pCDBThread;
    fiList_t      * pCdbList;

    pCdbList = pShowList;
    pCdbList = pCdbList->flink;

    while(pShowList != pCdbList)
    {
        pCDBThread = hpObjectBase(CDBThread_t,
                                  CDBLink,pCdbList );

        pCdbList = pCdbList->flink;

        if(pCDBThread->thread_hdr.threadType == threadType_CDBThread)
        {
            if( DevThread->FC_TapeDevice)
            {
                fiLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "%s Dev %2X X_ID %3X State %d D %X Rd %d TAPE %x",
                                "CFuncFC_Tape",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                DevThread->DevInfo.CurrentAddress.AL_PA,
                                pCDBThread->X_ID,
                                pCDBThread->thread_hdr.currentState,
                                pCDBThread->CDBStartTimeBase.Lo - CThread_ptr(hpRoot)->LinkDownTime.Lo,
                                osTimeStamp(hpRoot) -  pCDBThread->TimeStamp,
                                DevThread->FC_TapeDevice,
                                0,0);

                if( DevThread->FC_TapeDevice)
                {
                    if( pCDBThread->thread_hdr.currentState != CDBStateThreadFree)
                    {
                        fiLogString(hpRoot,
                                    "CDBThread currentState %02X  CDB Class %2X Type %2X State %2X Status %2X",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    (os_bit32)pCDBThread->thread_hdr.currentState,
                                    (os_bit32)pCDBThread->CDB_CMND_Class,
                                    (os_bit32)pCDBThread->CDB_CMND_Type,
                                    (os_bit32)pCDBThread->CDB_CMND_State,
                                    (os_bit32)pCDBThread->CDB_CMND_Status,
                                    0,0,0);

                        fiSendEvent(&(pCDBThread->thread_hdr),CDBEventREC_TOV);
                    }
                    continue;
                }
            }
        }
    }
}


agBOOLEAN IS_WITHIN(os_bit32 post, os_bit32 window, os_bit32 value, os_bit32 MAX)
{
    agBOOLEAN return_value = agFALSE;

    if( value == post)
    {
        return_value = agTRUE;
    }
    else
    {
        if( value > MAX )
        {
            return_value = agFALSE;
        }

        if( value > post)
        {
            if(value > post + window)
            {
                if(value + window >= MAX )
                {
                    if(post <= ((value + window) - MAX ))
                    {
                        return_value = agTRUE;
                    }
                    else /* post less than value plus window */
                    {
                        return_value = agFALSE;
                    }
                }
                else
                {
                    return_value = agFALSE;
                }
            }
            else /* value less than post plus window */
            {
                return_value = agTRUE;
            }
        }
        else /*  value less than  post */
        {
            if(value < post - window)
            {
                if( post + window >= MAX)
                {
                    if( value <= ((post + window) - MAX))
                    {
                        return_value = agTRUE;
                    }
                    else
                    {
                        return_value = agFALSE;
                    }
                }
                else
                {
                    if(post - value < window )
                    {
                        return_value = agTRUE;
                    }
                    else
                    {
                        return_value = agFALSE;
                    }
                }
            }
        }
    }
return(return_value);
}


os_bit32 CFuncShowActiveCDBThreadsOnQ( agRoot_t * hpRoot, fiList_t * pShowList, os_bit32 ERQ, os_bit32 Mode )
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * DevThread;
    fiList_t      * pDevList;
    os_bit32 NumActiveCDBThreads = 0;

    CDBThread_t   * CDBThread;
    fiList_t      * pCDBList;
    os_bit32           PlusMinus = 2;
    os_bit32           SearchOffset = 1;
    os_bit32           Max_ERQ     = pCThread->Calculation.MemoryLayout.ERQ.elements - 1;

/* Positive search offset
    if( ERQ + SearchOffset >= Max_ERQ )
    {
        ERQ = (( ERQ + SearchOffset) - Max_ERQ );
    }
    else
    {
        ERQ += SearchOffset;
    }
Positive search offset */

/* Negative search offset */
    if( ERQ < SearchOffset )
    {
        ERQ = Max_ERQ - ( SearchOffset - ERQ );
    }
    else
    {
        ERQ -= SearchOffset;
    }
/* Negative search offset */

    if( fiNumElementsOnList(pShowList) > 0xFFE)
    {
        fiLogString(hpRoot,
                        "List corrupt !!!!!!",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "List corrupt !!!!!!",
                        (void *)agNULL,(void *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
        /*Arbitrary number */
        NumActiveCDBThreads = 10000;
    }
    else
    {
        if(fiListNotEmpty((pShowList) ))
        {
            pDevList = pShowList;
            pDevList = pDevList->flink;

            while( pShowList!= pDevList)
            {
                DevThread = hpObjectBase(DevThread_t,
                                      DevLink,pDevList );
                if(fiListNotEmpty( &(DevThread->Send_IO_CDBLink) ))
                {
                    pCDBList= &(DevThread->Send_IO_CDBLink);
                    pCDBList= pCDBList->flink;
                    while((&(DevThread->Send_IO_CDBLink)) != pCDBList)
                    {
                        CDBThread = hpObjectBase(CDBThread_t,
                                              CDBLink, pCDBList);
                        if(IS_WITHIN(ERQ, PlusMinus, CDBThread->SentERQ, Max_ERQ) || Mode == ShowERQ )
                        {
                            if(!DevThread->FC_TapeDevice )
                            {
                                CDBThread->ActiveDuringLinkEvent = agTRUE;
                            }
                        }
                        if( Mode ==  ShowActive )
                        {
                            fiLogDebugString(hpRoot,
                                        FCMainLogErrorLevel,
                                        "%s %s Area %X ALPA %X  X_ID %3X AdLe %x State %d D %d ERQ %X SERQ %X",
                                        "CFSACDBs","Send CDB",
                                        (void *)agNULL,(void *)agNULL,
                                        DevThread->DevInfo.CurrentAddress.Area,
                                        DevThread->DevInfo.CurrentAddress.AL_PA,
                                        CDBThread->X_ID,
                                        CDBThread->ActiveDuringLinkEvent,
                                        CDBThread->thread_hdr.currentState,
                                        osTimeStamp(hpRoot) - CDBThread->TimeStamp,
                                        CFunc_Get_ERQ_Entry( hpRoot, CDBThread->X_ID ),
                                        CDBThread->SentERQ);
                        }
                        NumActiveCDBThreads += 1;
                        pCDBList= pCDBList->flink;
                    }
                }

                if(fiListNotEmpty( &(DevThread->TimedOut_CDBLink) ))
                {
                    pCDBList= &(DevThread->TimedOut_CDBLink);
                    pCDBList= pCDBList->flink;
                    while((&(DevThread->TimedOut_CDBLink)) != pCDBList)
                    {
                        CDBThread = hpObjectBase(CDBThread_t,
                                              CDBLink, pCDBList);

                        if(IS_WITHIN(ERQ, PlusMinus, CDBThread->SentERQ, Max_ERQ) || Mode ==  ShowERQ)
                        {
                            if(!DevThread->FC_TapeDevice )
                            {
                                CDBThread->ActiveDuringLinkEvent = agTRUE;
                            }
                        }

                        if( Mode ==  ShowActive )
                        {
                            fiLogDebugString(hpRoot,
                                        FCMainLogErrorLevel,
                                        "%s %s Area %X ALPA %X  X_ID %3X AdLe %x State %d D %d ERQ %X SERQ %X",
                                        "CFSACDBs","TOCDB",
                                        (void *)agNULL,(void *)agNULL,
                                        DevThread->DevInfo.CurrentAddress.Area,
                                        DevThread->DevInfo.CurrentAddress.AL_PA,
                                        CDBThread->X_ID,
                                        CDBThread->ActiveDuringLinkEvent,
                                        CDBThread->thread_hdr.currentState,
                                        osTimeStamp(hpRoot) - CDBThread->TimeStamp,
                                        CFunc_Get_ERQ_Entry( hpRoot, CDBThread->X_ID ),
                                        CDBThread->SentERQ);
                        }
                        NumActiveCDBThreads += 1;
                        pCDBList= pCDBList->flink;
                    }
                }
                if(fiListNotEmpty(&(DevThread->Active_CDBLink_3)))
                {
                    pCDBList= &(DevThread->Active_CDBLink_3);
                    pCDBList= pCDBList->flink;
                    while((&(DevThread->Active_CDBLink_3)) != pCDBList)
                    {
                        CDBThread = hpObjectBase(CDBThread_t,
                                              CDBLink, pCDBList);
                        if(IS_WITHIN(ERQ, PlusMinus, CDBThread->SentERQ, Max_ERQ) || Mode == ShowERQ )
                        {
                            if(!DevThread->FC_TapeDevice )
                            {
                                CDBThread->ActiveDuringLinkEvent = agTRUE;
                            }
                        }
                        if( Mode ==  ShowActive)
                        {
                            fiLogDebugString(hpRoot,
                                    FCMainLogErrorLevel,
                                    "%s %s Area %X ALPA %X  X_ID %3X AdLe %x State %d D %d ERQ %X SERQ %X",
                                    "CFSACDBs","CDBLink_3",
                                    (void *)agNULL,(void *)agNULL,
                                    DevThread->DevInfo.CurrentAddress.Area,
                                    DevThread->DevInfo.CurrentAddress.AL_PA,
                                    CDBThread->X_ID,
                                    CDBThread->ActiveDuringLinkEvent,
                                    CDBThread->thread_hdr.currentState,
                                    osTimeStamp(hpRoot) - CDBThread->TimeStamp,
                                    CFunc_Get_ERQ_Entry( hpRoot, CDBThread->X_ID ),
                                    CDBThread->SentERQ);
                        }

                        NumActiveCDBThreads += 1;
                        pCDBList= pCDBList->flink;
                    }
                }

                if(fiListNotEmpty(&(DevThread->Active_CDBLink_2)))
                {
                    pCDBList= &(DevThread->Active_CDBLink_2);
                    pCDBList= pCDBList->flink;
                    while((&(DevThread->Active_CDBLink_2)) != pCDBList)
                    {
                        CDBThread = hpObjectBase(CDBThread_t,
                                              CDBLink, pCDBList);

                        if(IS_WITHIN(ERQ, PlusMinus, CDBThread->SentERQ, Max_ERQ) || Mode == ShowERQ  )
                        {
                            if(!DevThread->FC_TapeDevice )
                            {
                                CDBThread->ActiveDuringLinkEvent = agTRUE;
                            }
                        }

                        if( Mode ==  ShowActive)
                        {
                            fiLogDebugString(hpRoot,
                                        FCMainLogErrorLevel,
                                        "%s %s Area %X ALPA %X  X_ID %3X AdLe %x State %d D %d ERQ %X SERQ %X",
                                        "CFSACDBs","CDBLink_2",
                                        (void *)agNULL,(void *)agNULL,
                                        DevThread->DevInfo.CurrentAddress.Area,
                                        DevThread->DevInfo.CurrentAddress.AL_PA,
                                        CDBThread->X_ID,
                                        CDBThread->ActiveDuringLinkEvent,
                                        CDBThread->thread_hdr.currentState,
                                        osTimeStamp(hpRoot) - CDBThread->TimeStamp,
                                        CFunc_Get_ERQ_Entry( hpRoot, CDBThread->X_ID ),
                                        CDBThread->SentERQ);
                        }
                        NumActiveCDBThreads += 1;
                        pCDBList= pCDBList->flink;
                    }
                }

                if(fiListNotEmpty(&(DevThread->Active_CDBLink_1)))
                {
                    pCDBList= &(DevThread->Active_CDBLink_1);
                    pCDBList= pCDBList->flink;
                    while((&(DevThread->Active_CDBLink_1)) != pCDBList)
                    {
                        CDBThread = hpObjectBase(CDBThread_t,
                                              CDBLink, pCDBList);

                        if(IS_WITHIN(ERQ, PlusMinus, CDBThread->SentERQ, Max_ERQ) || Mode ==  ShowERQ)
                        {
                            if(!DevThread->FC_TapeDevice )
                            {
                                CDBThread->ActiveDuringLinkEvent = agTRUE;
                            }
                        }

                        if( Mode ==  ShowActive )
                        {
                            fiLogDebugString(hpRoot,
                                        FCMainLogErrorLevel,
                                        "%s %s Area %X ALPA %X  X_ID %3X AdLe %x State %d D %d ERQ %X SERQ %X",
                                        "CFSACDBs","CDBLink_1",
                                        (void *)agNULL,(void *)agNULL,
                                        DevThread->DevInfo.CurrentAddress.Area,
                                        DevThread->DevInfo.CurrentAddress.AL_PA,
                                        CDBThread->X_ID,
                                        CDBThread->ActiveDuringLinkEvent,
                                        CDBThread->thread_hdr.currentState,
                                        osTimeStamp(hpRoot) - CDBThread->TimeStamp,
                                        CFunc_Get_ERQ_Entry( hpRoot, CDBThread->X_ID ),
                                        CDBThread->SentERQ);
                        }

                        NumActiveCDBThreads += 1;
                        pCDBList= pCDBList->flink;
                    }
                }
                if(fiListNotEmpty(&(DevThread->Active_CDBLink_0)))
                {
                    pCDBList= &(DevThread->Active_CDBLink_0);
                    pCDBList= pCDBList->flink;
                    while((&(DevThread->Active_CDBLink_0)) != pCDBList)
                    {
                        CDBThread = hpObjectBase(CDBThread_t,
                                              CDBLink, pCDBList);

                        if(IS_WITHIN(ERQ, PlusMinus, CDBThread->SentERQ, Max_ERQ) || Mode ==  ShowERQ)
                        {
                            if(!DevThread->FC_TapeDevice )
                            {
                                CDBThread->ActiveDuringLinkEvent = agTRUE;
                            }
                        }

                        if( Mode ==  ShowActive )
                        {
                            fiLogDebugString(hpRoot,
                                        FCMainLogErrorLevel,
                                        "%s %s Area %X ALPA %X  X_ID %3X AdLe %x State %d D %d ERQ %X SERQ %X",
                                        "CFSACDBs","CDBLink_0",
                                        (void *)agNULL,(void *)agNULL,
                                        DevThread->DevInfo.CurrentAddress.Area,
                                        DevThread->DevInfo.CurrentAddress.AL_PA,
                                        CDBThread->X_ID,
                                        CDBThread->ActiveDuringLinkEvent,
                                        CDBThread->thread_hdr.currentState,
                                        osTimeStamp(hpRoot) - CDBThread->TimeStamp,
                                        CFunc_Get_ERQ_Entry( hpRoot, CDBThread->X_ID ),
                                        CDBThread->SentERQ);
                        }
                        NumActiveCDBThreads += 1;
                        pCDBList= pCDBList->flink;
                    }
                }

                if(fiListNotEmpty(&(DevThread->Awaiting_Login_CDBLink)))
                {
                    pCDBList= &(DevThread->Awaiting_Login_CDBLink);
                    pCDBList= pCDBList->flink;
                    while((&(DevThread->Awaiting_Login_CDBLink)) != pCDBList)
                    {
                        CDBThread = hpObjectBase(CDBThread_t,
                                              CDBLink, pCDBList);

                        if(IS_WITHIN(ERQ, PlusMinus, CDBThread->SentERQ, Max_ERQ) || Mode == ShowERQ )
                        {
                            if(!DevThread->FC_TapeDevice )
                            {
                                CDBThread->ActiveDuringLinkEvent = agTRUE;
                            }
                        }
                        if( Mode ==  ShowActive )
                        {
                            fiLogDebugString(hpRoot,
                                        FCMainLogErrorLevel,
                                        "%s %s Area %X ALPA %X  X_ID %3X AdLe %x State %d D %d ERQ %X SERQ %X",
                                        "CFSACDBs","Awaiting_Login_CDBLink",
                                        (void *)agNULL,(void *)agNULL,
                                        DevThread->DevInfo.CurrentAddress.Area,
                                        DevThread->DevInfo.CurrentAddress.AL_PA,
                                        CDBThread->X_ID,
                                        CDBThread->ActiveDuringLinkEvent,
                                        CDBThread->thread_hdr.currentState,
                                        osTimeStamp(hpRoot) - CDBThread->TimeStamp,
                                        CFunc_Get_ERQ_Entry( hpRoot, CDBThread->X_ID ),
                                        CDBThread->SentERQ);
                        }
                        NumActiveCDBThreads += 1;
                        pCDBList= pCDBList->flink;
                    }
                }
                pDevList = pDevList->flink;
            }
        }
    }

    return(NumActiveCDBThreads);
}



os_bit32 CFuncShowActiveCDBThreads( agRoot_t * hpRoot, os_bit32 Mode)
{
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    os_bit32 ERQ = 0;
    os_bit32 NumActiveCDBThreads = 0;

    ERQ = osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s CCnt %x ERQ %x",
                "CFuncShowActiveCDBThreads",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->CDBpollingCount,
                ERQ,
                0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "Now TimeBase %X %08X LinkDownTime %X %08X Delta %d",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->TimeBase.Hi,
                pCThread->TimeBase.Lo,
                pCThread->LinkDownTime.Hi,
                pCThread->LinkDownTime.Lo,
                pCThread->TimeBase.Lo - pCThread->LinkDownTime.Lo,
                0,0,0);

    NumActiveCDBThreads += CFuncShowActiveCDBThreadsOnQ( hpRoot, (&pCThread->Active_DevLink), ERQ, Mode);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s OK",
                "Active_DevLink",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);

    NumActiveCDBThreads += CFuncShowActiveCDBThreadsOnQ( hpRoot, (&pCThread->AWaiting_Login_DevLink), ERQ, Mode);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s OK",
                "AWaiting_Login_DevLink",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);

    NumActiveCDBThreads += CFuncShowActiveCDBThreadsOnQ( hpRoot, (&pCThread->AWaiting_ADISC_DevLink), ERQ, Mode);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s OK",
                "AWaiting_ADISC_DevLink",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);

    NumActiveCDBThreads += CFuncShowActiveCDBThreadsOnQ( hpRoot, (&pCThread->Prev_Active_DevLink), ERQ, Mode);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s OK",
                "Prev_Active_DevLink",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);

    NumActiveCDBThreads += CFuncShowActiveCDBThreadsOnQ( hpRoot, (&pCThread->Unknown_Slot_DevLink), ERQ, Mode);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s OK",
                "Unknown_Slot_DevLink",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);

    NumActiveCDBThreads += CFuncShowActiveCDBThreadsOnQ( hpRoot, (&pCThread->Slot_Searching_DevLink), ERQ, Mode);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s OK",
                "Slot_Searching_DevLink",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);

    NumActiveCDBThreads += CFuncShowActiveCDBThreadsOnQ( hpRoot, (&pCThread->Prev_Unknown_Slot_DevLink), ERQ, Mode );

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s OK",
                "Prev_Unknown_Slot_DevLink",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);

/*   NumActiveCDBThreads +=   CFuncShowActiveCDBThreadsOnQ( hpRoot, (&pCThread->DevSelf_NameServer_DevLink), ERQ, Mode );

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s OK",
                "DevSelf_NameServer_DevLink",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);
*/
    NumActiveCDBThreads += CFuncShowActiveCDBThreadsOnQ( hpRoot, (&pCThread->RSCN_Recieved_NameServer_DevLink), ERQ, Mode);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "%s OK",
                "RSCN_Recieved_NameServer_DevLink",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);
    return(NumActiveCDBThreads);
}



os_bit32 CFunc_Get_ERQ_Entry( agRoot_t *hpRoot, os_bit32 Search_X_ID )
{
    CThread_t                  * pCThread= CThread_ptr(hpRoot);
    IRB_t                      * Base_ERQ_Entry;
    IRB_t                      * ERQ_Entry;
    X_ID_t                       X_ID;
    fiMemMapMemoryDescriptor_t * CDBThread_MemoryDescriptor = &pCThread->Calculation.MemoryLayout.CDBThread;
    fiMemMapMemoryDescriptor_t * ERQ_MemoryDescriptor = &pCThread->Calculation.MemoryLayout.ERQ;


    os_bit32 entry ;

    Base_ERQ_Entry = (IRB_t  *)pCThread->Calculation.MemoryLayout.ERQ.addr.DmaMemory.dmaMemoryPtr;

    for(entry = 0; entry < ERQ_MemoryDescriptor->elements; entry ++)
    {
        ERQ_Entry = Base_ERQ_Entry + entry;

        X_ID = (X_ID_t)(ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID & 0x00007fff);

        if(X_ID < CDBThread_MemoryDescriptor->elements)
        {

            if(X_ID == Search_X_ID)
            {
                break;
            }
        }
    }
    return( entry);
}

void CFuncWaitForFCP( agRoot_t *hpRoot )
{
    CThread_t                  * CThread= CThread_ptr(hpRoot);
    os_bit32 TimeOut = 1000;

    while(! CThread_ptr(hpRoot)->FCP_FROZEN)
    {
        osStallThread(hpRoot,1);
        CThread->FuncPtrs.Proccess_IMQ( hpRoot );
        TimeOut--;
        if(TimeOut== 0) break;

    }
    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "%S LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x TimeOut %x",
                        "CFuncWaitForFCP",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread_ptr(hpRoot)->LOOP_DOWN,
                        CThread_ptr(hpRoot)->IDLE_RECEIVED,
                        CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                        CThread_ptr(hpRoot)->ERQ_FROZEN,
                        CThread_ptr(hpRoot)->FCP_FROZEN,
                        CThread_ptr(hpRoot)->ProcessingIMQ,
                        TimeOut,0);
    CFunc_Always_Enable_Queues( hpRoot );

}

void CFuncFreezeFCP( agRoot_t *hpRoot )
{
    os_bit32 Value_To_Write;

    Value_To_Write = osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status );

    Value_To_Write |= ChipIOUp_TachLite_Control_FFA;

    CFuncWriteTL_ControlReg(hpRoot, Value_To_Write );
    fiLogDebugString(hpRoot,
                FCMainLogErrorLevel,
                "%s TL Status %08X",
                "CFuncFreezeFCP",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control),
                0,0,0,0,0,0);

}


void CFuncWriteTimeoutValues( agRoot_t *hpRoot, agTimeOutValue_t * TOV )
{

    fiLogString(hpRoot,
                    "%s Tov1 %X Tov2 %X",
                    "CFuncWriteTimeoutValues",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Chip_Frame_Manager_TimeOut_Values_1(TOV->RT_Tov, TOV->ED_Tov),
                    Chip_Frame_Manager_TimeOut_Values_2(TOV->LP_Tov , TOV->AL_Time ),
                    0,0,0,0,0,0);

     osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_TimeOut_Values_1,
        Chip_Frame_Manager_TimeOut_Values_1(TOV->RT_Tov, TOV->ED_Tov));

     osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_TimeOut_Values_2,
        Chip_Frame_Manager_TimeOut_Values_2(TOV->LP_Tov , TOV->AL_Time ));

}

event_t CFuncProcessFcpRsp(agRoot_t * hpRoot, CDBThread_t * pCDBThread, event_t event_to_send )
{
    CThread_t               *  pCThread                      = CThread_ptr(hpRoot);

/**/
    os_bit8                 *  tmpptr;
    FC_FCP_RSP_Payload_t    *  fcprsp;
    os_bit32                   AdditionalSenseCode           = 0;
    os_bit32                   AdditionalSenseCodeQualifier  = 0;
    os_bit32                   SenseKey                      = 0;

    if(pCDBThread->FCP_RESP_Ptr)
    {
        fcprsp = (FC_FCP_RSP_Payload_t  * )(((os_bit8 *)pCDBThread->FCP_RESP_Ptr) + sizeof(FCHS_t));
        if( fcprsp->FCP_STATUS.SCSI_status_byte == 0x2 )
        {
            if( fcprsp->FCP_SNS_LEN)
            {
                if( event_to_send == CDBEventIoSuccess) /* off card response */
                {
                    event_to_send = CDBEventIoSuccessRSP;
                }


                tmpptr = (os_bit8 *)&fcprsp->FCP_SNS_LEN;
                tmpptr += 8;
                tmpptr += fcprsp->FCP_STATUS.ValidityStatusIndicators &
                            FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RSP_LEN_VALID ?
                            hpSwapBit32(fcprsp->FCP_RSP_LEN) : 0;


                SenseKey                     = (os_bit32)*(tmpptr+ SENSE_KEY_OFFSET) & 0xff;
                AdditionalSenseCode          = (os_bit32)*(tmpptr+ SENSE_ASC_OFFSET) & 0xff;
                AdditionalSenseCodeQualifier = (os_bit32)*(tmpptr+ SENSE_ASQ_OFFSET) & 0xff;

                fiLogDebugString(hpRoot,
                                CDBStateLogErrorLevel,
                                "%s SK %x ASC %x ASQ %x C %d @ %d X_ID %X",
                                "Check Condition",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                SenseKey,
                                AdditionalSenseCode,
                                AdditionalSenseCodeQualifier,
                                pCThread->thread_hdr.currentState,
                                pCDBThread->TimeStamp,
                                pCDBThread->X_ID,0,0);

                if(SenseKey == 0x6 && AdditionalSenseCode   == POWER_ON_RESET_OR_BUS_DEVICE_RESET_OCCURRED )
                {

                    event_to_send = CDBEventIoSuccessRSP;

                    CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
                    pCThread->LinkDownTime = pCThread->TimeBase;
/*
                    fiLogString(hpRoot,
                                        "%s SK %x ASC %x ASQ %x C %d @ %d",
                                        "Check Condition",(char *)agNULL,
                                        (void *)agNULL,(void *)agNULL,
                                        SenseKey,
                                        AdditionalSenseCode,
                                        AdditionalSenseCodeQualifier,
                                        pCThread->thread_hdr.currentState,
                                        pCDBThread->TimeStamp,0,0,0);

*/
                    return event_to_send;
                }
            }
        }
        else
        {
            if( fcprsp->FCP_STATUS.SCSI_status_byte )
            {

                if(pCDBThread->CDBRequest)
                fiLogDebugString(hpRoot,
                                CDBStateLogErrorLevel,
                                "%s %2X  @ %d",
                                "FCP_STATUS.SCSI_status_byte" ,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                (os_bit32)fcprsp->FCP_STATUS.SCSI_status_byte,
                                pCDBThread->TimeStamp,
                                0,0,0,0,0,0);

                event_to_send = CDBEventIoFailed;
            }
        }
#ifndef Performance_Debug
     fiLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    " %x scsi stat %x sense len %x",
                    "Good Completion valid",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)fcprsp->FCP_STATUS.ValidityStatusIndicators,
                    (os_bit32)fcprsp->FCP_STATUS.SCSI_status_byte,
                    (os_bit32)fcprsp->FCP_SNS_LEN,
                    0,0,0,0,0);
#endif /* Performance_Debug */
    }

    return event_to_send;
}


void internSingleThreadedEnter(agRoot_t   *    hpRoot,os_bit32  Caller )
{
    CThread_t *  pCThread;
    if( hpRoot ==  agNULL )
    {
        fiLogString(hpRoot,
                "%s hpRoot ==  agNULL Caller %d",
                "internSingleThreadedEnter",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                0,0,0,0,0,0,0);
        return;
    }
    pCThread = CThread_ptr(hpRoot);

    if( pCThread ==  agNULL )
    {
        fiLogString(hpRoot,
                "%s pCThread ==  agNULL Caller %d",
                "internSingleThreadedEnter",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                0,0,0,0,0,0,0);
        osSingleThreadedEnter( hpRoot );
        return;
    }

    if( pCThread->LastSingleThreadedEnterCaller != 0 )
    {
        fiLogString(hpRoot,
                "%s LastSingleThreadedEnterCaller(%d) != %d Should Be Zero Async %x",
                "internSingleThreadedEnter",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                pCThread->LastSingleThreadedEnterCaller,
                pCThread->LastAsyncSingleThreadedEnterCaller,
                0,0,0,0,0);
    }

    pCThread->LastSingleThreadedEnterCaller = Caller;

    osSingleThreadedEnter( hpRoot );

}
void internSingleThreadedLeave(agRoot_t   *    hpRoot,os_bit32  Caller )
{
    CThread_t *  pCThread;
    if( hpRoot ==  agNULL )
    {
        fiLogString(hpRoot,
                "%s hpRoot ==  agNULL Caller %d",
                "internSingleThreadedLeave",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                0,0,0,0,0,0,0);
        return;
    }
    pCThread = CThread_ptr(hpRoot);

    if( pCThread ==  agNULL )
    {
        fiLogString(hpRoot,
                "%s pCThread ==  agNULL Caller %d",
                "internSingleThreadedLeave",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                0,0,0,0,0,0,0);
        return;
    }

    if( pCThread->LastSingleThreadedEnterCaller != Caller )
    {
        fiLogString(hpRoot,
                "%s LastSingleThreadedEnterCaller(%d) != Last %d Async %d",
                "internSingleThreadedLeave",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                pCThread->LastSingleThreadedEnterCaller,
                pCThread->LastAsyncSingleThreadedEnterCaller,
                0,0,0,0,0);
    }
    pCThread->LastSingleThreadedEnterCaller = 0;

    osSingleThreadedLeave( hpRoot );

}

void internAsyncSingleThreadedLeave(agRoot_t   *    hpRoot,os_bit32  Caller )
{
    CThread_t *  pCThread;
    if( hpRoot ==  agNULL )
    {
        fiLogString(hpRoot,
                "%s hpRoot ==  agNULL Caller %d",
                "internAsyncSingleThreadedLeave",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                0,0,0,0,0,0,0);
        return;
    }
    pCThread = CThread_ptr(hpRoot);

    if( pCThread ==  agNULL )
    {
        fiLogString(hpRoot,
                "%s pCThread ==  agNULL Caller %d",
                "internAsyncSingleThreadedLeave",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                0,0,0,0,0,0,0);
        return;
    }

    if( pCThread->LastAsyncSingleThreadedEnterCaller != 0 )
    {
        fiLogString(hpRoot,
                "%s (%d)LastAsyncSingleThreadedEnteCaller != %d",
                "internAsyncSingleThreadedLeave",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                pCThread->LastAsyncSingleThreadedEnterCaller,
                0,0,0,0,0,0);
    }
    pCThread->LastSingleThreadedLeaveCaller = pCThread->LastSingleThreadedEnterCaller;

    pCThread->LastSingleThreadedEnterCaller = 0;

    pCThread->LastAsyncSingleThreadedEnterCaller = Caller;

    osSingleThreadedLeave( hpRoot );

}

void internAsyncSingleThreadedEnter(agRoot_t * hpRoot,os_bit32  Caller )
{
    CThread_t *  pCThread;
    if( hpRoot ==  agNULL )
    {
        fiLogString(hpRoot,
                "%s hpRoot ==  agNULL Caller %d",
                "internAsyncSingleThreadedEnter",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                0,0,0,0,0,0,0);
        return;
    }
    pCThread = CThread_ptr(hpRoot);

    if( pCThread ==  agNULL )
    {
        fiLogString(hpRoot,
                "%s pCThread ==  agNULL Caller %d",
                "internAsyncSingleThreadedEnter",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                0,0,0,0,0,0,0);
        return;
    }

    if( pCThread->LastAsyncSingleThreadedEnterCaller != Caller )
    {
        fiLogString(hpRoot,
                "%s LastAsyncSingleThreadedEnteCaller (%d)!= %d",
                "internAsyncSingleThreadedEnter",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                Caller,
                pCThread->LastAsyncSingleThreadedEnterCaller,
                0,0,0,0,0,0);
    }

    pCThread->LastSingleThreadedEnterCaller = pCThread->LastSingleThreadedLeaveCaller;

    pCThread->LastAsyncSingleThreadedEnterCaller=0;

    osSingleThreadedEnter( hpRoot );

}

/* #define disable_2gig disables 2 gig if defined */
/*+
  Function: CFuncDoLinkSpeedNegotiation
   Purpose: Checks if Two Gig link speed functions. Uses chip function
            ChipIOUp_Frame_Manager_Control_SAS.
   Returns: agTrue if Negotiation completes at Two Gig
 Called By: CFuncCheckCstate
            CActionInitFM
     Calls: osChipIOUpReadBit32
            osChipIOUpWriteBit32
            osStallThread
            fiTimerTick

-*/
agBOOLEAN CFuncDoLinkSpeedNegotiation(agRoot_t * hpRoot)
{
#ifndef disable_2gig
    CThread_t *  pCThread = CThread_ptr(hpRoot);

    os_bit32 Hard_Stall = ONE_SECOND;
    os_bit32 FM_Status = 0;

    if (pCThread->DEVID != ChipConfig_DEVID_TachyonXL2)
    {
        return  agFALSE;
    }

    fiLogDebugString(hpRoot,
            FCMainLogErrorLevel,
            "%s Link Started FM Cfg3 %08X FM Stat %08X  TL Stat %08X %x %x %x 2G %x LPS %x",
            "CFuncDoLinkSpeedNegotiation",(char *)agNULL,
            (void *)agNULL,(void *)agNULL,
            osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Configuration_3),
            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
            osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
            FM_Status,FRAMEMGR_LINK_DOWN,((FM_Status & FRAMEMGR_LINK_DOWN ) == FRAMEMGR_LINK_DOWN ),
            pCThread->TwoGigSuccessfull,
            pCThread->LoopPreviousSuccess);

    if(pCThread->LoopPreviousSuccess)
    {/* Only do negotiation if two gig succeeded before  */
        if( ! pCThread->TwoGigSuccessfull )
        {
            return  agFALSE;
        }
    }

    FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
    /* Enable auto nego */
    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration_3,  ChipIOUp_Frame_Manager_Configuration_3_EN_AutoSpeed_Nego );
    /* Start nego */
    osChipIOUpWriteBit32( hpRoot,ChipIOUp_Frame_Manager_Control , ChipIOUp_Frame_Manager_Control_SAS  );
    /* Nego finished when bit clear */

    while(  osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Configuration_3) & ChipIOUp_Frame_Manager_Configuration_3_AutoSpeed_Nego_In_Prog )
    {
        osStallThread( hpRoot, 1 );
        fiTimerTick( hpRoot, 1 );
        Hard_Stall--;

        if( Hard_Stall == 1)break;

    }

    if (Hard_Stall == 1 )
    {
        fiLogString(hpRoot,
                    "%s 2Gig Setting failed HS %x FM Cfg3 %08X",
                    "CFuncDoLinkSpeedNegotiation",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Hard_Stall,
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Configuration_3),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    0,0,0,0,0);
        fiLogString(hpRoot,
                    "%s FM Stat %08X TL Stat %08X",
                    "CFuncDoLinkSpeedNegotiation",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    FM_Status,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0,0);

        return agFALSE;
    }
    else
    {
        if( (osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Configuration_3) & \
            ( ChipIOUp_Frame_Manager_Configuration_3_2Gig_TXS   | ChipIOUp_Frame_Manager_Configuration_3_2Gig_RXS ) \
            ) == ( ChipIOUp_Frame_Manager_Configuration_3_2Gig_TXS |  ChipIOUp_Frame_Manager_Configuration_3_2Gig_RXS ))
        {

            fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s 2Gig Setting. HS %x FM Cfg3 %08X",
                        "CFuncDoLinkSpeedNegotiation",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Hard_Stall,
                        osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Configuration_3),
                        0,0,0,0,0,0);

            fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s FM Stat %08X TL Stat %08X",
                        "CFuncDoLinkSpeedNegotiation",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        FM_Status,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        0,0,0,0,0,0);

            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration_3,  ( ChipIOUp_Frame_Manager_Configuration_3_2Gig_TXS |  ChipIOUp_Frame_Manager_Configuration_3_2Gig_RXS ) );
        }
        else
        {
            fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s 1Gig Setting. HS %x FM Cfg3 %08X",
                        "CFuncDoLinkSpeedNegotiation",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Hard_Stall,
                        osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Configuration_3),
                        0,0,0,0,0,0);
            fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s FM Stat %08X  TL Stat %08X in FM stat %08X",
                        "CFuncDoLinkSpeedNegotiation",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        FM_Status,
                        0,0,0,0,0);

            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration_3,  0 );
        }
        return agTRUE;
    }
#else
        return agTRUE;

#endif /*  disable_2gig */

}

/*+
  Function: CFuncLoopMapRecieved
   Purpose: Evaluates LoopMap sets  LoopMapFabricFound and  LoopMapErrataFound flags.
   Returns: Number of devices found excluding fabric and the hba
 Called By:
     Calls: <none>
-*/
os_bit32 CFuncLoopMapRecieved(agRoot_t * hpRoot, agBOOLEAN Check_Active )
{
    CThread_t     * pCThread          = CThread_ptr(hpRoot);
    FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t * AL_PA_Position_Map = (FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *)(CThread_ptr(hpRoot)->Calculation.MemoryLayout.LOOPDeviceMAP.addr.CachedMemory.cachedMemoryPtr);
    os_bit32        IndexIntoLoopMap  = 0;
    os_bit32        NumFoundDevices   = 0;

    pCThread->LoopMapNPortPossible = agFALSE;
#ifndef _BYPASSLOOPMAP
    fiLogString(hpRoot,
                "Index    0 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[0],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[1],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[2],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[3],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[4],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[5],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[6],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[7] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index    8 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[8],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[9],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[10],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[11],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[12],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[13],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[14],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[15] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   16 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[16],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[17],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[18],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[19],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[20],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[21],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[22],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[23] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   24 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[24],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[25],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[26],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[27],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[28],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[29],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[30],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[31] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   32 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[32],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[33],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[34],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[35],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[36],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[37],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[38],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[39] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   40 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[40],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[41],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[42],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[43],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[44],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[45],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[46],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[47] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   48 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[48],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[49],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[50],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[51],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[52],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[53],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[54],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[55] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   56 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[56],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[57],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[58],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[59],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[60],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[61],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[62],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[63] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   64 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[64],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[65],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[66],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[67],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[68],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[69],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[70],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[71] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   72 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[72],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[73],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[74],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[75],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[76],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[77],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[78],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[79] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   80 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[80],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[81],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[82],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[83],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[84],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[85],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[86],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[87] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   88 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[88],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[89],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[90],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[91],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[92],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[93],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[94],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[95] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index   96 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[ 96],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[ 97],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[ 98],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[ 99],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[100],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[101],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[102],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[103] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index  104 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[104],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[105],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[106],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[107],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[108],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[109],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[110],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[111] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index  112 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[112],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[113],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[114],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[115],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[116],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[117],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[118],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[119] );

   fiLogDebugString(hpRoot,
                CDBStateLogErrorLevel,
                "Index  120 %02X %02X %02X %02X %02X %02X %02X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[120],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[121],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[122],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[123],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[124],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[125],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[126],
                (os_bit32)AL_PA_Position_Map->AL_PA_Slot[127]);

#endif /*  _BYPASSLOOPMAP */

    for(IndexIntoLoopMap  =0; IndexIntoLoopMap < AL_PA_Position_Map->AL_PA_Index; IndexIntoLoopMap ++)
    {
        if( AL_PA_Position_Map->AL_PA_Slot[IndexIntoLoopMap] == pCThread->ChanInfo.CurrentAddress.AL_PA
         || AL_PA_Position_Map->AL_PA_Slot[IndexIntoLoopMap] == 0 /* Fabric */)
        {
            continue;
        }
        else
        {
            if(Check_Active)
            {
                FC_Port_ID_t  Port_ID;
                Port_ID.Struct_Form.reserved=0;
                Port_ID.Struct_Form.Domain=0;
                Port_ID.Struct_Form.Area =0;
                Port_ID.Struct_Form.AL_PA = AL_PA_Position_Map->AL_PA_Slot[IndexIntoLoopMap];

                if( ! CFuncCheckIfPortActive( hpRoot,   Port_ID))
                {
                    fiLogString(hpRoot,
                                "%s %s %X I %d",
                                "CFuncLoopMapRecieved","Device Missing",
                                (void *)agNULL,(void *)agNULL,
                                Port_ID.Bit32_Form,
                                IndexIntoLoopMap,
                                0,0,0,0,0,0);
                }
            }

            NumFoundDevices ++;
            if( AL_PA_Position_Map->AL_PA_Slot[IndexIntoLoopMap] == 0xff)
            {
                pCThread->LoopMapErrataFound = agTRUE;
                NumFoundDevices = 0;
                fiLogString(hpRoot,
                            "%s %s",
                            "CFuncLoopMapRecieved","LoopMapErrataFound",
                            (void *)agNULL,(void *)agNULL,
                            0,0,0,0,0,0,0,0);
                return(NumFoundDevices);

            }
        }

    }

    fiLogDebugString(hpRoot,
                FCMainLogErrorLevel,
                "%s NumFoundDevices %x",
                "CFuncLoopMapRecieved",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                NumFoundDevices,0,0,0,0,0,0,0);

    if(NumFoundDevices == 0)
    {
        if( AL_PA_Position_Map->AL_PA_Slot[0] == 0 /* Fabric */)
        {
            if( AL_PA_Position_Map->AL_PA_Slot[1] == pCThread->ChanInfo.CurrentAddress.AL_PA )
            {
                fiLogString(hpRoot,
                            "%s %s",
                            "CFuncLoopMapRecieved","LoopMapNPortPossible",
                            (void *)agNULL,(void *)agNULL,
                            0,0,0,0,0,0,0,0);

                pCThread->LoopMapNPortPossible = agTRUE;
            }
        }
    }
    return(NumFoundDevices);
}

/*+
  Function: CFuncCheckFabricMap
   Purpose: Returns number of decices in current fabric map
   Returns:
 Called By:
     Calls: <none>
-*/
os_bit32 CFuncCheckFabricMap(agRoot_t * hpRoot, agBOOLEAN Check_Active )
{
    CThread_t     * pCThread        = CThread_ptr(hpRoot);
    FC_Port_ID_t    Port_ID;
    os_bit32        NumFoundDevices = 0;
    os_bit32        AL_PA_Index     = 0;

    FC_NS_DU_GID_PT_FS_ACC_Payload_t * RegisteredEntries  = (FC_NS_DU_GID_PT_FS_ACC_Payload_t *)(CThread_ptr(hpRoot)->Calculation.MemoryLayout.FabricDeviceMAP.addr.CachedMemory.cachedMemoryPtr);

    do
    {
        if ( (RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[0] == pCThread->ChanInfo.CurrentAddress.Domain) &&
             (RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[1] == pCThread->ChanInfo.CurrentAddress.Area) &&
             (RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[2] == pCThread->ChanInfo.CurrentAddress.AL_PA) )
        {
            AL_PA_Index++;
            continue;
        }

        if(Check_Active)
        {
            Port_ID.Struct_Form.reserved = 0;
            Port_ID.Struct_Form.Domain = RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[0];
            Port_ID.Struct_Form.Area   = RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[1];
            Port_ID.Struct_Form.AL_PA  = RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[2];

            if( ! CFuncCheckIfPortActive( hpRoot,   Port_ID))
            {
                fiLogString(hpRoot,
                            "%s %s %X I %d",
                            "CFuncCheckFabricMap","Device Missing",
                            (void *)agNULL,(void *)agNULL,
                            Port_ID.Bit32_Form,
                            AL_PA_Index,
                            0,0,0,0,0,0);
            }
        }
        NumFoundDevices++;

        AL_PA_Index++;

    } while (RegisteredEntries->Control_Port_ID[AL_PA_Index - 1].Control != FC_NS_Control_Port_ID_Control_Last_Port_ID);


    return(NumFoundDevices);
}


/*+
  Function: CFuncDoADISC
   Purpose: Does ADISC to all devices on Prev_Active_DevLink. Does not work if inIMQ is agTRUE.
   Returns: none
 Called By: fcDelayedInterruptHandler
            fcStartIO
     Calls: CFuncInterruptPoll
            CFuncQuietShowWhereDevThreadsAre
            CFuncCompleteActiveCDBThreadsOnDevice
            DevEventAllocAdisc
            CFuncInterruptPoll
            CFuncCompleteActiveCDBThreadsOnDevice
            DevThreadFree
            CFuncShowWhereCDBThreadsAre
            CFuncWhatStateAreCDBThreads
            Proccess_IMQ
-*/
void CFuncDoADISC(agRoot_t * hpRoot)
{
    CThread_t     * pCThread            = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread;
    fiList_t      * pDevList;


    while(fiListNotEmpty(&pCThread->Prev_Active_DevLink ))
    {

        if(pCThread->ADISC_pollingCount > pCThread->NumberOutstandingFindDevice )
        {/* This limits the stack depth */
            fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "%s pCThread->ADISC_pollingCount > NumberOutstandingFindDevice %x",
                        "Do ADISC",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->NumberOutstandingFindDevice,
                        0,0,0,0,0,0,0 );


            if(CFuncInterruptPoll( hpRoot,&pCThread->ADISC_pollingCount ))
            {
                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "LF Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                        0,0,0,0);
            }/* End ADISC_pollingCount Interrupt poll */

        }/* End NumberOutstandingFindDevice */

        fiListDequeueFromHead(&pDevList,
                                  &pCThread->Prev_Active_DevLink );
        pDevThread = hpObjectBase(DevThread_t,
                                  DevLink,pDevList );

        if( pDevThread->DevInfo.DeviceType & agDevSCSITarget )
        {

            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "%s %s %x",
                        "Do ADISC","Prev_Active_DevLink",
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
                        0,0,0,0,0,0,0);

            fiSendEvent(&pDevThread->thread_hdr,DevEventAllocAdisc);
        }
        else
        {
            if(CFuncQuietShowWhereDevThreadsAre( hpRoot))
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s %s ADISC cnt %d",
                            "Do ADISC","CFuncQuietShowWhereDevThreadsAre",
                            (void *)agNULL,(void *)agNULL,
                            pCThread->ADISC_pollingCount,
                            0,0,0,0,0,0,0);

            }

            CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset,  CDBEventIODeviceReset );

            DevThreadFree( hpRoot, pDevThread );

            if(CFuncQuietShowWhereDevThreadsAre( hpRoot))
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s BB ADISC cnt %d",
                            "Do ADISC",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->ADISC_pollingCount,
                            0,0,0,0,0,0,0);

            }
        }/*End else */
    }/*End fiListNotEmpty  */

    FinishAdisc:

    if(CFuncInterruptPoll( hpRoot,&pCThread->ADISC_pollingCount ))
    {

        fiLogString(hpRoot,
                "%s CFuncInterruptPoll Time out Cstate %d ADISC cnt %d",
                "Do ADISC",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->thread_hdr.currentState,
                pCThread->ADISC_pollingCount,
                0,0,0,0,0,0 );

        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "ADISC  Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                0,0,0,0);
    }

    fiLogString(hpRoot,
                "%s Free %d Active %d Un %d Login %d",
                "Do ADISC",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                fiNumElementsOnList(&pCThread->Free_DevLink),
                fiNumElementsOnList(&pCThread->Active_DevLink),
                fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
                fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                0,0,0,0 );
    fiLogString(hpRoot,
                "%s ADISC %d SS %d PrevA login %d Prev Un %d",
                "Do ADISC",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
                fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
                fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
                fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink),
                0,0,0,0 );

    if(CFuncShowWhereDevThreadsAre( hpRoot))
    {
        CFuncWhatStateAreDevThreads( hpRoot );
    }

    if( CFuncShowWhereCDBThreadsAre(hpRoot))
    {
        CFuncWhatStateAreCDBThreads(hpRoot);
    }


    while(fiListNotEmpty(&pCThread->Prev_Unknown_Slot_DevLink ))
    {
        fiListDequeueFromHeadFast(&pDevList,
                                  &pCThread->Prev_Unknown_Slot_DevLink );
        pDevThread = hpObjectBase(DevThread_t,
                                  DevLink,pDevList );
        CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset,  CDBEventIODeviceReset );

        fiLogDebugString(hpRoot,
                        DevStateLogErrorLevel,
                        "In %s Device  ALPA %06X Failed",
                        "Do ADISC",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiComputeDevThread_D_ID(pDevThread),
                        0,0,0,0,0,0,0);

        DevThreadFree( hpRoot, pDevThread );
    }

    if(CFuncShowWhereDevThreadsAre( hpRoot))
    {
        CFuncWhatStateAreDevThreads( hpRoot );
    }


    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot (%p) Out %s - State = %d ADcnt %x Dev Self %p",
                    "Do ADISC",(char *)agNULL,
                    hpRoot,pCThread->DeviceSelf,
                    (os_bit32)pCThread->thread_hdr.currentState,
                    pCThread->ADISC_pollingCount,
                    0,0,0,0,0,0);


    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FM Status %08X FM Config %08X TL Status %08X TL Control %08X Rec Alpa Reg %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0);

    fiLogString(hpRoot,
                "%s FM %08X TL %08X AC %x ADISC %d FDc %d",
                "Do ADISC",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                CFuncAll_clear( hpRoot ),
                pCThread->ADISC_pollingCount,
                pCThread->FindDEV_pollingCount,
                0,0,0);

    fiLogString(hpRoot,
                "End %s Free %d Active %d Un %d Login %d",
                "Do ADISC",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                fiNumElementsOnList(&pCThread->Free_DevLink),
                fiNumElementsOnList(&pCThread->Active_DevLink),
                fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
                fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                0,0,0,0 );
    fiLogString(hpRoot,
                "End %s ADISC %d SS %d PrevA login %d Prev Un %d",
                "Do ADISC",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
                fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
                fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
                fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink),
                0,0,0,0 );

    if(pCThread->ADISC_pollingCount)
    {
        goto FinishAdisc;
    }
    pCThread->FuncPtrs.Proccess_IMQ(hpRoot);

}

/*+
  Function: CFunc_MAX_XL2_Payload
   Purpose: Deterimines if SFQ is large enough to hold a 2k frame
   Returns: Max XL2 receive payload
 Called By: CActionDoFlogi
            fiLinkSvcInit
     Calls: none
-*/
os_bit32 CFunc_MAX_XL2_Payload( agRoot_t *hpRoot )
{
    CThread_t *CThread = CThread_ptr(hpRoot);
    os_bit32   XL2_MaxFrameSize = TachyonXL_Max_Frame_Payload;

    if( CThread->Calculation.MemoryLayout.SFQ.objectSize <= TachyonXL_Max_Frame_Payload )
    {
        XL2_MaxFrameSize = 0x400;
    }

    return(XL2_MaxFrameSize);
}


/*+
  Function: CFuncReadBiosParms
   Purpose: Reads flashrom to allow BIOS settings to affect fclayer operation.
            Sets InitAsNport operation and Link Speed to either 1 or 2 gig
   Returns: none
 Called By: fcInitializeChannel
     Calls: fiFlashReadBit8
            fiFlashReadBit32
-*/
void CFuncReadBiosParms(agRoot_t * hpRoot)
{
    agBiosConfig_t      BConfig;
    CThread_t         * pCThread = CThread_ptr(hpRoot);

    BConfig.Valid       = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,Valid) );
    BConfig.Struct_Size = fiFlashReadBit32( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,Struct_Size) );
    BConfig.agBiosConfig_Version = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,agBiosConfig_Version) );

    BConfig.H_Domain    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,H_Domain) );
    BConfig.H_Area      = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,H_Area) );
    BConfig.H_Alpa      = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,H_Alpa) );

    BConfig.B_Domain    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_Domain) );
    BConfig.B_Area      = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_Area) );
    BConfig.B_Alpa      = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_Alpa) );

    BConfig.B_WWN[0]    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_WWN)+0 );
    BConfig.B_WWN[1]    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_WWN)+1 );
    BConfig.B_WWN[2]    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_WWN)+2 );
    BConfig.B_WWN[3]    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_WWN)+3 );
    BConfig.B_WWN[4]    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_WWN)+4 );
    BConfig.B_WWN[5]    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_WWN)+5 );
    BConfig.B_WWN[6]    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_WWN)+6 );
    BConfig.B_WWN[7]    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,B_WWN)+7 );

    BConfig.BackwardScan= fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,BackwardScan) );
    BConfig.BiosEnabled = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,BiosEnabled) );
    BConfig.MaxDevice   = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,MaxDevice) );
    BConfig.FLport      = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,FLport) );
    BConfig.Alpa_WWN    = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,Alpa_WWN) );
    BConfig.ToggleXL2   = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,ToggleXL2) );

    BConfig.RevMajor  = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,RevMajor) );
    BConfig.RevMinorL = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,RevMinorL) );
    BConfig.RevMinorH = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,RevMinorH) );
    BConfig.RevType   = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,RevType) );

    BConfig.End_Sig   = fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + hpFieldOffset(agBiosConfig_t,End_Sig) );

    if(BConfig.Valid == agBIOS_Config_VALID && BConfig.End_Sig == agBIOS_Config_EndSig )
    {

        if(fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + BConfig.Struct_Size - 1) != agBIOS_Config_EndSig)
        {
            fiLogString(hpRoot,
                        "End Sig mismatch %X %X %X",
                        "Bios Valid",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        BConfig.Struct_Size,
                        (os_bit32)fiFlashReadBit8( hpRoot, agBIOS_Config_OffSet + BConfig.Struct_Size - 1 ),
                        hpFieldOffset(agBiosConfig_t,End_Sig),
                        0,0,0,0,0 );
        }
        
        fiLogString(hpRoot,
                    "%s %x Hard Domain %X Area %X ALPA %X",
                    "Bios Valid",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)BConfig.Valid,
                    (os_bit32)BConfig.H_Domain,
                    (os_bit32)BConfig.H_Area,
                    (os_bit32)BConfig.H_Alpa ,
                    0,0,0,0 );

        fiLogString(hpRoot,
                    "BiosEnabled %x InitAsNport %x (%x)FLport %x Link Speed %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)BConfig.BiosEnabled,
                    CThread_ptr(hpRoot)->InitAsNport,
                    pCThread->Calculation.Parameters.InitAsNport,
                    (os_bit32)BConfig.FLport ,
                    (os_bit32)BConfig.ToggleXL2,
                    0,0,0 );

        /*Set InitAsNport */
        if( BConfig.FLport == agBIOS_FLport && pCThread->Calculation.Parameters.InitAsNport)
        {
            if( BConfig.BiosEnabled == agBIOS_Enabled )
            {
                fiLogString(hpRoot,
                            "%s InitAsNport Conflict with registry %x %x FM %08X",
                            "Bios ",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->Calculation.Parameters.InitAsNport,
                            BConfig.FLport,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            0,0,0,0,0);
            }
        }

        if( BConfig.BiosEnabled == agBIOS_Enabled )
        {
            if( BConfig.FLport == agBIOS_FLport )
            {
                fiLogString(hpRoot,
                            "%s InitAsNport set to Loop",
                            "Bios ",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->Calculation.Parameters.InitAsNport,
                            BConfig.FLport,0,0,0,0,0,0);
                 pCThread->InitAsNport = agFALSE;
            }
            else
            {
                fiLogString(hpRoot,
                            "%s InitAsNport set to NPort",
                            "Bios",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->Calculation.Parameters.InitAsNport,
                            BConfig.FLport,0,0,0,0,0,0);
                pCThread->InitAsNport = agTRUE;
            }
        }
        else
        {
            fiLogString(hpRoot,
                        "%s InitAsNport set from registry(%x) (%x)",
                        "Bios Disabled",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->Calculation.Parameters.InitAsNport,
                        BConfig.FLport,0,0,0,0,0,0);
            pCThread->InitAsNport = pCThread->Calculation.Parameters.InitAsNport;
        }


        if( BConfig.ToggleXL2 == agBIOS_ToggleXL2_Link_Speed_2_gig )
        {
            fiLogString(hpRoot,
                        "%s Link Speed 2 Gig %x",
                        "Bios",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        BConfig.ToggleXL2,0,0,0,0,0,0,0 );
            pCThread->TwoGigSuccessfull = agTRUE;

            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration_3,  ( ChipIOUp_Frame_Manager_Configuration_3_2Gig_TXS |  ChipIOUp_Frame_Manager_Configuration_3_2Gig_RXS ) );
        }
        else
        {
            fiLogString(hpRoot,
                        "%s Link Speed 1 Gig",
                        "Bios",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        BConfig.ToggleXL2,0,0,0,0,0,0,0 );
            pCThread->TwoGigSuccessfull = agFALSE;
            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration_3,  0 );

        }

        fiLogString(hpRoot,
                    "%s Boot Domain %X Area %X ALPA %X",
                    "Bios",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)BConfig.B_Domain,
                    (os_bit32)BConfig.B_Area,
                    (os_bit32)BConfig.B_Alpa,
                    0,0,0,0,0 );

        fiLogString(hpRoot,
                    "%s WWN %X %X %X %X %X %X %X %X",
                    "Bios",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)BConfig.B_WWN[0],
                    (os_bit32)BConfig.B_WWN[1],
                    (os_bit32)BConfig.B_WWN[2],
                    (os_bit32)BConfig.B_WWN[3],
                    (os_bit32)BConfig.B_WWN[4],
                    (os_bit32)BConfig.B_WWN[5],
                    (os_bit32)BConfig.B_WWN[6],
                    (os_bit32)BConfig.B_WWN[7] );

        fiLogString(hpRoot,
                    "%s BackwardScan %X BiosEnabled %X MaxDevice %d",
                    "Bios",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)BConfig.BackwardScan,
                    (os_bit32)BConfig.BiosEnabled,
                    (os_bit32)BConfig.MaxDevice,
                    0,0,0,0,0);


        fiLogString(hpRoot,
                    "%s FLport %X Alpa_WWN %X ToggleXL2 %X",
                    "Bios",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)BConfig.FLport ,
                    (os_bit32)BConfig.Alpa_WWN ,
                    (os_bit32)BConfig.ToggleXL2,
                    0,0,0,0,0);
    }
    else
    {
        fiLogString(hpRoot,
                    "%s  %x Hard Domain %X Area %X ALPA %X",
                    "Bios INVALID",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)BConfig.Valid,
                    (os_bit32)BConfig.H_Domain,
                    (os_bit32)BConfig.H_Area,
                    (os_bit32)BConfig.H_Alpa ,
                    0,0,0,0 );

        fiLogString(hpRoot,
                    "%s InitAsNport set from registry",
                    "Bios INVALID",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

         pCThread->InitAsNport = pCThread->Calculation.Parameters.InitAsNport;

    }

}

/*+
  Function: Cfunc_c
   Purpose: When compiled updates browser info file for VC 5.0 / 6.0
   Returns: none
 Called By: none
     Calls: none
-*/
/*void Cfunc_c(void){} */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\cdbstate.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/CDBSTATE.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 7/20/00 2:33p   $

Purpose:

  This file defines the macros, types, and data structures
  used by ../C/cdbState.C

--*/

#ifndef __CDBState_H__
#define __CDBState_H__

#define   CDBStateConfused                  0
#define   CDBStateThreadFree                1
#define   CDBStateInitialize                2
#define   CDBStateFillLocalSGL              3
#define   CDBStateAllocESGL                 4
#define   CDBStateFillESGL                  5
#define   CDBStateSendIo                    6
#define   CDBStateFcpCompleteSuccess        7
#define   CDBStateFcpCompleteSuccessRSP     8

#define   CDBStateFcpCompleteFail           9
#define   CDBStateFcpCompleteAbort          10    /* a */
#define   CDBStateFcpCompleteDeviceReset    11    /* b */
#define   CDBStateFcpCompleteOver           12    /* c */
#define   CDBStateOOOReceived               13    /* d */
#define   CDBStateOOOFixup                  14    /* e */
#define   CDBStateOOOSend                   15    /* f */

#define   CDBStateInitialize_DR             16    /* 10 */
#define   CDBStateFillLocalSGL_DR           17    /* 11 */
#define   CDBStateAllocESGL_DR              18    /* 12 */
#define   CDBStateFillESGL_DR               19    /* 13 */

#define   CDBStateInitialize_Abort          20    /* 14 */
#define   CDBStateFillLocalSGL_Abort        21    /* 15 */
#define   CDBStateAllocESGL_Abort           22    /* 16 */
#define   CDBStateFillESGL_Abort            23    /* 17 */

#define   CDBStateOOOReceived_Abort         24    /* 18 */
#define   CDBStateOOOReceived_DR            25    /* 19 */
#define   CDBStateOOOFixup_Abort            26    /* 1A */
#define   CDBStateOOOFixup_DR               27    /* 1B */

#define   CDBStateOutBoundError             28    /* 1C */
#define   CDBStateFailure_NO_RSP            29    /* 1D */

#define   CDBStateAlloc_Abort               30    /* 1E */
#define   CDBStateDo_Abort                  31    /* 1F */

#define   CDBStatePending_Abort             32    /* 20 */
#define   CDBStatePrepare_For_Abort         33    /* 21 */

#define   CDBStateBuild_CCC_IO              34    /* 22 */
#define   CDBStateSend_CCC_IO               35    /* 23 */
#define   CDBState_CCC_IO_Success           36    /* 24 */
#define   CDBState_CCC_IO_Fail              37    /* 25 */

#define   CDBStateSend_REC                  38    /* 26 */
#define   CDBStateSend_REC_Second           39    /* 27 */
#define   CDBStateSend_SRR                  40    /* 28 */
#define   CDBStateSend_SRR_Second           41    /* 29 */

#define   CDBState_REC_Success              42    /* 2A */
#define   CDBState_SRR_Success              43    /* 2B */
 
#define   CDBState_SRR_Fail                 44    /* 2C */
#define   CDBState_Alloc_REC                45    /* 2D */
#define   CDBStateDO_Nothing                46    /* 2E */
#define   CDBStateReSend_IO                 47    /* 2F */

#define   CdbStateMAXState      CDBStateReSend_IO                 


#define   CDBEventConfused        0
#define   CDBEventInitialize      1
#define   CDBEventLocalSGL        2
#define   CDBEventNeedESGL        3
#define   CDBEventGotESGL         4
#define   CDBEventESGLSendIo      5
#define   CDBEventLocalSGLSendIo  6
#define   CDBEventIoSuccess       7
#define   CDBEventIoFailed        8
#define   CDBEventIoAbort         9
#define   CDBEventIoOver         10
#define   CDBEventThreadFree     11
#define   CDBEventIODeviceReset  12

#define   CDBEventOOOReceived    13
#define   CDBEventOOOFixup       14
#define   CDBEventOOOSend        15

#define   CDBEventIoSuccessRSP   16

#define   CDBEventOutBoundError  17
#define   CDBEventFailNoRSP      18

#define   CDBEventAlloc_Abort     19
#define   CDBEventDo_Abort        20
#define   CDBEvent_Abort_Rejected 21

#define   CDBEvent_PrepareforAbort   22

#define   CDBEventDo_CCC_IO          23
#define   CDBEvent_CCC_IO_Built      24
#define   CDBEvent_CCC_IO_Success    25
#define   CDBEvent_CCC_IO_Fail       26

#define   CDBEventREC_TOV            27
#define   CDBEventSendREC_Success    28
#define   CDBEventSendREC_Fail       29
#define   CDBEventSendSRR            30
#define   CDBEventSendSRR_Success    31
#define   CDBEventSendSRR_Again      32

#define   CDBEvent_Got_REC           33
#define   CDBEvent_ResendIO          34
#define   CDBEventSendSRR_Fail       35

#define   CdbEventMAXEvent  CDBEventSendSRR_Fail

#define   CdbCompetionStatusReSendIO  0x0000FFFF


STATE_PROTO( CDBActionConfused               );                    /* 0  */
STATE_PROTO( CDBActionThreadFree             );                    /* 1  */
STATE_PROTO( CDBActionInitialize             );                    /* 2  */
STATE_PROTO( CDBActionFillLocalSGL           );                    /* 3  */
STATE_PROTO( CDBActionAllocESGL              );                    /* 4  */
STATE_PROTO( CDBActionFillESGL               );                    /* 5  */
STATE_PROTO( CDBActionSendIo                 );                    /* 6  */
STATE_PROTO( CDBActionFcpCompleteSuccess     );                    /* 7  */
STATE_PROTO( CDBActionFcpCompleteSuccessRSP  );                    /* 8  */
STATE_PROTO( CDBActionFcpCompleteFail        );                    /* 9  */
STATE_PROTO( CDBActionFcpCompleteAbort       );                    /* 10 */
STATE_PROTO( CDBActionFcpCompleteDeviceReset );                    /* 11 */
STATE_PROTO( CDBActionFcpCompleteOver        );                    /* 12 */
STATE_PROTO( CDBActionOOOReceived            );                    /* 13 */
STATE_PROTO( CDBActionOOOFixup               );                    /* 14 */
STATE_PROTO( CDBActionOOOSend                );                    /* 15 */
STATE_PROTO( CDBActionInitialize_DR          );                    /* 16 */
STATE_PROTO( CDBActionFillLocalSGL_DR        );                    /* 17 */
STATE_PROTO( CDBActionAllocESGL_DR           );                    /* 18 */
STATE_PROTO( CDBActionFillESGL_DR            );                    /* 19 */
STATE_PROTO( CDBActionInitialize_Abort       );                    /* 20 */
STATE_PROTO( CDBActionFillLocalSGL_Abort     );                    /* 21 */
STATE_PROTO( CDBActionAllocESGL_Abort        );                    /* 22 */
STATE_PROTO( CDBActionFillESGL_Abort         );                    /* 23 */

STATE_PROTO( CDBActionOOOReceived_Abort      );                    /* 24 */
STATE_PROTO( CDBActionOOOReceived_DR         );                    /* 25 */
STATE_PROTO( CDBActionOOOFixup_Abort         );                    /* 26 */
STATE_PROTO( CDBActionOOOFixup_DR            );                    /* 27 */

STATE_PROTO( CDBActionOutBoundError          );                    /* 28 */
STATE_PROTO( CDBActionFailure_NO_RSP         );                    /* 29 */

STATE_PROTO( CDBActionAlloc_Abort            );                    /* 30 */
STATE_PROTO( CDBActionDo_Abort               );                    /* 31 */

STATE_PROTO( CDBActionPending_Abort          );                    /* 32 */

STATE_PROTO( CDBActionPrepare_For_Abort      );                    /* 33 */

STATE_PROTO( CDBActionBuild_CCC_IO      );
STATE_PROTO( CDBActionSend_CCC_IO       );
STATE_PROTO( CDBAction_CCC_IO_Success   );
STATE_PROTO( CDBAction_CCC_IO_Fail      );

STATE_PROTO( CDBActionSend_REC       );
STATE_PROTO( CDBActionSend_REC_Second);
STATE_PROTO( CDBActionSend_SRR       );
STATE_PROTO( CDBActionSend_SRR_Second);
STATE_PROTO( CDBAction_REC_Success   );
STATE_PROTO( CDBAction_SRR_Success   );
STATE_PROTO( CDBAction_SRR_Fail      );
STATE_PROTO( CDBAction_Alloc_REC     );
STATE_PROTO( CDBActionDO_Nothing     );
STATE_PROTO( CDBActionReSend_IO      );

extern stateTransitionMatrix_t CDBStateTransitionMatrix;
extern stateActionScalar_t CDBStateActionScalar;

extern void fill_Loc_SGL_offCard(CDBThread_t * pCDBThread);
extern void fill_Loc_SGL_onCard(CDBThread_t * pCDBThread);

void fillptr_SEST_offCard_ESGL_offCard(CDBThread_t * pCDBThread);
void fillptr_SEST_offCard_ESGL_onCard(CDBThread_t * pCDBThread);
void fillptr_SEST_onCard_ESGL_offCard(CDBThread_t * pCDBThread);
void fillptr_SEST_onCard_ESGL_onCard(CDBThread_t * pCDBThread);

void fill_ESGL_onCard(CDBThread_t * pCDBThread);
void fill_ESGL_offCard(CDBThread_t * pCDBThread);

void CDBFuncIRB_onCardInit(CDBThread_t  * CDBThread );
void CDBFuncIRB_offCardInit(CDBThread_t  * CDBThread );

CDBThread_t *CCC_CdbThreadAlloc(
                             agRoot_t          *hpRoot,
                             DevThread_t       *DevThread,
                             os_bit32 Lun
                           );


#ifdef USESTATEMACROS

void testCDBthread( agRoot_t *hpRoot  );

#define CDBSTATE_FUNCTION_ACTION( x , Action) extern void x( fi_thread__t * thread, \
                 eventRecord_t * eventRecord ){         \
    agRoot_t * hpRoot=thread->hpRoot;                   \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d",             \
                      #x,(char *)agNULL,                \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,   \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "Sends event...%s %d",          \
                      #Action,(char *)agNULL,             \
                      (void * )agNULL,(void * )agNULL,  \
                      Action,0,0,0,0,0,0,0);            \
    fiSetEventRecord(eventRecord, thread, Action);   }  \

#define CDBSTATE_FUNCTION_TERMINATE(x) extern void x(fi_thread__t *thread,\
                                      eventRecord_t *eventRecord ){\
    agRoot_t * hpRoot=thread->hpRoot;                   \
    CThread_t  * pCThread=CThread_ptr(hpRoot);          \
    CDBThread_t * pCDBThread=(CDBThread_t * )thread;    \
    DevThread_t * pDevThread=pCDBThread->Device;        \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d",     \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "...simply returns",            \
                      (char *)agNULL,(char *)agNULL,        \
                      (void * )agNULL,(void * )agNULL,  \
                      0,0,0,0,0,0,0,0);                 \
    eventRecord->thread = agNULL;                         \
    }\

#define CDBSTATE_FUNCTION_MULTI_ACTION(x,Action0,Action1,Action2,Action3) extern void x( fi_thread__t *thread,\
                                      eventRecord_t *eventRecord ){ \
    agRoot_t * hpRoot = thread->hpRoot;               \
    os_bit8 WhichAction[4];                              \
    static  os_bit32 ActionCount=0;                      \
    WhichAction[0] = Action0;                         \
    WhichAction[1] = Action1;                         \
    WhichAction[2] = Action2;                         \
    WhichAction[3] = Action3;                         \
    osLogDebugString(thread->hpRoot,                  \
                      StateLogConsoleLevel,           \
                      "In %s - State = %d",           \
                      #x,(char *)agNULL,                \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,    \
                      0,0,0,0,0,0,0);                 \
    osLogDebugString(thread->hpRoot,                  \
                      StateLogConsoleLevel,           \
                      "...returns event %s %d",       \
                      #Action0,#Action1,              \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)WhichAction[ActionCount],\
                      0,0,0,0,0,0,0);                 \
    osLogDebugString(thread->hpRoot,                  \
                      StateLogConsoleLevel,           \
                      "or %s  or %s",                 \
                      #Action2,#Action3,              \
                      (void * )agNULL,(void * )agNULL,  \
                      0,0,0,0,0,0,0,0);               \
    fiSetEventRecord(eventRecord,thread,WhichAction[ActionCount]);  \
    if(ActionCount<3)ActionCount++;                   \
    else ActionCount =0;                              \
    }                                                 \

#ifdef  TestCdbStateMachine

char * CdbStateString[]=
{

    "CDBStateConfused               ",
    "CDBStateThreadFree             ",
    "CDBStateInitialize             ",
    "CDBStateFillLocalSGL           ",
    "CDBStateAllocESGL              ",
    "CDBStateFillESGL               ",
    "CDBStateSendIo                 ",
    "CDBStateFcpCompleteSuccess     ",
    "CDBStateFcpCompleteSuccessRSP  ",
    "CDBStateFcpCompleteFail        ",
    "CDBStateFcpCompleteAbort       ",
    "CDBStateFcpCompleteDeviceReset ",
    "CDBStateFcpCompleteOver        ",
    "CDBStateOOOReceived            ",
    "CDBStateOOOFixup               ",
    "CDBStateOOOSend                ",
    "CDBStateInitialize_DR          ",
    "CDBStateFillLocalSGL_DR        ",
    "CDBStateAllocESGL_DR           ",
    "CDBStateFillESGL_DR            ",
    "CDBStateInitialize_Abort       ",
    "CDBStateFillLocalSGL_Abort     ",
    "CDBStateAllocESGL_Abort        ",
    "CDBStateFillESGL_Abort         ",
    "CDBStateOOOReceived_Abort      ",
    "CDBStateOOOReceived_DR         ",
    "CDBStateOOOFixup_Abort         ",
    "CDBStateOOOFixup_DR            ",
    "CDBStateOutBoundError          ",
    "CDBStateFailure_NO_RSP         ",
    "CDBStateAlloc_Abort            ",
    "CDBStateDo_Abort               ",
    "CDBStatePending_Abort          ",
    "CDBStatePrepare_For_Abort      ",
    "CDBStateBuild_CCC_IO           ",
    "CDBStateSend_CCC_IO            ",
    "CDBState_CCC_IO_Success        ",
    "CDBState_CCC_IO_Fail           ",
    "CDBStateSend_REC               ",
    "CDBStateSend_REC_Second        ",
    "CDBStateSend_SRR               ",
    "CDBStateSend_SRR_Second        ",
    "CDBState_REC_Success           ",
    "CDBState_SRR_Success           ",
    "CDBState_SRR_Fail              ",
    "CDBState_Alloc_REC             ",
    "CDBStateDO_Nothing             ",
    "CDBStateReSend_IO              ",
    agNULL
};


char * CdbEventString[]=
{

    "CDBEventConfused         ",
    "CDBEventInitialize       ",
    "CDBEventLocalSGL         ",
    "CDBEventNeedESGL         ",
    "CDBEventGotESGL          ",
    "CDBEventESGLSendIo       ",
    "CDBEventLocalSGLSendIo   ",
    "CDBEventIoSuccess        ",
    "CDBEventIoFailed         ",
    "CDBEventIoAbort          ",
    "CDBEventIoOver           ",
    "CDBEventThreadFree       ",
    "CDBEventIODeviceReset    ",
    "CDBEventOOOReceived      ",
    "CDBEventOOOFixup         ",
    "CDBEventOOOSend          ",
    "CDBEventIoSuccessRSP     ",
    "CDBEventOutBoundError    ",
    "CDBEventFailNoRSP        ",
    "CDBEventAlloc_Abort      ",
    "CDBEventDo_Abort         ",
    "CDBEvent_Abort_Rejected  ",
    "CDBEvent_PrepareforAbort ",
    "CDBEventDo_CCC_IO        ",
    "CDBEvent_CCC_IO_Built    ",
    "CDBEvent_CCC_IO_Success  ",
    "CDBEvent_CCC_IO_Fail     ",
    "CDBEventREC_TOV          ",
    "CDBEventSendREC_Success  ",
    "CDBEventSendREC_Fail     ",
    "CDBEventSendSRR          ",
    "CDBEventSendSRR_Success  ",
    "CDBEventSendSRR_Again    ",
    "CDBEvent_Got_REC         ",
    "CDBEvent_ResendIO        ",
    agNULL
};

#endif /* USESTATEMACROS was defined */

#endif /* USESTATEMACROS was defined */

#endif /*  __CDBState_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\cdbstate.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/CDBSTATE.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 10/23/00 5:35p  $

Purpose:

  This file implements the FC Layer State Machine.

--*/

#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/cdbstate.h"
#include "../h/devstate.h"
#include "../h/cdbsetup.h"
#include "../h/queue.h"
#include "../h/cstate.h"
#include "../h/sfstate.h"
#include "../h/timersvc.h"
#include "../h/cfunc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"
#include "cdbstate.h"
#include "devstate.h"
#include "cdbsetup.h"
#include "queue.h"
#include "cstate.h"
#include "sfstate.h"
#include "timersvc.h"
#include "cfunc.h"
#endif  /* _New_Header_file_Layout_ */


stateTransitionMatrix_t CDBStateTransitionMatrix = {
    /* Event/State 0        State 1          State 2...             */
    CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
      CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
        CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
          CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
            CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
              CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                  CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                    CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                      CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                        CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                          CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                            CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
    CDBStateThreadFree,
      CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
        CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
          CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
            CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
              CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventInitialize 1                      */
    CDBStateInitialize,CDBStateInitialize,0,0,0,
      0,CDBStateReSend_IO,0,0,0,
        0,CDBStateInitialize,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,CDBStateInitialize,0,
                0,CDBStatePending_Abort,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,CDBStateInitialize,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventLocalSGL 2                                                      */
    0,0,CDBStateFillLocalSGL,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventNeedESGL 3                                                      */
    0,0,CDBStateAllocESGL,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventGotESGL 4                                                      */
    0,0,0,0,CDBStateFillESGL, 
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                CDBStateAllocESGL_Abort,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventESGLSendIo 5                                                      */
    0,0,0,0,0, CDBStateSendIo,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventLocalSGLSendIo 6                                                      */
    0,0,0,CDBStateSendIo,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventIoSuccess 7                                                      */
    0,CDBStateInitialize_DR,0,0,0,
      0,CDBStateFcpCompleteSuccess,0,0,0,
        0,0,0,0,0,
          CDBStateFcpCompleteSuccess,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                CDBStatePending_Abort,CDBStatePending_Abort,CDBStatePending_Abort,CDBStateFcpCompleteAbort,0,
                  CDBEvent_CCC_IO_Success,0,0,CDBStateFcpCompleteSuccess,CDBStateFcpCompleteSuccess,
                    CDBStateFcpCompleteSuccess,CDBStateFcpCompleteSuccess,CDBStateFcpCompleteSuccess,CDBStateFcpCompleteSuccess,CDBStateFcpCompleteSuccess,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventIoFailed 8                                                      */
    0,CDBStateInitialize_DR,0,0,0,
      0,CDBStateFcpCompleteFail,0,0,0,
        0,0,0,0,0,
          CDBStateFcpCompleteFail,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                CDBStatePending_Abort,CDBStatePending_Abort,CDBStatePending_Abort,0,0,
                  CDBState_CCC_IO_Fail,0,0,0,CDBStateFcpCompleteFail,
                    CDBStateFcpCompleteFail,CDBStateFcpCompleteFail,CDBStateFcpCompleteFail,CDBStateFcpCompleteFail,CDBStateFcpCompleteFail,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventIoAbort 9                                                      */
    0,CDBStateInitialize_DR,CDBStateInitialize_Abort,CDBStateFillLocalSGL_Abort,CDBStateAllocESGL_Abort,
      CDBStateFillESGL_Abort,CDBStateFcpCompleteAbort,0,0,0,
        0,0,0,CDBStateOOOReceived_Abort,CDBStateOOOFixup_Abort,
          CDBStateFcpCompleteAbort,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,0,0,
                  CDBState_CCC_IO_Fail,0,0,0,CDBStateFcpCompleteAbort,
                    CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventIoOver 10 A                                                   */
    0,CDBStateInitialize_DR,0,0,0,
      0,CDBStateFcpCompleteOver,0,0,0,
        0,0,0,0,0,
          CDBStateFcpCompleteOver,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                CDBStatePending_Abort,CDBStatePending_Abort,CDBStatePending_Abort,0,0,
                  CDBState_CCC_IO_Fail,0,0,CDBStateFcpCompleteOver,CDBStateFcpCompleteOver,
                    CDBStateFcpCompleteOver,CDBStateFcpCompleteOver,CDBStateFcpCompleteOver,CDBStateFcpCompleteOver,CDBStateFcpCompleteOver,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventThreadFree 11 B                                                   */
    0,0,0,0,0,
      0,0,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
        CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,0,0,
          0,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
            CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
              CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,0,CDBStateThreadFree,
                CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                  CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                    CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,CDBStateThreadFree,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventIODeviceReset 12 c                                                    */
    0,CDBStateInitialize_DR,CDBStateInitialize_DR,CDBStateFillLocalSGL_DR,CDBStateAllocESGL_DR,
      CDBStateFillESGL_DR,CDBStateFcpCompleteDeviceReset,0,0,0,
        0,0,0,CDBStateOOOReceived_DR,CDBStateOOOFixup_DR,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                CDBStatePending_Abort,CDBStatePending_Abort,CDBStatePending_Abort,CDBStateFcpCompleteAbort,0,
                  CDBState_CCC_IO_Fail,0,0,CDBStateFcpCompleteDeviceReset,CDBStateFcpCompleteDeviceReset,
                    CDBStateFcpCompleteDeviceReset,CDBStateFcpCompleteDeviceReset,CDBStateFcpCompleteDeviceReset,CDBStateFcpCompleteDeviceReset,CDBStateFcpCompleteDeviceReset,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventOOOReceived 13 d                                                    */
    0,0,0,0,0, 0,CDBStateOOOReceived,0,0,0, 0,0,0,0,0, CDBStateOOOReceived,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventOOOFixup 14 e                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,CDBStateOOOFixup,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventOOOSend 15 f                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,CDBStateOOOSend, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventIoSuccessRSP 16  10                                                  */
    0,CDBStateInitialize_DR,0,0,0,
      0,CDBStateFcpCompleteSuccessRSP,0,0,0,
        0,0,0,0,0,
          CDBStateFcpCompleteSuccessRSP,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                CDBStatePending_Abort,CDBStatePending_Abort,CDBStatePending_Abort,CDBStateFcpCompleteAbort,0,
                  CDBState_CCC_IO_Fail,0,0,0,CDBStateFcpCompleteSuccessRSP,
                    CDBStateFcpCompleteSuccessRSP,CDBStateFcpCompleteSuccessRSP,CDBStateFcpCompleteSuccessRSP,CDBStateFcpCompleteSuccessRSP,CDBStateFcpCompleteSuccessRSP,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventOutBoundError 17  11                                                  */
    0,CDBStateInitialize_DR,0,0,0,
      0,CDBStateOutBoundError,0,0,0,
        0,0,0,0,0,
          CDBStateOutBoundError,0,0,0,0,
            0,0,0,0,0,
              0,0,0,CDBStateOutBoundError,0,
                CDBStatePending_Abort,CDBStatePending_Abort,CDBStatePending_Abort,0,0,
                  CDBStateOutBoundError,CDBState_CCC_IO_Fail,0,0,CDBStateOutBoundError,
                    CDBStateOutBoundError,CDBStateOutBoundError,CDBStateOutBoundError,CDBStateOutBoundError,CDBStateOutBoundError,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventFailNoRSP 18  12                                                  */
    CDBStateInitialize_DR,CDBStateInitialize_DR,0,0,0,
      0,CDBStateFailure_NO_RSP,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,CDBStateInitialize_DR,
                CDBStatePending_Abort,CDBStatePending_Abort,CDBStatePending_Abort,0,0,
                  CDBState_CCC_IO_Fail,0,0,0,CDBStateFailure_NO_RSP,
                    CDBStateFailure_NO_RSP,CDBStateFailure_NO_RSP,CDBStateFailure_NO_RSP,CDBStateFailure_NO_RSP,CDBStateFailure_NO_RSP,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 19 CDBEventAlloc_Abort */
    CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,CDBStateFcpCompleteAbort,
      CDBStateFcpCompleteAbort,CDBStateAlloc_Abort,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,CDBStateAlloc_Abort,0,
                  CDBStateAlloc_Abort,CDBStateAlloc_Abort,CDBStateAlloc_Abort,CDBStateAlloc_Abort,CDBStateAlloc_Abort,
                    CDBStateAlloc_Abort,CDBStateAlloc_Abort,CDBStateAlloc_Abort,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 20 CDBEventDo_Abort */
    0,0,0,0,0, 
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                CDBStateDo_Abort,CDBStatePending_Abort,CDBStateFcpCompleteAbort,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 21 CDBEvent_Abort_Rejected */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,CDBStatePending_Abort,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 22 CDBEvent_PrepareforAbort */
    0,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStateAllocESGL_Abort,
      CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,0,0,0,
        0,0,0,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,
          CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,
            CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,
              CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,0,CDBStatePrepare_For_Abort,
                CDBStatePending_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,
                  CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,
                    CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,CDBStatePrepare_For_Abort,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventDo_CCC_IO       23  */
    CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,
      CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,
        CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,
          CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,
            CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,
              CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,
                CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,CDBStateBuild_CCC_IO,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEvent_CCC_IO_Build   24  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,CDBStateSend_CCC_IO,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEvent_CCC_IO_Success 25  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  CDBState_CCC_IO_Success,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEvent_CCC_IO_Fail    26  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  CDBState_CCC_IO_Fail,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
     0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventREC_TOV 27  */
    0,0,0,0,0,
      0,CDBState_Alloc_REC,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,CDBStateSend_REC,
                    CDBStateSend_SRR,CDBStateSend_REC,CDBStateSend_REC,CDBStateSend_REC,CDBStateSend_REC,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventSendREC_Success 28  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,CDBStatePending_Abort,0,0,
                  0,0,0,CDBState_REC_Success,CDBState_REC_Success,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventSendREC_Fail 29  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,CDBStateSend_REC_Second,CDBStateSend_REC_Second,
                    0,0,0,CDBStateSend_REC_Second,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventSendSRR 30  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,CDBStateSend_SRR,
                    0,0,CDBStateSend_SRR,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventSendSRR_Success 31  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    CDBState_SRR_Success,CDBState_SRR_Success,0,0,CDBState_SRR_Success,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event CDBEventSendSRR_Again 32  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    CDBState_SRR_Fail,0,0,0,CDBStateSend_SRR_Second,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 33 CDBEvent_Got_REC */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      CDBStateSend_REC,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* CDBEvent_ResendIO          34  */
    0,0,0,0,0,
      0,CDBStateSendIo,0,0,0,
        CDBStateReSend_IO,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,CDBStateReSend_IO,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* CDBEventSendSRR_Fail 35  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    CDBState_SRR_Fail,CDBState_SRR_Fail,0,0,CDBStateSend_SRR_Second,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 36                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 37                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 38                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 39                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 40                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 41                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 42                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 43                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 44                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 45                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 46                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 47                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 48                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 49                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 50                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 51                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 52                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 53                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 54                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 55                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 56                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 57                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 58                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 59                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 60                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 61                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 62                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 63                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 64                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 65                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 66                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 67                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 68                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 69                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 70                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 71                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 72                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 73                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 74                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 75                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 76                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 77                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 78                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 79                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 80                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 81                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 82                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 83                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 84                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 85                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 86                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 87                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 88                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 89                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 90                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 91                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 92                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 93                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 94                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 95                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 96                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 97                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 98                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 99                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 100                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 101                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 102                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 103                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 104                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 105                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 106                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 107                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 108                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 109                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 110                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 111                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 112                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 113                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 114                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 115                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 116                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 117                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 118                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 119                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 120                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 121                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 122                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 123                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 124                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 125                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 126                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 127                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    };
/*
stateTransitionMatrix_t copiedCDBStateTransitionMatrix;
*/
stateActionScalar_t CDBStateActionScalar = {
    &CDBActionConfused,                /* 0  */
    &CDBActionThreadFree,              /* 1  */
    &CDBActionInitialize,              /* 2  */
    &CDBActionFillLocalSGL,            /* 3  */
    &CDBActionAllocESGL,               /* 4  */
    &CDBActionFillESGL,                /* 5  */
    &CDBActionSendIo,                  /* 6  */
    &CDBActionFcpCompleteSuccess,      /* 7  */
    &CDBActionFcpCompleteSuccessRSP,   /* 8  */
    &CDBActionFcpCompleteFail,         /* 9  */
    &CDBActionFcpCompleteAbort,        /* 10 */
    &CDBActionFcpCompleteDeviceReset,  /* 11 */
    &CDBActionFcpCompleteOver,         /* 12 */
    &CDBActionOOOReceived,             /* 13 */
    &CDBActionOOOFixup,                /* 14 */
    &CDBActionOOOSend,                 /* 15 */
    &CDBActionInitialize_DR,           /* 16 */
    &CDBActionFillLocalSGL_DR,         /* 17 */
    &CDBActionAllocESGL_DR,            /* 18 */
    &CDBActionFillESGL_DR,             /* 19 */
    &CDBActionInitialize_Abort,        /* 20 */
    &CDBActionFillLocalSGL_Abort,      /* 21 */
    &CDBActionAllocESGL_Abort,         /* 22 */
    &CDBActionFillESGL_Abort,          /* 23 */
    &CDBActionOOOReceived_Abort,       /* 24 */
    &CDBActionOOOReceived_DR,          /* 25 */
    &CDBActionOOOFixup_Abort,          /* 26 */
    &CDBActionOOOFixup_DR,             /* 27 */
    &CDBActionOutBoundError,           /* 28 */
    &CDBActionFailure_NO_RSP,          /* 29 */
    &CDBActionAlloc_Abort,
    &CDBActionDo_Abort,
    &CDBActionPending_Abort,
    &CDBActionPrepare_For_Abort,
    &CDBActionBuild_CCC_IO,
    &CDBActionSend_CCC_IO,
    &CDBAction_CCC_IO_Success,
    &CDBAction_CCC_IO_Fail,
    &CDBActionSend_REC,
    &CDBActionSend_REC_Second,
    &CDBActionSend_SRR,
    &CDBActionSend_SRR_Second,
    &CDBAction_REC_Success,
    &CDBAction_SRR_Success,
    &CDBAction_SRR_Fail,
    &CDBAction_Alloc_REC,
    &CDBActionDO_Nothing,
    &CDBActionReSend_IO,
    &CDBActionConfused,
    &CDBActionConfused,
    &CDBActionConfused
    };

/*
stateActionScalar_t copiedCDBStateActionScalar;
*/

#define testCDBCompareBase 0x00000110

#ifndef __State_Force_Static_State_Tables__
actionUpdate_t CDBTestActionUpdate[] = {
                              {0,          0,      agNULL,                 agNULL}
                     };
#endif /* __State_Force_Static_State_Tables__ was not defined */

#define TIMEOUT_VALUE 6250
/*
#define TEST_REC
*/
#ifndef USESTATEMACROS

/*+

   Function: CDBActionConfused

    Purpose: Terminating State for error detection
  Called By: Any State/Event pair that does not have a assign action.
             This function is called only in programming error condtions.
      Calls: <none>

-*/
/* CDBStateConfused           0 */
extern void CDBActionConfused(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t *   pCDBThread =    (CDBThread_t * )thread;
    DevThread_t *   pDevThread =    pCDBThread->Device;

    /* pCThread->CDBpollingCount--; */

    fiLogString(thread->hpRoot,
                    "CDBActionConfused",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X X_ID %X",
                    "CDBActionConfused",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);

    if(! fiListElementOnList(  &(pCDBThread->CDBLink),
                               &(CThread_ptr(thread->hpRoot)->Free_CDBLink)))
    {
        pCDBThread->ExchActive = agFALSE;
        CDBThreadFree( thread->hpRoot,pCDBThread);
    }
}

/*+

   Function: CDBActionThreadFree

    Purpose: Terminating State releases CDBThread for reuse.
  Called By: Any State/Event pair that has finished using a CDBThread.
      Calls: CDBThreadFree

-*/
/* CDBStateThreadFree         1 */
extern void CDBActionThreadFree(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t *   pCDBThread =    (CDBThread_t * )thread;
    DevThread_t *   pDevThread =    pCDBThread->Device;

#ifndef Performance_Debug
    fiLogDebugString(thread->hpRoot,
                    CDBStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionThreadFree",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);
#endif /* Performance_Debug */

    fiSetEventRecordNull(eventRecord);

    CDBThreadFree( thread->hpRoot,pCDBThread);
}

/*+

   Function: CDBActionInitialize

    Purpose: Initial State of CDBThread. Calculates number of memory segments
             needed by IO request.
  Called By: DevAction_IO_Ready
      Calls: Number memory segments 
                error           CDBEventConfused
                Need ESGL       CDBEventNeedESGL
                Use Local SGL   CDBEventLocalSGL
-*/
/* CDBStateInitialize         2 */
extern void CDBActionInitialize( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    event_t event_to_send    = CDBEventLocalSGL;

    os_bit32 Chunks=0;
    os_bit32 GetSGLStatus =0;
    os_bit32     hpChunkOffset=0;
    os_bit32     hpChunkUpper32;
    os_bit32     hpChunkLower32;
    os_bit32     hpChunkLen;
    os_bit32     DataLength;

    os_bit32         SG_Cache_Offset = 0;
    os_bit32         SG_Cache_Used   = 0;
    os_bit32         SG_Cache_MAX    = CThread_ptr(thread->hpRoot)->Calculation.Parameters.SizeCachedSGLs;
    SG_Element_t *SG_Cache_Ptr       = &(pCDBThread->SG_Cache[0]);
    os_bit32         hpIOStatus;
    os_bit32         hpIOInfoLen = 0;

    os_bit32 ChunksPerESGL = CThread_ptr(thread->hpRoot)->Calculation.MemoryLayout.ESGL.elementSize/sizeof(SG_Element_t) - 1;

/*
    if( pCDBThread->ReSentIO )
    {
        fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "In %s - State = %d ALPA %X ReSentIO",
                        "CDBActionInitialize",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        fiComputeDevThread_D_ID(pDevThread),
                        0,0,0,0,0,0);
    }

*/
    if (pCDBThread->CDBRequest->FcpCmnd.FcpCntl[3] & agFcpCntlReadData)
    {
        pCDBThread->ReadWrite  =  CDBThread_Read;
    }
    else /* !(pCDBThread->CDBRequest->FcpCmnd.FcpCntl[3] & agFcpCntlReadData) */
    {
        pCDBThread->ReadWrite  =  CDBThread_Write;
    }

    DataLength = pCDBThread->DataLength;

    CThread_ptr(thread->hpRoot)->FuncPtrs.fiFillInFCP_CMND(pCDBThread);
    CThread_ptr(thread->hpRoot)->FuncPtrs.fiFillInFCP_RESP(pCDBThread);
    CThread_ptr(thread->hpRoot)->FuncPtrs.fiFillInFCP_SEST(pCDBThread);

    while( hpChunkOffset < DataLength ){
        GetSGLStatus = osGetSGLChunk( thread->hpRoot,
                         pCDBThread->hpIORequest,
                         hpChunkOffset,
                         &hpChunkUpper32,
                         &hpChunkLower32,
                         &hpChunkLen
                         );

        if (hpChunkLen > SG_Element_Len_MAX)
        {
            fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "%s hpChunkLen %X hpChunkOffset %X hpChunkUpper32 %X hpChunkLower32 %X",
                    "CDBActionInitialize",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    hpChunkLen,
                    hpChunkOffset,
                    hpChunkUpper32,
                    hpChunkLower32,
                    0,0,0,0);

            hpChunkLen = SG_Element_Len_MAX;

        }

        if (hpChunkLen == 0)
        {
            fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "%s hpChunkLen %X hpChunkOffset %X hpChunkUpper32 %X hpChunkLower32 %X",
                    "CDBActionInitialize",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    hpChunkLen,
                    hpChunkOffset,
                    hpChunkUpper32,
                    hpChunkLower32,
                    0,0,0,0);
        }

        if (SG_Cache_Used < SG_Cache_MAX)
        {
            SG_Cache_Ptr->U32_Len = (hpChunkUpper32 << SG_Element_U32_SHIFT) | hpChunkLen;
            SG_Cache_Ptr->L32     = hpChunkLower32;

            SG_Cache_Offset += hpChunkLen;
            SG_Cache_Used   += 1;
            SG_Cache_Ptr    += 1;
        }

        if(GetSGLStatus)
        {
            hpIOStatus = osIOInfoBad;
            osIOCompleted( thread->hpRoot,
               pCDBThread->hpIORequest,
               hpIOStatus,
               hpIOInfoLen);

            Device_IO_Throttle_Decrement
            event_to_send=CDBEventConfused;
            break;
        }
        hpChunkOffset+=hpChunkLen;
        Chunks++;

    }

    pCDBThread->SG_Cache_Offset = SG_Cache_Offset;
    pCDBThread->SG_Cache_Used   = SG_Cache_Used;

    if(event_to_send != CDBEventConfused )
    {
        if(Chunks > 3)
        {
            event_to_send=CDBEventNeedESGL;
            pCDBThread->ESGL_Request.num_ESGL = (Chunks + ChunksPerESGL - 1) / ChunksPerESGL;
        }
        else pCDBThread->ESGL_Request.num_ESGL = 0;

    }

#ifndef Performance_Debug
    fiLogDebugString(thread->hpRoot,
                    CDBStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X ESGL req %x",
                    "CDBActionInitialize",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->ESGL_Request.num_ESGL,0,0,0,0,0);

#endif /* Performance_Debug */

    fiSetEventRecord(eventRecord,thread,event_to_send);
}

/*+

   Function: CDBActionFillLocalSGL

    Purpose: Copies result of SGL calculation to SEST entry. 
  Called By: CDBActionInitialize
      Calls: CDBEventLocalSGLSendIo
-*/
/* CDBStateFillLocalSGL       3 */
extern void CDBActionFillLocalSGL( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;

    CThread_ptr(thread->hpRoot)->FuncPtrs.fillLocalSGL(pCDBThread);

#ifndef Performance_Debug

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionFillLocalSGL",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

#endif /* Performance_Debug */

    fiSetEventRecord(eventRecord,thread,CDBEventLocalSGLSendIo);
}

/*+

   Function: CDBActionAllocESGL

    Purpose: Requests ESGL pages calculated in CDBActionInitialize.
  Called By: CDBActionInitialize
      Calls: ESGLAlloc sends event CDBEventGotESGL when all resources are available
-*/
/* CDBStateAllocESGL          4 */
extern void CDBActionAllocESGL( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;

    ESGL_Request_t *pESGL_Request = &pCDBThread->ESGL_Request;

    pESGL_Request->eventRecord_to_send.thread= thread;
    pESGL_Request->eventRecord_to_send.event= CDBEventGotESGL;

#ifndef Performance_Debug
    fiLogDebugString(thread->hpRoot,
                    CDBStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionAllocESGL",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

#endif /* Performance_Debug */

    CThread_ptr(thread->hpRoot)->FuncPtrs.ESGLAlloc( thread->hpRoot,pESGL_Request );

    fiSetEventRecordNull(eventRecord);

}

/*+

   Function: CDBActionFillESGL

    Purpose: Fills Requested ESGL pages calculated in CDBActionInitialize.
  Called By: CDBActionAllocESGL
      Calls: CDBEventESGLSendIo

-*/
/* CDBStateFillESGL           5 */
extern void CDBActionFillESGL( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;

    CThread_ptr(thread->hpRoot)->FuncPtrs.upSEST(pCDBThread);
    CThread_ptr(thread->hpRoot)->FuncPtrs.fillESGL(pCDBThread);
#ifndef Performance_Debug

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionFillESGL",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);
#endif /* Performance_Debug */

    fiSetEventRecord(eventRecord,thread,CDBEventESGLSendIo);
}

/*+

   Function: CDBActionSendIo

    Purpose: Fills all remaining information to send IO.
  Called By: CDBActionFillESGL or CDBActionFillLocalSGL
      Calls: WaitForERQ
             CDBFuncIRB_Init
             SENDIO
-*/
/* CDBStateSendIo             6 */
extern void CDBActionSendIo(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t        * hpRoot        = thread->hpRoot;
    CThread_t       * pCThread      = CThread_ptr(hpRoot);
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;

    pCThread->FuncPtrs.WaitForERQ( hpRoot );

    pCThread->FuncPtrs.CDBFuncIRB_Init(pCDBThread);

    pCDBThread->SentERQ   =  pCThread->HostCopy_ERQProdIndex;

    if( pCDBThread->CDB_CMND_Type != SFThread_SF_CMND_Type_CDB_FC_Tape)
    {
/*
        fiLogString(hpRoot,
                    "Startio X_ID %X  CDB Class %2X Type %2X State %2X Status %2X Time %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->X_ID,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    pCDBThread->TimeStamp,
                    0,0);
*/
        pCDBThread->TimeStamp =  osTimeStamp(hpRoot);

    }
    else
    {
/****************** FC Tape ******************************************/


       if( pCDBThread->CDB_CMND_Type == SFThread_SF_CMND_Type_CDB_FC_Tape)
        {

             fiLogString(hpRoot,
                    "Startio Dev %02X Cl %2X Ty %2X St %2X Stat %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);

            if( pCDBThread->CDB_CMND_State == SFThread_SF_CMND_State_CDB_FC_Tape_ReSend)
            {/* ReSend command */ 

                if (pCDBThread->ReadWrite == CDBThread_Read)
                {
                }
                else /* CDBThread->ReadWrite == CDBThread_Write */
                {
                    USE_t           * SEST          = &( pCDBThread->SEST_Ptr->USE);
                    FCHS_t          * FCHS          = pCDBThread->FCP_CMND_Ptr;
                    fiMemMapMemoryDescriptor_t *ERQ = &(pCThread->Calculation.MemoryLayout.ERQ);
                    IRB_t                      *pIrb;

 
                    pIrb = (IRB_t *)ERQ->addr.DmaMemory.dmaMemoryPtr;
                    pIrb += pCThread->HostCopy_ERQProdIndex;

                    SEST->Bits &= 0x00FFFFFF;
                    SEST->Bits |=  (IWE_VAL | IWE_INI | IWE_DAT | IWE_RSP);
                    SEST->Unused_DWord_6 = pCDBThread->FC_Tape_RXID;


                    pIrb->Req_A.Bits__SFS_Len   &= ~IRB_SFA;

                    fiLogDebugString(hpRoot,
                                    SFStateLogErrorLevel,
                                    "Sest DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    SEST->Bits,
                                    SEST->Unused_DWord_1,
                                    SEST->Unused_DWord_2,
                                    SEST->Unused_DWord_3,
                                    SEST->LOC,
                                    SEST->Unused_DWord_5,
                                    SEST->Unused_DWord_6,
                                    SEST->Unused_DWord_7);

                    fiLogDebugString(hpRoot,
                                    SFStateLogErrorLevel,
                                    "FCHS DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                                    (char *)agNULL,(char *)agNULL,
                                     (void *)agNULL,(void *)agNULL,
                                    FCHS->MBZ1,
                                    FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                                    FCHS->R_CTL__D_ID,
                                    FCHS->CS_CTL__S_ID,
                                    FCHS->TYPE__F_CTL,
                                    FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                                    FCHS->OX_ID__RX_ID,
                                    FCHS->RO );

                    fiLogDebugString(hpRoot,
                                    SFStateLogErrorLevel,
                                    "IRB  DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    pIrb->Req_A.Bits__SFS_Len,
                                    pIrb->Req_A.SFS_Addr,
                                    pIrb->Req_A.D_ID,
                                    pIrb->Req_A.MBZ__SEST_Index__Trans_ID,
                                    0,0,0,0);

                    fiListDequeueThis(&(pCDBThread->CDBLink));

                    fiListEnqueueAtTail( &(pCDBThread->CDBLink),&(pDevThread->Active_CDBLink_1) );


                }
            }/* End if( pCDBThread->CDB_CMND_State == SFThread_SF_CMND_State_CDB_FC_Tape_ReSend)*/
            else
            {
                if( pCDBThread->CDB_CMND_State == SFThread_SF_CMND_State_CDB_FC_Tape_GotXRDY)
                {/* Re send data  */ 
                    USE_t           * SEST          = &( pCDBThread->SEST_Ptr->USE);
                    FCHS_t          * FCHS          = pCDBThread->FCP_CMND_Ptr;
                    fiMemMapMemoryDescriptor_t *ERQ = &(pCThread->Calculation.MemoryLayout.ERQ);
                    IRB_t                      *pIrb;

                    fiLogString(hpRoot,
                                    "SFThread_SF_CMND_State_CDB_FC_Tape_GotXRDY",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    0,0,0,0,0,0,0,0 );


                    pIrb = (IRB_t *)ERQ->addr.DmaMemory.dmaMemoryPtr;
                    pIrb += pCThread->HostCopy_ERQProdIndex;

                    SEST->Bits &= 0x00FFFFFF;
                    SEST->Bits |=  (IWE_VAL | IWE_INI | IWE_DAT | IWE_RSP);
                    SEST->Unused_DWord_6 = pCDBThread->FC_Tape_RXID;


                    pIrb->Req_A.Bits__SFS_Len   &= ~IRB_SFA;

                    fiLogDebugString(hpRoot,
                                    SFStateLogErrorLevel,
                                    "Sest DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    SEST->Bits,
                                    SEST->Unused_DWord_1,
                                    SEST->Unused_DWord_2,
                                    SEST->Unused_DWord_3,
                                    SEST->LOC,
                                    SEST->Unused_DWord_5,
                                    SEST->Unused_DWord_6,
                                    SEST->Unused_DWord_7);

                    fiLogDebugString(hpRoot,
                                    SFStateLogErrorLevel,
                                    "FCHS DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                                    (char *)agNULL,(char *)agNULL,
                                     (void *)agNULL,(void *)agNULL,
                                    FCHS->MBZ1,
                                    FCHS->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp,
                                    FCHS->R_CTL__D_ID,
                                    FCHS->CS_CTL__S_ID,
                                    FCHS->TYPE__F_CTL,
                                    FCHS->SEQ_ID__DF_CTL__SEQ_CNT,
                                    FCHS->OX_ID__RX_ID,
                                    FCHS->RO );

                    fiLogDebugString(hpRoot,
                                    SFStateLogErrorLevel,
                                    "IRB  DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    pIrb->Req_A.Bits__SFS_Len,
                                    pIrb->Req_A.SFS_Addr,
                                    pIrb->Req_A.D_ID,
                                    pIrb->Req_A.MBZ__SEST_Index__Trans_ID,
                                    0,0,0,0);

                    fiListDequeueThis(&(pCDBThread->CDBLink));

                    fiListEnqueueAtTail( &(pCDBThread->CDBLink),&(pDevThread->Active_CDBLink_1) );

                }
            }
        } /****************** FC Tape ******************************************/
    }

    pCDBThread->CDBStartTimeBase = pCThread->TimeBase;

    ROLL(pCThread->HostCopy_ERQProdIndex,
        pCThread->Calculation.MemoryLayout.ERQ.elements);

    SENDIO(hpRoot,pCThread,thread,DoFuncCdbCmnd);

#ifndef Performance_Debug

    fiLogDebugString(hpRoot,
                    CDBStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X CCnt %x X_ID %X ERQ %X",
                    "CDBActionSendIo",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCThread->CDBpollingCount,
                    pCDBThread->X_ID,
                    pCThread->HostCopy_ERQProdIndex,
                    0,0,0);
#endif /* Performance_Debug */

    fiSetEventRecordNull(eventRecord);

}

/*+
  Function: CDBActionFcpCompleteSuccess

   Purpose: Successful IO completion hpIOInfoLen set to zero indicating oslayer does not
            need to access response buffer information.
 Called By: CFuncProcessFcpRsp CFuncSEST_ off / on Card_FCPCompletion
     Calls: osIOCompleted 
            CDBEventThreadFree
-*/
/* CDBStateFcpCompleteSuccess 7 */
extern void CDBActionFcpCompleteSuccess( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus     = osIOSuccess;
    os_bit32 hpIOInfoLen = 0;

    /* CThread_ptr(thread->hpRoot)->CDBpollingCount--; */
#ifndef Performance_Debug

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionFcpCompleteSuccess",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);
    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "Good",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);

        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }
#endif /* Performance_Debug */

#ifdef FULL_FC_TAPE_DBG

    if (pCDBThread->FC_Tape_Active)
    {
        fiLogDebugString(thread->hpRoot,
                    CFuncLogConsoleERROR,
                    "%d Found a FC_Tape_Active cbdthread %p X_ID %X",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread,agNULL,
                    (os_bit32)thread->currentState,
                    pCDBThread->X_ID,                    
                    0,0,0,0,0,0);

         fiLogDebugString(thread->hpRoot,
                    CFuncLogConsoleERROR,
                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);
        

        if (pCDBThread->ReadWrite == CDBThread_Read)
        {

            if(pCDBThread->DataLength - pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt != pCDBThread->SEST_Ptr->IRE.Byte_Count)
            {
                fiLogDebugString(thread->hpRoot,
                            CFuncLogConsoleERROR,
                            "Byte Count %08X Exp %08X %s DataLength %X",
                            "Read",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCDBThread->SEST_Ptr->IRE.Byte_Count,
                            pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt,
                            pCDBThread->DataLength,
                            0,0,0,0,0);
            }
        }
        else
        {
            if(pCDBThread->DataLength - pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt != pCDBThread->SEST_Ptr->IWE.Data_Len)
            {
                fiLogDebugString(thread->hpRoot,
                        CFuncLogConsoleERROR,
                        "Byte Count %08X Exp %08X %s DataLength %X",
                        "Write",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCDBThread->SEST_Ptr->IWE.Data_Len,
                        pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt,
                        pCDBThread->DataLength,
                        0,0,0,0,0);
            }
        }
    }

#endif /* FULL_FC_TAPE_DBG */

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );

    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionFcpCompleteSuccessRSP

    Purpose: Does completion on Succesful IO that have response buffer 
             information to return.
  Called By: CFuncProcessFcpRsp CFuncSEST_ off / on Card_FCPCompletion
      Calls: osIOCompleted 
             CDBEventThreadFree
-*/
/* CDBStateFcpCompleteSuccessRSP 8 */
extern void CDBActionFcpCompleteSuccessRSP( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIOSuccess;
    os_bit32 hpIOInfoLen = CThread_ptr(thread->hpRoot)->Calculation.MemoryLayout.FCP_RESP.elementSize;
    os_bit32 ERQ_Entry = 0;

    /* CThread_ptr(thread->hpRoot)->CDBpollingCount--; */

    ERQ_Entry = CFunc_Get_ERQ_Entry( thread->hpRoot, pCDBThread->X_ID );

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X ERQ %X SERQ %X",
                    "CDBActionFcpCompleteSuccessRSP",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    ERQ_Entry,
                    pCDBThread->SentERQ,
                    0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "Good RSP",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    if (pCDBThread->FC_Tape_Active)
    {
        fiLogDebugString(thread->hpRoot,
                    CFuncLogConsoleERROR,
                    "%d Found a FC_Tape_Active cbdthread %p X_ID %X",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread,agNULL,
                    (os_bit32)thread->currentState,
                    pCDBThread->X_ID,                    
                    0,0,0,0,0,0);

         fiLogDebugString(thread->hpRoot,
                    CFuncLogConsoleERROR,
                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);
        

        if (pCDBThread->ReadWrite == CDBThread_Read)
        {

            if(pCDBThread->DataLength - pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt != pCDBThread->SEST_Ptr->IRE.Byte_Count)
            {
                fiLogDebugString(thread->hpRoot,
                            CFuncLogConsoleERROR,
                            "Byte Count %08X Exp %08X %s DataLength %X",
                            "Read",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCDBThread->SEST_Ptr->IRE.Byte_Count,
                            pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt,
                            pCDBThread->DataLength,
                            0,0,0,0,0);
            }
        }
        else
        {
            if(pCDBThread->DataLength - pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt != pCDBThread->SEST_Ptr->IWE.Data_Len)
            {
                fiLogDebugString(thread->hpRoot,
                        CFuncLogConsoleERROR,
                        "Byte Count %08X Exp %08X %s DataLength %X",
                        "Write",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCDBThread->SEST_Ptr->IWE.Data_Len,
                        pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt,
                        pCDBThread->DataLength,
                        0,0,0,0,0);
            }
        }
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionFcpCompleteFail

    Purpose: Does completion on failed IO that have response buffer 
             information to return.
  Called By: CFuncProcessFcpRsp CFuncSEST_ off / on Card_FCPCompletion
             CFuncOutBoundCompletion
             CFunc_LOGO_Completion

      Calls: osIOCompleted 
             CDBEventThreadFree
-*/
/* CDBStateFcpCompleteFail    9 */
extern void CDBActionFcpCompleteFail( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIOFailed;
    os_bit32 hpIOInfoLen = CThread_ptr(thread->hpRoot)->Calculation.MemoryLayout.FCP_RESP.elementSize;

    /* CThread_ptr(thread->hpRoot)->CDBpollingCount--; */

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X ExchActive %X",
                    "CDBActionFcpCompleteFail",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    pCDBThread->ExchActive,
                    0,0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "Fail",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);

    }

    if (pCDBThread->FC_Tape_Active)
    {
        fiLogDebugString(thread->hpRoot,
                    CFuncLogConsoleERROR,
                    "%d Found a FC_Tape_Active cbdthread %p X_ID %X",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread,agNULL,
                    (os_bit32)thread->currentState,
                    pCDBThread->X_ID,                    
                    0,0,0,0,0,0);

         fiLogDebugString(thread->hpRoot,
                    CFuncLogConsoleERROR,
                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);
        

        if (pCDBThread->ReadWrite == CDBThread_Read)
        {

            if(pCDBThread->DataLength - pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt != pCDBThread->SEST_Ptr->IRE.Byte_Count)
            {
                fiLogDebugString(thread->hpRoot,
                            CFuncLogConsoleERROR,
                            "Byte Count %08X Exp %08X %s DataLength %X",
                            "Read",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCDBThread->SEST_Ptr->IRE.Byte_Count,
                            pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt,
                            pCDBThread->DataLength,
                            0,0,0,0,0);
            }
        }
        else
        {
            if(pCDBThread->DataLength - pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt != pCDBThread->SEST_Ptr->IWE.Data_Len)
            {
                fiLogDebugString(thread->hpRoot,
                        CFuncLogConsoleERROR,
                        "Byte Count %08X Exp %08X %s DataLength %X",
                        "Write",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCDBThread->SEST_Ptr->IWE.Data_Len,
                        pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt,
                        pCDBThread->DataLength,
                        0,0,0,0,0);
            }
        }
    }


    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionFcpCompleteAbort

    Purpose: Does completion on IO that have  been aborted.
  Called By: SFActionAbortAccept
             SFActionAbortRej
             SFActionAbortBadALPA
             SFActionAbortTimedOut
      Calls: osIOCompleted 
             CDBEventThreadFree
-*/
/* CDBStateFcpCompleteAbort   10 */
extern void CDBActionFcpCompleteAbort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus         = pCDBThread->CompletionStatus;
    os_bit32 hpIOInfoLen = 0;

    /* CThread_ptr(thread->hpRoot)->CDBpollingCount--; */

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X @ %d Status %x",
                    "CDBActionFcpCompleteAbort",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    pCDBThread->TimeStamp,
                    pCDBThread->CompletionStatus,
                    0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "Abort",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);

    }

    if(pCDBThread->FC_Tape_CompletionStatus == CdbCompetionStatusReSendIO)
    {
        fiSetEventRecord(eventRecord,thread,CDBEvent_ResendIO);
    }
    else
    {

        osIOCompleted( thread->hpRoot,
                       pCDBThread->hpIORequest,
                       hpIOStatus,
                       hpIOInfoLen
                      );
        Device_IO_Throttle_Decrement
        pCDBThread->ExchActive = agFALSE;
        fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
    }
}

/*+
   Function: CDBActionFcpCompleteDeviceReset

    Purpose: Does completion on IO that have  been reset.
  Called By: CFuncOutBoundCompletion
             CFuncCompleteAllActiveCDBThreads with CDBEventIODeviceReset
             CFuncCompleteActiveCDBThreadsOnDevice with CDBEventIODeviceReset
      Calls: osIOCompleted 
             CDBEventThreadFree
-*/
/* CDBStateFcpCompleteDeviceReset  11 */
extern void CDBActionFcpCompleteDeviceReset( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIODevReset;
    os_bit32 hpIOInfoLen = 0;

    /* CThread_ptr(thread->hpRoot)->CDBpollingCount--; */

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "(%p)In %s State = %d CCnt %x ALPA %X X_ID %X @ %d",
                    "CDBActionFcpCompleteDeviceReset",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    CThread_ptr(thread->hpRoot)->CDBpollingCount,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    pCDBThread->TimeStamp,
                    0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "Reset",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionFcpCompleteOver

    Purpose: Does completion on IO that have mismatch with request data length 
             and actual data length.
  Called By: CFuncProcessFcpRsp CFuncSEST_ off / on Card_FCPCompletion
      Calls: osIOCompleted 
             CDBEventThreadFree
-*/
/* CDBStateFcpCompleteOver   12 */
extern void CDBActionFcpCompleteOver( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
/*
    os_bit32    *  fcprsp= ( os_bit32 * )pCDBThread->FCP_RESP_Ptr;
*/
    os_bit32 hpIOStatus = osIOOverUnder;
    os_bit32 hpIOInfoLen = CThread_ptr(thread->hpRoot)->Calculation.MemoryLayout.FCP_RESP.elementSize;

    /* CThread_ptr(thread->hpRoot)->CDBpollingCount--; */
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleErrorOverRun,
                    "(%p)In %s - State = %d ALPA %X X_ID %X",
                    "CDBActionFcpCompleteOver",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);

    if (pCDBThread->FC_Tape_Active)
    {
        fiLogDebugString(thread->hpRoot,
                    CFuncLogConsoleERROR,
                    "%d Found a FC_Tape_Active cbdthread %p X_ID %X",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread,agNULL,
                    (os_bit32)thread->currentState,
                    pCDBThread->X_ID,                    
                    0,0,0,0,0,0);

         fiLogDebugString(thread->hpRoot,
                    CFuncLogConsoleERROR,
                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);
        

        if (pCDBThread->ReadWrite == CDBThread_Read)
        {

            if(pCDBThread->DataLength - pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt != pCDBThread->SEST_Ptr->IRE.Byte_Count)
            {
                fiLogDebugString(thread->hpRoot,
                            CFuncLogConsoleERROR,
                            "Byte Count %08X Exp %08X %s DataLength %X",
                            "Read",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCDBThread->SEST_Ptr->IRE.Byte_Count,
                            pCDBThread->SEST_Ptr->IRE.Exp_Byte_Cnt,
                            pCDBThread->DataLength,
                            0,0,0,0,0);
            }
        }
        else
        {
            if(pCDBThread->DataLength - pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt != pCDBThread->SEST_Ptr->IWE.Data_Len)
            {
                fiLogDebugString(thread->hpRoot,
                        CFuncLogConsoleERROR,
                        "Byte Count %08X Exp %08X %s DataLength %X",
                        "Write",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCDBThread->SEST_Ptr->IWE.Data_Len,
                        pCDBThread->SEST_Ptr->IWE.Exp_Byte_Cnt,
                        pCDBThread->DataLength,
                        0,0,0,0,0);
            }
        }
    }



/*
    fiLogString(thread->hpRoot,
                    "FCHS  0 %08X %08X %08X %08X %08X %08X %08X %08X",
                    (char *)NULL,(char *)NULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32(*(fcprsp+0)),
                    hpSwapBit32(*(fcprsp+1)),
                    hpSwapBit32(*(fcprsp+2)),
                    hpSwapBit32(*(fcprsp+3)),
                    hpSwapBit32(*(fcprsp+4)),
                    hpSwapBit32(*(fcprsp+5)),
                    hpSwapBit32(*(fcprsp+6)),
                    hpSwapBit32(*(fcprsp+7))
                    );
    fiLogString(thread->hpRoot,
                    "RSP   0 %08X %08X  %08X %08X %08X %08X %08X %08X",
                    (char *)NULL,(char *)NULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32(*(fcprsp+8)),
                    hpSwapBit32(*(fcprsp+9)),
                    hpSwapBit32(*(fcprsp+10)),
                    hpSwapBit32(*(fcprsp+11)),
                    hpSwapBit32(*(fcprsp+12)),
                    hpSwapBit32(*(fcprsp+13)),
                    hpSwapBit32(*(fcprsp+14)),
                    hpSwapBit32(*(fcprsp+15))
                    );
    fiLogString(thread->hpRoot,
                    "RSP  9 %08X %08X %08X %08X %08X %08X %08X %08X",
                    (char *)NULL,(char *)NULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32(*(fcprsp+16)),
                    hpSwapBit32(*(fcprsp+17)),
                    hpSwapBit32(*(fcprsp+18)),
                    hpSwapBit32(*(fcprsp+19)),
                    hpSwapBit32(*(fcprsp+20)),
                    hpSwapBit32(*(fcprsp+21)),
                    hpSwapBit32(*(fcprsp+22)),
                    hpSwapBit32(*(fcprsp+23))
                    );

    *(fcprsp+10) = FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RESID_OVER << 16;
                    
    *(fcprsp+11) = ~*(fcprsp+11);

    fiLogString(thread->hpRoot,
                    "Status   %08X Resid %X", 
                    (char *)NULL,(char *)NULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32(*(fcprsp+10)),
                    hpSwapBit32(*(fcprsp+11)),
                    0,0,0,0,0,0);

*/
    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "Over",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionOOOReceived

    Purpose: Place holder state for Out Of Order Data reception.
  Called By: None
      Calls: CDBEventOOOFixup
             
-*/
/*  CDBStateOOOReceived  13 */
extern void CDBActionOOOReceived( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionOOOReceived",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);


    fiSetEventRecord(eventRecord,thread,CDBEventOOOFixup);
}

/*+
   Function: CDBActionOOOReceived

    Purpose: Place holder state for Out Of Order Data reception.
  Called By: None
      Calls: CDBEventOOOSend
             
-*/
/* CDBStateOOOFixup   14 */
extern void CDBActionOOOFixup( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionOOOFixup",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,CDBEventOOOSend);
}

/*+
   Function: CDBActionOOOSend

    Purpose: Place holder state for Out Of Order Data reception.
  Called By: None
      Calls: Terminating
             
-*/
/* CDBStateOOOSend   15 */
extern void CDBActionOOOSend( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionOOOSend",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

/*+
   Function: CDBActionInitialize_DR

    Purpose: Place holder state for receiving  Device Reset Event .while in CDBActionInitialize
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
            
             
-*/
/* CDBStateInitialize_DR   16 */
extern void CDBActionInitialize_DR( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus      = pCDBThread->CompletionStatus;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionInitialize_DR",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "DR I",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionFillLocalSGL_DR

    Purpose: Place holder state for receiving Device Reset Event while in CDBActionFillLocalSGL_DR
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/* CDBStateFillLocalSGL_DR   17 */
extern void CDBActionFillLocalSGL_DR( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIODevReset;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionFillLocalSGL_DR",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "DR LSGL",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionAllocESGL_DR 

    Purpose: Place holder state for receiving Device Reset Event while in CDBActionAllocESGL
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/* CDBStateAllocESGL_DR   18 */
extern void CDBActionAllocESGL_DR( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIODevReset;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionAllocESGL_DR",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);
/*
    ESGLAllocCancel(thread->hpRoot,&pCDBThread->ESGL_Request);
*/
    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "DR ESGL",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);

    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionFillESGL_DR 

    Purpose: Place holder state for receiving Device Reset Event while in CDBActionFillESGL
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/*  CDBStateFillESGL_DR  19 */
extern void CDBActionFillESGL_DR( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIODevReset;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionFillESGL_DR",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "DR F ESGL",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);

    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionInitialize_Abort 

    Purpose: Place holder state for receiving abort Event while in CDBActionInitialize
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/* CDBStateInitialize_Abort   20 */
extern void CDBActionInitialize_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIOAborted;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionInitialize_Abort",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);


    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "A I",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionFillLocalSGL_Abort 

    Purpose: Place holder state for receiving abort Event while in CDBActionFillLocalSGL
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/* CDBStateFillLocalSGL_Abort  21 */
extern void CDBActionFillLocalSGL_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIOAborted;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionFillLocalSGL_Abort",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);


    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "A FLSGL",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionAllocESGL_Abort 

    Purpose: Place holder state for receiving abort Event while in CDBActionAllocESGL
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/* CDBStateAllocESGL_Abort   22 */
extern void CDBActionAllocESGL_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIOAborted;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionAllocESGL_Abort",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);
    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "A ESGL",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionFillESGL_Abort 

    Purpose: Place holder state for receiving abort Event while in CDBActionFillESGL
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/*  CDBStateFillESGL_Abort  23 */
extern void CDBActionFillESGL_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIOAborted;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionFillESGL_Abort",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);


    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "A F ESGL",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }


    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionOOOReceived_Abort 

    Purpose: Place holder state for receiving abort Event while in CDBActionOOOReceived
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/* CDBStateOOOReceived_Abort   24 */
extern void CDBActionOOOReceived_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIOAborted;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionOOOReceived_Abort",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "A OOO",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionOOOReceived_DR 

    Purpose: Place holder state for receiving Device Reset Event while in CDBActionOOOReceived
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/*  CDBStateOOOReceived_DR  25 */
extern void CDBActionOOOReceived_DR( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIODevReset;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionOOOReceived_DR",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "DR OOO",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionOOOFixup_Abort 

    Purpose: Place holder state for receiving abort Event while in CDBActionOOOFixup
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/* CDBStateOOOFixup_Abort   26 */
extern void CDBActionOOOFixup_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIOAborted;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "In %s - State = %d ALPA %X",
                    "CDBActionOOOFixup_Abort",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "A F OOO",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }


    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionOOOFixup_DR 

    Purpose: Place holder state for receiving Device Reset Event while in CDBActionOOOFixup
  Called By: None Not possible to be in this state at Device Reset time.
      Calls: osIOCompleted CDBEventThreadFree
-*/
/*  CDBStateOOOFixup_DR  27 */
extern void CDBActionOOOFixup_DR( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIODevReset;
    os_bit32 hpIOInfoLen = 0;

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X",
                    "CDBActionOOOFixup_DR",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);
    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "DR F OOO",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionOutBoundError

    Purpose: Does completion on IO that have mismatch with request data length and actual data length.
  Called By: CFuncProcessFcpRsp CFuncSEST_ off / on Card_FCPCompletion
CFuncOutBoundCompletion
             CFuncCompleteAllActiveCDBThreads with CDBEventIODeviceReset
             CFuncCompleteActiveCDBThreadsOnDevice with CDBEventIODeviceReset
SFActionAbortAccept
             SFActionAbortRej
             SFActionAbortBadALPA
             SFActionAbortTimedOut
      Calls: osIOCompleted 
             CDBEventThreadFree
-*/
/*  CDBStateOutBoundError  28 */
extern void CDBActionOutBoundError( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;

    /* CThread_ptr(thread->hpRoot)->CDBpollingCount--; */

    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X",
                    "CDBActionOutBoundError",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);
    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "Outbound",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    if (pCDBThread->ESGL_Request.State != ESGL_Request_InActive)
    {
        if (pCDBThread->ESGL_Request.State == ESGL_Request_Pending)
        {
            CThread_ptr(thread->hpRoot)->FuncPtrs.ESGLAllocCancel(
                                                thread->hpRoot,
                                                &(pCDBThread->ESGL_Request)
                                              );
        }
        else /* pCDBThread->ESGL_Request.State == ESGL_Request_Granted */
        {
            CThread_ptr(thread->hpRoot)->FuncPtrs.ESGLFree(
                                         thread->hpRoot,
                                         &(pCDBThread->ESGL_Request)
                                       );
        }
    }
    /* Resend OutboundError CDB's */
    fiSetEventRecord(eventRecord,thread,CDBEventInitialize);
}

/*+
   Function: CDBActionFailure_NO_RSP

    Purpose: Does completion on IO that have failed but do not have a response buffer.
  Called By: CFuncProcessFcpRsp CFuncSEST_ off / on Card_FCPCompletion
             CFuncOutBoundCompletion
      Calls: osIOCompleted 
             CDBEventThreadFree
-*/
/* CDBStateFailure_NO_RSP    29 */
extern void CDBActionFailure_NO_RSP( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    os_bit32 hpIOStatus = osIOFailed;
    os_bit32 hpIOInfoLen = 0;

    /* CThread_ptr(thread->hpRoot)->CDBpollingCount--; */
    fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X",
                    "CDBActionFailure_NO_RSP",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);

    if( osTimeStamp(thread->hpRoot)- pCDBThread->TimeStamp > TIMEOUT_VALUE ) /*1.6 ms per */
    {
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s IO timeout ALPA %X  X_ID %3X Time %d",
                    "F NR",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    osTimeStamp(thread->hpRoot)-pCDBThread->TimeStamp,
                    0,0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CDBStateLogErrorLevel,
                    "%s Bytes %d TimeBase %d",
                    pCDBThread->ReadWrite ? "Write": "Read" ,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCDBThread->DataLength,
                    CThread_ptr(thread->hpRoot)->TimeBase.Lo -  pCDBThread->CDBStartTimeBase.Lo,
                    0,0,0,0,0,0);
    }

    osIOCompleted( thread->hpRoot,
                   pCDBThread->hpIORequest,
                   hpIOStatus,
                   hpIOInfoLen
                  );
    Device_IO_Throttle_Decrement
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);
}

/*+
   Function: CDBActionAlloc_Abort

    Purpose: Gets resources for aborting current CDBThread.
  Called By: CDBActionSend_REC_Second
             CFuncReadSFQ
             CFuncCheckActiveDuringLinkEvent
             DevActionExternalDeviceReset
             fcAbortIO
      Calls: SFThreadAlloc
-*/
/* CDBStateAlloc_Abort 30 */
extern void CDBActionAlloc_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t * pDevThread    = pCDBThread->Device;

    fiLogDebugString(thread->hpRoot,
                    CDBStateAbortPathLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X",
                    "CDBActionAlloc_Abort",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);


#ifdef ESGLCancelAllocAbortRequests
    if (pCDBThread->ESGL_Request.State != ESGL_Request_InActive)
    {
        if (pCDBThread->ESGL_Request.State == ESGL_Request_Pending)
        {
            CThread_ptr(thread->hpRoot)->FuncPtrs.ESGLAllocCancel(
                                                thread->hpRoot,
                                                &(pCDBThread->ESGL_Request)
                                              );
        }
        else /* pCDBThread->ESGL_Request.State == ESGL_Request_Granted */
        {
            CThread_ptr(thread->hpRoot)->FuncPtrs.ESGLFree(
                                         thread->hpRoot,
                                         &(pCDBThread->ESGL_Request)
                                       );
        }
    }

#endif /* ESGLCancelAllocAbortRequests */
    if( pCDBThread->SFThread_Request.State  != SFThread_Request_InActive )
    {
        fiLogDebugString(thread->hpRoot,
                        0,
                        "(%p)In %s - State = %d ALPA %X X_ID %X SF(%p) SFrS %x Ev %d!",
                        "CDBActionAlloc_Abort",(char *)agNULL,
                        thread,pCDBThread->SFThread_Request.SFThread,
                        (os_bit32)thread->currentState,
                        fiComputeDevThread_D_ID(pDevThread),
                        pCDBThread->X_ID,
                        (os_bit32)pCDBThread->SFThread_Request.State,
                        (os_bit32)pCDBThread->SFThread_Request.eventRecord_to_send.event,
                        0,0,0);

        fiSetEventRecord(eventRecord,thread,CDBEvent_PrepareforAbort);
        return;
    }
    pCDBThread->SFThread_Request.eventRecord_to_send.event = CDBEventDo_Abort;
    pCDBThread->SFThread_Request.eventRecord_to_send.thread = thread;

    fiSetEventRecordNull(eventRecord);
    SFThreadAlloc( thread->hpRoot, & pCDBThread->SFThread_Request );

}

/*+
   Function: CDBActionAlloc_Abort

    Purpose: Sends event to SFThread to aborting current CDBThread.
  Called By: SFThreadAlloc
      Calls: SFActionDoAbort
-*/
/* CDBStateDo_Abort        31  */
extern void CDBActionDo_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;
    SFThread_t      * pSFThread     = pCDBThread->SFThread_Request.SFThread;

    pSFThread->parent.CDB = pCDBThread;

    fiLogDebugString(thread->hpRoot,
                    CDBStateAbortPathLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X",
                    "CDBActionDo_Abort",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
    fiSetEventRecord(eventRecord,&pSFThread->thread_hdr,SFEventDoAbort);
}

/*+
   Function: CDBActionPending_Abort

    Purpose: Changes CDBThread execution so aborted IO only complete with aborted status .
  Called By: Many
      Calls: Terminating State
-*/
/* CDBStatePending_Abort        32  */
extern void CDBActionPending_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;

    fiLogDebugString(thread->hpRoot,
                    CDBStateAbortPathLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X",
                    "CDBActionPending_Abort",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);

}

/*+
   Function: CDBActionPrepare_For_Abort

    Purpose: Changes CDBThread execution when waiting for alloc abort.
  Called By: Many
      Calls: Terminating State
-*/
/* CDBStatePrepare_For_Abort        33  */
extern void CDBActionPrepare_For_Abort( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;


    fiLogDebugString(thread->hpRoot,
                    CDBStateAbortPathLevel,
                    "(%p)In %s - State = %d ALPA %X X_ID %X",
                    "CDBActionPrepare_For_Abort",(char *)agNULL,
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);


    fiSetEventRecordNull(eventRecord);

}

/*+
   Function: CDBActionBuild_CCC_IO

    Purpose: Builds private CDB to Clear Check Condition.
  Called By: Not Used
      Calls: Not Used
-*/
/*  CDBStateBuild_CCC_IO              34           */
extern void CDBActionBuild_CCC_IO( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t        * hpRoot        = thread->hpRoot;
    CThread_t       * pCThread      = CThread_ptr(hpRoot);
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;
    os_bit8 x;
    X_ID_t       Masked_OX_ID;
    os_bit32        FCP_CMND_Offset = pCDBThread->FCP_CMND_Offset;
    FCHS_t      *FCHS            = pCDBThread->FCP_CMND_Ptr;
    os_bit8 * tmp8                 = (os_bit8 *)FCHS + sizeof(FCHS_t);
    os_bit32 * FCHSbit_32 = (os_bit32 * )FCHS; /* NW BUG */


    pCDBThread->CCC_pollingCount++;

    pCDBThread->ReadWrite  =  CDBThread_Write;
    pCDBThread->SG_Cache_Offset = 0;
    pCDBThread->SG_Cache_Used   = 0;

    if (pCThread->Calculation.MemoryLayout.FCP_CMND.memLoc == inCardRam)
    {
#ifndef __MemMap_Force_Off_Card__

        Masked_OX_ID = pCDBThread->X_ID;

        osCardRamWriteBlock(
                             hpRoot,
                             FCP_CMND_Offset,
                             (os_bit8 *)&(pDevThread->Template_FCHS),
                             sizeof(FCHS_t)
                           );

        osCardRamWriteBit32(
                             hpRoot,
                             FCP_CMND_Offset + hpFieldOffset(
                                                              FCHS_t,
                                                              OX_ID__RX_ID
                                                            ),
                             (  (Masked_OX_ID << FCHS_OX_ID_SHIFT)
                              | (0xFFFF << FCHS_RX_ID_SHIFT)      )
                           );
        /* Fill in CDB 0 for TUR */
        for(x=0; x < sizeof(agFcpCmnd_t); x++)
        {
            osCardRamWriteBit8(
                             hpRoot,
                             FCP_CMND_Offset + sizeof(FCHS_t)+x,
                             0 );
        }

        osCardRamWriteBit8(
                         hpRoot,
                         FCP_CMND_Offset + sizeof(FCHS_t)+1,
                         (os_bit8)pCDBThread->Lun );

        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "FCP_CMND_Offset %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        FCP_CMND_Offset,
                        0,0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "FCP_CMND_Offset DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 0),
                        osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 4),
                        osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 8),
                        osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 12),
                        osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 16),
                        osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 20),
                        osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 24),
                        osCardRamReadBit32(hpRoot,FCP_CMND_Offset + 28));

#endif /* __MemMap_Force_Off_Card__ was not defined */
    }
    else /* CThread_ptr(CDBThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.FCP_CMND.memLoc == inDmaMemory */
    {
#ifndef __MemMap_Force_On_Card__

        Masked_OX_ID = (X_ID_t)(pCDBThread->X_ID | X_ID_Write);

        *FCHS              = pDevThread->Template_FCHS;

        FCHS->OX_ID__RX_ID =   (Masked_OX_ID << FCHS_OX_ID_SHIFT)
                             | (0xFFFF << FCHS_RX_ID_SHIFT);

        /* Fill in CDB 0 for TUR */
        for(x=0; x < sizeof(agFcpCmnd_t); x++)
        {
            *(tmp8+x) = 0;
        }
        *(tmp8 + 1) = (os_bit8) pCDBThread->Lun;

        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "FCP_CMND_ptr %p",
                        (char *)agNULL,(char *)agNULL,
                        FCHSbit_32,agNULL,
                        0,0,0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "FCP_CMND_ptr DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        * (FCHSbit_32 + 0),
                        * (FCHSbit_32 + 4),
                        * (FCHSbit_32 + 8),
                        * (FCHSbit_32 + 12),
                        * (FCHSbit_32 + 16),
                        * (FCHSbit_32 + 20),
                        * (FCHSbit_32 + 24),
                        * (FCHSbit_32 + 28));


#endif /* __MemMap_Force_On_Card__ was not defined */

    }

    pCThread->FuncPtrs.fiFillInFCP_RESP(pCDBThread);
    pCThread->FuncPtrs.fiFillInFCP_SEST(pCDBThread);

#ifndef Performance_Debug

    fiLogDebugString(hpRoot,
                    CDBStateCCC_IOPathLevel,
                    "In %s - State = %d ALPA %X X_ID %X Lun %x",
                    "CDBActionBuild_CCC_IO",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    pCDBThread->Lun,
                    0,0,0,0);

#endif /* Performance_Debug */

    fiSetEventRecord(eventRecord,thread,CDBEvent_CCC_IO_Built);

}

/*+
   Function: CDBActionSend_CCC_IO

    Purpose: Sends private CDB to Clear Check Condition.
  Called By: Not Used but functional
      Calls: Not Used
-*/
/*  CDBStateSend_CCC_IO               35          */
extern void CDBActionSend_CCC_IO( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t        * hpRoot        = thread->hpRoot;
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;
    USE_t           * SEST          = &( pCDBThread->SEST_Ptr->USE);
    os_bit32             SEST_Offset   = pCDBThread->SEST_Offset;

    CThread_ptr(hpRoot)->FuncPtrs.WaitForERQ( hpRoot );

    CThread_ptr(hpRoot)->FuncPtrs.CDBFuncIRB_Init(pCDBThread);

    pCDBThread->TimeStamp =  osTimeStamp(hpRoot);

    ROLL(CThread_ptr(hpRoot)->HostCopy_ERQProdIndex,
        CThread_ptr(hpRoot)->Calculation.MemoryLayout.ERQ.elements);

    /* Big_Endian_code */
    SENDIO(hpRoot,CThread_ptr(hpRoot),thread,DoFuncCdbCmnd);

    fiSetEventRecordNull(eventRecord);

    if(SEST)
    {
        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "SEST_Offset %08X X_ID %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST_Offset,
                        pCDBThread->X_ID,
                        0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "Sest DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Bits,
                        SEST->Unused_DWord_1,
                        SEST->Unused_DWord_2,
                        SEST->Unused_DWord_3,
                        SEST->LOC,
                        SEST->Unused_DWord_5,
                        SEST->Unused_DWord_6,
                        SEST->Unused_DWord_7);

        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "Sest DWORD 8 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Unused_DWord_8,
                        SEST->Unused_DWord_9,
                        SEST->First_SG.U32_Len,
                        SEST->First_SG.L32,
                        SEST->Second_SG.U32_Len,
                        SEST->Second_SG.L32,
                        SEST->Third_SG.U32_Len,
                        SEST->Third_SG.L32);
    }
    else
    {
        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "SEST_Offset %08X X_ID %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST_Offset,
                        pCDBThread->X_ID,
                        0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "Sest DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Bits))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_1))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_2))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_3))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,LOC))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_5))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_6))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_7))));


        fiLogDebugString(hpRoot,
                        CStateLogConsoleShowSEST,
                        "Sest DWORD 8 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_8))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Unused_DWord_9))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,First_SG))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,First_SG))+4),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Second_SG))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Second_SG))+4),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Third_SG))),
                        osCardRamReadBit32(hpRoot,SEST_Offset+(hpFieldOffset(USE_t,Third_SG))+4));

    }

    fiLogDebugString(hpRoot,
                    CDBStateCCC_IOPathLevel,
                    "In %s - State = %d ALPA %X X_ID %X BitMask %X",
                    "CDBActionSend_CCC_IO",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    pDevThread->Lun_Active_Bitmask,
                    0,0,0,0);
}

/*+
   Function: CDBAction_CCC_IO_Success

    Purpose: Completion on private CDB to Clear Check Condition.
  Called By: Not Used but functional
      Calls: Not Used
-*/
/*   CDBState_CCC_IO_Success           36         */
extern void CDBAction_CCC_IO_Success( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;

    pCDBThread->CCC_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    CDBStateCCC_IOPathLevel,
                    "In %s - State = %d ALPA %X X_ID %X BitMask %X Lun %x",
                    "CDBAction_CCC_IO_Success",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    pDevThread->Lun_Active_Bitmask,
                    pCDBThread->Lun,
                    0,0,0);
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);

}

/*+
   Function: CDBAction_CCC_IO_Fail

    Purpose: Completion on private CDB to Clear Check Condition.
  Called By: Not Used but functional
      Calls: Not Used
-*/
/* CDBState_CCC_IO_Fail              37           */
extern void CDBAction_CCC_IO_Fail( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;

    pCDBThread->CCC_pollingCount--;

    pDevThread->Lun_Active_Bitmask &=  ~ (1 <<  pCDBThread->Lun);

    fiLogDebugString(thread->hpRoot,
                    CDBStateCCC_IOPathLevel,
                    "In %s - State = %d ALPA %X X_ID %X BitMask %X Lun %x",
                    "CDBAction_CCC_IO_Fail",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    pDevThread->Lun_Active_Bitmask,
                    pCDBThread->Lun,
                    0,0,0);
    pCDBThread->ExchActive = agFALSE;
    fiSetEventRecord(eventRecord,thread,CDBEventThreadFree);

}

/****************** FC Tape ******************************************/

/*+
   Function: CDBAction_Alloc_REC

    Purpose: Allocates REC ELS for FCTape recovery.
  Called By: CFuncReadSFQ
             CFuncFC_Tape
      Calls: SFThreadAlloc
-*/

/* CDBState_Alloc_REC                45            */
extern void CDBAction_Alloc_REC(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t *   pCDBThread =    (CDBThread_t * )thread;
    DevThread_t *   pDevThread =    pCDBThread->Device;

    fiLogString(thread->hpRoot,
                    "(%p) %s St %d %s ALPA %X X_ID %X",
                    "CDBAction_Alloc_REC",pCDBThread->ReadWrite ? "Write": "Read",
                    thread,agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);

    fiLogString(thread->hpRoot,
                    "CDB Cl %2X Ty %2X St %2X Stat %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0,0);

    pCDBThread->FC_Tape_Active  = agTRUE;
    pCDBThread->CDB_CMND_Class  = SFThread_SF_CMND_Class_FC_Tape;
    pCDBThread->CDB_CMND_Type   = SFThread_SF_CMND_Type_CDB_FC_Tape;
    pCDBThread->CDB_CMND_State  = SFThread_SF_CMND_State_CDB_FC_Tape_AllocREC;
    pCDBThread->CDB_CMND_Status = SFThread_SF_CMND_Status_NULL;


    pCDBThread->FC_Tape_REC_Reject_Count = 0;
    pCDBThread->FC_Tape_ExchangeStatusBlock= 0,
    pCDBThread->FC_Tape_Active = agTRUE;
    pCDBThread->FC_Tape_HBA_Has_SequenceInitiative = 0;
    pCDBThread->FC_Tape_CompletionStatus = 0;

    pCDBThread->SFThread_Request.eventRecord_to_send.event = CDBEvent_Got_REC;
    pCDBThread->SFThread_Request.eventRecord_to_send.thread = thread;

    fiSetEventRecordNull(eventRecord);
    SFThreadAlloc( thread->hpRoot, &pCDBThread->SFThread_Request );
}

/*+
   Function: CDBActionSend_REC

    Purpose: Send REC ELS for FCTape recovery.
  Called By: SFThreadAlloc / CDBAction_Alloc_REC
             
      Calls: SFActionDoREC
-*/
/*  CDBStateSend_REC                  38            */
extern void CDBActionSend_REC(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     =   thread->hpRoot;
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread =  pCDBThread->Device;
    SFThread_t  * pSFThread  =  pCDBThread->SFThread_Request.SFThread;
    FCHS_t      * FCHS       =  pCDBThread->FCP_CMND_Ptr;
    USE_t       * SEST       = &( pCDBThread->SEST_Ptr->USE);

    fiLogString(hpRoot,
                    "(%p) %s St %d ALPA %X X_ID %X SF %p R_CT %08X RX %08X",
                    "CDBActionSend_REC",(char *)agNULL,
                    thread,pSFThread,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    FCHS->R_CTL__D_ID,
                    SEST->Unused_DWord_6,
                    0,0,0);


    if( pCDBThread->SFThread_Request.SFThread->thread_hdr.currentState == SFStateDoREC )
    {
        fiLogString(hpRoot,
                        "%s - Currently Active !!!",
                        "CDBActionSend_REC",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
        fiSetEventRecordNull(eventRecord);
        return;
    }

/*  Last resort.......
    CFuncFreezeFCP( hpRoot );
    CFuncWaitForFCP( hpRoot );
*/
    pSFThread->parent.CDB = pCDBThread; 

    fiSetEventRecord(eventRecord,&pSFThread->thread_hdr,SFEventDoREC);
}

/*+
   Function: CDBActionSend_REC_Second

    Purpose: Sends REC ELS multiple REC could be sent, the CDBThead bounce back a forth  
             between this function and CDBActionSend_REC.
  Called By: SFThreadAlloc / CDBAction_Alloc_REC
             
      Calls: SFActionDoREC
-*/
/*  CDBStateSend_REC_Second           39              */
extern void CDBActionSend_REC_Second(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     =   thread->hpRoot;
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;
    DevThread_t * pDevThread = pCDBThread->Device;
    SFThread_t  * pSFThread  = pCDBThread->SFThread_Request.SFThread;
    FCHS_t      * FCHS       = pCDBThread->FCP_CMND_Ptr;
    USE_t       * SEST       = &( pCDBThread->SEST_Ptr->USE);

    pCDBThread->FC_Tape_RXID  = SEST->Unused_DWord_6;

    pCDBThread->CDB_CMND_State = SFThread_SF_CMND_State_CDB_FC_Tape_REC2;

    fiLogString(hpRoot,
                    "In %s St %d ALPA %X X_ID %X R_CTL %08X",
                    "CDBASR_S",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    FCHS->R_CTL__D_ID,
                    0,0,0,0);

    if( pCDBThread->SFThread_Request.SFThread->thread_hdr.currentState == SFStateRECRej )
    {
        /* If the REC is rejected the target did not get the command */
        pCDBThread->FC_Tape_REC_Reject_Count ++;
        if( pCDBThread->FC_Tape_REC_Reject_Count > 2 )
        {
                fiLogString(hpRoot,
                            "%s %s %d R_CTL %08X",
                            "CDBASRS","FC_TRRC",
                            (void *)agNULL,(void *)agNULL,
                            pCDBThread->FC_Tape_REC_Reject_Count,
                            FCHS->R_CTL__D_ID,
                            0,0,0,0,0,0);
            pCDBThread->FC_Tape_CompletionStatus =  CdbCompetionStatusReSendIO;
            SFThreadFree(thread->hpRoot, &pCDBThread->SFThread_Request );
            fiSetEventRecord(eventRecord,thread,CDBEventAlloc_Abort);
            return;
        }
    }
    fiSetEventRecord(eventRecord,&pSFThread->thread_hdr,SFEventDoREC);

/*
    fiSetEventRecord(eventRecord,thread,CDBEventSendREC_Success);
  
    fiSetEventRecordNull(eventRecord);
*/
}

/*+
   Function: CDBAction_REC_Success

    Purpose: Detrimines next action in fctape recovery.
  Called By: SFActionRECAccept 
             
      Calls: CDBStateSend_SRR or terminates
-*/
/* CDBState_REC_Success              42             */
extern void CDBAction_REC_Success(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot        = thread->hpRoot;
    CDBThread_t *   pCDBThread  = (CDBThread_t * )thread;
    DevThread_t *   pDevThread  = pCDBThread->Device;
    USE_t       *   SEST        = &( pCDBThread->SEST_Ptr->USE);
    os_bit32        SEST_Offset = pCDBThread->SEST_Offset;
    FCHS_t      * FCHS          = pCDBThread->FCP_CMND_Ptr;

    pCDBThread->FC_Tape_RXID    = SEST->Unused_DWord_6;

    fiLogString(hpRoot,
                    "%s S %d ALPA %X X_ID %X ESB %08X R_CTL %08X",
                    "CDBAction_REC_Success",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    pCDBThread->FC_Tape_ExchangeStatusBlock,
                    FCHS->R_CTL__D_ID,
                    0,0,0);

    fiLogString(hpRoot,
                    "Dev %02X Cl %2X Ty %2X St %2X Stat %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);

    if( pCDBThread->FC_Tape_ExchangeStatusBlock )
    {

       fiLogString(hpRoot,
                        "pCDBThread Direction  %s ",
                        pCDBThread->ReadWrite & CDBThread_Write ? "CDBThread_Write": "CDBThread_Read" ,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

        fiLogString(hpRoot,
                        "FC_Tape_ExchangeStatusBlock %s Owner %s",
                        pCDBThread->FC_Tape_ExchangeStatusBlock & FC_REC_ESTAT_ESB_OWNER_Responder          ? "Responder": "Originator" ,
                        pCDBThread->FC_Tape_ExchangeStatusBlock & FC_REC_ESTAT_SequenceInitiativeThisPort ? "This Port": "Other Port" ,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
        fiLogString(hpRoot,
                        "FC_Tape_ExchangeStatusBlock Exchange %s Ending %s",
                        pCDBThread->FC_Tape_ExchangeStatusBlock & FC_REC_ESTAT_ExchangeCompletion      ? "Complete" : "Open" ,
                        pCDBThread->FC_Tape_ExchangeStatusBlock & FC_REC_ESTAT_EndingConditionAbnormal ? "Abnormal": "Normal" ,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
        fiLogString(hpRoot,
                        "FC_Tape_ExchangeStatusBlock Error  %s  RQ %s",
                        pCDBThread->FC_Tape_ExchangeStatusBlock & FC_REC_ESTAT_ErrorTypeAbnormal       ? "Abnormal Termination" : "ABTX" ,
                        pCDBThread->FC_Tape_ExchangeStatusBlock & FC_REC_ESTAT_RecoveryQualiferActive   ? "Recovery Qualifer Active" : "None" ,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

        fiLogString(hpRoot,
                        "FC_Tape_ExchangeStatusBlock Policy %s  ( %08X) ",
                        pCDBThread->FC_Tape_ExchangeStatusBlock & FC_REC_ESTAT_ExchangePolicy_DiscardMultipleRetry ? "Retransmit"  : "Discard " ,
                        (char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCDBThread->FC_Tape_ExchangeStatusBlock & FC_REC_ESTAT_ExchangePolicy_MASK,
                        0,0,0,0,0,0,0);

    }
    if( pCDBThread->FC_Tape_ExchangeStatusBlock )
    {
        if(pCDBThread->ReadWrite & CDBThread_Write )
        {
            if( pCDBThread->FC_Tape_ExchangeStatusBlock & FC_REC_ESTAT_ESB_OWNER_Responder )
            {
                if( FC_REC_ESTAT_SequenceInitiativeThisPort & ~pCDBThread->FC_Tape_ExchangeStatusBlock)
                {
                    pCDBThread->FC_Tape_HBA_Has_SequenceInitiative++;
                }
            }
        }
    }

    if(SEST)
    {
        fiLogString(hpRoot,
                        "SEST_Offset %08X X_ID %08X",
                        (char *)NULL,(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST_Offset,
                        pCDBThread->X_ID,
                        0,0,0,0,0,0);

        fiLogString(hpRoot,
                        "Sest0 %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)NULL,(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Bits,
                        SEST->Unused_DWord_1,
                        SEST->Unused_DWord_2,
                        SEST->Unused_DWord_3,
                        SEST->LOC,
                        SEST->Unused_DWord_5,
                        SEST->Unused_DWord_6,
                        SEST->Unused_DWord_7);

        fiLogString(hpRoot,
                        "Sest8 %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)NULL,(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Unused_DWord_8,
                        SEST->Unused_DWord_9,
                        SEST->First_SG.U32_Len,
                        SEST->First_SG.L32,
                        SEST->Second_SG.U32_Len,
                        SEST->Second_SG.L32,
                        SEST->Third_SG.U32_Len,
                        SEST->Third_SG.L32);
    }

    if( pCDBThread->FC_Tape_HBA_Has_SequenceInitiative < 1 )
    {
        fiSetEventRecordNull(eventRecord);
    }
    else
    {
        fiLogString(hpRoot,
                        "%s - %s %d",
                        "CDBARS","FC_Tape_HBA_Has_SequenceInitiative",
                        (void *)agNULL,(void *)agNULL,
                        pCDBThread->FC_Tape_HBA_Has_SequenceInitiative,
                        0,0,0,0,0,0,0);
        /*

        pCDBThread->FC_Tape_CompletionStatus =  CdbCompetionStatusReSendIO;
        SFThreadFree(thread->hpRoot, &pCDBThread->SFThread_Request );
        fiSetEventRecord(eventRecord,thread,CDBEventAlloc_Abort);
        */
        fiSetEventRecord(eventRecord,thread,CDBEventSendSRR);

    }
}

/*+
   Function: CDBActionSend_SRR

    Purpose: Detrimines next action in fctape recovery.
  Called By: CDBAction_REC_Success 
             
      Calls: SFActionDoSRR or terminates if SRR is active
-*/
/*  CDBStateSend_SRR                  40            */
extern void CDBActionSend_SRR(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     =   thread->hpRoot;
    CDBThread_t * pCDBThread =  (CDBThread_t * )thread;
    DevThread_t * pDevThread =  pCDBThread->Device;
    SFThread_t  * pSFThread  =  pCDBThread->SFThread_Request.SFThread;
    FCHS_t      * FCHS       =  pCDBThread->FCP_CMND_Ptr;
    USE_t       * SEST       = &( pCDBThread->SEST_Ptr->USE);

    pCDBThread->CDB_CMND_State = SFThread_SF_CMND_State_CDB_FC_Tape_SRR;

    fiLogString(hpRoot,
                    "%s St %d ALPA %X X_ID %X R_CTL %08X",
                    "CDBASSRR",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    FCHS->R_CTL__D_ID,
                    0,0,0,0);

    if(SEST)
    {

        fiLogString(hpRoot,
                        "Sest0 %08X %08X %08X %08X %08X %08X %08X %08X",
                        (char *)NULL,(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Bits,
                        SEST->Unused_DWord_1,
                        SEST->Unused_DWord_2,
                        SEST->Unused_DWord_3,
                        SEST->LOC,
                        SEST->Unused_DWord_5,
                        SEST->Unused_DWord_6,
                        SEST->Unused_DWord_7);

        fiLogString(hpRoot,
                        "Sest8 %08X %08X %08X %08X %08X %08X  %08X  %08X",
                        (char *)NULL,(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        SEST->Unused_DWord_8,
                        SEST->Unused_DWord_9,
                        SEST->First_SG.U32_Len,
                        SEST->First_SG.L32,
                        SEST->Second_SG.U32_Len,
                        SEST->Second_SG.L32,
                        SEST->Third_SG.U32_Len,
                        SEST->Third_SG.L32);
    }


    if( pCDBThread->SFThread_Request.SFThread->thread_hdr.currentState == SFStateDoSRR )
    {
        fiLogString(hpRoot,
                        "%s - Currently Active !!!",
                        "CDBActionSend_SRR",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
        fiSetEventRecordNull(eventRecord);
        return;
    }

    fiSetEventRecord(eventRecord,&pSFThread->thread_hdr,SFEventDoSRR);
  
/*
    fiSetEventRecord(eventRecord,thread,CDBEventSendSRR_Success);
    fiSetEventRecordNull(eventRecord);
*/
}

/*+
   Function: CDBActionSend_SRR_Second

    Purpose: If first SRR Fails try again.
  Called By: CDBState_SRR_Fail 
             
      Calls: SFActionDoSRR 
-*/
/*  CDBStateSend_SRR_Second           41           */
extern void CDBActionSend_SRR_Second(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     =   thread->hpRoot;
    CDBThread_t *   pCDBThread =    (CDBThread_t * )thread;
    DevThread_t *   pDevThread =    pCDBThread->Device;
    SFThread_t  *   pSFThread  =    pCDBThread->SFThread_Request.SFThread;
    FCHS_t      * FCHS       =  pCDBThread->FCP_CMND_Ptr;


    pCDBThread->CDB_CMND_State = SFThread_SF_CMND_State_CDB_FC_Tape_SRR2;

        fiLogString(hpRoot,
                    "%s St %d ALPA %X X_ID %X R_CTL %08X",
                    "CDBASSRS",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    FCHS->R_CTL__D_ID,
                    0,0,0,0);

    fiSetEventRecord(eventRecord,&pSFThread->thread_hdr,SFEventDoSRR);

  
/*
    fiSetEventRecordNull(eventRecord);
*/
}

/*+
   Function: CDBAction_SRR_Success

    Purpose: If SRR succedes wait for next action.
  Called By: SFActionSRRAccept 
             
      Calls: Terminates 
-*/
/*  CDBState_SRR_Success              43            */
extern void CDBAction_SRR_Success(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     =   thread->hpRoot;
    CDBThread_t *   pCDBThread =    (CDBThread_t * )thread;
    DevThread_t *   pDevThread =    pCDBThread->Device;

    fiLogString(hpRoot,
                    "%s St %d ALPA %X X_ID %X",
                    "CDBASRR_S",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);


    if( (pCDBThread->FC_Tape_ExchangeStatusBlock )  == FC_REC_ESTAT_ESB_OWNER_Responder)
    {
        if(pCDBThread->CDB_CMND_State != SFThread_SF_CMND_State_CDB_FC_Tape_ReSend)
        {
            /* pCDBThread->CDB_CMND_State = SFThread_SF_CMND_State_CDB_FC_Tape_ReSend; */
            fiSetEventRecordNull(eventRecord);

        }
        else
        {
            /* pCDBThread->CDB_CMND_Status  = SFThread_SF_CMND_Status_CDB_FC_TapeTargetReSendData;
               fiSetEventRecord(eventRecord,thread,CDBEvent_ResendIO);
            */
            fiSetEventRecordNull(eventRecord);
        }
    }
    else
    {
        /* pCDBThread->CDB_CMND_Status  = SFThread_SF_CMND_Status_CDB_FC_TapeGet_RSP;
        */        
        fiSetEventRecordNull(eventRecord);
    }
}

/*+
   Function: CDBAction_SRR_Fail

    Purpose: If SRR failed try it again.
  Called By: SFActionSRRRej
             SFActionSRRTimedOut
             SFActionSRRBadALPA
          
      Calls: SFActionDoSRR 
-*/
/* CDBState_SRR_Fail                 44            */
extern void CDBAction_SRR_Fail(fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     =   thread->hpRoot;
    CDBThread_t *   pCDBThread =    (CDBThread_t * )thread;
    DevThread_t *   pDevThread =    pCDBThread->Device;
    SFThread_t  *   pSFThread  =    pCDBThread->SFThread_Request.SFThread;

    fiLogString(hpRoot,
                    "%s St %d ALPA %X X_ID %X",
                    "CDBA_SRR_F",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,&pSFThread->thread_hdr,SFEventDoSRR);

}

/*+
   Function: CDBActionDO_Nothing

    Purpose: Unused state
  Called By: None
          
      Calls: Terminates
-*/
/*   CDBStateDO_Nothing           46      */
extern void CDBActionDO_Nothing( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    agRoot_t    * hpRoot     =   thread->hpRoot;
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;

        fiLogString(hpRoot,
                    "%s St %d ALPA %X X_ID %X",
                    "CDBADO_N",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

/*+
   Function: CDBActionReSend_IO

    Purpose: Frees resources from CDBThread for resend
  Called By: CFuncReadSFQ
             CDBActionFcpCompleteAbort          

      Calls: CDBActionInitialize
-*/
/*   CDBStateReSend_IO   47      */
extern void CDBActionReSend_IO( fi_thread__t *thread, eventRecord_t *eventRecord )
{
    CDBThread_t     * pCDBThread    = (CDBThread_t * )thread;
    DevThread_t     * pDevThread    = pCDBThread->Device;

    fiLogString(thread->hpRoot,
                    "%s St %d ALPA %X X_ID %X",
                    "CDBARS_IO",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCDBThread->X_ID,
                    0,0,0,0,0);

    fiLogString(thread->hpRoot,
                    "Dev %02X  Cl %2X Ty %2X St %2X Stat %2X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                    (os_bit32)pCDBThread->CDB_CMND_Class,
                    (os_bit32)pCDBThread->CDB_CMND_Type,
                    (os_bit32)pCDBThread->CDB_CMND_State,
                    (os_bit32)pCDBThread->CDB_CMND_Status,
                    0,0,0);


    pCDBThread->ReSentIO = agTRUE;

    if (pCDBThread->ESGL_Request.State != ESGL_Request_InActive)
    {
        if (pCDBThread->ESGL_Request.State == ESGL_Request_Pending)
        {
            CThread_ptr(thread->hpRoot)->FuncPtrs.ESGLAllocCancel(
                                               thread->hpRoot,
                                               &(pCDBThread->ESGL_Request)
                                             );
        }
        else /* CDBThread->ESGL_Request.State == ESGL_Request_Granted */
        {
            CThread_ptr(thread->hpRoot)->FuncPtrs.ESGLFree(
                                        thread->hpRoot,
                                        &(pCDBThread->ESGL_Request)
                                      );
        }
    }

    if (pCDBThread->SFThread_Request.State != SFThread_Request_InActive)
    {
        if (pCDBThread->SFThread_Request.State == SFThread_Request_Pending)
        {
            SFThreadAllocCancel(
                                 thread->hpRoot,
                                 &(pCDBThread->SFThread_Request)
                               );
        }
        else /* CDBThread->SFThread_Request.State == SFThread_Request_Granted */
        {
            fiLogString(thread->hpRoot,
                            "In %s - SF %p SFState = %d CCnt %x",
                            "CDBAReSend_IO",(char *)agNULL,
                            pCDBThread->SFThread_Request.SFThread,agNULL,
                            (os_bit32)pCDBThread->SFThread_Request.SFThread->thread_hdr.currentState,
                            CThread_ptr(thread->hpRoot)->CDBpollingCount,
                            0,0,0,0,0,0);

            SFThreadFree( thread->hpRoot,&(pCDBThread->SFThread_Request) );
        }
    }

    if (pCDBThread->Timer_Request.Active == agTRUE)
    {
        fiTimerStop(
                     &(pCDBThread->Timer_Request)
                   );
    }

    /* CThread_ptr(thread->hpRoot)->CDBpollingCount--; */

    fiListDequeueThis( &(pCDBThread->CDBLink) );

    fiListEnqueueAtTail( &(pCDBThread->CDBLink),  &(pDevThread->Active_CDBLink_0) );

    fiSetEventRecord(eventRecord,thread,CDBEventInitialize);

}

/******************End FC Tape ******************************************/

/*+
   Function: CDBFuncIRB_onCardInit

    Purpose: On card memory version of Initialize IRB (IO request Block) in 
             the ERQ (Exchange Request Queue)
  Called By: CDBActionSendIo

      Calls: None
-*/
void CDBFuncIRB_onCardInit(CDBThread_t  * CDBThread )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t                   * hpRoot    = CDBThread->thread_hdr.hpRoot;
    CThread_t                  * CThread   = CThread_ptr(hpRoot);
    DevThread_t                * DevThread = CDBThread->Device;
    fiMemMapMemoryDescriptor_t * ERQ       = &(CThread->Calculation.MemoryLayout.ERQ);
    os_bit32                     Irb_offset;
    os_bit32                     D_ID;

    D_ID = DevThread->DevInfo.CurrentAddress.Domain << 16
            | DevThread->DevInfo.CurrentAddress.Area   <<  8
            | DevThread->DevInfo.CurrentAddress.AL_PA;

    Irb_offset = ERQ->addr.CardRam.cardRamOffset;

    Irb_offset += ERQ->elementSize * CThread->HostCopy_ERQProdIndex;

    osCardRamWriteBit32(hpRoot,
                    Irb_offset, /*Req_A.Bits__SFS_Len */
                    (sizeof(agCDBRequest_t)+32) | IRB_SFA | IRB_DCM);

    osCardRamWriteBit32(hpRoot,
                    Irb_offset+4, /*Req_A.SFS_Addr */
                    CDBThread->FCP_CMND_Lower32);

    osCardRamWriteBit32(hpRoot,
                    Irb_offset+8, /* Req_A.D_ID  */
                    D_ID << IRB_D_ID_SHIFT);
    osCardRamWriteBit32(hpRoot,
                    Irb_offset+12, /* Req_A.MBZ__SEST_Index__Trans_ID */
                    CDBThread->X_ID);
    osCardRamWriteBit32(hpRoot,
                    Irb_offset+16, /*     pIrb->Req_B.Bits__SFS_Len */
                    0);
#endif /* __MemMap_Force_Off_Card__ was not defined */
    }

/*+
   Function: CDBFuncIRB_offCardInit

    Purpose: Off card (system )memory version of Initialize IRB (IO request Block) in 
             the ERQ (Exchange Request Queue)
  Called By: CDBActionSendIo

      Calls: None
-*/
void CDBFuncIRB_offCardInit(CDBThread_t  * CDBThread )
{
#ifndef __MemMap_Force_On_Card__
    CThread_t                  *CThread = CThread_ptr(CDBThread->thread_hdr.hpRoot);
    DevThread_t               *DevThread= CDBThread->Device;
    fiMemMapMemoryDescriptor_t *ERQ     = &(CThread->Calculation.MemoryLayout.ERQ);
    IRB_t                      *pIrb;
    os_bit32                    D_ID;

    D_ID = DevThread->DevInfo.CurrentAddress.Domain << 16
            | DevThread->DevInfo.CurrentAddress.Area   <<  8
            | DevThread->DevInfo.CurrentAddress.AL_PA;

    pIrb = (IRB_t *)ERQ->addr.DmaMemory.dmaMemoryPtr;
    pIrb += CThread->HostCopy_ERQProdIndex;


    pIrb->Req_A.Bits__SFS_Len   = (sizeof(agCDBRequest_t)+32) | IRB_SFA | IRB_DCM;

    pIrb->Req_A.SFS_Addr                 = CDBThread->FCP_CMND_Lower32;
    pIrb->Req_A.D_ID                      = D_ID << IRB_D_ID_SHIFT;
    pIrb->Req_A.MBZ__SEST_Index__Trans_ID = CDBThread->X_ID;
    pIrb->Req_B.Bits__SFS_Len = 0;
#endif /* __MemMap_Force_On_Card__ was not defined */
}

/*+
   Function: fill_Loc_SGL_offCard

    Purpose: Off card (system )memory version to set IO buffers using only 
             local Scatter Gather
             
  Called By: CDBActionFillLocalSGL

      Calls: None
-*/
void fill_Loc_SGL_offCard(CDBThread_t * pCDBThread)
{
#ifndef __MemMap_Force_On_Card__
    SG_Element_t *LSGL_Ptr      = &(pCDBThread->SEST_Ptr->USE.First_SG);
    os_bit32         SG_Cache_Used = pCDBThread->SG_Cache_Used;
    SG_Element_t *SG_Cache_Ptr  = &(pCDBThread->SG_Cache[0]);

#ifndef Performance_Debug
    fiLogDebugString(
                      pCDBThread->thread_hdr.hpRoot,
                      CDBStateLogConsoleLevel,
                      "%s  Length %d",
                      "fill_Loc_SGL_offCard",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      pCDBThread->DataLength,
                      0,0,0,0,0,0,0
                    );
#endif /* Performance_Debug */

    while (SG_Cache_Used--)
    {
        *LSGL_Ptr++ = *SG_Cache_Ptr++;
    }
#endif /* __MemMap_Force_On_Card__ was not defined */
}

/*+
   Function: fill_Loc_SGL_onCard

    Purpose: On card memory version to set IO buffers using only 
             local Scatter Gather
             
  Called By: CDBActionFillLocalSGL

      Calls: None
-*/
void fill_Loc_SGL_onCard(CDBThread_t * pCDBThread)
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t     *hpRoot       = pCDBThread->thread_hdr.hpRoot; /* NW BUG */
    os_bit32         LSGL_Offset  = pCDBThread->SEST_Offset + hpFieldOffset(USE_t,First_SG);/* NW BUG */
    SG_Element_t *SG_Cache_Ptr = &(pCDBThread->SG_Cache[0]);/* NW BUG */

#ifndef Performance_Debug
    fiLogDebugString(
                      hpRoot,
                      CDBStateLogConsoleLevel,
                      "%s  Length %d",
                      "fill_Loc_SGL_onCard",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      pCDBThread->DataLength,
                      0,0,0,0,0,0,0
                    );
#endif /* Performance_Debug */

    osCardRamWriteBlock(
                         hpRoot,
                         LSGL_Offset,
                         (void *)SG_Cache_Ptr,
                         (os_bit32)(pCDBThread->SG_Cache_Used * sizeof(SG_Element_t))
                       );
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

/*+
   Function: fillptr_SEST_offCard_ESGL_offCard

    Purpose: Off card (system )memory version to set SEST to point to initial ESGL Page. 
             
  Called By: CDBActionFillESGL

      Calls: None
-*/
void fillptr_SEST_offCard_ESGL_offCard(CDBThread_t * pCDBThread)
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t        * hpRoot        = pCDBThread->thread_hdr.hpRoot;
    CThread_t       * pCThread      = CThread_ptr(hpRoot);
    ESGL_Request_t  * pESGL_Request = &pCDBThread->ESGL_Request;
    os_bit32        * Clear_LOC     = (os_bit32 * )((os_bit8 *)(pCDBThread->SEST_Ptr) + hpFieldOffset(USE_t,LOC) );

    SG_Element_t * pLSGL  = &pCDBThread->SEST_Ptr->USE.First_SG;

    *Clear_LOC &= ~USE_LOC;

    pLSGL->U32_Len = 0;
    pLSGL->L32 = pCThread->Calculation.Input.dmaMemoryLower32+pESGL_Request->offsetToFirst;
#endif /* __MemMap_Force_On_Card__ was not defined */
}

/*+
   Function: fillptr_SEST_offCard_ESGL_onCard

    Purpose: On card memory version to set SEST to point to initial ESGL Page
             local Scatter Gather
             
  Called By: CDBActionFillESGL

      Calls: None
-*/
void fillptr_SEST_offCard_ESGL_onCard(CDBThread_t * pCDBThread)
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t        * hpRoot            = pCDBThread->thread_hdr.hpRoot;
    CThread_t       * pCThread          = CThread_ptr(hpRoot);
    SG_Element_t * pLSGL  = &pCDBThread->SEST_Ptr->USE.First_SG;

    os_bit32           * Clear_LOC     = (os_bit32 * )((os_bit8 *)(pCDBThread->SEST_Ptr) + hpFieldOffset(USE_t,LOC) );

    ESGL_Request_t *pESGL_Request = &pCDBThread->ESGL_Request;

    *Clear_LOC &= ~USE_LOC;

    pLSGL->U32_Len = 0;
    pLSGL->L32 = pCThread->Calculation.Input.cardRamLower32+pESGL_Request->offsetToFirst;

#endif /* __MemMap_Force_Off_Card__ was not defined */
}

/*+
   Function: fillptr_SEST_onCard_ESGL_offCard

    Purpose: On card memory version to set fill memory locations and data length in 
             allocated  ESGL Pages when SEST in off card
             
  Called By: CDBActionFillESGL

      Calls: None
-*/
void fillptr_SEST_onCard_ESGL_offCard(CDBThread_t * pCDBThread)
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t        * hpRoot        = pCDBThread->thread_hdr.hpRoot;
    CThread_t       * pCThread      = CThread_ptr(hpRoot);
    ESGL_Request_t  * pESGL_Request = &pCDBThread->ESGL_Request;

    os_bit32             Clear_LOC_Offset  = pCDBThread->SEST_Offset + hpFieldOffset(USE_t,LOC);
    os_bit32             LSGL_Offset       = pCDBThread->SEST_Offset + hpFieldOffset(USE_t,First_SG);

    osCardRamWriteBit32(hpRoot,
                        Clear_LOC_Offset,
                        osCardRamReadBit32(hpRoot,
                                Clear_LOC_Offset) & ~USE_LOC );

    osCardRamWriteBit32(hpRoot,
                        LSGL_Offset,
                        0);

    osCardRamWriteBit32(hpRoot,
                        LSGL_Offset + 4,
                        pCThread->Calculation.Input.dmaMemoryLower32+pESGL_Request->offsetToFirst
                        );

#endif /* __MemMap_Force_On_Card__ was not defined */
}

/*+
   Function: fillptr_SEST_onCard_ESGL_onCard

    Purpose: On card memory version to set fill memory locations and data length in 
             allocated  ESGL Pages when SEST in on card
             
  Called By: CDBActionFillESGL

      Calls: None
-*/
void fillptr_SEST_onCard_ESGL_onCard(CDBThread_t * pCDBThread)
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t        * hpRoot            = pCDBThread->thread_hdr.hpRoot;
    CThread_t       * pCThread          = CThread_ptr(hpRoot);
    os_bit32             Clear_LOC_Offset  = pCDBThread->SEST_Offset + hpFieldOffset(USE_t,LOC);
    os_bit32             LSGL_Offset       = pCDBThread->SEST_Offset + hpFieldOffset(USE_t,First_SG);
    ESGL_Request_t *pESGL_Request = &pCDBThread->ESGL_Request;

    osCardRamWriteBit32(hpRoot,
                        Clear_LOC_Offset,
                        osCardRamReadBit32(hpRoot,
                                Clear_LOC_Offset) & ~USE_LOC );

    osCardRamWriteBit32(hpRoot,
                        LSGL_Offset,
                        0);

    osCardRamWriteBit32(hpRoot,
                        LSGL_Offset + 4,
                        pCThread->Calculation.Input.cardRamLower32+pESGL_Request->offsetToFirst
                        );

#endif /* __MemMap_Force_Off_Card__ was not defined */
}

/*+
   Function: fill_ESGL_offCard

    Purpose: System memory version to set fill memory locations and data length in 
             allocated  ESGL Pages when ESGL is off card.
             
  Called By: CDBActionFillESGL

      Calls: None
-*/
void fill_ESGL_offCard(CDBThread_t * pCDBThread)
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t        * hpRoot        = pCDBThread->thread_hdr.hpRoot;
    CThread_t       * pCThread      = CThread_ptr(hpRoot);
    ESGL_Request_t  * pESGL_Request = &pCDBThread->ESGL_Request;

    SG_Element_t * pESGL  = (SG_Element_t * )((os_bit8 *)(pCThread->Calculation.Input.dmaMemoryPtr)
                                                                + pESGL_Request->offsetToFirst );

    os_bit32 DataLength = pCDBThread->DataLength;

    os_bit32 ChunksPerESGL;
    os_bit32 TotalChunks;
    os_bit32 Chunk          = 0;
    os_bit32 hpChunkOffset  = pCDBThread->SG_Cache_Offset;
    os_bit32 hpChunkUpper32;
    os_bit32 hpChunkLower32;
    os_bit32 hpChunkLen;

    os_bit32       SG_Cache_Used = pCDBThread->SG_Cache_Used;
    SG_Element_t * SG_Cache_Ptr  = &(pCDBThread->SG_Cache[0]);

    ChunksPerESGL = pCThread->Calculation.MemoryLayout.ESGL.elementSize / sizeof(SG_Element_t);
    TotalChunks   = ChunksPerESGL * pESGL_Request->num_ESGL;

#ifndef Performance_Debug

    fiLogDebugString(
                      hpRoot,
                      CDBStateLogConsoleLevel,
                      " %s Length %d",
                      "fill_ESGL_offCard",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      pCDBThread->DataLength,
                      0,0,0,0,0,0,0
                    );
#endif /* Performance_Debug */

    while (SG_Cache_Used--)
    {
        *pESGL++ = *SG_Cache_Ptr++;

        Chunk++;
        TotalChunks--;

        if (Chunk == (ChunksPerESGL-1))
        {
           /*
            Chain ESGL here
            */

            pESGL = (SG_Element_t * )((os_bit8 *)(pCThread->Calculation.Input.dmaMemoryPtr)
                                      + (pESGL->L32 - pCThread->Calculation.Input.dmaMemoryLower32) );

            Chunk = 0;
            TotalChunks--;
        }
    }

    while (hpChunkOffset < DataLength)
    {
        osGetSGLChunk( hpRoot,
                         pCDBThread->hpIORequest,
                         hpChunkOffset,
                         &hpChunkUpper32,
                         &hpChunkLower32,
                         &hpChunkLen
                         );

        if (hpChunkLen > SG_Element_Len_MAX)
            hpChunkLen = SG_Element_Len_MAX;

        pESGL->U32_Len = (hpChunkUpper32 << SG_Element_U32_SHIFT) | hpChunkLen;
        pESGL->L32     = hpChunkLower32;

        hpChunkOffset += hpChunkLen;
        pESGL++;

        Chunk++;
        TotalChunks--;

        if (Chunk == (ChunksPerESGL-1))
        {
           /*
            Chain ESGL here
            */

            pESGL = (SG_Element_t * )((os_bit8 *)(pCThread->Calculation.Input.dmaMemoryPtr)
                                      + (pESGL->L32 - pCThread->Calculation.Input.dmaMemoryLower32) );

            Chunk = 0;
            TotalChunks--;
        }
    }

    while (TotalChunks--)
    {
        pESGL->U32_Len = 0;
        pESGL->L32     = 0;

        pESGL++;
    }
#endif /* __MemMap_Force_On_Card__ was not defined */
}

/*+
   Function: fill_ESGL_onCard

    Purpose: On card version to set fill memory locations and data length in 
             allocated  ESGL Pages when ESGL is on card.
             
  Called By: CDBActionFillESGL

      Calls: None
-*/
void fill_ESGL_onCard(CDBThread_t * pCDBThread)
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t        * hpRoot        = pCDBThread->thread_hdr.hpRoot;
    CThread_t       * pCThread      = CThread_ptr(hpRoot);
    ESGL_Request_t  * pESGL_Request = &pCDBThread->ESGL_Request;

    os_bit32 ESGL_offset  = pESGL_Request->offsetToFirst;

    os_bit32     DataLength = pCDBThread->DataLength;

    os_bit32 ChunksPerESGL;
    os_bit32 TotalChunks;
    os_bit32     Chunk  = 0;
    os_bit32     hpChunkOffset  = pCDBThread->SG_Cache_Offset;
    os_bit32     hpChunkUpper32;
    os_bit32     hpChunkLower32;
    os_bit32     hpChunkLen;

    os_bit32         SG_Cache_Used = pCDBThread->SG_Cache_Used;
    SG_Element_t *SG_Cache_Ptr  = &(pCDBThread->SG_Cache[0]);

    ChunksPerESGL = pCThread->Calculation.MemoryLayout.ESGL.elementSize / sizeof(SG_Element_t);
    TotalChunks = ChunksPerESGL * pESGL_Request->num_ESGL;

#ifndef Performance_Debug
    fiLogDebugString(
                      hpRoot,
                      CDBStateLogConsoleLevel,
                      "%s  Length %d",
                      "fill_ESGL_onCard",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      pCDBThread->DataLength,
                      0,0,0,0,0,0,0
                    );

#endif /* Performance_Debug */
    while (SG_Cache_Used--)
    {
        osCardRamWriteBlock(
                             hpRoot,
                             ESGL_offset,
                             (void *)SG_Cache_Ptr,
                             (os_bit32)sizeof(SG_Element_t)
                           );

        ESGL_offset  += sizeof(SG_Element_t);
        SG_Cache_Ptr += 1;

        Chunk++;
        TotalChunks--;

        if (Chunk == (ChunksPerESGL-1))
        {
           /*
            Chain ESGL here
            */

            ESGL_offset = osCardRamReadBit32(hpRoot,ESGL_offset + 4 );

            Chunk = 0;
            TotalChunks--;
        }
    }

    while (hpChunkOffset < DataLength)
    {
        osGetSGLChunk( hpRoot,
                         pCDBThread->hpIORequest,
                         hpChunkOffset,
                         &hpChunkUpper32,
                         &hpChunkLower32,
                         &hpChunkLen
                         );

        if (hpChunkLen > SG_Element_Len_MAX)
            hpChunkLen = SG_Element_Len_MAX;

        osCardRamWriteBit32(hpRoot,
                            ESGL_offset,
                            (hpChunkUpper32 << SG_Element_U32_SHIFT) | hpChunkLen);
        osCardRamWriteBit32(hpRoot,
                            ESGL_offset + 4,
                            hpChunkLower32);

        hpChunkOffset += hpChunkLen;
        ESGL_offset += sizeof(SG_Element_t);

        Chunk++;
        TotalChunks--;

        if (Chunk == (ChunksPerESGL-1))
        {
           /*
            Chain ESGL here
            */

            ESGL_offset = osCardRamReadBit32(hpRoot,ESGL_offset + 4 );

            Chunk = 0;
            TotalChunks--;
        }
    }

    while (TotalChunks--)
    {
        osCardRamWriteBit32(hpRoot,
                            ESGL_offset,
                            0);
        osCardRamWriteBit32(hpRoot,
                            ESGL_offset+4,
                            0);

        ESGL_offset += sizeof(SG_Element_t);
    }
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

/*+
   Function: CCC_CdbThreadAlloc

    Purpose: Allocates private Test Unit ready CDB to Clear Check Condition.
  Called By: Not Used but functional
      Calls: Not Used
-*/
CDBThread_t *CCC_CdbThreadAlloc(
                             agRoot_t          *hpRoot,
                             DevThread_t       *DevThread,
                             os_bit32 Lun
                           )
{
    agIORequest_t      hpIORequest;
    agIORequestBody_t  hpIORequestBody;
    CDBThread_t       *CDBThread_to_return;
    os_bit32              i;

    for (i = 0;i <  8;i++) hpIORequestBody.CDBRequest.FcpCmnd.FcpLun[i]  = 0;
    for (i = 0;i <  4;i++) hpIORequestBody.CDBRequest.FcpCmnd.FcpCntl[i] = 0;
    for (i = 0;i < 16;i++) hpIORequestBody.CDBRequest.FcpCmnd.FcpCdb[i]  = 0;
    for (i = 0;i <  4;i++) hpIORequestBody.CDBRequest.FcpCmnd.FcpDL[i]   = 0;

    CDBThread_to_return = CDBThreadAlloc(hpRoot,&hpIORequest,(agFCDev_t)DevThread,&hpIORequestBody);

    if (CDBThread_to_return != (CDBThread_t *)agNULL)
    {
        CDBThread_to_return->Lun = Lun;
    }

    return CDBThread_to_return;
}

#endif /* Not USESTATEMACROS  */


/*+
  Function: CDBState_c
   Purpose: When compiled updates browser info file for VC 5.0 / 6.0
   Returns: none
 Called By: none
     Calls: none
-*/
/* void CDBState_c(void){} */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\cmntrans.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/CmnTrans.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 9/07/00 4:35p   $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/CmnTrans.C

--*/

#ifndef __CmnTrans_H__
#define __CmnTrans_H__

/* SF_CMND_Type(SF_CMND_Class==SFThread_SF_CMND_Class_CmnTrans) Declarations */

#define SFThread_SF_CMND_CT_Type_GA_NXT     0x01
#define SFThread_SF_CMND_CT_Type_GPN_ID     0x02
#define SFThread_SF_CMND_CT_Type_GNN_ID     0x03
#define SFThread_SF_CMND_CT_Type_GCS_ID     0x04
#define SFThread_SF_CMND_CT_Type_GFT_ID     0x05
#define SFThread_SF_CMND_CT_Type_GSPN_ID    0x06
#define SFThread_SF_CMND_CT_Type_GPT_ID     0x07
#define SFThread_SF_CMND_CT_Type_GIPP_ID    0x08
#define SFThread_SF_CMND_CT_Type_GID_PN     0x09
#define SFThread_SF_CMND_CT_Type_GIPP_PN    0x0A
#define SFThread_SF_CMND_CT_Type_GID_NN     0x0B
#define SFThread_SF_CMND_CT_Type_GIP_NN     0x0C
#define SFThread_SF_CMND_CT_Type_GIPA_NN    0x0E
#define SFThread_SF_CMND_CT_Type_GSNN_NN    0x0F
#define SFThread_SF_CMND_CT_Type_GNN_IP     0x10
#define SFThread_SF_CMND_CT_Type_GIPA_IP    0x11
#define SFThread_SF_CMND_CT_Type_GID_FT     0x12
#define SFThread_SF_CMND_CT_Type_GID_PT     0x13
#define SFThread_SF_CMND_CT_Type_GID_IPP    0x14
#define SFThread_SF_CMND_CT_Type_GPN_IPP    0x15
#define SFThread_SF_CMND_CT_Type_RPN_ID     0x16
#define SFThread_SF_CMND_CT_Type_RNN_ID     0x17
#define SFThread_SF_CMND_CT_Type_RCS_ID     0x18
#define SFThread_SF_CMND_CT_Type_RFT_ID     0x19
#define SFThread_SF_CMND_CT_Type_RPT_ID     0x1a
#define SFThread_SF_CMND_CT_Type_RIPP_ID    0x1b
#define SFThread_SF_CMND_CT_Type_RIP_NN     0x1c
#define SFThread_SF_CMND_CT_Type_RIPA_NN    0x1d
#define SFThread_SF_CMND_CT_Type_RSNN_NN    0x1e
#define SFThread_SF_CMND_CT_Type_IU_First   0x1f
#define SFThread_SF_CMND_CT_Type_IU_Last    0x20
#define SFThread_SF_CMND_CT_Type_RJT_IU     0x21
#define SFThread_SF_CMND_CT_Type_ACC_IU     0x22





/* SF_CMND_State(SF_CMND_Class==SFThread_SF_CMND_Class_CT,SF_CMND_Type==<any>) Declarations */

#define SFThread_SF_CMND_CT_State_Started  0x01
#define SFThread_SF_CMND_CT_State_Finished 0x02

/* SF_CMND_Status(SF_CMND_Class==SFThread_SF_CMND_Class_CT,SF_CMND_Type==<any>) Declarations */

#define SFThread_SF_CMND_CT_Status_Good 0x01
#define SFThread_SF_CMND_CT_Status_Bad  0x02
#define SFThread_SF_CMND_CT_Status_Confused 0x03

/* Function Prototypes */

osGLOBAL void fiCTInit(
                           agRoot_t *hpRoot
                         );

osGLOBAL os_bit32 fiFillInRFT_ID(
                             SFThread_t *SFThread

                           );

osGLOBAL os_bit32 fiFillInRFT_ID_OnCard(
                                    SFThread_t *SFThread
                                  );

osGLOBAL os_bit32 fiFillInRFT_ID_OffCard(
                                     SFThread_t *SFThread
                                   );
osGLOBAL os_bit32 fiFillInGID_FT(
                             SFThread_t *SFThread

                           );

osGLOBAL os_bit32 fiFillInGID_FT_OnCard(
                                    SFThread_t *SFThread
                                  );

osGLOBAL os_bit32 fiFillInGID_FT_OffCard(
                                     SFThread_t *SFThread
                                   );



osGLOBAL void fiCTProcess_RFT_ID_Response_OnCard(
                                                   SFThread_t *SFThread,
                                                   os_bit32       Frame_Length,
                                                   os_bit32       Offset_to_FCHS,
                                                   os_bit32       Offset_to_Payload,
                                                   os_bit32       Payload_Wrap_Offset,
                                                   os_bit32       Offset_to_Payload_Wrapped
                                                 );

osGLOBAL void fiCTProcess_RFT_ID_Response_OffCard(
                                                    SFThread_t          *SFThread,
                                                    os_bit32                Frame_Length,
                                                    FCHS_t              *FCHS,
                                                    FC_BA_ACC_Payload_t *Payload,
                                                    os_bit32                Payload_Wrap_Offset,
                                                    FC_BA_ACC_Payload_t *Payload_Wrapped
                                                  );

osGLOBAL void fiFillInCTFrameHeader_OnCard(
                                           SFThread_t *SFThread,
                                           os_bit32       D_ID,
                                           os_bit32       X_ID,
                                           os_bit32       F_CTL_Exchange_Context
                                         );

osGLOBAL void fiFillInCTFrameHeader_OffCard(
                                            SFThread_t *SFThread,
                                            os_bit32       D_ID,
                                            os_bit32       X_ID,
                                            os_bit32       F_CTL_Exchange_Context
                                          );
osGLOBAL void fiCTProcess_GID_FT_Response_OffCard(
                                              SFThread_t                 *SFThread,
                                              os_bit32                       Frame_Length,
                                              FCHS_t                     *FCHS,
                                              FC_CT_IU_HDR_t              *Payload,
                                              os_bit32                       Payload_Wrap_Offset,
                                              FC_CT_IU_HDR_t             *Payload_Wrapped
                                            );



#define fiCT_Cmd_Status_ACC              0x00000010
#define fiCT_Cmd_Status_RJT              0x00000011
#define fiCT_Cmd_Status_Confused         0x00000100

osGLOBAL os_bit32 fiCTProcessSFQ(
                                  agRoot_t        *hpRoot,
                                  SFQConsIndex_t   SFQConsIndex,
                                  os_bit32            Frame_Length,
                                  fi_thread__t       **Thread_to_return
                                );

osGLOBAL os_bit32 fiCTProcessSFQ_OnCard(
                                         agRoot_t        *hpRoot,
                                         SFQConsIndex_t   SFQConsIndex,
                                         os_bit32            Frame_Length,
                                         fi_thread__t       **Thread_to_return
                                       );

osGLOBAL os_bit32 fiCTProcessSFQ_OffCard(
                                          agRoot_t        *hpRoot,
                                          SFQConsIndex_t   SFQConsIndex,
                                          os_bit32            Frame_Length,
                                          fi_thread__t       **Thread_to_return
                                        );



#endif /* __CT_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\cmntrans.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/CmnTrans.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 9/20/00 2:35p   $ (Last Modified)

Purpose:

  This file implements Common Transport protocol for the FC Layer.

--*/
#ifndef _New_Header_file_Layout_

#include "../h/globals.h"
#include "../h/state.h"
#include "../h/tgtstate.h"
#include "../h/memmap.h"
#include "../h/tlstruct.h"
#include "../h/fcmain.h"
#include "../h/queue.h"
#include "../h/cmntrans.h"
#include "../h/cfunc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "tgtstate.h"
#include "memmap.h"
#include "tlstruct.h"
#include "fcmain.h"
#include "queue.h"
#include "cmntrans.h"
#include "cfunc.h"
#endif  /* _New_Header_file_Layout_ */

#ifdef NAME_SERVICES

void fiFillInCTFrameHeader_OnCard(
                                    SFThread_t *SFThread,
                                    os_bit32       D_ID,
                                    os_bit32       X_ID,
                                    os_bit32       F_CTL_Exchange_Context
                                  )
{
#ifndef __MemMap_Force_Off_Card__
    agRoot_t  *hpRoot            = SFThread->thread_hdr.hpRoot;
    CThread_t *CThread           = CThread_ptr(hpRoot);
    os_bit32      CT_Header_Offset  = SFThread->SF_CMND_Offset;
    os_bit32      R_CTL__D_ID;
    os_bit32      S_ID;
    os_bit32      TYPE__F_CTL;
    os_bit32      OX_ID__RX_ID;

    S_ID = fiComputeCThread_S_ID(
                                  CThread
                                );

    if (F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Originator)
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Unsolicited_Control
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_Fibre_Channel_Services
                       | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_First_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence
                       | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer);

        OX_ID__RX_ID = (  (SFThread->X_ID << FCHS_OX_ID_SHIFT)
                        | (X_ID           << FCHS_RX_ID_SHIFT));
    }
    else /* F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Responder */
    {
        R_CTL__D_ID = (  FC_Frame_Header_TYPE_Fibre_Channel_Services
                       | FC_Frame_Header_R_CTL_Lo_Solicited_Control
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                       | FC_Frame_Header_F_CTL_Exchange_Context_Responder
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_Last_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence
                       | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer);

        OX_ID__RX_ID = (  (X_ID           << FCHS_OX_ID_SHIFT)
                        | (SFThread->X_ID << FCHS_RX_ID_SHIFT));
    }

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            MBZ1
                                                          ),
                         0
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp
                                                          ),
                         (  FCHS_SOF_SOFi3
                          | FCHS_EOF_EOFn
                          | FCHS_CLS      )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            R_CTL__D_ID
                                                          ),
                         R_CTL__D_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            CS_CTL__S_ID
                                                          ),
                         S_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            TYPE__F_CTL
                                                          ),
                         TYPE__F_CTL
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            SEQ_ID__DF_CTL__SEQ_CNT
                                                          ),
                         FC_Frame_Header_DF_CTL_No_Device_Header
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            OX_ID__RX_ID
                                                          ),
                         OX_ID__RX_ID
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Header_Offset + hpFieldOffset(
                                                            FCHS_t,
                                                            RO
                                                          ),
                         0
                       );
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

void fiFillInCTFrameHeader_OffCard(
                                     SFThread_t *SFThread,
                                     os_bit32       D_ID,
                                     os_bit32       X_ID,
                                     os_bit32       F_CTL_Exchange_Context
                                   )
{
#ifndef __MemMap_Force_On_Card__
    agRoot_t  *hpRoot       = SFThread->thread_hdr.hpRoot;
    CThread_t *CThread      = CThread_ptr(hpRoot);
    FCHS_t    *CT_Header   = SFThread->SF_CMND_Ptr;
    os_bit32      R_CTL__D_ID;
    os_bit32      S_ID;
    os_bit32      TYPE__F_CTL;
    os_bit32      OX_ID__RX_ID;

    S_ID = fiComputeCThread_S_ID(
                                  CThread
                                );

    if (F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Originator)
    {
        R_CTL__D_ID = (  FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                       | FC_Frame_Header_R_CTL_Lo_Unsolicited_Control
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_TYPE_Fibre_Channel_Services
                       | FC_Frame_Header_F_CTL_Exchange_Context_Originator
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_First_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence
                       | FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer);

        OX_ID__RX_ID = (  (SFThread->X_ID << FCHS_OX_ID_SHIFT)
                        | (X_ID           << FCHS_RX_ID_SHIFT));
    }
    else /* F_CTL_Exchange_Context == FC_Frame_Header_F_CTL_Exchange_Context_Responder */
    {
        R_CTL__D_ID = (  FC_Frame_Header_TYPE_Fibre_Channel_Services
                       | FC_Frame_Header_R_CTL_Lo_Solicited_Control
                       | D_ID                                             );

        TYPE__F_CTL = (  FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame
                       | FC_Frame_Header_F_CTL_Exchange_Context_Responder
                       | FC_Frame_Header_F_CTL_Sequence_Context_Initiator
                       | FC_Frame_Header_F_CTL_Last_Sequence
                       | FC_Frame_Header_F_CTL_End_Sequence);

        OX_ID__RX_ID = (  (X_ID           << FCHS_OX_ID_SHIFT)
                        | (SFThread->X_ID << FCHS_RX_ID_SHIFT));
    }

    CT_Header->MBZ1                                        = 0;
    CT_Header->SOF_EOF_MBZ2_UAM_CLS_LCr_MBZ3_TFV_Timestamp =   FCHS_SOF_SOFi3
                                                               | FCHS_EOF_EOFn
                                                               | FCHS_CLS;
    CT_Header->R_CTL__D_ID                                 = R_CTL__D_ID;
    CT_Header->CS_CTL__S_ID                                = S_ID;
    CT_Header->TYPE__F_CTL                                 = TYPE__F_CTL;
    CT_Header->SEQ_ID__DF_CTL__SEQ_CNT                     = FC_Frame_Header_DF_CTL_No_Device_Header;
    CT_Header->OX_ID__RX_ID                                = OX_ID__RX_ID;
    CT_Header->RO                                          = 0;
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInRFT_ID(
                    SFThread_t *SFThread
                  )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInRFT_ID_OnCard(
                                    SFThread
                                  );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInRFT_ID_OffCard(
                                     SFThread
                                   );
    }
}


os_bit32 fiFillInRFT_ID_OnCard(
                             SFThread_t *SFThread
                           )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot                = SFThread->thread_hdr.hpRoot;
    os_bit32        CT_Header_Offset      = SFThread->SF_CMND_Offset;
    os_bit32        CT_Payload_Offset     = CT_Header_Offset + sizeof(FCHS_t);
    os_bit32        RFT_ID_Payload_Offset = CT_Payload_Offset + sizeof(FC_CT_IU_HDR_t);
    os_bit8         Bit8_Index;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_CT;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_CT_Type_RFT_ID;
    SFThread->SF_CMND_State = SFThread_SF_CMND_CT_State_Finished;

/*+
Fill in RFT_ID Frame Header
-*/

    fiFillInCTFrameHeader_OnCard(
                                   SFThread,
#ifdef BROCADE_BUG
                                   0xFFFC41,
#else /* BROCADE_BUG */
                                   FC_Well_Known_Port_ID_Directory_Server,
#endif /* BROCADE_BUG */
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in RFT_ID Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Payload_Offset + hpFieldOffset(
                                                                FC_CT_IU_HDR_t,
                                                                Revision__IN_ID
                                                              ),
                         hpSwapBit32( FC_CT_IU_HDR_Revision_First_Revision )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Payload_Offset + hpFieldOffset(
                                                                FC_CT_IU_HDR_t,
                                                                FS_Type__FS_Subtype__Options
                                                              ),
                         hpSwapBit32( FC_CT_IU_HDR_FS_Type_Directory_Service_Application |
                                      FC_CT_IU_HDR_FS_Subtype_Directory_Name_Service   )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Payload_Offset + hpFieldOffset(
                                                                FC_CT_IU_HDR_t,
                                                                CommandResponse_Code__MaximumResidual_Size
                                                              ),
                         hpSwapBit32( FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RFT_ID |
                                      FC_CT_IU_HDR_MaximumResidual_Size_FS_REQ_No_Maximum)
                       );

/*
   osCardRamWriteBit32(
                        hpRoot,
                        RFT_ID_Payload_Offset + 0,
                        hpSwapBit32(   ((CThread->ChanInfo.CurrentAddress.Domain << 16)
                                 | (CThread->ChanInfo.CurrentAddress.Area   <<  8)
                                 |  CThread->ChanInfo..CurrentAddress.AL_PA        )));




*/



/*

    osCardRamWriteBit8(
                        hpRoot,
                        RFT_ID_Payload_Offset + hpFieldOffset(
                                                                FC_NS_DU_RFT_ID_Payload_t,
                                                                Port_ID[0]
                                                                ),
                        hpSwapBit32(CThread->ChanInfo.CurrentAddress.Domain)
                      );



    osCardRamWriteBit8(
                        hpRoot,
                        RFT_ID_Payload_Offset + hpFieldOffset(
                                                                FC_NS_DU_RFT_ID_Payload_t,
                                                                Port_ID[1]
                                                             ),
                        hpSwapBit32(CThread->ChanInfo.CurrentAddress.Area)
                      );

    osCardRamWriteBit8(
                        hpRoot,
                        RFT_ID_Payload_Offset + hpFieldOffset(
                                                                FC_NS_DU_RFT_ID_Payload_t,
                                                                Port_ID[2]
                                                                ),
                       hpSwapBit32(CThread->ChanInfo.CurrentAddress.AL_PA)
                       );

*/

    for ( Bit8_Index = 0;
            Bit8_Index < sizeof(FC_NS_FC_4_Types_t);
            Bit8_Index++)
    {
        osCardRamWriteBit8(
                            hpRoot,
                            RFT_ID_Payload_Offset + hpFieldOffset(FC_NS_DU_RFT_ID_Payload_t,
                                                                  FC_4_Types[Bit8_Index]),
                            0x00
                            );
    }


     /* Set the SCSI-FCP bit */
     osCardRamWriteBit8(
                            hpRoot,
                            RFT_ID_Payload_Offset + hpFieldOffset(FC_NS_DU_RFT_ID_Payload_t,
                                                                  FC_4_Types[2]),
                            0x01
                        );

    /* May also need to set the FiberChannel Services bit */
    osCardRamWriteBit8(
                            hpRoot,
                            RFT_ID_Payload_Offset + hpFieldOffset(FC_NS_DU_RFT_ID_Payload_t,
                                                                  FC_4_Types[7]),
                            0x01
                        );

/*+
Return length of RFT_ID Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_CT_IU_HDR_t) + sizeof(FC_NS_DU_RFT_ID_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInRFT_ID_OffCard(
                              SFThread_t *SFThread
                              )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    agRoot_t                *hpRoot         = SFThread->thread_hdr.hpRoot;
    CThread_t               *CThread        = CThread_ptr(hpRoot);
    FCHS_t                  *RFT_ID_Header  = SFThread->SF_CMND_Ptr;
    FC_CT_IU_HDR_t          *CT_Header      = (FC_CT_IU_HDR_t *)((os_bit8 *)RFT_ID_Header + sizeof(FCHS_t));
    FC_NS_DU_RFT_ID_Payload_t *RFT_ID_Payload = (FC_NS_DU_RFT_ID_Payload_t *)((os_bit8 *)CT_Header + sizeof(FC_CT_IU_HDR_t));
    os_bit8                    Bit8_Index;
    os_bit32                 * pPayload = (os_bit32 *)CT_Header;

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_CT;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_CT_Type_RFT_ID;
    SFThread->SF_CMND_State = SFThread_SF_CMND_CT_State_Finished;

/*+
Fill in RFT_ID Frame Header
-*/


    fiFillInCTFrameHeader_OffCard(
                                   SFThread,
#ifdef BROCADE_BUG
                                   0xFFFC41,
#else /* BROCADE_BUG */
                                   FC_Well_Known_Port_ID_Directory_Server,
#endif /* BROCADE_BUG */
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in RFT_ID Frame Payload
-*/

    CT_Header->Revision__IN_ID                  =   hpSwapBit32(FC_CT_IU_HDR_Revision_First_Revision);

    CT_Header->FS_Type__FS_Subtype__Options     =  hpSwapBit32(FC_CT_IU_HDR_FS_Type_Directory_Service_Application |
                                                    FC_CT_IU_HDR_FS_Subtype_Directory_Name_Service);

    CT_Header->CommandResponse_Code__MaximumResidual_Size = hpSwapBit32(FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RFT_ID |
                                                        FC_CT_IU_HDR_MaximumResidual_Size_FS_REQ_No_Maximum);

    CT_Header->Reason_Code__Reason_Code_Explanation__Vendor_Unique  =   0;

    RFT_ID_Payload->Port_ID.reserved =   0;
    RFT_ID_Payload->Port_ID.Domain  =   CThread->ChanInfo.CurrentAddress.Domain;
    RFT_ID_Payload->Port_ID.Area  =   CThread->ChanInfo.CurrentAddress.Area;
    RFT_ID_Payload->Port_ID.AL_PA  =   CThread->ChanInfo.CurrentAddress.AL_PA;


    for ( Bit8_Index = 0;
            Bit8_Index < sizeof(FC_NS_FC_4_Types_t);
            Bit8_Index++)
    {

        RFT_ID_Payload->FC_4_Types[Bit8_Index] = 0x0;
    }


/* Set the FC_4_Type to be FCP-SCSI */
    RFT_ID_Payload->FC_4_Types[2]   =   0x01;

/* May also need to set the FiberChannel Services bit */
    RFT_ID_Payload->FC_4_Types[7]   =   0x01;

    fiLogDebugString(
                      hpRoot,
                      CTLogConsoleLevelInfo,
                      "%s Size %X FC_CT_IU_HDR_t %X FC_NS_DU_RFT_ID_Payload_t %X",
                      "RFT_ID",
                      (char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      sizeof(FC_CT_IU_HDR_t) + sizeof(FC_NS_DU_RFT_ID_Payload_t),
                      sizeof(FC_CT_IU_HDR_t),
                      sizeof(FC_NS_DU_RFT_ID_Payload_t),
                      0,0,0,0,0 );

    fiLogDebugString(
                      hpRoot,
                      CTLogConsoleLevelInfo,
                      "%s %08X %08X %08X %08X %08X",
                      "OUT RFT_ID", (char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      hpSwapBit32( *(pPayload+0)),
                      hpSwapBit32( *(pPayload+1)),
                      hpSwapBit32( *(pPayload+2)),
                      hpSwapBit32( *(pPayload+3)),
                      hpSwapBit32( *(pPayload+4)),
                      0,0,0);

    fiLogDebugString(
                      hpRoot,
                      CTLogConsoleLevelInfo,
                      "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                      "OUT RFT_ID",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      hpSwapBit32( *(pPayload+5)),
                      hpSwapBit32( *(pPayload+6)),
                      hpSwapBit32( *(pPayload+7)),
                      hpSwapBit32( *(pPayload+8)),
                      hpSwapBit32( *(pPayload+9)),
                      hpSwapBit32( *(pPayload+10)),
                      hpSwapBit32( *(pPayload+11)),
                      hpSwapBit32( *(pPayload+12)));

/*+
Return length of RFT_ID Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_CT_IU_HDR_t) + sizeof(FC_NS_DU_RFT_ID_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiFillInGID_FT(
                    SFThread_t *SFThread
                  )
{
    if (CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inCardRam)
    {
        return fiFillInGID_FT_OnCard(
                                    SFThread
                                  );
    }
    else /* CThread_ptr(SFThread->thread_hdr.hpRoot)->Calculation.MemoryLayout.SF_CMND.memLoc == inDmaMemory */
    {
        return fiFillInGID_FT_OffCard(
                                     SFThread
                                   );
    }
}


os_bit32 fiFillInGID_FT_OnCard(
                             SFThread_t *SFThread
                           )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    agRoot_t    *hpRoot                = SFThread->thread_hdr.hpRoot;
    os_bit32     CT_Header_Offset      = SFThread->SF_CMND_Offset;
    os_bit32     CT_Payload_Offset     = CT_Header_Offset + sizeof(FCHS_t);
    os_bit32     GID_FT_Payload_Offset = CT_Payload_Offset + sizeof(FC_CT_IU_HDR_t);

    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_CT;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_CT_Type_GID_FT;
    SFThread->SF_CMND_State = SFThread_SF_CMND_CT_State_Finished;

/*+
Fill in GID_FT Frame Header
-*/

    fiFillInCTFrameHeader_OnCard(
                                   SFThread,
#ifdef BROCADE_BUG
                                   0xFFFC41,
#else /* BROCADE_BUG */
                                   FC_Well_Known_Port_ID_Directory_Server,
#endif /* BROCADE_BUG */
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in GID_FT Frame Payload
-*/

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Payload_Offset + hpFieldOffset(
                                                                FC_CT_IU_HDR_t,
                                                                Revision__IN_ID
                                                              ),
                         hpSwapBit32( FC_CT_IU_HDR_Revision_First_Revision )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Payload_Offset + hpFieldOffset(
                                                                FC_CT_IU_HDR_t,
                                                                FS_Type__FS_Subtype__Options
                                                              ),
                         hpSwapBit32( FC_CT_IU_HDR_FS_Type_Directory_Service_Application |
                                      FC_CT_IU_HDR_FS_Subtype_Directory_Name_Service   )
                       );

    osCardRamWriteBit32(
                         hpRoot,
                         CT_Payload_Offset + hpFieldOffset(
                                                                FC_CT_IU_HDR_t,
                                                                CommandResponse_Code__MaximumResidual_Size
                                                              ),
                         hpSwapBit32( FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GID_FT |
                                      FC_CT_IU_HDR_MaximumResidual_Size_FS_REQ_No_Maximum)
                       );

    osCardRamWriteBit32(
                        hpRoot,
                        GID_FT_Payload_Offset + hpFieldOffset(
                                                                FC_NS_DU_GID_FT_Request_Payload_t,
                                                                FC_4_Type_Code
                                                                ),
                         hpSwapBit32(FC_Frame_Header_TYPE_SCSI_FCP >>
                                           FC_NS_DU_GID_FT_FC_Frame_Header_TYPE_SCSI_FCP_Shift)
                      );



/*+
Return length of GID_FT Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_CT_IU_HDR_t) + sizeof(FC_NS_DU_GID_FT_Request_Payload_t);
#endif /* __MemMap_Force_Off_Card__ was not defined */
}

os_bit32 fiFillInGID_FT_OffCard(
                              SFThread_t *SFThread
                              )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    FCHS_t                              *GID_FT_Header  = SFThread->SF_CMND_Ptr;
    FC_CT_IU_HDR_t                      *CT_Header      = (FC_CT_IU_HDR_t *)((os_bit8 *)GID_FT_Header + sizeof(FCHS_t));
    FC_NS_DU_GID_FT_Request_Payload_t   *GID_FT_Payload = (FC_NS_DU_GID_FT_Request_Payload_t *)
                                                            ((os_bit8 *)CT_Header + sizeof(FC_CT_IU_HDR_t));

    os_bit32 * Payload =(os_bit32 *) GID_FT_Payload;
    os_bit32 * Header =(os_bit32 *) CT_Header;
    SFThread->SF_CMND_Class = SFThread_SF_CMND_Class_CT;
    SFThread->SF_CMND_Type  = SFThread_SF_CMND_CT_Type_GID_FT;
    SFThread->SF_CMND_State = SFThread_SF_CMND_CT_State_Finished;

/*+
Fill in GID_FT Frame Header
-*/


    fiFillInCTFrameHeader_OffCard(
                                   SFThread,
#ifdef BROCADE_BUG
                                   0xFFFC41,
#else /* BROCADE_BUG */
                                   FC_Well_Known_Port_ID_Directory_Server,
#endif /* BROCADE_BUG */
                                   0xFFFF,
                                   FC_Frame_Header_F_CTL_Exchange_Context_Originator
                                 );

/*+
Fill in GID_FT Frame Payload
-*/

    CT_Header->Revision__IN_ID                  =   hpSwapBit32(FC_CT_IU_HDR_Revision_First_Revision);

    CT_Header->FS_Type__FS_Subtype__Options     =  hpSwapBit32(FC_CT_IU_HDR_FS_Type_Directory_Service_Application |
                                                    FC_CT_IU_HDR_FS_Subtype_Directory_Name_Service);

    CT_Header->CommandResponse_Code__MaximumResidual_Size
                                                = hpSwapBit32(FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GID_FT |
                                                        FC_CT_IU_HDR_MaximumResidual_Size_FS_REQ_No_Maximum);

    CT_Header->Reason_Code__Reason_Code_Explanation__Vendor_Unique = hpSwapBit32(0);

    GID_FT_Payload->FC_4_Type_Code              =   hpSwapBit32(FC_Frame_Header_TYPE_SCSI_FCP >>
                                                    FC_NS_DU_GID_FT_FC_Frame_Header_TYPE_SCSI_FCP_Shift);

    fiLogDebugString(SFThread->thread_hdr.hpRoot,
                CFuncLogConsoleERROR,
                "%s %08X %08X %08X %08X %s %08X",
                "CT_Header","GID_FT_Payload",
                (void *)agNULL,(void *)agNULL,
                hpSwapBit32(*(Header+0)),
                hpSwapBit32(*(Header+1)),
                hpSwapBit32(*(Header+2)),
                hpSwapBit32(*(Header+3)),
                hpSwapBit32(*(Payload+0)),
                0,0,0 );


/*+
Return length of GID_FT Frame (including FCHS and Payload)
-*/

    return sizeof(FCHS_t) + sizeof(FC_CT_IU_HDR_t) + sizeof(FC_NS_DU_GID_FT_Request_Payload_t);
#endif /* __MemMap_Force_On_Card__ was not defined */
}

os_bit32 fiCTProcessSFQ(
                           agRoot_t        *hpRoot,
                           SFQConsIndex_t   SFQConsIndex,
                           os_bit32            Frame_Length,
                           fi_thread__t       **Thread_to_return
                         )
{
    if (CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFQ.memLoc == inCardRam)
    {
        return fiCTProcessSFQ_OnCard(
                                           hpRoot,
                                           SFQConsIndex,
                                           Frame_Length,
                                           Thread_to_return
                                         );
    }
    else /* CThread_ptr(hpRoot)->Calculation.MemoryLayout.SFQ.memLoc == inDmaMemory */
    {
        return fiCTProcessSFQ_OffCard(
                                            hpRoot,
                                            SFQConsIndex,
                                            Frame_Length,
                                            Thread_to_return
                                          );
    }
}



os_bit32 fiCTProcessSFQ_OnCard(
                                   agRoot_t        *hpRoot,
                                   SFQConsIndex_t   SFQConsIndex,
                                   os_bit32         Frame_Length,
                                   fi_thread__t   **Thread_to_return
                                 )
{
#ifdef __MemMap_Force_Off_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_Off_Card__ was not defined */
    CThread_t                  *CThread                    = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFQ_MemoryDescriptor       = &(CThread->Calculation.MemoryLayout.SFQ);
    os_bit32                       Offset_to_FCHS             = SFQ_MemoryDescriptor->addr.CardRam.cardRamOffset
                                                             + (SFQConsIndex * SFQ_MemoryDescriptor->elementSize);
    os_bit32                    Offset_to_Payload          = Offset_to_FCHS + sizeof(FCHS_t);
    os_bit32                    Payload_Wrap_Offset        = SFQ_MemoryDescriptor->objectSize
                                                             - (SFQConsIndex * SFQ_MemoryDescriptor->elementSize)
                                                             - sizeof(FCHS_t);
    os_bit32                    Offset_to_Payload_Wrapped  = Offset_to_Payload
                                                             - SFQ_MemoryDescriptor->objectSize;
    os_bit32                    R_CTL__D_ID;
    os_bit32                    TYPE__F_CTL;
    os_bit32                    Recv_CT_Type;
    os_bit32                    Recv_Command_Code;
    os_bit32                    Sent_CT_Type;
    X_ID_t                      OX_ID;
    X_ID_t                      RX_ID;

    fiMemMapMemoryDescriptor_t *CDBThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.CDBThread);
    os_bit32                       CDBThread_X_ID_Max         = CDBThread_MemoryDescriptor->elements - 1;
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.SFThread);
    os_bit32                    SFThread_X_ID_Offset       = CDBThread_X_ID_Max + 1;
    SFThread_t                 *SFThread;

    /* Note the assumption that the entire FCHS fits in the pointed to SFQ entry (i.e. it doesn't wrap) */

    OX_ID = (X_ID_t)(((osCardRamReadBit32(
                                           hpRoot,
                                           Offset_to_FCHS + hpFieldOffset(FCHS_t,OX_ID__RX_ID)
                                         ) & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    RX_ID = (X_ID_t)(((osCardRamReadBit32(
                                           hpRoot,
                                           Offset_to_FCHS + hpFieldOffset(FCHS_t,OX_ID__RX_ID)
                                         ) & FCHS_RX_ID_MASK) >> FCHS_RX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    R_CTL__D_ID = osCardRamReadBit32(
                                      hpRoot,
                                      Offset_to_FCHS + hpFieldOffset(FCHS_t,R_CTL__D_ID)
                                    );

    TYPE__F_CTL = osCardRamReadBit32(
                                      hpRoot,
                                      Offset_to_FCHS + hpFieldOffset(FCHS_t,TYPE__F_CTL)
                                    );


    if ((TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) == FC_Frame_Header_TYPE_Fibre_Channel_Services)
    {
        /* Process FibreChannel Services frames   */

        if ( (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) != FC_Frame_Header_F_CTL_Exchange_Context_Responder )
        {
            /* Starting here, this function only understands Service Responses */

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "fiCTProcessSFQ_OnCard(): Len %X",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Frame_Length,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK)",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "        != FC_Frame_Header_F_CTL_Exchange_Context_Responder",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    TYPE__F_CTL==0x%08X",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              TYPE__F_CTL,
                              0,0,0,0,0,0,0
                              );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    R_CTL__D_ID 0x%08X",
                              (void *)agNULL,(void *)agNULL,
                              (char *)agNULL,
                              (char *)agNULL,
                              R_CTL__D_ID,
                              0,0,0,0,0,0,0
                             );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiCT_Cmd_Status_Confused;
        }


        Recv_CT_Type = R_CTL__D_ID & FC_Frame_Header_R_CTL_Lo_MASK;

        if (Recv_CT_Type != FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame)
        {


            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "fiCTProcessSFQ_OnCard():",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );


            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiCT_Cmd_Status_Confused;
        }

       /* Now we will have to look into the IU unit and parse on
         * FS_Type to see if this is a ACC or RJT
         */

    if ((hpFieldOffset(FC_CT_IU_HDR_t,CommandResponse_Code__MaximumResidual_Size) + sizeof(os_bit32)) <= Payload_Wrap_Offset)
    {
        Recv_Command_Code = hpSwapBit32(osCardRamReadBit32(
                                                        hpRoot,
                                                        Offset_to_Payload + hpFieldOffset(FC_CT_IU_HDR_t,CommandResponse_Code__MaximumResidual_Size)
                                                      ));
    }
    else
    {
        Recv_Command_Code = hpSwapBit32(osCardRamReadBit32(
                                                        hpRoot,
                                                        Offset_to_Payload_Wrapped + hpFieldOffset(FC_CT_IU_HDR_t,CommandResponse_Code__MaximumResidual_Size)
                                                      ));
    }

    Recv_Command_Code = (Recv_Command_Code & FC_CT_IU_HDR_CommandResponse_Code_MASK);

     if ((Recv_Command_Code != FC_CT_IU_HDR_CommandResponse_Code_FS_ACC_IU) ||
          (Recv_Command_Code != FC_CT_IU_HDR_CommandResponse_Code_FS_RJT_IU)  )

     {
            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "fiCTProcessSFQ_OnCard():",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    Not ACC nor REJ",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0);


            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiCT_Cmd_Status_Confused;
        }

        SFThread = (SFThread_t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                              + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

        *Thread_to_return = (fi_thread__t *)SFThread;

        Sent_CT_Type = SFThread->SF_CMND_Type;

        SFThread->SF_CMND_State = SFThread_SF_CMND_CT_State_Finished;
        switch(Sent_CT_Type)
        {
            case SFThread_SF_CMND_CT_Type_RFT_ID:
                /* Since we don't have to do anything, let's not call another function here.
                 * Just check to see if this an ACC or reject and return the right status.
                 */
                return ((Recv_Command_Code == FC_CT_IU_HDR_CommandResponse_Code_FS_ACC_IU) ? fiCT_Cmd_Status_ACC : fiCT_Cmd_Status_RJT);
             case SFThread_SF_CMND_CT_Type_GID_FT:
                /* Since we don't have to do anything, let's not call another function here.
                 * Just check to see if this an ACC or reject and return the right status.
                 */

                /* Copy the payload for now into the Cthread. It is unknown how this is going to
                   be presented to the device handles etc. */


                return ((Recv_Command_Code == FC_CT_IU_HDR_CommandResponse_Code_FS_ACC_IU) ? fiCT_Cmd_Status_ACC : fiCT_Cmd_Status_RJT);

            default:
            /* Unknown CT Command recorded in SFThread */

                    fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "fiCTProcessSFQ_OnCard(): Unknown CT Command [0x%02X] recorded in SFThread->SF_CMND_Type",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              Sent_CT_Type,
                              0,0,0,0,0,0,0
                            );

            return fiCT_Cmd_Status_Confused;
        }
    }

    return fiCT_Cmd_Status_Confused;
#endif   /* __MemMap_Force_Off_Card__ */
}



os_bit32 fiCTProcessSFQ_OffCard(
                                   agRoot_t        *hpRoot,
                                   SFQConsIndex_t   SFQConsIndex,
                                   os_bit32            Frame_Length,
                                   fi_thread__t       **Thread_to_return
                                 )
{
#ifdef __MemMap_Force_On_Card__
    return (os_bit32)0;
#else /* __MemMap_Force_On_Card__ was not defined */
    CThread_t                  *CThread                   = CThread_ptr(hpRoot);
    fiMemMapMemoryDescriptor_t *SFQ_MemoryDescriptor      = &(CThread->Calculation.MemoryLayout.SFQ);
    FCHS_t                     *FCHS                      = (FCHS_t *)((os_bit8 *)(SFQ_MemoryDescriptor->addr.DmaMemory.dmaMemoryPtr)
                                                                        + (SFQConsIndex * SFQ_MemoryDescriptor->elementSize));
    FC_CT_IU_HDR_t              *Payload                  = (FC_CT_IU_HDR_t *)((os_bit8 *)FCHS + sizeof(FCHS_t));
    os_bit32                    Payload_Wrap_Offset       = SFQ_MemoryDescriptor->objectSize
                                                             - (SFQConsIndex * SFQ_MemoryDescriptor->elementSize)
                                                             - sizeof(FCHS_t);
    FC_CT_IU_HDR_t              *Payload_Wrapped          = (FC_CT_IU_HDR_t *)((os_bit8 *)Payload
                                                                                          - SFQ_MemoryDescriptor->objectSize);
    os_bit32                    R_CTL__D_ID               = FCHS->R_CTL__D_ID;
    os_bit32                    TYPE__F_CTL               = FCHS->TYPE__F_CTL;
    os_bit32                    Recv_Command_Code;
    os_bit32                    Recv_CT_Type;
    X_ID_t                      OX_ID;
    X_ID_t                      RX_ID;
    fiMemMapMemoryDescriptor_t *CDBThread_MemoryDescriptor = &(CThread->Calculation.MemoryLayout.CDBThread);
    os_bit32                    CDBThread_X_ID_Max         = CDBThread_MemoryDescriptor->elements - 1;
    fiMemMapMemoryDescriptor_t *SFThread_MemoryDescriptor  = &(CThread->Calculation.MemoryLayout.SFThread);
    os_bit32                    SFThread_X_ID_Offset       = CDBThread_X_ID_Max + 1;
    SFThread_t                 *SFThread;
    os_bit32                    Sent_CT_Type;
    os_bit32                 * pPayload = (os_bit32 *)Payload;

    /* Note the assumption that the entire FCHS fits in the pointed to SFQ entry (i.e. it doesn't wrap) */

    OX_ID = (X_ID_t)(((FCHS->OX_ID__RX_ID & FCHS_OX_ID_MASK) >> FCHS_OX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);

    RX_ID = (X_ID_t)(((FCHS->OX_ID__RX_ID & FCHS_RX_ID_MASK) >> FCHS_RX_ID_SHIFT) & ~X_ID_ReadWrite_MASK);


    if ((TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) == FC_Frame_Header_TYPE_Fibre_Channel_Services)
    {
        /* Process FibreChannel Services frames   */

        if ( (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK) != FC_Frame_Header_F_CTL_Exchange_Context_Responder )
        {
            /* Starting here, this function only understands Service Responses */

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "fiCTProcessSFQ_OffCard():",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    (TYPE__F_CTL & FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK)",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "        != FC_Frame_Header_F_CTL_Exchange_Context_Responder",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    TYPE__F_CTL==0x%08X",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              TYPE__F_CTL,
                              0,0,0,0,0,0,0
                              );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    R_CTL__D_ID 0x%08X",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              R_CTL__D_ID,
                              0,0,0,0,0,0,0
                             );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiCT_Cmd_Status_Confused;
        }


        Recv_CT_Type = R_CTL__D_ID & FC_Frame_Header_R_CTL_Hi_MASK;


        if (Recv_CT_Type != FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame)
        {


            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "fiCTProcessSFQ_OffCard():",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    (Recv_CT_Type != FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame)",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    Recv_CT_Type==0x%08X",
                              (void *)agNULL,(void *)agNULL,
                              (char *)agNULL,
                              (char *)agNULL,
                              Recv_CT_Type,
                              0,0,0,0,0,0,0
                            );

            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiCT_Cmd_Status_Confused;
        }

       /* Now we will have to look into the IU unit and parse on
         * FS_Type to see if this is an ACC or RJT
         */

        Recv_Command_Code = hpSwapBit32(Payload->CommandResponse_Code__MaximumResidual_Size);
        Recv_Command_Code = (Recv_Command_Code & FC_CT_IU_HDR_CommandResponse_Code_MASK);

        if (!(Recv_Command_Code == FC_CT_IU_HDR_CommandResponse_Code_FS_ACC_IU  ||
              Recv_Command_Code == FC_CT_IU_HDR_CommandResponse_Code_FS_RJT_IU ))

        {
            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "fiCTProcessSFQ_OffCard():",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "    Not ACC nor REJ",
                              (char *)agNULL,
                              (char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0);


            *Thread_to_return = (fi_thread__t *)agNULL;

            return fiCT_Cmd_Status_Confused;
        }

        SFThread = (SFThread_t *)((os_bit8 *)SFThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr
                              + ((OX_ID - SFThread_X_ID_Offset) * SFThread_MemoryDescriptor->elementSize));

        *Thread_to_return = (fi_thread__t *)SFThread;

        Sent_CT_Type = SFThread->SF_CMND_Type;

        SFThread->SF_CMND_State = SFThread_SF_CMND_CT_State_Finished;
        switch(Sent_CT_Type)
        {
            case SFThread_SF_CMND_CT_Type_RFT_ID:
                /* Since we don't have to do anything, let's not call another function here.
                 * Just check to see if this an ACC or reject and return the right status.
                 */
                        fiLogDebugString(
                                          hpRoot,
                                          CTLogConsoleLevelInfo,
                                          "%s %08X %08X %08X %08X",
                                          "IN RFT_ID",
                                          (char *)agNULL,
                                          (void *)agNULL,(void *)agNULL,
                                          hpSwapBit32( *(pPayload+0)),
                                          hpSwapBit32( *(pPayload+1)),
                                          hpSwapBit32( *(pPayload+2)),
                                          hpSwapBit32( *(pPayload+3)),
                                          0,0,0,0);


                return ((Recv_Command_Code == FC_CT_IU_HDR_CommandResponse_Code_FS_ACC_IU) ? fiCT_Cmd_Status_ACC : fiCT_Cmd_Status_RJT);

           case SFThread_SF_CMND_CT_Type_GID_FT:
                /* Since we don't have to do anything, let's not call another function here.
                 * Just check to see if this an ACC or reject and return the right status.
                 * Copy the payload into the right place.
                 */
                        fiLogDebugString(
                                          hpRoot,
                                          CTLogConsoleLevelInfo,
                                          "%s %08X %08X %08X %08X %08X %08X %08X %08X ",
                                          "GID_FT",
                                          (char *)agNULL,
                                          (void *)agNULL,(void *)agNULL,
                                          hpSwapBit32( *(pPayload+0)),
                                          hpSwapBit32( *(pPayload+1)),
                                          hpSwapBit32( *(pPayload+2)),
                                          hpSwapBit32( *(pPayload+3)),
                                          hpSwapBit32( *(pPayload+4)),
                                          hpSwapBit32( *(pPayload+5)),
                                          hpSwapBit32( *(pPayload+6)),
                                          hpSwapBit32( *(pPayload+7)));

                    fiCTProcess_GID_FT_Response_OffCard(
                                         SFThread,
                                         Frame_Length,
                                         FCHS,
                                         (FC_CT_IU_HDR_t *)Payload,
                                         Payload_Wrap_Offset,
                                         (FC_CT_IU_HDR_t *)Payload_Wrapped
                                       );

                return ((Recv_Command_Code == FC_CT_IU_HDR_CommandResponse_Code_FS_ACC_IU) ? fiCT_Cmd_Status_ACC : fiCT_Cmd_Status_RJT);

            default:
            /* Unknown CT Command recorded in SFThread */

                    fiLogDebugString(
                              hpRoot,
                              CTLogConsoleLevel,
                              "fiCTProcessSFQ_OffCard(): Unknown CT Command ",
                              (char *)agNULL,(char *)agNULL,
                              (void *)agNULL,(void *)agNULL,
                              0,0,0,0,0,0,0,0
                            );

            return fiCT_Cmd_Status_Confused;
        }

    } /*(TYPE__F_CTL & FC_Frame_Header_TYPE_MASK) == FC_Frame_Header_TYPE_Fibre_Channel_Services */

    return fiCT_Cmd_Status_Confused;
#endif    /* __MemMap_Force_Off_Card__ */
}


void fiCTProcess_GID_FT_Response_OffCard(
                                              SFThread_t                 *SFThread,
                                              os_bit32                    Frame_Length,
                                              FCHS_t                     *FCHS,
                                              FC_CT_IU_HDR_t              *Payload,
                                              os_bit32                    Payload_Wrap_Offset,
                                              FC_CT_IU_HDR_t             *Payload_Wrapped
                                            )
{

#ifndef __MemMap_Force_On_Card__
    agRoot_t                            *hpRoot             = SFThread->thread_hdr.hpRoot;
    CThread_t                           *pCThread           = CThread_ptr(hpRoot);
    FC_NS_DU_GID_FT_FS_ACC_Payload_t    *pGID_FT_Payload;
    os_bit32                             Bit8_Index         =0;
    os_bit32                             Bit32_Index        =0;
    os_bit32                             CurrentBit32_Index = pCThread->NS_CurrentBit32Index;
    os_bit32                             NumDevices         = pCThread->Calculation.Parameters.NumDevices;

    os_bit32                            *pPayload = (os_bit32 *)Payload;

    FC_NS_DU_GID_PT_FS_ACC_Payload_t * RegisteredEntries  = (FC_NS_DU_GID_PT_FS_ACC_Payload_t *)(CThread_ptr(hpRoot)->Calculation.MemoryLayout.FabricDeviceMAP.addr.CachedMemory.cachedMemoryPtr);

    /* Zero out old Fabric MAP for changes in Zoning */
    for(Bit8_Index=0;Bit8_Index < NumDevices; Bit8_Index++)
    {
        RegisteredEntries->Control_Port_ID[Bit8_Index].Control = 0;
        RegisteredEntries->Control_Port_ID[Bit8_Index].Port_ID[0] = 0;
        RegisteredEntries->Control_Port_ID[Bit8_Index].Port_ID[1] = 0;
        RegisteredEntries->Control_Port_ID[Bit8_Index].Port_ID[2] = 0;
    }

    Payload_Wrap_Offset = Payload_Wrap_Offset - sizeof(FC_CT_IU_HDR_t);

    fiLogDebugString( hpRoot,
                    CTLogConsoleLevel,
                    "%s Payload %p Payload_Wrapped %p FL %d",
                    "fiCTProcess_GID_FT_Response_OffCard",
                    (char *)agNULL,
                    (void *)Payload,(void *)Payload_Wrapped,
                    Frame_Length,
                    0,0,0,0,0,0,0 );

    fiLogDebugString( hpRoot,
                   CTLogConsoleLevel,
                    "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                    "GID_FT",
                    (char *)agNULL,
                    FCHS,(void *)agNULL,
                    hpSwapBit32( *(pPayload+0)),
                    hpSwapBit32( *(pPayload+1)),
                    hpSwapBit32( *(pPayload+2)),
                    hpSwapBit32( *(pPayload+3)),
                    hpSwapBit32( *(pPayload+4)),
                    hpSwapBit32( *(pPayload+5)),
                    hpSwapBit32( *(pPayload+6)),
                    hpSwapBit32( *(pPayload+7)));

    fiLogDebugString( hpRoot,
                  CTLogConsoleLevel,
                  "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                  "GID_FT",
                  (char *)agNULL,
                  (void *)agNULL,(void *)agNULL,
                  hpSwapBit32( *(pPayload+8)),
                  hpSwapBit32( *(pPayload+9)),
                  hpSwapBit32( *(pPayload+10)),
                  hpSwapBit32( *(pPayload+11)),
                  hpSwapBit32( *(pPayload+12)),
                  hpSwapBit32( *(pPayload+13)),
                  hpSwapBit32( *(pPayload+14)),
                  hpSwapBit32( *(pPayload+15)));

    if( Frame_Length > (FC_NS_DU_GID_PT_FS_ACC_Payload_t_SIZE + sizeof(FCHS_t) + sizeof(FC_CT_IU_HDR_t)) )
    {

        fiLogString(hpRoot,
                    "%s Frame (%x) To Large !(%X)",
                    "fiCTProcess_GID_FT_Response_OffCard",
                    (char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Frame_Length,
                    FC_NS_DU_GID_PT_FS_ACC_Payload_t_SIZE + sizeof(FCHS_t) + sizeof(FC_CT_IU_HDR_t),
                    0,0,0,0,0,0 );

        fiLogDebugString( hpRoot,
                    CTLogConsoleLevel,
                    "%s Frame (%x) To Large !(%X)",
                    "fiCTProcess_GID_FT_Response_OffCard",
                    (char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    Frame_Length,
                    FC_NS_DU_GID_PT_FS_ACC_Payload_t_SIZE + sizeof(FCHS_t) + sizeof(FC_CT_IU_HDR_t),
                    0,0,0,0,0,0 );
        Frame_Length = (FC_NS_DU_GID_PT_FS_ACC_Payload_t_SIZE + sizeof(FCHS_t) + sizeof(FC_CT_IU_HDR_t));
    }

    while (Bit32_Index <= ((Frame_Length - sizeof(FCHS_t) - sizeof(FC_CT_IU_HDR_t))/sizeof(os_bit32)))
    {
        if ((hpFieldOffset(FC_NS_DU_GID_FT_FS_ACC_Payload_t,Control_Port_ID[Bit32_Index])
            + sizeof(os_bit32)) <= Payload_Wrap_Offset)
        {
            pGID_FT_Payload = (FC_NS_DU_GID_FT_FS_ACC_Payload_t *)((os_bit8 *)Payload + sizeof(FC_CT_IU_HDR_t));
            RegisteredEntries->Control_Port_ID[CurrentBit32_Index].Control = pGID_FT_Payload->Control_Port_ID[Bit32_Index].Control;

            for (Bit8_Index = 0;
                Bit8_Index < (FC_NS_Control_Port_ID_t_SIZE - 1);
                Bit8_Index++)
            {
                RegisteredEntries->Control_Port_ID[CurrentBit32_Index].Port_ID[Bit8_Index] = pGID_FT_Payload->Control_Port_ID[Bit32_Index].Port_ID[Bit8_Index];
            }
        }
        else
        {
            pGID_FT_Payload = (FC_NS_DU_GID_FT_FS_ACC_Payload_t *)((os_bit8 *)Payload_Wrapped + sizeof(FC_CT_IU_HDR_t));
            RegisteredEntries->Control_Port_ID[CurrentBit32_Index].Control = pGID_FT_Payload->Control_Port_ID[Bit32_Index].Control;

            for (Bit8_Index = 0;
                Bit8_Index < (FC_NS_Control_Port_ID_t_SIZE - 1);
                Bit8_Index++)
            {
                RegisteredEntries->Control_Port_ID[CurrentBit32_Index].Port_ID[Bit8_Index] = pGID_FT_Payload->Control_Port_ID[Bit32_Index].Port_ID[Bit8_Index];
            }
        }


       if (RegisteredEntries->Control_Port_ID[CurrentBit32_Index].Control == FC_NS_Control_Port_ID_Control_Last_Port_ID)
       {
            pCThread->ExpectMoreNSFrames = agFALSE;
            pCThread->NS_CurrentBit32Index = 0;
            fiLogDebugString( hpRoot,
                CTLogConsoleLevel,
                "fiCTProcessSFQ_OffCard(): Reached End of Name Server Database NumOfEntries %x ",
                (char *)agNULL,
                (char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                CurrentBit32_Index,
                0,0,0,0,0,0,0
                );

            break;
        }

        Bit32_Index++;
        CurrentBit32_Index++;
        if( CurrentBit32_Index == NumDevices)
        {   /* Dont go beyond number of devices */
            /* Set Last entry to indicate end   */
            RegisteredEntries->Control_Port_ID[CurrentBit32_Index].Control = FC_NS_Control_Port_ID_Control_Last_Port_ID;
            break;

        }
        pCThread->NS_CurrentBit32Index = CurrentBit32_Index;
    }
    pPayload = (os_bit32 *)RegisteredEntries;
    fiLogDebugString( hpRoot,
                    CTLogConsoleLevel,
                    "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                    "Reg E",
                    (char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32( *(pPayload+0)),
                    hpSwapBit32( *(pPayload+1)),
                    hpSwapBit32( *(pPayload+2)),
                    hpSwapBit32( *(pPayload+3)),
                    hpSwapBit32( *(pPayload+4)),
                    hpSwapBit32( *(pPayload+5)),
                    hpSwapBit32( *(pPayload+6)),
                    hpSwapBit32( *(pPayload+7)));
    fiLogDebugString( hpRoot,
                    CTLogConsoleLevel,
                    "%s %08X %08X %08X %08X %08X %08X %08X %08X",
                    "Reg E",
                    (char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    hpSwapBit32( *(pPayload+8)),
                    hpSwapBit32( *(pPayload+9)),
                    hpSwapBit32( *(pPayload+10)),
                    hpSwapBit32( *(pPayload+11)),
                    hpSwapBit32( *(pPayload+12)),
                    hpSwapBit32( *(pPayload+13)),
                    hpSwapBit32( *(pPayload+14)),
                    hpSwapBit32( *(pPayload+15)));


#endif /* __MemMap_Force_On_Card__ was not defined */
}

#endif /* NAME_SERVICES */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\control.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    Control.c

Abstract:

    This is the miniport driver for the Agilent
    PCI to Fibre Channel Host Bus Adapter (HBA). This module is specific to the NT 5.0 
    PnP and Power Management Support.

Authors:
    IW - Ie Wei Njoo
 
Environment:

    kernel mode only

Version Control Information:

    $Archive: /Drivers/Win2000/Trunk/OSLayer/C/CONTROL.C $

Revision History:

    $Revision: 5 $
    $Date: 10/23/00 5:35p $
    $Modtime::  $

Notes:

--*/


#include "buildop.h"

#include "osflags.h"
#include "TLStruct.H"

#ifdef HP_NT50

#ifdef _DEBUG_EVENTLOG_
extern PVOID      gDriverObject;
#endif

/*++

Routine Description:

    Support routines to perform synchronous operation to control the state
    or behavior of the HBA, such as for the PnP and power management (NT 5.0).

Arguments:

    pCard-  Points to the miniport driver's per-HBA storage area. 
    ControlType - Specifies the adapter-control operations. 
    Parameters -  If ControlType is ScsiStopAdapter, ScsiSetBootConfig, 
              ScsiSetRunningConfig, or ScsiRestartAdapter, Parameters is NULL. 

              If ControlType is ScsiQuerySupportedControlTypes, Parameters 
              points to a caller-allocated SCSI_SUPPORTED_CONTROL_TYPE_LIST 
              structure, 

Return Value:

    ScsiAdapterControlSuccess - The miniport completed the requested operation
    successfully. Currently, this routine must return this value for all
    control types.

    ScsiAdapterControlUnsuccessful - Reserved for future NT 5.0 use.

--*/
SCSI_ADAPTER_CONTROL_STATUS
HPAdapterControl(
    IN PCARD_EXTENSION pCard,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    )
{
    agRoot_t * phpRoot = &pCard->hpRoot;
    PSCSI_SUPPORTED_CONTROL_TYPE_LIST pControlTypeList;
    ULONG return_value;

    switch(ControlType) 
    {
        case ScsiQuerySupportedControlTypes: 
        {
            pControlTypeList = (PSCSI_SUPPORTED_CONTROL_TYPE_LIST) Parameters;
            pControlTypeList->SupportedTypeList[ScsiQuerySupportedControlTypes] = TRUE;   
            pControlTypeList->SupportedTypeList[ScsiStopAdapter]           = TRUE;  
            pControlTypeList->SupportedTypeList[ScsiRestartAdapter]           = TRUE;  
            osDEBUGPRINT((ALWAYS_PRINT, "HPAdapterControl: ScsiQuerySupportedControlTypes called.\n"));
            break;
        }

        case ScsiStopAdapter: 
        {
            //
            // Shut down all interrupts on the adapter.  They'll get re-enabled
            // by the initialization routines.
            //
    
            pCard->inDriver = TRUE;    // Make sure the timer routine will be idle

         
            fcShutdownChannel(phpRoot);
            osDEBUGPRINT((ALWAYS_PRINT, "HPAdapterControl: ScsiStopAdapter called.\n"));
            
            #ifdef _DEBUG_EVENTLOG_
            LogEvent(   pCard, 
                  NULL,
                  HPFC_MSG_ADAPTERCONTROL_STOP,
                  NULL, 
                  0, 
                  NULL);
         
            if (pCard->EventLogBufferIndex < MAX_CARDS_SUPPORTED)
            {
                StopEventLogTimer(gDriverObject, (PVOID) pCard);
                ReleaseEventLogBuffer(gDriverObject, (PVOID) pCard);
                }
            #endif
            break;
        }

        case ScsiRestartAdapter: 
        {
            //
            // Enable all the interrupts on the adapter while port driver call
            // for power up an HBA that was shut down for power management
            //

            return_value = fcInitializeChannel(  phpRoot,
                                                fcSyncInit,
                                                agTRUE, // sysIntsActive
                                                pCard->cachedMemoryPtr,
                                                pCard->cachedMemoryNeeded,
                                                pCard->dmaMemoryUpper32,
                                                pCard->dmaMemoryLower32,
                                                pCard->dmaMemoryPtr,
                                                pCard->dmaMemoryNeeded,
                                                pCard->nvMemoryNeeded,
                                                pCard->cardRamUpper,
                                                pCard->cardRamLower,
                                                pCard->RamLength ,
                                                pCard->cardRomUpper,
                                                pCard->cardRomLower,
                                                pCard->RomLength,
                                                pCard->usecsPerTick );

            if (return_value != fcInitializeSuccess) 
            {
                osDEBUGPRINT((ALWAYS_PRINT, "HPAdapterControl: fcInitializeChannel FAILED.\n"));
                #ifdef _DEBUG_EVENTLOG_
                LogEvent(   pCard, 
                  NULL,
                  HPFC_MSG_ADAPTERCONTROL_RESTARTFAILED,
                  NULL, 
                  0, 
                  NULL);
                #endif
            }
            else
            {
                osDEBUGPRINT((ALWAYS_PRINT, "HPAdapterControl: ScsiRestartAdapter OK.\n"));
                pCard->inDriver = FALSE;      // The timer routine could now do usefull work
            }
         
            #ifdef _DEBUG_EVENTLOG_
            {
                ULONG    ix;
         
                ix = AllocEventLogBuffer(gDriverObject, (PVOID) pCard);
                if (ix < MAX_CARDS_SUPPORTED)
                {
                pCard->EventLogBufferIndex = ix;                      /* store it */
                StartEventLogTimer(gDriverObject,pCard);
                }
            
                LogHBAInformation(pCard);
            }
            #endif

            break;
        }

        default: 
        {
            #ifdef _DEBUG_EVENTLOG_
            LogEvent(   pCard, 
                  NULL,
                  HPFC_MSG_ADAPTERCONTROL_UNSUPPORTEDCOMMAND,
                  NULL, 
                  0, 
                  "%x", ControlType);
            #endif
            osDEBUGPRINT((ALWAYS_PRINT, "HPAdapterControl: ScsiAdapterControlUnsuccessful.\n"));
            return ScsiAdapterControlUnsuccessful;
        }
    }

    return ScsiAdapterControlSuccess;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\cstate.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/CSTATE.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 7/24/00 1:47p   $

Purpose:

  This file defines the macros, types, and data structures
  used by ../C/CState.C

--*/

#ifndef __CState_H__
#define __CState_H__

#define CSTATE_NOISE( hpRoot, State ) (CThread_ptr(hpRoot)->thread_hdr.currentState == State ?  CStateLogConsoleLevel : CStateLogConsoleERROR)




#define CStateConfused              0
#define CStateShutdown              1
#define CStateInitialize            2
#define CStateInitFM                3
#define CStateInitDataStructs       4
#define CStateVerify_AL_PA          5
#define CStateAllocFlogiThread      6
#define CStateDoFlogi               7
#define CStateFlogiSuccess          8
#define CStateALPADifferent         9
#define CStateFreeSFthread          10
#define CStateSuccess               11
#define CStateNormal                12
#define CStateResetNeeded           13
#define CStateLoopFail              14
#define CStateReInitFM              15
#define CStateInitializeFailed      16
#define CStateLoopFailedReInit      17
#define CStateFindDevice            18 /**/

#define CStateElasticStoreEventStorm 19
#define CStateLIPEventStorm          20

#define CStateExternalDeviceReset     21

#define CStateExternalLogout          22
#define CStateExternalLogoutRecovery  23

#define CStateDoExternalDeviceReset   24
#define CStateSendPrimitive           25

#define CStateInitFM_DelayDone        26

#define CStateAllocRFT_IDThread       27
#define CStateDoRFT_ID                28
#define CStateRFT_IDSuccess           29
#define CStateAllocDiPlogiThread      30
#define CStateDoDiPlogi               31
#define CStateDiPlogiSuccess          32
#define CStateAllocGID_FTThread       33
#define CStateDoGID_FT                34
#define CStateGID_FTSuccess           35

#define CStateFindDeviceUseNameServer 36
#define CStateFindDeviceUseLoopMap    37

#define CStateAllocSCRThread          38
#define CStateDoSCR                   39
#define CStateSCRSuccess              40

#define CStateRSCNErrorBackIOs        41
#define CStateFindPtToPtDevice        42

#define CStateFlipNPortState          43

#define CStateMAXState  CStateFlipNPortState



#define CEventShutdown                  0
#define CEventDoInitalize               1
#define CEventInitChipSuccess           2
#define CEventInitalizeFailure          3
#define CEventInitFMSuccess             4
#define CEventInitFMFailure             5
#define CEventDataInitalizeSuccess      6
#define CEventAllocFlogiThread          7
#define CEventGotFlogiThread            8
#define CEventFlogiSuccess              9
#define CEventFlogiFail                 10
#define CEventSameALPA                  11
#define CEventChangedALPA               12
#define CEventInitalizeSuccess          13
#define CEventAsyncLoopEventDetected    14
#define CEventResetDetected             15
#define CEventResetNotNeeded            16   /* 10 */
#define CEventResetIfNeeded             17   /* 11 */

#define CEventLoopEventDetected         18   /* 12 */

#define CEventLoopConditionCleared      19   /* 13 */
#define CEventLoopNeedsReinit           20   /* 14 */
#define CEventReInitFMSuccess           21   /* 15 */
#define CEventReInitFMFailure           22   /* 16 */

#define CEventNextDevice                23   /* 17 */
#define CEventDeviceListEmpty           24   /* 18 */
#define CEventElasticStoreEventStorm    25   /* 19 */
#define CEventLIPEventStorm             26   /* 1A */

#define CEvent_AL_PA_BAD                27

#define CEventExternalDeviceReset       28

#define CEventExternalLogout            29

#define CEventDoExternalDeviceReset     30

#define CEventSendPrimitive             31

#define CEventDelay_for_FM_init         32

#define CEventAllocRFT_IDThread         33
#define CEventDoRFT_ID                  34
#define CEventRFT_IDSuccess             35
#define CEventRFT_IDFail                36



#define CEventAllocDiPlogiThread        37
#define CEventDoDiPlogi                 38
#define CEventDiPlogiSuccess            39
#define CEventDiPlogiFail               40

#define CEventAllocGID_FTThread         41
#define CEventDoGID_FT                  42
#define CEventGID_FTSuccess             43
#define CEventGID_FTFail                44


#define CEventFindDeviceUseNameServer   45
#define CEventFindDeviceUseLoopMap      46

#define CEventAllocSCRThread            47
#define CEventDoSCR                     48
#define CEventSCRSuccess                49
#define CEventSCRFail                   50
#define CEventRSCNErrorBackIOs          51
#define CEventFindPtToPtDevice          52
#define CEventClearHardwareFoulup       53

#define CEventFlipNPortState            54

#define CEventGoToInitializeFailed      55 

#define CEventMAXEvent  CEventGoToInitializeFailed

STATE_PROTO(CActionConfused          );
STATE_PROTO(CActionShutdown          );
STATE_PROTO(CActionInitialize        );
STATE_PROTO(CActionInitFM            );
STATE_PROTO(CActionInitDataStructs   );
STATE_PROTO(CActionVerify_AL_PA      );
STATE_PROTO(CActionAllocFlogiThread  );
STATE_PROTO(CActionDoFlogi           );
STATE_PROTO(CActionFlogiSuccess      );
STATE_PROTO(CActionALPADifferent     );
STATE_PROTO(CActionFreeSFthread      );
STATE_PROTO(CActionSuccess           );
STATE_PROTO(CActionNormal            );
STATE_PROTO(CActionResetNeeded       );
STATE_PROTO(CActionLoopFail          );
STATE_PROTO(CActionReInitFM          );
STATE_PROTO(CActionInitializeFailed  );
STATE_PROTO(CActionLoopFailedReInit  );
STATE_PROTO(CActionFindDevice        );
STATE_PROTO(CActionFindDeviceUseAllALPAs  );
STATE_PROTO(CActionFindDeviceUseLoopMap   );
STATE_PROTO(CActionFindDeviceUseNameServer);
STATE_PROTO(CActionFindPtToPtDevice);


STATE_PROTO(CActionElasticStoreEventStorm);
STATE_PROTO(CActionLIPEventStorm         );
STATE_PROTO(CActionExternalDeviceReset   );

STATE_PROTO(CActionExternalLogout        );
STATE_PROTO(CActionExternalLogoutRecovery);

STATE_PROTO(CActionDoExternalDeviceReset);

STATE_PROTO(CActionSendPrimitive);
STATE_PROTO(CActionInitFM_DelayDone);
STATE_PROTO(CActionFlipNPortState);

/* Begin: Big_Endian_Code */
#ifdef hpMustSwapDmaMem
#define SENDIO(hpRoot,CThread,Thread,Func) CFuncSwapDmaMemBeforeIoSent(Thread,Func)
#define AFTERIO(hpRoot) CFuncSwapDmaMemAfterIoDone(hpRoot)
#else /* hpMustSwapDmaMem */
#define SENDIO(hpRoot,CThread,Thread,Func) osChipIOLoWriteBit32(hpRoot,ChipIOLo_ERQ_Producer_Index,(os_bit32)CThread->HostCopy_ERQProdIndex)
#define AFTERIO(hpRoot); 
#endif /* hpMustSwapDmaMem */

#define DoFuncCdbCmnd  0
#define DoFuncSfCmnd   1
/* End: Big_Endian_Code */


STATE_PROTO(CActionAllocRFT_IDThread);
STATE_PROTO(CActionDoRFT_ID);
STATE_PROTO(CActionRFT_IDSuccess);
STATE_PROTO(CActionAllocDiPlogiThread);
STATE_PROTO(CActionDoDiPlogi);
STATE_PROTO(CActionDiPlogiSuccess);
STATE_PROTO(CActionAllocGID_FTThread);
STATE_PROTO(CActionDoGID_FT);
STATE_PROTO(CActionGID_FTSuccess);
STATE_PROTO(CActionAllocSCRThread);
STATE_PROTO(CActionDoSCR);
STATE_PROTO(CActionSCRSuccess);

STATE_PROTO(CActionRSCNErrorBackIOs);
STATE_PROTO(CActionRSCNErrorBackIOsOther);

#define CSubStateInitialized            0
#define CSubStateNormal                 1
#define CSubStateResettingDevices       2

/*
#define ROLL(index, end)    index=((index+1) & (end-1))
*/
#define ROLL(index, end)   (index++ < (end-1) ?  index : (index = 0))


#define FULL(index,end) (index == end ? agTRUE : agFALSE)
#define NEXT_INDEX(index, end)    ((index+1) & (end-1))

#define CLipStormQueisingTOV        (5 * 1000000)  /* 5 Seconds*/
#define CResetChipDelay             (4 * 100000 )  /* 400 MilliSeconds*/
#define CInitFM_Delay               (1 * 100000 )  /* 100 MilliSeconds*/
#define CReinitNportAfterFailureDetectionTOV (50 * 1000000) /* 50 seconds */
#define CFlipNportTOV             (150 * 1000000) /* 150 seconds */
#define CWaitAfterRATOV            (10 * 1000000) /* 10 Seconds */
#define CWaitAfterFlogi             (2 * 1000000) /* 2 Seconds */

extern stateTransitionMatrix_t CStateTransitionMatrix;
extern stateActionScalar_t     CStateActionScalar;


#ifdef USESTATEMACROS

void testCthread( agRoot_t *hpRoot  );

#define CSTATE_FUNCTION_ACTION( x , Action) extern void x( fi_thread__t * thread, \
                 eventRecord_t * eventRecord ){         \
    agRoot_t * hpRoot=thread->hpRoot;                   \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d",             \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "Sends event...%s %d",          \
                      #Action,(char *)agNULL,             \
                      (void * )agNULL,(void * )agNULL,  \
                      Action,0,0,0,0,0,0,0);            \
    fiSetEventRecord(eventRecord, thread, Action);   }  \

#define CSTATE_FUNCTION_TERMINATE(x) extern void x(fi_thread__t *thread,\
                                      eventRecord_t *eventRecord ){\
    agRoot_t * hpRoot=thread->hpRoot;                            \
    CThread_t  * pCThread=CThread_ptr(hpRoot);                   \
    CDBThread_t * pCDBThread=(CDBThread_t * )thread;             \
    DevThread_t * pDevThread=pCDBThread->Device;                 \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d",     \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "...simply returns",            \
                      (char *)agNULL,(char *)agNULL,        \
                      (void * )agNULL,(void * )agNULL,  \
                      0,0,0,0,0,0,0,0);                 \
    eventRecord->thread = agNULL;                         \
    }\


#define CSTATE_FUNCTION_MULTI_ACTION(x,Action0,Action1,Action2,Action3) extern void x( fi_thread__t *thread,\
                                      eventRecord_t *eventRecord ){ \
    agRoot_t * hpRoot = thread->hpRoot;                            \
    CThread_t  * pCThread = CThread_ptr(hpRoot);                   \
    CDBThread_t * pCDBThread = (CDBThread_t * )thread;             \
    DevThread_t * pDevThread = pCDBThread->Device;                 \
    os_bit8 WhichAction[4];                                            \
    static  os_bit32 ActionCount=0;                                    \
    WhichAction[0] = Action0;                                       \
    WhichAction[1] = Action1;                                       \
    WhichAction[2] = Action2;                                       \
    WhichAction[3] = Action3;                                       \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d ALPA %X",     \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                    \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "...returns event %s %d",       \
                      #Action0,#Action1,                \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)WhichAction[ActionCount],  \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "or %s  or %s",                  \
                      (void * )agNULL,(void * )agNULL,  \
                      #Action2,#Action3,                \
                      0,0,0,0,0,0,0,0);                 \
    fiSetEventRecord(eventRecord,thread,WhichAction[ActionCount]);  \
    if(ActionCount<3)ActionCount++;                              \
    else ActionCount =0;                                            \
    }                                                               \

#ifdef TestCStateMachine

char * CStateString[]=
{
    "CStateConfused                ",
    "CStateShutdown                ",
    "CStateInitialize              ",
    "CStateInitFM                  ",
    "CStateInitDataStructs         ",
    "CStateVerify_AL_PA            ",
    "CStateAllocFlogiThread        ",
    "CStateDoFlogi                 ",
    "CStateFlogiSuccess            ",
    "CStateALPADifferent           ",
    "CStateFreeSFthread            ",
    "CStateSuccess                 ",
    "CStateNormal                  ",
    "CStateResetNeeded             ",
    "CStateLoopFail                ",
    "CStateReInitFM                ",
    "CStateInitializeFailed        ",
    "CStateLoopFailedReInit        ",
    "CStateFindDevice              ",
    "CStateElasticStoreEventStorm  ",
    "CStateLIPEventStorm           ",
    "CStateExternalDeviceReset     ",
    "CStateExternalLogout          ",
    "CStateExternalLogoutRecovery  ",
    "CStateDoExternalDeviceReset   ",
    "CStateSendPrimitive           ",
    "CStateInitFM_DelayDone        ",
    "CStateAllocRFT_IDThread       ",
    "CStateDoRFT_ID                ",
    "CStateRFT_IDSuccess           ",
    "CStateAllocDiPlogiThread      ",
    "CStateDoDiPlogi               ",
    "CStateDiPlogiSuccess          ",
    "CStateAllocGID_FTThread       ",
    "CStateDoGID_FT                ",
    "CStateGID_FTSuccess           ",
    "CStateFindDeviceUseNameServer ",
    "CStateFindDeviceUseLoopMap    ",
    "CStateAllocSCRThread          ",
    "CStateDoSCR                   ",
    "CStateSCRSuccess              ",
    "CStateRSCNErrorBackIOs        ",
    "CStateFindPtToPtDevice        ",
    "CStateFlipNPortState          ",
    agNULL
};

char * CEventString[]=
{
    "CEventShutdown                  ",
    "CEventInitalize                 ",
    "CEventInitChipSuccess           ",
    "CEventInitalizeFailure          ",
    "CEventInitFMSuccess             ",
    "CEventInitFMFailure             ",
    "CEventDataInitalizeSuccess      ",
    "CEventAllocFlogiThread          ",
    "CEventGotFlogiThread            ",
    "CEventFlogiSuccess              ",
    "CEventFlogiFail                 ",
    "CEventSameALPA                  ",
    "CEventChangedALPA               ",
    "CEventInitalizeSuccess          ",
    "CEventAsyncLoopEventDetected    ",
    "CEventResetDetected             ",
    "CEventResetNotNeeded            ",
    "CEventResetIfNeeded             ",
    "CEventLoopEventDetected         ",
    "CEventLoopConditionCleared      ",
    "CEventLoopNeedsReinit           ",
    "CEventReInitFMSuccess           ",
    "CEventReInitFMFailure           ",
    "CEventNextDevice                ",
    "CEventDeviceListEmpty           ",
    "CEventElasticStoreEventStorm    ",
    "CEventLIPEventStorm             ",
    "CEvent_AL_PA_BAD                ",
    "CEventExternalDeviceReset       ",
    "CEventExternalLogout            ",
    "CEventDoExternalDeviceReset     ",
    "CEventSendPrimitive             ",
    "CEventDelay_for_FM_init         ",
    "CEventAllocRFT_IDThread         ",
    "CEventDoRFT_ID                  ",
    "CEventRFT_IDSuccess             ",
    "CEventRFT_IDFail                ",
    "CEventAllocDiPlogiThread        ",
    "CEventDoDiPlogi                 ",
    "CEventDiPlogiSuccess            ",
    "CEventDiPlogiFail               ",
    "CEventAllocGID_FTThread         ",
    "CEventDoGID_FT                  ",
    "CEventGID_FTSuccess             ",
    "CEventGID_FTFail                ",
    "CEventFindDeviceUseNameServer   ",
    "CEventFindDeviceUseLoopMap      ",
    "CEventAllocSCRThread            ",
    "CEventDoSCR                     ",
    "CEventSCRSuccess                ",
    "CEventSCRFail                   ",
    "CEventRSCNErrorBackIOs          ",
    "CEventFindPtToPtDevice          ",
    "CEventClearHardwareFoulup       ",
    "CEventFlipNPortState            ",
    agNULL
};


#endif /*  TestCStateMachine was defined */

#endif /* USESTATEMACROS was defined */

#endif /*  __CState_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\cstring.c ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

    csprintf.c

Abstract:

    This is source contains String utility functions

Authors:

    
Environment:

    kernel mode only

Notes:

Version Control Information:

    $Archive: /Drivers/Win2000/MSE/OSLayer/C/cstring.c $


Revision History:

    $Revision: 4 $
    $Date: 12/07/00 1:35p $
    $Modtime:: 12/07/00 1:35p           $

Notes:


--*/

#include <stdarg.h>

#ifndef NULL
#define NULL 0
#endif

/*++

Routine Description:

    Check for white spaces
   
Arguments:
    c           - character
    
Return Value:

    1 = white space
    0 = anythingelse

--*/
int C_isspace (char c) 
{
    return (c == '\t' || c == '\n' || c == ' ');
}

/*
 * Cstrlen
 */
int C_strlen(const char *str)
{
    int count;
    if( !str )
    {
        return 0;
    }
    for (count = 0; *str; str++,count++);

    return count;
}


int C_strnlen(const char *str, int maxLen)
{
    int count;
    if( !str )
    {
        return 0;
    }
    for (count = 0; *str && ((unsigned) count <= (unsigned)maxLen); str++,count++);

    return count;
}

int C_isxdigit(char a)
{
   return ( ((a >= 'a') && (a <= 'z')) ||
            ((a >= 'A') && (a <= 'Z')) ||
            ((a >= '0') && (a <= '9')) );
}

int C_isdigit(char a)
{
   return ( ((a >= '0') && (a <= '9')) );
}

int C_islower(char a)
{
   return ( ((a >= 'a') && (a <= 'z')) );
}

int C_isupper(char a)
{
   return ( ((a >= 'A') && (a <= 'Z')) );
}

char C_toupper(char a)
{
   if (C_islower (a) )
      return (a - 'a' + 'A' );
   else
      return a;
}

char *C_stristr(const char *String, const char *Pattern)
{
   char           *pptr, *sptr, *start;
   unsigned int   slen, plen;

   if(!String || !Pattern)
   {
        return(NULL);
   }
   for (start = (char *)String,
        pptr  = (char *)Pattern,
        slen  = C_strlen(String),
        plen  = C_strlen(Pattern);
        /* while string length not shorter than pattern length */
        slen >= plen;
        start++, slen--)
   {
      /* find start of pattern in string */
      while (C_toupper(*start) != C_toupper(*Pattern))
      {
         start++;
         slen--;

         /* if pattern longer than string */

         if (slen < plen)
            return(NULL);
      }

      sptr = start;
      pptr = (char *)Pattern;

      while (C_toupper(*sptr) == C_toupper(*pptr))
      {
         sptr++;
         pptr++;

         /* if end of pattern then pattern was found */

         if ('\0' == *pptr)
            return (start);
      }
   }
   return(NULL);
}


char *C_strncpy (
   char *destStr,
   char *sourceStr,
   int   count)
{
    if( !destStr || !sourceStr )
    {
        return NULL;
    }
   while (count--) 
   {
      *destStr = *sourceStr;
      if (*sourceStr == '\0')
         break;
      *destStr++;
      *sourceStr++;
   }
   return destStr;

}

char *C_strcpy (
   char *destStr,
   char *sourceStr)
{
   return C_strncpy (destStr,sourceStr,-1) ;
}



long C_strtoul(const char *cp,char **endp,unsigned int base)
{
    unsigned long result = 0,value;
    if (!base) 
    {
        base = 10;
        if (*cp == '0') 
        {
            base = 8;
            cp++;
            if ((*cp == 'x') && C_isxdigit(cp[1])) 
            {
                cp++;
                base = 16;
            }
        }
    }
    while (C_isxdigit(*cp) && (value = C_isdigit(*cp) ? *cp-'0' : (C_islower(*cp)
        ? C_toupper(*cp) : *cp)-'A'+10) < base) 
    {
        result = result*base + value;
        cp++;
    }
    if (endp)
        *endp = (char *)cp;
    return result;
}

long C_strtol(const char *cp,char **endp,unsigned int base)
{
    if(*cp=='-')
        return -C_strtoul(cp+1,endp,base);
    return C_strtoul(cp,endp,base);
}


static int skip_atoi(const char **s)
{
    int i=0;

    while (C_isdigit(**s))
        i = i*10 + *((*s)++) - '0';
    return i;
}

#define ZEROPAD 1       /* pad with zero */
#define SIGN    2       /* unsigned/signed long */
#define PLUS    4       /* show plus */
#define SPACE   8       /* space if plus */
#define LEFT    16      /* left justified */
#define SPECIAL 32      /* 0x */
#define LARGE   64      /* use 'ABCDEF' instead of 'abcdef' */

long do_div(long *n,int base) 
{ 
    long __res; 

    __res = ((unsigned long) *n) % (unsigned) base; 
    *n = ((unsigned long) *n) / (unsigned) base; 

    return __res; 
}

static char * number(char * str,
                     long num, 
                     int base, 
                     int size, 
                     int precision,
                     int type)
{
    char c,sign,tmp[66];
    const char *digits="0123456789abcdefghijklmnopqrstuvwxyz";
    int i;

    if (type & LARGE)
        digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

    if (type & LEFT)
        type &= ~ZEROPAD;

    if (base < 2 || base > 36)
        return 0;

    c = (type & ZEROPAD) ? '0' : ' ';
    sign = 0;

    if (type & SIGN) 
    {
        if (num < 0) 
        {
            sign = '-';
            num = -num;
            size--;
        } 
        else 
        {   
            if (type & PLUS) 
            {
            sign = '+';
            size--;
            } 
            else 
            {   
                if (type & SPACE) 
                {
                sign = ' ';
                size--;
                }
            }
        }
    }

    if (type & SPECIAL) 
    {
        if (base == 16)
            size -= 2;
        else 
            if (base == 8)
            size--;
    }

    i = 0;
    if (num == 0)
        tmp[i++]='0';
    else 
    {   
        while (num != 0)
            tmp[i++] = digits[do_div(&num,base)];
    }

    if (i > precision)
        precision = i;

    size -= precision;
    if (!(type&(ZEROPAD+LEFT)))
    {
        while(size-->0)
            *str++ = ' ';
    }

    if (sign)
        *str++ = sign;
    if (type & SPECIAL) 
    {
        if (base==8)
            *str++ = '0';
        else 
        {
            if (base==16) 
            {
                *str++ = '0';
                *str++ = digits[33];
            }
        }
    }

    if (!(type & LEFT))
        while (size-- > 0)
            *str++ = c;
    while (i < precision--)
        *str++ = '0';
    while (i-- > 0)
        *str++ = tmp[i];
    while (size-- > 0)
        *str++ = ' ';
    return str;
}

/* 
 * Limited functionality vsprintf
 */
int C_vsprintf(char *buf, const char *fmt, va_list args)
{
    long len;
    unsigned long num;
    int i;
    int base;
    char * str;
    const char *s;

    int flags;      /* flags to number() */

    int field_width;    /* width of output field */
    int precision;      /* min. # of digits for integers; max
                   number of chars for from string */
    int qualifier;      /* 'h', 'l', or 'L' for integer fields */
    if( !buf || !fmt )
    {
        return 0;
    }
    for (str=buf ; *fmt ; ++fmt) 
    {
        if (*fmt != '%') 
        {
            *str++ = *fmt;
            continue;
        }
            
        /* process flags */
        flags = 0;
        
repeat:
        ++fmt;      /* this also skips first '%' */
        switch (*fmt) 
        {
            case '-': flags |= LEFT; goto repeat;
            case '+': flags |= PLUS; goto repeat;
            case ' ': flags |= SPACE; goto repeat;
            case '#': flags |= SPECIAL; goto repeat;
            case '0': flags |= ZEROPAD; goto repeat;
        }
        
        /* get field width */
        field_width = -1;
        if (C_isdigit(*fmt))
            field_width = skip_atoi(&fmt);
        else 
        {
            if (*fmt == '*') 
            {
                ++fmt;
                /* it's the next argument */
                field_width = va_arg(args, int);
                if (field_width < 0) 
                {
                    field_width = -field_width;
                    flags |= LEFT;
                }
            }
        }
        
        /* get the precision */
        precision = -1;
        if (*fmt == '.') 
        {
            ++fmt;  
            if (C_isdigit(*fmt))
                precision = skip_atoi(&fmt);
            else if (*fmt == '*') 
            {
                ++fmt;
                /* it's the next argument */
                precision = va_arg(args, int);
            }
            if (precision < 0)
                precision = 0;
        }

        /* get the conversion qualifier */
        qualifier = -1;
        if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L') 
        {
            qualifier = *fmt;
            ++fmt;
        }

        /* default base */
        base = 10;

        switch (*fmt) 
        {
            case 'c':
                if (!(flags & LEFT))
                    while (--field_width > 0)
                        *str++ = ' ';
                *str++ = (unsigned char) va_arg(args, int);
                while (--field_width > 0)
                    *str++ = ' ';
                continue;

            case 's':
                s = va_arg(args, char *);
                if (!s)
                    s = "<NULL>";

                len = C_strnlen(s, precision);

                if (!(flags & LEFT))
                    while (len < field_width--)
                        *str++ = ' ';
                for (i = 0; i < len; ++i)
                    *str++ = *s++;
                while (len < field_width--)
                    *str++ = ' ';
                continue;

            case '%':
                *str++ = '%';
                continue;

            /* integer number formats - set up the flags and "break" */
            case 'o':
                base = 8;
                break;

            case 'X':
                flags |= LARGE;
            case 'x':
                base = 16;
                break;

            case 'd':
            case 'i':
                flags |= SIGN;
            case 'u':
                break;

            default:
                *str++ = '%';
                if (*fmt)
                    *str++ = *fmt;
                else
                    --fmt;
                continue;
            }

        if (qualifier == 'l')
            num = va_arg(args, unsigned long);
        else 
            if (qualifier == 'h') 
            {
                num = (unsigned short) va_arg(args, int);
                if (flags & SIGN)
                    num = (short) num;
            } 
            else 
                if (flags & SIGN)
                    num = va_arg(args, int);
                else
                    num = va_arg(args, unsigned int);
            str = number(str, num, base, field_width, precision, flags);
    }

    *str = '\0';
    return ((int) (str-buf));
}

int C_sprintf(char * buf, const char *fmt, ...)
{
    va_list args;
    int i;

    va_start(args, fmt);
    i=C_vsprintf(buf,fmt,args);
    va_end(args);
    return i;
}

#ifdef TESTING_MODE
int main(int argc, char* argv[])
{

    char test[512];

    C_sprintf (test,"%s=%x\n", "hello mam", 12);

    C_sprintf (test,"%-10s said %s\n", "Mommie", "yes");
    
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\cstring.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

   string.h

Abstract:

   This is the reset bus enty point for the Agilent
   PCI to Fibre Channel Host Bus Adapter (HBA).

Authors:

   Leopold Purwadihardja

Environment:

   kernel mode only

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/cstring.h $

Revision History:

   $Revision: 1 $
   $Date: 10/23/00 6:26p $
   $Modtime:: 10/19/00 3:26p        $

Notes:


--*/


#ifndef __SSTRING_H_inc__
#define __SSTRING_H_inc__

extern int C_isspace(char a);
extern int C_isdigit(char a);
extern int C_isxdigit(char a);
extern int C_islower(char a);
extern char C_toupper(char a);
extern char *C_stristr(const char *String, const char *Pattern);
extern char *C_strncpy (char *destStr,char *sourceStr,int   count);
extern char *C_strcpy (char *destStr, char *sourceStr);
extern int C_sprintf(char *buffer, const char *format, ...);
extern int C_vsprintf(char *buffer, const char *format, void *va_list);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\cstate.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/CSTATE.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 10/27/00 6:31p  $

Purpose:

  This file implements the FC Layer State Machine.

--*/

#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/fcstruct.h"
#include "../h/state.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/linksvc.h"
#include "../h/cmntrans.h"
#include "../h/flashsvc.h"
#include "../h/timersvc.h"

#include "../h/cstate.h"
#include "../h/cfunc.h"
#include "../h/devstate.h"
#include "../h/cdbstate.h"
#include "../h/sfstate.h"

#include "../h/queue.h"
#include "../h/cdbsetup.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "fcstruct.h"
#include "state.h"

#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"
#include "linksvc.h"
#include "cmntrans.h"
#include "flashsvc.h"
#include "timersvc.h"

#include "cstate.h"
#include "cfunc.h"
#include "devstate.h"
#include "cdbstate.h"
#include "sfstate.h"

#include "queue.h"
#include "cdbsetup.h"
#endif  /* _New_Header_file_Layout_ */

extern stateTransitionMatrix_t  DevStateTransitionMatrix;
extern stateActionScalar_t      DevStateActionScalar;
extern stateTransitionMatrix_t  SFstateTransitionMatrix;
extern stateActionScalar_t      SFstateActionScalar;


stateTransitionMatrix_t CStateTransitionMatrix = {
    /* Event/State 0        State 1          State 2...             */
    CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
      CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
        CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
          CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
            CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
              CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
                CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
                  CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
                    CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
                      CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
                        CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
                          CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
                            CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
    CStateShutdown,
      CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
        CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
          CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
            CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
              CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
                CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,CStateShutdown,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 1  CEventDoInitalize                                           */
    CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
      CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
        CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
          CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
            CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
              CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
                CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
                  CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
                    CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
                      CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
                        CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
                          CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
                            CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
    CStateInitialize,
      CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
        CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
          CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
            CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
              CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
                CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,CStateInitialize,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 2  CEventInitChipSuccess                                                    */
    0,0,CStateInitFM,0,0,
      0,0,0,0,0,
        0,0,CStateNormal,0,0,
#ifdef NPORT_STUFF
          CStateInitFM,CStateInitFM,0,0,0,
#else /* NPORT_STUFF */
          0,CStateInitFM,0,0,0,
#endif /* NPORT_STUFF */
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,

    0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 3  CEventInitalizeFailure                                                    */
    0,0,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,
      0,0,CStateInitializeFailed,0,0,
        CStateInitializeFailed,0,CStateResetNeeded,CStateInitializeFailed,CStateInitializeFailed,
          CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateResetNeeded,CStateInitializeFailed,
            CStateInitializeFailed,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 4  CEventInitFMSuccess                                                    */
    0,0,0,CStateInitDataStructs,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,CStateLoopFailedReInit,CStateInitDataStructs,0,CStateElasticStoreEventStorm,
            CStateLIPEventStorm,0,0,0,0,
              0,CStateInitDataStructs,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 5  CEventInitFMFailure                                                    */
    0,0,0,CStateInitializeFailed,0,
      0,0,0,0,0,
        0,0,0,CStateInitializeFailed,0,
          0,0,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,
            CStateInitializeFailed,0,0,0,0,
              0,CStateInitializeFailed,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 6   CEventDataInitalizeSuccess                         */
    0,0,0,0,CStateVerify_AL_PA,
      0,0,0,0,0,
        0,0,0,CStateVerify_AL_PA,0,
          0,0,CStateLoopFailedReInit,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 7   CEventAllocFlogiThread                             */
    0,0,0,0,0,
      CStateAllocFlogiThread,0,0,0,0,
        0,0,0,CStateResetNeeded,0,
          0,CStateAllocFlogiThread,CStateLoopFailedReInit,0,CStateElasticStoreEventStorm,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 8   CEventGotFlogiThread                               */
    0,0,0,0,0,
      0,CStateDoFlogi,CStateDoFlogi,0,0,
        0,CStateResetNeeded,0,CStateResetNeeded,0,
          0,0,CStateLoopFailedReInit,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 9    CEventFlogiSuccess                                */
    0,0,0,0,0,
      0,0,CStateFlogiSuccess,0,0,
        0,0,0,CStateResetNeeded,0,
          0,0,CStateLoopFailedReInit,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 10  A CEventFlogiFail                                  */
    0,0,0,0,0,
      0,0,CStateFreeSFthread,0,0,
        0,0,0,CStateFreeSFthread,0,
          0,0,CStateLoopFailedReInit,0,CStateElasticStoreEventStorm,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 11  B  CEventSameALPA                                  */
    0,0,0,0,0,
      0,CStateSuccess,0,CStateSuccess,0,
        CStateSuccess,0,0,CStateLoopFailedReInit,0,
          0,0,CStateLoopFailedReInit,0,0,
            0,0,0,0,0,
              0,CStateSuccess,0,0,0,
                0,0,0,0,0,
                  CStateSuccess,0,0,0,0,
                    CStateSuccess,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 12  C  CEventChangedALPA                               */
    0,0,0,0,0, 0,0,0,CStateALPADifferent,0,         0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 13  D  CEventInitalizeSuccess                          */
    0,0,0,0,0,
      0,0,0,0,0,
        CStateResetNeeded,CStateFindDevice,0,CStateResetNeeded,CStateInitialize,
          CStateInitialize,CStateInitialize,CStateInitialize,CStateSuccess,0,
            CStateResetNeeded,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,CStateFindDevice,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 14  E  CEventAsyncLoopEventDetected                    */
    CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,
      CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,
        CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,
          CStateResetNeeded,CStateResetNeeded,CStateLoopFailedReInit,CStateResetNeeded,CStateResetNeeded,
            CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,
              CStateResetNeeded,CStateResetNeeded,0,CStateResetNeeded,0,
                CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,
                  0,CStateResetNeeded,CStateResetNeeded,0,CStateResetNeeded,
                    CStateResetNeeded,CStateResetNeeded,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 15  F  CEventResetDetected                             */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,CStateLoopFail,CStateLoopFail,0,
          0,CStateLoopFailedReInit,0,0,0,
            0,0,0,0,0,
              CStateLoopFail,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 16  10  CEventResetNotNeeded                           */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 17  11  CEventResetIfNeeded                            */
    CStateInitialize,0,0,0,0,
      0,0,0,0,0,
        0,0,CStateNormal,CStateLoopFail,CStateLoopFail,
          CStateInitialize,CStateInitialize,CStateInitialize,0,0,
            CStateInitialize,0,CStateExternalLogoutRecovery,0,0,
              0,CStateInitialize,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 18  12  CEventLoopEventDetected                        */
    0,CStateResetNeeded,CStateResetNeeded,0,CStateLoopFail,
      CStateResetNeeded,0,0,0,0,
        0,0,CStateResetNeeded,CStateLoopFail,0,
          0,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,CStateResetNeeded,
            CStateResetNeeded,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,CStateResetNeeded,CStateResetNeeded,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 19  13  CEventLoopConditionCleared                     */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateInitDataStructs,CStateInitDataStructs,
          0,0,CStateResetNeeded,0,CStateElasticStoreEventStorm,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 20  14  CEventLoopNeedsReinit                          */
    0,0,0,CStateLoopFailedReInit,CStateResetNeeded,
      CStateLoopFailedReInit,0,CStateLoopFailedReInit,0,0,
        CStateLoopFailedReInit,CStateResetNeeded,CStateLoopFailedReInit,CStateLoopFailedReInit,CStateReInitFM,
          CStateLoopFailedReInit,CStateLoopFailedReInit,CStateResetNeeded,CStateLoopFailedReInit,CStateElasticStoreEventStorm,
            CStateLIPEventStorm,CStateLoopFailedReInit,0,0,0,
              CStateLoopFailedReInit,CStateLoopFailedReInit,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 21  15   CEventReInitFMSuccess                         */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,CStateInitDataStructs,0, CStateInitDataStructs,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 22  16   CEventReInitFMFailure                         */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateInitialize,0,
          CStateInitialize,0,CStateLoopFailedReInit,0,CStateInitialize,
            CStateInitialize,0,CStateLoopFailedReInit,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 23  17   CEventNextDevice                              */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,CStateSuccess,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 24  18    CEventDeviceListEmpty                        */
    0,0,0,0,0,
      0,0,0,CStateResetNeeded,0,
        CStateNormal,0,CStateResetNeeded,CStateResetNeeded,0,
          0,0,CStateNormal,CStateNormal,CStateNormal,
            CStateNormal,0,0,CStateNormal,CStateNormal,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,CStateNormal,CStateNormal,0,0,
                    0,CStateNormal,CStateNormal,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 25   19     CEventElasticStoreEventStorm               */
    CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,
      CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,
        CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,
          CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,
            CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,
              CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,
                0,CStateElasticStoreEventStorm,0,0,0,
                  0,CStateElasticStoreEventStorm,CStateElasticStoreEventStorm,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 26   1A     CEventLIPEventStorm                        */
    CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,
      CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,
        CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,
          CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,
            CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,CStateLIPEventStorm,
              0,CStateLIPEventStorm,0,0,0,
                0,0,0,0,0,
                  0,CStateLIPEventStorm,CStateLIPEventStorm,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 27   1B  CEvent_AL_PA_BAD                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 28   1B     CEventExternalDeviceReset                 */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,CStateExternalDeviceReset,0,0,
          0,0,CStateLoopFailedReInit,CStateResetNeeded,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 29 CEventExternalLogout                                */
    0,0,0,0,0,
      CStateVerify_AL_PA,0,0,0,0,
        0,0,CStateExternalLogout,0,0,
          0,0,0,CStateResetNeeded,0,
            0,0,0,0,0,
              0,0,0,0,CStateResetNeeded,
                0,0,0,0,0,
                  0,CStateResetNeeded,CStateResetNeeded,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 30  CEventDoExternalDeviceReset                                                   */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,CStateDoExternalDeviceReset,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 31  CEventSendPrimitive                                                   */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateLoopFail,0,
          0,CStateSendPrimitive,CStateSendPrimitive,0,CStateSendPrimitive,
            CStateSendPrimitive,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 32 CEventDelay_for_FM_init         32           */
    0,0,0,CStateInitFM_DelayDone,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,0,
          CStateInitFM_DelayDone,CStateInitializeFailed,CStateInitFM_DelayDone,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 33   CEventAllocRFT_IDThread                                                  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,CStateAllocRFT_IDThread,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 34 CEventDoRFT_ID                                                   */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,CStateDoRFT_ID,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 35 CEventRFT_IDSuccess                                                   */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,CStateRFT_IDSuccess,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 36 CEventRFT_IDFail                                                   */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,CStateFreeSFthread,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 37   CEventAllocDiPlogiThread                                                  */
    0,0,0,0,0,
      0,0,0,CStateAllocDiPlogiThread,0,
        0,0,CStateAllocDiPlogiThread,CStateResetNeeded,CStateResetNeeded,
          0,0,CStateInitialize,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,CStateAllocDiPlogiThread,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 38 CEventDoDiPlogi                                                    */
    0,0,0,0,0,
      0,0,0,CStateDoDiPlogi,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,CStateInitialize,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                CStateDoDiPlogi,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 39 CEventDiPlogiSuccess                                                   */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,CStateInitialize,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,CStateDiPlogiSuccess,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 40 CEventDoDiFailed                                                   */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,CStateResetNeeded,CStateInitialize,0,CStateElasticStoreEventStorm,
            0,0,0,0,0,
              0,0,0,0,0,
                0,CStateFreeSFthread,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 41 CEventAllocGID_FTThread */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,CStateAllocGID_FTThread,
                0,0,0,0,0, /* State 32 CStateDiPlogiSuccess*/
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
     /* Event 42 CEventDoGID_FT    */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,CStateDoGID_FT,0,  /* State 33 CStateAllocGID_FTThread */
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 43 CEventGID_FTSuccess     */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,CStateGID_FTSuccess,    /* State 34 CStateDoGID_FT */
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 44 CEventGID_FTFail        */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,CStateFreeSFthread,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 45 CEventFindDeviceUseNameServer                                                  */
    0,0,0,0,0,
      0,0,0,0,0,
        0,CStateFindDeviceUseNameServer,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 46 CEventFindDeviceUseLoopMap                                                     */
    0,0,0,0,0,
      0,0,0,0,0,
        0,CStateFindDeviceUseLoopMap,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,CStateFindDeviceUseLoopMap,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 47 CEventAllocSCRThread */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  CStateAllocSCRThread,0,0,0,0,/* State 35 CStateGID_FTSuccess*/
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
 /* Event 48 CEventDoSCR    */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,CStateDoSCR,0,/* State 38 CStateDoSCRThread */
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 49 CEventSCRSuccess     */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,CStateSCRSuccess,/* State 39 CStateDoSCR */
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 50 CEventSCRFail        */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,CStateFreeSFthread,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 51 CEventRSCNErrorBackIOs */
    0,0,0,0,0,
      0,0,0,CStateRSCNErrorBackIOs,0,
        0,0,CStateRSCNErrorBackIOs,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
            0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 52 CEventFindPtToPtDevice                                                  */
    0,0,0,0,0,
      0,0,0,0,0,
        CStateFindPtToPtDevice,0,0,CStateResetNeeded,CStateResetNeeded,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 53   CEventClearHardwareFoulup                     */
    0,0,0,0,0,
      0,0,0,0,0,
        0,0,0,CStateInitializeFailed,0,
          0,0,0,0,CStateVerify_AL_PA,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 54 CEventFlipNPortState                             */
    0,0,0,0,0, 
      0,0,0,0,0, 
        0,0,CStateFlipNPortState,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 55   CEventGoToInitializeFailed                     */
    0,0,0,0,0, 
      0,0,CStateInitializeFailed,0,0, 
        0,0,CStateResetNeeded,CStateInitializeFailed,CStateInitializeFailed,
          CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,
            CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,
              CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,
                CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,
                  CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,
                    CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,
                      CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,CStateInitializeFailed,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 56                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 57                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 58                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 59                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 60                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 61                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 62                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 63                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 64                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 65                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 66                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 67                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 68                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 69                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 70                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 71                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 72                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 73                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 74                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 75                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 76                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 77                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 78                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 79                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 80                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 81                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 82                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 83                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 84                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 85                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 86                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 87                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 88                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 89                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 90                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 91                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 92                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 93                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 94                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 95                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 96                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 97                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 98                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 99                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 100                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 101                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 102                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 103                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 104                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 105                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 106                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 107                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 108                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 109                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 110                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 111                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 112                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 113                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 114                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 115                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 116                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 117                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 118                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 119                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 120                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 121                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 122                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 123                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 124                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 125                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 126                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 127                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    };

/*
stateTransitionMatrix_t copiedCStateTransitionMatrix;
*/
stateActionScalar_t CStateActionScalar = {
    &CActionConfused,                /*   CStateConfused              0      */
    &CActionShutdown,                /*   CStateShutdown              1      */
    &CActionInitialize,              /*   CStateInitialize            2      */
    &CActionInitFM,                  /*   CStateInitFM                3      */
    &CActionInitDataStructs,         /*   CStateInitDataStructs       4      */
    &CActionVerify_AL_PA,            /*   CStateVerify_AL_PA          5      */
    &CActionAllocFlogiThread,        /*   CStateAllocFlogiThread      6      */
    &CActionDoFlogi,                 /*   CStateDoFlogi               7      */
    &CActionFlogiSuccess,            /*   CStateFlogiSuccess          8      */
    &CActionALPADifferent,           /*   CStateALPADifferent         9      */
    &CActionFreeSFthread,            /*   CStateFreeSFthread          10     */
    &CActionSuccess,                 /*   CStateSuccess               11     */
    &CActionNormal,                  /*   CStateNormal                12     */
    &CActionResetNeeded,             /*   CStateResetNeeded           13     */
    &CActionLoopFail,                /*   CStateLoopFail              14     */
    &CActionReInitFM,                /*   CStateReInitFM              15     */
    &CActionInitializeFailed,        /*   CStateInitializeFailed      16     */
    &CActionLoopFailedReInit,
    &CActionFindDeviceUseAllALPAs,
    &CActionElasticStoreEventStorm,
    &CActionLIPEventStorm,
    &CActionExternalDeviceReset,
    &CActionExternalLogout,
    &CActionExternalLogoutRecovery,
    &CActionDoExternalDeviceReset,
    &CActionSendPrimitive,
    &CActionInitFM_DelayDone,
    &CActionAllocRFT_IDThread,    /* CStateAllocRFT_ID   27      */
    &CActionDoRFT_ID,             /* CStateDoRFT_ID      28      */
    &CActionRFT_IDSuccess,        /* CStateRFT_IDSuccess 29      */
    &CActionAllocDiPlogiThread,
    &CActionDoDiPlogi,
    &CActionDiPlogiSuccess,
    &CActionAllocGID_FTThread,    /* CStateAllocGID_FT   33      */
    &CActionDoGID_FT,             /* CStateDoGID_FT      34      */
    &CActionGID_FTSuccess,        /* CStateGID_FTSuccess 35      */
    &CActionFindDeviceUseNameServer,
    &CActionFindDeviceUseLoopMap,
    &CActionAllocSCRThread,     /* CStateAllocSCRThread 38      */
    &CActionDoSCR,              /* CStateDoSCR          39      */
    &CActionSCRSuccess,         /* CStateSCRSuccess     40      */
    &CActionRSCNErrorBackIOs,   /* CStateRSCNErrorBackIOs 41    */
    &CActionFindPtToPtDevice,
    &CActionFlipNPortState,
    &CActionConfused,
    &CActionConfused,
    &CActionConfused,
    &CActionConfused,
    };

/*
stateActionScalar_t copiedCStateActionScalar;
*/
#define testCompareBase 0x00000110

#ifndef __State_Force_Static_State_Tables__
extern actionUpdate_t noActionUpdate;
#endif /* __State_Force_Static_State_Tables__ was not defined */

extern os_bit8 Alpa_Index[256];

#ifndef __State_Force_Static_State_Tables__
actionUpdate_t testCActionUpdate[] = {
                              0,          0,      agNULL,                 agNULL
                     };
#endif /* __State_Force_Static_State_Tables__ was not defined */

#ifndef USESTATEMACROS
/*+
  Function: CActionConfused
   Purpose: Terminating State for error detection 
 Called By: Any State/Event pair that does not have an assigned action.
            This function is called only in programming error condtions.
     Calls: CFuncYellowLed to indicate link down
-*/
/*CStateConfused      0 */
extern void CActionConfused( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogString(thread->hpRoot,
                    "CActionConfused",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p)In %s - State = %d",
                    "CActionConfused",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: CActionShutdown
   Purpose: Terminating State shutdown condtion.
 Called By: Any State/Event pair that does not have an assigned action.
            This function is called only in programming error condtions.
     Calls: CFuncYellowLed to indicate link down
-*/
/* CStateShutdown              1*/
extern void CActionShutdown( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t  *hpRoot  = thread->hpRoot;

    CFuncYellowLed(hpRoot, agFALSE);

    faSingleThreadedLeave( hpRoot, CStateShutdown  );

    osFCLayerAsyncEvent( hpRoot, osFCLinkDown );

    faSingleThreadedEnter( hpRoot , CStateShutdown  );

    CFuncCompleteAllActiveCDBThreads( hpRoot,osIOFailed,CDBEventIODeviceReset );

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) In %s - State = %d",
                    "CActionShutdown",(char *)agNULL,
                    hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiLogString(hpRoot,
                    "%s FM Stat %08X LPS %x",
                    "CActionShutdown",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    CThread_ptr(hpRoot)->LoopPreviousSuccess,
                    0,0,0,0,0,0);
    /* CThread->sysIntsActive = agFALSE; */

    osChipIOUpWriteBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration,
            (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) | 
                                 ChipIOUp_Frame_Manager_Configuration_ELB     ));

    osStallThread(hpRoot, 200);

    osChipIOUpWriteBit32(hpRoot, ChipIOUp_Frame_Manager_Control,
                  ChipIOUp_Frame_Manager_Control_CMD_Offline );


    osChipIOUpWriteBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration,
            (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 
                                 ~ChipIOUp_Frame_Manager_Configuration_ELB     )); 
    

    CFuncDisable_Interrupts(hpRoot,ChipIOUp_INTEN_MASK);

    fiSetEventRecordNull(eventRecord);
}
/*+
  Function: CActionInitialize
   Purpose: Begining of Channel Initialation brings data structures to a known state.
            Resets Chip.
 Called By: CEventDoInitalize
     Calls: CFuncYellowLed to indicate link down
            fiTimerSvcInit
            PktThreadsInitializeFreeList
            TgtThreadsInitializeFreeList
            DevThreadsInitializeFreeList
            CDBThreadsInitializeFreeList
            SFThreadsInitializeFreeList
            ESGLInitializeFreeList
            CFuncInit_DevLists
            CFuncInit_Threads
            osFCLayerAsyncEvent
            CFuncSoftResetAdapterNoStall
            CFuncInitFM_Registers
            fiTimerStart
            CEventInitChipSuccess
            osStallThread
            fiTimerTick

-*/
/*CStateInitialize            2*/
extern void CActionInitialize( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t   *    hpRoot          = thread->hpRoot;
    CThread_t  *    pCThread        = CThread_ptr(hpRoot);

#ifdef OSLayer_NT
     os_bit32           Hard_Stall      = 0;
#endif /* OSLayer_NT */

    pCThread->Flogi_AllocDone = agFALSE;
/*
    pCThread->InitAsNport = pCThread->Calculation.Parameters.InitAsNport;
    pCThread->RelyOnLossSyncStatus = pCThread->Calculation.Parameters.RelyOnLossSyncStatus;
*/
    pCThread->FlogiRcvdFromTarget = agFALSE;
    pCThread->FoundActiveDevicesBefore = agFALSE;
    pCThread->ALPA_Changed_OnLinkEvent = agFALSE;
    pCThread->FlogiTimedOut = agFALSE;
    pCThread->ReScanForDevices = agFALSE;
    pCThread->DirectoryServicesFailed = agFALSE;
    pCThread->NumberOfPlogiTimeouts = 0;
    pCThread->NumberOfFLOGITimeouts = 0;
    pCThread->RSCNreceived = agFALSE;

    fiLogString( hpRoot,
                    "%p %s St %d InIMQ %x InitAsNport %x MY_ID %X",
                    "CAI",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->ProcessingIMQ,
                    pCThread->InitAsNport,
                    (os_bit32)fiComputeCThread_S_ID(pCThread),
                    0,0,0,0);

    if(pCThread->ProcessingIMQ)
    {
        pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;
        fiSetEventRecord(eventRecord,thread, CEventLoopEventDetected );
        return;
    }

    CFuncYellowLed(hpRoot, agFALSE);
    if( pCThread->LoopPreviousSuccess)
    {
        CFuncCompleteAllActiveCDBThreads( hpRoot,osIOAborted,CDBEventIODeviceReset );
    }
    /*+
    +  CFuncReadGBICSerEprom( hpRoot);
    +*/
    if( pCThread->DeviceSelf != agNULL)
    {
        DevThreadFree(hpRoot,pCThread->DeviceSelf);
        pCThread->DeviceSelf = (DevThread_t *)agNULL;
        CFuncQuietShowWhereDevThreadsAre( hpRoot);

        fiLogString(hpRoot,
                    "I DevThreadFree Was %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeCThread_S_ID(pCThread),
                    0,0,0,0,0,0,0);

    }

    pCThread->FindDEV_pollingCount = 0;
    pCThread->ADISC_pollingCount   = 0;
    pCThread->DEVReset_pollingCount= 0;

    pCThread->DeviceDiscoveryMethod = DDiscoveryMethodInvalid;

    fiTimerSvcInit(hpRoot);

#ifdef _DvrArch_1_30_
    PktThreadsInitializeFreeList( hpRoot );
#endif /* _DvrArch_1_30_ was defined */

    TgtThreadsInitializeFreeList( hpRoot );

    DevThreadsInitializeFreeList( hpRoot );

    CDBThreadsInitializeFreeList( hpRoot );

    SFThreadsInitializeFreeList( hpRoot );

    ESGLInitializeFreeList( hpRoot );

    CFuncInit_DevLists( hpRoot );

    CFuncInit_Threads( hpRoot );

    faSingleThreadedLeave( hpRoot ,CStateInitialize );

    osFCLayerAsyncEvent( hpRoot, osFCLinkDown );

    faSingleThreadedEnter( hpRoot ,CStateInitialize );

    CFuncSoftResetAdapterNoStall(hpRoot);

    if( pCThread->TwoGigSuccessfull )
    {
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration_3,  ( ChipIOUp_Frame_Manager_Configuration_3_2Gig_TXS |  ChipIOUp_Frame_Manager_Configuration_3_2Gig_RXS ) );
    }

    CFuncInitFM_Registers( hpRoot , agFALSE);

    if( pCThread->NoStallTimerTickActive )
    {
        if(! fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                       &(pCThread->TimerQ)))
        {
            fiLogDebugString( hpRoot,
                                CStateLogConsoleERROR,
                                "hpRoot %p Soft Stall In %s - State = %d InIMQ %x",
                                "CActionInitialize",(char *)agNULL,
                                thread->hpRoot,(void *)agNULL,
                                (os_bit32)thread->currentState,
                                pCThread->ProcessingIMQ,
                                0,0,0,0,0,0);

            fiSetEventRecordNull(eventRecord);

            fiTimerSetDeadlineFromNow(thread->hpRoot, &pCThread->Timer_Request, CResetChipDelay);

            pCThread->Timer_Request.eventRecord_to_send.thread= thread;
            pCThread->Timer_Request.eventRecord_to_send.event = CEventInitChipSuccess;

            fiTimerStart(thread->hpRoot,&pCThread->Timer_Request);
            return;
        }
    }
    else
    {
        CFuncDisable_Interrupts(thread->hpRoot,ChipIOUp_INTEN_MASK); /*DRL*/

/*
        Hard_Stall = ( CResetChipDelay / Interrupt_Polling_osStallThread_Parameter ) * Interrupt_Polling_osStallThread_Parameter;
        fiLogDebugString( hpRoot,
                                CStateLogConsoleERROR,
                                "hpRoot %p Hard Stall %d In %s - State = %d InIMQ %x",
                                "CActionInitialize",(char *)agNULL,
                                thread->hpRoot,(void *)agNULL,
                                Hard_Stall,
                                (os_bit32)thread->currentState,
                                pCThread->ProcessingIMQ,
                                0,0,0,0,0);
*/
#ifndef OSLayer_NT

            osStallThread( hpRoot, CResetChipDelay );

            fiTimerTick(hpRoot,CResetChipDelay );

#else /* ~OSLayer_NT */
        Hard_Stall = ( CResetChipDelay / Interrupt_Polling_osStallThread_Parameter ) * Interrupt_Polling_osStallThread_Parameter;
        while( Hard_Stall > Interrupt_Polling_osStallThread_Parameter )
        {
            osStallThread( hpRoot,Interrupt_Polling_osStallThread_Parameter);

            fiTimerTick( hpRoot,Interrupt_Polling_osStallThread_Parameter );
            Hard_Stall-=Interrupt_Polling_osStallThread_Parameter;
        }
#endif /* ~OSLayer_NT */

        fiSetEventRecord(eventRecord,thread, CEventInitChipSuccess );
    }

    fiLogString(hpRoot,
                    "Out %p %s FM Stat %08X LPS %x MY_ID %x",
                    "CAI",(char *)agNULL,
                    pCThread->DeviceSelf,(void *)agNULL,
                    (os_bit32)osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    pCThread->LoopPreviousSuccess,
                    (os_bit32)fiComputeCThread_S_ID(pCThread),
                    0,0,0,0,0);


}

/*+
  Function: CActionInitFM
   Purpose: Initializes chip and Frame manager pCThread->LaserEnable flag set
            to turn on transitter. InitAsNport evalulated to determine chip 
            configuration.Phyical expected to be up on exit for this function.
            Unless NoStallTimerTickActive is set.
            For XL2 link speed set.
            
 Called By: CEventInitChipSuccess
     Calls: CFuncYellowLed to indicate link down
            CFuncInitChip
            osFCLayerAsyncEvent
            CFuncInitFM_Registers
            fiTimerStart
            osStallThread
            fiTimerTick
            CFuncDoLinkSpeedNegotiation
            CEventInitalizeFailure
            CEventDelay_for_FM_init
-*/

/*CStateInitFM                3*/
extern void CActionInitFM( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t   * hpRoot    = thread->hpRoot;
    CThread_t  * pCThread  = CThread_ptr(hpRoot);
    os_bit32    Hard_Stall = 0;
    os_bit32    FM_Status  = 0;

    agBOOLEAN Success = agFALSE;

    CFuncYellowLed(hpRoot, agFALSE);

    faSingleThreadedLeave( hpRoot , CStateInitFM);

    osFCLayerAsyncEvent( hpRoot, osFCLinkDown );

    faSingleThreadedEnter( hpRoot , CStateInitFM);

    fiLogDebugString( hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Begin %s - State = %d InIMQ %x",
                    "CAIFM",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->ProcessingIMQ,
                    0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "A %s HA %x CA %x",
                    "CAIFM",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)(pCThread->ChanInfo.HardAddress.AL_PA),
                    (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                    0,0,0,0,0,0);


#ifdef NPORT_STUFF
    /* Make sure, we turn off the ConnectedToNportOrFPort flag to agFALSE since
     * We are initing FM.
     */

    pCThread->ConnectedToNportOrFPort = agFALSE;
#endif   /* NPORT_STUFF */
    pCThread->FlogiSucceeded          = agFALSE;
    pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;

    if(!CFuncInitChip( hpRoot ))
    {
        fiSetEventRecord(eventRecord,thread, CEventInitalizeFailure );
        return;
    }

    pCThread->Flogi_AllocDone = agFALSE;

    pCThread->FM_pollingCount = 0;

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d FM %08X",
                    "CAIFM",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);

    if(fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                   &(pCThread->TimerQ)))
    {
        fiTimerStop(&pCThread->Timer_Request);
    }


    if( ! pCThread->LaserEnable )
    {
        pCThread->LaserEnable = agTRUE;
    
        fiLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            "%s %s Now",
                            "CAIFM","LaserEnable",
                            (void *)agNULL,(void *)agNULL,
                            0,0,0,0,0,0,0,0);
    }

    fiLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "B %s HA %x CA %x",
                    "CAIFM",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)(pCThread->ChanInfo.HardAddress.AL_PA),
                    (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                    0,0,0,0,0,0);

    CFuncYellowLed( hpRoot, agFALSE);

    faSingleThreadedLeave( hpRoot , CStateInitFM );

    osFCLayerAsyncEvent( hpRoot, osFCLinkDown );

    faSingleThreadedEnter( hpRoot, CStateInitFM );

    osStallThread( hpRoot, 10 );
/*
    pCThread->TwoGigSuccessfull = CFuncDoLinkSpeedNegotiation( hpRoot);
*/
    pCThread->LoopPreviousSuccess = agFALSE;

    CFuncInitFM_Registers( hpRoot , agTRUE);

/**/
    if (pCThread->InitAsNport)
    {
        Hard_Stall = Init_FM_NPORT_Delay_Count;
        while( Hard_Stall > 1  )
        {
            FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
        
            if( (FM_Status & ChipIOUp_Frame_Manager_Status_PSM_MASK) ==
                                     ChipIOUp_Frame_Manager_Status_PSM_ACTIVE )
            {
                Success = agTRUE;
                break;        
            }

            if( (FM_Status & \
                ( ChipIOUp_Frame_Manager_Status_NP | ChipIOUp_Frame_Manager_Status_OS | ChipIOUp_Frame_Manager_Status_LS )\
                 ) == \
                ( ChipIOUp_Frame_Manager_Status_NP | ChipIOUp_Frame_Manager_Status_OS | ChipIOUp_Frame_Manager_Status_LS )  )
            {

                if( (FM_Status & ChipIOUp_Frame_Manager_Status_PSM_MASK) == ChipIOUp_Frame_Manager_Status_PSM_LF2  )
                {

                    break;        
                }
            }


            pCThread->FuncPtrs.Proccess_IMQ(hpRoot); /* */
            osStallThread( hpRoot, 1 );
            fiTimerTick( hpRoot, 1 );
            Hard_Stall--;

            if(! (Hard_Stall % 1000))
            {
                if( (FM_Status & ChipIOUp_Frame_Manager_Status_PSM_MASK) == ChipIOUp_Frame_Manager_Status_PSM_Offline  )
                {
                    break;        
                }
                if(! (Hard_Stall % 4000))
                {
 
                    if( (FM_Status & ChipIOUp_Frame_Manager_Status_PSM_MASK) ==  ChipIOUp_Frame_Manager_Status_PSM_LF1 )
                    {
                        break;        
                    }
                    if( (FM_Status & ChipIOUp_Frame_Manager_Status_PSM_MASK) ==  ChipIOUp_Frame_Manager_Status_PSM_LF2 )
                    {
                        break;        
                    }
/*
                    if( (FM_Status & ChipIOUp_Frame_Manager_Status_PSM_MASK) ==  ChipIOUp_Frame_Manager_Status_PSM_OL1 )
                    {
                        break;        
                    }
*/
                }
            }
        }

        osChipIOUpWriteBit32(hpRoot, ChipIOUp_Frame_Manager_Status, 0xffffffff );

        fiLogDebugString(hpRoot,
                        CFuncLogConsoleERROR,
                        "%s %s FM Status %08X HS %d FM Cfg %08X FM Cfg3 %08X",
                        "CAIFM","InitAsNport",
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        Hard_Stall,
                        osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                        osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration_3 ),
                        0,0,0,0);

        if( Success == agTRUE)
        {

            fiSetEventRecord(eventRecord,thread, CEventDelay_for_FM_init );
        }
        else
        {
            fiLogString( hpRoot,
                            "%s InitAsNport %x MY_ID %x FM %08X HS %d",
                            "CAIFM",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->InitAsNport,
                            (os_bit32)fiComputeCThread_S_ID(pCThread),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            Hard_Stall,0,0,0,0);

            fiSetEventRecord(eventRecord,thread, CEventInitalizeFailure );
        }
        return;
    }/* End InitAsNport */
 
    if( pCThread->NoStallTimerTickActive )
    {
        if(! fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                       &(pCThread->TimerQ)))
        {
            fiLogDebugString( hpRoot,
                                CStateLogConsoleERROR,
                                "hpRoot %p Soft Stall In %s - State = %d InIMQ %x",
                                "CAIFM",(char *)agNULL,
                                thread->hpRoot,(void *)agNULL,
                                (os_bit32)thread->currentState,
                                pCThread->ProcessingIMQ,
                                0,0,0,0,0,0);

            fiSetEventRecordNull(eventRecord);

            fiTimerSetDeadlineFromNow(hpRoot, &pCThread->Timer_Request, CInitFM_Delay );

            pCThread->Timer_Request.eventRecord_to_send.thread= thread;
            pCThread->Timer_Request.eventRecord_to_send.event = CEventDelay_for_FM_init;

            fiTimerStart(hpRoot,&pCThread->Timer_Request);

            CFuncEnable_Interrupts(
                                    thread->hpRoot,
                                    (  ChipIOUp_INTEN_MPE
                                     | ChipIOUp_INTEN_CRS
                                     | ChipIOUp_INTEN_INT
                                     | ChipIOUp_INTEN_DER
                                     | ChipIOUp_INTEN_PER)
                                  );
           return;
        }
    }
    else
    {
        CFuncDisable_Interrupts(hpRoot,ChipIOUp_INTEN_MASK);/*DRL*/
        Hard_Stall = Init_FM_Delay_Count;
        while( Hard_Stall > 1  )
        {
			FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
			if(FM_Status & ChipIOUp_Frame_Manager_Status_LS)
			{
				break;
			}
            pCThread->FuncPtrs.Proccess_IMQ(hpRoot);
            if ( pCThread->DeviceSelf != agNULL)
            {
                fiLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                "PASS %s HA %x CA %x Hard_Stall %d",
                                "CAIFM",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                (os_bit32)(pCThread->ChanInfo.HardAddress.AL_PA),
                                (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                                Hard_Stall,
                                0,0,0,0,0);
                Success = agTRUE;

                break;
            }
            osStallThread( hpRoot, 1 );
            fiTimerTick( hpRoot, 1 );
            Hard_Stall--;
        }

        if ( pCThread->DeviceSelf == agNULL)
        {
        
                fiLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                "FAIL %s HA %x CA %x Hard_Stall %d",
                                "CAIFM",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                (os_bit32)(pCThread->ChanInfo.HardAddress.AL_PA),
                                (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                                Hard_Stall,
                                0,0,0,0,0);
            fiSetEventRecord(eventRecord,thread, CEventInitalizeFailure );

        }
        else
        {
            fiSetEventRecord(eventRecord,thread, CEventDelay_for_FM_init );
        }
    }

    fiLogString(hpRoot,
                "SELF %p %s My_ID %08X Success %x %d",
                "CAIFM",(char *)agNULL,
                pCThread->DeviceSelf,(void *)agNULL,
                (os_bit32)Success,
                fiComputeCThread_S_ID(pCThread),
                Hard_Stall,
                0,0,0,0,0);

    CFuncShowWhereDevThreadsAre( hpRoot );

}

/*+
  Function: CActionInitDataStructs
   Purpose: Sets chip ChipIOUp_My_ID register
            
 Called By: CEventDelay_for_FM_init
     Calls: CFuncYellowLed to indicate link down
            osChipIOUpWriteBit32
            CFuncAll_clear
-*/
/*CStateInitDataStructs       4*/
extern void CActionInitDataStructs( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t   *    hpRoot          = thread->hpRoot;
    CThread_t  *    pCThread        = CThread_ptr(hpRoot);
    os_bit32        My_ID           = 0;

    CFuncYellowLed(thread->hpRoot, agFALSE);

    pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;
    My_ID = fiComputeCThread_S_ID(pCThread); 

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "SELF %p In %s My_ID %08X LD %x IR %x CCnt %x InIMQ %x",
                    "CAIDS",(char *)agNULL,
                    pCThread->DeviceSelf,(void *)agNULL,
                    My_ID,
                    pCThread->LOOP_DOWN,
                    pCThread->IDLE_RECEIVED,
                    pCThread->FindDEV_pollingCount,
                    pCThread->ProcessingIMQ,
                    0,0,0);

    /* Write aquired AL_PA */
    osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, My_ID  );


    fiLogString(hpRoot,
                    "SELF %p %s FM %08X LPS %x AC %x My_ID %X",
                    "CAIDS",(char *)agNULL,
                    pCThread->DeviceSelf,(void *)agNULL,
                    (os_bit32)osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    pCThread->LoopPreviousSuccess,
                    CFuncAll_clear(hpRoot ),
                    (os_bit32)My_ID,
                    0,0,0,0);


#ifdef NPORT_STUFF
    if (pCThread->InitAsNport)
    {
       pCThread->ConnectedToNportOrFPort = agTRUE;
       fiSetEventRecord(eventRecord,thread, CEventDataInitalizeSuccess );
       return;
    }
#endif

    if( CFuncAll_clear(hpRoot ) )
    {
        fiSetEventRecord(eventRecord,thread, CEventDataInitalizeSuccess );
    }
    else
    {
        pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;
        fiSetEventRecord(eventRecord,thread, CEventLoopEventDetected );
    }
}

/*+
  Function: CActionVerify_AL_PA
   Purpose: Verifies chip can "talk" to it self if loop. Open and PLOGI sent, Received payload examined
            WWN is used to make sure we do not have ALPA conflict.
            Bails out if pCThread->DeviceSelf agNULL
            Bails out if NPORT
            Bails out if verify fails
            
 Called By: CEventDelay_for_FM_init
     Calls: CFuncYellowLed to indicate link down
            CFuncInterruptPoll
            DevEventLogin
            CEventAllocFlogiThread
            osChipIOUpWriteBit32
            CFuncAll_clear
            CEventAllocFlogiThread
-*/
/*CStateVerify_AL_PA             5 */
extern void CActionVerify_AL_PA( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t   *    hpRoot         = thread->hpRoot;
    CThread_t     * pCThread       = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread     = pCThread->DeviceSelf;


    CFuncYellowLed(thread->hpRoot, agFALSE);

    faSingleThreadedLeave( hpRoot, CStateVerify_AL_PA );

    osFCLayerAsyncEvent( hpRoot, osFCLinkDown );

    faSingleThreadedEnter( hpRoot , CStateVerify_AL_PA);

/*
    pCThread->FuncPtrs.Proccess_IMQ(hpRoot);
*/
    if( pDevThread == (DevThread_t *)agNULL )
    {

        pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;

        fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "DevSelf agNULL hpRoot %p  %s - State = %d Dev State %d Loop_Reset_Event_to_Send %d",
                    "CAVA",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->Loop_Reset_Event_to_Send,
                    0,0,0,0,0,0);

        fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
        return;
    }

#ifdef NPORT_STUFF
    if (pCThread->ConnectedToNportOrFPort)
    {
#endif   /* NPORT_STUFF */
#ifdef NAME_SERVICES
        fiSetEventRecord(eventRecord,thread,CEventAllocFlogiThread);
        fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "About to Alloc FLOGI In %s My_ID %08X",
                    "CAVA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeCThread_S_ID(pCThread),
                    0,0,0,0,0,0,0);

        return;
#endif   /* NAME_SERVICES */
#ifdef NPORT_STUFF
    }
#endif   /* NPORT_STUFF */

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p  %s - State = %d Dev State %d Self %p FDCnt %x",
                    "CAVA",(char *)agNULL,
                    thread->hpRoot,pDevThread,
                    (os_bit32)thread->currentState,
                    pDevThread->thread_hdr.currentState,
                    pCThread->FindDEV_pollingCount,
                    0,0,0,0,0);

    pDevThread->Plogi_Reason_Code = PLOGI_REASON_VERIFY_ALPA;

    fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

    if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "In %s - State = %d   ALPA %X FDCCnt %x",
                    "CAVA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCThread->FindDEV_pollingCount,0,0,0,0,0);

    }


    if(pDevThread->thread_hdr.currentState == DevStateDoPlogi )
    {
        fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "DEV STATE WRONG",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
    }


    if(pDevThread->thread_hdr.currentState == DevStateAL_PA_Self_OK  ||
       pDevThread->thread_hdr.currentState == DevStateHandleAvailable  )
    {
        pCThread->PreviouslyAquiredALPA = agTRUE;

        fiSetEventRecord(eventRecord,thread,CEventAllocFlogiThread);
    }
    else
    {

        fiLogString(hpRoot,
                    "%s FM %08X CFG %08X Dev S %d AC %x",
                    "CAVA",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    (os_bit32)osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    pDevThread->thread_hdr.currentState,
                    CFuncAll_clear(hpRoot ),
                    0,0,0,0);

        fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "DEV STATE WRONG %d Reinit !!!",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pDevThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);
        pCThread->PreviouslyAquiredALPA = agFALSE;

        DevThreadFree(hpRoot,pCThread->DeviceSelf);
        pCThread->DeviceSelf = (DevThread_t *)agNULL;
        fiLogString(hpRoot,
                    "V DevThreadFree %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeCThread_S_ID(pCThread),
                    0,0,0,0,0,0,0);

        pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;
        fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
    }
    CFuncQuietShowWhereDevThreadsAre( hpRoot);

/*
    CFuncShowWhereDevThreadsAre( hpRoot, agTRUE );
*/
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After %s - State = %d Dev State %d Self %p",
                    "CAVA",(char *)agNULL,
                    thread->hpRoot,
                    pDevThread,
                    (os_bit32)thread->currentState,
                    pDevThread->thread_hdr.currentState,
                    0,0,0,0,0,0);

    fiLogString(hpRoot,
                    "SELF %p %s FM %08X LPS %x AC %x E %d",
                    "CAVA",(char *)agNULL,
                    pCThread->DeviceSelf,(void *)agNULL,
                    (os_bit32)osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    pCThread->LoopPreviousSuccess,
                    CFuncAll_clear(hpRoot ),
                    eventRecord->event,
                    0,0,0,0);


}


/*+
  Function: CActionAllocFlogiThread
   Purpose: Allocates recource for Fabric Login. Release old SFThread if still in use
            Proceddes to next state when sfthread is allocated.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            SFThreadFree
            CEventSameALPA
            CEventGotFlogiThread
            CFuncDisable_Interrupts
            SFThreadAlloc

-*/
/* CStateAllocFlogiThread      6*/
extern void CActionAllocFlogiThread( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t *hpRoot= thread->hpRoot;

    CThread_t  * pCThread = CThread_ptr( hpRoot);

    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;

    /* If an FLOGI was already in progress and we reinit the loop,
     * we need to free the old SFThread and get a new one. */
    CFuncYellowLed(thread->hpRoot, agFALSE);

    pCThread->FLOGI_pollingCount  = 0;
    pCThread->Fabric_pollingCount = 0;

    if(pSFThread != (SFThread_t *) agNULL)
    {
        if( pCThread->SFThread_Request.State == SFThread_Request_Granted)
        {
            fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "pCThread %p Freeing SFThread in %s ",
                "CActionAllocFlogiThread",(char *)agNULL,
                pCThread,(void *)agNULL,
                0,0,0,0,0,0,0,0);

            SFThreadFree( hpRoot, &pCThread->SFThread_Request );
            pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
        }
    }


#ifdef Tachlite_works
    if(!(pCThread->FabricLoginRequired))
        fiSetEventRecord(eventRecord,thread,CEventSameALPA);

    else
    {
#endif   /* Tachlite_works */

        pCThread->SFThread_Request.eventRecord_to_send.event = CEventGotFlogiThread;
        pCThread->SFThread_Request.eventRecord_to_send.thread = thread;



        fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot %p After In %s - State = %d My_ID %08X",
                        "CActionAllocFlogiThread",(char *)agNULL,
                        thread->hpRoot,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        fiComputeCThread_S_ID(pCThread),
                        0,0,0,0,0,0);

        fiSetEventRecordNull(eventRecord);

        CFuncDisable_Interrupts(thread->hpRoot,ChipIOUp_INTEN_MASK);

        SFThreadAlloc( hpRoot,&pCThread->SFThread_Request );

#ifdef Tachlite_works
    }
#endif   /* Tachlite_works */

}

/*+
  Function: CActionDoFlogi
   Purpose: Executes fabric login. This action determines what type of driver - loop or fabric.
            If we are on a loop Flogi fails with bad ALPA otherwise any other response
            indicates a switch is connected. 
            SFStateFlogiAccept   Good switch response continue 
            SFStateFlogiRej      Good switch response Adjust paramaters and retry FLOGI
            SFStateDoFlogi:      Bad response retry FLOGI
            SFStateFlogiTimedOut Bad response retry FLOGI
            SFStateFlogiBadALPA  Good loop response continue

 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncShowWhereDevThreadsAre
            SFEventDoFlogi
            CFuncInterruptPoll
            CEventFlogiSuccess
            CEventGotFlogiThread
            CEventFlogiFail
            CEventAsyncLoopEventDetected
-*/
/*CStateDoFlogi               7*/
extern void CActionDoFlogi( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t  * hpRoot   = thread->hpRoot;
    CThread_t * pCThread = CThread_ptr( hpRoot);
    os_bit32 SFthreadState = 0;
    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;
    pSFThread->parent.Device= (DevThread_t *)agNULL;

    CFuncYellowLed(thread->hpRoot, agFALSE);


    fiLogString(thread->hpRoot,
                "SELF %p In %s Fpc %x inIMQ %x AC %x SF %p",
                "CADF",(char *)agNULL,
                pCThread->DeviceSelf,pSFThread,
                pCThread->FLOGI_pollingCount,
                pCThread->ProcessingIMQ,
                CFuncAll_clear( thread->hpRoot ),
                0,0,0,0,0);


    pCThread->DirectoryServicesStarted = agFALSE;

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Before %s - State = %d InIMQ %x My_ID %08X",
                    "CADF",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->ProcessingIMQ,
                    fiComputeCThread_S_ID(pCThread),
                    0,0,0,0,0);

    /* DRL find dev thread*/
    CFuncShowWhereDevThreadsAre( hpRoot);

    fiSetEventRecordNull(eventRecord);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoFlogi);

    if(CFuncInterruptPoll( hpRoot,&pCThread->FLOGI_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Flogi Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
        fiLogString(thread->hpRoot,
                    "DoFlogi TimeOut FM %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    0,0,0,0,0,0,0);
    }

    SFthreadState = pSFThread->thread_hdr.currentState;

    switch(SFthreadState)
    {
        case SFStateFlogiAccept:
                            fiSetEventRecord(eventRecord,thread,CEventFlogiSuccess);
                            break;

        case SFStateFlogiRej:
                            fiLogString(hpRoot,
                                            "Do Flogi Fail REJ SF %d Retry %d Rea %x Exp %x",
                                            (char *)agNULL,(char *)agNULL,
                                            (void *)agNULL,(void *)agNULL,
                                            SFthreadState,
                                            (os_bit32)pSFThread->SF_REJ_RETRY_COUNT,
                                            (os_bit32)pSFThread->RejectReasonCode,
                                            (os_bit32)pSFThread->RejectExplanation,
                                            0,0,0,0);
                switch(pSFThread->RejectReasonCode )
                    {
                        case FC_ELS_LS_RJT_Shifted_Logical_Error:
                            if(pSFThread->RejectExplanation == FC_ELS_LS_RJT_Shifted_Invalid_Common_Service_Parameters)
                            {
                                pCThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size = 0;
                                if (CThread_ptr(hpRoot)->DEVID == ChipConfig_DEVID_TachyonXL2)
                                {
                                    pCThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
                                        =   FC_N_Port_Common_Parms_Continuously_Increasing_Supported
                                          | FC_N_Port_Common_Parms_N_Port
                                          /* MacData | FC_N_Port_Common_Parms_Alternate_BB_Credit_Management */ 
                                          | (CFunc_MAX_XL2_Payload(hpRoot) << FC_N_Port_Common_Parms_BB_Recv_Data_Field_Size_SHIFT);

                                }
                                else
                                {
                                    pCThread->ChanInfo.N_Port_Common_Parms.Common_Features__BB_Recv_Data_Field_Size
                                        =   FC_N_Port_Common_Parms_Continuously_Increasing_Supported
                                          | FC_N_Port_Common_Parms_N_Port
                                          /* MacData | FC_N_Port_Common_Parms_Alternate_BB_Credit_Management */ 
                                          | (TachyonTL_Max_Frame_Payload << FC_N_Port_Common_Parms_BB_Recv_Data_Field_Size_SHIFT);

                                }

                                fiLogString(hpRoot,
                                                "McData Switch Detected Rej Rea %x Exp %x",
                                                (char *)agNULL,(char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                pSFThread->RejectReasonCode,
                                                pSFThread->RejectExplanation,
                                                0,0,0,0,0,0);

                                fiSetEventRecord(eventRecord,thread,CEventGotFlogiThread);
                                return;
                            }
                            fiLogString(hpRoot,
                                            "%s %s ! Rej Rea %x Exp %x",
                                            "FC_ELS_LS_RJT_Shifted_Logical_Error","Not Coded",
                                            (void *)agNULL,(void *)agNULL,
                                            pSFThread->RejectReasonCode,
                                            pSFThread->RejectExplanation,
                                            0,0,0,0,0,0);
                            break;

                        case FC_ELS_LS_RJT_Shifted_Command_Not_Supported:
                                    if(pSFThread->RejectExplanation == (FC_ELS_LS_RJT_Shifted_No_Additional_Explanation ))
                                    {/* We get this reject from Brocade */
                                        if(pSFThread->SF_REJ_RETRY_COUNT < MAX_FLOGI_RETRYS )
                                        {  
                                            pSFThread->SF_REJ_RETRY_COUNT += 1;
                                            fiSetEventRecord(eventRecord,thread,CEventGotFlogiThread);
                                            return;
                                        }
                                        else
                                        {
                                            fiLogString(hpRoot,
                                                            "%s %s ! Retry %d",
                                                            "FC_ELS_LS_RJT_Shifted_Command_Not_Supported","Give it up",
                                                            (void *)agNULL,(void *)agNULL,
                                                            pSFThread->SF_REJ_RETRY_COUNT,
                                                            0,0,0,0,0,0,0);
                                        }
                                    }

                                    fiSetEventRecord(eventRecord,thread,CEventFlogiFail);
                                    pCThread->FlogiSucceeded = agFALSE;

                                    if(pCThread->InitAsNport)
                                    {  
                                        pCThread->DeviceDiscoveryMethod = DDiscoveryMethodInvalid;
                                    }
                                    else
                                    {
                                        if(pCThread->LoopMapLIRP_Received )
                                        {
                                            pCThread->DeviceDiscoveryMethod = DDiscoveryLoopMapReceived;
                                        }
                                        else
                                        {
                                            pCThread->DeviceDiscoveryMethod = DDiscoveryScanAllALPAs;
                                        }
                                    }

                                    break;

                        case FC_ELS_LS_RJT_Shifted_Invalid_LS_Command_Code:
                            fiLogString(hpRoot,
                                            "%s %s Rej Rea %x Exp %x",
                                            "FC_ELS_LS_RJT_Shifted_Invalid_LS_Command_Code","Not Coded",
                                            (void *)agNULL,(void *)agNULL,
                                            pSFThread->RejectReasonCode,
                                            pSFThread->RejectExplanation,
                                            0,0,0,0,0,0);
                                    break;

                        case FC_ELS_LS_RJT_Shifted_Logical_Busy:
                            fiLogString(hpRoot,
                                            "%s %s Rej Rea %x Exp %x",
                                            "FC_ELS_LS_RJT_Shifted_Logical_Busy","Not Coded",
                                            (void *)agNULL,(void *)agNULL,
                                            pSFThread->RejectReasonCode,
                                            pSFThread->RejectExplanation,
                                            0,0,0,0,0,0);
                                    break;
                        case FC_ELS_LS_RJT_Shifted_Protocol_Error:
                            fiLogString(hpRoot,
                                            "%s %s Rej Rea %x Exp %x",
                                            "FC_ELS_LS_RJT_Shifted_Protocol_Error","Not Coded",
                                            (void *)agNULL,(void *)agNULL,
                                            pSFThread->RejectReasonCode,
                                            pSFThread->RejectExplanation,
                                            0,0,0,0,0,0);
                                    break;
                        case FC_ELS_LS_RJT_Shifted_Unable_to_perform_command_request:
                            /*flogi to brocade with old port address */
                            fiLogString(hpRoot,
                                            "%s %s Rej Rea %x Exp %x",
                                            "FC_ELS_LS_RJT_Shifted_Unable_to_perform_command_request","Not Coded",
                                            (void *)agNULL,(void *)agNULL,
                                            pSFThread->RejectReasonCode,
                                            pSFThread->RejectExplanation,
                                            0,0,0,0,0,0);
                                    break;
                        case FC_ELS_LS_RJT_Shifted_Vendor_Unique_Error:
                            fiLogString(hpRoot,
                                            "%s %s Rej Rea %x Exp %x",
                                            "FC_ELS_LS_RJT_Shifted_Vendor_Unique_Error","Not Coded",
                                            (void *)agNULL,(void *)agNULL,
                                            pSFThread->RejectReasonCode,
                                            pSFThread->RejectExplanation,
                                            0,0,0,0,0,0);
                                    break;
                        default:
                                if(pSFThread->SF_REJ_RETRY_COUNT < MAX_FLOGI_RETRYS )
                                {  
                                    pSFThread->SF_REJ_RETRY_COUNT += 1;
                                    fiSetEventRecord(eventRecord,thread,CEventGotFlogiThread);
                                    return;
                                }
                                else
                                {
                                    fiLogString(hpRoot,
                                                    "Unknown FLOGI Reason   SF %d Retry %d Reason %X Explanation %X",
                                                    (char *)agNULL,(char *)agNULL,
                                                    (void *)agNULL,(void *)agNULL,
                                                    SFthreadState,
                                                    (os_bit32)pSFThread->SF_REJ_RETRY_COUNT,
                                                    (os_bit32)pSFThread->RejectReasonCode,
                                                    (os_bit32)pSFThread->RejectExplanation,
                                                    0,0,0,0);
                                }

                        }

                        fiSetEventRecord(eventRecord,thread,CEventFlogiFail);
                        pCThread->FlogiSucceeded = agFALSE;
                        if(pCThread->InitAsNport)
                        {  
                            pCThread->DeviceDiscoveryMethod = DDiscoveryMethodInvalid;
                        }
                        else
                        {
                            if(pCThread->LoopMapLIRP_Received )
                            {
                                pCThread->DeviceDiscoveryMethod = DDiscoveryLoopMapReceived;
                            }
                            else
                            {
                                pCThread->DeviceDiscoveryMethod = DDiscoveryScanAllALPAs;
                            }
                        }
                        break;

                   case SFStateFlogiBadALPA:
                            {
                               fiSetEventRecord(eventRecord,thread,CEventFlogiFail);

                                if(pCThread->InitAsNport)
                                {  
                                    pCThread->DeviceDiscoveryMethod = DDiscoveryMethodInvalid;
                                }
                                else
                                {

                                    pCThread->ChanInfo.CurrentAddress.Domain = 0;
                                    pCThread->ChanInfo.CurrentAddress.Area   = 0;
                                    osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, (fiComputeCThread_S_ID(pCThread) ));
                                    if(pCThread->LoopMapLIRP_Received )
                                    {
                                        pCThread->DeviceDiscoveryMethod = DDiscoveryLoopMapReceived;
                                    }
                                    else
                                    {
                                        pCThread->DeviceDiscoveryMethod = DDiscoveryScanAllALPAs;
                                    }
                                }
                                pCThread->FlogiSucceeded = agFALSE;

                                fiLogString(hpRoot,
                                                "Flogi Bad ALPA SF %d R %d Reas %X Exp %X DM %x",
                                                (char *)agNULL,(char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                SFthreadState,
                                                (os_bit32)pSFThread->SF_REJ_RETRY_COUNT,
                                                (os_bit32)pSFThread->RejectReasonCode,
                                                (os_bit32)pSFThread->RejectExplanation,
                                                pCThread->DeviceDiscoveryMethod,
                                                0,0,0);

                                fiLogString(hpRoot,
                                                "MY_ID %X MY dev ID %X",
                                                (char *)agNULL,(char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                fiComputeCThread_S_ID(pCThread),
                                                fiComputeDevThread_D_ID(pCThread->DeviceSelf),
                                                0,0,0,0,0,0);

  
                            }

                           break;
        case SFStateDoFlogi:
        case SFStateFlogiTimedOut:
                            if(pCThread->FlogiTimedOut)
                            {
                                pCThread->FlogiSucceeded = agFALSE;
                                if(pCThread->NumberOfFLOGITimeouts < MAX_FLOGI_TIMEOUTS )
                                {
                                    pCThread->NumberOfFLOGITimeouts ++;
                                    pCThread->FlogiTimedOut = agFALSE;
                                    fiSetEventRecord(eventRecord,thread,CEventGotFlogiThread);
                                    return;
                                }
                                fiLogString(hpRoot,
                                                "Do Flogi Timedout SF %d Timouts %d",
                                                (char *)agNULL,(char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                SFthreadState,
                                                pCThread->NumberOfFLOGITimeouts,
                                                0,0,0,0,0,0);

                                /* fiSetEventRecord(eventRecord,thread,CEventFlogiFail);*/
                                if(pCThread->FlogiRcvdFromTarget )
                                {
                                    fiSetEventRecord(eventRecord,thread,CEventGoToInitializeFailed);
                                }
                                else
                                {
                                    fiSetEventRecord(eventRecord,thread,CEventDoInitalize);
                                }
                                break;
                            }
                            else
                            {
                                pCThread->NumberOfFLOGITimeouts ++;
                                pCThread->FlogiTimedOut = agTRUE;
                                fiSetEventRecord(eventRecord,thread,CEventGotFlogiThread);
                                return;
                            }
                            pCThread->ReScanForDevices = agTRUE;
        default:
                            {
                                fiLogString(hpRoot,
                                                "Do Flogi Invalid SF %d",
                                                (char *)agNULL,(char *)agNULL,
                                                (void *)agNULL,(void *)agNULL,
                                                SFthreadState,
                                                0,0,0,0,0,0,0);

                                pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
                                fiSetEventRecord(eventRecord,thread,CEventAsyncLoopEventDetected);
                            }

    }



    fiLogString(thread->hpRoot,
                "SELF %p Out %s Fpc %x inIMQ %x AC %x SF %d",
                "CADF",(char *)agNULL,
                pCThread->DeviceSelf,(void *)agNULL,
                pCThread->FLOGI_pollingCount,
                pCThread->ProcessingIMQ,
                CFuncAll_clear( thread->hpRoot ),
                SFthreadState,
                0,0,0,0);
/*
    CFuncShowWhereDevThreadsAre( hpRoot, agTRUE );
*/
    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After  %s - State = %d SFThread %p FDcnt %x",
                    "CADF",(char *)agNULL,
                    hpRoot,pSFThread,
                    (os_bit32)thread->currentState,
                    pCThread->FindDEV_pollingCount,
                    0,0,0,0,0,0);


}

/*+
  Function: CActionFlogiSuccess
   Purpose: Checks for running timers either set a timer to continue talking to switch
            or does so immediatly if timers are not running
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventDoDiPlogi
            fiTimerStart
-*/
/* CStateFlogiSuccess          8 */
extern void CActionFlogiSuccess( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    CThread_t  * pCThread = CThread_ptr(thread->hpRoot);

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p In %s - State = %d InIMQ %x",
                    "CActionFlogiSuccess",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->ProcessingIMQ,
                    0,0,0,0,0,0);

#ifdef Do_Not_USE_Flogi_SFThread
    SFThreadFree(thread->hpRoot, & pCThread->SFThread_Request );
    pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
#endif/* Do_Not_USE_Flogi_SFThread */
    /* Update the EDTOV register with the right EDTOV value gotten from the fabric */

   /* osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_TimeOut_Values_1,
                                (pCThread->F_Port_Common_Parms.E_D_TOV<<ChipIOUp_Frame_Manager_TimeOut_Values_1_ED_TOV_SHIFT)); */

    pCThread->FlogiSucceeded = agTRUE;
    if (pCThread->TimerTickActive)
    {

        fiSetEventRecordNull(eventRecord);
        fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "%s hproot %p Need to go through RSCN after timeout",
                "CActionFlogiSuccess",(char *)agNULL,
                thread->hpRoot,(void *)agNULL,
                0,0,0,0,0,0,0,0);

       if(! fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                       &(pCThread->TimerQ)))
       {
            fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "%s Setting Timer for RSCN",
                        "CActionFlogiSuccess",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);
            fiTimerSetDeadlineFromNow(thread->hpRoot, &pCThread->Timer_Request, CWaitAfterFlogi);

            pCThread->Timer_Request.eventRecord_to_send.thread= thread;

            pCThread->Timer_Request.eventRecord_to_send.event = CEventDoDiPlogi;
/*
            pCThread->Timer_Request.eventRecord_to_send.event = CEventAllocDiPlogiThread;
*/
            fiTimerStart(thread->hpRoot,&pCThread->Timer_Request);

       }
    } /* RSCN Pending */
    else
    {
#ifdef NAME_SERVICES
/*
        fiSetEventRecord(eventRecord, thread, CEventAllocDiPlogiThread);
*/
        fiSetEventRecord(eventRecord, thread, CEventDoDiPlogi);
#else /* NAME_SERVICES */
        fiSetEventRecord(eventRecord,thread,CEventSameALPA);
#endif/* NAME_SERVICES */
    }/*No RSCN Pending */
}

/*+
  Function: CActionALPADifferent
   Purpose: Was expected to "fix up" channel if switch changed our ALPA. This is handled when 
            FLOGI payload is parsed
 Called By: NONE
     Calls: CFuncYellowLed to indicate link down
            Terminating State
-*/
/* CStateALPADifferent         9 */
extern void CActionALPADifferent( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionALPADifferent",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: CActionFreeSFthread
   Purpose: Releases FLOGI/Switch SFThread. Does fine tuning of device discovery method.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncShowWhereDevThreadsAre
            SFThreadFree
            Proccess_IMQ
            CEventSameALPA
            CEventInitalizeFailure
            CEventFindPtToPtDevice
            CEventAsyncLoopEventDetected
            CEventInitalizeSuccess

-*/
/* CStateFreeSFthread          10 */
extern void CActionFreeSFthread( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    CThread_t  * pCThread = CThread_ptr(thread->hpRoot);

    event_t  Event_To_Send    = CEventInitalizeSuccess;

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d InIMQ %x",
                    "CActionFreeSFthread",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->ProcessingIMQ,
                    0,0,0,0,0,0);
    /* DRL find dev thread*/
    CFuncShowWhereDevThreadsAre( thread->hpRoot);


    SFThreadFree(thread->hpRoot, & pCThread->SFThread_Request );
    pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;

    /* Clear Bad ALPA from FLOGI Failure */

    if( ! pCThread->ProcessingIMQ )
    {
        pCThread->FuncPtrs.Proccess_IMQ(thread->hpRoot);
    }


    if (!(pCThread->FlogiSucceeded )) 
    {
        if (!(pCThread->InitAsNport))
        {
            Event_To_Send = CEventSameALPA;
        }
        else
        {
#ifdef NPORT_NOT_SUPPORTED
           /* We may be in an NPort to Nport Mode. Currently not supported */
           fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "hpRoot %08X Possible NPort Connect In %s - State = %d",
                "CActionFreeSFthread",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)thread->hpRoot,
                (os_bit32)thread->currentState,
                0,0,0,0,0,0);
            Event_To_Send = CEventInitalizeFailure;
#else /* NPORT_NOT_SUPPORTED */
            Event_To_Send = CEventFindPtToPtDevice;
            pCThread->DeviceDiscoveryMethod  =  DDiscoveryPtToPtConnection;
        
#endif /* NPORT_NOT_SUPPORTED */
        }
    }
    else
    {
           /*In this case we are sure we are connected to FL/FPort, FLOGI
            succeeded but directory services failes, we do not want to treat this like a
            private loop and scan all the devices. Take it Initialize failed. */
            fiLogDebugString(thread->hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot %P Out %s - State = %d Sending event %s FlogiSucceeded",
                            "CActionFreeSFthread","CEventInitalizeFailure",
                            thread->hpRoot,(void *)agNULL,
                            (os_bit32)thread->currentState,
                            0,0,0,0,0,0,0);
            fiLogString(thread->hpRoot,
                            "Directory Fail DSFRy %d",
                            (char *)NULL,(char *)NULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->DirectoryServicesFailed,
                            0,0,0,0,0,0,0);

            /* Try again if we got to failed then we link down and errors occur */
/* WAS
            fiSetEventRecord(eventRecord,thread, CEventInitalizeFailure );
*/
            /* WAS pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;*/
            /* WAS fiSetEventRecord(eventRecord,thread, CEventAsyncLoopEventDetected );*/
            if( ! pCThread->DirectoryServicesFailed)
            {
                pCThread->DirectoryServicesFailed = agTRUE;
                pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
                fiSetEventRecord(eventRecord,thread, CEventAsyncLoopEventDetected );
            }
            else
            {
                fiSetEventRecord(eventRecord,thread, CEventDeviceListEmpty );
            }
            return;

    }

    if(pCThread->DirectoryServicesStarted )
    {
          fiLogDebugString(thread->hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot %P Out %s - State = %d Sending event %s FlogiSucceeded",
                            "CActionFreeSFthread","CEventAsyncLoopEventDetected",
                            thread->hpRoot,(void *)agNULL,
                            (os_bit32)thread->currentState,
                            0,0,0,0,0,0,0);
            fiLogString(thread->hpRoot,
                            "Directory sevice Fail Retrying",
                            (char *)NULL,(char *)NULL,
                            (void *)agNULL,(void *)agNULL,
                            0,0,0,0,0,0,0,0);

            pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
            fiSetEventRecord(eventRecord,thread, CEventAsyncLoopEventDetected );
            return;
    }

    fiSetEventRecord(eventRecord,thread,Event_To_Send);
    pCThread->Flogi_AllocDone = agTRUE;

}

/*+
  Function: CActionSuccess
   Purpose: If we get to this point all channel setup has been successful. Do some double checking before
            device discovery. Sets next event to proper device device discovery method.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncShowWhereDevThreadsAre
            SFThreadFree
            CFuncEnable_Interrupts
            Proccess_IMQ
            CFunc_Queues_Frozen
            CEventFindDeviceUseNameServer
            CEventFindDeviceUseLoopMap
            CEventInitalizeSuccess
-*/
/* CStateSuccess               11 */
extern void CActionSuccess( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    CThread_t  * pCThread           = CThread_ptr(thread->hpRoot);
    event_t      Initialized_event  = CEventInitalizeSuccess;
    SFThread_t * pSFThread          = pCThread->SFThread_Request.SFThread;

    CFuncYellowLed(thread->hpRoot, agFALSE);

    if(pSFThread != (SFThread_t *) agNULL)
    {
       if( pCThread->SFThread_Request.State == SFThread_Request_Granted)
        {
            fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "pCThread %p Freeing SFThread in %s ",
                "CActionSuccess",(char *)agNULL,
                pCThread,(void *)agNULL,
                0,0,0,0,0,0,0,0);

            SFThreadFree( thread->hpRoot, &pCThread->SFThread_Request );
            pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
        }
    }

    CFuncEnable_Interrupts(
                            thread->hpRoot,
                            (  ChipIOUp_INTEN_MPE
                             | ChipIOUp_INTEN_CRS
                             | ChipIOUp_INTEN_INT
                             | ChipIOUp_INTEN_DER
                             | ChipIOUp_INTEN_PER)
                          );


    faSingleThreadedLeave( thread->hpRoot ,CStateSuccess );

    osFCLayerAsyncEvent( thread->hpRoot, osFCLinkDown );

    faSingleThreadedEnter( thread->hpRoot ,CStateSuccess );

    if(thread->currentState != CStateSuccess )
    {

        fiLogDebugString(thread->hpRoot,
                            CSTATE_NOISE(thread->hpRoot,CStateSuccess),
                            "hpRoot %p After In %s - State = %d Wrong not %d - Event %d InIMQ %x",
                            "CActionSuccess",(char *)agNULL,
                            thread->hpRoot,(void *)agNULL,
                            (os_bit32)thread->currentState,
                            CStateSuccess,
                            Initialized_event,
                            0,0,0,0,0);


        if(pCThread->LoopPreviousSuccess)
        {

            pCThread->Loop_Reset_Event_to_Send = CEventDoInitalize;
            Initialized_event = CEventAsyncLoopEventDetected;
        }
        else
        {
            Initialized_event = CEventLoopNeedsReinit;
        }

        fiLogDebugString(thread->hpRoot,
                    CSTATE_NOISE(thread->hpRoot,CStateSuccess),
                    "hpRoot %p In %s - State = %d - Event %d Queues %x LD %x IR %x InIMQ %x",
                    "CActionSuccess",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    Initialized_event,
                    CFunc_Queues_Frozen( thread->hpRoot ),
                    pCThread->LOOP_DOWN,
                    pCThread->IDLE_RECEIVED,
                    pCThread->ProcessingIMQ,0,0);

    }


    if(CFunc_Queues_Frozen( thread->hpRoot ))
    {

        if(! pCThread->ProcessingIMQ)
        {
            pCThread->FuncPtrs.Proccess_IMQ(thread->hpRoot);
        }
        else
        {
            fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot %p In %s - State = %d - Event %d Queues %x LD %x IR %x InIMQ %x",
                        "CActionSuccess",(char *)agNULL,
                        thread->hpRoot,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        Initialized_event,
                        CFunc_Queues_Frozen( thread->hpRoot ),
                        pCThread->LOOP_DOWN,
                        pCThread->IDLE_RECEIVED,
                        pCThread->ProcessingIMQ,0,0);
        }
    }

    if(ERQ_FULL(pCThread->HostCopy_ERQProdIndex,
                pCThread->FuncPtrs.GetERQConsIndex(thread->hpRoot),
                pCThread->Calculation.MemoryLayout.ERQ.elements     ))
    {
        fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "ERQ FULL ERQ_PROD %d Cons INDEX %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_ERQProdIndex,
                    pCThread->FuncPtrs.GetERQConsIndex(thread->hpRoot ),
                    0,0,0,0,0,0);
        Initialized_event = CEventLoopNeedsReinit;

    }

    fiLogDebugString(thread->hpRoot,
                    /* CSTATE_NOISE(thread->hpRoot,CStateSuccess),*/
                    CStateLogConsoleERROR,
                    "hpRoot %p In %s - State = %d - Event %d Queues %x LD %x IR %x InIMQ %x FDcnt %x",
                    "CActionSuccess",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    Initialized_event,
                    CFunc_Queues_Frozen( thread->hpRoot ),
                    pCThread->LOOP_DOWN,
                    pCThread->IDLE_RECEIVED,
                    pCThread->ProcessingIMQ,
                    pCThread->FindDEV_pollingCount,0);


    if(!  CFuncAll_clear( thread->hpRoot ) )
    {
        Initialized_event = CEventLoopNeedsReinit;

        fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot %p In %s - State = %d - Event %d Queues %x LD %x IR %x InIMQ %x",
                        "CActionSuccess",(char *)agNULL,
                        thread->hpRoot,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        Initialized_event,
                        CFunc_Queues_Frozen( thread->hpRoot ),
                        pCThread->LOOP_DOWN,
                        pCThread->IDLE_RECEIVED,
                        pCThread->ProcessingIMQ,0,0);
    }

    if(Initialized_event == CEventInitalizeSuccess)
    {
        switch (pCThread->DeviceDiscoveryMethod){

        case DDiscoveryQueriedNameService:
            fiSetEventRecord(eventRecord,thread,CEventFindDeviceUseNameServer);
            break;

        case DDiscoveryLoopMapReceived:
            fiSetEventRecord(eventRecord,thread,CEventFindDeviceUseLoopMap);
            break;

        case DDiscoveryMethodInvalid:
            fiSetEventRecord(eventRecord,thread,CEventGoToInitializeFailed);
            break;

        /* The default is the brute force method */
        default:
            fiSetEventRecord(eventRecord,thread,Initialized_event);
            break;
        }

        fiLogString(thread->hpRoot,
                        "%s DeviceDiscoveryMethod %X",
                        "CActionSuccess",(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->DeviceDiscoveryMethod,
                        0,0,0,0,0,0,0);
        return;
    }



    fiSetEventRecord(eventRecord,thread,Initialized_event);
}

/*+
  Function: CActionNormal
   Purpose: If we get to this point everything has been successful. All devices have been found.
            Indicate handles are available by setting osFCLinkUp. This is the only state that
            the osLayer is allowed to send IO to devices. At all other times it is invalid.
 Called By: 
     Calls: Terminating State
            CFuncYellowLed to indicate link up
            CFuncShowWhereDevThreadsAre
            CFuncInterruptPoll
            fiTimerStop
            CFuncCheckForDuplicateDevThread
-*/
/* CStateNormal                12 */
extern void CActionNormal( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    CThread_t  * pCThread    = CThread_ptr(thread->hpRoot);
    agRoot_t   * hpRoot      = thread->hpRoot;

    pCThread->DirectoryServicesFailed = agFALSE;
    pCThread->NumberOfPlogiTimeouts =0;

    fiLogString(hpRoot,
                "%d %s MY_ID %X DM %X",
                "CAN",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)thread->currentState,
                fiComputeCThread_S_ID(pCThread),
                pCThread->DeviceDiscoveryMethod,
                0,0,0,0,0 );

    if( pCThread->FindDEV_pollingCount )
    {

        fiLogString(hpRoot,
                    "%d %s Free %d Active %d Un %d Login %d",
                    "CAN",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
			        fiNumElementsOnList(&pCThread->Free_DevLink),
			        fiNumElementsOnList(&pCThread->Active_DevLink),
			        fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
			        fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                    0,0,0 );
        fiLogString(hpRoot,
                    "Fdcnt %d %s ADISC %d SS %d PrevA login %d Prev Un %d",
                    "CAN",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->FindDEV_pollingCount, 
			        fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
			        fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
			        fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
			        fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink),
                    0,0,0 );

        if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    "CAN",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
            pCThread->FindDEV_pollingCount = 0;
        }

    }
    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "In - %s FM Status %08X TL Status %08X Ints %08X sysInts-Act %x Log %x",
                    "CAN",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                    CThread_ptr(hpRoot)->sysIntsActive,
                    CThread_ptr(hpRoot)->sysIntsLogicallyEnabled,
                    0,0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LOOP_DOWN,
                    CThread_ptr(hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(hpRoot)->ERQ_FROZEN,
                    CThread_ptr(hpRoot)->FCP_FROZEN,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "pCThread->HostCopy_IMQConsIndex %X  IMQProdIndex %X FDcnt %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->HostCopy_IMQConsIndex,
                    pCThread->FuncPtrs.GetIMQProdIndex(hpRoot),
                    pCThread->FindDEV_pollingCount,
                    0,0,0,0,0);


#ifdef NPORT_STUFF

    if (pCThread->ConnectedToNportOrFPort)
    {

        fiSetEventRecordNull(eventRecord);

        if(fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                       &(pCThread->TimerQ)))
        {
            if(pCThread->Timer_Request.eventRecord_to_send.event != CEventAllocDiPlogiThread)
            {
                fiTimerStop(&pCThread->Timer_Request);
            }
        }

        fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleLevel,
                        "hpRoot %p NPort Out %s",
                        "CAN",(char *)agNULL,
                        thread->hpRoot,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

        if(pCThread->FindDEV_pollingCount)
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "%s Ccnt Non Zero FDcnt %x",
                        "CAN",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->FindDEV_pollingCount,
                        0,0,0,0,0,0,0);
        }

        CFuncYellowLed(hpRoot, agTRUE );
        if(pCThread->ChanInfo.LIPCountLower + 1 < pCThread->ChanInfo.LIPCountUpper )
        {
            pCThread->ChanInfo.LIPCountUpper ++;
        }
        pCThread->ChanInfo.LIPCountLower += 1;

        faSingleThreadedLeave( thread->hpRoot,CStateNormal  );

        osFCLayerAsyncEvent( thread->hpRoot, osFCLinkUp );

        faSingleThreadedEnter( thread->hpRoot,CStateNormal );

        return;
    }
#endif    /* NPORT_STUFF */


#ifdef FLIP_NportState
    if(! fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                   &(pCThread->TimerQ)))
    {
        fiTimerSetDeadlineFromNow(thread->hpRoot, &pCThread->Timer_Request, CFlipNportTOV);

        pCThread->Timer_Request.eventRecord_to_send.thread= thread;

        pCThread->Timer_Request.eventRecord_to_send.event = CEventFlipNPortState;

        fiTimerStart(thread->hpRoot,&pCThread->Timer_Request);

    }

#endif /* FLIP_NportState */

    fiSetEventRecordNull(eventRecord);

    if(fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                   &(pCThread->TimerQ)))
    {
        fiLogString(thread->hpRoot,
                        "%s %s Event %d",
                        "CAN","Timer set",
                        (void *)agNULL,(void *)agNULL,
                        pCThread->Timer_Request.eventRecord_to_send.event,
                        0,0,0,0,0,0,0);

        if(pCThread->Timer_Request.eventRecord_to_send.event != CEventAllocDiPlogiThread)
        {
            fiTimerStop(&pCThread->Timer_Request);
        }
    }

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleLevel,
                    "hpRoot %p Out %s",
                    "CAN",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    if( pCThread->Loop_Reset_Event_to_Send == CEventDoInitalize )
    {   /* The Loop came up good Initalize causes LIP.... */
        if (! pCThread->InitAsNport)
        {
            pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
        }
    }

    fiLogString(hpRoot,
                    "%s FM Stat %08X LPS %x LRES %d AC %x Num Dev %d",
                    "CAN",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    pCThread->LoopPreviousSuccess,
                    pCThread->Loop_Reset_Event_to_Send,
                    CFuncAll_clear(hpRoot ),
                    CFuncCountFC4_Devices(hpRoot),
                    0,0,0);
    fiLogString(hpRoot,
                    "%s Active %x ADISC %d FDcnt %d",
                    "CAN",(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
				    CFuncShowActiveCDBThreads( hpRoot, ShowActive),
                    pCThread->ADISC_pollingCount,
                    pCThread->FindDEV_pollingCount,
                    0,0,0,0,0);

    CFuncYellowLed(hpRoot, agTRUE );

    CFuncCheckForDuplicateDevThread( thread->hpRoot );

    faSingleThreadedLeave( thread->hpRoot,CStateNormal  );

    osFCLayerAsyncEvent( thread->hpRoot, osFCLinkUp );

    faSingleThreadedEnter( thread->hpRoot,CStateNormal );


}

/*+
  Function: CActionResetNeeded
   Purpose: When ever link event occurs this state is called. If chip is bypassed
            reinitialize.
 Called By: 
     Calls: Terminating State
            CFuncYellowLed to indicate link down
-*/
/*CStateResetNeeded           13*/
extern void CActionResetNeeded( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t      * hpRoot  = thread->hpRoot;
    CFuncYellowLed(hpRoot, agFALSE);

    faSingleThreadedLeave( hpRoot, CStateResetNeeded );

    osFCLayerAsyncEvent( hpRoot, osFCLinkDown );

    faSingleThreadedEnter( hpRoot, CStateResetNeeded);

    if( osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) & ChipIOUp_Frame_Manager_Status_BYP )
    {
        fiSetEventRecord(eventRecord,thread,CEventDoInitalize);

        fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "In %s with ChipIOUp_Frame_Manager_Status_BYP event %d",
                            "CARN",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            CEventDoInitalize,
                            0,0,0,0,0,0,0);
        return;
    }


    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Out %s FDcnt %x InIMQ %x",
                    "CARN",(char *)agNULL,
                    hpRoot,(void *)agNULL,
                    CThread_ptr(hpRoot)->FindDEV_pollingCount,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0,0,0,0,0);

    fiLogString(hpRoot,
                    "%s TL %08X LDT %X",
                    "CARN",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    CThread_ptr(hpRoot)->LinkDownTime.Lo,
                    0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);

}

/*+
  Function: CActionLoopFail
   Purpose: This state sends ADISC to all targets.
            Exit this state if currently processing the IMQ
            If ALPA changed kill all outstanding IO's
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventLoopNeedsReinit
            CEventAsyncLoopEventDetected
            CFuncFreezeQueuesPoll
            CFuncCompleteAllActiveCDBThreads
            CFuncShowWhereDevThreadsAre
            CFuncWhatStateAreDevThread
            CFunc_Always_Enable_Queues
            CFuncAll_clear
            CEventAsyncLoopEventDetected
            DevEventAllocAdisc
            CFuncInterruptPoll
            CFuncCompleteActiveCDBThreadsOnDevice
            DevThreadFree
            CEventLoopEventDetected
            CEventLoopConditionCleared
-*/
/* CStateLoopFail              14 */
extern void CActionLoopFail( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    event_t         Initialized_event  = CEventLoopNeedsReinit;
    agRoot_t      * hpRoot             = thread->hpRoot;
    CThread_t     * pCThread           = CThread_ptr(hpRoot);

    CFuncYellowLed(hpRoot, agFALSE);

    fiLogString(thread->hpRoot,
                "In %s Fpc %x inIMQ %x AC %x ADISC %d FDcnt %d Lrets %d",
                "CALF",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->FLOGI_pollingCount,
                pCThread->ProcessingIMQ,
                CFuncAll_clear( thread->hpRoot ),
                pCThread->ADISC_pollingCount,
                pCThread->FindDEV_pollingCount,
                pCThread->Loop_Reset_Event_to_Send,
                0,0);

    fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "%s 0 FDcnt % InIMQ %x",
                "CALF",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->FindDEV_pollingCount,
                pCThread->ProcessingIMQ,
                0,0,0,0,0,0);

    if( pCThread->DeviceSelf ==(DevThread_t *) agNULL )
    {
        if (! pCThread->InitAsNport)
        {
            Initialized_event    = CEventLoopNeedsReinit;
            fiSetEventRecord(eventRecord,thread,Initialized_event);

            fiLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "In %s with agNULL SELF ! event %d",
                                "CALF",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                CEventLoopNeedsReinit,
                                0,0,0,0,0,0,0);
            return;
        }
    }

    if( pCThread->ProcessingIMQ )
    {
        /* If we are in IMQ bail because we can't get any work done */
        pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
        fiSetEventRecord(eventRecord,thread,CEventAsyncLoopEventDetected);
        return;
    }


    if( pCThread->LOOP_DOWN )
    {
/*
        if (pCThread->InitAsNport)
        {
            fiSetEventRecord(eventRecord,thread, CEventInitalizeFailure );
            return;
        }
*/
        if(! CFuncLoopDownPoll(hpRoot))
        {
            if (!pCThread->InitAsNport)
            {

                if( (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) &
                                                    ChipIOUp_Frame_Manager_Status_LSM_MASK) )
                {

                    fiLogString(hpRoot,
                                "Out %s reinit Fpc %x inIMQ %x AC %x ADISC %d FDcnt %d Lrets %d",
                                "CALF",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCThread->FLOGI_pollingCount,
                                pCThread->ProcessingIMQ,
                                CFuncAll_clear( thread->hpRoot ),
                                pCThread->ADISC_pollingCount,
                                pCThread->FindDEV_pollingCount,
                                pCThread->Loop_Reset_Event_to_Send,
                                0,0);
                    fiSetEventRecord(eventRecord,thread,CEventInitalizeFailure);
                    return;


                }
            }

            if( pCThread->thread_hdr.currentState == CStateLIPEventStorm         ||
                pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm   )
            {

                fiLogString(hpRoot,
                                "%s sends %s FM_Status %08X FM_IMQ_Status %08X",
                                "CALF","CEventLIPEventStorm",
                                (void *)agNULL,(void *)agNULL,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                                pCThread->From_IMQ_Frame_Manager_Status,
                                0,0,0,0,0,0);

                fiSetEventRecord(eventRecord,thread,CEventLIPEventStorm);
                return;

            }
        }    
    }
    if( pCThread->ProcessingIMQ )
    {
        /* If we are in IMQ bail because we can't get any work done */
        /* CFuncLoopDownPoll might put us in IMQ ??? */
        pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
        fiSetEventRecord(eventRecord,thread,CEventAsyncLoopEventDetected);
        return;
    }

    if( CFuncFreezeQueuesPoll( hpRoot))
    {
        if( pCThread->thread_hdr.currentState == CStateLIPEventStorm         ||
            pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm   )
        {
            fiLogDebugString(hpRoot,
                            CFuncCheckCstateErrorLevel,
                            "A %s sends %s FM_Status %08X FM_IMQ_Status %08X",
                            "CALF","CEventLIPEventStorm",
                            (void *)agNULL,(void *)agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            pCThread->From_IMQ_Frame_Manager_Status,
                            0,0,0,0,0,0);

            fiSetEventRecord(eventRecord,thread,CEventLIPEventStorm);
            return;

        }
    }

    if(pCThread->ALPA_Changed_OnLinkEvent )
    {

        fiLogString(thread->hpRoot,
                    "In %s %s CurrentAddress %X",
                    "CALF","ALPA_Changed_OnLinkEvent",
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                    0,0,0,0,0,0,0);

        fiLogString(thread->hpRoot,
                    "Fpc %x inIMQ %x AC %x ADISC %d FDcnt %d Lrets %d",
                    (char *)agNULL,(char  *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->FLOGI_pollingCount,
                    pCThread->ProcessingIMQ,
                    CFuncAll_clear( thread->hpRoot ),
                    pCThread->ADISC_pollingCount,
                    pCThread->FindDEV_pollingCount,
                    pCThread->Loop_Reset_Event_to_Send,
                    0,0);

        CFuncCompleteAllActiveCDBThreads( hpRoot, osIODevReset,CDBEventIODeviceReset );
        pCThread->ALPA_Changed_OnLinkEvent = agFALSE;
    }


    if( CFuncShowWhereCDBThreadsAre(hpRoot))
    {
        CFuncWhatStateAreCDBThreads(hpRoot);
    }

    if( osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Producer_Index) != 
                        osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index))
    {
        if( osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ) & ChipIOUp_TachLite_Status_EQF )
        osChipIOLoWriteBit32(hpRoot,ChipIOLo_ERQ_Consumer_Index , 
                        osChipIOLoReadBit32(hpRoot,ChipIOLo_ERQ_Producer_Index ));
    }

    if(CFuncShowWhereDevThreadsAre( hpRoot)) 
    {
        CFuncWhatStateAreDevThreads( hpRoot );
    }

    faSingleThreadedLeave( hpRoot ,CStateLoopFail );

    osFCLayerAsyncEvent( hpRoot, osFCLinkDown );

    faSingleThreadedEnter( hpRoot ,CStateLoopFail);

    /* Reinit without lip ???  */

    if ( CFunc_Always_Enable_Queues(hpRoot ) )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Loop Fail Queues Frozen after Enable",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
    }


    if( CFuncAll_clear( hpRoot ))
    {
        if( pCThread->DeviceSelf !=(DevThread_t *) agNULL )
        {
            Initialized_event    = CEventLoopConditionCleared;
        }
    }

    CFuncShowWhereDevThreadsAre( hpRoot);

    if( thread->currentState != CStateLoopFail )
    {
        pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
        fiSetEventRecord(eventRecord,thread,CEventAsyncLoopEventDetected);
        return;
    }

    fiListEnqueueListAtTail(&pCThread->Active_DevLink,&pCThread->Prev_Active_DevLink);

    CFuncDoADISC( hpRoot);

    /* See if Link event occured */
    if( thread->currentState != CStateLoopFail)
    {
        Initialized_event = CEventLoopEventDetected;
    }

    fiLogString(hpRoot,
                    "%s FM %08X TL %08X AC %x ADISC %d FDcnt %d",
                    "CALF",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    CFuncAll_clear( hpRoot ),
                    pCThread->ADISC_pollingCount,
                    pCThread->FindDEV_pollingCount,
                    0,0,0);



    fiSetEventRecord(eventRecord,thread,Initialized_event);

}

/*+
  Function: CActionReInitFM
   Purpose: This state will generate LIP without reinitializing channel data for LOOP only NPORT goes to CActionInitFM.
            via CEventInitChipSuccess.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventInitChipSuccess
            CFunc_Queues_Frozen
            CFunc_Always_Enable_Queues
            CFuncLoopDownPoll
            CFuncAll_clear
            CFuncQuietShowWhereDevThreadsAre
            CFuncInitFM_Registers
            CFuncDisable_Interrupts
            Proccess_IMQ
            osStallThread
            fiTimerTick
            CEventInitalizeFailure
            CEventAsyncLoopEventDetected
            CEventReInitFMSuccess
-*/
/*CStateReInitFM                15 */
extern void CActionReInitFM( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t *hpRoot= thread->hpRoot;
    CThread_t  *    pCThread        = CThread_ptr(hpRoot);
    os_bit32        Hard_Stall=0;
    event_t  Initialized_event   = CEventReInitFMSuccess;
    agBOOLEAN Success = agFALSE;
    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "In %s with event %d Current State %x (%x) InIMQ %x",
                        "CARIFM",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Initialized_event,
                        thread->currentState,
                        CStateReInitFM,
                        pCThread->ProcessingIMQ,
                        0,0,0,0);


    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "%s FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                        "CARIFM",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                        0,0,0,0);



    CFuncYellowLed( hpRoot, agFALSE);
#ifdef NPORT_STUFF

    /* Unlike the loop case, we are combining the ReinitFM with InitFM.
     * So, transition here directly to Init FM.
     */
    if (pCThread->InitAsNport)
    {
        fiSetEventRecord(eventRecord,thread, CEventInitChipSuccess );
        return;
    }

#endif   /* NPORT_STUFF */
    if(CFunc_Queues_Frozen(hpRoot))
    {
        CFunc_Always_Enable_Queues(hpRoot );
    }

    if( pCThread->LOOP_DOWN )
    {
        CFuncLoopDownPoll(hpRoot);
    }

    if( CFuncAll_clear( hpRoot ) && ( pCThread->DeviceSelf != (DevThread_t *)agNULL ))
    {
        Initialized_event    = CEventLoopConditionCleared;
        Success = agTRUE;
    }
    else
    {
        /*
            CFuncInit_Threads( hpRoot );
            Put Self back on list ????????
        */
        if( pCThread->DeviceSelf != (DevThread_t *)agNULL )
        {
            fiLogString(hpRoot,
                    "%s DevThreadFree Was %X",
                    "CARIFM",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeCThread_S_ID(pCThread),
                    0,0,0,0,0,0,0);

            pCThread->ChanInfo.CurrentAddress.Domain = 0;
            pCThread->ChanInfo.CurrentAddress.Area   = 0;

            DevThreadFree(hpRoot,pCThread->DeviceSelf);
            pCThread->DeviceSelf = (DevThread_t *)agNULL;
        }

        fiLogString(hpRoot,
                    "%s DeviceSelf %X FM %X",
                    "CARIFM",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiComputeCThread_S_ID(pCThread),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    0,0,0,0,0,0);

        CFuncQuietShowWhereDevThreadsAre( hpRoot);
        CFuncInitFM_Registers( hpRoot, agTRUE );
        if( pCThread->NoStallTimerTickActive )
        {
            if(! fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                           &(pCThread->TimerQ)))
            {
                fiLogDebugString( hpRoot,
                                    CStateLogConsoleERROR,
                                    "hpRoot %p Soft Stall In %s - State = %d InIMQ %x",
                                    "CAIFM",(char *)agNULL,
                                    thread->hpRoot,(void *)agNULL,
                                    (os_bit32)thread->currentState,
                                    pCThread->ProcessingIMQ,
                                    0,0,0,0,0,0);

                fiSetEventRecordNull(eventRecord);

                fiTimerSetDeadlineFromNow(hpRoot, &pCThread->Timer_Request, CInitFM_Delay );

                pCThread->Timer_Request.eventRecord_to_send.thread= thread;
                pCThread->Timer_Request.eventRecord_to_send.event = CEventDelay_for_FM_init;

                fiTimerStart(hpRoot,&pCThread->Timer_Request);

                CFuncEnable_Interrupts(
                                        thread->hpRoot,
                                        (  ChipIOUp_INTEN_MPE
                                         | ChipIOUp_INTEN_CRS
                                         | ChipIOUp_INTEN_INT
                                         | ChipIOUp_INTEN_DER
                                         | ChipIOUp_INTEN_PER)
                                      );
               return;
            }
        }
        else
        {

            CFuncInitFM_Registers( hpRoot, agTRUE );

            CFuncDisable_Interrupts(thread->hpRoot,ChipIOUp_INTEN_MASK);/*DRL*/

            Hard_Stall = Init_FM_Delay_Count;
            while( Hard_Stall > 1 )
            {
                pCThread->FuncPtrs.Proccess_IMQ(hpRoot);
                if ( pCThread->DeviceSelf != agNULL)
                {
                    fiLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    "PASS %s HA %x CA %x Hard_Stall %x",
                                    "CARIFM",(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    (os_bit32)(pCThread->ChanInfo.HardAddress.AL_PA),
                                    (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                                    Hard_Stall,
                                    0,0,0,0,0);
                    Success = agTRUE;
                    break;
                }
                osStallThread( hpRoot, 1 );
                fiTimerTick( hpRoot, 1 );
                Hard_Stall--;
            }
        }
        if ( pCThread->DeviceSelf == agNULL)
        {
            Initialized_event = CEventInitalizeFailure;
            fiLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            "FAIL %s HA %x CA %x Hard_Stall %d",
                            "CARIFM",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            (os_bit32)(pCThread->ChanInfo.HardAddress.AL_PA),
                            (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                            Hard_Stall,
                            0,0,0,0,0);
        }
        else
        {
            Initialized_event = CEventReInitFMSuccess;
        }
 
    }

    if( Initialized_event != CEventReInitFMSuccess)
    {
        if( (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ) &
                                            ChipIOUp_Frame_Manager_Status_LSM_MASK) ==
                                            ChipIOUp_Frame_Manager_Status_LSM_Loop_Fail )
        {
            pCThread->Loop_Reset_Event_to_Send = Initialized_event;
            Initialized_event = CEventInitalizeFailure;

        }
        else
        {
            pCThread->Loop_Reset_Event_to_Send = Initialized_event;
            Initialized_event = CEventGoToInitializeFailed;
        }
    }

    fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "Out %s with event %d Current State %d should be %d",
                        "CARIFM",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Initialized_event,
                        thread->currentState,
                        CStateReInitFM,
                        0,0,0,0,0);

    fiLogString(hpRoot,
                "%s Success %x %d FM %X(%X)",
                "CARIFM",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)Success,
                Hard_Stall,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                fiComputeCThread_S_ID(pCThread),
                0,0,0,0);


    fiSetEventRecord(eventRecord,thread, Initialized_event );

}

/*+
  Function: CActionInitializeFailed
   Purpose: This state where you end up if the cable is pulled out or never attached. Loop attempts
            to recover one more time. Terminate until some external action is taken.
 Called By: 
     Calls: CFuncYellowLed to indicate link dead
            fiTimerStop
            CFuncDisable_Interrupts
            osChipIOUpReadBit32
            Proccess_IMQ
            osStallThread
            fiTimerTick
            CEventAsyncLoopEventDetected
            CFuncEnable_Interrupts
-*/
/*  CStateInitializeFailed 16 */
extern void CActionInitializeFailed( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t   *    hpRoot      = thread->hpRoot;
    CThread_t  *    pCThread    = CThread_ptr(hpRoot);
    agBOOLEAN       Success     = agFALSE;
    os_bit32        Hard_Stall  = 0;
    os_bit32        FM_Status  = 0;

    pCThread->NumberOfPlogiTimeouts =0;

    CFuncYellowLed(hpRoot, agFALSE);

    faSingleThreadedLeave( hpRoot , CStateInitializeFailed );

    osFCLayerAsyncEvent( hpRoot, osFCLinkDown );

    faSingleThreadedEnter( hpRoot, CStateInitializeFailed);

    if(fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                   &(pCThread->TimerQ)))
    {
        fiTimerStop(&pCThread->Timer_Request);
    }

    fiLogString( hpRoot,
                    "%s InitAsNport %x MY_ID %x",
                    "CAIF",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->InitAsNport,
                    (os_bit32)fiComputeCThread_S_ID(pCThread),
                    0,0,0,0,0,0);

    if (! pCThread->InitAsNport)
    {
        if(pCThread->TimerTickActive != agTRUE)
        {
            CFuncDisable_Interrupts(hpRoot,ChipIOUp_INTEN_MASK);/*DRL*/
            Hard_Stall = Init_FM_Delay_Count;
            while( Hard_Stall > 1  )
            {
			    FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
			    if(FM_Status & ChipIOUp_Frame_Manager_Status_LS)
			    {
				    break;
			    }
			    if(FM_Status & ChipIOUp_Frame_Manager_Status_EW)
			    {
				    break;
			    }
                pCThread->FuncPtrs.Proccess_IMQ(hpRoot);
                if ( pCThread->DeviceSelf != agNULL)
                {
                    fiLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    "PASS %s HA %x CA %x Hard_Stall %d",
                                    "CAIF",(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    (os_bit32)(pCThread->ChanInfo.HardAddress.AL_PA),
                                    (os_bit32)(pCThread->ChanInfo.CurrentAddress.AL_PA),
                                    Hard_Stall,
                                    0,0,0,0,0);
                    Success = agTRUE;
                    break;
                }
                osStallThread( hpRoot, 1 );
                fiTimerTick( hpRoot, 1 );
                Hard_Stall--;
            }
            if( Success )
            {
                pCThread->Loop_Reset_Event_to_Send = CStateResetNeeded;
                fiSetEventRecord(eventRecord,thread,CEventAsyncLoopEventDetected);
                return;
            }

        }
    }
    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot (%p) In %s - State = %d",
                    "CAIF",(char *)agNULL,
                    hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FM Status %08X FM Config %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "TL Status %08X TL Control %08X Rec Alpa Reg %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0,0);

    CFuncEnable_Interrupts(
                            hpRoot,
                            (  ChipIOUp_INTEN_MPE
                             | ChipIOUp_INTEN_CRS
                             | ChipIOUp_INTEN_INT
                             | ChipIOUp_INTEN_DER
                             | ChipIOUp_INTEN_PER)
                          );


    faSingleThreadedLeave( hpRoot, CStateInitializeFailed );

    if(thread->currentState == CStateInitializeFailed )
    {
        osFCLayerAsyncEvent( hpRoot, osFCLinkDead );
    }

    faSingleThreadedEnter( hpRoot, CStateInitializeFailed );

    pCThread->ChanInfo.CurrentAddress.Domain = 0;
    pCThread->ChanInfo.CurrentAddress.Area   = 0;
    osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, (fiComputeCThread_S_ID(pCThread)));

    fiLogString(hpRoot,
                    "CAIF FM %08X TL %08X FiFMS %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    pCThread->From_IMQ_Frame_Manager_Status,0,0,0,0,0);

    CFuncYellowLed(hpRoot, agFALSE);

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: CActionLoopFailedReInit
   Purpose: Terminate until some external action is taken. All outstanding IOs killed.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncCompleteActiveCDBThreadsOnDevice
-*/
/*  CStateLoopFailedReInit 17 */
extern void CActionLoopFailedReInit( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t      * hpRoot      = thread->hpRoot;
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread;
    fiList_t      * pDevList;

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot (%p) In %s - State = %d",
                    "CALFRI",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FM Status %08X FM Config %08X TL Status %08X TL Control %08X Rec Alpa Reg %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0);

    pDevList = &pCThread->Active_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->Active_DevLink) != pDevList)
    {
        pDevThread = hpObjectBase(DevThread_t,
                              DevLink,pDevList );

        pDevList = pDevList->flink;

        CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset,  CDBEventIODeviceReset );

    }

    if(pCThread->CDBpollingCount)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Ccnt Non Zero Ccnt %x",
                    "CALFRI",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->CDBpollingCount,
                    0,0,0,0,0,0,0);
    }

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot (%p) Out %s - State = %d",
                    "CALFRI",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LOOP_DOWN,
                    CThread_ptr(hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(hpRoot)->ERQ_FROZEN,
                    CThread_ptr(hpRoot)->FCP_FROZEN,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0);
    if( pCThread->LoopPreviousSuccess )
    {
        pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
    }

    fiLogString(hpRoot,
                    "%s FM Stat %08X LPS %x",
                    "CALFRI",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    pCThread->LoopPreviousSuccess,
                    0,0,0,0,0,0);


    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: CActionFindDeviceUseAllALPAs
   Purpose: Find devices using open to all valid ALPAs. Does not login to a device if 
            already has devthread. Bails out if link event. Does DevThreadAlloc until
            stack depth reached then polls to free up resources.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncAll_clear
            CFuncCheckIfPortActive
            DevThreadAlloc
            DevEventLogin
            CFuncCompleteActiveCDBThreadsOnDevice
            DevThreadFree
            CFuncQuietShowWhereDevThreadsAre
            CFuncInterruptPoll

-*/
/* CStateFindDevice       18 */
extern void CActionFindDeviceUseAllALPAs( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t      * hpRoot      = thread->hpRoot;
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread;
    FC_Port_ID_t    Port_ID;
    fiList_t      * pDevList;

    os_bit32         AL_PA_Index=0;

    CFuncYellowLed(hpRoot, agFALSE);
    /* DRL find dev thread*/
    CFuncShowWhereDevThreadsAre( hpRoot);

    fiLogString(hpRoot,
                "IN %s FM %08X TL %08X AC %x ADISC Cnt %d FDcnt %d",
                "CAFDAll",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                CFuncAll_clear( hpRoot ),
                pCThread->ADISC_pollingCount,
                pCThread->FindDEV_pollingCount,
                0,0,0);

    fiLogString(hpRoot,
                "%d IN %s Free %d Active %d Un %d Login %d",
                "CAFDAll",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)thread->currentState,
				fiNumElementsOnList(&pCThread->Free_DevLink),
				fiNumElementsOnList(&pCThread->Active_DevLink),
				fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
				fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                0,0,0 );

    fiLogString(hpRoot,
                "IN %s ADISC %d SS %d PrevA login %d Prev Un %d",
                "CAFDAll",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
				fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
				fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
				fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
				fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink),
                0,0,0,0 );

    fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "hpRoot %p Before %s - State = %d CCnt %x Dev %d FDcnt %x InIMQ %x",
                "CAFDAll",(char *)agNULL,
                thread->hpRoot,(void *)agNULL,
                (os_bit32)thread->currentState,
                pCThread->CDBpollingCount,
                fiNumElementsOnList(&pCThread->Active_DevLink),
                pCThread->FindDEV_pollingCount,
                pCThread->ProcessingIMQ,
                0,0,0);

    if( CFuncAll_clear( hpRoot ) )
    {

        if( fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                       &(pCThread->TimerQ)))
        {   /* If timer is active kill it things should be ok */
            fiTimerStop( &(pCThread->Timer_Request));
        }
        AL_PA_Index = sizeof(Alpa_Index);

        while(AL_PA_Index--)
        {
            if(pCThread->FindDEV_pollingCount > pCThread->NumberOutstandingFindDevice )
            {/* This limits the stack depth */
                fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s pCThread->FindDEV_pollingCount > NumberOutstandingFindDevice %x",
                            "CAFDAll",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->NumberOutstandingFindDevice,
                            0,0,0,0,0,0,0 );


                if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
                {
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                            "CAFDAll",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                            osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                            0,0,0,0);
                }

            }
            if( ! CFuncAll_clear( hpRoot ) )
            {
                  break;
            }

            if( CFuncShowWhereDevThreadsAre( hpRoot))
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s AL_PA_Index %X AL_PA %X FDnt %x",
                            "CFuncShowWhereDevThreadsAre",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            AL_PA_Index,
                            Alpa_Index[AL_PA_Index],
                            pCThread->FindDEV_pollingCount,
                            0,0,0,0,0);

            } /*if( CFuncShowWhereDevThreadsAre( hpRoot)) */

            if(  Alpa_Index[AL_PA_Index] != 0xFF           )
            {
                if( AL_PA_Index == pCThread->ChanInfo.CurrentAddress.AL_PA ||
                    AL_PA_Index == 0                                           )
                {
                    continue;
                }

                Port_ID.Struct_Form.reserved = 0;
                Port_ID.Struct_Form.Domain = 0;
                Port_ID.Struct_Form.Area   = 0;
                Port_ID.Struct_Form.AL_PA = (os_bit8)AL_PA_Index;

            }
            else
            {
                continue;
            }

            if( CFuncCheckIfPortActive( hpRoot,  Port_ID))
            {
                continue;
            }

            if( thread->currentState != CStateFindDevice )
            {
                fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
                return;
            }

            pDevThread = DevThreadAlloc( hpRoot,Port_ID );

            if(pDevThread != (DevThread_t *)agNULL )
            {
                pDevThread->Plogi_Reason_Code = PLOGI_REASON_DEVICE_LOGIN;

                fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);
            }
            else
            {
                fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "In %s - State = %d  CCnt %x FDcnt %x Ran out of DEVTHREADs !!!!!!!",
                        "CAFDAll",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pCThread->CDBpollingCount,
                        pCThread->FindDEV_pollingCount,
                        0,0,0,0,0);

                fiLogString(hpRoot,
                            "%s (DT) Free %d Active %d Un %d Login %d",
                            "CAFDAll",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
				            fiNumElementsOnList(&pCThread->Free_DevLink),
				            fiNumElementsOnList(&pCThread->Active_DevLink),
				            fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
				            fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                            0,0,0,0 );
                fiLogString(hpRoot,
                            "%s (DT) ADISC %d SS %d PrevA login %d Prev Un %d",
                            "CAFDAll",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
				            fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
				            fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
				            fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
				            fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink),
                            0,0,0,0 );

                /* We Must poll now becase threads are awaiting processing */
                if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
                {
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "FDA1 Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Received_ALPA),
                            0,0,0,0);
                }

                if(  fiListNotEmpty(&pCThread->Unknown_Slot_DevLink ) )
                {
                    while(  fiListNotEmpty(&pCThread->Unknown_Slot_DevLink ) )
                    {
                        fiListDequeueFromHeadFast(&pDevList,
                                                  &pCThread->Unknown_Slot_DevLink );
                        pDevThread = hpObjectBase(DevThread_t,
                                                  DevLink,pDevList );

                        if(pDevThread->thread_hdr.currentState == DevStateLoginFailed)
                        {

                            CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset,  CDBEventIODeviceReset );
                            DevThreadFree(hpRoot,pDevThread);
                            CFuncQuietShowWhereDevThreadsAre( hpRoot);
                        }
                        else
                        {
                            fiLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "Unknown_Slot_DevLink Dev %p Alpa %X FDcnt %x",
                                    (char *)agNULL,(char *)agNULL,
                                    pDevThread,(void *)agNULL,
                                    Alpa_Index[AL_PA_Index],
                                    pCThread->FindDEV_pollingCount,
                                    0,0,0,0,0,0);

                            fiListEnqueueAtHead(&pDevList,
                                                &pCThread->Unknown_Slot_DevLink );
                            break;
                        }

                    }
                }

            }/*End DevThreadAlloc fail*/
            pCThread->FuncPtrs.Proccess_IMQ(thread->hpRoot);

            if( thread->currentState != CStateFindDevice )
            {
                fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
                return;
            }

            if(  fiListNotEmpty(&pCThread->Unknown_Slot_DevLink ) )
            {
                if(CFuncShowWhereDevThreadsAre( hpRoot)) CFuncWhatStateAreDevThreads( hpRoot );

                fiListDequeueFromHeadFast(&pDevList,
                                          &pCThread->Unknown_Slot_DevLink );
                
                pDevThread = hpObjectBase(DevThread_t,
                                          DevLink,pDevList );
                if(pDevThread->thread_hdr.currentState == DevStateLoginFailed)
                {
                    CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset,  CDBEventIODeviceReset );
                    DevThreadFree(hpRoot,pDevThread);
                    CFuncQuietShowWhereDevThreadsAre( hpRoot);

                }
                else
                {
                    fiListEnqueueAtHead(&pDevList,
                                        &pCThread->Unknown_Slot_DevLink );

                }
            }

        }/* End while(AL_PA_Index--) */

        if(CFuncShowWhereDevThreadsAre( hpRoot)) CFuncWhatStateAreDevThreads( hpRoot );

        /* We Must poll now becase bad ALPA / FTO will freeze the chip */
        if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FDA2 Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
        }

        if(CFuncShowWhereDevThreadsAre( hpRoot)) CFuncWhatStateAreDevThreads( hpRoot );
        if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))

        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FDA3 Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
            fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "In %s - State = %d   ALPA %X CCnt %x",
                    "CAFDAll",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0xbad,
                    pCThread->CDBpollingCount,0,0,0,0,0);
        }

        if(CFuncShowWhereDevThreadsAre( hpRoot)) CFuncWhatStateAreDevThreads( hpRoot );

        if(  fiListNotEmpty(&pCThread->Unknown_Slot_DevLink ) )
        {
            while(  fiListNotEmpty(&pCThread->Unknown_Slot_DevLink ) )
            {
                if(CFuncShowWhereDevThreadsAre( hpRoot)) CFuncWhatStateAreDevThreads( hpRoot );
                  
                fiListDequeueFromHead(&pDevList,
                                          &pCThread->Unknown_Slot_DevLink );


                pDevThread = hpObjectBase(DevThread_t,
                                          DevLink,pDevList );

                if(pDevThread->thread_hdr.currentState == DevStateLoginFailed)
                {

                    CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset,  CDBEventIODeviceReset );
                    DevThreadFree(hpRoot,pDevThread);
                    CFuncQuietShowWhereDevThreadsAre( hpRoot);

                }
                else
                {
                    fiListEnqueueAtHead(&pDevList,
                                        &pCThread->Unknown_Slot_DevLink );
                    break;
                }
            }
        }

        if(CFuncShowWhereDevThreadsAre( hpRoot)) CFuncWhatStateAreDevThreads( hpRoot );

        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot %p After %s - State = %d CCnt %x EL %d FDcnt %x",
                        "CAFDAll",(char *)agNULL,
                        thread->hpRoot,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pCThread->CDBpollingCount,
                        fiNumElementsOnList(&pCThread->Active_DevLink),
                        pCThread->FindDEV_pollingCount,
                        0,0,0,0);


        pCThread->LoopPreviousSuccess = agTRUE;

        if(CFuncShowWhereDevThreadsAre( hpRoot)) CFuncWhatStateAreDevThreads( hpRoot );

        fiSetEventRecord(eventRecord,thread,CEventDeviceListEmpty);
    }
    else /* Not CFuncAll_clear */
    {
        if( CFuncAll_clear( hpRoot ) )/*Free version gets here reaction !*/
        {
            pCThread->LoopPreviousSuccess = agTRUE;
            /*+ Check This DRL  -*/
            fiSetEventRecord(eventRecord,thread,CEventDeviceListEmpty);
        }
        else
        {
        }
    }

    pCThread->FuncPtrs.Proccess_IMQ(hpRoot);
    /* See if Link event occured */
    if( thread->currentState != CStateFindDevice)
    {
        fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
    }

    if( CThread_ptr(thread->hpRoot)->ReScanForDevices )
    {
            pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
            fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
            fiLogString(hpRoot,
                        "%s %s",
                        "CAFDAll","ReScanForDevices",
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0 );
            CThread_ptr(thread->hpRoot)->ReScanForDevices = agFALSE;

    }

    fiLogString(hpRoot,
                "%d End %s Free %d Active %d Un %d Login %d",
                "CAFDAll",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)thread->currentState,
				fiNumElementsOnList(&pCThread->Free_DevLink),
				fiNumElementsOnList(&pCThread->Active_DevLink),
				fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
				fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                0,0,0 );
    fiLogString(hpRoot,
                "End %s ADISC %d SS %d PrevA login %d Prev Un %d",
                "CAFDAll",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
				fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
				fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
				fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
				fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink),
                0,0,0,0 );

    

}

/*+
  Function: CActionFindDeviceUseLoopMap
   Purpose: Find devices using open to all ALPAs in loopmap. Does not login to a device if 
            already has devthread. Bails out if link event. Does DevThreadAlloc until
            stack depth reached then polls to free up resources. Logins into devices in ALPA
            order not LOOPMAP order.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncAll_clear
            CFuncCheckIfPortActive
            DevThreadAlloc
            DevEventLogin
            CFuncCompleteActiveCDBThreadsOnDevice
            DevThreadFree
            CFuncQuietShowWhereDevThreadsAre
            CFuncInterruptPoll
-*/
/* CStateFindDeviceUseLoopMap         37 */
extern void CActionFindDeviceUseLoopMap( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t      * hpRoot      = thread->hpRoot;
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t * AL_PA_Position_Map        = (FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t *)(CThread_ptr(hpRoot)->Calculation.MemoryLayout.LOOPDeviceMAP.addr.CachedMemory.cachedMemoryPtr);
    DevThread_t   * pDevThread = (DevThread_t *)agNULL;
    FC_Port_ID_t    Port_ID;
    os_bit32        AL_PA_Index   = sizeof(Alpa_Index);
    os_bit32        IndexIntoLoopMap = 0;
/*  os_bit8         LoopMap_Index =0;*/
    agBOOLEAN Found = agFALSE;

    CFuncYellowLed(hpRoot, agFALSE);

    fiLogString(hpRoot,
                    "%p %s State %d InIMQ %x",
                    "CAFDLM",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->ProcessingIMQ,
                    0,0,0,0,0,0);


    if(thread->currentState == CStateFindDeviceUseLoopMap  )
    {
        while(AL_PA_Index--)
        {
            if( CFuncAll_clear( hpRoot ) )
            {
                if(pCThread->FindDEV_pollingCount > pCThread->NumberOutstandingFindDevice )
                {/* This limits the stack depth */
                    fiLogDebugString(hpRoot,
                                FCMainLogErrorLevel,
                                "%s pCThread->FindDEV_pollingCount > NumberOutstandingFindDevice %x",
                                "CAFDLM",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCThread->NumberOutstandingFindDevice,
                                0,0,0,0,0,0,0 );


                    if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
                    {
                        fiLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "FDA Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                                0,0,0,0);
                    }
                }

                if(  Alpa_Index[AL_PA_Index] != 0xFF )
                {
                    if( AL_PA_Index == pCThread->ChanInfo.CurrentAddress.AL_PA ||
                        AL_PA_Index == 0                                           )
                    {
                        continue;
                    }

                    Port_ID.Struct_Form.reserved = 0;
                    Port_ID.Struct_Form.Domain = 0;
                    Port_ID.Struct_Form.Area   = 0;
                    Port_ID.Struct_Form.AL_PA = (os_bit8)AL_PA_Index;

                }
                else /* Invalid Alpa_Index[AL_PA_Index] */
                {
                    continue;
                }

                if( CFuncCheckIfPortActive( hpRoot,  Port_ID))
                {
                    continue;
                }
                for(IndexIntoLoopMap  =0; IndexIntoLoopMap < AL_PA_Position_Map->AL_PA_Index; IndexIntoLoopMap ++)
                {
                    pDevThread = NULL;
                    Found = agFALSE;
                    if( Port_ID.Struct_Form.AL_PA == AL_PA_Position_Map->AL_PA_Slot[IndexIntoLoopMap])
                    {
                        Found = agTRUE;
                        pDevThread = DevThreadAlloc( hpRoot,Port_ID );
                        break;
                    }
                    else /* AL_PA not in loopmap */
                    {
                        continue;
                    }
                }

                if(pDevThread != (DevThread_t *)agNULL)
                {
                    pDevThread->Plogi_Reason_Code = PLOGI_REASON_DEVICE_LOGIN;
                    fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);
                }
                else
                {
                    if( Found )
                    {
                        fiLogDebugString(thread->hpRoot,
                                CStateLogConsoleERROR,
                                "In %s - State = %d  CCnt %x Ran out of DEVTHREADs !!!!!!!",
                                "CAFDLM",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                (os_bit32)thread->currentState,
                                pCThread->CDBpollingCount,0,0,0,0,0,0);
                    }
                }
            }
            else/* Not CFuncAll_clear */
            {
                fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
                break;
            }
        }/* AL_PA_Index */
    }
    else /*  currentState Not CStateFindDeviceUseLoopMap */
    {
        fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
        return;
    }


    
    /* we know ALPA is there Poll after all are sent  */
    /* Some will be done by time we get there         */

    if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "FDL Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "In %s - State = %d  FDcnt %x",
                "CAFDLM",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)thread->currentState,
                pCThread->FindDEV_pollingCount,0,0,0,0,0,0);
    }
    if( CFuncAll_clear( hpRoot ) )
    {
        fiLogString(hpRoot,
                        "%p %s State %d InIMQ %x EL %d LM %d",
                        "CAFDLM",(char *)agNULL,
                        thread->hpRoot,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pCThread->ProcessingIMQ,
                        fiNumElementsOnList(&pCThread->Active_DevLink),
                        CFuncLoopMapRecieved(hpRoot,agTRUE),
                        0,0,0,0);

        pCThread->LoopPreviousSuccess = agTRUE;
        fiSetEventRecord(eventRecord,&pCThread->thread_hdr,CEventDeviceListEmpty);
    }
    else
    {
        fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
    }

}

/*+
  Function: CActionFindPtToPtDevice
   Purpose: Attempts to login to device 0. We have not had a point to point device available.
            Doubtful this works.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncAll_clear
            CFuncCheckIfPortActive
            DevThreadAlloc
            DevEventLogin
            CFuncInterruptPoll
            CEventDeviceListEmpty
-*/
/* CStateFindPtToPtDevice      42 */
extern void CActionFindPtToPtDevice (fi_thread__t *thread, eventRecord_t *eventRecord)
{
    agRoot_t      * hpRoot      = thread->hpRoot;
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread;
    FC_Port_ID_t    Port_ID;

    CFuncYellowLed(hpRoot, agFALSE);

    Port_ID.Struct_Form.reserved = 0;
    Port_ID.Struct_Form.Domain = 0;
    Port_ID.Struct_Form.Area   = 0;
    Port_ID.Struct_Form.AL_PA  = 0;

    pDevThread = DevThreadAlloc( hpRoot,Port_ID );

    if(pDevThread != (DevThread_t *)agNULL )
    {
        pDevThread->Plogi_Reason_Code = PLOGI_REASON_DEVICE_LOGIN;

        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);
    }
    else
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "In %s - State = %d  FDCnt %x Ran out of DEVTHREADs !!!!!!!",
                "CAFDPT",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)thread->currentState,
                pCThread->FindDEV_pollingCount,0,0,0,0,0,0);

    }

    if(CFuncInterruptPoll( hpRoot, &pCThread->FindDEV_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "FDP Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status),
                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                0,0,0,0);
        fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "In %s - State = %d FDCnt %x",
                "CAFDPT",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)thread->currentState,
                pCThread->FindDEV_pollingCount,0,0,0,0,0,0);
    }
    pCThread->LoopPreviousSuccess = agTRUE;
    fiSetEventRecord(eventRecord,&pCThread->thread_hdr,CEventDeviceListEmpty);

}

/*+
  Function: CActionFindDeviceUseNameServer
   Purpose: Uses name server information to login to devices.  Does not login to a device if 
            already has devthread. Bails out if link event. Does DevThreadAlloc until
            stack depth reached then polls to free up resources. Removes device if no longer
            in the name server.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncAll_clear
            CFuncCheckIfPortActive
            DevThreadAlloc
            DevEventLogin
            CFuncCompleteActiveCDBThreadsOnDevice
            DevThreadFree
            CFuncQuietShowWhereDevThreadsAre
            CFuncInterruptPoll

 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncAll_clear
            CFuncCheckIfPortActive
            DevThreadAlloc
            DevEventLogin
            CFuncInterruptPoll
            CEventDeviceListEmpty
-*/
/* CStateFindDeviceUseNameServer      36 */
extern void CActionFindDeviceUseNameServer( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t      * hpRoot      = thread->hpRoot;
    CThread_t     * pCThread    = CThread_ptr(hpRoot);
    DevThread_t   * pDevThread;
    FC_Port_ID_t    Port_ID;
    os_bit8         AL_PA_Index=0;
    fiList_t      * pDevList;

    FC_NS_DU_GID_PT_FS_ACC_Payload_t * RegisteredEntries  = (FC_NS_DU_GID_PT_FS_ACC_Payload_t *)(CThread_ptr(hpRoot)->Calculation.MemoryLayout.FabricDeviceMAP.addr.CachedMemory.cachedMemoryPtr);

    CFuncYellowLed(hpRoot, agFALSE);

    if(!(pCThread->DeviceDiscoveryMethod == DDiscoveryQueriedNameService ))
    {
        if(pCThread->InitAsNport)
        {  
            fiSetEventRecord(eventRecord,&pCThread->thread_hdr,CEventGoToInitializeFailed);
            return;
        }
        else
        {
            if(pCThread->LoopMapLIRP_Received )
            {
                fiSetEventRecord(eventRecord,&pCThread->thread_hdr,CEventFindDeviceUseLoopMap);
                return;
            }
            else
            {
                fiSetEventRecord(eventRecord,&pCThread->thread_hdr,CEventInitalizeSuccess);
                return;
            }
        }
    }

    if( fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                   &(pCThread->TimerQ)))
    {   /* If timer is active kill it things should be ok */
        fiTimerStop( &(pCThread->Timer_Request));
    }


    if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "CA_UNS Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                0,0,0,0);
    }

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p In %s - State = %d InIMQ %x FDCnt %d",
                    "CA_UNS",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->ProcessingIMQ,
                    pCThread->FindDEV_pollingCount,
                    0,0,0,0,0);

    fiLogString(thread->hpRoot,
                "In %s Fpc %x inIMQ %x AC %x",
                "CA_UNS",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->FLOGI_pollingCount,
                pCThread->ProcessingIMQ,
                CFuncAll_clear( thread->hpRoot ),
                0,0,0,0,0);

    fiLogString(hpRoot,
                "%d %s Free %d Active %d Un %d Login %d",
                "CA_UNS",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)thread->currentState,
			    fiNumElementsOnList(&pCThread->Free_DevLink),
			    fiNumElementsOnList(&pCThread->Active_DevLink),
			    fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
			    fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                0,0,0 );
    fiLogString(hpRoot,
                "   %s ADISC %d SS %d PrevA login %d Prev Un %d",
                "CA_UNS",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
			    fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
			    fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
			    fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
			    fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink),
                0,0,0,0 );

    if(pCThread->Loop_Reset_Event_to_Send == CEventDoInitalize )
    {
        pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
    }


/*
    CFuncShowWhereDevThreadsAre( hpRoot );
*/
    if(  fiListNotEmpty(&pCThread->Unknown_Slot_DevLink ) )
    {
        while(  fiListNotEmpty(&pCThread->Unknown_Slot_DevLink ) )
        {
            fiListDequeueFromHeadFast(&pDevList,
                                  &pCThread->Unknown_Slot_DevLink );

            pDevThread = hpObjectBase(DevThread_t,
                                      DevLink, pDevList);

            if(pDevThread->thread_hdr.currentState == DevStateLoginFailed)
            {
                CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset,  CDBEventIODeviceReset );
                DevThreadFree(hpRoot,pDevThread);
                CFuncQuietShowWhereDevThreadsAre( hpRoot);

            }
            else
            {
                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "Unknown_Slot_DevLink Dev %p Alpa %X FDcnt %x",
                        (char *)agNULL,(char *)agNULL,
                        pDevThread,(void *)agNULL,
                        Alpa_Index[AL_PA_Index],
                        pCThread->FindDEV_pollingCount,
                        0,0,0,0,0,0);

                fiListEnqueueAtHead(&pDevList,
                                    &pCThread->Unknown_Slot_DevLink );
                break;
            }
        }
    }
/*
            CFuncShowWhereDevThreadsAre( hpRoot, agTRUE );
*/

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Before SCAN %s - State = %d InIMQ %x",
                    "CA_UNS",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->ProcessingIMQ,
                    0,0,0,0,0,0);

    if(  fiListNotEmpty(&pCThread->Active_DevLink ) )
    {
        fiListEnqueueListAtTailFast(&pCThread->Active_DevLink,&pCThread->Prev_Active_DevLink);
    }

    if(thread->currentState ==  CStateFindDeviceUseNameServer )
    {
       do
        {
            if ( (RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[0] == pCThread->ChanInfo.CurrentAddress.Domain) &&
                 (RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[1] == pCThread->ChanInfo.CurrentAddress.Area) &&
                 (RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[2] == pCThread->ChanInfo.CurrentAddress.AL_PA) )
            {
                AL_PA_Index++;
                continue;
            }

            if(pCThread->FindDEV_pollingCount > pCThread->NumberOutstandingFindDevice )
            {/* This limits the stack depth */
                fiLogDebugString(hpRoot,
                            FCMainLogErrorLevel,
                            "%s pCThread->FindDEV_pollingCount > NumberOutstandingFindDevice %x",
                            "CA_UNS",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->NumberOutstandingFindDevice,
                            0,0,0,0,0,0,0 );


                if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
                {
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "CA_UNS Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                            osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                            0,0,0,0);
                }

            }
            Port_ID.Struct_Form.reserved = 0;
            Port_ID.Struct_Form.Domain = RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[0];
            Port_ID.Struct_Form.Area   = RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[1];
            Port_ID.Struct_Form.AL_PA  = RegisteredEntries->Control_Port_ID[AL_PA_Index].Port_ID[2];

            /* This port_id is on name server and is on prev active list put it on active */
            if( CFuncCheckIfPortPrev_Active( hpRoot,  Port_ID))
            {

                pDevThread = CFuncMatchALPAtoThread( hpRoot, Port_ID);
                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "CA_UNS (%p)Port_ID %X found in database",
                        (char *)agNULL,(char *)agNULL,
                        pDevThread,(void *)agNULL,
                        Port_ID.Bit32_Form,
                        0,0,0,0,0,0,0);


                if(fiListElementOnList(&pDevThread->DevLink,&pCThread->Prev_Active_DevLink ))
                {
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "CA_UNS (%p)Port_ID %X put on active list",
                            (char *)agNULL,(char *)agNULL,
                            pDevThread,(void *)agNULL,
                            Port_ID.Bit32_Form,
                            0,0,0,0,0,0,0);

                    fiListDequeueThis(&pDevThread->DevLink );
                    fiListEnqueueAtTail(&pDevThread->DevLink,&pCThread->Active_DevLink );
                    AL_PA_Index++;
                    continue;
                }
                else
                {
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "CA_UNS (%p)Port_ID %X  NOT FOUND !",
                            (char *)agNULL,(char *)agNULL,
                            pDevThread,(void *)agNULL,
                            Port_ID.Bit32_Form,
                            0,0,0,0,0,0,0);


                }

            }

            pDevThread = DevThreadAlloc( hpRoot,Port_ID );

            if(pDevThread != (DevThread_t *)agNULL )
            {
                pDevThread->Plogi_Reason_Code = PLOGI_REASON_DEVICE_LOGIN;

                fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);
            }
            else
            {
                fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "In %s - State = %d  FDCnt %x Ran out of DEVTHREADs !!!!!!!",
                        "CA_UNS",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pCThread->FindDEV_pollingCount,0,0,0,0,0,0);

                if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
                {
                    fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Find Dev CA_UNS Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                            osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                            0,0,0,0);
                }

            }

            /* we know ALPA is there Poll after all are sent  */
            /* Some will be done by time we get there         */
            if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
            {
                fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "CA_UNS Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status),
                        osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                        0,0,0,0);
                fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "In %s - State = %d  CDBCnt %x FDCnt %x",
                        "CA_UNS",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pCThread->CDBpollingCount,
                        pCThread->FindDEV_pollingCount,0,0,0,0,0);
            }
            AL_PA_Index++;

        } while (RegisteredEntries->Control_Port_ID[AL_PA_Index - 1].Control != FC_NS_Control_Port_ID_Control_Last_Port_ID);

        fiLogString(hpRoot,
                    "%d %s Free %d Active %d Un %d Login %d",
                    "1 CA_UNS",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
			        fiNumElementsOnList(&pCThread->Free_DevLink),
			        fiNumElementsOnList(&pCThread->Active_DevLink),
			        fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
			        fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                    0,0,0 );
        fiLogString(hpRoot,
                    "   %s ADISC %d SS %d PrevA login %d Prev Un %d",
                    "1 CA_UNS",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
			        fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
			        fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
			        fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
			        fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink),
                    0,0,0,0 );

        if(  fiListNotEmpty(&pCThread->Prev_Active_DevLink ) )
        {
            while(  fiListNotEmpty(&pCThread->Prev_Active_DevLink ) )
            {
                fiListDequeueFromHeadFast(&pDevList,
                                      &pCThread->Prev_Active_DevLink );

                pDevThread = hpObjectBase(DevThread_t,
                                          DevLink, pDevList);

                fiSendEvent(&pDevThread->thread_hdr,DevEvent_Device_Gone);

            }
        }

        fiLogString(hpRoot,
                    "%d %s Free %d Active %d Un %d Login %d",
                    "2 CA_UNS",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
			        fiNumElementsOnList(&pCThread->Free_DevLink),
			        fiNumElementsOnList(&pCThread->Active_DevLink),
			        fiNumElementsOnList(&pCThread->Unknown_Slot_DevLink),
			        fiNumElementsOnList(&pCThread->AWaiting_Login_DevLink),
                    0,0,0 );
        fiLogString(hpRoot,
                    "   %s ADISC %d SS %d PrevA login %d Prev Un %d",
                    "2 CA_UNS",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
			        fiNumElementsOnList(&pCThread->AWaiting_ADISC_DevLink),
			        fiNumElementsOnList(&pCThread->Slot_Searching_DevLink),
			        fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
			        fiNumElementsOnList(&pCThread->Prev_Unknown_Slot_DevLink),
                    0,0,0,0 );

        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot %p After SCAN %s - State = %d InIMQ %x",
                        "CA_UNS",(char *)agNULL,
                        thread->hpRoot,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pCThread->ProcessingIMQ,
                        0,0,0,0,0,0);


        if(CFuncInterruptPoll( hpRoot,&pCThread->FindDEV_pollingCount ))
        {

            fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "In %s - State = %d  CDBCnt %x",
                    "CA_UNS",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->CDBpollingCount,
                    0,0,0,0,0,0);

            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FDNS Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
        }

        pCThread->LoopPreviousSuccess = agTRUE;
        if( fiNumElementsOnList(&pCThread->Active_DevLink) == 0 )
        {

            fiLogString(thread->hpRoot,
                            "CA_UNS - Empty Fadb %d Cfm %d",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            (os_bit32)pCThread->FoundActiveDevicesBefore,
                            CFuncCheckFabricMap(thread->hpRoot,agFALSE),0,0,0,0,0,0);
            if(pCThread->FoundActiveDevicesBefore)
            {
                pCThread->FoundActiveDevicesBefore = agFALSE; /*So we don't do this forever... */
                fiSetEventRecord(eventRecord,&pCThread->thread_hdr,CEventLoopEventDetected);
                return;
            }
        }
        else
        {
            if( fiNumElementsOnList(&pCThread->Active_DevLink) != CFuncCheckFabricMap( thread->hpRoot,agTRUE) )
            {
                fiLogString(thread->hpRoot,
                                "CA_UNS - EL %d != CFM %d",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                fiNumElementsOnList(&pCThread->Active_DevLink),
                                CFuncCheckFabricMap( thread->hpRoot,agFALSE),
                                0,0,0,0,0,0);
            }
            if( CFuncCountFC4_Devices(thread->hpRoot) == 0)
            {
                fiLogString(thread->hpRoot,
                            "Just nonFC4 Devices %d Fadb %d",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            fiNumElementsOnList(&pCThread->Active_DevLink),
                            (os_bit32)pCThread->FoundActiveDevicesBefore,
                            0,0,0,0,0,0);
                if( CThread_ptr(thread->hpRoot)->ReScanForDevices )
                {
                        pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
                        fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
                        fiLogString(hpRoot,
                                    "%s %s",
                                    "CA_UNS","ReScanForDevices",
                                    (void *)agNULL,(void *)agNULL,
                                    0,0,0,0,0,0,0,0 );
                        CThread_ptr(thread->hpRoot)->ReScanForDevices = agFALSE;
                        return;
                }
                if(pCThread->FoundActiveDevicesBefore)
                {
                    pCThread->FoundActiveDevicesBefore = agFALSE; /*So we don't do this forever... */

                    fiSetEventRecord(eventRecord,&pCThread->thread_hdr,CEventLoopEventDetected);
                    return;
                }
            }
            else
            {
                if( CThread_ptr(thread->hpRoot)->ReScanForDevices )
                {
                        pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
                        fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
                        fiLogString(hpRoot,
                                    "%s %s",
                                    "CA_UNS","ReScanForDevices",
                                    (void *)agNULL,(void *)agNULL,
                                    0,0,0,0,0,0,0,0 );
                        CThread_ptr(thread->hpRoot)->ReScanForDevices = agFALSE;
                        return;
                }
            }
        }

        fiLogString(thread->hpRoot,
                    "Out %s FDpc %x inIMQ %x AC %x",
                    "CA_UNS",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->FindDEV_pollingCount,
                    pCThread->ProcessingIMQ,
                    CFuncAll_clear( thread->hpRoot ),
                    0,0,0,0,0);

        fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "In %s - State = %d  CCnt %x FC4 Devices %d ReScanForDevices %d",
                        "CA_UNS",(char *)NULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        pCThread->FindDEV_pollingCount,
                        CFuncCountFC4_Devices(thread->hpRoot),
                        CThread_ptr(thread->hpRoot)->ReScanForDevices,
                        0,0,0,0);
 
        if( CFuncCountFC4_Devices(thread->hpRoot) != 0)
        {
            pCThread->FoundActiveDevicesBefore = agTRUE;
        }
        fiSetEventRecord(eventRecord,&pCThread->thread_hdr,CEventDeviceListEmpty);
    }
    else /* if(thread->currentState !=  CStateFindDeviceUseNameServer ) */
    {
           fiLogString(thread->hpRoot,
                    "Out %s State Change FDpc %x inIMQ %x AC %x CState %d",
                    "CA_UNS",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->FindDEV_pollingCount,
                    pCThread->ProcessingIMQ,
                    CFuncAll_clear( thread->hpRoot ),
                    thread->currentState,
                    0,0,0,0);
        if(pCThread->Loop_Reset_Event_to_Send == CEventDoInitalize )
        {
            pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
        }

        fiSetEventRecord(eventRecord,thread,CEventLoopEventDetected);
    }

    if(pCThread->Loop_Reset_Event_to_Send == CEventDoInitalize )
    {
        pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
    }
    /* Clean up list after completion */
    while(fiListNotEmpty(&pCThread->Prev_Unknown_Slot_DevLink ))
    {
        fiListDequeueFromHeadFast(&pDevList,
                                  &pCThread->Prev_Unknown_Slot_DevLink );
        pDevThread = hpObjectBase(DevThread_t,
                                  DevLink,pDevList );

        DevThreadFree( hpRoot, pDevThread );
    }

    fiLogString(thread->hpRoot,
                "Bottom %s FDpc %x inIMQ %x AC %x CState %d LRES %d",
                "CA_UNS",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->FindDEV_pollingCount,
                pCThread->ProcessingIMQ,
                CFuncAll_clear( thread->hpRoot ),
                thread->currentState,
                pCThread->Loop_Reset_Event_to_Send,
                0,0,0);


}

/*+
  Function: CActionElasticStoreEventStorm
   Purpose: If timer running ignore everything, reinitialize channel after timeout period.
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncCompleteAllActiveCDBThreads
            CFuncDisable_Interrupts
            fiTimerStart
            CEventDoInitalize
-*/
/* CStateElasticStoreEventStorm           19 */
extern void CActionElasticStoreEventStorm( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    CThread_t       * pCThread = CThread_ptr(thread->hpRoot);

    CFuncYellowLed(thread->hpRoot, agFALSE);

    faSingleThreadedLeave( thread->hpRoot, CStateElasticStoreEventStorm );

    osFCLayerAsyncEvent( thread->hpRoot, osFCLinkDown );

    faSingleThreadedEnter( thread->hpRoot, CStateElasticStoreEventStorm);

    CFuncCompleteAllActiveCDBThreads( thread->hpRoot,osIOAborted,CDBEventIODeviceReset );

    CFuncDisable_Interrupts(thread->hpRoot,ChipIOUp_INTEN_MASK);

    fiLogString(thread->hpRoot,
                    "%s",
                    "CActionElasticStoreEventStorm",(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Out %s",
                    "CActionElasticStoreEventStorm",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    if( pCThread->TimerTickActive )
    {
        if(! fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                       &(pCThread->TimerQ)))
        {
            if (!(pCThread->InitAsNport))
                fiTimerSetDeadlineFromNow(thread->hpRoot, &pCThread->Timer_Request, CLipStormQueisingTOV);
            else
                fiTimerSetDeadlineFromNow(thread->hpRoot, &pCThread->Timer_Request, CReinitNportAfterFailureDetectionTOV);

            pCThread->Timer_Request.eventRecord_to_send.thread= thread;

            pCThread->Timer_Request.eventRecord_to_send.event = CEventDoInitalize;

            fiTimerStart(thread->hpRoot,&pCThread->Timer_Request);

        }

        fiSetEventRecordNull(eventRecord);
    }
    else
    {
        fiSetEventRecord(eventRecord,thread,CEventDoInitalize);
    }

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: CActionLIPEventStorm
   Purpose: If timer running ignore everything, reinitialize channel after timeout period.
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncCompleteAllActiveCDBThreads
            CFuncDisable_Interrupts
            fiTimerStart
            CEventDoInitalize
-*/
/* CStateLIPEventStorm          20 */
extern void CActionLIPEventStorm( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    CThread_t       * pCThread = CThread_ptr(thread->hpRoot);

    CFuncYellowLed(thread->hpRoot, agFALSE);
    CFuncDisable_Interrupts(thread->hpRoot,ChipIOUp_INTEN_MASK);

    fiLogString(thread->hpRoot,
                    "%s",
                    "CActionLIPEventStorm",(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p In %s",
                    "CActionLIPEventStorm",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

        /* Code to start a timer to reinit the card after 10 seconds... */
    faSingleThreadedLeave( thread->hpRoot, CStateLIPEventStorm );

    osFCLayerAsyncEvent( thread->hpRoot, osFCLinkDown );

    faSingleThreadedEnter( thread->hpRoot, CStateLIPEventStorm);

    CFuncCompleteAllActiveCDBThreads( thread->hpRoot,osIOAborted,CDBEventIODeviceReset );

    if( pCThread->TimerTickActive )
    {
        if(! fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                       &(pCThread->TimerQ)))
        {
            fiTimerSetDeadlineFromNow(thread->hpRoot, &pCThread->Timer_Request, CLipStormQueisingTOV);

            pCThread->Timer_Request.eventRecord_to_send.thread= thread;
            pCThread->Timer_Request.eventRecord_to_send.event = CEventDoInitalize;

            fiTimerStart(thread->hpRoot,&pCThread->Timer_Request);

        }

        fiSetEventRecordNull(eventRecord);
    }
    else
    {
        fiSetEventRecord(eventRecord,thread,CEventDoInitalize);
    }
}

/*+
  Function: CActionExternalLogout
   Purpose: Old code for LOGO recovery, no longer implemented this way.
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncCompleteAllActiveCDBThreads
-*/
/* CStateExternalLogout          22 */
extern void CActionExternalLogout( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    CThread_t       * pCThread = CThread_ptr(thread->hpRoot);

    DevThread_t     * pDevThread;
    fiList_t        * pDevList;

    /*+ Check This DRL  -*/
    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogString(thread->hpRoot,
                    "%s",
                    "CActionExternalLogout",(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p In %s - State = %d Prev_Unknown_Slot_DevLink %x EL %d",
                    "CActionExternalLogout",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiListNotEmpty(&pCThread->Prev_Unknown_Slot_DevLink),
                    fiNumElementsOnList(&pCThread->Active_DevLink),
                    0,0,0,0,0);

    faSingleThreadedLeave( thread->hpRoot, CStateExternalLogout );

    osFCLayerAsyncEvent( thread->hpRoot, osFCLinkDown );

    faSingleThreadedEnter( thread->hpRoot, CStateExternalLogout);


    pDevList = &pCThread->Active_DevLink;
    pDevList = pDevList->flink;

    while((&pCThread->Active_DevLink) != pDevList)
    {
        pDevThread = (DevThread_t *)hpObjectBase(DevThread_t, DevLink,pDevList );

       if( pDevThread->DevInfo.LoggedIn == agFALSE )
        {
/* */
            fiLogDebugString(thread->hpRoot,
                        CStateLogConsoleERROR,
                        "%s Completing Active IO's Device %X CDBcnt %x",
                        "CActionExternalLogout",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fiComputeDevThread_D_ID(pDevThread),
                        pCThread->CDBpollingCount,
                        0,0,0,0,0,0);
            CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset,  CDBEventIODeviceReset );
        }
        pDevList = pDevList->flink;
    }

    if(pCThread->CDBpollingCount)
    {
        fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "%s Ccnt Non Zero CDBcnt %x",
                    "CActionExternalLogout",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->CDBpollingCount,
                    0,0,0,0,0,0,0);
    }

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Out %s - State = %d Prev_Unknown_Slot_DevLink %x EL %d",
                    "CActionExternalLogout",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiListNotEmpty(&pCThread->Prev_Unknown_Slot_DevLink),
                    fiNumElementsOnList(&pCThread->Active_DevLink),
                    0,0,0,0,0);
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->LOOP_DOWN,
                    pCThread->IDLE_RECEIVED,
                    pCThread->OUTBOUND_RECEIVED,
                    pCThread->ERQ_FROZEN,
                    pCThread->FCP_FROZEN,
                    pCThread->ProcessingIMQ,
                    0,0);

    pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;

    fiSetEventRecordNull(eventRecord);

}


/*+
  Function: CActionExternalLogoutRecovery
   Purpose: Old code for LOGO recovery, no longer implemented this way.
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncInterruptPoll
            CFuncCompleteAllActiveCDBThreads
-*/
/* CStateExternalLogout          23 */
extern void CActionExternalLogoutRecovery( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t      * hpRoot      = thread->hpRoot;

    CThread_t       * pCThread = CThread_ptr(thread->hpRoot);

    DevThread_t     * pDevThread;
    fiList_t        * pList;

    fiLogString(hpRoot,
                    "%s",
                    "CActionExternalLogoutRecovery",(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    CFuncYellowLed(thread->hpRoot, agFALSE);
/*+ Check This DRL  -*/
    if(pCThread->ProcessingIMQ)
    {
        pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;

        fiSetEventRecord(eventRecord,thread,CEventResetIfNeeded);
        return;
    }

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p In %s - State = %d Prev_Unknown_Slot_DevLink %x EL %d",
                    "CActionExternalLogoutRecovery",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiListNotEmpty(&pCThread->Prev_Unknown_Slot_DevLink),
                    fiNumElementsOnList(&pCThread->Active_DevLink),
                    0,0,0,0,0);
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->LOOP_DOWN,
                    pCThread->IDLE_RECEIVED,
                    pCThread->OUTBOUND_RECEIVED,
                    pCThread->ERQ_FROZEN,
                    pCThread->FCP_FROZEN,
                    pCThread->ProcessingIMQ,
                    0,0);

    pList = &pCThread->Active_DevLink;
    pList = pList->flink;

    while((&pCThread->Active_DevLink) != pList)
    {
        pDevThread = (DevThread_t *)hpObjectBase(DevThread_t, DevLink,pList );

        if( pDevThread->DevInfo.LoggedIn == agFALSE )
        {
           fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);
        }

        if(CFuncInterruptPoll( hpRoot,&pDevThread->pollingCount ))
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "EXLO Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
            fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "In %s - State = %d   ALPA %X CDBCnt %x",
                    "CActionExternalLogoutRecovery",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCThread->CDBpollingCount,0,0,0,0,0);
        }

        pList = pList->flink;
    }
    if(pCThread->CDBpollingCount)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Ccnt Non Zero Ccnt %x",
                    "CActionExternalLogoutRecovery",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->CDBpollingCount,
                    0,0,0,0,0,0,0);
/*
        CFuncCompleteAllActiveCDBThreads( thread->hpRoot,osIOAborted,CDBEventIODeviceReset );
*/

    }

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Out %s - State = %d Prev_Unknown_Slot_DevLink %x EL %d",
                    "CActionExternalLogoutRecovery",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiListNotEmpty(&pCThread->Prev_Unknown_Slot_DevLink),
                    fiNumElementsOnList(&pCThread->Active_DevLink),
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,CEventDeviceListEmpty);

}

/*+
  Function: CActionExternalDeviceReset
   Purpose: If we get an task management function reset other devices have as well
            High likelyhood of IO timeouts.
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
-*/
/* CStateExternalDeviceReset          21 */
extern void CActionExternalDeviceReset( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    CFuncYellowLed(thread->hpRoot, agFALSE);
/*+ Check This DRL  Mark ADLE -*/
    fiLogString(thread->hpRoot,
                    "%s",
                    "CActionExternalDeviceReset",(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    faSingleThreadedLeave( thread->hpRoot, CStateExternalDeviceReset );

    osFCLayerAsyncEvent( thread->hpRoot, osFCLinkDown );

    faSingleThreadedEnter( thread->hpRoot, CStateExternalDeviceReset);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Out %s",
                    "CActionDoExternalDeviceReset",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: CActionDoExternalDeviceReset
   Purpose: This is the recovery action to CActionExternalDeviceReset
            Returns to CActionNormal on completion
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncCompleteAllActiveCDBThreads
            CFuncFreezeQueuesPoll
            CFunc_Always_Enable_Queues
            DevEventExternalDeviceReset
            CFuncInterruptPoll
            CEventDeviceListEmpty
-*/
/* CStateDoExternalDeviceReset          24 */
extern void CActionDoExternalDeviceReset( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t   *    hpRoot          = thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    DevThread_t   * pDevThread;
    fiList_t      * pList;

    fiLogString(hpRoot,
                    "%s",
                    "CActionDoExternalDeviceReset",(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

/*+ Check This DRL  -*/
    CFuncYellowLed(hpRoot, agFALSE);

    faSingleThreadedLeave( thread->hpRoot , CStateDoExternalDeviceReset  );

    osFCLayerAsyncEvent( thread->hpRoot, osFCLinkDown );

    faSingleThreadedEnter( thread->hpRoot, CStateDoExternalDeviceReset );

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p In %s",
                    "CActionExternalDeviceReset",(char *)agNULL,
                    hpRoot,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    CFuncFreezeQueuesPoll(hpRoot);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "LD %x IR %x OR %x ERQ %x FCP %x Queues %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->LOOP_DOWN,
                    pCThread->IDLE_RECEIVED,
                    pCThread->OUTBOUND_RECEIVED,
                    pCThread->ERQ_FROZEN,
                    pCThread->FCP_FROZEN,
                    CFunc_Queues_Frozen( hpRoot ),
                    0,0);

    if ( CFunc_Always_Enable_Queues(hpRoot ) )
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p)EXT Loop Fail Queues Frozen after Enable",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
    }



    pList = &pCThread->Active_DevLink;
    pList = pList->flink;

    while((&pCThread->Active_DevLink) != pList)
    {
        pDevThread = (DevThread_t *)hpObjectBase(DevThread_t, DevLink,pList );
        pList = pList->flink;

        if( pDevThread->DevInfo.DeviceType & agDevSCSITarget)
        {

           fiSendEvent(&pDevThread->thread_hdr,DevEventExternalDeviceReset);

        }
    }

    if(CFuncInterruptPoll( hpRoot,&pCThread->DEVReset_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "EDR Find Dev Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
/*
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "In %s - State = %d   ALPA %X CCnt %x DCnt %x",
                    "CActionExternalDeviceReset",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCThread->CDBpollingCount,
                    pDevThread->pollingCount,
                    0,0,0,0);
*/
    }

    fiSetEventRecord(eventRecord,thread,CEventDeviceListEmpty);
}

/*+
  Function: CActionSendPrimitive
   Purpose: This action used to send a primitive sequence does not any longer
            Just brings the Loop down.
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncTakeOffline
            CEventResetDetected
            CEventDoInitalize
-*/
/*  CStateSendPrimitive  25 */
extern void CActionSendPrimitive( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t  *hpRoot  = thread->hpRoot;
    CThread_t  *    pCThread        = CThread_ptr(hpRoot);

    fiLogString(hpRoot,
                    "%s",
                    "CActionSendPrimitive",(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    CFuncYellowLed(hpRoot, agFALSE);
/*+ Check This DRL  -*/
    if (!(pCThread->InitAsNport))
    {
        CFuncTakeOffline(thread->hpRoot);
    }



    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) In %s - State = %d SendPrimativeSuccess %x",
                    "CActionSendPrimitive",(char *)agNULL,
                    hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pCThread->PrimitiveReceived,
                    0,0,0,0,0,0);

    if(pCThread->PrimitiveReceived)
    {
        fiSetEventRecord(eventRecord,thread,CEventResetDetected);
    }
    else
    {
        fiSetEventRecord(eventRecord,thread,CEventDoInitalize);

    }

}

/*+
  Function: CActionInitFM_DelayDone
   Purpose: This action is used to bring the loop up without stalling
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncNewInitFM
            CEventInitFMFailure
            CEventInitFMSuccess
-*/
/*  CStateInitFM_DelayDone   26 */
extern void CActionInitFM_DelayDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t  *hpRoot  = thread->hpRoot;

    event_t  Initialized_Event    = CEventInitFMSuccess;

    CFuncYellowLed(hpRoot, agFALSE);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) In %s - State = %d FM Cfg %08x FM Cfg3 %08x",
                    "CAIFM_DD",(char *)agNULL,
                    hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration_3 ),
                    0,0,0,0,0);

    fiLogString(hpRoot,
                    "%s FM %08X TL %08X",
                    "CAIFM_DD",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0,0);


    if(!CFuncNewInitFM( hpRoot ))
    {
        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "%s failed FM Status %08X FM Config %08X",
                        "CAIFM_DD",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                        0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "TL Status %08X TL Control %08X Rec Alpa Reg %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control ),
                        osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                        0,0,0,0,0);


        Initialized_Event = CEventInitFMFailure;
    }


#ifdef WASBEFORE

    if(!CFuncInitFM_Clear_FM( hpRoot ))
    {
        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "%s failed FM Status %08X FM Config %08X",
                        "CAIFM_DD",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                        0,0,0,0,0,0);

        fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "TL Status %08X TL Control %08X Rec Alpa Reg %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control ),
                        osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                        0,0,0,0,0);
/*
#ifdef NPORT_STUFF */
        /* Failure in initializing FM means we will have to go back
         * to initializing as a LOOP first before retrying NPORT.
         */
 /*       pCThread->InitAsNport = agFALSE;
        pCThread->ConnectedToNportOrFPort = agFALSE;
#endif  */  /* NPORT_STUFF */

        Initialized_Event = CEventInitFMFailure;
    }

#endif
    /* DRL find dev thread*/
    if( CFuncShowWhereDevThreadsAre( hpRoot))
    {
        Initialized_Event = CEventInitFMFailure;
    }

    fiSetEventRecord(eventRecord,thread, Initialized_Event);

}


#ifdef NAME_SERVICES

/*+
  Function: CActionAllocRFT_IDThread
   Purpose: This action used to allocate a SFThread for doing a RFT_ID
            now the previously allocated FLOGI SFThread is used
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventDoRFT_ID
-*/
/* CStateAllocRFT_IDThread      27 */
extern void CActionAllocRFT_IDThread( fi_thread__t *thread,eventRecord_t *eventRecord )
{
#ifdef Do_Not_USE_Flogi_SFThread
    agRoot_t *hpRoot= thread->hpRoot;

    CThread_t  * pCThread = CThread_ptr( hpRoot);
    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;

    if(pSFThread != (SFThread_t *) agNULL)
    {
       if( pCThread->SFThread_Request.State == SFThread_Request_Granted)
        {
            fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "pCThread %p Freeing SFThread in %s ",
                "CActionRFT_IDThread",(char *)agNULL,
                pCThread,(void *)agNULL,
                0,0,0,0,0,0,0,0);

            SFThreadFree( hpRoot, &pCThread->SFThread_Request );
            pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
        }
    }

    pCThread->SFThread_Request.eventRecord_to_send.event = CEventDoRFT_ID;
    pCThread->SFThread_Request.eventRecord_to_send.thread = thread;


    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionAllocRFT_IDThread",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    CFuncDisable_Interrupts(thread->hpRoot,ChipIOUp_INTEN_MASK);
    fiSetEventRecordNull(eventRecord);
    SFThreadAlloc( hpRoot,&pCThread->SFThread_Request );
#endif/* Do_Not_USE_Flogi_SFThread */

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionAllocRFT_IDThread",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);
    fiSetEventRecord(eventRecord,thread, CEventDoRFT_ID);


}

/*+
  Function: CActionDoRFT_ID
   Purpose: This action  does the RFT_ID
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            fiSendEvent
            CFuncInterruptPoll
            CEventRFT_IDSuccess 
            CEventRFT_IDFail           
-*/
/* CStateDoRFT_ID               28 */
extern void CActionDoRFT_ID( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t *hpRoot= thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr( hpRoot);


    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;
#ifdef Do_Not_USE_Flogi_SFThread
    pSFThread->parent.Device= (DevThread_t *)agNULL;
#endif/* Do_Not_USE_Flogi_SFThread */

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Before %s - State = %d",
                    "CActionDoRFT_ID",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    fiSetEventRecordNull(eventRecord);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoRFT_ID);
    if(CFuncInterruptPoll( hpRoot,&pCThread->Fabric_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "RFT_ID Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X ",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0);

        fiSetEventRecord(eventRecord,thread,CEventRFT_IDFail);
    }
    else
    {
        if( pSFThread->thread_hdr.currentState == SFStateRFT_IDAccept)
        {
          fiSetEventRecord(eventRecord,thread,CEventRFT_IDSuccess);
        }
        else
        {
          fiSetEventRecord(eventRecord,thread,CEventRFT_IDFail);
        }

    }
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After  %s - State = %d SFThread %p SFState %d",
                    "CActionDoRFT_ID",(char *)agNULL,
                    thread->hpRoot,pSFThread,
                    (os_bit32)thread->currentState,
                    (os_bit32)pSFThread->thread_hdr.currentState,
                    0,0,0,0,0,0);


}

/*+
  Function: CActionRFT_IDSuccess
   Purpose: This action used to free the SFThread after RFT_ID
            Now does nothing but move to the next state
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventAllocGID_FTThread
-*/
/* CStateRFT_IDSuccess          29 */
extern void CActionRFT_IDSuccess( fi_thread__t *thread,eventRecord_t *eventRecord )
{
#ifdef Do_Not_USE_Flogi_SFThread
    SFThreadFree(thread->hpRoot, & pCThread->SFThread_Request );
    pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
#endif/* Do_Not_USE_Flogi_SFThread */
    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionRFT_IDSuccess",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord, thread, CEventAllocGID_FTThread);
}

/*+
  Function: CActionAllocDiPlogiThread
   Purpose: Allocates PLOGI to the directory server 
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            SFThreadFree
            CFuncShowActiveCDBThreads
            CFuncDisable_Interrupts
            SFThreadAlloc            
-*/
/* CStateAllocDiPlogiThread      30 */
extern void CActionAllocDiPlogiThread( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t *hpRoot= thread->hpRoot;

    CThread_t  * pCThread = CThread_ptr( hpRoot);
    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;
    pCThread->DirectoryServicesStarted = agTRUE;


    if(pSFThread != (SFThread_t *) agNULL)
    {
        if( pCThread->SFThread_Request.State == SFThread_Request_Granted)
        {
            fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "pCThread %p Freeing SFThread in %s ",
                "CActionAllocDiPlogiThread",(char *)agNULL,
                pCThread,(void *)agNULL,
                0,0,0,0,0,0,0,0);

            SFThreadFree( hpRoot, &pCThread->SFThread_Request );
            pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
        }
    }

/*
    pCThread->LinkDownTime = pCThread->TimeBase;
    CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
*/
    pCThread->SFThread_Request.eventRecord_to_send.event = CEventDoDiPlogi;
    pCThread->SFThread_Request.eventRecord_to_send.thread = thread;


    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionAllocDiPlogiThread",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);

    CFuncDisable_Interrupts(thread->hpRoot,ChipIOUp_INTEN_MASK);

    SFThreadAlloc( hpRoot,&pCThread->SFThread_Request );

}

/*+
  Function: CActionDoDiPlogi
   Purpose: Does PLOGI to the directory server 
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            SFEventDoPlogi
            CFuncInterruptPoll
            CEventDiPlogiSuccess
            CEventDiPlogiFail
-*/
/*CStateDoDiPlogi               31 */
extern void CActionDoDiPlogi( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t *hpRoot= thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr( hpRoot);
    DevThread_t * pDevThread = (DevThread_t *)(&(pCThread->DirDevThread));

    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;
    pSFThread->parent.Device= pDevThread;

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Before %s - State = %d",
                    "CActionDoDiPlogi",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    fiSetEventRecordNull(eventRecord);

    pDevThread->Plogi_Reason_Code = PLOGI_REASON_DIR_LOGIN;
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPlogi);

    if(CFuncInterruptPoll( hpRoot,&pCThread->Fabric_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Dir Plogi Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);

        fiSetEventRecord(eventRecord,thread,CEventDiPlogiFail);
    }
    else
    {
        if( pSFThread->thread_hdr.currentState == SFStatePlogiAccept)
        {
          fiSetEventRecord(eventRecord,thread,CEventDiPlogiSuccess);
        }
        else
        {
          fiSetEventRecord(eventRecord,thread,CEventDiPlogiFail);
        }

    }
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After  %s - State = %d SFThread %p SFState %d",
                    "CActionDoDiPlogi",(char *)agNULL,
                    thread->hpRoot,pSFThread,
                    (os_bit32)thread->currentState,
                    (os_bit32)pSFThread->thread_hdr.currentState,
                    0,0,0,0,0,0);


}

/*+
  Function: CActionDiPlogiSuccess
   Purpose: Sets event record to CEventAllocRFT_IDThread
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventAllocRFT_IDThread
-*/
/* CStateDiPlogiSuccess         32 */
extern void CActionDiPlogiSuccess( fi_thread__t *thread,eventRecord_t *eventRecord )
{

#ifdef Do_Not_USE_Flogi_SFThread
    SFThreadFree(thread->hpRoot, & pCThread->SFThread_Request );
    pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
#endif/* Do_Not_USE_Flogi_SFThread */
    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionDiPlogiSuccess",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    fiSetEventRecord(eventRecord, thread, CEventAllocRFT_IDThread);

}

/*+
  Function: CActionAllocGID_FTThread
   Purpose: Sets event record to CEventDoGID_FT
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventDoGID_FT
-*/
/* CStateAllocGID_FTThread      33 */
extern void CActionAllocGID_FTThread( fi_thread__t *thread,eventRecord_t *eventRecord )
{
#ifdef Do_Not_USE_Flogi_SFThread
    agRoot_t *hpRoot= thread->hpRoot;

    CThread_t  * pCThread = CThread_ptr( hpRoot);
    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;

    if(pSFThread != (SFThread_t *) agNULL)
    {
        if( pCThread->SFThread_Request.State == SFThread_Request_Granted)
        {
            fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "pCThread %p Freeing SFThread in %s ",
                "CActionAllocGID_FTThread",(char *)agNULL,
                pCThread,(void *)agNULL,
                0,0,0,0,0,0,0,0);

            SFThreadFree( hpRoot, &pCThread->SFThread_Request );
            pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
        }
    }

    pCThread->SFThread_Request.eventRecord_to_send.event = CEventDoGID_FT;
    pCThread->SFThread_Request.eventRecord_to_send.thread = thread;


    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionAllocGID_FTThread",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
    CFuncDisable_Interrupts(thread->hpRoot,ChipIOUp_INTEN_MASK);
    SFThreadAlloc( hpRoot,&pCThread->SFThread_Request );

#endif/* Do_Not_USE_Flogi_SFThread */
    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionAllocGID_FTThread",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);
    fiSetEventRecord(eventRecord, thread,CEventDoGID_FT );

}

/*+
  Function: CActionDoGID_FT
   Purpose: Does GID_FT
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            fiSendEvent
            CFuncInterruptPoll
            CEventGID_FTFail
            CEventGID_FTSuccess
-*/
/*CStateDoGID_FT               34 */
extern void CActionDoGID_FT( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t *hpRoot= thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr( hpRoot);

    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;

#ifdef Do_Not_USE_Flogi_SFThread
    pSFThread->parent.Device= (DevThread_t *)agNULL;
#endif/* Do_Not_USE_Flogi_SFThread */

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Before %s - State = %d",
                    "CActionDoGID_FT",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    fiSetEventRecordNull(eventRecord);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoGID_FT);
    if(CFuncInterruptPoll( hpRoot,&pCThread->Fabric_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "GID_FT Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X ",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0);

        fiSetEventRecord(eventRecord,thread,CEventGID_FTFail);
    }
    else
    {
        if( pSFThread->thread_hdr.currentState == SFStateGID_FTAccept)
        {
          fiSetEventRecord(eventRecord,thread,CEventGID_FTSuccess);
        }
        else
        {
          fiSetEventRecord(eventRecord,thread,CEventGID_FTFail);
        }

    }
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After  %s - State = %d SFThread %p SFState %d",
                    "CActionDoGID_FT",(char *)agNULL,
                    thread->hpRoot,pSFThread,
                    (os_bit32)thread->currentState,
                    (os_bit32)pSFThread->thread_hdr.currentState,
                    0,0,0,0,0,0);


}

/*+
  Function: CActionGID_FTSuccess
   Purpose: Sets eventRecord to CEventAllocSCRThread
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventAllocSCRThread
-*/
/* CStateGID_FTSuccess          35  */
extern void CActionGID_FTSuccess( fi_thread__t *thread,eventRecord_t *eventRecord )
{
#ifdef Do_Not_USE_Flogi_SFThread
    CThread_t  * pCThread = CThread_ptr(thread->hpRoot);
    SFThreadFree(thread->hpRoot, & pCThread->SFThread_Request );
    pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
#endif/* Do_Not_USE_Flogi_SFThread */
    CFuncYellowLed(thread->hpRoot, agFALSE);
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionGID_FTSuccess",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    CThread_ptr(thread->hpRoot)->DeviceDiscoveryMethod = DDiscoveryQueriedNameService;

    fiSetEventRecord(eventRecord, thread, CEventAllocSCRThread);
}

/*+
  Function: CActionAllocSCRThread
   Purpose: Sets eventRecord to CEventDoSCR
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventDoSCR
-*/
/* CStateAllocSCRThread      38 */
extern void CActionAllocSCRThread( fi_thread__t *thread,eventRecord_t *eventRecord )
{
#ifdef Do_Not_USE_Flogi_SFThread
/*
    agRoot_t *hpRoot= thread->hpRoot;

    CThread_t  * pCThread = CThread_ptr( hpRoot);
    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;

    if(pSFThread != (SFThread_t *) agNULL)
    {
        if( pCThread->SFThread_Request.State == SFThread_Request_Granted)
        {
            fiLogDebugString(thread->hpRoot,
                CStateLogConsoleERROR,
                "pCThread %p Freeing SFThread in %s ",
                "CActionAllocSCRThread",(char *)agNULL,
                pCThread,(void *)agNULL,
                0,0,0,0,0,0,0,0);

            SFThreadFree( hpRoot, &pCThread->SFThread_Request );
            pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
        }
    }

    pCThread->SFThread_Request.eventRecord_to_send.event = CEventDoSCR;
    pCThread->SFThread_Request.eventRecord_to_send.thread = thread;

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionAllocSCRThread",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
    CFuncDisable_Interrupts(thread->hpRoot,ChipIOUp_INTEN_MASK);

    SFThreadAlloc( hpRoot,&pCThread->SFThread_Request );
*/
#endif/* Do_Not_USE_Flogi_SFThread */
    CFuncYellowLed(thread->hpRoot, agFALSE);
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionAllocSCRThread",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiSetEventRecord(eventRecord, thread, CEventDoSCR);


}

/*+
  Function: CActionDoSCR
   Purpose: Does SCR
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            SFEventDoSCR
            CFuncInterruptPoll
            CEventSCRFail
            CEventSCRSuccess            
-*/
/*CStateDoSCR               39 */
extern void CActionDoSCR( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t *hpRoot= thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr( hpRoot);


    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;
    pSFThread->parent.Device= (DevThread_t *)agNULL;

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Before %s - State = %d",
                    "CActionDoSCR",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    fiSetEventRecordNull(eventRecord);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoSCR);
    if(CFuncInterruptPoll( hpRoot,&pCThread->Fabric_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "SCR Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X ",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0);

        fiSetEventRecord(eventRecord,thread,CEventSCRFail);
    }
    else
    {
        if( pSFThread->thread_hdr.currentState == SFStateSCRAccept)
        {
          fiSetEventRecord(eventRecord,thread,CEventSCRSuccess);
        }
        else
        {
          fiSetEventRecord(eventRecord,thread,CEventSCRFail);
        }

    }
    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After  %s - State = %d SFThread %p SFState %d",
                    "CActionDoSCR",(char *)agNULL,
                    thread->hpRoot,pSFThread,
                    (os_bit32)thread->currentState,
                    (os_bit32)pSFThread->thread_hdr.currentState,
                    0,0,0,0,0,0);


}

/*+
  Function: CActionSCRSuccess
   Purpose: Does ADISC for all SCSI targets
            frees devthread for initiators
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            DevEventAllocAdisc
            CFuncInterruptPoll
            CEventSameALPA
-*/
/* CStateSCRSuccess          40  */
extern void CActionSCRSuccess( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    CThread_t     * pCThread  = CThread_ptr(thread->hpRoot);
    agRoot_t      * hpRoot    = thread->hpRoot;
    DevThread_t   * pDevThread;
    fiList_t      * pDevList;

    CFuncYellowLed(thread->hpRoot, agFALSE);

    pCThread->DirectoryServicesStarted = agFALSE;
#ifdef Do_Not_USE_Flogi_SFThread
    SFThreadFree(thread->hpRoot, & pCThread->SFThread_Request );
    pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
#endif/* Do_Not_USE_Flogi_SFThread */

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After In %s - State = %d",
                    "CActionSCRSuccess",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    while(fiListNotEmpty(&pCThread->Prev_Active_DevLink ))
    {
        fiListDequeueFromHead(&pDevList,
                                  &pCThread->Prev_Active_DevLink );
        pDevThread = hpObjectBase(DevThread_t,
                                  DevLink,pDevList );

        if( pDevThread->DevInfo.DeviceType & agDevSCSITarget )
        {
            fiLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "%s %s %x",
                        "CActionSCRSuccess","Prev_Active_DevLink",
                        (void *)agNULL,(void *)agNULL,
                        fiNumElementsOnList(&pCThread->Prev_Active_DevLink),
                        0,0,0,0,0,0,0);

            fiSendEvent(&pDevThread->thread_hdr,DevEventAllocAdisc);
        }
        else
        {/*+ Check This DRL  -*/
            if(CFuncQuietShowWhereDevThreadsAre( hpRoot))
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s AA CCnt %x",
                            "CActionSCRSuccess",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->CDBpollingCount,
                            0,0,0,0,0,0,0);
            
            }
            /*+ Check This DRL  -*/
            CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset,  CDBEventIODeviceReset );

            DevThreadFree( hpRoot, pDevThread );

            if(CFuncQuietShowWhereDevThreadsAre( hpRoot))
            {
                fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s BB CCnt %x",
                            "CActionSCRSuccess",(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->CDBpollingCount,
                            0,0,0,0,0,0,0);
            
            }
        }

    }

    if(CFuncInterruptPoll( hpRoot,&pCThread->ADISC_pollingCount ))
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "SCR ADISC  Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                0,0,0,0);
    }

    if(CFuncShowWhereDevThreadsAre( hpRoot)) CFuncWhatStateAreDevThreads( hpRoot );

    pCThread->DeviceDiscoveryMethod = DDiscoveryQueriedNameService;

    fiSetEventRecord(eventRecord, thread, CEventSameALPA);
}


/*+
  Function: CActionRSCNErrorBackIOs
   Purpose: Sets timer to get directory server information
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CFuncShowActiveCDBThreads
            fiTimerStart
-*/
/* CStateRSCNErrorBackIOs              41 */
extern void CActionRSCNErrorBackIOs( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t      * hpRoot             = thread->hpRoot;
    CThread_t     * pCThread           = CThread_ptr(hpRoot);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p In %s - State = %d",
                    "CActionRSCNErrorBackIOs",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiLogString(hpRoot,
                    "In %s Active IO %x",
                    "CActionRSCNErrorBackIOs",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
    				CFuncShowActiveCDBThreads( hpRoot, ShowActive),
                    0,0,0,0,0,0,0);

    pCThread->InterruptsDelayed = agFALSE;
    CFuncInteruptDelay(hpRoot, agFALSE);

    faSingleThreadedLeave( hpRoot , CStateRSCNErrorBackIOs);

    osFCLayerAsyncEvent( hpRoot, osFCLinkDown );

    faSingleThreadedEnter( hpRoot , CStateRSCNErrorBackIOs);

    if(pCThread->CDBpollingCount)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Ccnt Non Zero Ccnt %x",
                    "CActionRSCNErrorBackIOs",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->CDBpollingCount,
                    0,0,0,0,0,0,0);
    }


    CFuncShowActiveCDBThreads( hpRoot,ShowERQ);

    fiListEnqueueListAtTail(&pCThread->Active_DevLink,&pCThread->Prev_Active_DevLink);
    pCThread->RSCNreceived = agTRUE;

    if(! fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                   &(pCThread->TimerQ)))
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Setting Timer",
                    "CActionRSCNErrorBackIOs",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiTimerSetDeadlineFromNow(thread->hpRoot, &pCThread->Timer_Request, pCThread->Calculation.Parameters.R_A_TOV);

        pCThread->Timer_Request.eventRecord_to_send.thread= thread;
        pCThread->Timer_Request.eventRecord_to_send.event = CEventAllocDiPlogiThread;

        fiTimerStart(thread->hpRoot,&pCThread->Timer_Request);

    }
    else
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Timer not SET ",
                    "CActionRSCNErrorBackIOs",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    }
    fiSetEventRecordNull(eventRecord);

}

/*+
  Function: CActionFlipNPortState
   Purpose: Flips channel between NPORT and LOOP
            
 Called By: 
     Calls: CFuncYellowLed to indicate link down
            CEventDoInitalize

-*/
/* CStateFlipNPortState          43 */
extern void CActionFlipNPortState( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    agRoot_t   *    hpRoot          = thread->hpRoot;
    CThread_t  * pCThread           = CThread_ptr(hpRoot);

    CFuncYellowLed(thread->hpRoot, agFALSE);

    fiLogString(hpRoot,
                    "%s",
                    "CActionFlipNPortState",(char *)agNULL,
                     (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p)In %s - State = %d",
                    "CActionFlipNPortState",(char *)agNULL,
                    hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
            (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) | 
                                     ChipIOUp_Frame_Manager_Configuration_ELB     ));

    if(pCThread->Calculation.Parameters.InitAsNport)
    {
        pCThread->Calculation.Parameters.InitAsNport = 0;
    }
    else
    {
        pCThread->Calculation.Parameters.InitAsNport = 1;
    }
    fiSetEventRecord(eventRecord, thread, CEventDoInitalize);

}

#endif   /* NAME_SERVICES */

#endif /* NOT DEF USESTATEMACROS */

/* void cstate_c(void){} */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\cstest.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/CSTEST.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 7/20/00 2:33p   $

Purpose:

  This file Tests the FC Layer State Machine.

--*/

#include <stdio.h>
#include <stdlib.h>
#include "../h/globals.h"
#include "../h/fcstruct.h"
#include "../h/state.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/linksvc.h"
#include "../h/flashsvc.h"
#include "../h/timersvc.h"

#include "../h/cstate.h"
#include "../h/cfunc.h"
#include "../h/devstate.h"
#include "../h/cdbstate.h"
#include "../h/sfstate.h"
#include "../h/tgtstate.h"

#include "../h/queue.h"
#include "../h/cdbsetup.h"

extern stateTransitionMatrix_t  DevStateTransitionMatrix;
extern stateActionScalar_t      DevStateActionScalar;
extern stateTransitionMatrix_t  SFstateTransitionMatrix;
extern stateActionScalar_t      SFstateActionScalar;

/*
extern actionUpdate_t CDBTestActionUpdate[];
extern actionUpdate_t DevTestActionUpdate[];
extern actionUpdate_t SFtestActionUpdate[];
*/
#ifdef USESTATEMACROS

CSTATE_FUNCTION_TERMINATE(CActionConfused );
CSTATE_FUNCTION_TERMINATE(CActionShutdown );

CSTATE_FUNCTION_TERMINATE(CActionInitializeFailed);
CSTATE_FUNCTION_TERMINATE(CActionALPADifferent   );

CSTATE_FUNCTION_MULTI_ACTION(CActionInitialize  ,CEventInitChipSuccess, CEventInitChipSuccess,CEventInitChipSuccess,CEventInitalizeFailure );
CSTATE_FUNCTION_MULTI_ACTION(CActionInitFM      ,CEventInitFMSuccess   ,CEventInitFMSuccess,   CEventInitFMSuccess  , CEventInitFMFailure  );
CSTATE_FUNCTION_ACTION(CActionInitDataStructs,CEventDataInitalizeSuccess );


CSTATE_FUNCTION_MULTI_ACTION(CActionDoFlogi     ,CEventFlogiFail ,CEventFlogiFail  ,CEventFlogiSuccess ,CEventFlogiSuccess   );
CSTATE_FUNCTION_MULTI_ACTION(CActionFlogiSuccess,CEventSameALPA        ,CEventChangedALPA  , CEventSameALPA     ,     CEventChangedALPA       );
CSTATE_FUNCTION_MULTI_ACTION(CActionLoopFail    ,CEventLoopConditionCleared,CEventLoopNeedsReinit,  CEventLoopConditionCleared,CEventLoopConditionCleared,  );
CSTATE_FUNCTION_MULTI_ACTION(CActionReInitFM    ,CEventReInitFMSuccess, CEventReInitFMSuccess, CEventReInitFMSuccess, CEventReInitFMFailure     );


CSTATE_FUNCTION_ACTION(CActionNonFaALPA        ,CEventAllocFlogiThread);
CSTATE_FUNCTION_ACTION(CActionAllocFlogiThread ,CEventGotFlogiThread  );
CSTATE_FUNCTION_ACTION(CActionFreeSFthread     ,CEventSameALPA  );
CSTATE_FUNCTION_ACTION(CActionSuccess  ,CEventInitalizeSuccess );

CSTATE_FUNCTION_TERMINATE(CActionNormal );
CSTATE_FUNCTION_TERMINATE(CActionResetNeeded );
CSTATE_FUNCTION_TERMINATE(CActionFindPtToPtDevice );
CSTATE_FUNCTION_TERMINATE(CActionRSCNErrorBackIOs );
CSTATE_FUNCTION_TERMINATE(CActionSCRSuccess );
CSTATE_FUNCTION_TERMINATE(CActionAllocSCRThread );
CSTATE_FUNCTION_TERMINATE(CActionFindDeviceUseLoopMap );
CSTATE_FUNCTION_TERMINATE(CActionFindDeviceUseNameServer );
CSTATE_FUNCTION_TERMINATE(CActionGID_FTSuccess );
CSTATE_FUNCTION_TERMINATE(CActionDoGID_FT );
CSTATE_FUNCTION_TERMINATE(CActionAllocGID_FTThread );
CSTATE_FUNCTION_TERMINATE(CActionDiPlogiSuccess );
CSTATE_FUNCTION_TERMINATE(CActionDoDiPlogi );
CSTATE_FUNCTION_TERMINATE(CActionAllocDiPlogiThread );
CSTATE_FUNCTION_TERMINATE(CActionRFT_IDSuccess );
CSTATE_FUNCTION_TERMINATE(CActionDoRFT_ID );
CSTATE_FUNCTION_TERMINATE(CActionInitFM_DelayDone );
CSTATE_FUNCTION_TERMINATE(CActionSendPrimitive );
CSTATE_FUNCTION_TERMINATE(CActionDoExternalDeviceReset );
CSTATE_FUNCTION_TERMINATE(CActionExternalLogoutRecovery );
CSTATE_FUNCTION_TERMINATE(CActionExternalLogout );
CSTATE_FUNCTION_TERMINATE(CActionExternalDeviceReset );
CSTATE_FUNCTION_TERMINATE(CActionLIPEventStorm );
CSTATE_FUNCTION_TERMINATE(CActionElasticStoreEventStorm);
CSTATE_FUNCTION_TERMINATE(CActionFindDeviceUseAllALPAs );
CSTATE_FUNCTION_TERMINATE(CActionLoopFailedReInit );
CSTATE_FUNCTION_TERMINATE(CActionVerify_AL_PA );
CSTATE_FUNCTION_TERMINATE(CActionFlipNPortState );

CSTATE_FUNCTION_TERMINATE(CActionDoSCR );
CSTATE_FUNCTION_TERMINATE(CActionAllocRFT_IDThread );

CDBSTATE_FUNCTION_TERMINATE( CDBActionConfused       );
CDBSTATE_FUNCTION_TERMINATE( CDBActionThreadFree     );
CDBSTATE_FUNCTION_TERMINATE( CDBActionInitialize     );
CDBSTATE_FUNCTION_TERMINATE( CDBActionFillLocalSGL   );
CDBSTATE_FUNCTION_TERMINATE( CDBActionAllocESGL      );
CDBSTATE_FUNCTION_TERMINATE( CDBActionFillESGL       );
CDBSTATE_FUNCTION_TERMINATE( CDBActionSendIo         );
CDBSTATE_FUNCTION_TERMINATE( CDBActionSend_REC_Second         );

CDBSTATE_FUNCTION_ACTION(    CDBActionFcpCompleteSuccess,     CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionFcpCompleteSuccessRSP,  CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionFcpCompleteFail,        CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionFcpCompleteAbort,       CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionFcpCompleteDeviceReset, CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionFcpCompleteOver,        CDBEventThreadFree );

CDBSTATE_FUNCTION_TERMINATE( CDBActionOOOReceived,                          );
CDBSTATE_FUNCTION_TERMINATE( CDBActionOOOFixup                              );
CDBSTATE_FUNCTION_TERMINATE( CDBActionOOOSend                               );

CDBSTATE_FUNCTION_ACTION(    CDBActionInitialize_DR,       CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionFillESGL_DR,         CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionAllocESGL_DR,        CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionFillLocalSGL_DR,     CDBEventThreadFree );

CDBSTATE_FUNCTION_ACTION(    CDBActionInitialize_Abort  ,CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionFillLocalSGL_Abort,CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionAllocESGL_Abort   ,CDBEventThreadFree );
CDBSTATE_FUNCTION_ACTION(    CDBActionFillESGL_Abort    ,CDBEventThreadFree );


CDBSTATE_FUNCTION_ACTION( CDBActionOOOReceived_Abort   ,CDBEventThreadFree    );                    /* 24 */
CDBSTATE_FUNCTION_ACTION( CDBActionOOOReceived_DR      ,CDBEventThreadFree    );                    /* 25 */
CDBSTATE_FUNCTION_ACTION( CDBActionOOOFixup_Abort      ,CDBEventThreadFree    );                    /* 26 */
CDBSTATE_FUNCTION_ACTION( CDBActionOOOFixup_DR         ,CDBEventThreadFree    );                    /* 27 */

CDBSTATE_FUNCTION_TERMINATE(CDBAction_SRR_Fail);
CDBSTATE_FUNCTION_TERMINATE(CDBAction_SRR_Success );
CDBSTATE_FUNCTION_TERMINATE(CDBAction_REC_Success );
CDBSTATE_FUNCTION_TERMINATE(CDBActionSend_SRR_Second );
CDBSTATE_FUNCTION_TERMINATE(CDBActionSend_SRR );
CDBSTATE_FUNCTION_TERMINATE(CDBActionSend_REC );
CDBSTATE_FUNCTION_TERMINATE(CDBAction_CCC_IO_Fail );
CDBSTATE_FUNCTION_TERMINATE(CDBAction_CCC_IO_Success );
CDBSTATE_FUNCTION_TERMINATE(CDBActionSend_CCC_IO );
CDBSTATE_FUNCTION_TERMINATE(CDBActionBuild_CCC_IO );
CDBSTATE_FUNCTION_TERMINATE(CDBActionPrepare_For_Abort );
CDBSTATE_FUNCTION_TERMINATE(CDBActionPending_Abort);
CDBSTATE_FUNCTION_TERMINATE(CDBActionDo_Abort );
CDBSTATE_FUNCTION_TERMINATE(CDBActionAlloc_Abort);
CDBSTATE_FUNCTION_TERMINATE(CDBActionFailure_NO_RSP );
CDBSTATE_FUNCTION_TERMINATE(CDBActionOutBoundError );
CDBSTATE_FUNCTION_TERMINATE(CDBActionReSend_IO );
CDBSTATE_FUNCTION_TERMINATE(CDBActionDO_Nothing );
CDBSTATE_FUNCTION_TERMINATE(CDBAction_Alloc_REC );

#define __State_Force_Static_State_Tables__

#ifdef SkipThisStuff 
void main(void)
{
agRoot_t rhpRoot;
agRoot_t * hpRoot = &rhpRoot;

hpRoot->fcData = agNULL;
testCDBthread( hpRoot  );
}


void testCthread( agRoot_t * hpRoot  ){
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    fiInitializeThread(&pCThread->thread_hdr,
        hpRoot,
        threadType_CThread,
        CStateShutdown,
#ifdef __State_Force_Static_State_Tables__
        &CStateTransitionMatrix,
        &CStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
        pCThread->Calculation.MemoryLayout.CTransitions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.CActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
        );

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "0 ******************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Initial state = %1x",
                    (char *)agNULL,(char *)agNULL,
                    pCThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);



    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventShutdown ...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCThread->thread_hdr,CEventShutdown);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Shutdown Final state = %1x",
                    (char *)agNULL,(char *)agNULL,
                    pCThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "1 ****************************************** Ends on CStateShutdown",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventInitalize...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventInitalize);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "2 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "3 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "4 ****************************************** Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "5 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "6 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "7 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);




    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "8 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "9 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "10 ****************************************** Ends on CStateALPADifferent",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventInitalize...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventInitalize);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "11 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "12 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "13 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "14 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "15 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "16 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "17 ******************************************Ends on CStateALPADifferent",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventInitalize...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventInitalize);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "18 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "19 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "20 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "21 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "22 ******************************************Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "23 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "24 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "25 ******************************************Ends on CStateALPADifferent",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventInitalize...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventInitalize);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "26 ****************************************** Ends on CStateInitializeFailed",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventInitalize...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventInitalize);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "27 ****************************************** Ends on CStateInitializeFailed",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventInitalize...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventInitalize);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "28 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "29 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "30 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "31 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "32 ******************************************Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "33 ****************************************** Ends on CStateNormal",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventAsyncLoopEventDetected...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventAsyncLoopEventDetected);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "34 ******************************************Ends on CStateResetNeeded",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "Sending event CEventResetIfNeeded...",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCThread->thread_hdr,CEventResetIfNeeded);

    osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "35 ******************************************Ends on CStateALPADifferent",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);



}

/* CDB Test functions *************************************************************************************
*/



void testCDBthread( agRoot_t * hpRoot ){

    CThread_t   * pCThread   = CThread_ptr(hpRoot);
    CDBThread_t * pCDBThread  = pCThread->Calculation.MemoryLayout.CDBThread.addr.CachedMemory.cachedMemoryPtr;
    DevThread_t * pDevThread = pCThread->Calculation.MemoryLayout.DevThread.addr.CachedMemory.cachedMemoryPtr;


     pCDBThread->Device = pDevThread;
    /* CDBThread */
    if(1)
        {

        fiInitializeThread(&pCDBThread->thread_hdr,
            hpRoot,
            threadType_CDBThread,
            CDBStateThreadFree,
#ifdef __State_Force_Static_State_Tables__
            &CDBStateTransitionMatrix,
            &CDBStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
            pCThread->Calculation.MemoryLayout.CDBTransitions.addr.CachedMemory.cachedMemoryPtr,
            pCThread->Calculation.MemoryLayout.CDBActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
            );

        }

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "1 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGL);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGLSendIo );

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in Send IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoSuccess);


    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "2 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoSuccess);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "3 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoSuccess);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "4 Start Reset Device ***************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIODeviceReset);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "4 Should be in ThreadFree  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "5 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGL);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIODeviceReset);


    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "6 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoAbort);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGL);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIODeviceReset);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "7 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIODeviceReset);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);
    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "8 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIODeviceReset);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

     osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "9 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGL);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoAbort);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "10 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoAbort);
 
   osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "11 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGL);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoAbort);
    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "12 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGL);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventLocalSGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIODeviceReset);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "13 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoAbort);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);
    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "14 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIODeviceReset);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "15 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIODeviceReset);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);
    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "16 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoAbort);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);
    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "17 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoAbort);

        osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "18 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);


    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoAbort);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "19 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoOver);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "20 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoFailed);



    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "21 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );
    
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoSuccess);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "22 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOReceived );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOFixup );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventOOOSend );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoSuccessRSP);

    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);
    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "23 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventInitialize);
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventNeedESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventGotESGL );
    fiSendEvent(&pCDBThread->thread_hdr,CDBEventESGLSendIo );

    fiSendEvent(&pCDBThread->thread_hdr,CDBEventIoSuccessRSP);



    osLogDebugString(pCDBThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "Should be in ThreadFree IO  %d            *******************",
                    (char *)agNULL,(char *)agNULL,
                    pCDBThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);

}

#endif /* SkipThisStuff  */


DEVSTATE_FUNCTION_TERMINATE(DevActionConfused);
DEVSTATE_FUNCTION_TERMINATE(DevActionAvailable );
DEVSTATE_FUNCTION_TERMINATE(DevActionLoginFailed );

DEVSTATE_FUNCTION_MULTI_ACTION(DevActionDoPlogi       ,DevEventPlogiSuccess, DevEventPlogiFailed, DevEventPlogiSuccess, DevEventPlogiSuccess );
DEVSTATE_FUNCTION_MULTI_ACTION(DevActionDoPrli        ,DevEventPrliSuccess,  DevEventPrliFailed,  DevEventPrliSuccess,  DevEventPrliSuccess );
DEVSTATE_FUNCTION_MULTI_ACTION(DevActionMatchWWN      ,DevEventMatchWWN,     DevEventNoMatchWWN,  DevEventMatchWWN,     DevEventNoMatchWWN  );


DEVSTATE_FUNCTION_ACTION(DevActionHandleEmpty,   DevEventLogin );
DEVSTATE_FUNCTION_ACTION(DevActionAllocSFThread ,DevEventGotSFThread  );
DEVSTATE_FUNCTION_ACTION(DevActionPlogiDone     ,DevEventDoPrli    );
DEVSTATE_FUNCTION_ACTION(DevActionPrliDone      ,DevEventCheckWWN  );
DEVSTATE_FUNCTION_ACTION(DevActionSlotNew       ,DevEventAvailable );
DEVSTATE_FUNCTION_ACTION(DevActionSlotKnown     ,DevEventAvailable );
DEVSTATE_FUNCTION_ACTION(DevActionLogout        ,DevEventLoggedOut );


DEVSTATE_FUNCTION_ACTION(DevActionAllocDeviceResetSoft, DevEventDeviceResetSoft);
DEVSTATE_FUNCTION_ACTION(DevActionAllocDeviceResetHard, DevEventDeviceResetHard);

DEVSTATE_FUNCTION_ACTION(DevActionDeviceResetSoft, DevEventDeviceResetDone);
DEVSTATE_FUNCTION_ACTION(DevActionDeviceResetHard, DevEventDeviceResetDone);
DEVSTATE_FUNCTION_TERMINATE(DevActionDeviceResetDone);

DEVSTATE_FUNCTION_TERMINATE(DevAction_IO_Sent);
DEVSTATE_FUNCTION_TERMINATE(DevAction_IO_Ready);
DEVSTATE_FUNCTION_TERMINATE(DevActionTickGotSFThread);
DEVSTATE_FUNCTION_TERMINATE(DevActionExternalDeviceReset);
DEVSTATE_FUNCTION_TERMINATE(DevActionTickVerifyALPA);
DEVSTATE_FUNCTION_TERMINATE(DevActionAdiscDone_FAIL);
DEVSTATE_FUNCTION_TERMINATE(DevActionAdiscDone_OK);
DEVSTATE_FUNCTION_TERMINATE(DevActionAdisc);
DEVSTATE_FUNCTION_TERMINATE(DevActionAL_PA_Self_BAD);
DEVSTATE_FUNCTION_TERMINATE(DevActionAL_PA_Self_OK);
DEVSTATE_FUNCTION_TERMINATE(DevActionAllocAdisc);
DEVSTATE_FUNCTION_TERMINATE(DevActionDeviceResetDoneFAIL);
DEVSTATE_FUNCTION_TERMINATE(DevActionAdiscDone_FAIL_ReLogin);
DEVSTATE_FUNCTION_TERMINATE(DevActionAdiscDone_FAIL_No_Device);
DEVSTATE_FUNCTION_TERMINATE(DevAction_FC_TAPE_Recovery);



SFSTATE_FUNCTION_TERMINATE(SFActionDoLS_RJT);
SFSTATE_FUNCTION_TERMINATE(SFActionLS_RJT_Done );

SFSTATE_FUNCTION_TERMINATE(SFActionDoPlogiAccept);
SFSTATE_FUNCTION_TERMINATE(SFActionPlogiAccept_Done);

SFSTATE_FUNCTION_TERMINATE(SFActionDoPrliAccept);
SFSTATE_FUNCTION_TERMINATE(SFActionPrliAccept_Done);

SFSTATE_FUNCTION_TERMINATE(SFActionDoELSAccept);
SFSTATE_FUNCTION_TERMINATE(SFActionELSAccept_Done);

SFSTATE_FUNCTION_TERMINATE(SFActionDoFCP_DR_ACC_Reply);
SFSTATE_FUNCTION_TERMINATE(SFActionFCP_DR_ACC_Reply_Done);


SFSTATE_FUNCTION_TERMINATE(SFActionLS_RJT_TimeOut );
SFSTATE_FUNCTION_TERMINATE(SFActionPlogiAccept_TimeOut);
SFSTATE_FUNCTION_TERMINATE(SFActionPrliAccept_TimeOut);
SFSTATE_FUNCTION_TERMINATE(SFActionELSAccept_TimeOut);
SFSTATE_FUNCTION_TERMINATE(SFActionFCP_DR_ACC_Reply_TimeOut);
SFSTATE_FUNCTION_TERMINATE(SFActionDoRFT_ID);
SFSTATE_FUNCTION_TERMINATE(SFActionRFT_IDAccept);
SFSTATE_FUNCTION_TERMINATE(SFActionRFT_IDRej);
SFSTATE_FUNCTION_TERMINATE(SFActionRFT_IDBadALPA);
SFSTATE_FUNCTION_TERMINATE(SFActionRFT_IDTimedOut);
SFSTATE_FUNCTION_TERMINATE(SFActionDoGID_FT);
SFSTATE_FUNCTION_TERMINATE(SFActionGID_FTAccept);
SFSTATE_FUNCTION_TERMINATE(SFActionGID_FTRej);
SFSTATE_FUNCTION_TERMINATE(SFActionGID_FTBadALPA);
SFSTATE_FUNCTION_TERMINATE(SFActionGID_FTTimedOut);

SFSTATE_FUNCTION_TERMINATE(SFActionDoSCR);
SFSTATE_FUNCTION_TERMINATE(SFActionSCRAccept);
SFSTATE_FUNCTION_TERMINATE(SFActionSCRRej);
SFSTATE_FUNCTION_TERMINATE(SFActionSCRBadALPA);
SFSTATE_FUNCTION_TERMINATE(SFActionSCRTimedOut);

SFSTATE_FUNCTION_TERMINATE(SFActionDoSRR);
SFSTATE_FUNCTION_TERMINATE(SFActionSRRAccept);
SFSTATE_FUNCTION_TERMINATE(SFActionSRRRej);
SFSTATE_FUNCTION_TERMINATE(SFActionSRRBadALPA);
SFSTATE_FUNCTION_TERMINATE(SFActionSRRTimedOut);

SFSTATE_FUNCTION_TERMINATE(SFActionDoREC);
SFSTATE_FUNCTION_TERMINATE(SFActionRECAccept);
SFSTATE_FUNCTION_TERMINATE(SFActionRECRej);
SFSTATE_FUNCTION_TERMINATE(SFActionRECBadALPA);
SFSTATE_FUNCTION_TERMINATE(SFActionRECTimedOut);


SFSTATE_FUNCTION_TERMINATE(SFActionLogoTimedOut);
SFSTATE_FUNCTION_TERMINATE(SFActionLogoBadALPA);
SFSTATE_FUNCTION_TERMINATE(SFActionLogoRej);
SFSTATE_FUNCTION_TERMINATE(SFActionLogoAccept);
SFSTATE_FUNCTION_TERMINATE(SFActionDoLogo);


TgtSTATE_FUNCTION_TERMINATE(TgtActionELSAcc);
TgtSTATE_FUNCTION_TERMINATE(TgtActionFCP_DR_ACC_ReplyDone);
TgtSTATE_FUNCTION_TERMINATE(TgtActionFCP_DR_ACC_Reply);
TgtSTATE_FUNCTION_TERMINATE(TgtActionELS_ACC_ReplyDone);
TgtSTATE_FUNCTION_TERMINATE(TgtActionLOGO_ACC_Reply);
TgtSTATE_FUNCTION_TERMINATE(TgtActionPRLI_ACC_ReplyDone);
TgtSTATE_FUNCTION_TERMINATE(TgtActionPRLI_ACC_Reply);
TgtSTATE_FUNCTION_TERMINATE(TgtActionPLOGI_ACC_ReplyDone);
TgtSTATE_FUNCTION_TERMINATE(TgtActionPLOGI_ACC_Reply);
TgtSTATE_FUNCTION_TERMINATE(TgtActionPLOGI_RJT_ReplyDone);
TgtSTATE_FUNCTION_TERMINATE(TgtActionPLOGI_RJT_Reply);
TgtSTATE_FUNCTION_TERMINATE(TgtActionIncoming);
TgtSTATE_FUNCTION_TERMINATE(TgtActionIdle);
TgtSTATE_FUNCTION_TERMINATE(TgtActionADISCAcc_ReplyDone);
TgtSTATE_FUNCTION_TERMINATE(TgtActionADISCAcc_Reply);

#ifdef SkipThisStuff  

void testDevthread(  agRoot_t * hpRoot ){
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    DevThread_t  * pDevThread;
    pDevThread = pCThread->Calculation.MemoryLayout.DevThread.addr.CachedMemory.cachedMemoryPtr;

    /* Dev Thread */
    if(1){
    fiInitializeThread(&pDevThread->thread_hdr,
            hpRoot,
            threadType_DevThread,
            DevStateHandleEmpty,
#ifdef __State_Force_Static_State_Tables__
            &DevStateTransitionMatrix,
            &DevStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
            pCThread->Calculation.MemoryLayout.DevTransitions.addr.CachedMemory.cachedMemoryPtr,
            pCThread->Calculation.MemoryLayout.DevActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
            );


        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "1 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "2 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "3 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "4 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "5 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "6 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "7 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "8 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "9 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "10 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventAllocDeviceResetSoft);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "11 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "12 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventAllocDeviceResetHard);

        osLogDebugString(pDevThread->thread_hdr.hpRoot,
                    CDBStateLogConsoleLevel,
                    
                    "13 ********************************************************************",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);
        fiSendEvent(&pDevThread->thread_hdr,DevEventLogin);



    }
    }

#endif /* SkipThisStuff  */

SFSTATE_FUNCTION_TERMINATE(SFActionConfused);
SFSTATE_FUNCTION_TERMINATE(SFActionReset);

SFSTATE_FUNCTION_TERMINATE(SFActionDoPdisc       );
SFSTATE_FUNCTION_ACTION(SFActionPdiscTimedOut , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPdiscAccept  , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPdiscRej     , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPdiscBadALPA , SFEventReset );

SFSTATE_FUNCTION_TERMINATE(SFActionDoAbort       );
SFSTATE_FUNCTION_ACTION(SFActionAbortTimedOut , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionAbortBadALPA  , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionAbortRej      , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionAbortAccept   , SFEventReset );

SFSTATE_FUNCTION_TERMINATE(SFActionDoPlogi       );
SFSTATE_FUNCTION_ACTION(SFActionPlogiTimedOut , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPlogiAccept  , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPlogiRej     , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPlogiBadALPA , SFEventReset );

SFSTATE_FUNCTION_TERMINATE(SFActionDoPrli        );
SFSTATE_FUNCTION_ACTION(SFActionPrliTimedOut  , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPrliAccept   , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPrliRej      , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPrliBadALPA  , SFEventReset );

SFSTATE_FUNCTION_TERMINATE(SFActionDoFlogi       );
SFSTATE_FUNCTION_ACTION(SFActionFlogiTimedOut , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionFlogiAccept  , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionFlogiRej     , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionFlogiBadALPA , SFEventReset );


SFSTATE_FUNCTION_TERMINATE(SFActionDoPlogo       );
SFSTATE_FUNCTION_ACTION(SFActionPlogoTimedOut , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPlogoAccept  , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPlogoRej     , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPlogoBadALPA , SFEventReset );

SFSTATE_FUNCTION_TERMINATE(SFActionDoPrlo        );
SFSTATE_FUNCTION_ACTION(SFActionPrloTimedOut , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPrloAccept   , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPrloRej      , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionPrloBadALPA  , SFEventReset );

SFSTATE_FUNCTION_TERMINATE(SFActionDoAdisc       );
SFSTATE_FUNCTION_ACTION(SFActionAdiscTimedOut, SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionAdiscAccept  , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionAdiscRej     , SFEventReset );
SFSTATE_FUNCTION_ACTION(SFActionAdiscBadALPA , SFEventReset );

SFSTATE_FUNCTION_TERMINATE(SFActionDoResetDevice);
SFSTATE_FUNCTION_ACTION(SFActionResetDeviceAccept,   SFEventReset);
SFSTATE_FUNCTION_ACTION(SFActionResetDeviceRej,      SFEventReset);
SFSTATE_FUNCTION_ACTION(SFActionResetDeviceBadALPA , SFEventReset);
SFSTATE_FUNCTION_ACTION(SFActionResetDeviceTimedOut, SFEventReset);

SFSTATE_FUNCTION_TERMINATE(SFActionADISCAccept_TimeOut);
SFSTATE_FUNCTION_TERMINATE(SFActionADISCAccept_Done);
SFSTATE_FUNCTION_TERMINATE(SFActionDoADISCAccept);



#ifdef  SkipThisStuff 

void testSFthread( agRoot_t * hpRoot ){
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    SFThread_t   * pSFThread = pCThread->Calculation.MemoryLayout.SFThread.addr.CachedMemory.cachedMemoryPtr;

    /* SF Thread */
    if(1){

        fiInitializeThread(&pSFThread->thread_hdr,
            hpRoot,
            threadType_SFThread,
            SFStateFree,
#ifdef __State_Force_Static_State_Tables__
            &SFStateTransitionMatrix,
            &SFStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
            pCThread->Calculation.MemoryLayout.SFTransitions.addr.CachedMemory.cachedMemoryPtr,
            pCThread->Calculation.MemoryLayout.SFActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
            );


    /* printf("Sending event SFEventDoPlogi...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPlogi);
    /* printf("Sending event SFEventPlogiAccept...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPlogiAccept);

    /* printf("Sending event SFEventDoPlogi...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPlogi);
    /* printf("Sending event SFEventPlogiRej...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPlogiRej);


    /* printf("Sending event SFEventDoPlogi...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPlogi);
    /* printf("Sending event SFEventPlogiBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPlogiBadALPA);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPlogi);
    /* printf("Sending event SFEventPlogiBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPlogiTimedOut);

    /* printf("Sending event SFEventDoFlogi...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoFlogi);
    /* printf("Sending event SFEventFlogiAccept...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventFlogiAccept);


    /* printf("Sending event SFEventDoFlogi...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoFlogi);
    /* printf("Sending event SFEventFlogiRej...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventFlogiRej);

    /* printf("Sending event SFEventDoFlogi...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoFlogi);
    /* printf("Sending event SFEventFlogiBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventFlogiBadALPA);

    /* printf("Sending event SFEventDoPrli...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPrli);
    /* printf("Sending event SFEventPrliAccept...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPrliAccept);

    /* printf("Sending event SFEventDoPrli...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPrli);
    /* printf("Sending event SFEventPrliRej...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPrliRej);

    /* printf("Sending event SFEventDoPrli...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPrli);
    /* printf("Sending event SFEventPrliBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPrliBadALPA);

    /* printf("Sending event SFEventDoPdisc...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPdisc);
    /* printf("Sending event SFEventPdiscAccept...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPdiscAccept);

    /* printf("Sending event SFEventDoPdisc...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPdisc);
    /* printf("Sending event SFEventPdiscRej...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPdiscRej);

    /* printf("Sending event SFEventDoPdisc...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPdisc);
    /* printf("Sending event SFEventPdiscBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPdiscBadALPA);

    /* printf("Sending event SFEventDoPdisc...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPdisc);
    /* printf("Sending event SFEventPdiscBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPdiscTimedOut);


    /* printf("Sending event SFEventDoAbort...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoAbort);
    /* printf("Sending event SFEventAbortBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventAbortTimedOut);

    /* printf("Sending event SFEventDoAdisc...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoAdisc);
    /* printf("Sending event SFEventAdiscBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventAdiscTimedOut);

    /* printf("Sending event SFEventDoFlogi...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoFlogi);
    /* printf("Sending event SFEventFlogiBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventFlogiBadALPA);

    /* printf("Sending event SFEventDoPlogi...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPlogi);
    /* printf("Sending event SFEventPlogiAccept...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPlogiAccept);
    /* printf("Sending event SFEventDoPrli...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPrli);
    /* printf("Sending event SFEventPrliAccept...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPrliAccept);
    /* printf("Sending event SFEventDoAdisc...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoAdisc);
    /* printf("Sending event SFEventAdiscBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventAdiscAccept);
    /* printf("Sending event SFEventDoPdisc...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPdisc);
    /* printf("Sending event SFEventPdiscAccept...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventPdiscAccept);
    /* printf("Sending event SFEventDoAbort...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoAbort);
    /* printf("Sending event SFEventAbortBadALPA...\n"); */
    fiSendEvent(&pSFThread->thread_hdr,SFEventAbortAccept);
    /* printf("Sending event SFEventDoPlogo...\n"); */

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoResetDevice);
    fiSendEvent(&pSFThread->thread_hdr,SFEventResetDeviceAccept);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoResetDevice);
    fiSendEvent(&pSFThread->thread_hdr,SFEventResetDeviceRej);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoResetDevice);
    fiSendEvent(&pSFThread->thread_hdr,SFEventResetDeviceBadALPA);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoResetDevice);
    fiSendEvent(&pSFThread->thread_hdr,SFEventResetDeviceTimedOut);

    }
    return;



}

#endif /* SkipThisStuff  */

#endif /* USESTATEMACROS */

#ifdef  SkipThisStuff 


void CFunc_Check_SEST(agRoot_t * hpRoot){
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    os_bit32 num_sest_entry = pCThread->Calculation.MemoryLayout.SEST.elements - 1;
    os_bit32 x;
    os_bit32 sest_offset;
    USE_t                     *SEST;


    if(pCThread->Calculation.MemoryLayout.SEST.memLoc ==  inDmaMemory)
    {
        SEST = (USE_t *)pCThread->Calculation.MemoryLayout.SEST.addr.DmaMemory.dmaMemoryPtr;
        for(x= 0; x < num_sest_entry; x++, SEST++)
        {
            if(SEST->Bits & USE_VAL )
            {
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            
                            "X_ID %3X Bits %08X Link %08X",
                            (char *)agNULL,(char *)agNULL,
                            x,
                            SEST->Bits,
                            SEST->Unused_DWord_5,
                            0,0,0,0,0);

    
/*
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            
                            "Sest DWORD 0 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                            (char *)agNULL,(char *)agNULL,
                            SEST->Bits,
                            SEST->Unused_DWord_1,
                            SEST->Unused_DWord_2,
                            SEST->Unused_DWord_3,
                            SEST->LOC,
                            SEST->Unused_DWord_5,
                            SEST->Unused_DWord_6,
                            SEST->Unused_DWord_7);

                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            
                            "Sest DWORD 8 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                            (char *)agNULL,(char *)agNULL,
                            SEST->Unused_DWord_8,
                            SEST->Unused_DWord_9,
                            SEST->First_SG.U32_Len,
                            SEST->First_SG.L32,
                            SEST->Second_SG.U32_Len,
                            SEST->Second_SG.L32,
                            SEST->Third_SG.U32_Len,
                            SEST->Third_SG.L32);
*/
            }

        }


    }
    else
    {   /* inCardRam */
            osLogDebugString(pCThread->thread_hdr.hpRoot,
                    CStateLogConsoleLevel,
                    
                    "SEST.memLoc OnCard",
                    (char *)agNULL,(char *)agNULL,
                    0,0,0,0,0,0,0,0);

             sest_offset  = pCThread->Calculation.MemoryLayout.SEST.addr.CardRam.cardRamOffset;

        for(x= 0; x < num_sest_entry; x++ )
        {

            osCardRamWriteBit32(
                                 hpRoot,
                                 sest_offset + (sizeof(USE_t) * x),
                                 0);

        }

    }

}


void CFunc_OLD_Check_ERQ_RegistersOld( agRoot_t *hpRoot )
{
    CThread_t                  * pCThread= CThread_ptr(hpRoot);
    IRB_t                      * Base_ERQ_Entry;
    IRB_t                      * ERQ_Entry;
    X_ID_t                       X_ID;
    DevThread_t                * pDevThread;
    CDBThread_t                * pCDBThread;
    fiMemMapMemoryDescriptor_t * CDBThread_MemoryDescriptor = &pCThread->Calculation.MemoryLayout.CDBThread;

    os_bit32 Producer_Index;
    os_bit32 Consumer_Index;
    os_bit32 entry ;

    os_bit32 Max_ERQ = pCThread->Calculation.MemoryLayout.ERQ.elements - 1;

    Producer_Index = osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Producer_Index);
    Consumer_Index = osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index);

    if(pCThread->Calculation.MemoryLayout.ERQ.memLoc == inDmaMemory)
    {
        Base_ERQ_Entry = (IRB_t  *)pCThread->Calculation.MemoryLayout.ERQ.addr.DmaMemory.dmaMemoryPtr;
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    
                    "Base_ERQ_Entry %08X P %4X  C %4X",
                    (char *)agNULL,(char *)agNULL,
                    (os_bit32)Base_ERQ_Entry,
                    Producer_Index,
                    Consumer_Index,
                    0,0,0,0,0);
    }



    if( Consumer_Index == Producer_Index )
    {
        ERQ_Entry = Base_ERQ_Entry + (Consumer_Index -1);
        X_ID = ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID & 0x00007fff;

        if(X_ID < CDBThread_MemoryDescriptor->elements)
        {
            pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                         + (X_ID * CDBThread_MemoryDescriptor->elementSize));

            if (!(pCDBThread->ExchActive))
            {
                osLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            
                            "Equal Prior Found a cbdthread that is not active... %x State %d",
                            (char *)agNULL,(char *)agNULL,
                            (os_bit32) pCDBThread,
                            pCDBThread->thread_hdr.currentState,0,0,0,0,0,0);

                 osLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            
                            "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                            (char *)agNULL,(char *)agNULL,
                            (os_bit32)pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                            (os_bit32)pCDBThread->CDB_CMND_Class,
                            (os_bit32)pCDBThread->CDB_CMND_Type,
                            (os_bit32)pCDBThread->CDB_CMND_State,
                            (os_bit32)pCDBThread->CDB_CMND_Status,
                            0,0,0);
            }
            else
            {
                pCThread->pollingCount--;
                pDevThread = pCDBThread->Device; 
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            
                            "Equal Prior Device %2X SEST Entry %3X",
                            (char *)agNULL,(char *)agNULL,
                            pDevThread->DevInfo.CurrentAddress.AL_PA,
                            ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID ,
                            0,0,0,0,0,0);
            }
        }

        ERQ_Entry = Base_ERQ_Entry + Consumer_Index;
        X_ID = ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID & 0x00007fff;

        if(X_ID < CDBThread_MemoryDescriptor->elements)
        {
            pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                         + (X_ID * CDBThread_MemoryDescriptor->elementSize));

            if (!(pCDBThread->ExchActive))
            {
                osLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            
                            "Equal Found a cbdthread that is not active... %x State %d",
                            (char *)agNULL,(char *)agNULL,
                            (os_bit32) pCDBThread,
                            pCDBThread->thread_hdr.currentState,0,0,0,0,0,0);

                 osLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            
                            "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                            (char *)agNULL,(char *)agNULL,
                            pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                            pCDBThread->CDB_CMND_Class,
                            pCDBThread->CDB_CMND_Type,
                            pCDBThread->CDB_CMND_State,
                            pCDBThread->CDB_CMND_Status,
                            0,0,0);
            }
            else
            {
                pDevThread = pCDBThread->Device; 
                pCThread->pollingCount--;
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            
                            "Equal Device %2X SEST Entry %3X",
                            (char *)agNULL,(char *)agNULL,
                            pDevThread->DevInfo.CurrentAddress.AL_PA,
                            ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID ,
                            0,0,0,0,0,0);
            }
        }
    }
    else /* Consumer_Index != Producer_Index  */
    {
        if( Consumer_Index < Producer_Index )
        {
            ERQ_Entry = Base_ERQ_Entry + (Consumer_Index -1);
            pCThread->pollingCount--;
            X_ID = ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID & 0x00007fff;

            if(X_ID < CDBThread_MemoryDescriptor->elements)
            {
                pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                             + (X_ID * CDBThread_MemoryDescriptor->elementSize));

                if (!(pCDBThread->ExchActive))
                {
                    osLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                
                                "Less Prior Found a cbdthread that is not active... %x State %d",
                                (char *)agNULL,(char *)agNULL,
                                (os_bit32) pCDBThread,
                                pCDBThread->thread_hdr.currentState,0,0,0,0,0,0);

                     osLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                
                                "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                                (char *)agNULL,(char *)agNULL,
                                pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                                pCDBThread->CDB_CMND_Class,
                                pCDBThread->CDB_CMND_Type,
                                pCDBThread->CDB_CMND_State,
                                pCDBThread->CDB_CMND_Status,
                                0,0,0);
                }
                else
                {
                    pDevThread = pCDBThread->Device; 
                    pCThread->pollingCount--;
                    osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                
                                "Less Prior Device %2X SEST Entry %3X",
                                (char *)agNULL,(char *)agNULL,
                                pDevThread->DevInfo.CurrentAddress.AL_PA,
                                ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID ,
                                0,0,0,0,0,0);
                }
            }
        
            for(entry = Consumer_Index; entry < Producer_Index; entry ++)
            {
                ERQ_Entry = Base_ERQ_Entry + entry;

                X_ID = ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID & 0x00007fff;

                if(X_ID < CDBThread_MemoryDescriptor->elements)
                {
                    pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                                 + (X_ID * CDBThread_MemoryDescriptor->elementSize));

                    if (!(pCDBThread->ExchActive))
                    {
                        osLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    
                                    "Less Found a cbdthread that is not active... %x State %d",
                                    (char *)agNULL,(char *)agNULL,
                                    (os_bit32) pCDBThread,
                                    pCDBThread->thread_hdr.currentState,0,0,0,0,0,0);

                         osLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    
                                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                                    (char *)agNULL,(char *)agNULL,
                                    pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                                    pCDBThread->CDB_CMND_Class,
                                    pCDBThread->CDB_CMND_Type,
                                    pCDBThread->CDB_CMND_State,
                                    pCDBThread->CDB_CMND_Status,
                                    0,0,0);
                    }
                    else
                    {
                        pDevThread = pCDBThread->Device; 
                        pCThread->pollingCount--;
                        osLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    
                                    "Less Device %2X SEST Entry %3X",
                                    (char *)agNULL,(char *)agNULL,
                                    pDevThread->DevInfo.CurrentAddress.AL_PA,
                                    ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID ,
                                    0,0,0,0,0,0);
                    }
                }
            }
            
        }
        else /* ( Consumer_Index > Producer_Index ) */
        {
            ERQ_Entry = Base_ERQ_Entry + (Consumer_Index -1);
            X_ID = ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID & 0x00007fff;

            if(X_ID < CDBThread_MemoryDescriptor->elements)
            {
                pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                             + (X_ID * CDBThread_MemoryDescriptor->elementSize));

                if (!(pCDBThread->ExchActive))
                {
                    osLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                
                                "Wrap Prior Found a cbdthread that is not active... %x State %d",
                                (char *)agNULL,(char *)agNULL,
                                (os_bit32) pCDBThread,
                                pCDBThread->thread_hdr.currentState,0,0,0,0,0,0);

                     osLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                
                                "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                                (char *)agNULL,(char *)agNULL,
                                pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                                pCDBThread->CDB_CMND_Class,
                                pCDBThread->CDB_CMND_Type,
                                pCDBThread->CDB_CMND_State,
                                pCDBThread->CDB_CMND_Status,
                                0,0,0);
                }
                else
                {
                    pDevThread = pCDBThread->Device; 
                    pCThread->pollingCount--;
                    osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                
                                "Wrap Prior Device %2X SEST Entry %3X",
                                (char *)agNULL,(char *)agNULL,
                                pDevThread->DevInfo.CurrentAddress.AL_PA,
                                ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID ,
                                0,0,0,0,0,0);
                }
            }


            for(entry = Consumer_Index; entry < Max_ERQ; entry ++)
            {
                ERQ_Entry = Base_ERQ_Entry + entry;
                X_ID = ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID & 0x00007fff;

                if(X_ID < CDBThread_MemoryDescriptor->elements)
                {
                    pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                                 + (X_ID * CDBThread_MemoryDescriptor->elementSize));

                    if (!(pCDBThread->ExchActive))
                    {
                        osLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    
                                    "Wrap Found a cbdthread that is not active... %x State %d",
                                    (char *)agNULL,(char *)agNULL,
                                    (os_bit32) pCDBThread,
                                    pCDBThread->thread_hdr.currentState,0,0,0,0,0,0);

                         osLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    
                                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                                    (char *)agNULL,(char *)agNULL,
                                    pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                                    pCDBThread->CDB_CMND_Class,
                                    pCDBThread->CDB_CMND_Type,
                                    pCDBThread->CDB_CMND_State,
                                    pCDBThread->CDB_CMND_Status,
                                    0,0,0);
                    }
                    else
                    {
                        pDevThread = pCDBThread->Device; 
                        pCThread->pollingCount--;
                        osLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    
                                    "Wrap Device %2X SEST Entry %3X",
                                    (char *)agNULL,(char *)agNULL,
                                    pDevThread->DevInfo.CurrentAddress.AL_PA,
                                    ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID ,
                                    0,0,0,0,0,0);
                    }
                }
            }

            for(entry = 0; entry < Producer_Index; entry ++)
            {
                ERQ_Entry = Base_ERQ_Entry + entry;
                X_ID = ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID & 0x00007fff;

                if(X_ID < CDBThread_MemoryDescriptor->elements)
                {
                    pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                                 + (X_ID * CDBThread_MemoryDescriptor->elementSize));

                    if (!(pCDBThread->ExchActive))
                    {
                        osLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    
                                    "Wrap Found a cbdthread that is not active... %x State %d",
                                    (char *)agNULL,(char *)agNULL,
                                    (os_bit32) pCDBThread,
                                    pCDBThread->thread_hdr.currentState,0,0,0,0,0,0);

                         osLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    
                                    "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                                    (char *)agNULL,(char *)agNULL,
                                    pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                                    pCDBThread->CDB_CMND_Class,
                                    pCDBThread->CDB_CMND_Type,
                                    pCDBThread->CDB_CMND_State,
                                    pCDBThread->CDB_CMND_Status,
                                    0,0,0);
                    }
                    else
                    {
                        pDevThread = pCDBThread->Device; 
                        pCThread->pollingCount--;
                        osLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    
                                    "Wrap Device %2X SEST Entry %3X",
                                    (char *)agNULL,(char *)agNULL,
                                    pDevThread->DevInfo.CurrentAddress.AL_PA,
                                    ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID ,
                                    0,0,0,0,0,0);
                    }
                }
            }
        }
    }
}

void CFunc_Check_ERQ_Registers( agRoot_t *hpRoot )
{
    CThread_t                  * pCThread= CThread_ptr(hpRoot);
    IRB_t                      * Base_ERQ_Entry;
    IRB_t                      * ERQ_Entry;
    X_ID_t                       X_ID;
    DevThread_t                * pDevThread;
    CDBThread_t                * pCDBThread;
    fiMemMapMemoryDescriptor_t * CDBThread_MemoryDescriptor = &pCThread->Calculation.MemoryLayout.CDBThread;
    fiMemMapMemoryDescriptor_t * ERQ_MemoryDescriptor = &pCThread->Calculation.MemoryLayout.ERQ;

    USE_t                     *SEST;

    os_bit32 Producer_Index;
    os_bit32 Consumer_Index;
    os_bit32 entry ;

    os_bit32 Max_ERQ = pCThread->Calculation.MemoryLayout.ERQ.elements - 1;

return;
    Producer_Index = osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Producer_Index);
    Consumer_Index = osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index);

    if(pCThread->Calculation.MemoryLayout.ERQ.memLoc == inDmaMemory)
    {
        Base_ERQ_Entry = (IRB_t  *)pCThread->Calculation.MemoryLayout.ERQ.addr.DmaMemory.dmaMemoryPtr;
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    
                    "Base_ERQ_Entry %08X P %4X  C %4X",
                    (char *)agNULL,(char *)agNULL,
                    (os_bit32)Base_ERQ_Entry,
                    Producer_Index,
                    Consumer_Index,
                    0,0,0,0,0);
    }
            
    for(entry = 0; entry < ERQ_MemoryDescriptor->elements; entry ++)
    {
        ERQ_Entry = Base_ERQ_Entry + entry;

        X_ID = ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID & 0x00007fff;

        if(X_ID < CDBThread_MemoryDescriptor->elements)
        {
            pCDBThread = (CDBThread_t *)((os_bit8 *)(CDBThread_MemoryDescriptor->addr.CachedMemory.cachedMemoryPtr)
                                         + (X_ID * CDBThread_MemoryDescriptor->elementSize));

            if (!(pCDBThread->ExchActive))
            {

/*
                osLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            
                            "Less Found a cbdthread that is not active... %x State %d",
                            (char *)agNULL,(char *)agNULL,
                            (os_bit32) pCDBThread,
                            pCDBThread->thread_hdr.currentState,0,0,0,0,0,0);

                 osLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            
                            "Device %02X  CDB Class %2X Type %2X State %2X Status %2X",
                            (char *)agNULL,(char *)agNULL,
                            pCDBThread->Device->DevInfo.CurrentAddress.AL_PA,
                            pCDBThread->CDB_CMND_Class,
                            pCDBThread->CDB_CMND_Type,
                            pCDBThread->CDB_CMND_State,
                            pCDBThread->CDB_CMND_Status,
                            0,0,0);
*/
            }
            else
            {
                SEST = (USE_t *)pCDBThread->SEST_Ptr;
                pDevThread = pCDBThread->Device; 
                pCThread->pollingCount--;

                 osLogDebugString(hpRoot,
                            CFuncLogConsoleERROR,
                            
                            "F %x Send %x TO %x A3 %x A2 %x A1 %x A0 %x A login %x",
                            (char *)agNULL,(char *)agNULL,
                            fiListElementOnList(&pCThread->Free_CDBLink,       &pCDBThread->CDBLink),
                            fiListElementOnList(&pDevThread->Send_IO_CDBLink,  &pCDBThread->CDBLink),
                            fiListElementOnList(&pDevThread->TimedOut_CDBLink, &pCDBThread->CDBLink),
                            fiListElementOnList(&pDevThread->Active_CDBLink_3, &pCDBThread->CDBLink),
                            fiListElementOnList(&pDevThread->Active_CDBLink_2, &pCDBThread->CDBLink),
                            fiListElementOnList(&pDevThread->Active_CDBLink_1, &pCDBThread->CDBLink),
                            fiListElementOnList(&pDevThread->Active_CDBLink_0, &pCDBThread->CDBLink),
                            fiListElementOnList(&pDevThread->Awaiting_Login_CDBLink,&pCDBThread->CDBLink) );

                pCDBThread->TimeStamp = 0;

                if(! fiListElementOnList(&pDevThread->Awaiting_Login_CDBLink,&pCDBThread->CDBLink) )
                {
                    fiListDequeueThis( &pCDBThread->CDBLink );

                    fiListEnqueueAtHead( &pCDBThread->CDBLink, &(pDevThread->Awaiting_Login_CDBLink) );
                }



                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            
                            "ERQ %X Device %2X %08X CCnt %x SEST Entry %3X Bits %08X State %d",
                            (char *)agNULL,(char *)agNULL,
                            entry,
                            pDevThread->DevInfo.CurrentAddress.AL_PA,
                            pCDBThread->CDBStartTimeBase.Lo,
                            pCThread->pollingCount,
                            ERQ_Entry->Req_A.MBZ__SEST_Index__Trans_ID,
                            pCDBThread->SEST_Ptr->USE.Bits,
                            pCDBThread->thread_hdr.currentState,
                            0);
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            
                            "Sest DWORD 7 %08X  %08X  %08X  %08X %08X  %08X  %08X  %08X",
                            (char *)agNULL,(char *)agNULL,
                            SEST->Unused_DWord_7,
                            SEST->Unused_DWord_8,
                            SEST->Unused_DWord_9,
                            SEST->First_SG.U32_Len,
                            SEST->First_SG.L32,
                            SEST->Second_SG.U32_Len,
                            SEST->Second_SG.L32,
                            SEST->Third_SG.U32_Len);


            }
        }
    }

}


#endif /* SkipThisStuff  */

osGLOBAL void osLogString(
                           agRoot_t *agRoot,
                           char     *formatString,
                           char     *firstString,
                           char     *secondString,
                           void     *firstPtr,
                           void     *secondPtr,
                           os_bit32  firstBit32,
                           os_bit32  secondBit32,
                           os_bit32  thirdBit32,
                           os_bit32  fourthBit32,
                           os_bit32  fifthBit32,
                           os_bit32  sixthBit32,
                           os_bit32  seventhBit32,
                           os_bit32  eighthBit32
                         )
{
}


#ifdef OBSOLETE_FUNCTIONS 
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/CSTEST.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 7/20/00 2:33p   $

Purpose:

  This file implements Initialize functions called by the FC Layer Card
  State Machine.

--*/

#include <stdio.h>
#include <stdlib.h>
#include "../h/globals.h"
#include "../h/fcstruct.h"
#include "../h/state.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"
#include "../h/linksvc.h"
#include "../h/cmntrans.h"
#include "../h/sf_fcp.h"
#include "../h/flashsvc.h"
#include "../h/timersvc.h"

#include "../h/cstate.h"
#include "../h/cfunc.h"
#include "../h/devstate.h"
#include "../h/cdbstate.h"
#include "../h/sfstate.h"
#include "../h/tgtstate.h"

#include "../h/queue.h"
#include "../h/cdbsetup.h"


#ifndef __State_Force_Static_State_Tables__
extern actionUpdate_t noActionUpdate;
#endif /* __State_Force_Static_State_Tables__ was not defined */

extern os_bit8 Alpa_Index[256];

agBOOLEAN CFuncInitFM_Clear_FM( agRoot_t *hpRoot )
{
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    agFCChanInfo_t *Self_info = &(pCThread->ChanInfo);
    os_bit32 stall_count = 0;
    os_bit32 FM_Status = 0;
#ifdef NPORT_STUFF
    os_bit32 Acquired_Alpa = 0xFF;
#else /* NPORT_STUFF */
    os_bit32 Acquired_Alpa = 0;
#endif /* NPORT_STUFF */

    os_bit32 Received_ALPA = 0;

    FC_Port_ID_t    Port_ID;

    os_bit32 Frame_Manager_Config =0;

#ifdef NPORT_STUFF
    /* If we are trying to connect to an NPort, Check the Port State Machine
     * to be active. The ALPA in this case is Zero. Note: This is the only place
     * that the check is made to determine if the link is UP or not.
     */
    if (pCThread->InitAsNport)
    {
        FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
        

        if( (FM_Status & ChipIOUp_Frame_Manager_Status_PSM_MASK) ==
                                 ChipIOUp_Frame_Manager_Status_PSM_ACTIVE )
        {
            pCThread->ChanInfo.CurrentAddress.AL_PA = 0;

            Port_ID.Struct_Form.Domain = pCThread->ChanInfo.CurrentAddress.Domain;
            Port_ID.Struct_Form.Area   = pCThread->ChanInfo.CurrentAddress.Area;
            Port_ID.Struct_Form.AL_PA  = pCThread->ChanInfo.CurrentAddress.AL_PA;

            if (FM_Status & ChipIOUp_Frame_Manager_Status_LF ||
                    FM_Status & ChipIOUp_Frame_Manager_Status_OLS)
            {
                    osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Detected NOS/OLS or Link Failure %08X FM Config %08X ALPA %08X",
                            (char *)agNULL,(char *)agNULL,
                            agNULL,agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                            osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                            0,0,0,0,0);

                    /* Since we are not going to be polling and reading the IMQ, we better
                       clear the FM status register so that when we do read the frame manager
                       as a result of the interrupt, we do not process this LF or OLS again.
                     */

                    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, (ChipIOUp_Frame_Manager_Status_LF | ChipIOUp_Frame_Manager_Status_OLS));
                    
           }


            Received_ALPA = (( Acquired_Alpa &
                            ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) >>
                       ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT);

            pCThread->DeviceSelf =  DevThreadAlloc( hpRoot,Port_ID );
            osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Clear FM DevSelf %x FM_Status %x",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    FM_Status,
                    0,
                    0,0,0,0,0);

            pCThread->DeviceSelf->DevSlot = DevThreadFindSlot(hpRoot,
                                                      Self_info->CurrentAddress.Domain,
                                                      Self_info->CurrentAddress.Area,
                                                      Self_info->CurrentAddress.AL_PA,
                                                      (FC_Port_Name_t *)(&Self_info->PortWWN));

            fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
            fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);

            return (agTRUE);
        }

        return (agFALSE);
    }

#endif /* NPORT_STUFF */

    if( CFuncClearFrameManager( hpRoot,&Acquired_Alpa ))
    {
        Received_ALPA = (( Acquired_Alpa &
                       ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) >>
                       ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT);

        if(Received_ALPA != 0  &&  Received_ALPA != 0xFF )
        {
            /* Write aquired AL_PA */
            osLogDebugString(hpRoot,
                        CFuncLogConsoleERROR,
                        "Clear FM Failed Self ALPA %x  Received_ALPA %x Acquired_Alpa %08X",
                        (char *)agNULL,(char *)agNULL,
                        agNULL,agNULL,
                        (os_bit32)Self_info->CurrentAddress.AL_PA,
                        Received_ALPA,
                        Acquired_Alpa,
                        0,0,0,0,0);

            osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, Received_ALPA);
        }

        if( pCThread->LOOP_DOWN )
        {
            if( CFuncLoopDownPoll(hpRoot))
            {
                osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "%s NOT %s  ...Failed",
                                "CFuncInitFM_ClearFM","CFuncLoopDownPoll",
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);

                return agFALSE;
            }

        }

    }

#ifdef OSLayer_Stub

    Port_ID.Struct_Form.Domain = pCThread->ChanInfo.CurrentAddress.Domain;
    Port_ID.Struct_Form.Area   = pCThread->ChanInfo.CurrentAddress.Area;
    Port_ID.Struct_Form.AL_PA  = 0xEF;
    pCThread->DeviceSelf = DevThreadAlloc( hpRoot,Port_ID );

    fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
    fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);


#else /* OSLayer_Stub */


    Port_ID.Struct_Form.Domain = pCThread->ChanInfo.CurrentAddress.Domain;
    Port_ID.Struct_Form.Area   = pCThread->ChanInfo.CurrentAddress.Area;
    Port_ID.Struct_Form.AL_PA  = pCThread->ChanInfo.CurrentAddress.AL_PA;

    Received_ALPA = (( Acquired_Alpa &
                       ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) >>
                       ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT);


     osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Clear FM OK  Self_info AL_PA %x Received_ALPA %x Acquired_Alpa %08X Port ID %08X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    Received_ALPA,
                    Acquired_Alpa,
                    Port_ID.Bit32_Form,
                    0,0,0,0);



    if(Received_ALPA == 0)
    {
#ifdef NPORT_STUFF
        /* When we first initialize as LPORT when really connected to
         * the NPORT, we get here and bail out.
         */
#endif /* NPORT_STUFF */
/*        return agFALSE;*/
    }

    pCThread->DeviceSelf = DevThreadAlloc( hpRoot,Port_ID );
    fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
    fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);


#ifdef _BYPASSLOOPMAP
    Frame_Manager_Config |= ChipIOUp_Frame_Manager_Configuration_BLM;
#endif /* _BYPASSLOOPMAP */

#endif  /* OSLayer_Stub */

    Frame_Manager_Config |= (Received_ALPA <<
                            ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT);


    if( Received_ALPA == 0xFF || pCThread->DeviceSelf == ( DevThread_t *)agNULL  )
    {
        osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "(%p)Received_ALPA  %08X or pCThread->DeviceSelf == agNULL %p",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,pCThread->DeviceSelf,
                    Received_ALPA,
                    0,0,0,0,0,0,0);

            return agFALSE;
    }


    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration, Frame_Manager_Config | ChipIOUp_Frame_Manager_Configuration_AQ);

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "hpRoot %p Frame Manager Status %08X Thread %p SELF AL_PA %X A %08X B %08X ",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,pCThread->DeviceSelf,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status),
                    Received_ALPA,
                    Frame_Manager_Config,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0);



    pCThread->DeviceSelf->DevSlot = DevThreadFindSlot(hpRoot,
                                                      Self_info->CurrentAddress.Domain,
                                                      Self_info->CurrentAddress.Area,
                                                      Self_info->CurrentAddress.AL_PA,
                                                      (FC_Port_Name_t *)(&Self_info->PortWWN));

    fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
    fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);

    /* Write aquired AL_PA */
    osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, pCThread->ChanInfo.CurrentAddress.AL_PA);

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "A * Self ALPA %x  Received_ALPA %x Acquired_Alpa %08X Info Alpa %x FM cfg %08X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    Received_ALPA,
                    Acquired_Alpa,
                    pCThread->ChanInfo.CurrentAddress.AL_PA,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0);


    return agTRUE;



}


void CFuncInitFM_Initialize( agRoot_t *hpRoot )
{
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    agFCChanInfo_t *Self_info = &(pCThread->ChanInfo);

    /* Frame Manager Initialize */

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Frame Manager Initialize FM Cfg %08X FM Stat %08X  TL Stat %08X Self ALPA %x",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Configuration),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    0,0,0,0);

    osChipIOUpWriteBit32( hpRoot,ChipIOUp_Frame_Manager_Status, osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ));

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Initialize );

}



agBOOLEAN CFuncInitFM( agRoot_t *hpRoot ){
    CThread_t  * pCThread = CThread_ptr(hpRoot);
    agFCChanInfo_t *Self_info = &(pCThread->ChanInfo);
    os_bit32 stall_count = 0;
    os_bit32 FM_Status = 0;
    os_bit32 Acquired_Alpa = 0;
    os_bit32 Received_ALPA = 0;
    FC_Port_ID_t    Port_ID;

    os_bit32 Init_FM_Value = 0;
    os_bit32 Frame_Manager_Config =0;

    CFuncGetHaInfoFromNVR(hpRoot);
    fiLinkSvcInit(hpRoot);

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "CFuncInitFM Frame Manager Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status),
                    0,0,0,0,0,0,0);

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "%s HA %x CA %x",
                    "CFuncInitFM",(char *)agNULL,
                    agNULL,agNULL,
                    (os_bit32)(Self_info->HardAddress.AL_PA),
                    (os_bit32)(Self_info->CurrentAddress.AL_PA),
                    0,0,0,0,0,0);


    if (Self_info->CurrentAddress.AL_PA == fiFlash_Card_Unassigned_Loop_Address)
    {
#ifdef _BYPASSLOOPMAP
        if(pCThread->PreviouslyAquiredALPA)
        {
        Init_FM_Value = (  ChipIOUp_Frame_Manager_Configuration_AQ  |
                           ChipIOUp_Frame_Manager_Configuration_BLM |
                           ( ((os_bit32)(Self_info->HardAddress.AL_PA))
                              << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 
        }
        else
        {
        Init_FM_Value = (  ChipIOUp_Frame_Manager_Configuration_SA  |
                           ChipIOUp_Frame_Manager_Configuration_BLM |
                           ( ((os_bit32)(Self_info->HardAddress.AL_PA))
                              << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 
        }
#else /* _BYPASSLOOPMAP */
        if(pCThread->PreviouslyAquiredALPA)
        {
        Init_FM_Value  = ChipIOUp_Frame_Manager_Configuration_AQ    |
                           ( ((os_bit32)(Self_info->HardAddress.AL_PA))
                              << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 
        }
        else
        {
        Init_FM_Value  = ChipIOUp_Frame_Manager_Configuration_SA    |
                           ( ((os_bit32)(Self_info->HardAddress.AL_PA))
                              << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) ); 
        }
#endif /* _BYPASSLOOPMAP */

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration, Init_FM_Value );

        osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "A %s Frame Manager Configuration %08X",
                    "CFuncInitFM",(char *)agNULL,
                    agNULL,agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration),
                    0,0,0,0,0,0,0);

    }
    else /* Self_info->CurrentAddress.AL_PA != fiFlash_Card_Unassigned_Loop_Address */
    {

#ifdef _BYPASSLOOPMAP
        Init_FM_Value = (  ChipIOUp_Frame_Manager_Configuration_HA  |
                           ChipIOUp_Frame_Manager_Configuration_BLM );
#else /* _BYPASSLOOPMAP */
        Init_FM_Value  = ChipIOUp_Frame_Manager_Configuration_HA;
#endif /* _BYPASSLOOPMAP */
        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
                             (  ( ((os_bit32)(Self_info->CurrentAddress.AL_PA))
                                  << ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ) |
                                     Init_FM_Value                                        ) );
        osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "B %s Frame Manager Configuration %08X",
                    "CFuncInitFM",(char *)agNULL,
                    agNULL,agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration),
                    0,0,0,0,0,0,0);

    }

    /* Frame Manager WWN */

    CFuncDisable_Interrupts(hpRoot,ChipIOUp_INTEN_INT);

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Writing High WWN %08X to %X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    hpSwapBit32(*(os_bit32*) &(Self_info->PortWWN[0])),
                    ChipIOUp_Frame_Manager_World_Wide_Name_High,
                    0,0,0,0,0,0);


    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_World_Wide_Name_High, hpSwapBit32(*(os_bit32*) &(Self_info->PortWWN[0])));

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Writing Low  WWN %08X to %X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    hpSwapBit32(*(os_bit32*)&(Self_info->PortWWN[4])),
                    ChipIOUp_Frame_Manager_World_Wide_Name_Low,
                    0,0,0,0,0,0);


    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_World_Wide_Name_Low, hpSwapBit32(*(os_bit32*) &(Self_info->PortWWN[4])));

    /* Frame Manager Initialize */

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Frame Manager Initialize FM Cfg %08X FM Stat %08X  TL Stat %08X Self ALPA %x",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Configuration),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    0,0,0,0);

    osChipIOUpWriteBit32( hpRoot,ChipIOUp_Frame_Manager_Status, osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ));

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Control, ChipIOUp_Frame_Manager_Control_CMD_Initialize );

    /* Wait for Initialize to complete */

#ifndef OSLayer_Stub

    for( stall_count=0; stall_count < 1000; stall_count++)
    {
        osStallThread(hpRoot,100);
    }

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Init FM LARGE TIME DELAY !!!",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    0,0,0,0,0,0,0,0);
/**/
    if( CFuncClearFrameManager( hpRoot,&Acquired_Alpa ))
    {

        Received_ALPA = (( Acquired_Alpa &
                           ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) >>
                           ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT);

        if(Received_ALPA != 0  &&  Received_ALPA != 0xFF )
        {

        /* Write aquired AL_PA */
        osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Clear FM Failed Self ALPA %x  Received_ALPA %x Acquired_Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    Received_ALPA,
                    Acquired_Alpa,
                    0,0,0,0,0);


        osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, Received_ALPA);

        }
        if( pCThread->LOOP_DOWN )
        {
            if( CFuncLoopDownPoll(hpRoot))
            {

                osLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "%s %s Failed",
                                    "CFuncInitFM","CFuncLoopDownPoll",
                                    (void *)agNULL,(void *)agNULL,
                                    0,0,0,0,0,0,0,0);
                return agFALSE;
            }

        }

    }
#endif  /* OSLayer_Stub */
    /* MULTI for( stall_count=0; stall_count < 10000; stall_count++)
                        osStallThread(hpRoot,100);
    */

    /* Get aquired AL_PA */


#ifdef OSLayer_Stub

    Port_ID.Struct_Form.Domain = pCThread->ChanInfo.CurrentAddress.Domain;
    Port_ID.Struct_Form.Area   = pCThread->ChanInfo.CurrentAddress.Area;
    Port_ID.Struct_Form.AL_PA  = pCThread->ChanInfo.CurrentAddress.AL_PA;
    pCThread->DeviceSelf = DevThreadAlloc( hpRoot,Port_ID );
    fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
    fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);

#else /* OSLayer_Stub */


    Received_ALPA = (( Acquired_Alpa &
                       ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) >>
                       ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT);

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Clear FM OK  Self_info AL_PA %x Received_ALPA %x Acquired_Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    Received_ALPA,
                    Acquired_Alpa,
                    0,0,0,0,0);



    if(Received_ALPA == 0)
    {
        osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "%s %s Failed",
                            "CFuncInitFM","Received_ALPA 0",
                            (void *)agNULL,(void *)agNULL,
                            0,0,0,0,0,0,0,0);

        return agFALSE;
    }

    Port_ID.Struct_Form.Domain = 0;
    Port_ID.Struct_Form.Area   = 0;
    Port_ID.Struct_Form.AL_PA  = (os_bit8)Received_ALPA;
    pCThread->DeviceSelf = DevThreadAlloc( hpRoot,Port_ID );
    fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
    fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "Set Self %p Domain %x Area %x AL_PA %x",
                    (char *)agNULL,(char *)agNULL,
                    pCThread->DeviceSelf,agNULL,
                    Port_ID.Struct_Form.Domain,
                    Port_ID.Struct_Form.Area,
                    Port_ID.Struct_Form.AL_PA,
                    0,0,0,0,0);


#ifdef _BYPASSLOOPMAP
    Frame_Manager_Config |= ChipIOUp_Frame_Manager_Configuration_BLM;
#endif /* _BYPASSLOOPMAP */

#endif  /* OSLayer_Stub */

    Frame_Manager_Config |= (Received_ALPA <<
                            ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT);


    if( Received_ALPA == 0xFF || pCThread->DeviceSelf == (DevThread_t *)agNULL  )
    {
        osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "(%p)Received_ALPA  %08X or pCThread->DeviceSelf == agNULL %p",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,pCThread->DeviceSelf,
                    Received_ALPA,
                    0,0,0,0,0,0,0);

            return agFALSE;
    }


    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
                           ( ChipIOUp_Frame_Manager_Configuration_BLM |
                             ChipIOUp_Frame_Manager_Configuration_AQ  |
                             Frame_Manager_Config                       ));

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "hpRoot %p Frame Manager Status %08X Thread %p SELF AL_PA %X A %08X B %08X ",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,pCThread->DeviceSelf,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status),
                    Received_ALPA,
                    Frame_Manager_Config,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0);



    pCThread->DeviceSelf->DevSlot = DevThreadFindSlot(hpRoot,
                                                      Self_info->CurrentAddress.Domain,
                                                      Self_info->CurrentAddress.Area,
                                                      (os_bit8)Received_ALPA,
                                                      (FC_Port_Name_t *)(&Self_info->PortWWN));

    fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
    fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);

    /* Write aquired AL_PA */
    osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, pCThread->ChanInfo.CurrentAddress.AL_PA);

    osLogDebugString(hpRoot,
                    CFuncLogConsoleERROR,
                    "* Self ALPA %x  Received_ALPA %x Acquired_Alpa %08X Info Alpa %x FM cfg %08X",
                    (char *)agNULL,(char *)agNULL,
                    agNULL,agNULL,
                    (os_bit32)Self_info->CurrentAddress.AL_PA,
                    Received_ALPA,
                    Acquired_Alpa,
                    pCThread->ChanInfo.CurrentAddress.AL_PA,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0);


    return agTRUE;

}

agBOOLEAN  CFuncClearFrameManager( agRoot_t *hpRoot, os_bit32 * Acquired_Alpa )
{
    /* Returns True if  a problem was detected  */
    CThread_t  * pCThread = CThread_ptr(hpRoot);

    os_bit32 FM_Status;
    os_bit32 State_ON_entry    = pCThread->thread_hdr.currentState;
    os_bit32 ALPA              =   0xff;
    agBOOLEAN Received_ALPA = agFALSE;

    FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );
    FM_Status &= ~ChipIOUp_Frame_Manager_Status_OLS;
    FM_Status &= ~ChipIOUp_Frame_Manager_Status_BA;
    /* If Loss of Sync is detected, just bail out */
    if (FM_Status & ChipIOUp_Frame_Manager_Status_LS)
    {
       osLogDebugString(hpRoot,
            CStateLogConsoleERROR,
            "Detected Loss of Sync  %08X FM Config %08X ALPA %08X",
            (char *)agNULL,(char *)agNULL,
            (void *)agNULL,(void *)agNULL,
            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
            0,0,0,0,0,0,0);

       return agTRUE;
    }  
    /* If the loop circuit has been established and the frame manager is
       participating, get the ALPA */

    if( FM_Status & ChipIOUp_Frame_Manager_Status_LP &&
        !( FM_Status & ChipIOUp_Frame_Manager_Status_NP    ))
    {
        ALPA =  osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA )  &
                      ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK;
        * Acquired_Alpa = ALPA;
        ALPA = ALPA >>  ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT;
        pCThread->ChanInfo.CurrentAddress.AL_PA = (os_bit8)ALPA;
        Received_ALPA = agTRUE;
    }
    else
    {
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Can't Acquire ALPA FM Status %08X FM Config %08X ALPA %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0,0);
    }

#ifdef AUTO_DETECT_NPORT
#ifdef NPORT_STUFF

    /* Need to remove the LF check once Tachlite gets its act together
     * and makes sure only the NOS/OLS is set when connected to an
     * NPORT and not the LF bit. LF bit should be used truely for
     * Link failures.
     */
    if (FM_Status & ChipIOUp_Frame_Manager_Status_LF ||
        FM_Status & ChipIOUp_Frame_Manager_Status_OLS)
    {
        osLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "Detected NOS/OLS or Link Failure %08X FM Config %08X ALPA %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                0,0,0,0,0);

        /* Since we are not going to be polling and reading the IMQ, we better
           clear the FM status register so that when we do read the frame manager
           as a result of the interrupt, we do not process this LF or OS again.
         */

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, (ChipIOUp_Frame_Manager_Status_LF | ChipIOUp_Frame_Manager_Status_OLS));
        pCThread->InitAsNport = agTRUE;
        return agFALSE;
    }

#endif  /* NPORT_STUFF */
#endif /* AUTODETECT NPORT */
    if(FM_Status == ChipIOUp_Frame_Manager_Status_LP)
    {
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "(%p)CFuncClearFrameManager Good FM Status %08X FM Config %08X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);

      osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "TL Status %08X TL Control %08X Alpa %08X Acq %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    * Acquired_Alpa,
                    0,0,0,0);

    return(agFALSE);
    }

    osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "(%p)In CFuncClearFrameManager FM Status %08X FM Config %08X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);

    osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "TL Status %08X TL Control %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0,0);

    while(FM_Status != ChipIOUp_Frame_Manager_Status_LP)
    {
        if( pCThread->thread_hdr.currentState == CStateLIPEventStorm         ||
            pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm   ) return(agTRUE);

        if ( FM_Status & ChipIOUp_Frame_Manager_Status_OS )
        {
            osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Out of Sync FM Status %08X FM Config %08X",
                    "CFuncClearFrameManager",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);
            return(agTRUE);
        }


        if( FM_Status & ChipIOUp_Frame_Manager_Status_LS )
        {
            osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s Loss of SIGNAL FM Status %08X FM Config %08X",
                    "CFuncClearFrameManager",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);
            return(agTRUE);
        }


        pCThread->FM_pollingCount = 1;
        if(CFuncInterruptPoll( hpRoot,&pCThread->FM_pollingCount ))
        {
            osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);

            FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );

            if( FM_Status & ChipIOUp_Frame_Manager_Status_LP &&
                !(FM_Status & ChipIOUp_Frame_Manager_Status_NP  ))
            {
                if( ! ( * Acquired_Alpa & ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) )
                {

                    ALPA =  osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA )  &
                                 ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK;
                    /* * Acquired_Alpa = ALPA; */
                    ALPA = ALPA >>  ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT;
                    pCThread->ChanInfo.CurrentAddress.AL_PA = (os_bit8)ALPA;
                    Received_ALPA = agTRUE;
                }
            }
            else
            {
                osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "Can't Acquire ALPA FM Status %08X FM Config %08X ALPA %08X",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                                0,0,0,0,0);
            }

            return(agTRUE);
        }


        FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );


        if( (FM_Status & ChipIOUp_Frame_Manager_Status_LSM_MASK) ==
                                 ChipIOUp_Frame_Manager_Status_LSM_Loop_Fail )
        {
            osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "LSM Loop Fail FM Status %08X FM Config %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);

            osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Loop Fail TL Status %08X TL Control %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0,0);
            return(agTRUE);
        }

        if( State_ON_entry != pCThread->thread_hdr.currentState )
        {
            osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "%s NOT %s  ...Failed",
                                "State_ON_entry","currentState",
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);

            return(agTRUE);
        }

    }

    FM_Status = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );

    if( FM_Status & ChipIOUp_Frame_Manager_Status_LP &&
        FM_Status & ~ChipIOUp_Frame_Manager_Status_NP    )
    {
        if( ! ( * Acquired_Alpa & ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) )
        {
            ALPA =  osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA )  &
                           ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK;
            /* * Acquired_Alpa = ALPA; */
            ALPA = ALPA >>  ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT;
            pCThread->ChanInfo.CurrentAddress.AL_PA = (os_bit8)ALPA;
            Received_ALPA = agTRUE;
        }
    }
    else
    {
        osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Can't Acquire ALPA FM Status %08X FM Config %08X ALPA %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                            osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                            0,0,0,0,0);
    }


    ALPA =  osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA )  &
                   ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK;

    ALPA = ALPA >>  ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT;
    if(ALPA)
    {
            pCThread->ChanInfo.CurrentAddress.AL_PA = (os_bit8)ALPA;
            /* * Acquired_Alpa = ALPA; */
            Received_ALPA = agTRUE;
    }
    osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "(%p)Out CFuncClearFrameManager Loop Good FM Status %08X FM Config %08X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0,0);

    osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "TL Status %08X TL Control %08X Rec Alpa %08X Acq %08X Received_ALPA %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Control ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    * Acquired_Alpa,
                    Received_ALPA,
                    0,0,0);

    return(! Received_ALPA);
}

void CFuncFMCompletion(agRoot_t * hpRoot)
{
    os_bit32 fmStatus;
    agBOOLEAN ResetLOOP       = agFALSE;
    agBOOLEAN LOOP_Cameback   = agFALSE;
    agBOOLEAN Credit_Error    = agFALSE;

    os_bit32 FMIntStatus;
    os_bit32 LoopStatus;
    os_bit32 LoopStateMachine;

    os_bit32 ClearInt = 0;
    os_bit32 BadAL_PA = 0;
    os_bit32 Link_UP_AL_PA = 0;
    FC_Port_ID_t    Port_ID;
    CThread_t         *pCThread = CThread_ptr(hpRoot);
/*
    DevThread_t       *pDevThread;
*/
    SFThread_t        *pSFThread;
    fiList_t      * pList;
    fiList_t      * pDevList;

    pCThread->From_IMQ_Frame_Manager_Status = fmStatus = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );

#ifdef NPORT_STUFF
    if (pCThread->InitAsNport)
    {
        CFuncProcessNportFMCompletion(hpRoot, fmStatus);

        return;
    }
#endif /* NPORT_STUFF */

    /* From here on, We are probably in a Loop topology */

    LoopStatus  = fmStatus & 0xFF000000;

    FMIntStatus  = fmStatus & 0x00FFFF00;

    LoopStateMachine = fmStatus & ChipIOUp_Frame_Manager_Status_LSM_MASK;

    if(LoopStateMachine < 80 )
    {

        if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LUP || FMIntStatus & ChipIOUp_Frame_Manager_Status_LDN)
        {
            Link_UP_AL_PA = ((osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA )  &
                                              ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_MASK) >>
                                               ChipIOUp_Frame_Manager_Received_ALPA_ACQ_ALPA_SHIFT);

            if(  Link_UP_AL_PA !=  pCThread->ChanInfo.CurrentAddress.AL_PA)
            {
                osLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                "G F * Self ALPA %x  FM cfg %08X",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCThread->ChanInfo.CurrentAddress.AL_PA,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                                0,0,0,0,0,0);
            }
        }
    }

    /* Take care of the NOS/OLS. We shouldn't be getting this if we are not
     * in an NPort mode but the fabric may have not yet transitioned....
     */

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_OLS)
    {

        /* osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, FMIntStatus); */

        /* Take the Cthread to ResetIfNeeded State waiting for the Reinit during the
         * the timer tick.
         */
#ifndef DONT_ACT_ON_OLS
        if(pCThread->thread_hdr.currentState == CStateInitializeFailed)
        {
            pCThread->NOS_DetectedInIMQ++;
            FMIntStatus &= ~ChipIOUp_Frame_Manager_Status_OLS;
            osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, FMIntStatus);
            return;
        }
        else
        {
//#ifdef DONT_ACT_ON_OLS
            if(pCThread->thread_hdr.currentState != CStateInitFM_DelayDone &&
               pCThread->thread_hdr.currentState != CStateInitFM    )
            {
                if(pCThread->thread_hdr.currentState == CStateLoopFailedReInit)
                {
                   ClearInt |= ChipIOUp_Frame_Manager_Status_OLS;
                }
                else
                {
                    if(pCThread->thread_hdr.currentState == CStateResetNeeded)
                    {
                       ClearInt |= ChipIOUp_Frame_Manager_Status_OLS;
                    }
                    else
                    {

                        osLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "hpRoot(%p) LOOP OLS/NOS received CState %d",
                                    (char *)agNULL,(char *)agNULL,
                                    hpRoot,agNULL,
                                    pCThread->thread_hdr.currentState,
                                    0,0,0,0,0,0,0);

                        osLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                     "hpRoot(%p) OLS/NOS Reinit the loop, Loop_Reset_Event_to_Send %d",
                                    (char *)agNULL,(char *)agNULL,
                                    hpRoot,agNULL,
                                    pCThread->Loop_Reset_Event_to_Send,
                                    0,0,0,0,0,0,0);
                        /*
                        pCThread->Loop_Reset_Event_to_Send = CEventLoopNeedsReinit;
                        fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);
                        */
                        FMIntStatus &= ~ChipIOUp_Frame_Manager_Status_OLS;
                        osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status, FMIntStatus);
                        pCThread->Loop_Reset_Event_to_Send = CEventLoopNeedsReinit;
                        fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventLoopNeedsReinit);
                        return;
                    }
                }
            }
#endif /* DONT_ACT_ON_OLS */
        }

       ResetLOOP=agTRUE;
 
       ClearInt |= ChipIOUp_Frame_Manager_Status_OLS;
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LF)
    {

        if( pCThread->Link_Failures_In_tick < FC_MAX_LINK_FAILURES_ALLOWED )
        {
            ClearInt |= ChipIOUp_Frame_Manager_Status_LF ;

            if( ! pCThread->Link_Failures_In_tick )
            {
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Link Failure LSM %X FMIntStatus %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,FMIntStatus,0,0,0,0,0,0);
            }

            pCThread->Link_Failures_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }

            ResetLOOP=agFALSE;

        }

    }


    if(LoopStatus & ChipIOUp_Frame_Manager_Status_LP )
    {

        ClearInt |= ChipIOUp_Frame_Manager_Status_LP;

        osLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "hpRoot(%p) Loop Good LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,
                    0,0,0,0,0,0,0);
    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_TP )
    {
        if( pCThread->Transmit_PE_In_tick < FC_MAX_TRANSMIT_PE_ALLOWED )
        {
            ResetLOOP=agTRUE;
            ClearInt |=  ChipIOUp_Frame_Manager_Status_TP ;
            if( ! pCThread->Transmit_PE_In_tick )
            {
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Transmit PE LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Transmit_PE_In_tick++;
        }
        else
        {
            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }

            ResetLOOP=agFALSE;

        }
    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_NP )
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_NP;
        ResetLOOP=agTRUE;
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p)fmStatus %08X Non Particapating LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    fmStatus,
                    LoopStateMachine,
                    0,0,0,0,0,0);
    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_BYP)
    {
        if( pCThread->Node_By_Passed_In_tick < FC_MAX_NODE_BY_PASSED_ALLOWED )
        {
            ClearInt |= ChipIOUp_Frame_Manager_Status_BYP;
            ResetLOOP=agTRUE;
            if( ! pCThread->Node_By_Passed_In_tick )
            {
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Node Bypassed LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Node_By_Passed_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }

            ResetLOOP=agFALSE;

        }

    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_FLT)
    {
        if( pCThread->Lost_sync_In_tick < FC_MAX_LINK_FAULTS_ALLOWED )
        {
            ClearInt |=  ChipIOUp_Frame_Manager_Status_FLT;
            ResetLOOP=agTRUE;
            if( ! pCThread->Link_Fault_In_tick )
            {
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Link Fault LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Link_Fault_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }

            ResetLOOP=agFALSE;

        }

    }
    if(LoopStatus & ChipIOUp_Frame_Manager_Status_OS )
    {

        if( pCThread->Lost_sync_In_tick < FC_MAX_LOSE_OF_SYNC_ALLOWED )
        {
            ClearInt |=  ChipIOUp_Frame_Manager_Status_OS;
            ResetLOOP=agTRUE;
            if( ! pCThread->Lost_sync_In_tick )
            {
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Loop Out of Sync LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Lost_sync_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }
            ResetLOOP=agFALSE;

        }


    }

    if(LoopStatus & ChipIOUp_Frame_Manager_Status_LS )
    {

        if( pCThread->Lost_Signal_In_tick < FC_MAX_LOST_SIGNALS_ALLOWED )
        {
            ClearInt |=  ChipIOUp_Frame_Manager_Status_LS;
            ResetLOOP=agTRUE;
            if( ! pCThread->Lost_Signal_In_tick )
            {
                osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Loop Lost Signal LSM %X",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,0,0,0,0,0,0,0);
            }

            pCThread->Lost_Signal_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
            }
            ResetLOOP=agFALSE;

        }


    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LPE)
    {
        /* ResetLOOP=agTRUE; */
        /* Ignore LPE */
        ClearInt |=ChipIOUp_Frame_Manager_Status_LPE;
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) LPE received LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
    }


    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LPB)
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_LPB;
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Loop ByPass Primitive received LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
    }


    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LST)
    {
        pCThread->Loop_State_TimeOut_In_tick++;
        ClearInt |= ChipIOUp_Frame_Manager_Status_LST;
        if( pCThread->Loop_State_TimeOut_In_tick < FC_MAX_LST_ALLOWED )/* Always zero */
        {
            if( ! pCThread->Loop_State_TimeOut_In_tick )
            {
                osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "hpRoot(%p) Loop State Timeout received LSM %X Cstate %d FMIntStatus %X TL Status %08X",
                                (char *)agNULL,(char *)agNULL,
                                hpRoot,agNULL,
                                LoopStateMachine,
                                pCThread->thread_hdr.currentState,
                                FMIntStatus,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                                0,0,0,0);
            }

        }
        else
        {
            /* ResetLOOP = agTRUE; */
            osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Loop State Timeout Cstate %d FMIntStatus %X TL Status %08X LST count %d",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            pCThread->thread_hdr.currentState,
                            FMIntStatus,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                            pCThread->Loop_State_TimeOut_In_tick,
                            0,0,0,0);

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ))
            {
                if( pCThread->thread_hdr.currentState == CStateNormal  )
                {
                    pCThread->Loop_Reset_Event_to_Send = CEventInitalizeFailure;
                    fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventLoopEventDetected);
                }
                else
                {
                    if( pCThread->thread_hdr.currentState == CStateInitializeFailed  )
                    {
                        ResetLOOP=agFALSE;
                    }
                    else
                    {
                        fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
                        return;
                    }
                }
            }
            else
            {
                ResetLOOP=agFALSE;
            }
        }
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LPF)
    {
        ResetLOOP=agTRUE;
        if( pCThread->Lip_F7_In_tick < FC_MAX_LIP_F7_ALLOWED )
        {
            if( ! pCThread->Lip_F7_In_tick )
            {
                osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "hpRoot(%p) LIPf received LSM %X Rec ALPA Reg %08X Cstate %d FMIntStatus %X",
                                (char *)agNULL,(char *)agNULL,
                                hpRoot,agNULL,
                                LoopStateMachine,
                                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                                pCThread->thread_hdr.currentState,
                                FMIntStatus,0,0,0,0);
            }

            if( 0xF7 ==  (osChipIOUpReadBit32(hpRoot,
                                            ChipIOUp_Frame_Manager_Received_ALPA) &
                                  ChipIOUp_Frame_Manager_Received_ALPA_LIPf_ALPA_MASK ))
            {
                ClearInt |= ChipIOUp_Frame_Manager_Status_LPF;
            }

            ClearInt |= ChipIOUp_Frame_Manager_Status_LPF;

            pCThread->Lip_F7_In_tick++;
        }
        else
        {

            if(!( pCThread->thread_hdr.currentState == CStateSendPrimitive           ||
                  pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm  ||
                  pCThread->thread_hdr.currentState == CStateInitFM_DelayDone        ||
                  pCThread->thread_hdr.currentState == CStateLIPEventStorm              ) )
            {
                    osLogDebugString(hpRoot,
                                    CFuncCheckCstateErrorLevel,
                                    "%s sends %s FM_Status %08X FM_IMQ_Status %08X ",
                                    "CFuncFMCompletion","CEventLIPEventStorm",
                                    (void *)agNULL,(void *)agNULL,
                                    FMIntStatus,
                                    pCThread->From_IMQ_Frame_Manager_Status,
                                    0,0,0,0,0,0);

                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventLIPEventStorm);
            }

            ResetLOOP=agFALSE;
        }

    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_BA)
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_BA;

#ifdef DONT_USE_THIS_ANYMORE
        ClearInt |= ChipIOUp_Frame_Manager_Status_BA;
        BadAL_PA = (osChipIOUpReadBit32(hpRoot,
                            ChipIOUp_Frame_Manager_Received_ALPA)  >>
                            ChipIOUp_Frame_Manager_Received_ALPA_Bad_ALPA_SHIFT) &
                            0xFF;

        if(BadAL_PA )
        {

            osLogDebugString(hpRoot,
                    CStateLogConsoleLevel,
                    "hpRoot(%p) Bad ALPA received %8X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    BadAL_PA,
                    0,0,0,0,0,0,0);

            pDevThread = CFuncMatchALPAtoThread( hpRoot,
                                           (os_bit32)BadAL_PA);
            if(pDevThread != (DevThread_t *)agNULL )
            {
#ifdef MYLEXFAILOVER
                if(pCThread->thread_hdr.currentState == CStateNormal)
                {
                   osFCLayerAsyncEvent( hpRoot, osFCLinkBadALPAFailover );
                }
#endif /* MYLEXFAILOVER */
                if(pDevThread->thread_hdr.currentState == DevStateDoPlogi  )
                {
                    pSFThread = pDevThread->SFThread_Request.SFThread;

                    osLogDebugString(hpRoot,
                        CStateLogConsoleLevel,
                        "pSFThread %p Bad AL_PA",
                        (char *)agNULL,(char *)agNULL,
                        pSFThread,agNULL,
                        0,0,0,0,0,0,0,0);

                    if ((pCThread->DEVID == ChipConfig_DEVID_TachyonTL) && (pCThread->REVID < ChipConfig_REVID_2_2))
                    {
                        fiSendEvent(&pSFThread->thread_hdr,SFEventPlogiBadALPA);
                    }
                }
                else
                {
                ResetLOOP=agTRUE;
                }
            }
            else
            {
                osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "hpRoot(%p)DevThread agNULL ! Really Bad ALPA received %X",
                                (char *)agNULL,(char *)agNULL,
                                hpRoot,agNULL,
                                BadAL_PA,
                                0,0,0,0,0,0,0);
            }
        }
        else
        {
            /* Flogi Type */

            if(pCThread->thread_hdr.currentState == CStateDoFlogi  )
            {

                if ((pCThread->DEVID == ChipConfig_DEVID_TachyonTL) && (pCThread->REVID < ChipConfig_REVID_2_2))
                {

                    pSFThread = pCThread->Calculation.MemoryLayout.SFThread.addr.CachedMemory.cachedMemoryPtr;
                    fiSendEvent(&pSFThread->thread_hdr,SFEventFlogiBadALPA);
                }
            }
            else
            {


                pDevThread = CFuncMatchALPAtoThread( hpRoot,
                                               (os_bit32)BadAL_PA);
                if(pDevThread != (DevThread_t *)agNULL )
                {
                    osLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "hpRoot(%p)DevThread %p ! Really Bad ALPA received %X",
                                    (char *)agNULL,(char *)agNULL,
                                    pDevThread,hpRoot,
                                    BadAL_PA,
                                    0,0,0,0,0,0,0);

                }
                else
                {
                    osLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "hpRoot(%p)DevThread agNULL ! Really Bad ALPA received %X",
                                    (char *)agNULL,(char *)agNULL,
                                    hpRoot,agNULL,
                                    BadAL_PA,
                                    0,0,0,0,0,0,0);
                }
                ResetLOOP=agTRUE;
            }
        }
#endif /* DONT_USE_THIS_ANYMORE */
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_PRX)
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_PRX;

        pCThread->PrimitiveReceived = agTRUE;

        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Primitive received LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_PTX)
    {
        ClearInt |= ChipIOUp_Frame_Manager_Status_PTX;
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Primitive Sent LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);
    }


    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_LG)
    {
        pCThread->FabricLoginRequired = agTRUE;
        ClearInt |= ChipIOUp_Frame_Manager_Status_LG ;
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) FLOGi Required LSM %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,0,0,0,0,0,0,0);

        if (!(FMIntStatus & ~ChipIOUp_Frame_Manager_Status_LG))
        {
            /* We are not acting on this since it is not a reliable mechanism
             * of detecting a fabric yet.
             */
           osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status,ClearInt);
           return;
        }
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_CE)
    {
        Credit_Error = agTRUE;
        ResetLOOP=agTRUE;
        ClearInt |= ChipIOUp_Frame_Manager_Status_CE;
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Credit Error (BB) LSM %X FMIntStatus %X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,FMIntStatus,0,0,0,0,0,0);
    }

    if(FMIntStatus & ChipIOUp_Frame_Manager_Status_EW)
    {
        if( pCThread->Elastic_Store_ERROR_Count < FC_MAX_ELASTIC_STORE_ERRORS_ALLOWED )
        {
            ClearInt |= ChipIOUp_Frame_Manager_Status_EW;
            pCThread->Elastic_Store_ERROR_Count++;
        }
        else
        {
            osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Elastic Store Error LSM %X FMIntStatus %X Cstate %d Count %x",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,FMIntStatus,
                    pCThread->thread_hdr.currentState,
                    pCThread->Elastic_Store_ERROR_Count,0,0,0,0);

            if(!(pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm   ||
                 pCThread->thread_hdr.currentState == CStateInitializeFailed         ||
                 pCThread->thread_hdr.currentState == CStateSendPrimitive                ))
            {

                fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventElasticStoreEventStorm);
    
                ResetLOOP=agTRUE;

                pCThread->Elastic_Store_ERROR_Count=0;
            }

        }

    }

    if( FMIntStatus & ChipIOUp_Frame_Manager_Status_LDN )
    {
        pCThread->LOOP_DOWN = agTRUE;
        pCThread->ChanInfo.LinkUp = agFALSE;
        pCThread->IDLE_RECEIVED = agFALSE;

#ifdef  USE_ADISC_FOR_RECOVERY 
        osLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "F HostCopy ERQ_PROD %x ERQ Cons %x ",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Producer_Index),
                        osChipIOLoReadBit32(hpRoot, ChipIOLo_ERQ_Consumer_Index),
                        0,0,0,0,0,0);
        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);

        osChipIOLoWriteBit32(hpRoot,ChipIOLo_ERQ_Consumer_Index , 
                        osChipIOLoReadBit32(hpRoot,ChipIOLo_ERQ_Producer_Index ));

/*
        CFunc_Check_ERQ_Registers( hpRoot );
*/
#endif /* USE_ADISC_FOR_RECOVERY  */

        ResetLOOP = agTRUE; /* If this is not here after a lip we will not be logged in */

        ClearInt |= ChipIOUp_Frame_Manager_Status_LDN;

        osLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) Link Down LSM %X Cstate %d CDBCnt %x",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        LoopStateMachine,
                        pCThread->thread_hdr.currentState,
                        pCThread->CDBpollingCount,
                        0,0,0,0,0);

        pCThread->LinkDownTime = pCThread->TimeBase;

        osLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "TimeBase %8X %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        pCThread->TimeBase.Hi,
                        pCThread->TimeBase.Lo,
                        0,0,0,0,0,0);

    }

    if( FMIntStatus & ChipIOUp_Frame_Manager_Status_LUP )
    {
        LOOP_Cameback = agTRUE;
        ResetLOOP = agTRUE; /* If this is not here after a lip we will not be logged in */
        ClearInt |= ChipIOUp_Frame_Manager_Status_LUP;
        osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) Link Up LSM %X Cstate %d LD %x IR %x CDBCnt %x",
                            (char *)agNULL,(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,
                            pCThread->thread_hdr.currentState,
                            pCThread->LOOP_DOWN,
                            pCThread->IDLE_RECEIVED,
                            pCThread->CDBpollingCount,
                            0,0,0);
        if ( pCThread->FM_pollingCount > 0 )  pCThread->FM_pollingCount --;
        pCThread->LOOP_DOWN = agFALSE;
        pCThread->ChanInfo.LinkUp = agTRUE;
/************************************/

        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot(%p) Loop Good LSM %X ALPA %x Self ALPA %x CFG %08X",
                    (char *)agNULL,(char *)agNULL,
                    hpRoot,agNULL,
                    LoopStateMachine,
                    Link_UP_AL_PA,
                    pCThread->ChanInfo.CurrentAddress.AL_PA,
                    (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 0xFFFFFF) |
                        ( Link_UP_AL_PA <<  ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ),
                    0,0,0,0);

        if(  Link_UP_AL_PA !=  pCThread->ChanInfo.CurrentAddress.AL_PA)
        {

            pCThread->ALPA_Changed_OnLinkEvent = agTRUE;
            if(Link_UP_AL_PA  != 0 || Link_UP_AL_PA != 0xff)
            {
                osChipIOUpWriteBit32( hpRoot, ChipIOUp_My_ID, Link_UP_AL_PA);

                osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Configuration,
                        (osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ) & 0xFFFFFF) |
                        ( Link_UP_AL_PA <<  ChipIOUp_Frame_Manager_Configuration_AL_PA_SHIFT ));

                osLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                "AF * Self ALPA %x  FM cfg %08X",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCThread->ChanInfo.CurrentAddress.AL_PA,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                                0,0,0,0,0,0);
                if(pCThread->DeviceSelf != agNULL)
                {

                    osLogDebugString(hpRoot,
                                    CFuncLogConsoleERROR,
                                    "pCThread->DeviceSelf != agNULL Empty ? %x On list ? %x",
                                    (char *)agNULL,(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    fiListNotEmpty(&pCThread->DevSelf_NameServer_DevLink ),
                                    fiListElementOnList(&(pCThread->DevSelf_NameServer_DevLink), &(pCThread->DeviceSelf->DevLink)), 
                                    0,0,0,0,0,0);

                    if(fiListNotEmpty(&pCThread->DevSelf_NameServer_DevLink ))
                    {
                        fiListDequeueFromHead(&pDevList, &pCThread->DevSelf_NameServer_DevLink );
                    }
                    fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
                    DevThreadFree(hpRoot,pCThread->DeviceSelf);
                    pCThread->DeviceSelf = agNULL;
                }

                Port_ID.Struct_Form.Domain = 0;
                Port_ID.Struct_Form.Area   = 0;
                Port_ID.Struct_Form.AL_PA  = (os_bit8)Link_UP_AL_PA;

                pCThread->DeviceSelf = DevThreadAlloc( hpRoot,Port_ID );

                pCThread->DeviceSelf->DevSlot = DevThreadFindSlot(hpRoot,
                                                            Port_ID.Struct_Form.Domain,
                                                            Port_ID.Struct_Form.Area,
                                                            Port_ID.Struct_Form.AL_PA,
                                                           (FC_Port_Name_t *)(&pCThread->ChanInfo.PortWWN));

                fiListDequeueThis(&(pCThread->DeviceSelf->DevLink));
                fiListEnqueueAtTail(&(pCThread->DeviceSelf->DevLink),&pCThread->DevSelf_NameServer_DevLink);

                pCThread->ChanInfo.CurrentAddress.AL_PA = Link_UP_AL_PA;

                ResetLOOP=agTRUE;

                osLogDebugString(hpRoot,
                                CFuncLogConsoleERROR,
                                " F * Self ALPA %x  FM cfg %08X",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCThread->ChanInfo.CurrentAddress.AL_PA,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                                0,0,0,0,0,0);

            }
        }

/*****************************************/
        if(pCThread->IDLE_RECEIVED)
        {

            if( CFunc_Always_Enable_Queues(hpRoot ))
            {
                osLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) FM Queues Frozen after enable !",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        0,0,0,0,0,0,0,0);

            }
            else
            {

                pCThread->IDLE_RECEIVED = agFALSE;
                if(fiListNotEmpty(&pCThread->QueueFrozenWaitingSFLink))
                {
                    fiListDequeueFromHeadFast(&pList,
                                        &pCThread->QueueFrozenWaitingSFLink );
                    pSFThread = hpObjectBase(SFThread_t,
                                              SFLink,pList );
                    osLogDebugString(hpRoot,
                                    CStateLogConsoleERROR,
                                    "hpRoot(%p) Starting frozen SFThread %p Event %d",
                                    (char *)agNULL,(char *)agNULL,
                                    hpRoot,pSFThread,
                                    pSFThread->QueuedEvent,
                                    0,0,0,0,0,0,0);

                    if(pSFThread->QueuedEvent )
                    {
                        fiSendEvent(&pSFThread->thread_hdr,(event_t)pSFThread->QueuedEvent);
                    }
                }
            }
        }
    }

    osChipIOUpWriteBit32( hpRoot, ChipIOUp_Frame_Manager_Status,ClearInt);

    if( pCThread->thread_hdr.currentState == CStateInitFM                   ||
        pCThread->thread_hdr.currentState == CStateInitFM_DelayDone         ||
        pCThread->thread_hdr.currentState == CStateResetNeeded              ||
        pCThread->thread_hdr.currentState == CStateLIPEventStorm            ||
        pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm   ||
        pCThread->thread_hdr.currentState == CStateInitializeFailed         ||
        pCThread->thread_hdr.currentState == CStateReInitFM                 ||
        pCThread->thread_hdr.currentState == CStateSendPrimitive                )
    {

        if( ! ( pCThread->thread_hdr.currentState == CStateInitializeFailed &&
                LOOP_Cameback == agTRUE                                           ))
        {
                ResetLOOP = agFALSE;
        }


    }


    if (ResetLOOP)
    {
        fmStatus = osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status );

        osLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "About to ResetLOOP FM Status %08X TL Status %08X CState %d",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        fmStatus,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                        pCThread->thread_hdr.currentState,
                        0,0,0,0,0);


        if(pCThread->LoopPreviousSuccess)
        {
            if (Credit_Error)
            {
                pCThread->Loop_Reset_Event_to_Send = CEventLoopNeedsReinit;
            }
            else
            {
                pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
            }

        }
        else
        {
            if( CFuncAll_clear( hpRoot ) )
            {
                pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;

                osLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) ResetLOOP LSM %X Cstate %d sends %s (%d)",
                        "CEventLoopNeedsReinit",(char *)agNULL,
                        hpRoot,agNULL,
                        LoopStateMachine,
                        pCThread->thread_hdr.currentState,
                        CEventAsyncLoopEventDetected,0,0,0,0,0);

            }
            else
            {
                if( pCThread->thread_hdr.currentState == CStateLoopFailedReInit )
                {

                    pCThread->Loop_Reset_Event_to_Send = CEventInitalize;
                }
                else
                {
                    /* WAS pCThread->Loop_Reset_Event_to_Send = CEventLoopNeedsReinit; */
                    pCThread->Loop_Reset_Event_to_Send = CEventLoopEventDetected;

                    osLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "hpRoot(%p) ResetLOOP LSM %X Cstate %d sends %s (%d)",
                            "CEventLoopNeedsReinit",(char *)agNULL,
                            hpRoot,agNULL,
                            LoopStateMachine,
                            pCThread->thread_hdr.currentState,
                            CEventLoopNeedsReinit,0,0,0,0,0);
                }
            }
        }

        osLogDebugString(hpRoot,
                        CStateLogConsoleERROR,
                        "hpRoot(%p) ResetLOOP LSM %X Cstate %d sends (%d) Event to send %d",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,agNULL,
                        LoopStateMachine,
                        pCThread->thread_hdr.currentState,
                        CEventAsyncLoopEventDetected,
                        pCThread->Loop_Reset_Event_to_Send,
                        0,0,0,0);

        fiSendEvent(&(CThread_ptr(hpRoot)->thread_hdr),CEventAsyncLoopEventDetected);

    }
}

/*CStateDoFlogi               7*/
extern void CActionDoFlogi( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t *hpRoot= thread->hpRoot;
    CThread_t  * pCThread = CThread_ptr( hpRoot);


    SFThread_t  * pSFThread = pCThread->SFThread_Request.SFThread;
    pSFThread->parent.Device= (DevThread_t *)agNULL;

    CFuncYellowLed(thread->hpRoot, agFALSE);

    osLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p Before %s - State = %d",
                    "CActionDoFlogi",(char *)agNULL,
                    thread->hpRoot,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    /* DRL find dev thread*/
    CFuncShowWhereDevThreadsAre( hpRoot);

    fiSetEventRecordNull(eventRecord);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoFlogi);

    if(CFuncInterruptPoll( hpRoot,&pCThread->FLOGI_pollingCount ))
    {
        osLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Flogi Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
        osLogString(thread->hpRoot,
                    "DoFLogi TimeOut FMStatus %X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    0,0,0,0,0,0,0);
        if( CFunc_Queues_Frozen(hpRoot ))
        {
            /* WAS */
            fiSetEventRecord(eventRecord,thread,CEventFlogiFail);
        }
        else
        {

            SFThreadFree(thread->hpRoot, & pCThread->SFThread_Request );
            pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;
            pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
            fiSetEventRecord(eventRecord,thread,CEventAsyncLoopEventDetected);
        }

    }
    else
    {
        /* SFState is Set in the SF State machine */
        if( pSFThread->thread_hdr.currentState == SFStateFlogiAccept)
        {
            fiSetEventRecord(eventRecord,thread,CEventFlogiSuccess);
        }
        else
        {
            if( pSFThread->thread_hdr.currentState == SFStateFlogiBadALPA )
            {
                osLogString(thread->hpRoot,
                                "Do FLogi Fail Bad ALPA",
                                (char *)agNULL,(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                0,0,0,0,0,0,0,0);

                fiSetEventRecord(eventRecord,thread,CEventFlogiFail);
                pCThread->FlogiSucceeded = agFALSE;
                pCThread->DeviceDiscoveryMethod = ScanAllALPAs;
            }
            else
            {

                if( pSFThread->thread_hdr.currentState == SFStateFlogiRej )
                {
                    osLogString(thread->hpRoot,
                                    "Do FLogi Fail %s",
                                    "SFStateFlogiRej",(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    0,0,0,0,0,0,0,0);
                    fiSetEventRecord(eventRecord,thread,CEventFlogiFail);
                    pCThread->FlogiSucceeded = agFALSE;

                    if (pCThread->InitAsNport)
                    {
                       fiSetEventRecord(eventRecord,thread, CEventInitalizeFailure );
                       return;
                    }

                    pCThread->DeviceDiscoveryMethod = ScanAllALPAs;
                }
                else
                {
                    osLogString(thread->hpRoot,
                                    "Do FLogi Failed SFstate %d",
                                    (char *)agNULL,(char *)agNULL,

                                    (void *)agNULL,(void *)agNULL,
                                    (os_bit32)pSFThread->thread_hdr.currentState,
                                    0,0,0,0,0,0,0);
            
                    SFThreadFree(thread->hpRoot, & pCThread->SFThread_Request );
                    pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;

                    pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
                    fiSetEventRecord(eventRecord,thread,CEventAsyncLoopEventDetected);
    /*
                  fiSetEventRecord(eventRecord,thread,CEventFlogiFail);
    */                
                }
            }
        }

    }
/*
    CFuncShowWhereDevThreadsAre( hpRoot, agTRUE );
*/
    osLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "hpRoot %p After  %s - State = %d SFThread %p SFState %d FDcnt %x",
                    "CActionDoFlogi",(char *)agNULL,
                    thread->hpRoot,pSFThread,
                    (os_bit32)thread->currentState,
                    (os_bit32)pSFThread->thread_hdr.currentState,
                    pCThread->FindDEV_pollingCount,
                    0,0,0,0,0);


}


agBOOLEAN CFuncSearchOffCardIMQ( agRoot_t *hpRoot, os_bit32 X_ID  )
{
#ifndef __MemMap_Force_On_Card__
    /*
        Returns agTRUE if X_ID Found agFALSE if not

    */

    CThread_t  * pCThread = CThread_ptr(hpRoot);

    agBOOLEAN Found = agFALSE;

    os_bit32 tempIMQProdIndex;
    os_bit32 tempCMType;

    os_bit32 num_IMQel;
    os_bit32 Sest_Index;

    CM_Unknown_t                * pGenericCM;
    CM_Inbound_FCP_Exchange_t   * pInbound_FCP_Exchange;
    CM_Outbound_t               * pOutbound;
    CM_Inbound_t                * pInbound;

    num_IMQel = pCThread->Calculation.MemoryLayout.IMQ.elements;

    while (tempIMQProdIndex < num_IMQel)
    {
        pGenericCM  = pCThread->Calculation.MemoryLayout.IMQ.addr.DmaMemory.dmaMemoryPtr;
        pGenericCM += tempIMQProdIndex;
        tempCMType  = pGenericCM->INT__CM_Type & CM_Unknown_CM_Type_MASK;
       /*
       ** get the completion message type
       */

        switch (tempCMType) {

            case  CM_Unknown_CM_Type_Inbound_FCP_Exchange:
                    pInbound_FCP_Exchange = (CM_Inbound_FCP_Exchange_t    *)pGenericCM;
                    Sest_Index = pInbound_FCP_Exchange->Bits__SEST_Index & CM_Inbound_FCP_Exchange_SEST_Index_MASK;
                    if( X_ID == Sest_Index)
                    {
                        osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "%s Inbound_FCP_Exchange IMQ Entry %X",
                                "CFuncSearchOffCardIMQ",(char *)agNULL,
                                agNULL,agNULL,
                                tempIMQProdIndex,
                                0,0,0,0,0,0,0);
                        Found = agTRUE;
                    }
                break;


            case  CM_Unknown_CM_Type_Inbound:
                    pInbound  = ( CM_Inbound_t   *)pGenericCM;
                    Sest_Index = pInbound->SFQ_Prod_Index & CM_Inbound_SFQ_Prod_Index_MASK;

                    if( X_ID == Sest_Index)
                    {

                        osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "%s Inbound IMQ Entry %X",
                                "CFuncSearchOffCardIMQ",(char *)agNULL,
                                agNULL,agNULL,
                                tempIMQProdIndex,0,0,0,0,0,0,0);
                        Found = agTRUE;
                    }

                    break;

            case  CM_Unknown_CM_Type_Outbound:
                    pOutbound = ( CM_Outbound_t   *)pGenericCM;
                    Sest_Index = pOutbound->Bits__SEST_Index__Trans_ID & CM_Outbound_SEST_Index_MASK;
                    if( X_ID == Sest_Index)
                    {
                        osLogDebugString(hpRoot,
                                CStateLogConsoleERROR,
                                "%s Outbound %08X  %08X %08X %08X IMQ Entry %X",
                                "CFuncSearchOffCardIMQ",(char *)agNULL,
                                agNULL,agNULL,
                                tempIMQProdIndex,0,0,0,0,0,0,0);
                        Found = agTRUE;
                    }
                break;

            case  CM_Unknown_CM_Type_Frame_Manager:
                break;
            case  CM_Unknown_CM_Type_Error_Idle:
                break;
            case  CM_Unknown_CM_Type_ERQ_Frozen:
                break;
            case  CM_Unknown_CM_Type_FCP_Assists_Frozen:
                break;
            case  CM_Unknown_CM_Type_Class_2_Frame_Header:
                break;
            case  CM_Unknown_CM_Type_Class_2_Sequence_Received:
                break;
            default:
                osLogDebugString(hpRoot,
                            CStateLogConsoleLevel,
                            "Unknown IMQ Completion Type %08X %08X %08X %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            tempCMType,
                            pGenericCM->Unused_DWord_1,
                            pGenericCM->Unused_DWord_2,
                            pGenericCM->Unused_DWord_3,
                            pGenericCM->Unused_DWord_4,
                            0,0,0);
            }
            ROLL(tempIMQProdIndex,num_IMQel);
        }

    return (Found);

#endif

}


#endif /* OBSOLETE_FUNCTIONS  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\devstate.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/DEVSTATE.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 7/28/00 3:47p   $

Purpose:

  This file defines the macros, types, and data structures
  used by ../C/DevState.C

--*/

#ifndef __DevState_H__
#define __DevState_H__

#define  PLOGI_REASON_VERIFY_ALPA  1
#define  PLOGI_REASON_DEVICE_LOGIN 2
#define  PLOGI_REASON_SOFT_RESET   3
#define  PLOGI_REASON_HEART_BEAT   4
#define  PLOGI_REASON_DIR_LOGIN    5

#define  DevStateConfused                      0
#define  DevStateHandleEmpty                   1
#define  DevStateAllocSFThread                 2
#define  DevStateDoPlogi                       3
#define  DevStatePlogiDone                     4
#define  DevStateDoPrli                        5
#define  DevStatePrliDone                      6
#define  DevStateMatchWWN                      7
#define  DevStateSlotNew                       8
#define  DevStateSlotKnown                     9
#define  DevStateHandleAvailable               10 /**/
#define  DevStateLoginFailed                   11
#define  DevStateLogout                        12
#define  DevStateAllocDeviceResetSoft          13
#define  DevStateAllocDeviceResetHard          14
#define  DevStateDeviceResetSoft               15
#define  DevStateDeviceResetHard               16
#define  DevStateDeviceResetDone               17

#define  DevStateAL_PA_Self_OK                 18
#define  DevStateAL_PA_Self_BAD                19

#define  DevStateDeviceResetDoneFAIL           20

#define  DevStateAllocAdisc                    21
#define  DevStateAdisc                         22
#define  DevStateAdiscDone_OK                  23
#define  DevStateAdiscDone_FAIL_No_Device      24
#define  DevStateAdiscDone_FAIL_ReLogin        30

#define  DevStateTickVerifyALPA                25
#define  DevStateExternalDeviceReset           26
#define  DevStateTickGotSFThread               27

#define  DevState_IO_Ready                     28 /**/
#define  DevState_FC_TAPE_Recovery             29 /**/
#define  DevStateNoDevice                      31 /**/

#define  DevStateMAXState  DevStateNoDevice

#define  DevEventConfused                     0
#define  DevEventLogin                        1
#define  DevEventGotSFThread                  2
#define  DevEventPlogiSuccess                 3
#define  DevEventDoPrli                       4
#define  DevEventPrliSuccess                  5
#define  DevEventCheckWWN                     6
#define  DevEventNoMatchWWN                   7
#define  DevEventMatchWWN                     8
#define  DevEventAvailable                    9

#define  DevEventPlogiFailed                  10
#define  DevEventPrliFailed                   11
#define  DevEventLoggedOut                    12

#define  DevEventAllocDeviceResetSoft         13
#define  DevEventAllocDeviceResetHard         14
#define  DevEventDeviceResetSoft              15
#define  DevEventDeviceResetHard              16

#define  DevEventDeviceResetDone              17
#define  DevEventDeviceResetDoneFail          20


#define  DevEventAL_PA_Self_OK                18
#define  DevEventAL_PA_Self_BAD               19

#define  DevEventAllocAdisc                   21
#define  DevEventAdisc                        22
#define  DevEventAdiscDone_OK                 23
#define  DevEventAdiscDone_FAIL_No_Device     24
#define  DevEventAdiscDone_FAIL_ReLogin       31

#define  DevEventDoTickVerifyALPA             25
#define  DevEventTickGotSFThread              27

#define  DevEventExternalDeviceReset          26

#define  DevEventExternalLogout               28
#define  DevEventSendIO                       29
#define  DevEvent_FC_TAPE_Recovery            30
#define  DevEvent_Device_Gone                 32

#define  DevEventMAXEvent  DevEvent_Device_Gone


STATE_PROTO(DevActionConfused       );
STATE_PROTO(DevActionHandleEmpty    );
STATE_PROTO(DevActionAllocSFThread  );
STATE_PROTO(DevActionDoPlogi        );
STATE_PROTO(DevActionPlogiDone      );
STATE_PROTO(DevActionDoPrli         );
STATE_PROTO(DevActionPrliDone       );
STATE_PROTO(DevActionMatchWWN       );
STATE_PROTO(DevActionSlotNew        );
STATE_PROTO(DevActionSlotKnown      );
STATE_PROTO(DevActionAvailable      );

STATE_PROTO(DevActionLoginFailed    );
STATE_PROTO(DevActionLogout         );

STATE_PROTO(DevActionAllocDeviceResetSoft );
STATE_PROTO(DevActionAllocDeviceResetHard );

STATE_PROTO(DevActionDeviceResetSoft );
STATE_PROTO(DevActionDeviceResetHard );
STATE_PROTO(DevActionDeviceResetDone );
STATE_PROTO(DevActionDeviceResetDoneFAIL );


STATE_PROTO(DevActionAL_PA_Self_OK   );
STATE_PROTO(DevActionAL_PA_Self_BAD  );

STATE_PROTO(DevActionAllocAdisc    );
STATE_PROTO(DevActionAdisc          );
STATE_PROTO(DevActionAdiscDone_OK   );
STATE_PROTO(DevActionAdiscDone_FAIL_No_Device );
STATE_PROTO(DevActionAdiscDone_FAIL_ReLogin );

STATE_PROTO(DevActionTickVerifyALPA  );
STATE_PROTO(DevActionTickGotSFThread );

STATE_PROTO(DevActionExternalDeviceReset   );
STATE_PROTO(DevAction_IO_Ready );
STATE_PROTO(DevAction_FC_TAPE_Recovery  );
STATE_PROTO(DevActionNoDevice );
 


#define DEVSTATE_NOISE( hpRoot, State ) (CThread_ptr(hpRoot)->thread_hdr.currentState == State ? DevStateLogConsoleLevel : DevStateLogErrorLevel )

extern stateTransitionMatrix_t DevStateTransitionMatrix;
extern stateActionScalar_t DevStateActionScalar;

#ifdef USESTATEMACROS

void testDevthread( agRoot_t *hpRoot  );

#define DEVSTATE_FUNCTION_ACTION( x , Action) extern void x( fi_thread__t * thread, \
                 eventRecord_t * eventRecord ){         \
    agRoot_t * hpRoot=thread->hpRoot;                   \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d",             \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "Sends event...%s %d",            \
                      #Action,(char *)agNULL,             \
                      (void * )agNULL,(void * )agNULL,  \
                      Action,0,0,0,0,0,0,0);            \
    fiSetEventRecord(eventRecord, thread, Action);   }  \

#define DEVSTATE_FUNCTION_TERMINATE(x) extern void x(fi_thread__t *thread,\
                                      eventRecord_t *eventRecord ){\
    agRoot_t * hpRoot=thread->hpRoot;                   \
    CThread_t  * pCThread=CThread_ptr(hpRoot);          \
    CDBThread_t * pCDBThread=(CDBThread_t * )thread;    \
    DevThread_t * pDevThread=pCDBThread->Device;        \
    osLogDebugString(hpRoot,                            \
                      StateLogConsoleLevel,             \
                      "In %s - State = %d",     \
                      #x,(char *)agNULL,                  \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,      \
                      0,0,0,0,0,0,0);                   \
    osLogDebugString(thread->hpRoot,                    \
                      StateLogConsoleLevel,             \
                      "...simply returns",            \
                      (char *)agNULL,(char *)agNULL,        \
                      (void * )agNULL,(void * )agNULL,  \
                      0,0,0,0,0,0,0,0);                 \
    eventRecord->thread = agNULL;                         \
    }\

#define DEVSTATE_FUNCTION_MULTI_ACTION(x,Action0,Action1,Action2,Action3) extern void x( fi_thread__t *thread,\
                                      eventRecord_t *eventRecord ){ \
    agRoot_t * hpRoot = thread->hpRoot;               \
    os_bit8 WhichAction[4];                              \
    static  os_bit32 ActionCount=0;                      \
    WhichAction[0] = Action0;                         \
    WhichAction[1] = Action1;                         \
    WhichAction[2] = Action2;                         \
    WhichAction[3] = Action3;                         \
    osLogDebugString(thread->hpRoot,                  \
                      StateLogConsoleLevel,           \
                      "In %s - State = %d",           \
                      #x,(char *)agNULL,                \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)thread->currentState,    \
                      0,0,0,0,0,0,0);                 \
    osLogDebugString(thread->hpRoot,                  \
                      StateLogConsoleLevel,           \
                      "...returns event %s %d",       \
                      #Action0,#Action1,              \
                      (void * )agNULL,(void * )agNULL,  \
                      (os_bit32)WhichAction[ActionCount],\
                      0,0,0,0,0,0,0);                 \
    osLogDebugString(thread->hpRoot,                  \
                      StateLogConsoleLevel,           \
                      "or %s  or %s",                 \
                      #Action2,#Action3,              \
                      (void * )agNULL,(void * )agNULL,  \
                      0,0,0,0,0,0,0,0);               \
    fiSetEventRecord(eventRecord,thread,WhichAction[ActionCount]);  \
    if(ActionCount<3)ActionCount++;                   \
    else ActionCount =0;                              \
    }                                                 \

#ifdef TestDevStateMachine

char * DevStateString[]=
{

    "DevStateConfused                 ",
    "DevStateHandleEmpty              ",
    "DevStateAllocSFThread            ",
    "DevStateDoPlogi                  ",
    "DevStatePlogiDone                ",
    "DevStateDoPrli                   ",
    "DevStatePrliDone                 ",
    "DevStateMatchWWN                 ",
    "DevStateSlotNew                  ",
    "DevStateSlotKnown                ",
    "DevStateHandleAvailable          ",
    "DevStateLoginFailed              ",
    "DevStateLogout                   ",
    "DevStateAllocDeviceResetSoft     ",
    "DevStateAllocDeviceResetHard     ",
    "DevStateDeviceResetSoft          ",
    "DevStateDeviceResetHard          ",
    "DevStateDeviceResetDone          ",
    "DevStateAL_PA_Self_OK            ",
    "DevStateAL_PA_Self_BAD           ",
    "DevStateDeviceResetDoneFAIL      ",
    "DevStateAllocAdisc               ",
    "DevStateAdisc                    ",
    "DevStateAdiscDone_OK             ",
    "DevStateAdiscDone_FAIL_No_Device ",
    "DevStateAdiscDone_FAIL_ReLogin   ",
    "DevStateTickVerifyALPA           ",
    "DevStateExternalDeviceReset      ",
    "DevStateTickGotSFThread          ",
    "DevState_IO_Ready                ",
    "DevState_FC_TAPE_Recovery        ",
    "DevStateNoDevice                 ",
    agNULL

};

char * DevEventString[]=
{
    "DevEventConfused                 ",
    "DevEventLogin                    ",
    "DevEventGotSFThread              ",
    "DevEventPlogiSuccess             ",
    "DevEventDoPrli                   ",
    "DevEventPrliSuccess              ",
    "DevEventCheckWWN                 ",
    "DevEventNoMatchWWN               ",
    "DevEventMatchWWN                 ",
    "DevEventAvailable                ",
    "DevEventPlogiFailed              ",
    "DevEventPrliFailed               ",
    "DevEventLoggedOut                ",
    "DevEventAllocDeviceResetSoft     ",
    "DevEventAllocDeviceResetHard     ",
    "DevEventDeviceResetSoft          ",
    "DevEventDeviceResetHard          ",
    "DevEventDeviceResetDone          ",
    "DevEventDeviceResetDoneFail      ",
    "DevEventAL_PA_Self_OK            ",
    "DevEventAL_PA_Self_BAD           ",
    "DevEventAllocAdisc               ",
    "DevEventAdisc                    ",
    "DevEventAdiscDone_OK             ",
    "DevEventAdiscDone_FAIL_No_Device ",
    "DevEventAdiscDone_FAIL_ReLogin   ",
    "DevEventDoTickVerifyALPA         ",
    "DevEventTickGotSFThread          ",
    "DevEventExternalDeviceReset      ",
    "DevEventExternalLogout           ",
    "DevEventSendIO                   ",
    "DevEvent_FC_TAPE_Recovery        ",
    "DevEvent_Device_Gone             ",
    agNULL

};


#endif /* TestDevStateMachine was defined */

#endif /* USESTATEMACROS was defined */

#endif /*  __DevState_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\dbgsport.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    Dbgsport.c

Abstract:

    Use to debug Scsiport Calls

Authors:

    LP - Leopold Purwadihardja

Environment:

    kernel mode only

Version Control Information:

    $Archive: /Drivers/Win2000/Trunk/OSLayer/C/dbgsport.c $

Revision History:

    $Revision: 4 $
    $Date: 10/23/00 5:36p $
    $Modtime:: 10/18/00 $

--*/


#include "buildop.h"       //LP021100 build switches

#include "osflags.h"
#include "hhba5100.ver"

#include "stdarg.h"

#ifdef _DEBUG_SCSIPORT_NOTIFICATION_

/*++

Routine Description:

    For debugging purpose, If enabled, it'll be used to trap all calls to SP
    the call is defined as
    VOID 
    ScsiPortNotification(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
      // Additional parameters, as required by the given NotificationType 
      // for RequestComplete add: 
    IN PSCSI_REQUEST_BLOCK Srb
      // for NextLuRequest add:  
    IN UCHAR PathId, 
    IN UCHAR TargetId, 
    IN UCHAR Lun 
      // for CallEnableInterrupts or CallDisableInterrupts add:  
    IN PHW_INTERRUPT  HwScsiXxxInterruptsCallback
      // for RequestTimerCall add:  
    IN PHW_TIMER  HwScsiTimer,
    IN ULONG MiniportTimerValue
      // for BusChangeDetected add:  
    IN UCHAR PathId
      // for WMIEvent add:  
    IN PVOID WMIEvent,
    IN UCHAR PathID,
      // if PathId != 0xFF also add: 
    IN UCHAR TargetId,
    IN UCHAR Lun
      // for WMIReregister, add: 
    IN UCHAR PathId,
      // if PathId != 0xFF also add: 
    IN UCHAR TargetId
    IN UCHAR Lun

Arguments:

Return Value:
++*/

#undef  ScsiPortNotification                 /* must be undefined, otherwise it'll recurse */
VOID
Local_ScsiPortNotification(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    )
{
    va_list           ap;
   
    va_start(ap, HwDeviceExtension);
    switch (NotificationType)
    {
        case NextRequest:
        {
            #ifdef DBGPRINT_IO
            if (gDbgPrintIo & DBGPRINT_SCSIPORT_NextRequest)
            {
                static   count;
                UCHAR    *uptr;
                osDEBUGPRINT((ALWAYS_PRINT, "SPReq(%-4d) %d.%d.%d- NextRequest on %x\n",
                    count++,
                    0,0,0,
                    HwDeviceExtension));
            }
            #endif   
            ScsiPortNotification(NotificationType, HwDeviceExtension);
            break;
        }
           
        case ResetDetected:
        {
            #ifdef DBGPRINT_IO
            if (gDbgPrintIo & DBGPRINT_SCSIPORT_ResetDetected)
            {
                static   count;
                UCHAR    *uptr;
         
                osDEBUGPRINT((ALWAYS_PRINT, "SPRst(%-4d) %d.%d.%d- Reset On %x\n",
                    count++,
                    0,0,0,
                    HwDeviceExtension));
            }
            #endif   
            ScsiPortNotification(NotificationType, HwDeviceExtension);
            break;
        }
        
         
        case RequestComplete:
        {
            PSCSI_REQUEST_BLOCK     pSrb;
      
            pSrb = va_arg(ap, void *);

            #ifdef DBGPRINT_IO
            if (gDbgPrintIo & DBGPRINT_SCSIPORT_RequestComplete)
            {
                static   count;
                UCHAR    *uptr;
         
                osDEBUGPRINT((ALWAYS_PRINT, "SPCom(%-4d) %d.%d.%d-%02x%02x%02x%02x %02x%02x%02x%02x %02x%02x Srb=%x Sta=%x.%x\n",
                    count++,
                    pSrb->PathId,
                    pSrb->TargetId,
                    pSrb->Lun,
                    pSrb->Cdb[0],pSrb->Cdb[1],pSrb->Cdb[2],pSrb->Cdb[3],pSrb->Cdb[4],
                    pSrb->Cdb[5],pSrb->Cdb[6],pSrb->Cdb[7],pSrb->Cdb[8],pSrb->Cdb[9], 
                    pSrb,
                    pSrb->SrbStatus,
                    pSrb->ScsiStatus));
            }
            #endif   
            ScsiPortNotification(NotificationType, HwDeviceExtension, pSrb);
            break;
        }
                 
        case NextLuRequest: 
        {
            UCHAR PathId; 
            UCHAR TargetId; 
            UCHAR Lun;
         
            PathId = va_arg(ap, UCHAR); 
            TargetId = va_arg(ap, UCHAR); 
            Lun = va_arg(ap, UCHAR);
            
            #ifdef DBGPRINT_IO
            if (gDbgPrintIo & DBGPRINT_SCSIPORT_NextLuRequest)
            {
                static   count;
                UCHAR    *uptr;
                osDEBUGPRINT((ALWAYS_PRINT, "SPxLu(%-4d) %d.%d.%d- Next Lu request\n",
                    count++,
                    PathId,
                    TargetId,
                    Lun));
            }
            #endif   
            ScsiPortNotification(NotificationType, HwDeviceExtension, PathId, TargetId, Lun);
            break;
        }
        
          
        case CallEnableInterrupts:
        case CallDisableInterrupts: 
        {
            PHW_INTERRUPT  HwScsiXxxInterruptsCallback;
         
            HwScsiXxxInterruptsCallback = va_arg(ap, PHW_INTERRUPT); 
         
            ScsiPortNotification(NotificationType, HwDeviceExtension, HwScsiXxxInterruptsCallback);
            break;
        }
        
      
        case RequestTimerCall:
        {
            PHW_TIMER  HwScsiTimer;
            ULONG MiniportTimerValue;
   
            HwScsiTimer = va_arg(ap, PHW_TIMER);
            MiniportTimerValue = va_arg(ap, ULONG);
   
            ScsiPortNotification(NotificationType, HwDeviceExtension, HwScsiTimer, MiniportTimerValue);
            break;
        }
      
    #ifdef HP_NT50    
        case BusChangeDetected:
        {
            UCHAR PathId;
         
            PathId = va_arg(ap, UCHAR); 
         
            ScsiPortNotification(NotificationType, HwDeviceExtension, PathId);
         
            break;
        }
        
         
        case WMIEvent:
        {
            PVOID WMIEvent;
            UCHAR PathId;
         
            /* if PathId != 0xFF also add: */
            UCHAR TargetId;
            UCHAR Lun;
         
            WMIEvent = va_arg(ap, PVOID); 
            PathId = va_arg(ap, UCHAR);
            if (PathId != 0xff)
            {
                TargetId = va_arg(ap, UCHAR);
                Lun = va_arg(ap, UCHAR);
                ScsiPortNotification(NotificationType, HwDeviceExtension, PathId, TargetId, Lun);
            }
            else
            {
                ScsiPortNotification(NotificationType, HwDeviceExtension, PathId);
            }
            break;
        }
      
         
        case WMIReregister:
        {
            UCHAR PathId;
            /* if PathId != 0xFF also add: */
            UCHAR TargetId;
            UCHAR Lun;

            PathId = va_arg(ap, UCHAR);
            if (PathId != 0xff)
            {
                TargetId = va_arg(ap, UCHAR);
                Lun = va_arg(ap, UCHAR);
                ScsiPortNotification(NotificationType, HwDeviceExtension, PathId, TargetId, Lun);
            }
            else
            {
                ScsiPortNotification(NotificationType, HwDeviceExtension, PathId);
            }
            break;
        }
      
    #endif
    }
    va_end(ap);
}

#endif



#ifdef _DEBUG_REPORT_LUNS_
void PrintReportLunData(PSCSI_REQUEST_BLOCK pSrb)
{
    UCHAR *ptr;
    ULONG count;

    count = pSrb->DataTransferLength/8;
    ptr = (UCHAR*) pSrb->DataBuffer;
    if (!ptr)
        return;
    osDEBUGPRINT((ALWAYS_PRINT,"PrintReportLunData: Buffer = %x Length = %d\n", ptr, pSrb->DataTransferLength));
            
    for (count = 0; count < pSrb->DataTransferLength/8; count++)
    {
        osDEBUGPRINT((ALWAYS_PRINT,"%02x%02x%02x%02x %02x%02x%02x%02x -",
            ptr[0],ptr[1],ptr[2],ptr[3],ptr[4],ptr[5],ptr[6],ptr[7]));
            ptr += 8;
        if (!(count % 4)) 
            osDEBUGPRINT((ALWAYS_PRINT,"\n"));
            
    }
    osDEBUGPRINT((ALWAYS_PRINT,"\n"));
         
}

#undef ScsiPortCompleteRequest
VOID 
Local_ScsiPortCompleteRequest(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    )
{
    #ifdef DBGPRINT_IO
    if (gDbgPrintIo & DBGPRINT_SCSIPORT_ScsiportCompleteRequest)
    {
        static   count;
        osDEBUGPRINT((ALWAYS_PRINT, "SPAll(%-4d) %d.%d.%d- ScsiportCompleteRequest status = %xx\n",
            count++,
            PathId,
            TargetId,
            Lun,
            (ULONG) SrbStatus));
    }
    #endif   
   
    ScsiPortCompleteRequest(HwDeviceExtension, PathId, TargetId, Lun, SrbStatus);
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\err_code.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   dupntdef.c

Abstract:

Authors:

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/ERR_CODE.H $


Revision History:

   $Revision: 2 $
   $Date: 9/07/00 11:14a $
   $Modtime:: 8/31/00 3:34p            $

Notes:


--*/

#ifndef __ERR_CODE_H__
#define __ERR_CODE_H__

#define ERR_VALIDATE_IOLBASE    0x00400000
#define ERR_MAP_IOLBASE         0x00300000
#define ERR_MAP_IOUPBASE        0x00200000
#define ERR_MAP_MEMIOBASE       0x00100000

#define ERR_UNCACHED_EXTENSION  0xe0000000
#define ERR_CACHED_EXTENSION    0xd0000000
#define ERR_RESET_FAILED        0xc0000000
#define ERR_ALIGN_QUEUE_BUF     0xb0000000
#define ERR_ACQUIRED_ALPA       0xa0000000
#define ERR_RECEIVED_LIPF_ALPA  0x90000000
#define ERR_RECEIVED_BAD_ALPA   0x80000000
#define ERR_CM_RECEIVED         0x70000000
#define ERR_INT_STATUS          0x60000000
#define ERR_FM_STATUS           0x50000000
#define ERR_PLOGI               0x40000000
#define ERR_PDISC               0x30000000
#define ERR_ADISC               0x20000000
#define ERR_PRLI                0x10000000

#define ERR_ERQ_FULL            0x0f000000
#define ERR_INVALID_LUN_EXT     0x0e000000
#define ERR_SEST_INVALIDATION   0x0d000000
#define ERR_SGL_ADDRESS         0x0c000000

#endif // __ERR_CODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\dvrentry.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    DvrEntry.c

Abstract:

    This is the miniport driver entry point for the Agilent
    PCI to Fibre Channel Host Bus Adapter (HBA).

Authors:

    MB - Michael Bessire
    DL - Dennis Lindfors FC Layer support
    IW - Ie Wei Njoo
    LP - Leopold Purwadihardja
    KR - Kanna Rajagopal

Environment:

    kernel mode only

Version Control Information:

    $Archive: /Drivers/Win2000/Trunk/OSLayer/C/DVRENTRY.C $

Revision History:

    $Revision: 4 $
    $Date: 10/23/00 5:40p $
    $Modtime:: 10/19/00 5:00p          $

Notes:

--*/


#include "buildop.h"
#include "osflags.h"

#if DBG
#include "ntdebug.h"
//  EXTERNAL_DEBUG_LEVEL is defined in ntdebug.h so this file does not change
extern ULONG Global_Print_Level =  EXTERNAL_DEBUG_LEVEL;
extern ULONG hpFcConsoleLevel;
// extern ULONG  HPDebugFlag =  EXTERNAL_HP_DEBUG_LEVEL;
#endif //  DBG

#if defined(HP_PCI_HOT_PLUG)
   #include "HotPlug4.h"    // NT 4.0 PCI Hot-Plug header file
#endif

#ifdef _DEBUG_EVENTLOG_
#include "eventlog.h"
PVOID    gDriverObject;
void RegisterUnload(void *dev);
#endif

#ifdef __REGISTERFORSHUTDOWN__
ULONG    gRegisterForShutdown = 0;
#endif


#ifdef   _ENABLE_LARGELUN_
ULONG    gMaximumLuns = MAXIMUM_LUN;
ULONG    gEnableLargeLun= 0;
#endif

#ifdef YAM2_1
#include "hhba5100.ver"
#endif

ULONG gDebugPerr = 0;
ULONG gEnablePseudoDevice = 0;
ULONG gMaximumTransferLength=0; 
ULONG gCrashDumping=FALSE;
ULONG gIrqlLevel = 0;

// os adjust parameter cache
OS_ADJUST_PARAM_CACHE hpOsAdjustParamCache;

/* Global Flag to indicate no. of ticks
 * before returning selection time out
 */
ULONG gGlobalIOTimeout = 10;

/*++

Routine Description:

    Installable driver initialization entry point for system.

Arguments:

    Driver Object - pointer ScsiPortxxx routines use to call DriverEntry
    Argument2     - pointer ScsiPortxxx routines use to call DriverEntry

Return Value:

    Status from ScsiPortInitialize()

--*/

ULONG
DriverEntry (
    IN PVOID DriverObject,
    IN PVOID Argument2
    )
{
    ULONG return_value;
   
    DebugPrint((0,"\nIN Agilent DriverEntry %lx %lx PRINT %08x  @ %x\n",DriverObject,Argument2, Global_Print_Level,osTimeStamp(0) ));

    osDEBUGPRINT((ALWAYS_PRINT,"\nIN Agilent DriverEntry %lx %lx  @ %x &Global_Print_Level %lx &hpFcConsoleLevel %lx\n",
        DriverObject,
        Argument2, 
        osTimeStamp(0),
        &Global_Print_Level,
        &hpFcConsoleLevel));

    #ifdef _DEBUG_EVENTLOG_
    gDriverObject = DriverObject;
    InitializeEventLog( DriverObject);
    #endif

    #ifdef _DEBUG_READ_REGISTRY_
    ReadGlobalRegistry(DriverObject);
    #endif
   
    // Initialize drivers and Fc layer
    return_value= HPFibreEntry(DriverObject, Argument2);

    #ifdef _DEBUG_EVENTLOG_
    if (return_value == 0)
    {
        #ifdef HP_NT50    
        RegisterUnload(DriverObject);
        #endif
        LogDriverStarted( DriverObject );
    }
    //
    // Initialize the event log.
    //
    // LogEvent(0, 0,HPFC_MSG_DYNAMIC_STRING, LOG_LEVEL_DEBUG, NULL, 0, NULL);
    // LogEvent(0, 0,HPFC_MSG_DYNAMIC_STRING, LOG_LEVEL_DEBUG, NULL, 0, "Testing Yahoo Yahee ...");
    // LogEvent(0, 0,HPFC_MSG_DYNAMIC_STRING, LOG_LEVEL_DEBUG, NULL, 0, "Next test %d %x %s ...", 2000, 2000, "two thou");

    #endif
   
    osDEBUGPRINT((ALWAYS_PRINT,"OUT Agilent DriverEntry %x\n",return_value));
    return (return_value);

} // end DriverEntry()


/*++

Routine Description:

    This routine is called from DriverEntry if this driver is installable
    or directly from the system if the driver is built into the kernel.
    It calls the OS dependent driver ScsiPortInitialize routine which
    controls the initialization.

Arguments:

    Driver Object - pointer ScsiPortxxx routines use to call DriverEntry
    Argument2     - pointer ScsiPortxxx routines use to call DriverEntry

Return Value:

    Status from ScsiPortInitialize()

--*/
ULONG
HPFibreEntry(
    IN PVOID DriverObject,
    IN PVOID Argument2
    )
{
    HW_INITIALIZATION_DATA hwInitializationData;
    ULONG i;
    // ULONG adapterCount = 0;
    ULONG return_value;
    ULONG cachedMemoryNeeded,Mem_needed;
    ULONG cachedMemoryAlign;
    ULONG dmaMemoryNeeded;
    ULONG dmaMemoryPhyAlign;
    ULONG nvMemoryNeeded;
    ULONG usecsPerTick;
    ULONG dmaMemoryPtrAlign;

    #if defined(HP_PCI_HOT_PLUG)
   // The HotPlugContext is used to pass info between actual HBAs 
   // with Hot Plug Psuedo device.
    HOT_PLUG_CONTEXT  HotPlugContext;      
    ULONG return_value2;
    #endif

    // vendor and device identification
    // ??? should get this from FCLayer
    UCHAR vendorId[4] = {'1', '0', '3', 'C'};
    UCHAR deviceId[4] = {'1', '0', '2', '\0'};

    osDEBUGPRINT((ALWAYS_PRINT,"HPFibreEntry In\n"));

    #if defined(HP_PCI_HOT_PLUG)            //-----------------BEGIN
    // The array in HotPlugcontext is used to contain pointers to device 
    // extensions and a count of the number of HBAs found. The count will 
    // be held in element zero of the array.
    HotPlugContext.extensions[0] = 0;
    #endif                              //----------------------------END

    // zero out structure.
    for (i=0; i<sizeof(HW_INITIALIZATION_DATA); i++) 
    {
        ((PUCHAR)&hwInitializationData)[i] = 0;
    }

    // set size of hwInitializationData.
    hwInitializationData.HwInitializationDataSize =
                                               sizeof(HW_INITIALIZATION_DATA);

    // set entry points.
    hwInitializationData.HwInitialize   =(PHW_INITIALIZE)HPFibreInitialize;
    hwInitializationData.HwFindAdapter  =(PHW_FIND_ADAPTER)HPFibreFindAdapter;
    hwInitializationData.HwStartIo      =(PHW_STARTIO)HPFibreStartIo;
    hwInitializationData.HwInterrupt    =(PHW_INTERRUPT)HPFibreInterrupt;
    hwInitializationData.HwResetBus     =(PHW_RESET_BUS)HPFibreResetBus;

    #if defined(HP_NT50)                //++++++++++++++++++++++++++++BEGIN
    hwInitializationData.HwAdapterControl = (PHW_ADAPTER_CONTROL)HPAdapterControl;
    #endif                              //++++++++++++++++++++++++++++END

    // indicate the number of access ranges that will be used.
    // (ie. reserved, IOBASEL, IOBASEU, Memory, RAMBASE, etc)
    //      1         2        3        4       5

    osDEBUGPRINT((DENT,"IN Num Config Ranges %lx\n",hwInitializationData.NumberOfAccessRanges));
    hwInitializationData.NumberOfAccessRanges = NUMBER_ACCESS_RANGES;

    // indicate the bus type.
    hwInitializationData.AdapterInterfaceType = PCIBus;

    // indicate no buffer mapping but will need physical addresses.
    hwInitializationData.NeedPhysicalAddresses = TRUE;

    // indicate other supported features
    hwInitializationData.AutoRequestSense     = TRUE;

    #ifdef MULTIPLE_IOS_PER_DEVICE          //--------------------------BEGIN
    hwInitializationData.MultipleRequestPerLu = TRUE;
    hwInitializationData.TaggedQueuing        = TRUE;
    #else // NOT MULTIPLE_IOS_PER_DEVICE    //--------------------------ELSE
    hwInitializationData.MultipleRequestPerLu = FALSE;
    hwInitializationData.TaggedQueuing        = FALSE;
    #endif //  MULTIPLE_IOS_PER_DEVICE      //--------------------------END

    // set up HBA identification information. This will be used by the
    // Scsiport driver to call the HwFindAdapter routine for each
    // associated device found.
    hwInitializationData.VendorId       = &vendorId;
    hwInitializationData.VendorIdLength = 4;
    hwInitializationData.DeviceId       = &deviceId;
    hwInitializationData.DeviceIdLength = 3;

    osZero (&hpOsAdjustParamCache, sizeof(hpOsAdjustParamCache));
    hpOsAdjustParamCache.safeToAccessRegistry = TRUE;

    osDEBUGPRINT((DENT,"Call fcInitializeDriver\n"));
    
    #ifdef OLD_CODE                         
    return_value = fcInitializeDriver (NULL,
                                       &cachedMemoryNeeded,
                                       &cachedMemoryAlign,
                                       &dmaMemoryNeeded,
                                       &dmaMemoryPtrAlign,
                                       &dmaMemoryPhyAlign,
                                       &nvMemoryNeeded,
                                       &usecsPerTick);

    if (return_value)
    {
        osDEBUGPRINT((ALWAYS_PRINT,"Call fcInitializeDriver failed error=%x\n", return_value));
        #ifdef _DEBUG_EVENTLOG_
        LogEvent(NULL, 
                  NULL,
                  HPFC_MSG_INITIALIZEDRIVERFAILED,
                  NULL, 
                  0, 
                  "%xx", return_value);
        #endif
      
        return (return_value);
    }  

    // IWN, IA-64 need 8 byte aligned
    cachedMemoryAlign = 8;
    #endif
    
    
    cachedMemoryAlign = 0;
    cachedMemoryNeeded = 0;

    hpOsAdjustParamCache.safeToAccessRegistry = FALSE;

    // specify size of extensions.
    // Per card  memory ==>> pCard
    #ifndef YAM2_1                                  
    Mem_needed = sizeof(CARD_EXTENSION) +
                 cachedMemoryNeeded +
                 cachedMemoryAlign;
    #else
    gDeviceExtensionSize = OSDATA_SIZE + 
                  cachedMemoryNeeded +
                  cachedMemoryAlign;
      
    Mem_needed =   gDeviceExtensionSize;

    osDEBUGPRINT((ALWAYS_PRINT,"HPFibreEntry: gDeviceExtensionSize is %x\n",gDeviceExtensionSize));
    osDEBUGPRINT((ALWAYS_PRINT,"HPFibreEntry: OSDATA_SIZE is %x \n",OSDATA_SIZE ));
    //osDEBUGPRINT((ALWAYS_PRINT,"cachedMemoryNeeded is %x\n",cachedMemoryNeeded));
    //osDEBUGPRINT((ALWAYS_PRINT,"cachedMemoryAlign is %x\n",cachedMemoryAlign));
    #endif

    hwInitializationData.DeviceExtensionSize     = Mem_needed;
    osDEBUGPRINT((DENT,"DeviceExtensionSize is %x\n",hwInitializationData.DeviceExtensionSize));
    #ifndef YAM2_1
    osDEBUGPRINT((DENT,"OS DeviceExtensionSize is %x\n", sizeof(CARD_EXTENSION)));
    #else
    osDEBUGPRINT((DENT,"OS DeviceExtensionSize is %x\n", gDeviceExtensionSize));
    #endif
    osDEBUGPRINT((DENT,"FC Layer DeviceExtensionSize is %x\n",cachedMemoryNeeded + cachedMemoryAlign));


    // Per logical unit memory ==>> lunExtension
    hwInitializationData.SpecificLuExtensionSize = sizeof(LU_EXTENSION);
    osDEBUGPRINT((DENT,"SpecificLuExtensionSize is %x\n",hwInitializationData.SpecificLuExtensionSize ));
    
    // Per request memory ==>> pSrbExt
    hwInitializationData.SrbExtensionSize        = sizeof(SRB_EXTENSION);
    osDEBUGPRINT((DENT,"SrbExtensionSize  is %x\n",hwInitializationData.SrbExtensionSize ));

    // Initialize calls findadap then adapinit during boot

    osDEBUGPRINT((DENT,"ScsiPortInitialize DriverObject %lx Argument2 %lx\n",
                                            DriverObject,Argument2 ));
    #if defined(HP_PCI_HOT_PLUG)
    // The HotPlugContext is used to pass info between actual HBAs 
    // with Hot Plug Psuedo device.
    return_value = ScsiPortInitialize(DriverObject,
                              Argument2,
                              &hwInitializationData,
                              &HotPlugContext);
    #else
    return_value = ScsiPortInitialize(DriverObject,
                              Argument2,
                              &hwInitializationData,
                              NULL);
    #endif
    osDEBUGPRINT((ALWAYS_PRINT,"HPFibreEntry: ScsiPortInitialize return_value %x\n", return_value));

    #if defined(HP_PCI_HOT_PLUG)

    if (!return_value) 
    {
        //
        // Added to provide use of pseudo controller for PCI Hot Plug IOCTL
        // handling.
        //

        for (i = 0; i < sizeof(HW_INITIALIZATION_DATA); i++) 
        {
            ((PUCHAR) &hwInitializationData)[i] = 0;
        }

        //
        // Fill in the hardware initialization data structure.
        //

        hwInitializationData.HwInitializationDataSize = sizeof(HW_INITIALIZATION_DATA);

        //
        // Set driver entry points.
        //

        hwInitializationData.HwInitialize = (PHW_INITIALIZE)PsuedoInit;
        hwInitializationData.HwStartIo = (PHW_STARTIO)PsuedoStartIo;
        hwInitializationData.HwInterrupt = NULL;
        hwInitializationData.HwResetBus = (PHW_RESET_BUS)PsuedoResetBus;
        hwInitializationData.HwDmaStarted = NULL;
        hwInitializationData.HwAdapterState = NULL;

        //
        // Specify size of extensions.
        //
        hwInitializationData.DeviceExtensionSize = sizeof(PSUEDO_DEVICE_EXTENSION); 
        hwInitializationData.SpecificLuExtensionSize = sizeof(LU_EXTENSION);
        hwInitializationData.SrbExtensionSize = sizeof(SRB_EXTENSION);

        //
        // Initialize other data.
        //
        hwInitializationData.MapBuffers = FALSE;
        hwInitializationData.NeedPhysicalAddresses = TRUE;
        hwInitializationData.TaggedQueuing = FALSE;
        hwInitializationData.AutoRequestSense = FALSE;
        hwInitializationData.ReceiveEvent = FALSE;
        hwInitializationData.MultipleRequestPerLu = TRUE;

        //
        // We are positioning the pseudo device as a PCI based controller,
        // since hot-plug will be supported only in PCI based systems.
        // This pseudo controller will not require any reserved resources.
        // 
        hwInitializationData.AdapterInterfaceType = PCIBus;
        hwInitializationData.NumberOfAccessRanges = 0;
        hwInitializationData.HwFindAdapter = (PHW_FIND_ADAPTER)PsuedoFind;

        HotPlugContext.psuedoDone = FALSE;

        return_value2 = ScsiPortInitialize(DriverObject, Argument2, &hwInitializationData, &HotPlugContext);

        osDEBUGPRINT((ALWAYS_PRINT, "\tPsuedo controller ScsiPortInitialize\t= %0#10x\n", return_value2));
    }

    #endif

    osDEBUGPRINT((ALWAYS_PRINT,"HPFibreEntry Out\n"));

    return (return_value);

} // end HPFibreEntry()


/*++

Routine Description:

    Searches the registry's DriverParameters string for a parameter.  
    String search is case-sensitive.

Arguments:

    Parameter     - NULL-terminated driver parameter string to look for.
    Default       - Default value of driver Parameter
    Min           - Lower legal limit of driver Parameter
    Max            - Upper legal limit of driver Parameter
    ArgumentString   - pointer of string to parse.
    
Return Value:

    Default        - Default return value if ArgumentString's Min, Max value is invalid
    Min         - Lower legal limit of Parameter value
    Max              - Upper legal limit of Parameter value 

--*/
ULONG
GetDriverParameter(
    IN PCHAR Parameter,
    IN ULONG Default,
    IN ULONG Min,
    IN ULONG Max,
    IN PCHAR ArgumentString
    )
{

    USHORT  ParameterValue=0;
    BOOLEAN Done=FALSE;

    UCHAR *RegStr = ArgumentString;
    UCHAR *DrvStr;
   

    if (ArgumentString == NULL)
        return Default;

    while (*RegStr != (UCHAR) NULL) 
    {
        //
        // skip character sets that are meaningless to us
        //
        while (C_isspace(*RegStr))  
        {
            RegStr++;
        }

        if (*RegStr == (UCHAR) NULL) 
        {
            return Default;
        }
        //
        // Start of a non-space character
        //
        DrvStr   =  Parameter;

        while (!(*RegStr == (UCHAR) NULL || *DrvStr == (UCHAR) NULL || C_isspace(*RegStr))) 
        {
            if (*DrvStr != *RegStr) 
            {
                RegStr++;
                break;
            }
            DrvStr++;
            RegStr++;
          
        } //End while (!(*RegStr == (UCHAR) NULL || *DrvStr == (UCHAR) NULL || C_isspace(*RegStr)))

        if (*DrvStr == (UCHAR) NULL) break;

    }//End   while (*RegStr != (UCHAR) NULL)


    //
    // Increment string pointer by one to skip "=" character
    //
    RegStr++;
   
    //
    // Since string compare was successful, we must now check the validity of ArgumentString
    //
    while ( !(*RegStr == (UCHAR) NULL || C_isspace(*RegStr) || !(C_isdigit(*RegStr))  )) 
    {
        if ( ( *RegStr>='0') && (*RegStr <='9') ) 
        {
            ParameterValue = ParameterValue*10 + (*RegStr - '0');
            Done = TRUE;
            RegStr++;
        }
    } //End while (!(*RegStr == (UCHAR) NULL || C_isspace(*RegStr)))

    //
    // if done bit is set, therefore ParameterValue is useable
    //
    if (Done  &&  ((ParameterValue >= Min) && (ParameterValue <= Max)) ) 
    {
        return (ParameterValue);
    } 
    else 
        if (Done  &&  (ParameterValue >= Max)) 
        {
            return (Max);
        } 
        else 
        {
            return (Default); //if no value found, return the Default value.
        }

} //End GetDriverParameter

/*++

Routine Description:

    OS Adjust Parameters:

    If the parameter name is found in the os adjust parameter cache then the
    parameter value of the parameter name is read from the os adjust
    parameter cache.

  
    Parameter value read, is returned if the parameter value is between
    "paramMin" and "paramMax" otherwise "paramDefault" is returned.
  

Arguments:

    pCard - HBA miniport driver's data adapter storage

Return Value:

    TRUE  - if initialization successful.
    FALSE - if initialization unsuccessful.

--*/
os_bit32
osAdjustParameterBit32 (
    agRoot_t *hpRoot,
    char     *paramName,
    os_bit32     paramDefault,
    os_bit32     paramMin,
    os_bit32     paramMax)
{
    os_bit32  x;
    int    found = FALSE;
    PCARD_EXTENSION pCard;
    char * pchar;
    ULONG   numIOs = 4;

    if (gCrashDumping)
    {
        gMaxPaDevices = 16;

        if (osStringCompare(paramName, "NumIOs") == TRUE)
        {
            x = numIOs;
            found = TRUE;
        }
        else if (osStringCompare(paramName, "NumCommandQ") == TRUE)
        {
            x = numIOs;
            found = TRUE;
        }
        else if (osStringCompare(paramName, "NumCompletionQ") == TRUE)
        {
            x = numIOs;
            found = TRUE;
        }
        else if (osStringCompare(paramName, "SizeSGLs") == TRUE)
        {
            x = paramMin;
            found = TRUE;
        }
        else if (osStringCompare(paramName, "NumSGLs") == TRUE)
        {
            x = 4;
            found = TRUE;
        }
        else if (osStringCompare(paramName, "NumTgtCmnds") == TRUE)
        {
            x = 4;
            found = TRUE;
        }
        else if (osStringCompare(paramName, "SF_CMND_Reserve") == TRUE)
        {
            x = 4;
            found = TRUE;
        }
        else if (osStringCompare(paramName, "NumInboundBufferQ") == TRUE)
        {
            x = 32;
            found = TRUE;
        }
        else if (osStringCompare(paramName, "NumDevices") == TRUE)
        {
            x = gMaxPaDevices;
            found = TRUE;
        }

        if (found == TRUE) 
        {
            if (x < paramMin)
                return paramMin;
            else 
                if (x > paramMax)
                    return paramMax;
                else
                    return x;
        } 
        else
            return paramDefault;    
    }

    //
    //  If we can read DriverParameters, we will retrieve the parameters from the Registry instead of the 
    //  "cached" parameters read during DriverEntry
    //
    if (hpRoot) 
    {
        pCard   = (PCARD_EXTENSION)hpRoot->osData;
        if (pCard) 
        {
            pchar = pCard->ArgumentString;    
        
            if (pchar) 
            {
            x = GetDriverParameter(   paramName, paramDefault, paramMin, paramMax, pchar) ;
            osDEBUGPRINT((ALWAYS_PRINT, "\tDriverParameter:%s\tDefault:%x, Min:%x, Max:%x, Return:%x\n", 
                    paramName,
                    paramDefault,
                    paramMin,
                    paramMax,
                    x));
            return x;    
            
        }
        //
        //  When we are at this level in the code, we could not read DriverParameters, i.e we cannot retrieve 
        //  per-host-adapter level parameters from the "cache" (We are already at FindAdapter at this stage)
        //
        else 
            if (RetrieveOsAdjustBit32Entry (paramName, &x)) 
            {
                found = TRUE;
            }
        } // if (pCard) 
    }

    #ifdef _DEBUG_READ_FROM_REGISTRY //+++ DEBUG purpose
    
    else 
        if (  hpOsAdjustParamCache.safeToAccessRegistry &&
            hpOsAdjustParamCache.numBit32Elements < MAX_OS_ADJUST_BIT32_PARAMS) 
        {
            if (ReadFromRegistry (paramName, 0, &x, sizeof (ULONG))) 
            {
                osStringCopy (hpOsAdjustParamCache.bit32Element [
                    hpOsAdjustParamCache.numBit32Elements].paramName,
                    paramName,
                    MAX_OS_ADJUST_PARAM_NAME_LEN - 1);

                hpOsAdjustParamCache.bit32Element [
                    hpOsAdjustParamCache.numBit32Elements].value = x;

                hpOsAdjustParamCache.numBit32Elements++;
                found = TRUE;
            }
        }
    #endif

    if (found == TRUE) 
    {
        if (x < paramMin)
            return paramMin;
        else 
            if (x > paramMax)
                return paramMax;
            else
                return x;
    } 
    else
        return paramDefault;
}

/*++

Routine Description:

    FCLayer Support routine

    If the parameter name is found in the os adjust parameter cache then the
    parameter value of the parameter name is read from the os adjust
    parameter cache.


    Parameter value read, is copied to paramBuffer.

Arguments:
    hpRoot            - card common data
    paramName         - name
    paramBuffer       - buffer
    paramBufLen       - length
   

Return Value:

    none
--*/

void
osAdjustParameterBuffer (
    agRoot_t *hpRoot,
    char     *paramName,
    void     *paramBuffer,
    os_bit32 paramBufLen)
{
    if (RetrieveOsAdjustBufferEntry (paramName, paramBuffer, paramBufLen))
        return;

#ifdef _DEBUG_READ_FROM_REGISTRY //+++ DEBUG purpose
    if (  hpOsAdjustParamCache.safeToAccessRegistry &&
           hpOsAdjustParamCache.numBufferElements < MAX_OS_ADJUST_BUFFER_PARAMS) 
    {
        if (ReadFromRegistry (paramName, 1,
                hpOsAdjustParamCache.bufferElement [hpOsAdjustParamCache.numBufferElements].value,
                (MAX_OS_ADJUST_PARAM_BUFFER_VALUE_LEN - 1))) 
        {
            osStringCopy (hpOsAdjustParamCache.bufferElement [
                    hpOsAdjustParamCache.numBufferElements].paramName,
                    paramName,
                    MAX_OS_ADJUST_PARAM_NAME_LEN - 1);

            osStringCopy (paramBuffer,
                    hpOsAdjustParamCache.bufferElement [
                      hpOsAdjustParamCache.numBufferElements].value,
                    paramBufLen);

            hpOsAdjustParamCache.numBufferElements++;
        }
    }
#endif    
}

/*++

Routine Description:
   This function is used for os adjust parameters of type os_bit32.

   If the parameter name is present in the os adjust parameter cache
   then the parameter value is copied to the address pointed to by the "value"
   parameter and TRUE is returned.

   If the parameter name is not present in the os adjust parameter cache
   then FALSE is returned.


Arguments:
   paramName         - name
   paramBuffer       - buffer
   

Return Value:

   none
--*/
BOOLEAN
RetrieveOsAdjustBit32Entry (
    char  *paramName,
    os_bit32 *value)
{
    int i;

    for (i = 0; i < hpOsAdjustParamCache.numBit32Elements; i++) 
    {
        if (osStringCompare (paramName,
                hpOsAdjustParamCache.bit32Element[i].paramName))
        {
            *value = hpOsAdjustParamCache.bit32Element[i].value;
            return TRUE;
        }
    }

    return FALSE;
}

/*++

Routine Description:
    RetrieveOsAdjustBufferEntry ()

    This function is used for os adjust parameters of type string.

    If the parameter name is present in the os adjust parameter cache
    then the parameter value is copied to the address pointed to by the "value"
    parameter and TRUE is returned.

    If the parameter name is not present in the os adjust parameter cache
    then FALSE is returned.



Arguments:
    paramName         - name
    paramBuffer       - buffer
    paramBufLen       - length
   

Return Value:

    none
--*/
BOOLEAN
RetrieveOsAdjustBufferEntry (
    char  *paramName,
    char  *value,
    int   len)
{
    int i;

    for (i = 0; i < hpOsAdjustParamCache.numBufferElements; i++) 
    {
        if (osStringCompare (paramName,
                hpOsAdjustParamCache.bufferElement[i].paramName))
        {
            osStringCopy (value,hpOsAdjustParamCache.bufferElement[i].value, len);
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\fcapi.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/FcApi.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 7/20/00 2:33p   $ (Last Modified)

Purpose:

  This is the TachyonXL-specific FC Layer API Include File.

--*/

#ifndef __TachyonXL_FcApi_H__

#define __TachyonXL_FcApi_H__

/*
 * Define each FC Layer function overridden
 */

#endif  /* ~__TachyonXL_FcApi_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\devstate.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/DEVSTATE.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $
   $Modtime:: 10/27/00 1:15p  $

Purpose:

  This file implements the FC Layer State Machine.

--*/

#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/state.h"

#include "../h/tlstruct.h"
#include "../h/memmap.h"
#include "../h/fcmain.h"

#include "../h/cstate.h"
#include "../h/devstate.h"
#include "../h/cdbstate.h"
#include "../h/sfstate.h"
#include "../h/flashsvc.h"
#include "../h/timersvc.h"
#include "../h/queue.h"
#include "../h/cfunc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"

#include "tlstruct.h"
#include "memmap.h"
#include "fcmain.h"

#include "cstate.h"
#include "devstate.h"
#include "cdbstate.h"
#include "sfstate.h"
#include "flashsvc.h"
#include "timersvc.h"
#include "queue.h"
#include "cfunc.h"
#endif  /* _New_Header_file_Layout_ */

extern os_bit8 Alpa_Index[256];

stateTransitionMatrix_t DevStateTransitionMatrix = {
    /* Event/State 0        State 1          State 2...             */
    0,0,0,0,0,    0,0,0,0,0,    0,0,0,0,0,    0,0,0,0,0,    0,0,0,0,0,    0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 1 DevEventLogin                                                     */
    DevStateHandleEmpty, DevStateAllocSFThread, DevStateHandleEmpty, DevStateHandleEmpty,DevStateHandleEmpty,
     DevStateHandleEmpty,DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty,
      DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty,
       DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty,DevStateHandleEmpty, DevStateHandleEmpty,
        DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty,
         DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty, DevStateHandleEmpty,   0,0,0,0,0, 0,0,0,0,0 ,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
         0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 2 DevEventGotSFThread                                                     */
    0,0,DevStateDoPlogi,0,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                DevStateDoPlogi,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 3 DevEventPlogiSuccess                                                     */
    0,0,0,DevStatePlogiDone,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,   0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 4 DevEventDoPrli                                                     */
    0,0,0,0,DevStateDoPrli, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 5 DevEventPrliSuccess                                                     */
    0,0,0,0,0,
      DevStatePrliDone,0,0,0,0, /* 5 */
        DevStatePrliDone,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,DevStatePrliDone,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 6  DevEventCheckWWN                                                    */
    0,0,0,0,0, 0,DevStateMatchWWN,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 7  DevEventNoMatchWWN                                                    */
    0,0,0,0,0, 0,0,DevStateSlotNew,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 8  DevEventMatchWWN                                                    */
    0,0,0,0,0, 0,0,DevStateSlotKnown,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 9  DevEventAvailable                                                    */
    0,0,0,0,0,
      0,0,0,DevStateHandleAvailable,DevStateHandleAvailable,
        0,0,0,0,0,
          0,0,DevStateHandleAvailable,0,0,
            0,0,0,DevStateHandleAvailable,0,
              0,DevStateHandleAvailable,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 10 a DevEventPlogiFailed*/
    0,0,0,DevStateLoginFailed,0,
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,0,0,DevStateLoginFailed, /* 20 */
              0,0,0,0,0, /* 25 */
                0,DevStateLoginFailed,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 11 b DevEventPrliFailed*/
    0,0,0,0,0, DevStateLogout,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0 ,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 12 c DevEventLoggedOut*/
    0,0,0,0,0, 0,0,0,0,0, 0,0,DevStateLoginFailed,0,0, 0,0,0,0,0 ,0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0 ,0,0, 0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 13 d DevEventAllocDeviceResetSoft*/
    0,0,0,0,0,
      0,0,0,0,0,
        DevStateAllocDeviceResetSoft,0,0,0,0,
          0,0,0,0,0,
            DevStateAllocDeviceResetSoft,0,0,0,0,
              0,0,0,DevStateAllocDeviceResetSoft,DevStateAllocDeviceResetSoft,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 14 e DevEventAllocDeviceResetHard */
    0,0,0,0,0,
      0,0,0,0,0,
        DevStateAllocDeviceResetHard,DevStateAllocDeviceResetSoft,0,0,DevStateAllocDeviceResetHard,
          0,0,DevStateAllocDeviceResetHard,0,0,
            DevStateAllocDeviceResetHard,0,0,0,0,
              0,DevStateAllocDeviceResetHard,0,DevStateAllocDeviceResetHard,DevStateAllocDeviceResetHard,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 15 f DevEventDeviceResetHard */
    0,0,0,0,0, 
      0,0,0,0,0, 
        0,0,0,DevStateDeviceResetSoft,0, 
          0,0,0,0,0,
            0,0,0,0,0,
              DevStateDeviceResetSoft,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 16 0x10 DevEventDeviceResetHard */
    0,0,0,0,0, 
      0,0,0,0,0,
        0,0,0,0,DevStateDeviceResetHard,
          0,0,0,0,0,
            0,0,0,0,0,
              DevStateDeviceResetHard,0,0,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 17 0x11 DevEventDeviceResetDone */
    0,0,0,0,0, 0,DevStateMatchWWN,0,0,0, 0,0,0,0,0, DevStateDeviceResetDone,DevStateDeviceResetDone,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 18 0x12 DevEventAL_PA_Self_OK   */
    0,0,0,DevStateAL_PA_Self_OK,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,DevStateHandleAvailable,0,
            0,0,0,0,0,
              0,0,DevStateAL_PA_Self_OK,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 19 0x13 DevEventAL_PA_Self_BAD  */
    0,0,0,DevStateAL_PA_Self_BAD,0,
      0,0,0,0,0,
        0,0,0,0,0,
          0,0,0,0,DevStateAL_PA_Self_BAD,
            0,0,0,0,0,
              0,0,DevStateAL_PA_Self_BAD,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 20  DevEventDeviceResetDoneFail */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, DevEventDeviceResetDoneFail,DevEventDeviceResetDoneFail,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 21  DevEventAllocAdisc          */
    0,0,0,0,0,  
      0,0,0,0,0, /* 5 */
        DevStateAllocAdisc,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            DevStateAllocAdisc,0,0,0,0, /* 20 */
              0,0,0,DevStateAllocAdisc,DevStateAllocAdisc, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 22  DevEventAdisc   */
    0,0,0,0,0,  
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,DevStateAdisc,0,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 23  DevEventAdiscDone_OK        */
    0,0,0,0,0,  
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,DevStateAdiscDone_OK,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 24  DevEventAdiscDone_FAIL_No_Device      */
    0,0,0,0,0,  
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,DevStateAdiscDone_FAIL_No_Device,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0,/* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 25  DevEventDoTickVerifyALPA    */
    0,DevStateTickVerifyALPA,0,0,0,
      0,0,0,0,0,
        DevStateTickVerifyALPA,0,0,0,0,
          0,0,0,DevStateTickVerifyALPA,DevStateTickVerifyALPA,
            0,0,0,0,0,
                DevStateTickVerifyALPA,0,DevStateTickVerifyALPA,0,0,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 26  DevEventExternalDeviceReset    */
    0,0,0,0,0,
      0,0,0,0,0,
        DevStateExternalDeviceReset,0,0,0,0,
          0,0,DevStateExternalDeviceReset,0,0,
            0,0,0,0,0,
              0,DevStateExternalDeviceReset,DevStateExternalDeviceReset,DevStateExternalDeviceReset,DevStateExternalDeviceReset,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 27 DevEventTickGotSFThread     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, DevStateTickGotSFThread,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 28 DevEventExternalLogout     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 29 DevEventSendIO     */
    0,0,0,0,0,
      0,0,0,0,0,
        DevState_IO_Ready,DevStateNoDevice,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,DevState_IO_Ready,DevState_FC_TAPE_Recovery,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 30 DevEvent_FC_TAPE_Recovery */
    0,0,0,0,0,
      0,0,0,0,0,
        DevState_FC_TAPE_Recovery,0,0,0,0,
          0,0,0,0,0,
            0,0,0,0,0,
              0,0,0,DevState_FC_TAPE_Recovery,DevState_FC_TAPE_Recovery,
                0,0,0,0,0,
                  0,0,0,0,0,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 31 DevEventAdiscDone_FAIL_ReLogin */
    0,0,0,0,0,  
      0,0,0,0,0, /* 5 */
        0,0,0,0,0, /* 10 */
          0,0,0,0,0, /* 15 */
            0,0,DevStateAdiscDone_FAIL_ReLogin,0,0, /* 20 */
              0,0,0,0,0, /* 25 */
                0,0,0,0,0, /* 30 */
                  0,0,0,0,0, /* 35 */
                    0,0,0,0,0, /* 40 */
                      0,0,0,0,0, /* 45 */
                        0,0,0,0,0, /* 50 */
                          0,0,0,0,0, /* 55 */
                            0,0,0,0,0, /* 60 */
                              0,0,0,0,0, /* 65 */
                                0,0,0,0,0, /* 70 */
                                  0,0,0,0,0, /* 75 */
                                    0,0,0,0,0, /* 80 */
                                      0,0,0,0,0, /* 85 */
                                        0,0,0,0,0, /* 90 */
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 32 DevEvent_Device_Gone  */
    0,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,
      DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,
        DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,
          DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,
            DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,
              DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,
                DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,
                  DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,DevStateNoDevice,
                    0,0,0,0,0,
                      0,0,0,0,0,
                        0,0,0,0,0,
                          0,0,0,0,0,
                            0,0,0,0,0,
                              0,0,0,0,0,
                                0,0,0,0,0,
                                  0,0,0,0,0,
                                    0,0,0,0,0,
                                      0,0,0,0,0,
                                        0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 33                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 34                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 35                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 36                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 37                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 38                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 39                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 40                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 41                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 42                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 43                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 44                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 45                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 46                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 47                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 48                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 49                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 50                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 51                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 52                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 53                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 54                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 55                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 56                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 57                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 58                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 59                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 60                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 61                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 62                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 63                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 64                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 65                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 66                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 67                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 68                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 69                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 70                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 71                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 72                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 73                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 74                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 75                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 76                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 77                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 78                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 79                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 80                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 81                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 82                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 83                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 84                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 85                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 86                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 87                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 88                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 89                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 90                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 91                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 92                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 93                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 94                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 95                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 96                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 97                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 98                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 99                                                      */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 100                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 101                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 102                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 103                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 104                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 105                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 106                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 107                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 108                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 109                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 110                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 111                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 112                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 113                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 114                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 115                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 116                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 117                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 118                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 119                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 120                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 121                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 122                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 123                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 124                                                     */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    /* Event 125                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 126                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,
    /* Event 127                                                    */
    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,
    0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0,  0,0,0,0,0, 0,0,0,0,0,
    0,0,0,0,0 ,0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,

    };

/*
stateTransitionMatrix_t copiedDevStateTransitionMatrix;
*/
stateActionScalar_t DevStateActionScalar = {
    &DevActionConfused,                       /*  0 */
    &DevActionHandleEmpty,                    /*  1 */
    &DevActionAllocSFThread,                  /*  2 */
    &DevActionDoPlogi,                        /*  3 */
    &DevActionPlogiDone,                      /*  4 */
    &DevActionDoPrli,                         /*  5 */
    &DevActionPrliDone,                       /*  6 */
    &DevActionMatchWWN,                       /*  7 */
    &DevActionSlotNew,                        /*  8 */
    &DevActionSlotKnown,                      /*  9 */
    &DevActionAvailable,                      /* 10 */
    &DevActionLoginFailed,                    /* 11 */
    &DevActionLogout,                         /* 12 */
    &DevActionAllocDeviceResetSoft,           /* 13 */
    &DevActionAllocDeviceResetHard,           /* 14 */
    &DevActionDeviceResetSoft,                /* 15 */
    &DevActionDeviceResetHard,                /* 16 */
    &DevActionDeviceResetDone,                /* 17 */
    &DevActionAL_PA_Self_OK,                  /* 18 */
    &DevActionAL_PA_Self_BAD,                 /* 19 */
    &DevActionDeviceResetDoneFAIL,            /* 20 */
    &DevActionAllocAdisc,                     /* 21 */
    &DevActionAdisc,                          /* 22 */
    &DevActionAdiscDone_OK,                   /* 23 */
    &DevActionAdiscDone_FAIL_No_Device,       /* 24 */
    &DevActionTickVerifyALPA,                 /* 25 */
    &DevActionExternalDeviceReset,            /* 26 */
    &DevActionTickGotSFThread,                /* 27 */
    &DevAction_IO_Ready,                      /* 28 */
    &DevAction_FC_TAPE_Recovery,               /* 29 */
    &DevActionAdiscDone_FAIL_ReLogin,         /* 30 */
    &DevActionNoDevice,                       /* 31 */
    &DevActionConfused,
    &DevActionConfused,
    &DevActionConfused,
    &DevActionConfused,
    &DevActionConfused
    };

/* 
stateActionScalar_t copiedDevStateActionScalar;
*/

#define testDevCompareBase 0x00000110

#ifndef __State_Force_Static_State_Tables__
actionUpdate_t DevTestActionUpdate[] = {
                              0,          0,      agNULL,                 agNULL
                     };
#endif /* __State_Force_Static_State_Tables__ was not defined */


#ifndef USESTATEMACROS
/*+
  Function: DevActionConfused
   Purpose: Terminating State for error detection 
 Called By: Any State/Event pair that does not have an assigned action.
            This function is called only in programming error condtions.
     Calls: None
-*/
/* DevStateConfused                      0    */
extern void DevActionConfused( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    DevThread_t     * pDevThread = ( DevThread_t  * )thread;

    fiLogString(thread->hpRoot,
                    "DevActionConfused",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    CFuncWhatStateAreDevThreads( thread->hpRoot );
    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d AL_PA %X",
                    "DevActionConfused",
                    (char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: DevActionHandleEmpty
   Purpose: Initial state for devthread. Completes all outstanding IO's on this device.
 Called By: DevEventLogin
     Calls: CFuncCompleteActiveCDBThreadsOnDevice
            DevEventLogin
-*/
/* DevStateHandleEmpty                   1    */
extern void DevActionHandleEmpty( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t     * pDevThread = (DevThread_t     *)thread;

    fiListDequeueThis(&pDevThread->DevLink);
    /*+ Check This DRL  -*/
    if( pDevThread->Plogi_Reason_Code != PLOGI_REASON_DEVICE_LOGIN)
    {
        fiListEnqueueAtTail(&pDevThread->DevLink,
                            &CThread_ptr(thread->hpRoot)->AWaiting_Login_DevLink);
    }
    CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIOAborted,  CDBEventIODeviceReset );

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d",
                    "DevActionHandleEmpty",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    fiSetEventRecord(eventRecord,thread,DevEventLogin);
}

/*+
  Function: DevActionAllocSFThread
   Purpose: Begins login process for devthread. Checks for active device reset. If device reset active
            device reset has failed.
 Called By: DevEventLogin
     Calls: SFThreadFree
            SFThreadAlloc
            DevEventGotSFThread
-*/
/* DevStateAllocSFThread                 2    */
extern void DevActionAllocSFThread( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t     * pDevThread = ( DevThread_t  * )thread;
    SFThread_t      * pSFThread  = pDevThread->SFThread_Request.SFThread;

    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount ++;

    pDevThread->SFThread_Request.eventRecord_to_send.event = DevEventGotSFThread;
    pDevThread->SFThread_Request.eventRecord_to_send.thread = thread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d SF Request State %x",
                    "DevActionAllocSFThread",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    pDevThread->SFThread_Request.State,
                    0,0,0,0,0,0);

    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            if (pSFThread->thread_hdr.currentState == SFStateDoResetDevice)
            {
                fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d Reset had failed, bump reset cnt",
                    "DevActionAllocSFThread",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

                pDevThread->Failed_Reset_Count++;
            }
            

            SFThreadFree( thread->hpRoot, &pDevThread->SFThread_Request );
        }
    }

    if( pDevThread->SFThread_Request.State)
    {
            fiLogString(thread->hpRoot,
                        "In %s - State = %d   ALPA %X  FDCnt %x SFThread req state  %08X Wrong !",
                        "DevActionAllocSFThread",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        fiComputeDevThread_D_ID(pDevThread),
                        CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                        pDevThread->SFThread_Request.State,
                        0,0,0,0);
    }
    fiSetEventRecordNull(eventRecord);
    SFThreadAlloc( thread->hpRoot, & pDevThread->SFThread_Request );

}

/*+
  Function: DevActionDoPlogi
   Purpose: Sends event to sfthread to do PLOGI.
            
 Called By: DevActionAllocSFThread
     Calls: Proccess_IMQ
            SFEventDoPlogi
-*/
/* DevStateDoPlogi                       3    */
extern void DevActionDoPlogi( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;

    pSFThread->parent.Device = pDevThread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x",
                    "DevActionDoPlogi",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,0,0,0,0,0);

    CThread_ptr(thread->hpRoot)->FuncPtrs.Proccess_IMQ(thread->hpRoot);

    pSFThread->SF_REJ_RETRY_COUNT =0;

    if( pDevThread->Prev_Active_Device_FLAG == agDevSCSITarget)
    {
        fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleLevelLip,
                    "Previous Login Succsess  NOW relogin State = %d ALPA %X Type %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pDevThread->DevInfo.DeviceType,
                    0,0,0,0,0);
    }

    fiSetEventRecord(eventRecord,&pSFThread->thread_hdr,SFEventDoPlogi);

}

/*+
  Function: DevActionPlogiDone
   Purpose: Successfull PLOGI completion.
            
 Called By: SFActionPlogiAccept,DevEventPlogiSuccess
     Calls: Proccess_IMQ
            SFEventDoPlogi
-*/
/* DevStatePlogiDone                     4    */
extern void DevActionPlogiDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t     * pDevThread = ( DevThread_t  * )thread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X FDCnt %x",
                    "DevActionPlogiDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,DevEventDoPrli);
}

/*+
  Function: DevActionDoPrli
   Purpose: Sends event to sfthread to do PRLI.
            
 Called By: DevEventDoPrli
     Calls: Proccess_IMQ
            SFEventDoPrli
-*/
/* DevStateDoPrli                        5    */
extern void DevActionDoPrli( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d  ALPA %X",
                    "DevActionDoPrli",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);

    CThread_ptr(thread->hpRoot)->FuncPtrs.Proccess_IMQ(thread->hpRoot);

    fiSetEventRecordNull(eventRecord);
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPrli);
}

/*+
  Function: DevActionPrliDone
   Purpose: Successfull PRLI completion.
            
 Called By: SFActionPrliAccept,DevEventPrliSuccess
     Calls: Proccess_IMQ
            DevEventCheckWWN
-*/
/* DevStatePrliDone                      6    */
extern void DevActionPrliDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t * pSFThread = pDevThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x",
                    "DevActionPrliDone",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    pSFThread->parent.Device = pDevThread;

    pDevThread->Prev_Active_Device_FLAG = pDevThread->DevInfo.DeviceType;

    fiSetEventRecord(eventRecord,thread,DevEventCheckWWN);

}

/*+
  Function: DevActionMatchWWN
   Purpose: Device has been successfuly accessed for login. Now find its slot in handle array.
            
 Called By: DevEventCheckWWN
     Calls: DevThreadFindSlot
            DevEventMatchWWN
-*/
/* DevStateMatchWWN                      7    */
extern void DevActionMatchWWN( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t    * pDevThread = ( DevThread_t  * )thread;
    FC_Port_Name_t * pwwn       = &(pDevThread->DevInfo.PortWWN);

    if(CThread_ptr(thread->hpRoot)->FindDEV_pollingCount) CThread_ptr(thread->hpRoot)->FindDEV_pollingCount --;

    pDevThread->DevSlot = DevThreadFindSlot(thread->hpRoot,
                                            pDevThread->DevInfo.CurrentAddress.Domain,
                                            pDevThread->DevInfo.CurrentAddress.Area,
                                            pDevThread->DevInfo.CurrentAddress.AL_PA,
                                            pwwn);

    fiSetEventRecord(eventRecord,thread,DevEventMatchWWN);

}

/*+
  Function: DevActionSlotNew
   Purpose: Move device linked list to Active_DevLink.
            
 Called By: DevEventMatchWWN
     Calls: DevEventAvailable
            
-*/
/* DevStateSlotNew                       8    */
extern void DevActionSlotNew( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t     * pDevThread = ( DevThread_t  * )thread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d",
                    "DevActionSlotNew",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiListDequeueThis(&pDevThread->DevLink);

    fiListEnqueueAtTail(&pDevThread->DevLink,
                        &CThread_ptr(thread->hpRoot)->Active_DevLink );

    fiSetEventRecord(eventRecord,thread,DevEventAvailable);
}

/*+
  Function: DevActionSlotKnown
   Purpose: Move device linked list to Active_DevLink.
            
 Called By: DevEventMatchWWN
     Calls: DevEventAvailable
            
-*/
/* DevStateSlotKnown                     9    */
extern void DevActionSlotKnown( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t   * pDevThread = (DevThread_t   * )thread;
    CThread_t     * pCThread = CThread_ptr(thread->hpRoot);

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d",
                    "DevActionSlotKnown",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    fiListDequeueThis(&pDevThread->DevLink);

    fiListEnqueueAtTail(&pDevThread->DevLink,
                        &pCThread->Active_DevLink );

    fiSetEventRecord(eventRecord,thread,DevEventAvailable);
}

/*+
  Function: DevActionAvailable
   Purpose: Frees any allocated recources. Moves any IO's that were queued during login
            to the send list. This is the end of the successful device discovery proccess.
            
 Called By: DevActionSlotKnown
     Calls: SFThreadFree
-*/
/* DevStateHandleAvailable               10   */
extern void DevActionAvailable( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;

    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree( thread->hpRoot, &pDevThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d",
                    "DevActionAvailable",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);


    if( CFuncShowWhereCDBThreadsAre(thread->hpRoot))
    {
        CFuncWhatStateAreCDBThreads(thread->hpRoot);
    }

    /* Start ADISC  Recovery */

/*
    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "%s %s %x AL_PA %X",
                    "DevActionAvailable","Awaiting_Login_CDBLink",
                    (void *)agNULL,(void *)agNULL,
                    fiNumElementsOnList(&pDevThread->Awaiting_Login_CDBLink),
                    fiComputeDevThread_D_ID(pDevThread),
                    0,0,0,0,0,0);
*/
    if( fiListNotEmpty(&pDevThread->Awaiting_Login_CDBLink))
    {
        fiListEnqueueListAtTailFast( &(pDevThread->Awaiting_Login_CDBLink), (&pDevThread->Send_IO_CDBLink));
    }

    if( CFuncShowWhereCDBThreadsAre(thread->hpRoot))
    {
        CFuncWhatStateAreCDBThreads(thread->hpRoot);
    }
    /* End ADISC  Recovery */

    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: DevActionLoginFailed
   Purpose: Frees any allocated resources. Completes any queued IOs with failed status. If a device
            was found before with this devthread the login process is repeated once. Otherwise this 
            is the end of the failed device discovery proccess.
            
 Called By: 
     Calls: SFThreadFree
-*/
/* DevStateLoginFailed                   11   */
extern void DevActionLoginFailed( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;

    if(CThread_ptr(thread->hpRoot)->FindDEV_pollingCount) CThread_ptr(thread->hpRoot)->FindDEV_pollingCount --;

    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree( thread->hpRoot, &pDevThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d ALPA %X Type %X",
                    "DevActionLoginFailed",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pDevThread->DevInfo.DeviceType,
                    0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);

    if( pDevThread->Prev_Active_Device_FLAG == agDevSCSITarget )
    {
        fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "Previous Login Succsess  NOW FAILED In %s - State = %d ALPA %X type %x",
                    "DevActionLoginFailed",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pDevThread->DevInfo.DeviceType,
                    0,0,0,0,0);


        pDevThread->Prev_Active_Device_FLAG = agFALSE;

        fiListDequeueThis(&pDevThread->DevLink);

        fiListEnqueueAtTail(&pDevThread->DevLink,
                            &CThread_ptr(thread->hpRoot)->Prev_Unknown_Slot_DevLink);

    }
    else
    {

        fiListDequeueThis(&pDevThread->DevLink);

        fiListEnqueueAtTail(&pDevThread->DevLink,
                            &CThread_ptr(thread->hpRoot)->Unknown_Slot_DevLink );
    }

    CFuncCompleteAwaitingLoginCDBThreadsOnDevice(pDevThread ,osIOAborted,  CDBEventIODeviceReset );

}

/*+
  Function: DevActionLogout
   Purpose: Does LOGO to device
 Called By: 
     Calls: Proccess_IMQ
            SFEventDoLogo
-*/
/* DevStateLogout                        12   */
extern void DevActionLogout( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t * pSFThread = pDevThread->SFThread_Request.SFThread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d",
                    "DevActionLogout",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    0,0,0,0,0,0,0);

    CThread_ptr(thread->hpRoot)->FuncPtrs.Proccess_IMQ(thread->hpRoot);

    fiSetEventRecordNull(eventRecord);
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoLogo);
}

/*+
  Function: DevActionAllocDeviceResetSoft
   Purpose: Begins "soft" reset process of PLOGI/Prli. This does not break scsi reserves.
 Called By: 
     Calls: DevEventDeviceResetSoft
            
-*/
/* DevStateAllocDeviceResetSoft               13   */
extern void DevActionAllocDeviceResetSoft( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;

    CThread_ptr(thread->hpRoot)->DEVReset_pollingCount ++;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x",
                    "DevActionAllocDeviceResetSoft",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    pDevThread->Plogi_Reason_Code = PLOGI_REASON_SOFT_RESET;

    pDevThread->SFThread_Request.eventRecord_to_send.event = DevEventDeviceResetSoft;
    pDevThread->SFThread_Request.eventRecord_to_send.thread = thread;

    fiSetEventRecordNull(eventRecord);

    SFThreadAlloc( thread->hpRoot, & pDevThread->SFThread_Request );

}

/*+
  Function: DevActionAllocDeviceResetSoft
   Purpose: Begins "Hard" reset process of Task managment reset. This does break scsi reserves.
 Called By: 
     Calls: DevEventDeviceResetSoft
            
-*/
/* DevStateAllocDeviceResetHard               14   */
extern void DevActionAllocDeviceResetHard( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;

    CThread_ptr(thread->hpRoot)->DEVReset_pollingCount ++;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x",
                    "DevActionAllocDeviceResetHard",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,0,0,0,0,0);

    pDevThread->SFThread_Request.eventRecord_to_send.event = DevEventDeviceResetHard;
    pDevThread->SFThread_Request.eventRecord_to_send.thread = thread;

    fiSetEventRecordNull(eventRecord);

    SFThreadAlloc( thread->hpRoot, & pDevThread->SFThread_Request );

}

/*+
  Function: DevActionDeviceResetSoft
   Purpose: Does PLOGI for soft reset.
 Called By: 
     Calls: Proccess_IMQ
            SFEventDoPlogi

-*/
/* DevStateDeviceResetSoft               15   */
extern void DevActionDeviceResetSoft( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t * pSFThread = pDevThread->SFThread_Request.SFThread;

    pSFThread->parent.Device = pDevThread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x",
                    "DevActionDeviceResetSoft",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,0,0,0,0,0);

    /*+ Check This DRL Do I need to set plogi type here ? -*/
    CThread_ptr(thread->hpRoot)->FuncPtrs.Proccess_IMQ(thread->hpRoot);

    fiSetEventRecordNull(eventRecord);
    /* Send event to SFthreads */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPlogi);

}

/*+
  Function: DevActionDeviceResetHard
   Purpose: Does hard reset.
 Called By: 
     Calls: Proccess_IMQ
            SFEventDoResetDevice

-*/
/* DevStateDeviceResetHard               16   */
extern void DevActionDeviceResetHard( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t * pSFThread = pDevThread->SFThread_Request.SFThread;

    pSFThread->parent.Device = pDevThread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x",
                    "DevActionDeviceResetHard",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    CThread_ptr(thread->hpRoot)->FuncPtrs.Proccess_IMQ(thread->hpRoot);

    fiSetEventRecordNull(eventRecord);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoResetDevice);

}

/*+
  Function: DevActionDeviceResetDone
   Purpose: Completion state for successful device reset. Frees resources. Completes all IO's 
            on device.
 Called By: 
     Calls: CFuncCompleteActiveCDBThreadsOnDevice
            SFThreadFree
            DevEventAvailable
-*/
/* DevStateDeviceResetDone               17   */
extern void DevActionDeviceResetDone( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;
/*
    CDBThread_t * pCDBThread;
    fiList_t      * pCdbList;
*/
    if(CThread_ptr(thread->hpRoot)->DEVReset_pollingCount) CThread_ptr(thread->hpRoot)->DEVReset_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X DevResetCnt %x SFThread %p",
                    "DevActionDeviceResetDone",(char *)agNULL,
                    pSFThread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->DEVReset_pollingCount,
                    0,0,0,0,0);

    CFuncCompleteActiveCDBThreadsOnDevice(pDevThread, osIODevReset, CDBEventIODeviceReset );

    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree( thread->hpRoot, &pDevThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

    pDevThread->Failed_Reset_Count              = 0;
    fiSetEventRecord(eventRecord,thread,DevEventAvailable);


}

/*+
  Function: DevActionAL_PA_Self_OK
   Purpose: Completion state for verifing ALPA successful. Frees resources. 
 Called By: 
     Calls: SFThreadFree
-*/
/* DevStateAL_PA_Self_OK               18   */
extern void DevActionAL_PA_Self_OK( fi_thread__t *thread,eventRecord_t *eventRecord ){
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;

    if(CThread_ptr(thread->hpRoot)->FindDEV_pollingCount) CThread_ptr(thread->hpRoot)->FindDEV_pollingCount --;

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleLevelLip,
                    "In %s - State = %d   ALPA %X FDCnt %x SFThread %p",
                    "DevActionAL_PA_Self_OK",(char *)agNULL,
                    pSFThread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    fiSetEventRecordNull(eventRecord);
    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree( thread->hpRoot, &pDevThread->SFThread_Request );
        }
        else
        {
            fiLogDebugString(thread->hpRoot,
                        DevStateLogErrorLevel,
                        "In %s - State = %d   ALPA %X  FDCnt %x SFThread %p SF on free list Wrong !",
                        "DevActionAL_PA_Self_OK",(char *)agNULL,
                        pSFThread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        fiComputeDevThread_D_ID(pDevThread),
                        CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                        0,0,0,0,0);

        }

    }
    /* else _asm nop; */
    pDevThread->In_Verify_ALPA_FLAG = agFALSE;

}

/*+
  Function: DevActionAL_PA_Self_BAD
   Purpose: Completion state for verifing ALPA failure. Frees resources. 
 Called By: 
     Calls: SFThreadFree
-*/
/* DevStateAL_PA_Self_BAD               19   */
extern void DevActionAL_PA_Self_BAD( fi_thread__t *thread,eventRecord_t *eventRecord ){
    agRoot_t     * hpRoot     = thread->hpRoot;
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;

    if(CThread_ptr(thread->hpRoot)->FindDEV_pollingCount) CThread_ptr(thread->hpRoot)->FindDEV_pollingCount --;

    fiLogDebugString(hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x SFThread %p",
                    "DevActionAL_PA_Self_BAD",(char *)agNULL,
                    pSFThread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "%s FM %08X TL status %08X Qf %d",
                    "DevActionAL_PA_Self_BAD",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    CFunc_Queues_Frozen( hpRoot ),
                    0,0,0,0,0);

    fiLogDebugString(thread->hpRoot,
                    CStateLogConsoleERROR,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LOOP_DOWN,
                    CThread_ptr(hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(hpRoot)->ERQ_FROZEN,
                    CThread_ptr(hpRoot)->FCP_FROZEN,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0);

    fiSetEventRecordNull(eventRecord);
    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(hpRoot)->Free_SFLink)))
        {
            SFThreadFree( hpRoot, &pDevThread->SFThread_Request );
        }
        else
        {
            fiLogDebugString(hpRoot,
                        DevStateLogErrorLevel,
                        "In %s - State = %d   ALPA %X FDCnt %x SFThread %p SF on free list Wrong !",
                        "DevActionAL_PA_Self_BAD",(char *)agNULL,
                        pSFThread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        fiComputeDevThread_D_ID(pDevThread),
                        CThread_ptr(hpRoot)->FindDEV_pollingCount,
                        0,0,0,0,0);

        }
    }
    /* else _asm nop; */
    CFunc_Always_Enable_Queues(hpRoot);
    pDevThread->In_Verify_ALPA_FLAG = agFALSE;

}

/*+
  Function: DevActionDeviceResetDoneFAIL
   Purpose: Completion state for device reset failure. Frees resources. 
 Called By: 
     Calls: CFuncCompleteActiveCDBThreadsOnDevice
            SFThreadFree
-*/
/* DevStateDeviceResetDoneFAIL               20   */
extern void DevActionDeviceResetDoneFAIL( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;
/*
    CDBThread_t * pCDBThread;
    fiList_t      * pCdbList;
*/

    if(CThread_ptr(thread->hpRoot)->DEVReset_pollingCount) CThread_ptr(thread->hpRoot)->DEVReset_pollingCount--;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x SFThread %p DevCnt %x",
                    "DevActionDeviceResetDoneFAIL",(char *)agNULL,
                    pSFThread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    CThread_ptr(thread->hpRoot)->DEVReset_pollingCount,
                    0,0,0,0);

    CFuncCompleteActiveCDBThreadsOnDevice(pDevThread, osIODevReset, CDBEventIODeviceReset );

    fiSetEventRecordNull(eventRecord);
    pDevThread->Failed_Reset_Count              = 0;
    if(pSFThread != (SFThread_t *) agNULL)
    {
        if(! fiListElementOnList(  &(pSFThread->SFLink),
                                   &(CThread_ptr(thread->hpRoot)->Free_SFLink)))
        {
            SFThreadFree( thread->hpRoot, &pDevThread->SFThread_Request );
        }
    }
    /* else _asm nop; */

}

/*+
  Function: DevActionAllocAdisc
   Purpose: Begins ADISC recovery process 
 Called By: 
     Calls: SFThreadAlloc
            
-*/
/*  DevStateAllocAdisc              21   */
extern void DevActionAllocAdisc( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;

    CThread_ptr(thread->hpRoot)->ADISC_pollingCount ++;

    fiListEnqueueAtTail(&pDevThread->DevLink,
                        &CThread_ptr(thread->hpRoot)->AWaiting_ADISC_DevLink);

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "(%p )In %s - State = %d ALPA %X FDCnt %x",
                    "DevActionAllocAdisc",(char *)agNULL,
                    thread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    pDevThread->SFThread_Request.eventRecord_to_send.event = DevEventAdisc;
    pDevThread->SFThread_Request.eventRecord_to_send.thread = thread;

    fiSetEventRecordNull(eventRecord);

    SFThreadAlloc( thread->hpRoot, & pDevThread->SFThread_Request );

}

/*+
  Function: DevActionAllocAdisc
   Purpose: Sends ADISC recovery process 
 Called By: DevActionAllocAdisc
     Calls: SFEventDoAdisc
            
-*/
/* DevStateAdisc               22   */
extern void DevActionAdisc( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * DevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread = DevThread->SFThread_Request.SFThread;

    pSFThread->parent.Device = DevThread;

    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount ++;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d ALPA %X  FDCnt %x",
                    "DevActionAdisc",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    DevThread->DevInfo.CurrentAddress.AL_PA,
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,0,0,0,0,0);

    if( CFuncShowWhereCDBThreadsAre(thread->hpRoot))
    {
        CFuncWhatStateAreCDBThreads(thread->hpRoot);
    }

    fiSetEventRecordNull(eventRecord);

    fiSendEvent(&pSFThread->thread_hdr,SFEventDoAdisc);

}

/*+
  Function: DevActionAllocAdisc
   Purpose: Successful ADISC completion 
 Called By: SFActionAdiscAccept,DevEventAdiscDone_OK 
     Calls: DevEventPrliSuccess
            
-*/
/* DevStateAdisc_OK             23   */
extern void DevActionAdiscDone_OK( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;

    CThread_ptr(thread->hpRoot)->ADISC_pollingCount --;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x SFThread %p",
                    "DevActionAdisc_OK",(char *)agNULL,
                    pSFThread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,DevEventPrliSuccess);

}

/*+
  Function: DevActionAdiscDone_FAIL_No_Device
   Purpose: ADISC completion failed because device missing
 Called By: SFActionAdiscBadALPA,DevEventAdiscDone_FAIL_No_Device 
     Calls: DevEventPlogiFailed
            
-*/
/* DevStateAdiscDone_FAIL_No_Device    24   */
extern void DevActionAdiscDone_FAIL_No_Device( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;
    SFThread_t   * pSFThread  = pDevThread->SFThread_Request.SFThread;

    CThread_ptr(thread->hpRoot)->ADISC_pollingCount--;

    CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset, CDBEventIODeviceReset );

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x SFThread %p",
                    "DevActionAdiscDone_FAIL_No_Device",(char *)agNULL,
                    pSFThread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,DevEventPlogiFailed);
}

/*+
  Function: DevActionTickVerifyALPA
   Purpose: Heartbeat function sends PLOGI to self every timertick.
 Called By:  
     Calls: SFThreadAlloc
            
-*/
/* DevStateDoTickVerifyALPA             25 */
extern void DevActionTickVerifyALPA( fi_thread__t *thread,eventRecord_t *eventRecord  )
{
    DevThread_t  * pDevThread   = ( DevThread_t  * )thread;
    SFThread_t * pSFThread      = pDevThread->SFThread_Request.SFThread;

    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount ++;

    fiLogDebugString(thread->hpRoot,
                    DEVSTATE_NOISE(thread->hpRoot,CStateNormal),
                    "In %s - State = %d   ALPA %X  FDCnt %x SFThread %p",
                    "DevActionTickVerifyALPA",(char *)agNULL,
                    pSFThread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

    pDevThread->Plogi_Reason_Code = PLOGI_REASON_HEART_BEAT;

    pDevThread->SFThread_Request.eventRecord_to_send.event = DevEventTickGotSFThread;
    pDevThread->SFThread_Request.eventRecord_to_send.thread = thread;
    if(pDevThread->SFThread_Request.State != SFThread_Request_InActive)
    {   /*+ Check This DRL why proceed if sfthread is active ? -*/
        fiLogDebugString(thread->hpRoot,
                        DevStateLogErrorLevel,
                        "In %s - State = %d   ALPA %X FDCnt %x SFThread %p SF req State Wrong !",
                        "DevActionTickVerifyALPA",(char *)agNULL,
                        pSFThread,(void *)agNULL,
                        (os_bit32)thread->currentState,
                        fiComputeDevThread_D_ID(pDevThread),
                        CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                        0,0,0,0,0);
    }

    pDevThread->In_Verify_ALPA_FLAG = agTRUE;
    fiSetEventRecordNull(eventRecord);
    SFThreadAlloc( thread->hpRoot, & pDevThread->SFThread_Request );
}

/*+
  Function: DevActionExternalDeviceReset
   Purpose: Aborts all IO's if external device reset recieved. This is where a second
            host did a task mangement reset. Most likely IO's to this device will timeout
 Called By:  
     Calls: CFuncCompleteActiveCDBThreadsOnDevice
            CDBEvent_PrepareforAbort
            CDBEventAlloc_Abort
-*/
/*   DevStateExternalDeviceReset            26 */
extern void DevActionExternalDeviceReset( fi_thread__t *thread,eventRecord_t *eventRecord )
{

    DevThread_t  * pDevThread = ( DevThread_t  * )thread;

    fiLogDebugString(thread->hpRoot,
                    DEVSTATE_NOISE(thread->hpRoot,CStateNormal),
                    "In %s - State = %d   ALPA %X  FDCnt %x",
                    "DevActionExternalDeviceReset",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);
    /*+ Check This DRL Could mark these with ADLE and only abort the IOs that Timed out  -*/
    CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIOAborted, CDBEvent_PrepareforAbort);
    CFuncCompleteActiveCDBThreadsOnDevice(pDevThread, osIODevReset, CDBEventAlloc_Abort);

    fiSetEventRecord(eventRecord,thread,DevEventAvailable);
}

/*+
  Function: DevActionExternalDeviceReset
   Purpose: Does PLOGI for Heartbeat function
 Called By:  
     Calls: SFEventDoPlogi
-*/
/* DevStateTickGotSFThread             27 */
extern void DevActionTickGotSFThread( fi_thread__t *thread,eventRecord_t *eventRecord  )
{
    DevThread_t  * pDevThread   = ( DevThread_t  * )thread;
    SFThread_t * pSFThread      = pDevThread->SFThread_Request.SFThread;

    pSFThread->parent.Device = pDevThread;

    fiLogDebugString(thread->hpRoot,
                    DEVSTATE_NOISE(thread->hpRoot,CStateNormal),
                    "In %s - State = %d   ALPA %X  FDCnt %x SFThread %p",
                    "DevActionTickVerifyALPA",(char *)agNULL,
                    pSFThread,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);


    fiSetEventRecordNull(eventRecord);
    /* Send event to SFthread */
    fiSendEvent(&pSFThread->thread_hdr,SFEventDoPlogi);

}

/*+
  Function: DevAction_IO_Ready
   Purpose: This is the default state for sending IO's. Moves queued IOs from Send_IO_CDBLink
            to Active_CDBLink_0
 Called By: DevEventSendIO 
     Calls: CDBEventInitialize
-*/
/*  DevState_IO_Ready            28 */
extern void DevAction_IO_Ready( fi_thread__t *thread,eventRecord_t *eventRecord  )
{
    DevThread_t  * pDevThread   = ( DevThread_t  * )thread;
    CDBThread_t  * pCDBThread;
    fiList_t    *  pCdbList = agNULL;

#ifndef Performance_Debug

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x Link %p",
                    "DevAction_IO_Ready",(char *)agNULL,
                    pCdbList,NULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);

#endif /* Performance_Debug was not defined */
    
    Device_IO_Throttle_Increment

    while(fiListNotEmpty( &pDevThread->Send_IO_CDBLink  ))
    {
        fiListDequeueFromHeadFast(&pCdbList,
                                  &pDevThread->Send_IO_CDBLink );

        pCDBThread = hpObjectBase(CDBThread_t,
                                  CDBLink, pCdbList);

        fiListEnqueueAtTail(pCdbList,
                           &(pDevThread->Active_CDBLink_0));

        /* Send event to CDB thread */
        fiSendEvent( &(pCDBThread->thread_hdr), CDBEventInitialize );
    }

    fiSetEventRecordNull(eventRecord);


}

/*+
  Function: DevAction_FC_TAPE_Recovery
   Purpose: Used in FC TAPE Recovery

 Called By: DevEventSendIO DevEvent_FC_TAPE_Recovery
     Calls: CDBEventInitialize
-*/
/*  DevState_FC_TAPE_Recovery            29 */
extern void DevAction_FC_TAPE_Recovery( fi_thread__t *thread,eventRecord_t *eventRecord  )
{

    DevThread_t  * pDevThread   = ( DevThread_t  * )thread;

    fiLogDebugString(thread->hpRoot,
                    DevStateLogConsoleLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x",
                    "DevAction_FC_TAPE_Recovery",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    CThread_ptr(thread->hpRoot)->FindDEV_pollingCount,
                    0,0,0,0,0);


    fiSetEventRecordNull(eventRecord);
}

/*+
  Function: DevActionAdiscDone_FAIL_ReLogin
   Purpose: When ADISC to the device responded with reject, relogin to device.
            ADISC rejects occur if it takes to long to send ADISC or a loop state timeout
            conditions existed to the device.

 Called By: SFActionAdiscRej,DevEventAdiscDone_FAIL_ReLogin 
     Calls: DevEventGotSFThread
-*/
/* DevStateAdiscDone_FAIL_ReLogin        30     */
extern void DevActionAdiscDone_FAIL_ReLogin( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t     * hpRoot     = thread->hpRoot;
    CThread_t    * pCThread   = CThread_ptr(hpRoot);
    DevThread_t  * DevThread = ( DevThread_t  * )thread;

    pCThread->ADISC_pollingCount--;

    CFuncCompleteActiveCDBThreadsOnDevice(DevThread ,osIODevReset, CDBEventIODeviceReset );

    fiLogDebugString(thread->hpRoot,
                    DevStateLogErrorLevel,
                    "In %s - State = %d   ALPA %X FDCnt %x",
                    "DevActionAdiscDone_FAIL_ReLogin",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    DevThread->DevInfo.CurrentAddress.AL_PA,
                    pCThread->FindDEV_pollingCount,
                    0,0,0,0,0);

    fiSetEventRecord(eventRecord,thread,DevEventGotSFThread);
}

/*+
  Function: DevActionNoDevice
   Purpose: If device goes missing.

 Called By: DevEvent_Device_Gone 
            CActionFindDeviceUseNameServer 
            CFuncCompleteActiveCDBThreadsOnDevice
            CFuncFMCompletion

     Calls: DevEventPlogiFailed
-*/
/*  DevStateNoDevice       31     */
extern void DevActionNoDevice( fi_thread__t *thread,eventRecord_t *eventRecord )
{
    agRoot_t     * hpRoot     = thread->hpRoot;
    CThread_t    * pCThread   = CThread_ptr(hpRoot);
    DevThread_t  * pDevThread = ( DevThread_t  * )thread;

    fiLogString(thread->hpRoot,
                    "In %s - State = %d ALPA %X FDCnt %x",
                    "DevActionNoDevice",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)thread->currentState,
                    fiComputeDevThread_D_ID(pDevThread),
                    pCThread->FindDEV_pollingCount,
                    0,0,0,0,0);

    pDevThread->Prev_Active_Device_FLAG = 0;
    /*+ Check This DRL Does this function complete all queues -*/
    CFuncCompleteActiveCDBThreadsOnDevice(pDevThread ,osIODevReset, CDBEventIODeviceReset );

    fiSetEventRecord(eventRecord,thread,DevEventPlogiFailed);
}



#endif /* USESTATEMACROS */

/*+
  Function: DevState_c
   Purpose: When compiled updates browser info file for VC 5.0 / 6.0
   Returns: none
 Called By: none
     Calls: none
-*/
/*void DevState_c(void){}  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\fcciioct.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

   FCCIIoct.c

Abstract:

   FCCI Ioctl Handler

Author:
   PS - Pooni Subranamiyam   HP FCCI
   LP - Leopold Purwadihardja

Revision History:

Environment:

   kernel mode only

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/C/fcciioct.c $

Revision History:

   $Revision: 5 $
   $Date: 11/10/00 5:50p $
   $Modtime:: $

--*/


#include "buildop.h"
#include "osflags.h"
#include "hhba5100.ver"

#ifdef _FCCI_SUPPORT

void
FcciFillDriverInfo(
   PSRB_IO_CONTROL srbIoCtl,
   AFCCI_DRIVER_INFO *FcciDriverInfo,
   UCHAR *status
   )
{

   if  (srbIoCtl->Length < ( sizeof(FCCI_DRIVER_INFO )    + 
                            sizeof(LDRIVER_NAME)         + 
                            sizeof(LDRIVER_DESCRIPTION)  +
                       sizeof(LDRIVER_VERSION_STR)  +
                             sizeof(LVER_COMPANYNAME_STR)))
   
   {
      FcciDriverInfo->out.DriverNameLength = (sizeof(LDRIVER_NAME) / sizeof(WCHAR));
      FcciDriverInfo->out.DriverDescriptionLength = (sizeof(LDRIVER_DESCRIPTION) / sizeof(WCHAR));
      FcciDriverInfo->out.DriverVersionLength = (sizeof(LDRIVER_VERSION_STR) / sizeof(WCHAR));
      FcciDriverInfo->out.DriverVendorLength = (sizeof(LVER_COMPANYNAME_STR) / sizeof(WCHAR));
      srbIoCtl->ReturnCode = FCCI_RESULT_INSUFFICIENT_BUFFER;
   } 
   else 
   {
      FcciDriverInfo->out.DriverNameLength = (sizeof(LDRIVER_NAME) /sizeof(WCHAR));
      memcpy(FcciDriverInfo->out.DriverName, LDRIVER_NAME, sizeof(LDRIVER_NAME));
      FcciDriverInfo->out.DriverDescriptionLength = (sizeof(LDRIVER_DESCRIPTION) / sizeof(WCHAR));
      memcpy(FcciDriverInfo->out.DriverDescription, LDRIVER_DESCRIPTION,
                                     sizeof(LDRIVER_DESCRIPTION));
      FcciDriverInfo->out.DriverVersionLength = (sizeof(LDRIVER_VERSION_STR) / sizeof(WCHAR));
      memcpy(FcciDriverInfo->out.DriverVersion, LDRIVER_VERSION_STR,sizeof(LDRIVER_VERSION_STR));
      FcciDriverInfo->out.DriverVendorLength = (sizeof(LVER_COMPANYNAME_STR) /sizeof(WCHAR));
      memcpy(FcciDriverInfo->out.DriverVendor, LVER_COMPANYNAME_STR,sizeof(LVER_COMPANYNAME_STR));
      srbIoCtl->ReturnCode = FCCI_RESULT_SUCCESS;
   }

}

void
FcciFillAdapterInfo(
   PSRB_IO_CONTROL srbIoCtl,
   AFCCI_ADAPTER_INFO *FcciAdapterInfo,
   PCARD_EXTENSION pCard,
   UCHAR *status
   )
{
    

   if  (srbIoCtl->Length <  (sizeof(FCCI_ADAPTER_INFO)    +
                            sizeof(LVER_COMPANYNAME_STR) + 
                            sizeof(PRODUCT_NAME)         +
                       sizeof(MODEL_NAME)           +
                             sizeof(SERIAL_NUMBER)))
   
   {
      FcciAdapterInfo->out.VendorNameLength =  (sizeof(LVER_COMPANYNAME_STR) / sizeof(WCHAR));
      FcciAdapterInfo->out.ProductNameLength = (sizeof(PRODUCT_NAME) / sizeof(WCHAR));
      FcciAdapterInfo->out.ModelNameLength =   (sizeof(MODEL_NAME) /sizeof(WCHAR));
      FcciAdapterInfo->out.SerialNumberLength = (sizeof(SERIAL_NUMBER) /sizeof(WCHAR));
      srbIoCtl->ReturnCode = FCCI_RESULT_INSUFFICIENT_BUFFER;
   } 
   else 
   {
      FcciAdapterInfo->out.PortCount     = PORT_COUNT; // Number of SCSI target ports
      FcciAdapterInfo->out.BusCount      = FCCI_MAX_BUS;
      FcciAdapterInfo->out.TargetsPerBus = FCCI_MAX_TGT;
      FcciAdapterInfo->out.LunsPerTarget = FCCI_MAX_LUN;
      FcciAdapterInfo->out.VendorNameLength   = (sizeof(LVER_COMPANYNAME_STR) / sizeof(WCHAR));
      FcciAdapterInfo->out.ProductNameLength  = (sizeof(PRODUCT_NAME) / sizeof(WCHAR));
      FcciAdapterInfo->out.ModelNameLength    = (sizeof(MODEL_NAME) / sizeof(WCHAR));
      FcciAdapterInfo->out.SerialNumberLength = (sizeof(SERIAL_NUMBER) / sizeof(WCHAR));
      memcpy(FcciAdapterInfo->out.VendorName, LVER_COMPANYNAME_STR, sizeof(LVER_COMPANYNAME_STR));
      memcpy(FcciAdapterInfo->out.ProductName, PRODUCT_NAME, sizeof(PRODUCT_NAME));
      memcpy(FcciAdapterInfo->out.ModelName,  MODEL_NAME, sizeof(MODEL_NAME));
      memcpy(FcciAdapterInfo->out.SerialNumber,SERIAL_NUMBER, sizeof(SERIAL_NUMBER));
      srbIoCtl->ReturnCode = FCCI_RESULT_SUCCESS;

   }
}

#define ChipIOUp_Frame_Manager_Status_NP    0x20000000

void
FcciFillAdapterPortInfo(
   PSRB_IO_CONTROL srbIoCtl,
   FCCI_ADAPTER_PORT_INFO *FcciAdapterPortInfo,
   PCARD_EXTENSION pCard,
   UCHAR *status
   )
{
   os_bit32 FM_Status;
   agFCChanInfo_t  chanInfo;
   agRoot_t        *hpRoot=&pCard->hpRoot;
   ULONG PortNumber;

   PortNumber = FcciAdapterPortInfo->in.PortNumber;
   /* If more than one miniport object per adapter then we need to do something *
   /* As of now do nothing  */

   fcGetChannelInfo (hpRoot, &chanInfo);

   osCopy(FcciAdapterPortInfo->out.NodeWWN, chanInfo.NodeWWN, 8);
   osDEBUGPRINT((ALWAYS_PRINT,"HPFillAdapterInfo: NodeWWN 0x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                                chanInfo.NodeWWN[0],chanInfo.NodeWWN[1],
                                chanInfo.NodeWWN[2],chanInfo.NodeWWN[3],
                                chanInfo.NodeWWN[4],chanInfo.NodeWWN[5],
                                chanInfo.NodeWWN[6],chanInfo.NodeWWN[7] ));
   FcciAdapterPortInfo->out.Flags |= FCCI_FLAG_NodeWWN_Valid;
   osCopy(FcciAdapterPortInfo->out.PortWWN, chanInfo.PortWWN, 8);
   FcciAdapterPortInfo->out.Flags |= FCCI_FLAG_PortWWN_Valid;
   osDEBUGPRINT((ALWAYS_PRINT,"HPFillAdapterInfo: PortWWN 0x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                                chanInfo.PortWWN[0],chanInfo.PortWWN[1],
                                chanInfo.PortWWN[2],chanInfo.PortWWN[3],
                                chanInfo.PortWWN[4],chanInfo.PortWWN[5],
                                chanInfo.PortWWN[6],chanInfo.PortWWN[7] ));
   FcciAdapterPortInfo->out.NportId = chanInfo.CurrentAddress.AL_PA;
   FcciAdapterPortInfo->out.Flags |= FCCI_FLAG_NportID_Valid;
   osDEBUGPRINT((ALWAYS_PRINT,"HPFillAdapterInfo: Alpa = 0x%02x\n",chanInfo.CurrentAddress.AL_PA));
   FcciAdapterPortInfo->out.PortTopology  = FCCI_PORT_TOPO_PTOP_FABRIC; // Current Topology

   FM_Status = osChipIOUpReadBit32(pCard->hpRoot, 0xC8);
   
   if( FM_Status & ChipIOUp_Frame_Manager_Status_NP )
      FcciAdapterPortInfo->out.PortState = FCCI_PORT_STATE_NON_PARTICIPATING;
   
   switch (pCard->State) 
   {
      case CS_DRIVER_ENTRY         :
      case CS_DURING_DRV_ENTRY     :
      case CS_DURING_FINDADAPTER   :
      case CS_DURING_DRV_INIT      :
      case CS_DURING_RESET_ADAPTER :
         FcciAdapterPortInfo->out.PortState = FCCI_PORT_STATE_INITIALIZING;
         break;
         
      case CS_FCLAYER_LOST_IO   :
      case CS_DURING_STARTIO    :         
      case CS_DURING_ISR        :        
      case CS_DURING_OSCOMPLETE :       
      case CS_HANDLES_GOOD      :        
      case CS_DURING_ANY        :     
      case CS_DUR_ANY_ALL       :      
      case CS_DUR_ANY_MOD       :      
      case CS_DUR_ANY_LOW       : 
         if (pCard->LinkState == LS_LINK_UP)
            FcciAdapterPortInfo->out.PortState = FCCI_PORT_STATE_NORMAL; // Current Adapter State
         break;
      default              :
         FcciAdapterPortInfo->out.PortState = 0;
   }
   srbIoCtl->ReturnCode = FCCI_RESULT_SUCCESS;

}

void
FcciFillLogUnitInfo(
   PSRB_IO_CONTROL srbIoCtl,
   FCCI_LOGUNIT_INFO *FcciLogUnitInfo,
   PCARD_EXTENSION pCard,
   UCHAR *status
   )
{
   agFCDev_t hpFcDev;
   agFCDevInfo_t hpFcDevInfo;
   UCHAR PathId, TargetId, Lun;
   agRoot_t * hpRoot=&pCard->hpRoot;
   PLU_EXTENSION pLunExt = NULL;     /* added for YAM21 support */
   LUN tempLun;                        /* added for FCP Lun data */
   PLUN ptempLun = &tempLun;
      
   PathId   = (UCHAR) FcciLogUnitInfo->in.TargetAddress.PathId;
   TargetId = (UCHAR)FcciLogUnitInfo->in.TargetAddress.TargetId;
   Lun      = (UCHAR)FcciLogUnitInfo->in.TargetAddress.Lun;
    
   /* Grab the Lun Extension, to be used in MapToHandle */
   pLunExt = ScsiPortGetLogicalUnit(pCard,
                                     PathId,
                                     TargetId,
                                     Lun );
   if (pLunExt != NULL) 
   {
      hpFcDev = MapToHandle(pCard, PathId, TargetId, Lun, pLunExt);
      if (hpFcDev != NULL) 
      {
         fcGetDeviceInfo(hpRoot, hpFcDev, &hpFcDevInfo);
         osCopy(FcciLogUnitInfo->out.NodeWWN, hpFcDevInfo.NodeWWN, 8);
         FcciLogUnitInfo->out.Flags |= FCCI_FLAG_NodeWWN_Valid;
         osCopy(FcciLogUnitInfo->out.PortWWN, hpFcDevInfo.PortWWN, 8);
         FcciLogUnitInfo->out.Flags |= FCCI_FLAG_PortWWN_Valid;
         FcciLogUnitInfo->out.NportId = hpFcDevInfo.CurrentAddress.AL_PA;
         FcciLogUnitInfo->out.Flags |= FCCI_FLAG_NportID_Valid;
         if (hpFcDevInfo.Present)
            FcciLogUnitInfo->out.Flags |= FCCI_FLAG_Exists;
         if (hpFcDevInfo.LoggedIn)
            FcciLogUnitInfo->out.Flags |= FCCI_FLAG_Logged_In;
   
   
         /* Get the FCP lun data */
         
         memset(ptempLun, 0, sizeof(LUN));
         if(pLunExt)
         {
            FcciLogUnitInfo->out.Flags |= FCCI_FLAG_LogicalUnit_Valid;
            switch(pLunExt->Mode)
            {
               case PA_DEVICE_TRY_MODE_VS:
                  SET_VS_LUN(ptempLun, PathId, TargetId, Lun)
                  memcpy(&(FcciLogUnitInfo->out.LogicalUnitNumber), ptempLun, sizeof(LUN)); 
                  break;
         
               case PA_DEVICE_TRY_MODE_LU:
                  SET_LU_LUN(ptempLun, PathId, TargetId, Lun)
                  memcpy(&(FcciLogUnitInfo->out.LogicalUnitNumber), ptempLun, sizeof(LUN)); 
                  break;
         
               case PA_DEVICE_TRY_MODE_PA:
                  SET_PA_LUN(ptempLun, PathId, TargetId, Lun)
                  memcpy(&(FcciLogUnitInfo->out.LogicalUnitNumber), ptempLun, sizeof(LUN)); 
                  break;
               
               default:
                  FcciLogUnitInfo->out.Flags &= ~FCCI_FLAG_LogicalUnit_Valid;

            } // end switch
         
         } // end if ( pLunExt )
      
      }
      else 
      {
         srbIoCtl->ReturnCode = FCCI_RESULT_INVALID_TARGET;
      }
   }
   else 
   {
      srbIoCtl->ReturnCode = FCCI_RESULT_INVALID_TARGET;
   }
   srbIoCtl->ReturnCode = FCCI_RESULT_SUCCESS;
}

void
FcciFillDeviceInfo(
   PSRB_IO_CONTROL srbIoCtl,
   AFCCI_DEVICE_INFO *FcciGetDeviceInfo,
   PCARD_EXTENSION pCard,
   UCHAR *status
   )
{
   agFCDev_t       hpFcDev;
   agFCDevInfo_t   hpFcDevInfo;
   UCHAR PathId, TargetId, Lun;
   agRoot_t        *hpRoot = &pCard->hpRoot;
   PLU_EXTENSION  pLunExt = NULL;
   int gNumberOfDevices = 0;
   int Count = 0;

   for (PathId = 0; PathId < NUMBER_OF_BUSES; PathId++) 
   {
      for (TargetId = 0; TargetId < MAXIMUM_TID; TargetId++) 
      {
         pLunExt = NULL;
         Lun = 0;
         pLunExt = ScsiPortGetLogicalUnit(pCard,
                                             PathId,
                                             TargetId,
                                             Lun );
                                   
         hpFcDev = MapToHandle(pCard, PathId, TargetId, Lun, pLunExt);
         if (hpFcDev != NULL) gNumberOfDevices++;
      }
   }

   Count = 0;
   if  (srbIoCtl->Length < ((gNumberOfDevices * sizeof(FCCI_DEVICE_INFO_ENTRY)) + sizeof(FCCI_DEVICE_INFO_OUT))) 
   {
      FcciGetDeviceInfo->out.TotalDevices = gNumberOfDevices;
      FcciGetDeviceInfo->out.OutListEntryCount = 0;
      srbIoCtl->ReturnCode = FCCI_RESULT_INSUFFICIENT_BUFFER;
   } 
   else 
   {
      srbIoCtl->ReturnCode = FCCI_RESULT_SUCCESS;
      FcciGetDeviceInfo->out.TotalDevices = gNumberOfDevices;
      FcciGetDeviceInfo->out.OutListEntryCount = gNumberOfDevices;
      for (PathId = 0; PathId < FCCI_MAX_BUS; PathId++) 
      {
         for (TargetId = 0; TargetId < FCCI_MAX_TGT; TargetId++) 
         {
            pLunExt = NULL;
            Lun = 0;
            pLunExt = ScsiPortGetLogicalUnit(pCard,
                                             PathId,
                                             TargetId,
                                             Lun );
            hpFcDev = MapToHandle(pCard, PathId, TargetId, Lun, pLunExt);
            if (hpFcDev != NULL) 
            {
               memset(&hpFcDevInfo, 0, sizeof( agFCDevInfo_t));
               fcGetDeviceInfo(hpRoot, hpFcDev, &hpFcDevInfo);
               osCopy(FcciGetDeviceInfo->out.entryList[Count].NodeWWN,hpFcDevInfo.NodeWWN,8);
               FcciGetDeviceInfo->out.entryList[Count].Flags |= FCCI_FLAG_NodeWWN_Valid;
               osCopy(FcciGetDeviceInfo->out.entryList[Count].PortWWN,hpFcDevInfo.PortWWN,8);
               FcciGetDeviceInfo->out.entryList[Count].Flags |= FCCI_FLAG_PortWWN_Valid;
               FcciGetDeviceInfo->out.entryList[Count].NportId = hpFcDevInfo.CurrentAddress.AL_PA;
               FcciGetDeviceInfo->out.entryList[Count].Flags |= FCCI_FLAG_NportID_Valid;
               if (hpFcDevInfo.Present)
                  FcciGetDeviceInfo->out.entryList[Count].Flags |= FCCI_FLAG_Exists;
               if (hpFcDevInfo.LoggedIn)
                  FcciGetDeviceInfo->out.entryList[Count].Flags |= FCCI_FLAG_Logged_In;
               FcciGetDeviceInfo->out.entryList[Count].TargetAddress.PathId = PathId;
               FcciGetDeviceInfo->out.entryList[Count].TargetAddress.TargetId = TargetId;
               FcciGetDeviceInfo->out.entryList[Count].TargetAddress.Lun = Lun;
               FcciGetDeviceInfo->out.entryList[Count].Flags |= FCCI_FLAG_TargetAddress_Valid;
               Count++;
            }
         }
      }
   }

}

void
FcciDoDeviceReset(
   PSRB_IO_CONTROL srbIoCtl,
   FCCI_RESET_TARGET *FcciResetTarget,
   PCARD_EXTENSION pCard,
   UCHAR *PathId,
   UCHAR *TargetId,
   UCHAR *status
   )
{
   agRoot_t * hpRoot=&pCard->hpRoot;
   agFCDev_t hpFcDev;
   ULONG ResetStatus;
   UCHAR Lun;

   *PathId   = (UCHAR)FcciResetTarget->in.PathId;
   *TargetId = (UCHAR)FcciResetTarget->in.TargetId;
   Lun       = (UCHAR)FcciResetTarget->in.Lun;
   hpFcDev = MapToHandle(pCard, *PathId, *TargetId, Lun, NULL);
   if (hpFcDev == NULL ||
        (ResetStatus = fcResetDevice(hpRoot, hpFcDev, fcHardReset)) != fcResetSuccess) 
   {
      srbIoCtl->ReturnCode = FCCI_RESULT_HARD_ERROR;
   }
}

ULONG FCCIIoctl(
   IN PCARD_EXTENSION pCard,
   IN PSCSI_REQUEST_BLOCK Srb,
   BOOLEAN    *LinkResetPerformed,
   BOOLEAN    *DeviceResetPerformed,
   UCHAR       *srb_status,
   UCHAR       *PathId, 
   UCHAR       *TargetId
   )
{
   agRoot_t * phpRoot      =   &pCard->hpRoot;
   PSRB_EXTENSION pSrbExt  =   Srb->SrbExtension;
   PSRB_IO_CONTROL srbIoCtl;
   UCHAR status;
// PSRB_IO_CONTROL srbIoCtl;
// ULONG    done = FALSE;
//   UCHAR    srbPathId = Srb->PathId;
//   UCHAR    srbTargetId = Srb->TargetId;
//   UCHAR    srbLun = Srb->Lun;

   status = *srb_status;
   
   srbIoCtl = ((PSRB_IO_CONTROL)(Srb->DataBuffer));

   switch (srbIoCtl->ControlCode) 
   {
      case FCCI_SRBCTL_GET_DRIVER_INFO : 
      {
         AFCCI_DRIVER_INFO *AFcciDriverInfo;

         if (FCCI_BufferLengthIsValid((PUCHAR)Srb->DataBuffer, 
                                                    Srb->DataTransferLength)) 
         {
            AFcciDriverInfo = (AFCCI_DRIVER_INFO *)FCCI_GetCommandBuffer(Srb->DataBuffer); 
            FcciFillDriverInfo(srbIoCtl, AFcciDriverInfo, &status);
         }
         else 
         {
            srbIoCtl->ReturnCode = FCCI_RESULT_INSUFFICIENT_BUFFER;
         }
         break;
      }

      case FCCI_SRBCTL_GET_ADAPTER_INFO : 
      {
         AFCCI_ADAPTER_INFO *AFcciAdapterInfo;
         
         if (FCCI_BufferLengthIsValid((PUCHAR)Srb->DataBuffer, 
                                                    Srb->DataTransferLength)) 
         {
            AFcciAdapterInfo = (AFCCI_ADAPTER_INFO *)FCCI_GetCommandBuffer(Srb->DataBuffer); 
            FcciFillAdapterInfo(srbIoCtl, AFcciAdapterInfo, pCard, &status);
         }
         else 
         {
            srbIoCtl->ReturnCode = FCCI_RESULT_INSUFFICIENT_BUFFER;
         }
         break;
      }

      case FCCI_SRBCTL_GET_ADAPTER_PORT_INFO : 
      {
         FCCI_ADAPTER_PORT_INFO *FcciAdapterPortInfo;
         
         if (FCCI_BufferLengthIsValid((PUCHAR)Srb->DataBuffer, 
                                                    Srb->DataTransferLength)) 
         {
            FcciAdapterPortInfo = (FCCI_ADAPTER_PORT_INFO *)FCCI_GetCommandBuffer(Srb->DataBuffer); 
            FcciFillAdapterPortInfo(srbIoCtl, FcciAdapterPortInfo, pCard,  &status);
         }
         else 
         {
            srbIoCtl->ReturnCode = FCCI_RESULT_INSUFFICIENT_BUFFER;
         }
         break;
      }

      case FCCI_SRBCTL_GET_LOGUNIT_INFO : 
      {
         FCCI_LOGUNIT_INFO *FcciLogUnitInfo;
         
         if (FCCI_BufferLengthIsValid((PUCHAR)Srb->DataBuffer, Srb->DataTransferLength)) 
         {
            FcciLogUnitInfo = (FCCI_LOGUNIT_INFO *)FCCI_GetCommandBuffer(Srb->DataBuffer); 
            FcciFillLogUnitInfo(srbIoCtl, FcciLogUnitInfo, pCard, &status);
         }
         else 
         {
            srbIoCtl->ReturnCode = FCCI_RESULT_INSUFFICIENT_BUFFER;
         }
         break;
      }

      case FCCI_SRBCTL_GET_DEVICE_INFO : 
      {
         AFCCI_DEVICE_INFO *AFcciDeviceInfo;
         BOOLEAN BufferLengthValid;
         
         if (FCCI_BufferLengthIsValid((PUCHAR)Srb->DataBuffer, Srb->DataTransferLength)) 
         {
            AFcciDeviceInfo = (AFCCI_DEVICE_INFO *)FCCI_GetCommandBuffer(Srb->DataBuffer); 
            FcciFillDeviceInfo(srbIoCtl, AFcciDeviceInfo, pCard, &status);
         }
         else 
         {
            srbIoCtl->ReturnCode = FCCI_RESULT_INSUFFICIENT_BUFFER;
         }
         break;
      }
        
      case FCCI_SRBCTL_RESET_TARGET : 
      {
         FCCI_RESET_TARGET *FcciResetTarget;
         if (FCCI_BufferLengthIsValid((PUCHAR)Srb->DataBuffer, Srb->DataTransferLength)) 
         {
            FcciResetTarget = (FCCI_RESET_TARGET *)FCCI_GetCommandBuffer(Srb->DataBuffer); 
            FcciDoDeviceReset(srbIoCtl, FcciResetTarget,pCard,PathId,TargetId,&status);
         }
         else 
         {
            srbIoCtl->ReturnCode = FCCI_RESULT_INSUFFICIENT_BUFFER;
         }
         break;
      }
               
      default :
         osDEBUGPRINT((ALWAYS_PRINT,"HPFibreStartIo: MiniportIOCtl not supported\n"));
         srbIoCtl->ReturnCode = HP_FC_RTN_BAD_CTL_CODE;

   } // end IOCTL switch
   
   *srb_status = status;
   return 0;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\fccint.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   fccint.c

Abstract:

Authors:

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/fccint.h $


Revision History:

   $Revision: 3 $
   $Date: 9/07/00 11:57a $
   $Modtime:: 9/07/00 11:57a           $

Notes:


--*/

//fccint.h
/*-------------- Fibre Channel Port Common Interface Definitions -------------*/

#ifndef _FCCI_NT_H //{
#define _FCCI_NT_H

#ifndef _NTDDSCSIH_
   #error You must include ntddscsi.h prior to this header.
#endif

/* FOR REFERENCE - from NTDDSCSI.h

typedef struct _SRB_IO_CONTROL 
{
        ULONG HeaderLength;
        UCHAR Signature[8];
        ULONG Timeout;
        ULONG ControlCode;
        ULONG ReturnCode;
        ULONG Length;
} SRB_IO_CONTROL, *PSRB_IO_CONTROL;

*/

/* 
pSRB->DataBuffer points to a buffer with the following layout and
length of pSRB->DataTransferLength.

  pSRB->DataBuffer
  { 
   SRB_IO_CONTROL Header Structure
   { 
        ULONG HeaderLength;
        UCHAR Signature[8];
        ULONG Timeout;
        ULONG ControlCode;
        ULONG ReturnCode;
        ULONG Length;
   } 

   CommandBuffer (variable in length*, can be of zero length)
   { 
        ....
   } 
  }
  
   * The length of the command buffer is SRB_IO_CONTROL.Length
*/

/*----- SRBCTL Signature -----------------------------------------------------*/
#define FCCI_SIGNATURE_VERSION_01               "FC_CI_01"

#define FCCI_SIGNATURE                          FCCI_SIGNATURE_VERSION_01

/*----- List of Control Codes ------------------------------------------------*/
#define FCCI_SRBCTL_GET_DRIVER_INFO             1
#define FCCI_SRBCTL_GET_ADAPTER_INFO       2
#define FCCI_SRBCTL_GET_ADAPTER_PORT_INFO  3
#define FCCI_SRBCTL_GET_LOGUNIT_INFO       4
#define FCCI_SRBCTL_GET_DEVICE_INFO             5
#define FCCI_SRBCTL_RESET_TARGET           6
#define FCCI_SRBCTL_INIT_EVENT_QUEUE       7
#define FCCI_SRBCTL_TERM_EVENT_QUEUE       8
#define FCCI_SRBCTL_QUEUE_EVENT                 9

/*----- Return Codes ---------------------------------------------------------*/
#define FCCI_RESULT_SUCCESS                     0
#define FCCI_RESULT_HARD_ERROR                  1
#define FCCI_RESULT_TEMP_ERROR                  2
#define FCCI_RESULT_UNKOWN_CTL_CODE             3
#define FCCI_RESULT_INSUFFICIENT_BUFFER         4
#define FCCI_RESULT_INVALID_TARGET              5

/*----- Flags ----------------------------------------------------------------*/
#define FCCI_FLAG_NodeWWN_Valid                 0x00000001
#define FCCI_FLAG_PortWWN_Valid                 0x00000002
#define FCCI_FLAG_NportID_Valid                 0x00000004
#define FCCI_FLAG_LogicalUnit_Valid             0x00000008
#define FCCI_FLAG_TargetAddress_Valid      0x00000010

#define FCCI_FLAG_Logged_In                     0x00000100
#define FCCI_FLAG_Exists                        0x00000200

/*----- Global & Shared data structures and defines --------------------------*/

typedef struct _FCCI_TARGET_ADDRESS 
{
   ULONG     PathId;                  // ULONG to be forward compatible
   ULONG     TargetId;           // ULONG to be forward compatible
   ULONG     Lun;                // ULONG to be forward compatible
} FCCI_TARGET_ADDRESS, *PFCCI_TARGET_ADDRESS;

// FCCI_BufferLengthIsValid
// pDataBuffer: Pointer to data buffer pointer to by the SRB DataBuffer field
//  nDataTransferLength: Length of data buffer from SRB DataTransferLength field
//
// returns:
//      TRUE if buffer length is valid
//      FALSE if buffer length is not valid
__inline 
BOOLEAN 
FCCI_BufferLengthIsValid( PVOID pDataBuffer, ULONG nDataTransferLength )
{
   PSRB_IO_CONTROL pHeader = (PSRB_IO_CONTROL) pDataBuffer;
   
   if ( nDataTransferLength < sizeof(SRB_IO_CONTROL) )
        return FALSE;

   if ( pHeader->HeaderLength < sizeof(SRB_IO_CONTROL) )
        return FALSE;

   if ( pHeader->Length + pHeader->HeaderLength > nDataTransferLength )
        return FALSE;

   return TRUE;
}

// FCCI_GetIOControlHeader
// pDataBuffer: Pointer to data buffer pointer to by the SRB DataBuffer field
//
// returns:
//      A pointer to the SRB_IO_CONTROL structure contained in SRB DataBuffer.
__inline 
PSRB_IO_CONTROL
FCCI_GetIOControlHeader( PVOID pDataBuffer )
{
   return (PSRB_IO_CONTROL) pDataBuffer;
}

// FCCI_GetCommandBuffer
// pDataBuffer: Pointer to data buffer pointer to by the SRB DataBuffer field
//
// returns:
//      A pointer to the command buffer contained in SRB DataBuffer
//      or it can return NULL if not command buffer exists.
__inline 
PVOID 
FCCI_GetCommandBuffer( PVOID pDataBuffer )
{
   PSRB_IO_CONTROL pHeader = (PSRB_IO_CONTROL) pDataBuffer;
   PUCHAR pBuffer = (PUCHAR) pDataBuffer;
   
   if ( pHeader->HeaderLength == 0 )
        return NULL;

   return (PVOID) ( pBuffer + pHeader->HeaderLength );
}

// FCCI_SetSignature
// pHeader:  Pointer to a SRB_IO_CONTROL structure
// pSig:          Pointer to the signature char buffer
__inline 
void 
FCCI_SetSignature( PSRB_IO_CONTROL pHeader, PUCHAR pSig )
{
   *((ULONGLONG*)&pHeader->Signature) = *((ULONGLONG*)&pSig);
}

// FCCI_IsSignature
// pHeader:  Pointer to a SRB_IO_CONTROL structure
// pSig:          Pointer to the signature char buffer
//
// returns:
//      TRUE if signatures match
//      FALSE if they don't
__inline 
BOOLEAN 
FCCI_IsSignature( PSRB_IO_CONTROL pHeader, PUCHAR pSig )
{
   ULONGLONG nSigA, nSigB;

   nSigA = *((ULONGLONG*)&pHeader->Signature);
   nSigB = *((ULONGLONG*)&pSig);

   return (nSigA == nSigB) ? TRUE : FALSE;
}

/*----- FCCI_SRBCTL_GET_DRIVER_INFO - data structures and defines ------------*/
typedef struct _FCCI_DRIVER_INFO_OUT 
{
   // lengths of each character field (number of WCHARs)
   USHORT    DriverNameLength;
   USHORT    DriverDescriptionLength;
   USHORT    DriverVersionLength;
   USHORT    DriverVendorLength;

   // character fields (lengths just previous) follow in this order
   //   WCHAR          DriverName[DriverNameLength];
   //   WCHAR          DriverDescription[DriverDescriptionLength];
   //   WCHAR          DriverVersion[DriverVersionLength];
   //   WCHAR          DriverVendor[DriverVendorLength];
} FCCI_DRIVER_INFO_OUT, *PFCCI_DRIVER_INFO_OUT;

// Used by consumers
#define FCCI_DRIVER_INFO_DEFAULT_SIZE (sizeof(FCCI_DRIVER_INFO) + (sizeof(WCHAR) * 32) * 4)

// !!! IMPORTANT !!!
// If the supplied buffer is not large enough to hold the variable length data
// fill in the non variable length fields and return the request
// with a ResultCode of FCCI_RESULT_INSUFFICIENT_BUFFER.

typedef union _FCCI_DRIVER_INFO 
{       
   // no inbound data
   FCCI_DRIVER_INFO_OUT     out;
} FCCI_DRIVER_INFO, *PFCCI_DRIVER_INFO;

/*----- FCCI_SRBCTL_GET_ADAPTER_INFO - data structures and defines -----------*/
typedef struct _FCCI_ADAPTER_INFO_OUT 
{
   ULONG     PortCount;               // How many ports on adapter?
                                      // The number should reflect the number of
                                      // ports this "miniport" device object controls
                                      // not necessarily the true number of
                                      // of ports on the adapter.

   ULONG     BusCount;           // How many virtual buses on adapter?
   ULONG     TargetsPerBus;      // How many targets supported per bus?
   ULONG     LunsPerTarget;      // How many LUNs supported per target?

   // lengths of each character field (number of WCHARs)
   USHORT    VendorNameLength;
   USHORT    ProductNameLength;
   USHORT    ModelNameLength;
   USHORT    SerialNumberLength;

   // character fields (lengths just previous) follow in this order
   //   WCHAR          VendorName[VendorNameLength];
   //   WCHAR          ProductName[ProductNameLength];
   //   WCHAR          ModelName[ModelNameLength];
   //   WCHAR          SerialNumber[SerialNumberLength];
} FCCI_ADAPTER_INFO_OUT, *PFCCI_ADAPTER_INFO_OUT;

// Used by consumers
#define FCCI_ADAPTER_INFO_DEFAULT_SIZE (sizeof(FCCI_ADAPTER_INFO) + (sizeof(WCHAR) * 32) * 4)

// !!! IMPORTANT !!!
// If the supplied buffer is not large enough to hold the variable length data
// fill in the non variable length fields and return the request
// with a ResultCode of FCCI_RESULT_INSUFFICIENT_BUFFER.

typedef union _FCCI_ADAPTER_INFO 
{       
   // no inbound data
   FCCI_ADAPTER_INFO_OUT    out;
} FCCI_ADAPTER_INFO, *PFCCI_ADAPTER_INFO;

/*----- FCCI_SRBCTL_GET_ADAPTER_PORT_INFO - data structures and defines ------*/
typedef struct _FCCI_ADAPTER_PORT_INFO_IN
{
   ULONG     PortNumber;              // Number of adapter port we want data for
                                      // The index is zero based.
} FCCI_ADAPTER_PORT_INFO_IN, *PFCCI_ADAPTER_PORT_INFO_IN; 

typedef struct _FCCI_ADAPTER_PORT_INFO_OUT
{
   UCHAR     NodeWWN[8];              // Node World Wide Name for adapter port
   UCHAR     PortWWN[8];              // Port World Wide Name for adapter port
   ULONG     NportId;            // Current NportId for adapter port
   ULONG     PortState;               // Current port state
   ULONG     PortTopology;       // Current port topology
   ULONG     Flags;
} FCCI_ADAPTER_PORT_INFO_OUT, *PFCCI_ADAPTER_PORT_INFO_OUT;

// States

// for those that do not support state information
#define FCCI_PORT_STATE_NOT_SUPPORTED      0
// adapter-driver is initializing or resetting  
#define FCCI_PORT_STATE_INITIALIZING       1
// online, connected, and running     
#define FCCI_PORT_STATE_NORMAL                  2
// not connected to anything ("no light", no GBIC, etc.)  
#define FCCI_PORT_STATE_NO_CABLE           3
// connected but in non-participating mode 
#define FCCI_PORT_STATE_NON_PARTICIPATING  4
// adapter has failed (not recoverable)    
#define FCCI_PORT_STATE_HARDWARE_ERROR          5
// adapter firmware or driver has failed (not recoverable)     
#define FCCI_PORT_STATE_SOFTWARE_ERROR          6    

// Topologies

// for those that do not support topology information
#define FCCI_PORT_TOPO_NOT_SUPPORTED  0
// topology is unkown
#define FCCI_PORT_TOPO_UNKOWN              1
// FCAL without switch (NLPort - NLPort - ...)  
#define FCCI_PORT_TOPO_LOOP                2
// FCAL attached to switch (NLPort - FLPort - ...)   
#define FCCI_PORT_TOPO_LOOP_FABRIC         3
// Point-to-Point without switch (NPort - NPort)     
#define FCCI_PORT_TOPO_PTOP                4
// Point-to-Point with switch (NPort - FPort)
#define FCCI_PORT_TOPO_PTOP_FABRIC         5    

typedef union _FCCI_ADAPTER_PORT_INFO 
{       
   FCCI_ADAPTER_PORT_INFO_IN     in;
   FCCI_ADAPTER_PORT_INFO_OUT    out;
} FCCI_ADAPTER_PORT_INFO, *PFCCI_ADAPTER_PORT_INFO;

/*----- FCCI_SRBCTL_GET_LOGUNIT_INFO - data structures and defines -----------*/
typedef struct _FCCI_LOGUNIT_INFO_IN
{
   FCCI_TARGET_ADDRESS TargetAddress; // scsi address to return info about
} FCCI_LOGUNIT_INFO_IN, *PFCCI_LOGUNIT_INFO_IN;

typedef struct _FCCI_LOGUNIT_INFO_OUT
{
   UCHAR     NodeWWN[8];                   // Node World Wide Name for device
   UCHAR     PortWWN[8];                   // Port World Wide Name for device
   ULONG     NportId;                 // Current NportId for device
   USHORT    LogicalUnitNumber[4];    // 8 byte LUN used in FC frame
   ULONG     Flags;
} FCCI_LOGUNIT_INFO_OUT, *PFCCI_LOGUNIT_INFO_OUT;

typedef union _FCCI_LOGUNIT_INFO 
{       
   FCCI_LOGUNIT_INFO_IN     in;
   FCCI_LOGUNIT_INFO_OUT    out;
} FCCI_LOGUNIT_INFO, *PFCCI_LOGUNIT_INFO;

/*----- FCCI_SRBCTL_GET_DEVICE_INFO - data structures and defines ------------*/

typedef struct _FCCI_DEVICE_INFO_ENTRY
{
   UCHAR                    NodeWWN[8];         // Node World Wide Name for device
   UCHAR                    PortWWN[8];         // Port World Wide Name for device
   ULONG                    NportId;       // Current NportId for device
   FCCI_TARGET_ADDRESS TargetAddress; // scsi address
   ULONG                    Flags;
} FCCI_DEVICE_INFO_ENTRY, *PFCCI_DEVICE_INFO_ENTRY;

typedef struct _FCCI_DEVICE_INFO_OUT
{
   ULONG     TotalDevices;       // set to total number of device the adapter
                                      // knows of.

   ULONG     OutListEntryCount;  // set to number of device entries being 
                                      // returned in list (see comment below).

   //FCCI_DEVICE_INFO_ENTRY  entryList[OutListEntryCount];
} FCCI_DEVICE_INFO_OUT, *PFCCI_DEVICE_INFO_OUT;

// !!! IMPORTANT !!!
// If the number of known devices is greater than the list size
// set OutListEntryCount to zero, don't fill in any list entries
// and set TotalDevices to the number of known devices.
// Then complete the FCCI_IOCTL_GET_DEVICE_INFO with a ResultCode
// of FCCI_RESULT_INSUFFICIENT_BUFFER.
// The higher level driver can then allocate a larger buffer and attempt the
// call again (if it wants to).

typedef union _FCCI_DEVICE_INFO
{       
   // no inbound data
   FCCI_DEVICE_INFO_OUT     out;
} FCCI_DEVICE_INFO, *PFCCI_DEVICE_INFO;

/*----- FCCI_SRBCTL_RESET_TARGET - data structures and defines ---------------*/

// inbound buffer will contain a FCCI_TARGET_ADDRESS 
// of the device to reset.

typedef union _FCCI_RESET_TARGET 
{       
   FCCI_TARGET_ADDRESS      in;
   // no outbound data
} FCCI_RESET_TARGET, *PFCCI_RESET_TARGET;


// The following is not yet supported or required...

   /*----- Events - data structures and defines ---------------------------------*/

   typedef struct _FCCI_EVENT_QUEUE_HEAD
   {
        struct  _FCCI_EVENT_QUEUE_HEAD*    NextQueueHead; // link to next queue
        struct  _FCCI_EVENT*               TopEvent; // simple LIFO list (aka Stack)

        ULONG     Extra;    // providers can use how ever they want
   } FCCI_EVENT_QUEUE_HEAD, *PFCCI_EVENT_QUEUE_HEAD;

   /*----- FCCI_SRBCTL_INIT_EVENT_QUEUE - data structures and defines -----------*/

   typedef struct _FCCI_INIT_EVENT_QUEUE_IN
   {
        PFCCI_EVENT_QUEUE_HEAD   QueueHead;     // pointer to queue head to be added
   } FCCI_INIT_EVENT_QUEUE_IN, *PFCCI_INIT_EVENT_QUEUE_IN;

   typedef union _FCCI_INIT_EVENT_QUEUE 
   {         
        FCCI_INIT_EVENT_QUEUE_IN in;
        // no outbound data
   } FCCI_INIT_EVENT_QUEUE, *PFCCI_INIT_EVENT_QUEUE;

   /*----- FCCI_SRBCTL_TERM_EVENT_QUEUE - data structures and defines -----------*/

   // on term complete any queued events with FCCI_EVENT_NO_EVENT

   typedef struct _FCCI_TERM_EVENT_QUEUE_IN
   {
        PFCCI_EVENT_QUEUE_HEAD   QueueHead;     // pointer to queue head to be removed
   } FCCI_TERM_EVENT_QUEUE_IN, *PFCCI_TERM_EVENT_QUEUE_IN;

   typedef union _FCCI_TERM_EVENT_QUEUE 
   {         
        FCCI_TERM_EVENT_QUEUE_IN in;
        // no outbound data
   } FCCI_TERM_EVENT_QUEUE, *PFCCI_TERM_EVENT_QUEUE;

   /*----- FCCI_SRBCTL_QUEUE_EVENT - data structures and defines ----------------*/

   // Events

   // null event (use to clear event queue)
   #define FCCI_EVENT_NO_EVENT                       0
   // new device, device info change, LIP, RSCN, etc.
   #define FCCI_EVENT_DEVICE_INFO_CHANGE        1
   // adapter NportID chagned, etc.
   #define FCCI_EVENT_ADAPTER_INFO_CHANGE       2
   // driver name, version, etc.
   #define FCCI_EVENT_DRIVER_INFO_CHANGE        3

   // No return data payloads have been defined at this time. So set
   // OutDataLength to zero.

   typedef struct _FCCI_EVENT
   {
        PFCCI_EVENT_QUEUE_HEAD   QueueHead;     // pointer to queue head
                                                     // this field is filled in by consumer
                                                     // and must NOT be change by providers
        
        struct  _FCCI_EVENT*     NextEvent;     // used by providers
        PSCSI_REQUEST_BLOCK      RelatedSRB;    // used by providers
        ULONG                         Extra;         // providers can use how ever they want

        ULONG     Event;                        // event type (see list above)
        ULONG     OutDataLength;           // set to size of data returned (if any)

        //UCHAR   data[OutDataLength];     // varible length data follows 
   } FCCI_EVENT, *PFCCI_EVENT;

   typedef union _FCCI_QUEUE_EVENT 
   {         
        FCCI_EVENT     in;
        FCCI_EVENT     out;
   } FCCI_QUEUE_EVENT, *PFCCI_QUEUE_EVENT;

   /*----------------------------------------------------------------------------*/

#endif //ndef'd _FCCI_NT_H //}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\fcmain.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/FCMain.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 10/30/00 6:39p  $ (Last Modified)

Purpose:

  This file implements the main entry points for the FC Layer.

--*/
#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/state.h"
#include "../h/memmap.h"
#include "../h/tlstruct.h"
#include "../h/fcmain.h"
#include "../h/queue.h"
#include "../h/timersvc.h"
#include "../h/flashsvc.h"
#ifdef _DvrArch_1_30_
#include "../h/ipstate.h"
#include "../h/pktstate.h"
#endif /* _DvrArch_1_30_ was defined */
#include "../h/devstate.h"
#include "../h/cdbstate.h"
#include "../h/sfstate.h"
#include "../h/cstate.h"
#include "../h/cfunc.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "state.h"
#include "memmap.h"
#include "tlstruct.h"
#include "fcmain.h"
#include "queue.h"
#include "timersvc.h"
#include "flashsvc.h"
#ifdef _DvrArch_1_30_
#include "ipstate.h"
#include "pktstate.h"
#endif /* _DvrArch_1_30_ was defined */
#include "devstate.h"
#include "cdbstate.h"
#include "sfstate.h"
#include "cstate.h"
#include "cfunc.h"
#endif  /* _New_Header_file_Layout_ */

#ifndef __State_Force_Static_State_Tables__
actionUpdate_t noActionUpdate = { 0,0,agNULL,agNULL };
#endif /* __State_Force_Static_State_Tables__ was not defined */

os_bit8 Alpa_Index[256] =
    {
       0x00, 0x01, 0x02, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, /* ALPA 00 01 02 04       */
       0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, /* ALPA 08 0F             */

       0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, /* ALPA 10 17             */
       0x08, 0xFF, 0xFF, 0x09, 0xFF, 0x0A, 0x0B, 0x0C, /* ALPA 18 1B 1D 1E 1F    */

       0xFF, 0xFF, 0xFF, 0x0D, 0xFF, 0x0E, 0x0F, 0x10, /* ALPA 23 25 26 27       */
       0xFF, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0xFF, /* ALPA 29 2A 2B 2C 2D 2E */

       0xFF, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0xFF, /* ALPA 31 32 33 34 35 36 */
       0xFF, 0x1D, 0x1E, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, /* ALPA 39 3A 3C          */

       0xFF, 0xFF, 0xFF, 0x20, 0xFF, 0x21, 0x22, 0x23, /* ALPA 43 45 46 47       */
       0xFF, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0xFF, /* ALPA 49 4A 4B 4C 4D 4E */

       0xFF, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0xFF, /* ALPA 51 52 53 54 55 56 */
       0xFF, 0x30, 0x31, 0xFF, 0x32, 0xFF, 0xFF, 0xFF, /* ALPA 59 5A 5C          */

       0xFF, 0xFF, 0xFF, 0x33, 0xFF, 0x34, 0x35, 0x36, /* ALPA 63 65 66 67       */
       0xFF, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0xFF, /* ALPA 69 6A 6B 6C 6D 6E */

       0xFF, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0xFF, /* ALPA 71 72 73 74 75 76 */
       0xFF, 0x43, 0x44, 0xFF, 0x45, 0xFF, 0xFF, 0xFF, /* ALPA 79 7A 7C          */

       0x46, 0x47, 0x48, 0xFF, 0x49, 0xFF, 0xFF, 0xFF, /* ALPA 80 81 82 84       */
       0x4A, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x4B, /* ALPA 88 8F             */

       0x4C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x4D, /* ALPA 90 97             */
       0x4E, 0xFF, 0xFF, 0x4F, 0xFF, 0x50, 0x51, 0x52, /* ALPA 98 9B 9D 9E 9F    */

       0xFF, 0xFF, 0xFF, 0x53, 0xFF, 0x54, 0x55, 0x56, /* ALPA A3 A5 A6 A7       */
       0xFF, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0xFF, /* ALPA A9 AA AB AC AD AE */

       0xFF, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0xFF, /* ALPA B1 B2 B3 B4 B5 B6 */
       0xFF, 0x63, 0x64, 0xFF, 0x65, 0xFF, 0xFF, 0xFF, /* ALPA B9 BA BC          */

       0xFF, 0xFF, 0xFF, 0x66, 0xFF, 0x67, 0x68, 0x69, /* ALPA C3 C5 C6 C7       */
       0xFF, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0xFF, /* ALPA C9 CA CB CC CD CE */

       0xFF, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0xFF, /* ALPA D1 D2 D3 D4 D5 D6 */
       0xFF, 0x76, 0x77, 0xFF, 0x78, 0xFF, 0xFF, 0xFF, /* ALPA D9 DA DC          */

       0x79, 0x7A, 0x7B, 0xFF, 0x7C, 0xFF, 0xFF, 0xFF, /* ALPA E0 E1 E2 E4       */
       0x7D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7E, /* ALPA E8 EF             */

       0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
       0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF  
    };

/*+
   Function: fcAbortIO 

    Purpose: Abort given request
  Called By: OSLayer
      Calls: CDBEvent_PrepareforAbort
             CDBEventAlloc_Abort
             osIOCompleted
-*/
void fcAbortIO(
                agRoot_t      *hpRoot,
                agIORequest_t *hpIORequest
              )
{
    CThread_t   * pCThread   = CThread_ptr(hpRoot);
    CDBThread_t * pCDBThread = (CDBThread_t * )(hpIORequest->fcData);

    fiSingleThreadedEnter( hpRoot, fdAbortIO );

    if(pCDBThread != agNULL)
    {
        pCDBThread->CompletionStatus =  osIOAborted;

		/*  hpRoot was removed from this message. IWN */
         fiLogDebugString(hpRoot,
                     FCMainLogConsoleLevel,
                        "fcAbortIO hpIORequest %p CDBThread %p State %d",
                        (char *)agNULL,(char *)agNULL,
                        hpIORequest,pCDBThread,
                        pCDBThread->thread_hdr.currentState,
                        0,0,0,0,0,0,0);


        if( pCDBThread->thread_hdr.currentState != CDBStateThreadFree &&
            pCDBThread->thread_hdr.currentState != CDBStateConfused      )
        {
            fiSendEvent(&(pCDBThread->thread_hdr),CDBEvent_PrepareforAbort);
            if(! fiListElementOnList(  &(pCDBThread->CDBLink), &(pCThread->Free_CDBLink)))
            {
                fiSendEvent(&(pCDBThread->thread_hdr),CDBEventAlloc_Abort);
            }
        }
        else
        {
            if( pCDBThread->thread_hdr.currentState == CDBStateConfused )
            {
                pCDBThread->CompletionStatus =  osIOAbortFailed;
				/*  hpRoot was removed from this message. IWN */
                fiLogDebugString(hpRoot,
                        FCMainLogConsoleLevel,
                        "fcAbortIO hpIORequest %p CDBThread %p State %d Request CDBStateConfused !",
                        (char *)agNULL,(char *)agNULL,
                        hpIORequest,pCDBThread,
                        pCDBThread->thread_hdr.currentState,
                        0,0,0,0,0,0,0);
                osIOCompleted( hpRoot,
                               pCDBThread->hpIORequest,
                               pCDBThread->CompletionStatus,
                               0);


            }
        }

    }
    else
    {
		/*  hpRoot was removed from this message. IWN */
        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "fcAbortIO hpIORequest %p CDBThread %p Request BAD !",
                        (char *)agNULL,(char *)agNULL,
                        hpIORequest,pCDBThread,
                        0,0,0,0,0,0,0,0);
    }
    fiSingleThreadedLeave( hpRoot , fdAbortIO );
    return;
}


#ifdef _DvrArch_1_30_

/*+
   Function: fcBindToWorkQs
    Purpose: IP Currently does nothing
  Called By: OSLayer
      Calls: 
-*/
os_bit32 fcBindToWorkQs(
                         agRoot_t  *agRoot,
                         os_bit32   agQPairID,
                         void     **agInboundQBase,
                         os_bit32   agInboundQEntries,
                         os_bit32  *agInboundQProdIndex,
                         os_bit32  *agInboundQConsIndex,
                         void     **agOutboundQBase,
                         os_bit32   agOutboundQEntries,
                         os_bit32  *agOutboundQProdIndex,
                         os_bit32  *agOutboundQConsIndex
                       )
{
    fiLogDebugString( agRoot,
                      FCMainLogConsoleLevel,
                      "fcBindToWorkQs():               agRoot==0x%8P            agQPairID==0x%1X",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agRoot,(void *)agNULL,
                      agQPairID,
                      0,0,0,0,0,0,0);

    fiLogDebugString( agRoot,
                      FCMainLogConsoleLevel,
                      "                        agInboundQBase==0x%8P    agInboundQEntries==0x%8X",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agInboundQBase,(void *)agNULL,
                      agInboundQEntries,
                      0,0,0,0,0,0,0);

    fiLogDebugString(agRoot,
                      FCMainLogConsoleLevel,
                      "                   agInboundQProdIndex==0x%8P  agInboundQConsIndex==0x%8P",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agInboundQProdIndex,
                      (void *)agInboundQConsIndex,
                      0,0,0,0,0,0,0,0 );

    fiLogDebugString( agRoot,
                      FCMainLogConsoleLevel,
                      "                       agOutboundQBase==0x%8P   agOutboundQEntries==0x%8X",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agOutboundQBase,(void *)agNULL,
                      agOutboundQEntries,
                      0,0,0,0,0,0,0 );

    fiLogDebugString( agRoot,
                      FCMainLogConsoleLevel,
                      "                  agOutboundQProdIndex==0x%8P agOutboundQConsIndex==0x%8P",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agOutboundQProdIndex,
                      (void *)agOutboundQConsIndex,
                      0,0,0,0,0,0,0,0 );

    return fcBindQInvalidID;
}
#endif /* _DvrArch_1_30_ was defined */

/*+
   Function: fcCardSupported
    Purpose: Returns True if card is supported by fclayer
  Called By: OSLayer fcInitializeChannel
      Calls: osChipConfigReadBit32
-*/
agBOOLEAN fcCardSupported(
                           agRoot_t *hpRoot
                         )
{
    os_bit32 DEVID_VENDID;
    os_bit32 VENDID;
    os_bit32 DEVID;
    os_bit32 REVID;
    os_bit32 SVID;
    os_bit32 MAJOR_REVID;
    os_bit32 MINOR_REVID;

    os_bit32 SUB_VENDID;
    os_bit32 SUB_DEVID;

    DEVID_VENDID = osChipConfigReadBit32(
                                          hpRoot,
                                          ChipConfig_DEVID_VENDID
                                        );

    VENDID       = DEVID_VENDID & ChipConfig_VENDID_MASK;

    DEVID        = DEVID_VENDID & ChipConfig_DEVID_MASK;

    REVID        = osChipConfigReadBit32(
                                          hpRoot,
                                          ChipConfig_CLSCODE_REVID
                                        )                          & ChipConfig_REVID_Major_Minor_MASK;

    MAJOR_REVID  = (REVID & ChipConfig_REVID_Major_MASK) >> ChipConfig_REVID_Major_MASK_Shift;
    MINOR_REVID  =  REVID & ChipConfig_REVID_Minor_MASK;

    SVID         = osChipConfigReadBit32(
                                          hpRoot,
                                          ChipConfig_SVID
                                        );
    SUB_VENDID       = SVID & ChipConfig_SubsystemVendorID_MASK;

    SUB_DEVID        = SVID & ChipConfig_SubsystemID_MASK;


    fiLogDebugString(
                      hpRoot,
                      FCMainLogConsoleCardSupported,
                      "fcCardSupported(): VENDID==0x%04X DEVID==0x%04X REVID==0x%02X (%x.%x) SVID==0x%08X",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      VENDID,
                      (DEVID >> 16),
                      REVID,
                      MAJOR_REVID,
                      MINOR_REVID,
                      SVID,
                      0,0
                    );


    fiLogString(hpRoot,
                      "%s VENDID==0x%04X DEVID==0x%04X",
                      "fcCardSupported",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      VENDID,
                      (DEVID >> 16),
                      0,0,0,0,0,0);
    fiLogString(hpRoot,
                      "%s REVID==0x%02X (%x.%x) SVID==0x%08X",
                      "fcCardSupported",(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      REVID,
                      MAJOR_REVID,
                      MINOR_REVID,
                      SVID,
                      0,0,0,0);

/*
    fiLogDebugString(
                      hpRoot,
                      FCMainLogConsoleCardSupported,
                      "Testing agfmtfill %s %s %p %p",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agNULL,(void *)agNULL,
                      0,0,0,0,0,0,0,0
                    );
*/    
#ifndef _ADAPTEC_HBA
#ifndef _AGILENT_HBA
#ifndef _GENERIC_HBA
#error Need  _AGILENT_HBA or _ADAPTEC_HBA defined !
#endif
#endif
#endif

#ifdef _ADAPTEC_HBA

	/* To differentiate Adaptec card's we need to check the Sub system vendor
	 * and sub device ids.
	 */

if (    ((VENDID == ChipConfig_VENDID_Agilent_Technologies) ||
        (VENDID == ChipConfig_VENDID_Hewlett_Packard))  )
    {
        switch (SUB_VENDID)
        {
        case ChipConfig_SubsystemVendorID_Adaptec:
            break;
        case ChipConfig_SubsystemVendorID_Agilent_Technologies:
        case ChipConfig_SubsystemVendorID_Hewlett_Packard:
        default:
            fiLogString( hpRoot,
                          "FAILED fcCardSupported():NOT  ChipConfig_SubsystemVendorID_Adaptec %X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          SUB_VENDID,0,0,0,0,0,0,0 );

            return agFALSE;

        }
    }

#endif /* _ADAPTEC_HBA */ 

#ifdef _AGILENT_HBA
    
if (    ((VENDID == ChipConfig_VENDID_Agilent_Technologies) ||
        (VENDID == ChipConfig_VENDID_Hewlett_Packard))  )
    {
    switch (SUB_VENDID)
        {
        case ChipConfig_SubsystemVendorID_Adaptec:
            fiLogString( hpRoot,
                          "FAILED fcCardSupported(): ChipConfig_SubsystemVendorID_Adaptec %X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0 );

            return agFALSE;
        case ChipConfig_SubsystemVendorID_Agilent_Technologies:
        case ChipConfig_SubsystemVendorID_Hewlett_Packard:
                break;
        default:
            fiLogString( hpRoot,
                          "FAILED fcCardSupported(): ChipConfig_SubsystemVendorID_UNKNOWN %X",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          SUB_VENDID,0,0,0,0,0,0,0 );
            return agFALSE;

        }
    
    }
#endif /* _AGILENT_HBA */ 
    

    if (    (DEVID != ChipConfig_DEVID_TachyonTL)
         && (DEVID != ChipConfig_DEVID_TachyonTS)
         && (DEVID != ChipConfig_DEVID_TachyonXL2) )
    {
        fiLogDebugString( hpRoot,
                          FCMainLogErrorLevel,
                          "fcCardSupported():    DEVID != ChipConfig_DEVID_TachyonTL (0x%04X)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          (ChipConfig_DEVID_TachyonTL >> 16),
                          0,0,0,0,0,0,0 );

        fiLogDebugString( hpRoot,
                          FCMainLogErrorLevel,
                          "                   && DEVID != ChipConfig_DEVID_TachyonTS (0x%04X)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          (ChipConfig_DEVID_TachyonTS >> 16),
                          0,0,0,0,0,0,0 );

        fiLogDebugString( hpRoot,
                          FCMainLogErrorLevel,
                          "                   && DEVID != ChipConfig_DEVID_TachyonXL2 (0x%04X)",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          (ChipConfig_DEVID_TachyonXL2 >> 16),
                          0,0,0,0,0,0,0 );

        return agFALSE;
    }


    if (    (DEVID == ChipConfig_DEVID_TachyonTL)
         && (REVID <  ChipConfig_REVID_2_2) )
    {
        fiLogDebugString(
                          hpRoot,
                          FCMainLogConsoleCardSupported,
                          "fcCardSupported():    DEVID == ChipConfig_DEVID_TachyonTL (0x%04X)",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                          (ChipConfig_DEVID_TachyonTL >> 16),
                          0,0,0,0,0,0,0
                        );

        fiLogDebugString(
                          hpRoot,
                          FCMainLogConsoleCardSupported,
                          "                   && REVID <  ChipConfig_REVID_2_2 (0x%02X)",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                          ChipConfig_REVID_2_2,
                          0,0,0,0,0,0,0
                        );
    }


    return agTRUE;
}


/*+
   Function: fcDelayedInterruptHandler
    Purpose: Process interrupts after interrupts have been masked off by fcInterruptHandler
             Evalulates current status on interrupt delay mechanism
             Re enables interrupts on exit
  Called By: OSLayer 
      Calls: CFuncRead_Interrupts
             on or off card version of Proccess_IMQ
-*/
void fcDelayedInterruptHandler(
                                agRoot_t *hpRoot
                              )
{
    CThread_t *pCThread         = CThread_ptr(hpRoot);
    os_bit32      intStatus;
    os_bit32      IOsActiveAtEntry;

    if(pCThread->DelayedInterruptActive)
    {
        fiLogString(hpRoot,
                          "%s Active twice !",
                          "fcDelayedInterruptHandler",(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0);
    }
    else
    {
        pCThread->DelayedInterruptActive = agTRUE;
    }
    
    fiSingleThreadedEnter( hpRoot , fdDelayedInterruptHandler );

    /*
    ** read interrupt register
    */

    intStatus = CFuncRead_Interrupts(hpRoot);

    if (intStatus & ChipIOUp_INTSTAT_INT)
    {
        IOsActiveAtEntry = pCThread->IOsActive;

        pCThread->IOsStartedSinceISR = 0;

        if (pCThread->InterruptDelaySuspended == agTRUE)
        {
            /* Indicate Interrupt Delay Suspension is over since ISR was called */

            pCThread->InterruptDelaySuspended = agFALSE;

            if (pCThread->InterruptsDelayed == agTRUE)
            {
                /* Restart delaying interrupts (if they should now be delayed) */

                CFuncInteruptDelay(hpRoot, agTRUE);
            }
        }

        pCThread->FuncPtrs.Proccess_IMQ( hpRoot );

        if(pCThread->RSCNreceived )
        {
            if( pCThread->thread_hdr.currentState == CStateRSCNErrorBackIOs  )
            {
                pCThread->RSCNreceived = agFALSE;
                CFuncDoADISC( hpRoot);
                fiSendEvent(&(pCThread->thread_hdr),CEventDeviceListEmpty);
                fiLogString(hpRoot,
                                "%s CState %d",
                                "fcDelayed",(char *)agNULL,
                                (void *)agNULL,(void *)agNULL,
                                pCThread->thread_hdr.currentState,
                                0,0,0,0,0,0,0);

            }
        }

        pCThread->IOsIntCompletedThisTimerTick += (IOsActiveAtEntry - pCThread->IOsActive);
    }
#ifdef ENABLE_INTERRUPTS_IN_IMQ
    else
    {
        CFuncEnable_Interrupts(hpRoot,ChipIOUp_INTEN_INT);
    }
#endif /* ENABLE_INTERRUPTS_IN_IMQ */

    if( ! pCThread->ProcessingIMQ )
    {
        if( pCThread->thread_hdr.currentState != CStateNormal  )
        {
            if( pCThread->thread_hdr.currentState == CStateResetNeeded  )
            {
                fiSendEvent(&(pCThread->thread_hdr),(event_t) pCThread->Loop_Reset_Event_to_Send);
            }
        }
    }

#ifndef ENABLE_INTERRUPTS_IN_IMQ
    /*Always enable interupts */
    CFuncEnable_Interrupts(hpRoot,ChipIOUp_INTEN_INT);
#endif /* ENABLE_INTERRUPTS_IN_IMQ */

    if(! (osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ) & ChipIOUp_INTEN_INT ))
    {
        if( pCThread->thread_hdr.currentState == CStateLIPEventStorm         ||
            pCThread->thread_hdr.currentState == CStateElasticStoreEventStorm   )
        {
        /* Ok to have ints disabled for these states */
        }
        else
        {

            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Leave %s (%p) IMQ Int disabled ! * ! Cstate %d",
                            "fcDelayedInterruptHandler",(char *)agNULL,
                            hpRoot,(void *)agNULL,
                            pCThread->thread_hdr.currentState,
                            0,0,0,0,0,0,0);

            fiLogDebugString(hpRoot,
                            CStateLogConsoleERROR,
                            "Interrupts %08X sysInts - Active %08X LogicallyEnabled %08X",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                            CThread_ptr(hpRoot)->sysIntsActive,
                            CThread_ptr(hpRoot)->sysIntsLogicallyEnabled,
                            0,0,0,0,0);
        }

    }

    pCThread->DelayedInterruptActive = agFALSE;

    fiSingleThreadedLeave( hpRoot, fdDelayedInterruptHandler  );

    return;
}


/*+

  Function: fcEnteringOS
   Purpose: This function is called to indicate to the FC Layer that it is 
            being called after the OS has switched back (presumably between NetWare 
            and BIOS) from the "other OS".  The prior switch out of "this OS" was 
            preceded by a call to fcLeavingOS() 
  Called By: <unknown OS Layer functions>
      Calls: CFuncEnable_Interrupts

-*/
void fcEnteringOS(
                   agRoot_t *hpRoot
                 )
{
    CThread_t *CThread = CThread_ptr(hpRoot);

    fiSingleThreadedEnter( hpRoot , fdEnteringOS );


    CThread->sysIntsActive = CThread->sysIntsActive_before_fcLeavingOS_call;

    CFuncEnable_Interrupts(
                            hpRoot,
                            0
                          );

    fiSingleThreadedLeave( hpRoot , fdEnteringOS );


    return;
}

/*+
  Function: fcGetChannelInfo
   Purpose: This function is called to copy agFCChanInfo_t for the agRoot_t HBA channel.
            Oslayer must provide buffer large enough to hold agFCChanInfo_t.
  Called By: <unknown OS Layer functions>
      Calls: None
-*/
os_bit32 fcGetChannelInfo(
                        agRoot_t       *hpRoot,
                        agFCChanInfo_t *hpFCChanInfo
                      )
{
    CThread_t *CThread = CThread_ptr(hpRoot);

    fiSingleThreadedEnter( hpRoot , fdGetChannelInfo );

    fiLogDebugString(hpRoot,
                    FCMainLogConsoleLevel,
                    "fcGetChannelInfo()",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    if (  CThread->thread_hdr.currentState == CStateNormal )
    {
        CThread->ChanInfo.LinkUp = agTRUE;
    }
    else
    {
        CThread->ChanInfo.LinkUp = agFALSE;
    }

    /*Update Chaninfo for SNIA IOCTLS */
    CThread->ChanInfo.PortSupportedSpeed =  (CThread->DEVID == ChipConfig_DEVID_TachyonXL2) ? HBA_PORTSPEED_2GBIT : HBA_PORTSPEED_1GBIT;
    CThread->ChanInfo.PortSpeed = CThread->TwoGigSuccessfull ? HBA_PORTSPEED_2GBIT : HBA_PORTSPEED_1GBIT;
    CThread->ChanInfo.PortState = (  CThread->thread_hdr.currentState == CStateNormal ) ? HBA_PORTSTATE_ONLINE : HBA_PORTSTATE_LINKDOWN;

    if(CThread->InitAsNport)
    {
        CThread->ChanInfo.PortType = HBA_PORTTYPE_NPORT;
    }
    else
    {
        CThread->ChanInfo.PortType = CThread->FlogiSucceeded ?  HBA_PORTTYPE_FLPORT : HBA_PORTTYPE_NLPORT;
    }

    CThread->ChanInfo.PortSupportedClassofService = 0x8;

    /*Not available til phase 2
    CThread->ChanInfo.FabricName;
    CThread->ChanInfo.PortSupportedFc4Types ;
    CThread->ChanInfo.PortActiveFc4Types;
    Not available til phase 2 */

    *hpFCChanInfo = CThread_ptr(hpRoot)->ChanInfo;

    fiSingleThreadedLeave(hpRoot , fdGetChannelInfo );

    return fcChanInfoReturned;
}


/*+
  Function: fcGetDeviceHandles
   Purpose: This function is called to copy maxFCDevs of handle information for the agRoot_t HBA channel.
            Oslayer must provide buffer large enough to hold maxFCDevs of handles.
            Returns zero if no devices found or if FCLayer does not have a valid list of devices.
            Only time possible to get non zero is after Link_up event notification with devices attached.
  Called By: <unknown OS Layer functions>
      Calls: Access's data structures only.
-*/
os_bit32 fcGetDeviceHandles(
                          agRoot_t  *hpRoot,
                          agFCDev_t  hpFCDev[],
                          os_bit32   maxFCDevs
                        )
{
    os_bit32     DevsFound       = 0;
    DevSlot_t    Highest_DevSlot = 0;
    fiList_t    *Active_DevLink;
    fiList_t    *Next_DevLink;
    CThread_t   *CThread         = CThread_ptr(hpRoot);
    DevThread_t *DevThread;
    os_bit32        slot;

    fiSingleThreadedEnter(hpRoot , fdGetDeviceHandles);

    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "In %s EL %d",
                    "fcGetDeviceHandles",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiNumElementsOnList(&CThread->Active_DevLink),
                    0,0,0,0,0,0,0);

    if (  CThread->thread_hdr.currentState != CStateNormal )
    {
        fiSingleThreadedLeave(hpRoot , fdGetDeviceHandles);

        return 0;
    }

    Active_DevLink = &(CThread->Active_DevLink);
    Next_DevLink   = Active_DevLink;

    while ((Next_DevLink = Next_DevLink->flink) != Active_DevLink)
    {
        DevsFound += 1;

        DevThread = hpObjectBase(DevThread_t,DevLink,Next_DevLink);

        if (DevThread->DevSlot > Highest_DevSlot)
        {
            Highest_DevSlot = DevThread->DevSlot;
        }
    }

    for (slot = 0;
         slot < maxFCDevs;
         slot++)
    {
        hpFCDev[slot] = (agFCDev_t *)agNULL;
    }

    while ((Next_DevLink = Next_DevLink->flink) != Active_DevLink)
    {
        DevThread = hpObjectBase(DevThread_t,DevLink,Next_DevLink);

        slot      = DevThread->DevSlot;

        if (slot < maxFCDevs)
        {
            hpFCDev[slot] = (agFCDev_t *)DevThread;
        }
    }

    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "Out %s EL %d",
                    "fcGetDeviceHandles",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    fiNumElementsOnList(&CThread->Active_DevLink),
                    0,0,0,0,0,0,0);

    fiSingleThreadedLeave(hpRoot , fdGetDeviceHandles);

    if (DevsFound > 0)
    {
        return (Highest_DevSlot + 1);
    }
    else /* DevsFound == 0 */
    {
        return 0;
    }
}


/*+
  Function: fcGetDeviceInfo
   Purpose: This function is called to copy hpFCDevInfo of device information for the agFCDev_t on agRoot_t HBA channel.
            Oslayer must provide buffer large enough to hold agFCDevInfo_t of handle.
  Called By: <unknown OS Layer functions>
      Calls: Access's data structures only
-*/
os_bit32 fcGetDeviceInfo(
                       agRoot_t      *hpRoot,
                       agFCDev_t      hpFCDev,
                       agFCDevInfo_t *hpFCDevInfo
                     )
{

    DevThread_t  * DevThread = (DevThread_t  *)hpFCDev;
    CThread_t    * CThread   = CThread_ptr(hpRoot);
    if(DevThread == agNULL)
    {
    return fcGetDevInfoFailed;
    }
/*
    fiLogString(hpRoot,
                    "Enter %s Enter %d Leave %d",
                    "fcGetDeviceInfo",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LastSingleThreadedEnterCaller,
                    CThread_ptr(hpRoot)->LastSingleThreadedLeaveCaller,
                    0,0,0,0,0,0);
*/
    fiSingleThreadedEnter(hpRoot , fdGetDeviceInfo);

    fiLogDebugString(hpRoot,
                    FCMainLogConsoleLevel,
                    "fcGetDeviceInfo(%p)",
                    (char *)agNULL,(char *)agNULL,
                    hpFCDev,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
    /*Update Devinfo for SNIA IOCTLS */
    DevThread->DevInfo.PortSupportedSpeed =  (CThread->DEVID == ChipConfig_DEVID_TachyonXL2) ? HBA_PORTSPEED_2GBIT : HBA_PORTSPEED_1GBIT;
    DevThread->DevInfo.PortSpeed = CThread->TwoGigSuccessfull ? HBA_PORTSPEED_2GBIT : HBA_PORTSPEED_1GBIT;
    DevThread->DevInfo.PortState = (  CThread->thread_hdr.currentState == CStateNormal ) ? HBA_PORTSTATE_ONLINE : HBA_PORTSTATE_LINKDOWN;

    if(CThread->InitAsNport)
    {
        DevThread->DevInfo.PortType = HBA_PORTTYPE_NPORT;
    }
    else
    {
        DevThread->DevInfo.PortType = CThread->FlogiSucceeded ?  HBA_PORTTYPE_FLPORT : HBA_PORTTYPE_NLPORT;
    }

    DevThread->DevInfo.PortSupportedClassofService = 0x8;


    /*Not available til phase 2
    DevThread->DevInfo.PortSupportedFc4Types ;
    DevThread->DevInfo.FabricName;
    DevThread->DevInfo.PortActiveFc4Types;
    Not available til phase 2 */

    *hpFCDevInfo = DevThread->DevInfo;
    fiSingleThreadedLeave(hpRoot , fdGetDeviceInfo);
    return fcGetDevInfoReturned;
}

/* extern os_bit32 hpFcConsoleLevel; */
/*+
  Function: fcInitializeChannel
   Purpose: This function is called initialize the agRoot_t for the channel. All memory 
            has to be allocated prior to calls of this function. If memory layout verifaction
            fails this function fails. Adapter specfic code exists. Various fclayer flags are 
            initialized. A number of attempts are made to exit this routine with the link in the UP
            state.
 Called By: <unknown OS Layer functions>
     Calls: fcCardSupported
            fiMemMapCalculate
            fiFlashSvcInitialize
            fiInstallStateMachine
            fiInitializeThread
            SFThreadInitializeRequest
            fiTimerInitializeRequest
            DevThreadInitializeSlots
            CFuncEnable_Interrupts
            CEventDoInitalize
            CFuncInit_FunctionPointers
            CFuncInteruptDelay
            Proccess_IMQ
            CFuncInterruptPoll

-*/
os_bit32 fcInitializeChannel(
                           agRoot_t *hpRoot,
                           os_bit32    initType,
                           agBOOLEAN   sysIntsActive,
                           void       *cachedMemoryPtr,
                           os_bit32    cachedMemoryLen,
                           os_bit32    dmaMemoryUpper32,
                           os_bit32    dmaMemoryLower32,
                           void       *dmaMemoryPtr,
                           os_bit32    dmaMemoryLen,
                           os_bit32    nvMemoryLen,
                           os_bit32    cardRamUpper32,
                           os_bit32    cardRamLower32,
                           os_bit32    cardRamLen,
                           os_bit32    cardRomUpper32,
                           os_bit32    cardRomLower32,
                           os_bit32    cardRomLen,
                           os_bit32    usecsPerTick
                         )
{
    agBOOLEAN               fiMemMapCalculate_rtn;
    fiMemMapCalculation_t   fiMemMapCalculation;
    CThread_t             * pCThread;
    os_bit32                DEVID_VENDID;
    os_bit32                retry_count = 0;

#ifdef OSLayer_NT

	os_bit32				   tmp;
#endif /* OSLayer_NT */

#ifdef Force_sysIntsActive
    sysIntsActive = Force_sysIntsActive;
#endif /* Force_sysIntsActive */

    if (fcCardSupported(
                         hpRoot
                       )        != agTRUE)
    {
        fiLogDebugString(
                          hpRoot,
                          FCMainLogErrorLevel,
                          "fcInitializeChannel(): fcCardSupported() Sanity Check returned agFALSE !!!",
                          (char *)agNULL,(char *)agNULL,
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        fiLogString(hpRoot,
                        "%s failed %s failed",
                        "fcInitializeChannel","fcCardSupported",
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

        return fcInitializeFailure;
    }

    fiSingleThreadedEnter(hpRoot , fdInitializeChannel);

    fiMemMapCalculation.Input.initType         = initType;
    fiMemMapCalculation.Input.sysIntsActive    = sysIntsActive;
    fiMemMapCalculation.Input.cachedMemoryPtr  = cachedMemoryPtr;
    fiMemMapCalculation.Input.cachedMemoryLen  = cachedMemoryLen;
    fiMemMapCalculation.Input.dmaMemoryUpper32 = dmaMemoryUpper32;
    fiMemMapCalculation.Input.dmaMemoryLower32 = dmaMemoryLower32;
    fiMemMapCalculation.Input.dmaMemoryPtr     = dmaMemoryPtr;
    fiMemMapCalculation.Input.dmaMemoryLen     = dmaMemoryLen;
    fiMemMapCalculation.Input.nvMemoryLen      = nvMemoryLen;
    fiMemMapCalculation.Input.cardRamUpper32   = cardRamUpper32;
    fiMemMapCalculation.Input.cardRamLower32   = cardRamLower32;
    fiMemMapCalculation.Input.cardRamLen       = cardRamLen;
    fiMemMapCalculation.Input.cardRomUpper32   = cardRomUpper32;
    fiMemMapCalculation.Input.cardRomLower32   = cardRomLower32;
    fiMemMapCalculation.Input.cardRomLen       = cardRomLen;
    fiMemMapCalculation.Input.usecsPerTick     = usecsPerTick;


    fiLogDebugString(
                    hpRoot,
                    FCMainLogErrorLevel,
                    "fcInitializeChannel vdma %p pdma %08X",
                    (char *)agNULL,(char *)agNULL,
                    dmaMemoryPtr,(void *)agNULL,
                    (os_bit32)dmaMemoryLower32,
                    0,0,0,0,0,0,0
                    );



    fiMemMapCalculate_rtn = fiMemMapCalculate(
                                               hpRoot,
                                               &fiMemMapCalculation,
                                               agFALSE
                                              );

    if (fiMemMapCalculate_rtn == agFALSE)
    {
        fiLogDebugString(
                        hpRoot,
                        FCMainLogConsoleLevel,
                        "fcInitializeChannel\fiMemMapCalculate(EnforceDefaults==agFALSE) returned agFALSE !!!",
                        (char *)agNULL,(char *)agNULL,
                        hpRoot,&fiMemMapCalculation,
                        0,0,0,0,0,0,0,0
                        );

        fiMemMapCalculate_rtn = fiMemMapCalculate(
                                                   hpRoot,
                                                   &fiMemMapCalculation,
                                                   agTRUE
                                                  );
    }

    if (fiMemMapCalculate_rtn == agFALSE)
    {
        fiLogDebugString(
                          hpRoot,
                          FCMainLogConsoleLevel,
                          "fcInitializeChannel\fiMemMapCalculate(EnforceDefaults==agTRUE) returned agFALSE as well!!!",
                          (char *)agNULL,(char *)agNULL,
                          hpRoot,&fiMemMapCalculation,
                          0,0,0,0,0,0,0,0
                        );

        fiLogString(hpRoot,
                        "%s failed %s failed %x",
                        "fcInitializeChannel","fiMemMapCalculate",
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

        fiSingleThreadedLeave(hpRoot , fdInitializeChannel);

        return fcInitializeFailure;
    }

    hpRoot->fcData = (void *)(fiMemMapCalculation.MemoryLayout.CThread.addr.CachedMemory.cachedMemoryPtr);

    ((CThread_t *)(hpRoot->fcData))->Calculation = fiMemMapCalculation;

    pCThread = CThread_ptr(hpRoot)->Calculation.MemoryLayout.CThread.addr.CachedMemory.cachedMemoryPtr;

    /* Read in important PCI Config Registers */

    DEVID_VENDID     = osChipConfigReadBit32(
                                              hpRoot,
                                              ChipConfig_DEVID_VENDID
                                            );

    pCThread->VENDID = DEVID_VENDID & ChipConfig_VENDID_MASK;

    pCThread->DEVID  = DEVID_VENDID & ChipConfig_DEVID_MASK;

    pCThread->REVID  = osChipConfigReadBit32(
                                              hpRoot,
                                              ChipConfig_CLSCODE_REVID
                                            )                          & ChipConfig_REVID_Major_Minor_MASK;

    pCThread->SVID   = osChipConfigReadBit32(
                                              hpRoot,
                                              ChipConfig_SVID
                                            );

    if(pCThread->SVID == 0x1101103C )
    {

        fiLogString(hpRoot,
                        "(%p) %s  SVID (%08X) JANUS Board Yuk !!!",
                        "fcInitializeChannel",(char *)agNULL,
                        hpRoot,(void *)agNULL,
                        pCThread->SVID,0,0,0,0,0,0,0);

        pCThread->JANUS = agTRUE;
    }
    else
    {
        fiLogDebugString(hpRoot,
                        CFuncLogConsoleERROR,
                        "(%p) %s  SVID (%08X) Single Channel Board",
                        "fcInitializeChannel",(char *)agNULL,
                        hpRoot,(void *)agNULL,
                        pCThread->SVID,0,0,0,0,0,0,0);
        pCThread->JANUS = agFALSE;
    }

    CFuncReadBiosParms(hpRoot);
    pCThread->NumberTwoGigFailures=0;
    /* Initialize Interrupt Delay Mechanism to be disabled */

    pCThread->RSCNreceived            = agFALSE;

    pCThread->InterruptsDelayed       = agFALSE;
    pCThread->InterruptDelaySuspended = agFALSE;
    pCThread->NoStallTimerTickActive  = agFALSE;
    pCThread->TimerTickActive         = agFALSE;

#ifdef __FC_Layer_Loose_IOs
    pCThread->IOsTotalCompleted = 0;
    pCThread->IOsFailedCompeted = 0;
#endif /*  __FC_Layer_Loose_IOs  */

    pCThread->thread_hdr.subState     = CSubStateInitialized;

    if( fiFlashSvcInitialize(hpRoot))
    {
        fiLogString(hpRoot,
                        "%s failed %s failed %x",
                        "fcInitializeChannel","fiFlashSvcInitialize",
                        (void *)agNULL,(void *)agNULL,
                        0,0,0,0,0,0,0,0);

        fiSingleThreadedLeave(hpRoot , fdInitializeChannel);

        return fcInitializeFailure;
    }

    /* Setup Channel Thread */

#ifndef __State_Force_Static_State_Tables__
    fiInstallStateMachine(
        &CStateTransitionMatrix,
        &CStateActionScalar,
        pCThread->Calculation.MemoryLayout.CTransitions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.CActions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.On_Card_MASK,
        &noActionUpdate
        );
#endif /* __State_Force_Static_State_Tables__ was not defined */

    fiInitializeThread(&pCThread->thread_hdr,
        hpRoot,
        threadType_CThread,
        CStateShutdown,
#ifdef __State_Force_Static_State_Tables__
        &CStateTransitionMatrix,
        &CStateActionScalar
#else /* __State_Force_Static_State_Tables__ was not defined */
        pCThread->Calculation.MemoryLayout.CTransitions.addr.CachedMemory.cachedMemoryPtr,
        pCThread->Calculation.MemoryLayout.CActions.addr.CachedMemory.cachedMemoryPtr
#endif /* __State_Force_Static_State_Tables__ was not defined */
        );

    pCThread->SFThread_Request.SFThread = (SFThread_t *)agNULL;

    SFThreadInitializeRequest(
                               &(pCThread->SFThread_Request)
                             );

    fiTimerInitializeRequest(
                               &(pCThread->Timer_Request)
                            );

    DevThreadInitializeSlots(
                               hpRoot
                            );

    /* Kick-off CThread to continue initialization */

#ifdef TEST_OSLayer_Stub
/*
    testCthread( hpRoot );
    testSFthread( hpRoot );
    testDevthread( hpRoot );
    testCDBthread( hpRoot );
    return fcInitializeSuccess;
*/
#endif  /* TEST_OSLayer_Stub */
    pCThread->AquiredCredit_Shifted = BB_CREDIT_SHIFTED( 1 ); /* Start out with one credit */

    pCThread->DelayedInterruptActive = agFALSE;

    pCThread->DeviceSelf = (DevThread_t *)agNULL;
    pCThread->NOS_DetectedInIMQ = 0;
    pCThread->LaserEnable = agFALSE;

    pCThread->ProcessingIMQ = agFALSE;
    pCThread->IDLE_RECEIVED = agFALSE;
    pCThread->LOOP_DOWN = agTRUE;
    pCThread->ChanInfo.LinkUp = agFALSE;

    pCThread->Elastic_Store_ERROR_Count     = 0;
    pCThread->Lip_F7_In_tick                = 0;
    pCThread->Link_Failures_In_tick         = 0;
    pCThread->Lost_Signal_In_tick           = 0;

    pCThread->Node_By_Passed_In_tick        = 0;
    pCThread->Lost_sync_In_tick             = 0;
    pCThread->Transmit_PE_In_tick           = 0;
    pCThread->Link_Fault_In_tick            = 0;

    pCThread->TimerTickActive               = agFALSE;

    pCThread->TimeOutValues.RT_Tov = pCThread->Calculation.Parameters.RT_TOV;
    pCThread->TimeOutValues.ED_Tov = pCThread->Calculation.Parameters.ED_TOV;
    pCThread->TimeOutValues.LP_Tov = pCThread->Calculation.Parameters.LP_TOV;
    pCThread->TimeOutValues.AL_Time= pCThread->Calculation.Parameters.AL_Time;

    pCThread->Loop_State_TimeOut_In_tick    = 0;
    /* SNIA Link statistics                                 ChipLinkStatus registers    */

    pCThread->ChanInfo.LIPCountUpper= 0;
    pCThread->ChanInfo.LIPCountLower= 0;

    pCThread->ChanInfo.NOSCountUpper= 0;
    pCThread->ChanInfo.NOSCountLower= 0;

    pCThread->ChanInfo.ErrorFramesUpper= 0;
    pCThread->ChanInfo.ErrorFramesLower= 0;                 /* Link_Status_3_Exp_Frm and Link_Status_2_Rx_EOFa */

    pCThread->ChanInfo.DumpedFramesUpper= 0;
    pCThread->ChanInfo.DumpedFramesLower= 0;                /* Link_Status_2_Dis_Frm */

    pCThread->ChanInfo.LinkFailureCountUpper = 0;
    pCThread->ChanInfo.LinkFailureCountLower = 0;           /* Link_Status_1_Link_Fail */

    pCThread->ChanInfo.LossOfSyncCountLower  = 0;
    pCThread->ChanInfo.LossOfSyncCountUpper  = 0;           /* Link_Status_1_Loss_of_Sync */

    pCThread->ChanInfo.LossOfSignalCountLower = 0;
    pCThread->ChanInfo.LossOfSignalCountUpper = 0;          /* Link_Status_1_Loss_of_Signal */

    pCThread->ChanInfo.PrimitiveSeqProtocolErrCountUpper= 0;
    pCThread->ChanInfo.PrimitiveSeqProtocolErrCountLower= 0;/* Link_Status_2_Proto_Err */

    pCThread->ChanInfo.InvalidRxWordCountUpper= 0;
    pCThread->ChanInfo.InvalidRxWordCountLower= 0;          /* Link_Status_1_Bad_RX_Char */

    pCThread->ChanInfo.InvalidCRCCountUpper= 0;
    pCThread->ChanInfo.InvalidCRCCountLower= 0;             /* Link_Status_2_Bad_CRC */

#ifdef _SANMARK_LIP_BACKOFF
    pCThread->TicksTillLIP_Count           = 0;
#endif /* _SANMARK_LIP_BACKOFF */ 

    pCThread->sysIntsActive           = sysIntsActive;
    pCThread->sysIntsLogicallyEnabled = 0;
 
    pCThread->PreviouslyAquiredALPA = agFALSE;
    pCThread->ExpectMoreNSFrames    = agTRUE;
    pCThread->NS_CurrentBit32Index  = 0;

    pCThread->CDBpollingCount        = 0;
    pCThread->SFpollingCount         = 0;
    pCThread->Fabric_pollingCount    = 0;

    /* set NumberOutstandingFindDevice to the a max of 32 or less */
    pCThread->NumberOutstandingFindDevice = pCThread->Calculation.Parameters.SF_CMND_Reserve > 32 ? 32 : pCThread->Calculation.Parameters.SF_CMND_Reserve   ;

    fiLogDebugString(hpRoot,
            FCMainLogErrorLevel,
            "NumberOutstandingFindDevice %d NumDevices %d SF_CMND_Reserve %d",
            (char *)agNULL,(char *)agNULL,
            (void *)agNULL,(void *)agNULL,
            pCThread->NumberOutstandingFindDevice,
            pCThread->Calculation.Parameters.NumDevices,
            pCThread->Calculation.Parameters.SF_CMND_Reserve ,
            0,0,0,0,0);

    CFuncEnable_Interrupts(
                            hpRoot,
                            (  ChipIOUp_INTEN_MPE
                             | ChipIOUp_INTEN_CRS
                             | ChipIOUp_INTEN_INT
                             | ChipIOUp_INTEN_DER
                             | ChipIOUp_INTEN_PER)
                          );

    CFuncInit_FunctionPointers(hpRoot );

    CFuncInteruptDelay(hpRoot, agFALSE);

    fiSendEvent(&(pCThread->thread_hdr),CEventDoInitalize);

    if (pCThread->FlogiRcvdFromTarget)
    {
        /* We are in a situation where we recvd our own FLOGI. Our 
           controller gets into this mode when we switch from
           loop to point to point and the system does not do a 
           PCI reset on a softboot. We have to give up on point to point
           and go loop. */

        pCThread->Calculation.Parameters.InitAsNport = 0;

        fiLogDebugString(hpRoot,
                FCMainLogErrorLevel,
                "Going to Loop mode due to initialize nport failure .... CState %d",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->thread_hdr.currentState,
                0,0,0,0,0,0,0);

        fiSendEvent(&(pCThread->thread_hdr),CEventDoInitalize);
    }

#ifdef OSLayer_NT

    if(pCThread->Calculation.Parameters.WolfPack)
    {
	    /*Guru: Stall for 10 seconds for Wolfpack */
        for (tmp = 0; tmp < 10000; tmp++)
        {
            osStallThread(hpRoot, 300 );
            if( pCThread->thread_hdr.currentState == CStateNormal  )
            {
                pCThread->FuncPtrs.Proccess_IMQ(hpRoot);
            }
            osStallThread(hpRoot, 600 );
            if( pCThread->thread_hdr.currentState == CStateNormal  )
            {
                pCThread->FuncPtrs.Proccess_IMQ(hpRoot);
            }
            osStallThread(hpRoot, 100 );
            if( pCThread->thread_hdr.currentState == CStateNormal  )
            {
                pCThread->FuncPtrs.Proccess_IMQ(hpRoot);
            }

        }
    }
#endif  /* OSLayer_NT */

    pCThread->FuncPtrs.Proccess_IMQ(hpRoot);

    if( pCThread->thread_hdr.currentState != CStateNormal  )
    {
        fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "After CEventDoInitalize Failed CState %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);
        if (pCThread->InitAsNport)
        {
            fiSendEvent(&(pCThread->thread_hdr),CEventDoInitalize);
        }

        
        if( pCThread->thread_hdr.currentState == CStateResetNeeded  )
        {
            while ( pCThread->thread_hdr.currentState == CStateResetNeeded  )
            {
                if( pCThread->Loop_Reset_Event_to_Send == CEventDoInitalize)
                {
                    pCThread->Loop_Reset_Event_to_Send = CEventResetIfNeeded;
                }
                if( retry_count > MAX_fcInitializeChannel_RETRYS)
                {
                   break;
                }
                fiLogString(hpRoot,
                            "After CEventDoInitalize Failed retry_count %d",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            retry_count,
                            0,0,0,0,0,0,0);

                retry_count ++;

                fiSendEvent(&(pCThread->thread_hdr),(event_t) pCThread->Loop_Reset_Event_to_Send);
            }
        }
        else
        {
            if( pCThread->thread_hdr.currentState == CStateRSCNErrorBackIOs)
            {
                if(fiListElementOnList( (fiList_t *)(&(pCThread->Timer_Request)),
                                               &(pCThread->TimerQ)))
                {
                    fiTimerStop(&pCThread->Timer_Request);
                }

                fiSendEvent(&(pCThread->thread_hdr),CEventAllocDiPlogiThread);
            }
            else
            {
                if( pCThread->thread_hdr.currentState != CStateInitializeFailed)
                {
                    fiLogString(hpRoot,
                                    "%s Success %s %d %x CEventShutdown",
                                    "fcInitializeChannel","Cstate",
                                    (void *)agNULL,(void *)agNULL,
                                    (os_bit32)pCThread->thread_hdr.currentState,
                                    0,0,0,0,0,0,0);

                    fiSendEvent(&(pCThread->thread_hdr),CEventShutdown);
                    fiSendEvent(&(pCThread->thread_hdr),CEventDoInitalize);
                }
            }

            if( pCThread->thread_hdr.currentState != CStateNormal)
            {

                fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "After CEventDoInitalize Failed CState %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);
                fiSingleThreadedLeave(hpRoot , fdInitializeChannel);

                fiLogString(hpRoot,
                                "%s Success %s %d %x",
                                "fcInitializeChannel","Cstate",
                                (void *)agNULL,(void *)agNULL,
                                (os_bit32)pCThread->thread_hdr.currentState,
                                0,0,0,0,0,0,0);

                return fcInitializeSuccess;
            }
        }
    }


    if( CFuncIMQ_Interrupt_Pending( hpRoot))
    {   /* Some OSLayers Enable interupts before getting a vector*/
        /* Try to clear interrupt before returning  */
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "CFuncIMQ_Interrupt_Pending FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                0,0,0,0);
         pCThread->FuncPtrs.Proccess_IMQ(hpRoot);
    }

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "After CEventDoInitalize CCnt %x",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->CDBpollingCount,
                0,0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                FCMainLogConsoleLevel,
                "CFuncEnable_Interrupts CCnt %x",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                pCThread->CDBpollingCount,
                0,0,0,0,0,0,0);

    if(CFuncInterruptPoll( hpRoot,&pCThread->CDBpollingCount ))
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "fcinit Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                (char *)agNULL,(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                0,0,0,0);
    }

    fiSingleThreadedLeave(hpRoot , fdInitializeChannel);

    CFuncEnable_Interrupts(hpRoot,ChipIOUp_INTEN_INT);

    fiLogString(hpRoot,
                    "E %s Success %s %d",
                    "fcInitializeChannel","Cstate",
                    (void *)agNULL,(void *)agNULL,
                    (os_bit32)pCThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);


    return fcInitializeSuccess;
}

/*+
  Function: fcInitializeDriver
   Purpose: This function is called to calculate memory needed for the channel.
            The addresses of the passed pointers are updated after calculations are complete.
 Called By: <unknown OS Layer functions>
     Calls: FCStructASSERTs
            TLStructASSERTs
            fiFlashSvcASSERTs
            fiMemMapCalculate
-*/
os_bit32 fcInitializeDriver(
                          agRoot_t *hpRoot,
                          os_bit32    *cachedMemoryNeeded,
                          os_bit32    *cachedMemoryPtrAlign,
                          os_bit32    *dmaMemoryNeeded,
                          os_bit32    *dmaMemoryPtrAlign,
                          os_bit32    *dmaMemoryPhyAlign,
                          os_bit32    *nvMemoryNeeded,
                          os_bit32    *usecsPerTick
                        )
{
    agBOOLEAN               fiMemMapCalculate_rtn;
    fiMemMapCalculation_t fiMemMapCalculation;

    if (FCStructASSERTs()   > 0)
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "%s FAILED !!!!!",
                "FCStructASSERTs",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);
 
        return fcInitializeFailure;
    }

    if (TLStructASSERTs()   > 0)
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "%s FAILED !!!!!",
                "TLStructASSERTs",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);
 
        return fcInitializeFailure;
    }

    if (fiFlashSvcASSERTs() > 0)
    {
        fiLogDebugString(hpRoot,
                CStateLogConsoleERROR,
                "%s FAILED !!!!!",
                "fiFlashSvcASSERTs",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);
 
        return fcInitializeFailure;
    }


    fiMemMapCalculation.Input.initType         = 0;
    fiMemMapCalculation.Input.sysIntsActive    = agFALSE;
    fiMemMapCalculation.Input.cachedMemoryPtr  = agNULL;
    fiMemMapCalculation.Input.cachedMemoryLen  = 0xFFFFFFFF;
    fiMemMapCalculation.Input.dmaMemoryUpper32 = 0;
    fiMemMapCalculation.Input.dmaMemoryLower32 = 0;
    fiMemMapCalculation.Input.dmaMemoryPtr     = agNULL;
    fiMemMapCalculation.Input.dmaMemoryLen     = 0xFFFFFFFF;
    fiMemMapCalculation.Input.nvMemoryLen      = 0xFFFFFFFF;
    fiMemMapCalculation.Input.cardRamUpper32   = 0;
    fiMemMapCalculation.Input.cardRamLower32   = 0;
    fiMemMapCalculation.Input.cardRamLen       = 0x00040000;
    fiMemMapCalculation.Input.cardRomUpper32   = 0;
    fiMemMapCalculation.Input.cardRomLower32   = 0;
    fiMemMapCalculation.Input.cardRomLen       = 0x00020000;
    fiMemMapCalculation.Input.usecsPerTick     = 0;

    fiMemMapCalculate_rtn = fiMemMapCalculate(
                                               hpRoot,
                                               &fiMemMapCalculation,
                                               agFALSE
                                              );

    if (fiMemMapCalculate_rtn == agFALSE)
    {
        fiLogDebugString(
                          hpRoot,
                          FCMainLogConsoleLevel,
                          "fcInitializeDriver\fiMemMapCalculate(EnforceDefaults==agFALSE) returned agFALSE !!!",
                          (char *)agNULL,(char *)agNULL,
                          hpRoot,&fiMemMapCalculation,
                          0,0,0,0,0,0,0,0
                        );

        fiMemMapCalculate_rtn = fiMemMapCalculate(
                                                   hpRoot,
                                                   &fiMemMapCalculation,
                                                   agTRUE
                                                  );
    }

    if (fiMemMapCalculate_rtn == agFALSE)
    {
        fiLogDebugString(
                          hpRoot,
                          FCMainLogConsoleLevel,
                          "fcInitializeDriver\fiMemMapCalculate(EnforceDefaults==agTRUE) returned agFALSE as well!!!",
                          (char *)agNULL,(char *)agNULL,
                          hpRoot,&fiMemMapCalculation,
                          0,0,0,0,0,0,0,0
                        );

        *cachedMemoryNeeded   = 0;
        *cachedMemoryPtrAlign = 0;
        *dmaMemoryNeeded      = 0;
        *dmaMemoryPtrAlign    = 0;
        *dmaMemoryPhyAlign    = 0;
        *nvMemoryNeeded       = 0;
        *usecsPerTick         = 0;

        return fcInitializeFailure;
    }

    *cachedMemoryNeeded   = fiMemMapCalculation.ToRequest.cachedMemoryNeeded;
    *cachedMemoryPtrAlign = fiMemMapCalculation.ToRequest.cachedMemoryPtrAlignAssumed;
    *dmaMemoryNeeded      = fiMemMapCalculation.ToRequest.dmaMemoryNeeded;
    *dmaMemoryPtrAlign    = fiMemMapCalculation.ToRequest.dmaMemoryPtrAlignAssumed;
    *dmaMemoryPhyAlign    = fiMemMapCalculation.ToRequest.dmaMemoryPhyAlignAssumed;
    *nvMemoryNeeded       = fiMemMapCalculation.ToRequest.nvMemoryNeeded;
    *usecsPerTick         = fiMemMapCalculation.ToRequest.usecsPerTick;

    return fcInitializeSuccess;
}

/*+
  Function: fcInterruptHandler
   Purpose: This function is called to disable interrupts for the channel.
            returns agTRUE if interrupt if active on this channel.
            Returns agFALSE if interrupt is cleared when checked.
            Special case. Some systems do not PCI reset the chip on reboot. 
            This could cause interrupts to be asserted before fclayer is setup(agNULL agRoot_t).
            Some OS's route interrupts to interrupt handler as soon as channel is identified.
            If called with agNULL agRoot_t reset chip.
 Called By: <unknown OS Layer functions>
     Calls: osChipIOUpWriteBit32
            CFuncSoftResetAdapter
            CFuncRead_Interrupts
            CFuncDisable_Interrupts
            osFCLayerAsyncError
            osDebugBreakpoint
-*/
agBOOLEAN fcInterruptHandler(
                            agRoot_t *hpRoot
                          )
{
    CThread_t *pCThread  = CThread_ptr(hpRoot);
    os_bit32      intStatus;

    if ( pCThread == agNULL)
    {
        /*
        ** Disable the interrupt.
        */

        osChipIOUpWriteBit32( hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST, 0 );

        /* If No Cthread this blue screens.....
             CFuncDisable_Interrupts(
                                     hpRoot,
                                     (  ChipIOUp_INTEN_MPE
                                      | ChipIOUp_INTEN_CRS
                                      | ChipIOUp_INTEN_INT
                                      | ChipIOUp_INTEN_DER
                                      | ChipIOUp_INTEN_PER)
                                   );
        */

        /*
        ** execute a hard reset on the HBA.
        */

        CFuncSoftResetAdapter(hpRoot);/*fcInterrupt*/

        return agFALSE;
    }

    intStatus = (  CFuncRead_Interrupts(
                                         hpRoot
                                       )
                 & ChipIOUp_INTPEND_MASK       );

    if (intStatus == ChipIOUp_INTPEND_INT)
    {
        /* Typically, we will find that TachyonTL generated the INT (a.k.a. "TachLite Interrupt") */

        CFuncDisable_Interrupts(
                                 hpRoot,
                                 ChipIOUp_INTEN_INT
                               );

        return agTRUE;
    }

	/*+
	 * If power is already removed from the PCI slot, return agFALSE as this is
	 * a spurious / invalid interrupt.
	-*/

    if (intStatus & ChipIOUp_INTPEND_Reserved )
    {   /* These bits should always be zero if set no power to chip these are set ! */
        return agFALSE;
    }
    if (!intStatus)
    {
        /* Alternatively, we will find that TachyonTL didn't generate any interrupt at all
           (i.e. some other PCI device is sharing TachyonTL's PCI Interrupt Line)          */

        return agFALSE;
    }

    /* If we get here, some non-INT interrupt has been raised (potentially INT as well) */

    if (intStatus & ChipIOUp_INTPEND_MPE)
    {
        /* MPE Interrupt raised - mask it and call osFCLayerAsyncError() */

        CFuncDisable_Interrupts(
                                 hpRoot,
                                 ChipIOUp_INTEN_MPE
                               );

        fiLogDebugString(
                          hpRoot,
                          FCMainLogErrorLevel,
                          "TachyonTL generated %s Interrupt (%s)",
                          "External Memory Parity Error",
                          "MPE",
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        osFCLayerAsyncError(
                             hpRoot,
                             osFCConfusedMPE
                           );
    }

    if (intStatus & ChipIOUp_INTPEND_CRS)
    {
        /* CRS Interrupt raised - mask it and call osFCLayerAsyncError() */

        CFuncDisable_Interrupts(
                                 hpRoot,
                                 ChipIOUp_INTEN_CRS
                               );

        fiLogDebugString(
                          hpRoot,
                          FCMainLogErrorLevel,
                          "TachyonTL generated %s Interrupt (%s)",
                          "PCI Master Address Crossed 45-Bit Boundary",
                          "CRS",
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        osFCLayerAsyncError(
                             hpRoot,
                             osFCConfusedCRS
                           );
    }

    if (intStatus & ChipIOUp_INTPEND_DER)
    {
        /* DER Interrupt raised - mask it and call osFCLayerAsyncError() */

        CFuncDisable_Interrupts(
                                 hpRoot,
                                 ChipIOUp_INTEN_DER
                               );

        fiLogDebugString(
                          hpRoot,
                          FCMainLogErrorLevel,
                          "TachyonTL generated %s Interrupt (%s)",
                          "DMA Error Detected",
                          "DER",
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        osFCLayerAsyncError(
                             hpRoot,
                             osFCConfusedDER
                           );
    }

    if (intStatus & ChipIOUp_INTPEND_PER)
    {
        /* PER Interrupt raised - mask it and call osFCLayerAsyncError() */

        CFuncDisable_Interrupts(
                                 hpRoot,
                                 ChipIOUp_INTEN_PER
                               );
/*
        fiLogDebugString(
                          hpRoot,
                          FCMainLogErrorLevel,
                          "TachyonTL generated %s Interrupt (%s)",
                          "PCI Error Detected",
                          "PER",
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

*/
       fiLogString(hpRoot,
                          "TachyonTL generated %s Interrupt (%s)",
                          "PCI Error Detected",
                          "PER",
                          (void *)agNULL,(void *)agNULL,
                          0,0,0,0,0,0,0,0
                        );

        CFuncYellowLed(hpRoot, agTRUE );
        osDebugBreakpoint (hpRoot, agTRUE, "PER");
        osFCLayerAsyncError(
                             hpRoot,
                             osFCConfusedPER
                           );
    }

    /* In case we are still alive, handle case where INT is also raised */

    if (intStatus & ChipIOUp_INTPEND_INT)
    {
        /* TachyonTL also generated the INT (a.k.a. "TachLite Interrupt") */

        CFuncDisable_Interrupts(
                                 hpRoot,
                                 ChipIOUp_INTEN_INT
                               );
    }

    return agTRUE;
} /* end fcInterruptHandler() */

/*+
  Function: fcIOInfoReadBit8
   Purpose: This function is called to read 8 bits of the response buffer information for agIORequest_t
            at offset fcIOInfoOffset.
            Only valid during osIOCompleted
 Called By: osIOCompleted
     Calls: Access's data structures only
-*/
os_bit8 fcIOInfoReadBit8(
                       agRoot_t      *hpRoot,
                       agIORequest_t *hpIORequest,
                       os_bit32          fcIOInfoOffset
                     )
{
    os_bit8                   to_return;
    os_bit32                  FCP_RESP_Offset;
    fiMemMapCalculation_t *Calculation;

    fiLogDebugString(hpRoot,
                    FCMainLogConsoleLevel,
                    "fcIOInfoReadBit8",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    Calculation = &(CThread_ptr(hpRoot)->Calculation);

    if (Calculation->MemoryLayout.FCP_RESP.memLoc == inCardRam)
    {
        FCP_RESP_Offset = CDBThread_ptr(hpIORequest)->FCP_RESP_Offset + fcIOInfoOffset;

        to_return = osCardRamReadBit8(
                                       hpRoot,
                                       FCP_RESP_Offset
                                     );
    }
    else /* Calculation->MemoryLayout.FCP_RESP.memLoc ==inDmaMemory */
    {
        to_return = *((os_bit8 *)(CDBThread_ptr(hpIORequest)->FCP_RESP_Ptr) + fcIOInfoOffset);
    }

    return to_return;
}

/*+
  Function: fcIOInfoReadBit16
   Purpose: This function is called to read 16 bits of the response buffer information for agIORequest_t
            at offset fcIOInfoOffset.
            Only valid during osIOCompleted
 Called By: osIOCompleted
     Calls: Access's data structures only
-*/
os_bit16 fcIOInfoReadBit16(
                         agRoot_t      *hpRoot,
                         agIORequest_t *hpIORequest,
                         os_bit32       fcIOInfoOffset
                       )
{
    os_bit16               to_return;
    os_bit32               FCP_RESP_Offset;
    fiMemMapCalculation_t *Calculation;

    fiLogDebugString(hpRoot,
                    FCMainLogConsoleLevel,
                    "fcIOInfoReadBit16",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    Calculation = &(CThread_ptr(hpRoot)->Calculation);

    if (Calculation->MemoryLayout.FCP_RESP.memLoc == inCardRam)
    {
        FCP_RESP_Offset = CDBThread_ptr(hpIORequest)->FCP_RESP_Offset + fcIOInfoOffset;

        to_return = osCardRamReadBit16(
                                        hpRoot,
                                        FCP_RESP_Offset
                                      );
    }
    else /* Calculation->MemoryLayout.FCP_RESP.memLoc ==inDmaMemory */
    {
        to_return = *(os_bit16 *)(((os_bit8 *)(CDBThread_ptr(hpIORequest)->FCP_RESP_Ptr) + fcIOInfoOffset));
    }

    return to_return;
}

/*+
  Function: fcIOInfoReadBit32
   Purpose: This function is called to read 32 bits of the response buffer information for agIORequest_t
            at offset fcIOInfoOffset.
            Only valid during osIOCompleted
 Called By: osIOCompleted
     Calls: Access's data structures only
-*/
os_bit32 fcIOInfoReadBit32(
                         agRoot_t      *hpRoot,
                         agIORequest_t *hpIORequest,
                         os_bit32          fcIOInfoOffset
                       )
{
    os_bit32                  to_return;
    os_bit32                  FCP_RESP_Offset;
    fiMemMapCalculation_t *Calculation;

    fiLogDebugString(hpRoot,
                    FCMainLogConsoleLevel,
                    "fcIOInfoReadBit32",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    Calculation = &(CThread_ptr(hpRoot)->Calculation);

    if (Calculation->MemoryLayout.FCP_RESP.memLoc == inCardRam)
    {
        FCP_RESP_Offset = CDBThread_ptr(hpIORequest)->FCP_RESP_Offset + fcIOInfoOffset;

        to_return = osCardRamReadBit32(
                                        hpRoot,
                                        FCP_RESP_Offset
                                      );
    }
    else /* Calculation->MemoryLayout.FCP_RESP.memLoc ==inDmaMemory */
    {
        to_return = *(os_bit32 *)(((os_bit8 *)(CDBThread_ptr(hpIORequest)->FCP_RESP_Ptr) + fcIOInfoOffset));
    }

    return to_return;
}

/*+
  Function: fcIOInfoReadBlock
   Purpose: This function is called to copy fcIOInfoBufLen bytes of the response buffer information
            for agIORequest_t at offset fcIOInfoOffset.
            Only valid during osIOCompleted
 Called By: osIOCompleted
     Calls: Access's data structures only
-*/
void fcIOInfoReadBlock(
                        agRoot_t      *hpRoot,
                        agIORequest_t *hpIORequest,
                        os_bit32       fcIOInfoOffset,
                        void          *fcIOInfoBuffer,
                        os_bit32       fcIOInfoBufLen
                      )
{
    os_bit32                  FCP_RESP_Offset;
    fiMemMapCalculation_t *Calculation;
    os_bit32                  cnt;
    os_bit8                  *src;
    os_bit8                  *dst = (void *)fcIOInfoBuffer;

#ifndef Performance_Debug
    fiLogDebugString(hpRoot,
                    FCMainLogConsoleLevel,
                    "fcIOInfoReadBlock",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);
#endif /* Performance_Debug */

    Calculation = &(CThread_ptr(hpRoot)->Calculation);

    if (Calculation->MemoryLayout.FCP_RESP.memLoc == inCardRam)
    {
        FCP_RESP_Offset = CDBThread_ptr(hpIORequest)->FCP_RESP_Offset + fcIOInfoOffset;

        osCardRamReadBlock(
                            hpRoot,
                            FCP_RESP_Offset,
                            fcIOInfoBuffer,
                            fcIOInfoBufLen
                          );
    }
    else /* Calculation->MemoryLayout.FCP_RESP.memLoc ==inDmaMemory */
    {
        src = (os_bit8 *)(CDBThread_ptr(hpIORequest)->FCP_RESP_Ptr) + fcIOInfoOffset;

        for (cnt = 0;
             cnt < fcIOInfoBufLen;
             cnt++
            )
        {
            *dst++ = *src++;
        }
    }

}


/*+

  Function: fcLeavingOS
   Purpose: This function is called to indicate to the FC Layer that it should prepare for the 
            OS to switch (presumably between NetWare and BIOS). Upon return from the "other OS", a 
            corresponding call to fcEnteringOS() will be made .  It is assumed by the OS Layer 
            that calling this function causes the FC Layer to stop participation on the Fibre 
            Channel until fcEnteringOS() is called.  Further, no interrupts or other PCI bus 
            accesses will be required by the card during this time.

  Called By: <unknown OS Layer functions>
      Calls: CFuncDisable_Interrupts

-*/
void fcLeavingOS(
                  agRoot_t *hpRoot
                )
{
    CThread_t *CThread;

    fiSingleThreadedEnter(hpRoot , fdLeavingOS);

    CThread = CThread_ptr(hpRoot);

    CThread->sysIntsActive_before_fcLeavingOS_call = CThread->sysIntsActive;

    CThread->sysIntsActive                         = agFALSE;

    CFuncDisable_Interrupts(
                             hpRoot,
                             0
                           );

    fiSingleThreadedLeave(hpRoot , fdLeavingOS);

    return;
}

#ifdef _DvrArch_1_30_

/*+
   Function: fcIPCancel
    Purpose: IP Cancels CancelItem
  Called By: OSLayer
      Calls: 
-*/
os_bit32 fcIPCancel(
                     agRoot_t          *hpRoot,
                     void              *osData,
		             void              *CancelItem
                   )
{
    CThread_t       *pCThread    = CThread_ptr(hpRoot);
    IPThread_t      *pIPThread   = pCThread->IP;
    void            *item        = CancelItem;

    if (item != agNULL)
    {
        if( fiListElementOnList( (fiList_t *) item, &pIPThread->IncomingBufferLink ) )
        {
            fiListDequeueThis( item );

            osFcNetIoctlCompleted( hpRoot, item, FC_CMND_STATUS_CANCELED );
        }
    }
    else do 
    {
        fiListDequeueFromHead( &item, &pIPThread->IncomingBufferLink );

        osFcNetIoctlCompleted( hpRoot, item, FC_CMND_STATUS_CANCELED );

    } while ( item != (void *) agNULL );

    osFcNetIoctlCompleted( hpRoot, osData, FC_CMND_STATUS_SUCCESS );

    return 0;
}

/*+
   Function: fcIPReceive
    Purpose: IP Initiates status report
  Called By: OSLayer
      Calls: 
-*/
os_bit32 fcIPReceive(
                      agRoot_t          *hpRoot,
                      void              *osData
                    )
{
    CThread_t       *pCThread    = CThread_ptr(hpRoot);
    IPThread_t      *pIPThread   = pCThread->IP;

    fiListEnqueueListAtTail( &pIPThread->IncomingBufferLink, osData );

    return 0;
}

/*+
   Function: fcIPSend
    Purpose: IP Initiates IPSend
  Called By: OSLayer
      Calls: PktEventDoIPData
-*/
os_bit32 fcIPSend(
                   agRoot_t          *hpRoot,
                   os_bit8           *DestAddress,
                   void              *osData,
		           os_bit32           PacketLength
                 )
{
    CThread_t       *pCThread    = CThread_ptr(hpRoot);
    PktThread_t     *pPktThread;
    os_bit32         i;

    DevThread_t     *pDevThread;
    os_bit8          PortWWN[8];

    fiLogDebugString(hpRoot,
                    IPStateLogConsoleLevel,
                    "In %s - State = %d",
                    "fcIPSend",(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

    PortWWN[0] = 0;
    PortWWN[1] = 0;
    for (i = 0; i < 6; i++)
        PortWWN[i+2] = DestAddress[i];

    pDevThread = CFuncMatchPortWWNtoThread( hpRoot, PortWWN );

    pPktThread = PktThreadAlloc( hpRoot, pDevThread );	

    pPktThread->osData = osData;
    pPktThread->DataLength = PacketLength;

    fiListEnqueueListAtTail( &pCThread->IP->OutgoingLink, pPktThread );

    fiSendEvent( &pPktThread->thread_hdr, PktEventDoIPData );

    return 0;
}

/*+
   Function: fcIPStatus
    Purpose: IP Initiates status report
  Called By: OSLayer
      Calls: IPEventReportLinkStatus
-*/
os_bit32 fcIPStatus(
                     agRoot_t          *hpRoot,
                     void              *osData
                   )
{
    CThread_t       *pCThread    = CThread_ptr(hpRoot);
    IPThread_t      *pIPThread   = pCThread->IP;

    pIPThread->LinkStatus.osData = osData;

    fiSendEvent( &pIPThread->thread_hdr, IPEventReportLinkStatus );

    return 0;
}

/*+
   Function: fcProcessInboundQ
    Purpose: IP Currently does nothing
  Called By: OSLayer
      Calls: 
-*/
void fcProcessInboundQ(
                        agRoot_t  *agRoot,
                        os_bit32   agQPairID
                      )
{
    fiLogDebugString( agRoot,
                      FCMainLogConsoleLevel,
                      "fcProcessInboundQ(): agRoot==0x%8P agQPairID==0x%1X",
                      (char *)agNULL,(char *)agNULL,
                      (void *)agRoot,(void *)agNULL,
                      agQPairID,
                      0,0,0,0,0,0,0 );
}
#endif /* _DvrArch_1_30_ was defined */

/*+
  Function: fcResetChannel
   Purpose: Completes all outstanding IO's. Initiates rescan of channel if channel is OK.
            Takes appropriate action if channel is not OK.
 Called By: OSLayer
     Calls: CFuncCompleteAllActiveCDBThreads
            CFuncCheckCstate
            CEventAsyncLoopEventDetected
            CFuncShowActiveCDBThreads
-*/
os_bit32 fcResetChannel(
                      agRoot_t *hpRoot,
                      os_bit32  hpResetType
                    )
{
    event_t      Event_to_Send = 0;
    CThread_t   *pCThread;
    os_bit32     Num_ActiveCDBSonEntry = 0;

    pCThread = CThread_ptr(hpRoot)->Calculation.MemoryLayout.CThread.addr.CachedMemory.cachedMemoryPtr;

    fiLogString(hpRoot,
                "In %s CState %d Active IO %x",
                "fcResetChannel",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)pCThread->thread_hdr.currentState,
				CFuncShowActiveCDBThreads( hpRoot, ShowActive),
                0,0,0,0,0,0);

    fiSingleThreadedEnter(hpRoot , fdResetChannel);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "fcResetChannel Ccnt %x CState %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    pCThread->CDBpollingCount,
                    (os_bit32)pCThread->thread_hdr.currentState,
                    0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FM Status %08X TL Status %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LOOP_DOWN,
                    CThread_ptr(hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(hpRoot)->ERQ_FROZEN,
                    CThread_ptr(hpRoot)->FCP_FROZEN,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0);

    Num_ActiveCDBSonEntry = CFuncShowActiveCDBThreads( hpRoot, ShowActive);

    CFuncCompleteAllActiveCDBThreads( hpRoot,osIOFailed,CDBEventIODeviceReset );

    if( pCThread->thread_hdr.currentState != CStateNormal )
    {
        if( (Event_to_Send = CFuncCheckCstate(hpRoot)) != 0)
        {
            fiSendEvent(&(pCThread->thread_hdr),Event_to_Send);
        }
        else
        {
            fiSendEvent(&(pCThread->thread_hdr),CEventDoInitalize);
        }
    }
    else
    {
        fiSendEvent(&(pCThread->thread_hdr),CEventAsyncLoopEventDetected);
    }

    if ((hpResetType & fcSyncAsyncResetMask) == fcAsyncReset)
    {
        osResetChannelCallback(
                                hpRoot,
                                fcResetSuccess
                              );
    }


    Num_ActiveCDBSonEntry = CFuncShowActiveCDBThreads( hpRoot, ShowActive);

    fiLogString(hpRoot,
                "Out %s CState %d Active %d",
                "fcResetChannel",(char *)agNULL,
                (void *)agNULL,(void *)agNULL,
                (os_bit32)pCThread->thread_hdr.currentState,
				Num_ActiveCDBSonEntry,
                0,0,0,0,0,0);

    fiSingleThreadedLeave(hpRoot , fdResetChannel);


    return(fcResetSuccess);
}


/*+
  Function: fcResetDevice
   Purpose: Completes all outstanding IO's on hpFCDev. If hpResetType is hard reset
            send task managment function Target Reset to hpFCDev. (This will break a 
            reserve on a disk drive ) Soft reset will do PLOGI and PRLI.
            If hpFCDevhpFCDev is  fcResetAllDevs all devices are sent the reset type.
        
 Called By: OSLayer
     Calls: Proccess_IMQ
            fiResetAllDevices
            fiResetDevice
            CFuncCheckCstate
            CFuncShowActiveCDBThreads
-*/
os_bit32 fcResetDevice(
                     agRoot_t  *hpRoot,
                     agFCDev_t  hpFCDev,
                     os_bit32   hpResetType
                   )
{
    CThread_t  *CThread                 = CThread_ptr(hpRoot);
    event_t     Event_to_Send           = 0;
    os_bit32    Num_ActiveCDBSonEntry   = 0;

    os_bit32 status = fcResetSuccess;

    fiSingleThreadedEnter(hpRoot, fdResetDevice );

    if(CThread->DEVReset_pollingCount)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Entry Non zero DEVReset_pollingCount %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread->DEVReset_pollingCount,
                    0,0,0,0,0,0,0);

        CThread->DEVReset_pollingCount = 0;
    }

    fiLogString(hpRoot,
                    "IN fcResetDevice %p Ldt %X CS %d AC %x",
                    (char *)agNULL,(char *)agNULL,
                    hpFCDev,(void *)agNULL,
                    CThread->LinkDownTime.Lo,
                    CThread->thread_hdr.currentState,
                    CFuncAll_clear( hpRoot ),
                    0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "IN fcResetDevice %p Ccnt %x",
                    (char *)agNULL,(char *)agNULL,
                    hpFCDev,(void *)agNULL,
                    CThread->CDBpollingCount,
                    0,0,0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "FM Status %08X TL Status %08X FMcfg %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32( hpRoot,ChipIOUp_Frame_Manager_Configuration ),
                    0,0,0,0,0);

    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "FLAGS LD %x IR %x OR %x ERQ %x FCP %x InIMQ %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread_ptr(hpRoot)->LOOP_DOWN,
                    CThread_ptr(hpRoot)->IDLE_RECEIVED,
                    CThread_ptr(hpRoot)->OUTBOUND_RECEIVED,
                    CThread_ptr(hpRoot)->ERQ_FROZEN,
                    CThread_ptr(hpRoot)->FCP_FROZEN,
                    CThread_ptr(hpRoot)->ProcessingIMQ,
                    0,0);

    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "Interrupt %08X (%08X) TLStatus %08X pending  %x !",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CFuncRead_Interrupts(hpRoot),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    CFuncIMQ_Interrupt_Pending( hpRoot),
                    0,0,0,0);

    if(  CFuncIMQ_Interrupt_Pending( hpRoot))
    {
        CThread->FuncPtrs.Proccess_IMQ(hpRoot);
    }

    if ( hpFCDev == agNULL )
    {
        fiSingleThreadedLeave(hpRoot, fdResetDevice );

        return fcResetFailure;
    }


    Num_ActiveCDBSonEntry = CFuncShowActiveCDBThreads( hpRoot, ShowActive);

	if(! CFuncFreezeQueuesPoll(hpRoot) )
    {
		CFuncReInitializeSEST(hpRoot);
		osChipIOUpWriteBit32(hpRoot, ChipIOUp_SEST_Linked_List_Head_Tail, 0xffffffff);
	}
    else
    {
        fiLogString(hpRoot,
                "%s %s failed !",
                "fcResetDevice","CFuncFreezeQueuesPoll",
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);

	}

	if (CFunc_Always_Enable_Queues(hpRoot))
    {
        fiLogString(hpRoot,
                "%s %s failed !",
                "fcResetDevice","CFunc_Always_Enable_Queues",
                (void *)agNULL,(void *)agNULL,
                0,0,0,0,0,0,0,0);
	}


    CThread->thread_hdr.subState = CSubStateResettingDevices;

    if ( hpFCDev == fcResetAllDevs )
    {
        status = fiResetAllDevices( hpRoot, hpResetType );

    }
    else
    {
        status = fiResetDevice( hpRoot, hpFCDev, hpResetType, agTRUE, agTRUE);
    }

    if(CThread->DEVReset_pollingCount)
    {
        fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Exit Non zero DEVReset_pollingCount %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread->DEVReset_pollingCount,
                    0,0,0,0,0,0,0);

        CThread->DEVReset_pollingCount = 0;
    }

    CThread->thread_hdr.subState = CSubStateInitialized;

    if( (Event_to_Send = CFuncCheckCstate(hpRoot)) != 0)
    {
        fiSendEvent(&(CThread->thread_hdr),Event_to_Send);
    }

    if ((hpResetType & fcSyncAsyncResetMask) == fcAsyncReset)
    {
        osResetDeviceCallback(
                                hpRoot,hpFCDev,
                                fcResetSuccess
                              );
    }


    fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "OUT fcResetDevice %p Ccnt %x",
                    (char *)agNULL,(char *)agNULL,
                    hpFCDev,(void *)agNULL,
                    CThread->CDBpollingCount,
                    0,0,0,0,0,0,0);

    fiLogString(hpRoot,
                "%s %p CState %d Aoe %x Now %x",
                "fcResetDevice",(char *)agNULL,
                 hpFCDev,(void *)agNULL,
                (os_bit32)CThread->thread_hdr.currentState,
				Num_ActiveCDBSonEntry,
				CFuncShowActiveCDBThreads( hpRoot, ShowActive),
                0,0,0,0,0);

    fiSingleThreadedLeave(hpRoot, fdResetDevice );

    return status;
}


/*+
  Function: fcShutdownChannel
   Purpose: Takes channel to shutdown state.        
 Called By: OSLayer
     Calls: CEventShutdown
-*/
void fcShutdownChannel(
                        agRoot_t  *hpRoot
                      )
{
    CThread_t *CThread = CThread_ptr(hpRoot);


    fiSingleThreadedEnter(hpRoot, fdShutdownChannel );

    fiSendEvent( &CThread->thread_hdr, CEventShutdown );

    fiSingleThreadedLeave(hpRoot, fdShutdownChannel );

    fiLogDebugString(hpRoot,
                    FCMainLogConsoleLevel,
                    "Out fcShutdownChannel",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);


    return;
}

/*+
  Function: fcStartIO
   Purpose: Executes SCSI IO to given hpFCDev.
            if defined _Sanity_Check_hpIORequest_ verifies that no IO's are owed by fclayer with the current 
            agIORequest_t. If Calculation.Parameters.IO_Mode is polling do not return until request completes.
            If CThread->IOsStartedSinceISR < CThread->Calculation.Parameters.IOsBetweenISRs disable 
            CFuncInteruptDelay.
   Returns: fcIOBusy if FCLayer cannot execute request if in a improper state or lack of recources.
            fcIONoDevice if device handle bad.
            fcIOStarted if IO accepted - fclayer now "owns" request.
 Called By: OSLayer
     Calls: CDBThreadAlloc
            DevEventSendIO
            CFuncInterruptPoll
            CThread->Loop_Reset_Event_to_Send
            CFuncInteruptDelay
            Proccess_IMQ
-*/
os_bit32 fcStartIO(
                 agRoot_t          *hpRoot,
                 agIORequest_t     *hpIORequest,
                 agFCDev_t          hpFCDev,
                 os_bit32           hpRequestType,
                 agIORequestBody_t *hpRequestBody
               )
{
    CThread_t   *CThread   = CThread_ptr(hpRoot);
    CDBThread_t *CDBThread;
    DevThread_t *DevThread = (DevThread_t *)hpFCDev;

#ifdef _Sanity_Check_hpIORequest_
    fiList_t    *Sanity_DevLink;
    fiList_t    *Sanity_DevLink_Start;
    DevThread_t *Sanity_DevThread;
    fiList_t    *Sanity_CDBLink;
    fiList_t    *Sanity_CDBLink_Start;
    CDBThread_t *Sanity_CDBThread;
#endif /* _Sanity_Check_hpIORequest_ was defined */

    fiSingleThreadedEnter(hpRoot, fdStartIO );

    if ( hpFCDev == agNULL )
    {
        fiSingleThreadedLeave(hpRoot, fdStartIO );

        return fcIONoDevice;
    }

    if( CThread->thread_hdr.currentState != CStateNormal )
    {
        fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "fcStartIO Busy - CThread not in CStateNormal State %d",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    CThread->thread_hdr.currentState,
                    hpRequestType,0,0,0,0,0,0);

        fiSingleThreadedLeave(hpRoot, fdStartIO );

        if( CThread->thread_hdr.currentState == CStateInitializeFailed )
        {
        }
        return fcIOBusy;
    }

#ifdef _Sanity_Check_hpIORequest_
    Sanity_DevLink_Start = &(CThread->Active_DevLink);
    Sanity_DevLink       = Sanity_DevLink_Start;
    while ((Sanity_DevLink = Sanity_DevLink->flink) != Sanity_DevLink_Start)
    {
        Sanity_DevThread     = hpObjectBase(DevThread_t,DevLink,Sanity_DevLink);
        Sanity_CDBLink_Start = &(Sanity_DevThread->Active_CDBLink);
        Sanity_CDBLink       = Sanity_CDBLink_Start;
        while ((Sanity_CDBLink = Sanity_CDBLink->flink) != Sanity_CDBLink_Start)
        {
            Sanity_CDBThread = hpObjectBase(CDBThread_t,CDBLink,Sanity_CDBLink);
            if (hpIORequest == Sanity_CDBThread->hpIORequest)
            {
                fiLogDebugString(
                                  hpRoot,
                                  FCMainLogErrorLevel,
                                  "fcStartIO() called w/ already active hpIORequest (0x%08X) thread (0x%08X)",
                                  (char *)agNULL,(char *)agNULL,
                                  (void *)agNULL,(void *)agNULL,
                                  (os_bit32)hpIORequest,
                                  (os_bit32)Sanity_CDBThread,
                                  0,0,0,0,0,0
                                );
            }
        }
    }
#endif /* _Sanity_Check_hpIORequest_ was defined */

#ifdef Device_IO_Throttle
    if( DevThread->DevActive_pollingCount > (Device_IO_Throttle_MAX_Outstanding_IO - 1)  )
    {
        fiSingleThreadedLeave(hpRoot,fdStartIO );
        fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "fcStartIO Busy - DevActive_pollingCount %x",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    DevThread->DevActive_pollingCount,
                    0,0,0,0,0,0,0);
        return fcIOBusy;
    }
#endif /* Device_IO_Throttle */

    if ((CDBThread = CDBThreadAlloc(
                                     hpRoot,
                                     hpIORequest,
                                     hpFCDev,
                                     hpRequestBody
                                   )) == (CDBThread_t *)agNULL)
    {
        fiSingleThreadedLeave(hpRoot,fdStartIO );

        fiLogDebugString(hpRoot,
                    FCMainLogErrorLevel,
                    "fcStartIO Busy - CDBThreadAlloc Failed",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    0,0,0,0,0,0,0,0);

        return fcIOBusy;
    }

#ifndef Performance_Debug
    fiLogDebugString(hpRoot,
                    FCMainLogConsoleLevel,
                    "Lun %08X %08X Control %08X CDB %08X %08X %08X %08X DL %08X ",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    *(os_bit32 *)&hpRequestBody->CDBRequest.FcpCmnd.FcpLun[0],
                    *(os_bit32 *)&hpRequestBody->CDBRequest.FcpCmnd.FcpLun[4],
                    *(os_bit32 *)&hpRequestBody->CDBRequest.FcpCmnd.FcpCntl[0],
                    *(os_bit32 *)&hpRequestBody->CDBRequest.FcpCmnd.FcpCdb[0],
                    *(os_bit32 *)&hpRequestBody->CDBRequest.FcpCmnd.FcpCdb[4],
                    *(os_bit32 *)&hpRequestBody->CDBRequest.FcpCmnd.FcpCdb[8],
                    *(os_bit32 *)&hpRequestBody->CDBRequest.FcpCmnd.FcpCdb[12],
                    *(os_bit32 *)&hpRequestBody->CDBRequest.FcpCmnd.FcpDL[0]);

#endif /* Performance_Debug */

    /*
    fiSendEvent( &(CDBThread->thread_hdr), CDBEventInitialize );
    */
    fiSendEvent( &(DevThread->thread_hdr), DevEventSendIO );

    if( CThread->thread_hdr.currentState == CStateResetNeeded )
    {
        fiSendEvent(&(CThread->thread_hdr),(event_t)CThread->Loop_Reset_Event_to_Send);
    }

    if ((CThread->sysIntsActive == agFALSE) || (CThread->Calculation.Parameters.IO_Mode == MemMap_Polling_IO_Mode))
    {
        if(CFuncInterruptPoll( hpRoot,&CThread->CDBpollingCount ))
        {
            fiLogDebugString(hpRoot,
                    CStateLogConsoleERROR,
                    "Sio Fail Poll Timeout FM Status %08X FM Config %08X TL Status %08X Alpa %08X",
                    (char *)agNULL,(char *)agNULL,
                    (void *)agNULL,(void *)agNULL,
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Configuration ),
                    osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                    osChipIOUpReadBit32(hpRoot,ChipIOUp_Frame_Manager_Received_ALPA),
                    0,0,0,0);
        }
    }
    else /* (CThread->sysIntsActive == agTRUE) && (CThread->Calculation.Parameters.IO_Mode == MemMap_Interrupt_IO_Mode) */
    {
        if (++CThread->IOsStartedSinceISR < CThread->Calculation.Parameters.IOsBetweenISRs)
        {
            CThread->FuncPtrs.Proccess_IMQ(hpRoot);/* IO Path */
            if(CThread->RSCNreceived )
            {
                if( CThread->thread_hdr.currentState == CStateRSCNErrorBackIOs  )
                {
                    CThread->RSCNreceived = agFALSE;
                    CFuncDoADISC( hpRoot);
                    fiSendEvent(&(CThread->thread_hdr),CEventDeviceListEmpty);
                    fiLogString(hpRoot,
                                    "%s CState %d",
                                    "fcStartIO",(char *)agNULL,
                                    (void *)agNULL,(void *)agNULL,
                                    CThread->thread_hdr.currentState,
                                    0,0,0,0,0,0,0);

                }
            }

        }
        else /* ++CThread->IOsStartedSinceISR >= CThread->Calculation.Parameters.IOsBetweenISRs */
        {
            if (    (CThread->InterruptsDelayed       == agTRUE)
                 && (CThread->InterruptDelaySuspended == agFALSE) )
            {
                /* Temporarily stop delaying interrupts */

                CThread->InterruptDelaySuspended = agTRUE;

                CFuncInteruptDelay(hpRoot, agFALSE);
#ifdef USE_XL_Delay_Register
                /* If XL DelayTimer */
                CThread->FuncPtrs.Proccess_IMQ(hpRoot); /* IO Path */
#endif /* USE_XL_Delay_Register */

            }
        }
    }

    fiSingleThreadedLeave(hpRoot, fdStartIO );

    return fcIOStarted;
}

/*+
  Function: fcSystemInterruptsActive
   Purpose: Allows OSLayer to control channel interrupt activity - global enable / disable.
 Called By: OSLayer
     Calls: CFuncEnable_Interrupts
-*/
void fcSystemInterruptsActive(
                               agRoot_t *hpRoot,
                               agBOOLEAN   sysIntsActive
                             )
{
    fiSingleThreadedEnter(hpRoot, fdSystemInterruptsActive );

    CThread_ptr(hpRoot)->sysIntsActive = sysIntsActive;

    CFuncEnable_Interrupts(
                            hpRoot,
                            0
                          );

    fiSingleThreadedLeave(hpRoot, fdSystemInterruptsActive );

    return;
}

/*
#define SkipHeartBeat
*/

/*+
  Function: fcTimerTick
   Purpose: Periodic opportuinity for fclayer housekeeping. Generally set to one second intervals. 
            Blinks the LED. Reset counters, poll link statictics, enable / disable interrupt delay. 
            Sends recovery events.
 Called By: OSLayer
     Calls: fiTimerTick
            Proccess_IMQ
            CFuncInteruptDelay
            CFuncCheckCstate
            CFuncCheckForTimeouts
-*/
void fcTimerTick(
                  agRoot_t *hpRoot
                )
{
    CThread_t * CThread                       = CThread_ptr(hpRoot);
    os_bit32    IntDelayRateMethod            = CThread->Calculation.Parameters.IntDelayRateMethod;
    os_bit32    IntDelayOnIORate              = CThread->Calculation.Parameters.IntDelayOnIORate;
    os_bit32    IntDelayOffIORate             = CThread->Calculation.Parameters.IntDelayOffIORate;
    os_bit32    IOsStartedThisTimerTick;
    os_bit32    IOsCompletedThisTimerTick;
    os_bit32    IOsIntCompletedThisTimerTick;
    os_bit32    IOsPollCompletedThisTimerTick;
    os_bit32    IOsActive;

    agBOOLEAN  Link_Status_counts_Change = agFALSE;

    event_t     event_to_send;
    os_bit32    Link_Status_Counts = 0;

    fiSingleThreadedEnter(hpRoot, fdTimerTick );
    if (! CThread->InitAsNport)
    {
        CThread->NoStallTimerTickActive = agTRUE;
    }
    CThread->TimerTickActive = agTRUE;
    /* Fetch running counters */

    IOsStartedThisTimerTick       = CThread->IOsStartedThisTimerTick;
    IOsCompletedThisTimerTick     = CThread->IOsCompletedThisTimerTick;
    IOsIntCompletedThisTimerTick  = CThread->IOsIntCompletedThisTimerTick;
    IOsPollCompletedThisTimerTick = IOsCompletedThisTimerTick - IOsIntCompletedThisTimerTick;
    IOsActive                     = CThread->IOsActive;

    if( CThread->IOsActive_LastTick )
    {
        if( CThread->IOsActive_LastTick == CThread->IOsActive)
        {
            if( IOsStartedThisTimerTick == 0 )
            {
                if( IOsIntCompletedThisTimerTick == 0 )
                {
                    if( IOsPollCompletedThisTimerTick == 0  &&  CThread->thread_hdr.currentState == CStateNormal )
                    {
                        CThread->IOsActive_No_ProgressCount++;

                        fiLogString(hpRoot,
                                        "%s No Progress Act %d Pend %d Cs %d Cnt %d",
                                        "fcTimerTick",(char *)agNULL,
                                        (void *)agNULL,(void *)agNULL,
                                        CThread->IOsActive,
                                        (CThread->FuncPtrs.GetIMQProdIndex(hpRoot) - CThread->HostCopy_IMQConsIndex),
                                        CThread->thread_hdr.currentState,
                                        CThread->IOsActive_No_ProgressCount,
                                        0,0,0,0);

                        if( CThread->IOsActive_No_ProgressCount > MAX_NO_PROGRESS_DETECTS )
                        {
                            CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
                            CThread->LinkDownTime = CThread->TimeBase;
                        }
                    }
                }
            }
        }
        else
        {
            CThread->IOsActive_No_ProgressCount = 0;
        }
    }

    /* Invoke normal TimerTick processing to increment time base and deliver expired timer events */

    fiTimerTick(
                 hpRoot,
                 CThread->Calculation.Input.usecsPerTick
               );

    /* Check to see if Interrupt Delay mechanism needs adjustment */

    if((CThread->FuncPtrs.GetIMQProdIndex(hpRoot) - CThread->HostCopy_IMQConsIndex) > 2)
    {
/*
        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "CThread->HostCopy_IMQConsIndex %03X != %03X %X Ints %08X",
                        (char *)agNULL,(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread->HostCopy_IMQConsIndex,
                        CThread->FuncPtrs.GetIMQProdIndex(hpRoot),
                        (CThread->FuncPtrs.GetIMQProdIndex(hpRoot) - CThread->HostCopy_IMQConsIndex),
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                        0,0,0,0);
*/
#ifdef USE_XL_Delay_Register
                /* If XL DelayTimer */
/*              This chnage masks the interrupt delay problem !
                CThread->FuncPtrs.Proccess_IMQ(hpRoot); 

*/
#endif /* USE_XL_Delay_Register */
#ifndef Performance_Debug
#endif /* Performance_Debug */

    }

    if (CThread->InterruptsDelayed == agFALSE)
    {
        /* Interrupts are currently not delayed - do they need to be? */

        if (    (    ( IntDelayRateMethod == MemMap_RateMethod_IOsStarted       )
                  && ( IntDelayOnIORate   <= IOsStartedThisTimerTick            ) )
             || (    ( IntDelayRateMethod == MemMap_RateMethod_IOsCompleted     )
                  && ( IntDelayOnIORate   <= IOsCompletedThisTimerTick          ) )
             || (    ( IntDelayRateMethod == MemMap_RateMethod_IOsIntCompleted  )
                  && ( IntDelayOnIORate   >= IOsIntCompletedThisTimerTick       ) )
             || (    ( IntDelayRateMethod == MemMap_RateMethod_IOsPollCompleted )
                  && ( IntDelayOnIORate   <= IOsPollCompletedThisTimerTick      ) )
             || (    ( IntDelayRateMethod == MemMap_RateMethod_IOsActive        )
                  && ( IntDelayOnIORate   <= IOsActive                          ) ) )
        {
            /* Start delaying interrupts */

            CThread->InterruptsDelayed = agTRUE;
            CFuncInteruptDelay(hpRoot, agTRUE);
        }
    }
    else /* CThread->InterruptsDelayed == agTRUE */
    {
        /* Interrupts are currently delayed - do they still need to be? */

        if (    (    ( IntDelayRateMethod == MemMap_RateMethod_IOsStarted       )
                  && ( IntDelayOffIORate  >= IOsStartedThisTimerTick            ) )
             || (    ( IntDelayRateMethod == MemMap_RateMethod_IOsCompleted     )
                  && ( IntDelayOffIORate  >= IOsCompletedThisTimerTick          ) )
             || (    ( IntDelayRateMethod == MemMap_RateMethod_IOsIntCompleted  )
                  && ( IntDelayOffIORate  <= IOsIntCompletedThisTimerTick       ) )
             || (    ( IntDelayRateMethod == MemMap_RateMethod_IOsPollCompleted )
                  && ( IntDelayOffIORate  >= IOsPollCompletedThisTimerTick      ) )
             || (    ( IntDelayRateMethod == MemMap_RateMethod_IOsActive        )
                  && ( IntDelayOffIORate  >= IOsActive                          ) ) )
        {
            /* Stop delaying interrupts */

            CThread->InterruptsDelayed = agFALSE;

            /* If XL DelayTimer CThread->FuncPtrs.Proccess_IMQ(hpRoot);*/

           CFuncInteruptDelay(hpRoot, agFALSE);
#ifdef USE_XL_Delay_Register
            /* If XL DelayTimer */
            CThread->FuncPtrs.Proccess_IMQ(hpRoot); /* IO Path */
#endif /* USE_XL_Delay_Register */

        }
    }

    CThread->Elastic_Store_ERROR_Count     = 0;
    CThread->Lip_F7_In_tick                = 0;
    CThread->Link_Failures_In_tick         = 0;
    CThread->Lost_Signal_In_tick           = 0;

    CThread->Node_By_Passed_In_tick        = 0;
    CThread->Lost_sync_In_tick             = 0;
    CThread->Transmit_PE_In_tick           = 0;
    CThread->Link_Fault_In_tick            = 0;

    CThread->Loop_State_TimeOut_In_tick    = 0;
    
    Link_Status_Counts =  osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Link_Status_1 );
    if(Link_Status_Counts )
    {
        Link_Status_counts_Change = agTRUE;
        fiLogDebugString(hpRoot,
                        FCMainLogConsoleLevel,
                        "%s %08x FMStatus %08x",
                        "Link_Status_1",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Link_Status_Counts,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        0,0,0,0,0,0);

        if(CThread->ChanInfo.LossOfSignalCountLower    \
            + ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Signal_AdjustToChar(Link_Status_Counts) \
            < CThread->ChanInfo.LossOfSignalCountLower )
        {
            CThread->ChanInfo.LossOfSignalCountUpper ++;
        }
        CThread->ChanInfo.LossOfSignalCountLower += ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Signal_AdjustToChar(Link_Status_Counts);

        if(CThread->ChanInfo.InvalidRxWordCountUpper    \
            + ChipIOUp_Frame_Manager_Link_Status_1_Bad_RX_Char_AdjustToChar(Link_Status_Counts) \
            < CThread->ChanInfo.InvalidRxWordCountUpper )
        {
            CThread->ChanInfo.InvalidRxWordCountUpper ++;
        }
        CThread->ChanInfo.InvalidRxWordCountLower += ChipIOUp_Frame_Manager_Link_Status_1_Bad_RX_Char_AdjustToChar(Link_Status_Counts);

        if(CThread->ChanInfo.LossOfSyncCountLower    \
            + ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Sync_AdjustToChar(Link_Status_Counts) \
            < CThread->ChanInfo.LossOfSyncCountLower )
        {
            CThread->ChanInfo.LossOfSyncCountUpper ++;
        }
        CThread->ChanInfo.LossOfSyncCountLower += ChipIOUp_Frame_Manager_Link_Status_1_Loss_of_Sync_AdjustToChar(Link_Status_Counts);


        if(CThread->ChanInfo.LinkFailureCountLower    \
            + ChipIOUp_Frame_Manager_Link_Status_1_Link_Fail_AdjustToChar(Link_Status_Counts) \
            < CThread->ChanInfo.LinkFailureCountLower )
        {
            CThread->ChanInfo.LinkFailureCountUpper ++;
        }
        CThread->ChanInfo.LinkFailureCountLower += ChipIOUp_Frame_Manager_Link_Status_1_Link_Fail_AdjustToChar(Link_Status_Counts);
    }

    Link_Status_Counts =  osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Link_Status_2 );

    if(Link_Status_Counts )
    {
        Link_Status_counts_Change = agTRUE;
        fiLogDebugString(hpRoot,
                        FCMainLogConsoleLevel,
                        "%%s %08x FMStatus %08x",
                        "Link_Status_2",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Link_Status_Counts,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        0,0,0,0,0,0);
        if(CThread->ChanInfo.ErrorFramesLower    \
            + ChipIOUp_Frame_Manager_Link_Status_2_Rx_EOFa_AdjustToChar(Link_Status_Counts) \
            < CThread->ChanInfo.ErrorFramesLower )
        {
            CThread->ChanInfo.ErrorFramesUpper ++;
        }
        CThread->ChanInfo.ErrorFramesLower += ChipIOUp_Frame_Manager_Link_Status_2_Rx_EOFa_AdjustToChar(Link_Status_Counts);

        if(CThread->ChanInfo.DumpedFramesLower    \
            + ChipIOUp_Frame_Manager_Link_Status_2_Dis_Frm_AdjustToChar(Link_Status_Counts) \
            < CThread->ChanInfo.DumpedFramesLower )
        {
            CThread->ChanInfo.DumpedFramesUpper ++;
        }
        CThread->ChanInfo.DumpedFramesLower += ChipIOUp_Frame_Manager_Link_Status_2_Dis_Frm_AdjustToChar(Link_Status_Counts);

        if(CThread->ChanInfo.InvalidCRCCountLower    \
            + ChipIOUp_Frame_Manager_Link_Status_2_Bad_CRC_AdjustToChar(Link_Status_Counts) \
            < CThread->ChanInfo.InvalidCRCCountLower )
        {
            CThread->ChanInfo.InvalidCRCCountUpper ++;
        }
        CThread->ChanInfo.InvalidCRCCountLower += ChipIOUp_Frame_Manager_Link_Status_2_Bad_CRC_AdjustToChar(Link_Status_Counts);

        if(CThread->ChanInfo.PrimitiveSeqProtocolErrCountLower    \
            + ChipIOUp_Frame_Manager_Link_Status_2_Proto_Err_AdjustToChar(Link_Status_Counts) \
            < CThread->ChanInfo.PrimitiveSeqProtocolErrCountLower )
        {
            CThread->ChanInfo.PrimitiveSeqProtocolErrCountUpper ++;
        }
        CThread->ChanInfo.PrimitiveSeqProtocolErrCountLower += ChipIOUp_Frame_Manager_Link_Status_2_Proto_Err_AdjustToChar(Link_Status_Counts);
    }


#ifdef __TACHYON_XL2
    Link_Status_Counts =  osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Link_Status_3 );

    if(Link_Status_Counts )
    {
        Link_Status_counts_Change = agTRUE;
        fiLogDebugString(hpRoot,
                        FCMainLogConsoleLevel,
                        "%s %08x FMStatus %08x",
                        "Link_Status_3",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        Link_Status_Counts,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        0,0,0,0,0,0);
        if(CThread->ChanInfo.ErrorFramesLower    \
            + ChipIOUp_Frame_Manager_Link_Status_3_Exp_Frm_AdjustToChar(Link_Status_Counts) \
            < CThread->ChanInfo.ErrorFramesLower )
        {
            CThread->ChanInfo.ErrorFramesUpper ++;
        }
        CThread->ChanInfo.ErrorFramesLower += ChipIOUp_Frame_Manager_Link_Status_3_Exp_Frm_AdjustToChar(Link_Status_Counts);
    }

#endif	/* __TACHYON_XL2 */																	

    if( Link_Status_counts_Change &&  CThread->thread_hdr.currentState == CStateNormal )
    {
        fiLogDebugString(hpRoot,
                        FCMainLogConsoleLevel,
                        "%p %s FMStatus %08x",
                        "Link_Detect",(char *)agNULL,
                        hpRoot,(void *)agNULL,
                        osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                        0,0,0,0,0,0,0);

        CFuncShowActiveCDBThreads( hpRoot,ShowERQ);
        CThread->LinkDownTime = CThread->TimeBase;
    }

    /* If nothing is going on, send watchdog frame to ourselves */

    if (CThread->IOsStartedThisTimerTick == 0 )
    {

        if( CThread->thread_hdr.currentState == CStateNormal )
        {

            if( CThread->DeviceSelf->In_Verify_ALPA_FLAG == agFALSE)
            {

                if ( CThread->DeviceDiscoveryMethod != DDiscoveryQueriedNameService)
                {

                    if ( ! CThread->InitAsNport)
                    {

#ifndef SkipHeartBeat
                        if(CThread->Calculation.Parameters.HeartBeat)
                        {
                            fiSendEvent(&CThread->DeviceSelf->thread_hdr,DevEventDoTickVerifyALPA);
                        }
#endif  /* SkipHeartBeat */
                    }
                }
            }
        }
        else
        {
            fiLogDebugString(hpRoot,
                            FCMainLogConsoleLevel,
                            "FcTimerTick  Not CStateNormal %d FM Status %08X TL Status %08X ",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            CThread->thread_hdr.currentState,
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_Frame_Manager_Status ),
                            osChipIOUpReadBit32(hpRoot, ChipIOUp_TachLite_Status ),
                            0,0,0,0,0);

        }
    }
    else
    {
#ifndef Performance_Debug
        fiLogDebugString(hpRoot,
                            FCMainLogConsoleLevel,
                            "%d Start %d Complete %d Int Complete %d Polled %d Active %d",
                            (char *)agNULL,(char *)agNULL,
                            (void *)agNULL,(void *)agNULL,
                            CThread->InterruptsDelayed,
                            CThread->IOsStartedThisTimerTick,
                            CThread->IOsCompletedThisTimerTick,
                            CThread->IOsIntCompletedThisTimerTick,
                            CThread->IOsCompletedThisTimerTick - CThread->IOsIntCompletedThisTimerTick,
                            CThread->IOsActive,
                            0,0);
#endif /* Performance_Debug */

    }

    /* Reset IO/Tick Counters */

    CThread->IOsStartedThisTimerTick      = 0;
    CThread->IOsCompletedThisTimerTick    = 0;
    CThread->IOsIntCompletedThisTimerTick = 0;
    CThread->IOsActive_LastTick           = CThread->IOsActive;

    /* Just in case, Reset Channel if previously postponed
       (this should no longer be needed here but it can't hurt) */

    if( (event_to_send = CFuncCheckCstate(hpRoot)) != 0)
    {
        fiSendEvent(&(CThread->thread_hdr),event_to_send);
    }

    if( CThread->thread_hdr.currentState == CStateNormal || (CThread->thread_hdr.currentState == CStateRSCNErrorBackIOs ))
    {
        /* If XL DelayTimer CThread->FuncPtrs.Proccess_IMQ(hpRoot);*/ /* IO Path */

        if( CThread->thread_hdr.currentState == CStateNormal )
        {
            if(CFuncCheckForTimeouts(hpRoot, &CThread->Active_DevLink))
            {
                CFuncShowNonEmptyLists(hpRoot, &CThread->Active_DevLink);
#ifdef USE_XL_Delay_Register
                /* If XL DelayTimer */
                CThread->FuncPtrs.Proccess_IMQ(hpRoot); 
#endif /* USE_XL_Delay_Register */

                fiLogDebugString(hpRoot,
                                FCMainLogErrorLevel,
                                "%s %s IMQ %X %X Ints %08X Active %d",
                                "CFCFT","CAN",
                                (void *)agNULL,(void *)agNULL,
                                CThread->FuncPtrs.GetIMQProdIndex(hpRoot),
                                CThread->HostCopy_IMQConsIndex,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                                CThread->IOsActive,0,0,0,0);
            }
            
        }

        if( CThread->thread_hdr.currentState == CStateRSCNErrorBackIOs )
        {

            if(CFuncCheckForTimeouts(hpRoot, &CThread->Active_DevLink))
            {
                CFuncShowNonEmptyLists(hpRoot, &CThread->Active_DevLink);
                fiLogDebugString(hpRoot,
                                FCMainLogErrorLevel,
                                "%s %s IMQ %X %X Ints %08X",
                                "CFuncCheckForTimeouts","CStateRSCNErrorBackIOs",
                                (void *)agNULL,(void *)agNULL,
                                CThread->FuncPtrs.GetIMQProdIndex(hpRoot),
                                CThread->HostCopy_IMQConsIndex,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                                0,0,0,0,0);
            }
            if(CFuncCheckForTimeouts(hpRoot, &CThread->Prev_Active_DevLink))
            {
                fiLogDebugString(hpRoot,
                                FCMainLogErrorLevel,
                                "%s %s IMQ %X %X Ints %08X",
                                "CFuncCheckForTimeouts","CStateRSCNErrorBackIOs",
                                (void *)agNULL,(void *)agNULL,
                                CThread->FuncPtrs.GetIMQProdIndex(hpRoot),
                                CThread->HostCopy_IMQConsIndex,
                                osChipIOUpReadBit32(hpRoot, ChipIOUp_INTSTAT_INTEN_INTPEND_SOFTRST ),
                                0,0,0,0,0);
            }
            
        }

       /* fiLogString(hpRoot,
                    "%s %s %d",
                    "fcTimerTick","CFuncCheckForTimeouts",
                    (void *)agNULL,(void *)agNULL,
                    CThread->thread_hdr.currentState,
                    0,0,0,0,0,0,0);
       */

    }
    else
    {
#ifdef _SANMARK_LIP_BACKOFF
        if( !fiListElementOnList( (fiList_t *)(&(CThread->Timer_Request)), &(CThread->TimerQ)))
            {
                switch(CThread->TicksTillLIP_Count)
                {

                    case 0:
                        CThread->TicksTillLIP_Count++;
                        break;
                    case 1:
                        CThread->TicksTillLIP_Count++;
                        fiTimerSetDeadlineFromNow(hpRoot, &CThread->Timer_Request, 2000000);

                        CThread->Timer_Request.eventRecord_to_send.thread= &CThread->thread_hdr;

                        CThread->Timer_Request.eventRecord_to_send.event = CEventDoInitalize;

                        fiTimerStart(hpRoot,&CThread->Timer_Request);
                        break;
                    case 2:
                        CThread->TicksTillLIP_Count++;
                        fiTimerSetDeadlineFromNow(hpRoot, &CThread->Timer_Request, 2000000 * 6);

                        CThread->Timer_Request.eventRecord_to_send.thread= &CThread->thread_hdr;

                        CThread->Timer_Request.eventRecord_to_send.event = CEventDoInitalize;

                        fiTimerStart(hpRoot,&CThread->Timer_Request);
                        break;
                    case 3:
                        CThread->TicksTillLIP_Count++;
                        fiTimerSetDeadlineFromNow(hpRoot, &CThread->Timer_Request, 2000000 * 12);

                        CThread->Timer_Request.eventRecord_to_send.thread= &CThread->thread_hdr;

                        CThread->Timer_Request.eventRecord_to_send.event = CEventDoInitalize;

                        fiTimerStart(hpRoot,&CThread->Timer_Request);
                        break;

                    default:
                        CThread->TicksTillLIP_Count = 0;

            }

        }

#endif /* _SANMARK_LIP_BACKOFF */ 

        fiLogDebugString(hpRoot,
                        FCMainLogErrorLevel,
                        "Exit %s %X %08X CState %d",
                        "fcTimerTick",(char *)agNULL,
                        (void *)agNULL,(void *)agNULL,
                        CThread->TimeBase.Hi,
                        CThread->TimeBase.Lo,
                        CThread->thread_hdr.currentState,
                        0,0,0,0,0);
    }

    fiSingleThreadedLeave(hpRoot, fdTimerTick );

    return;
}


/*+
  Function: fcmain_c
   Purpose: When compiled updates browser info file for VC 5.0 / 6.0
   Returns: none
 Called By: none
     Calls: none
-*/
/* void fcmain_c(void){}  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\fcciimpl.h ===
/*++

Copyright (c) 2000 Agilent Technologies

Module Name:

   fcciimpl.c

Abstract:

Authors:

Environment:

   kernel mode only

Notes:

Version Control Information:

   $Archive: /Drivers/Win2000/Trunk/OSLayer/H/fcciimpl.h $


Revision History:

   $Revision: 3 $
   $Date: 9/07/00 11:55a $
   $Modtime:: 9/07/00 11:54a           $

Notes:


--*/

#ifndef _FCCI_IMPL_H 
#define _FCCI_IMPL_H

#include "hhba5100.ver"

#define PORT_COUNT 1
#define PRODUCT_NAME  L"HHBA5100"
#define MODEL_NAME    L"HHBA5100"
#define SERIAL_NUMBER L"HHBA5100"
#define FCCI_MAX_BUS  8
#if _WIN32_WINNT >= 0x500
  #define FCCI_MAX_TGT  128
#else
  #define FCCI_MAX_TGT  32
#endif
#define FCCI_MAX_LUN  256

typedef struct _AGILENT_IMP_FCCI_DRIVER_INFO_OUT 
{
   // lengths of each character field (number of WCHARs)
   USHORT    DriverNameLength;
   USHORT    DriverDescriptionLength;
   USHORT    DriverVersionLength;
   USHORT    DriverVendorLength;

   // character fields (lengths just previous) follow in this order
   WCHAR          DriverName[(sizeof(LDRIVER_NAME) / sizeof(WCHAR))];
   WCHAR          DriverDescription[(sizeof(LDRIVER_DESCRIPTION) / sizeof(WCHAR))];
   WCHAR          DriverVersion[(sizeof(LDRIVER_VERSION_STR) / sizeof(WCHAR))] ;
   WCHAR          DriverVendor[(sizeof(LVER_COMPANYNAME_STR) / sizeof(WCHAR))];
} AFCCI_DRIVER_INFO_OUT, *PAFCCI_DRIVER_INFO_OUT;

typedef union _AGILENT_IMP_FCCI_DRIVER_INFO 
{       
   // no inbound data
   AFCCI_DRIVER_INFO_OUT    out;
} AFCCI_DRIVER_INFO, *PAFCCI_DRIVER_INFO;

/*----- FCCI_SRBCTL_GET_ADAPTER_INFO - data structures and defines -----------*/
typedef struct _AGILENT_IMP_FCCI_ADAPTER_INFO_OUT 
{
   ULONG     PortCount;               // How many ports on adapter?
                                      // The number should reflect the number of
                                      // ports this "miniport" device object controls
                                      // not necessarily the true number of
                                      // of ports on the adapter.

   ULONG     BusCount;           // How many virtual buses on adapter?
   ULONG     TargetsPerBus;      // How many targets supported per bus?
   ULONG     LunsPerTarget;      // How many LUNs supported per target?

   // lengths of each character field (number of WCHARs)
   USHORT    VendorNameLength;
   USHORT    ProductNameLength;
   USHORT    ModelNameLength;
   USHORT    SerialNumberLength;

   // character fields (lengths just previous) follow in this order
   WCHAR          VendorName[sizeof(LVER_COMPANYNAME_STR) / sizeof(WCHAR)];
   WCHAR          ProductName[sizeof(PRODUCT_NAME) / sizeof(WCHAR)];
   WCHAR          ModelName[sizeof(MODEL_NAME) / sizeof(WCHAR)];
   WCHAR          SerialNumber[sizeof(SERIAL_NUMBER) / sizeof(WCHAR)];
} AFCCI_ADAPTER_INFO_OUT, *PAFCCI_ADAPTER_INFO_OUT;


// !!! IMPORTANT !!!
// If the supplied buffer is not large enough to hold the variable length data
// fill in the non variable length fields and return the request
// with a ResultCode of FCCI_RESULT_INSUFFICIENT_BUFFER.

typedef union _AGILENT_IMP_FCCI_ADAPTER_INFO 
{       
   // no inbound data
   AFCCI_ADAPTER_INFO_OUT   out;
} AFCCI_ADAPTER_INFO, *PAFCCI_ADAPTER_INFO;

typedef struct _AGILENT_IMP_FCCI_DEVICE_INFO_OUT
{
   ULONG     TotalDevices;       // set to total number of device the adapter
                                      // knows of.

   ULONG     OutListEntryCount;  // set to number of device entries being 
                                      // returned in list (see comment below).

   FCCI_DEVICE_INFO_ENTRY  entryList[NUMBER_OF_BUSES * MAXIMUM_TID];
} AFCCI_DEVICE_INFO_OUT, *PAFCCI_DEVICE_INFO_OUT;

typedef union _AGILENT_IMPL_FCCI_DEVICE_INFO
{       
   // no inbound data
   AFCCI_DEVICE_INFO_OUT    out;
} AFCCI_DEVICE_INFO, *PAFCCI_DEVICE_INFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\fcmain.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/FCMain.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 10/30/00 6:39p  $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/FCMain.C

--*/

#ifndef __FCMain_H__
#define __FCMain_H__
#define NPORT_STUFF
#define NAME_SERVICES

/* #define USE_XL_Delay_Register */

/* #define  _BYPASSLOOPMAP */


/* #define BROCADE_BUG */
/* #define ONLY_UNTIL_DEVTHREADS_INITIALIZE */
/*+
FC Layer Main Logging Levels
-*/
#define FCMainLogErrorLevel                  0x00000002
#define CFuncLogConsoleERROR                 0x00000004

#ifdef _DvrArch_1_30_
#define IPStateLogErrorLevel                 0x00000005
#define PktStateLogErrorLevel                0x00000005
#endif /* _DvrArch_1_30_ was defined */

#define SFStateLogErrorLevel                 0x00000005
#define TgtStateLogErrorLevel                0x00000005
#define CStateLogConsoleERROR                0x00000005
#define TimerServiceLogErrorLevel            0x00000005
#define QueueLogConsoleERRORLevel            0x00000006
#define CDBStateLogErrorLevel                0x00000007
#define DevStateLogErrorLevel                0x00000007
#define LinkSvcLog_ERROR_Level               0x00000009

#define SF_FCP_LogConsoleLevel               0x00000009

#define CStateLogConsoleShowSEST             0x00000019

#define CStateLogConsoleHideInboundErrors    0x00000009
#define CStateLogConsoleLevelLip             0x00000009

#define LinkSvcLogConsoleLevel               0x00000009

#define LinkSvcLogTraceLevel                 0x00000009

#define CTLogConsoleLevelInfo                0x00000009
#define CTLogConsoleLevel                    0x00000009
#define CTLogTraceLevel                      0x00000009

#define SFStateLogConsoleLevelOne            0x0000000C

#define CStateLogConsoleErrorOverRun         0x0000000C
#define CStateLogConsoleLevelHi              0x0000000C
#define CStateLogConsoleLevelLo              0x0000000E
#define CStateLogConsoleLevel                0x0000000F
#define FCMainLogConsoleLevel                0x00000010
#define FCMainLogConsoleCardSupported        0x00000005
#define CFuncCheckCstateErrorLevel           0x0000000A
#define FlashSvcLogConsoleLevel              0x00000007
#define FlashSvcLogTraceLevel                0x00000007
#define CFuncLogConsolePLOGIPAYLOAD          0x00000017

#define CDBStateAbortPathLevel               0x00000017
#define CDBStateCCC_IOPathLevel              0x00000007

#define MemMapDumpCalculationLogConsoleLevel 0x0000001B
#define TimerServiceLogInfoLevel             0x00000014
#define CDBStateLogOtherErrorLevel           0x00000017

#define SFStateLogConsoleLevel               0x0000001E
#ifdef _DvrArch_1_30_
#define IPStateLogConsoleLevel               0x00000009
#define PktStateLogConsoleLevel              0x00000009
#endif /* _DvrArch_1_30_ was defined */

#define TgtStateLogConsoleLevel              0x00000009

#define DevStateLogConsoleLevel              0x00000020
#define CDBStateLogConsoleLevel              0x00000025
#define QueueLogConsoleLevel                 0x00000026
#define TimerServiceLogConsoleLevel          0x00000190
#define CFuncLogConsoleDefaultLevel          0x00000190

#define QueueLogTraceLevel                   0x00000100

#define StateLogTraceLevel                   0x00000101
#define SF_FCP_LogTraceLevel                 0x00000100
#define LinkSvcLogTraceHideLevel             0x00000109


#define FCMainLogTraceLevel                  0x00000115
#define MemMapDumpCalculationLogTraceLevel   0x00000100

/*+
Useful macros
-*/

#define NEXT_INDEX(index, end)    ((index+1) & (end-1))

#define ERQ_FULL(prodIndex, conIndex, ERQ_LEN) \
                (NEXT_INDEX(prodIndex, ERQ_LEN) == conIndex) ? agTRUE : agFALSE

#define ONE_SECOND (200 * 1000 ) /* During a one microsecond  loop  one second takes 200,000 iterations */

#define Init_FM_Delay_Count (ONE_SECOND * 2)
#define Init_FM_NPORT_Delay_Count (ONE_SECOND * 10)

#define MAX_NO_PROGRESS_DETECTS                 5

#define MAX_PLOGI_TIMEOUTS                      10
#define MAX_FLOGI_TIMEOUTS                      2
#define MAX_FLOGI_RETRYS                        3
#define MAX_fcInitializeChannel_RETRYS          30

#define FC_MAX_RESET_RETRYS                     1
#define FC_MAX_PRLI_REJECT_RETRY                5

#define FC_MAX_ELASTIC_STORE_ERRORS_ALLOWED     90
#define FC_MAX_LIP_F7_ALLOWED                   80
#define FC_MAX_LOST_SIGNALS_ALLOWED             20
#define FC_MAX_LINK_FAILURES_ALLOWED            20
#define FC_MAX_NODE_BY_PASSED_ALLOWED           20
#define FC_MAX_LOSE_OF_SYNC_ALLOWED             20

#define FC_MAX_TRANSMIT_PE_ALLOWED             20
#define FC_MAX_LINK_FAULTS_ALLOWED             20
#define FC_MAX_LST_ALLOWED                     0
#define FRAMEMGR_LINK_DOWN  ( ChipIOUp_Frame_Manager_Status_OS | ChipIOUp_Frame_Manager_Status_LS )
 
#define FRAMEMGR_NPORT_OK ( ChipIOUp_Frame_Manager_Status_LSM_Old_Port | ChipIOUp_Frame_Manager_Status_PSM_ACTIVE )
#define FRAMEMGR_NPORT_LINK_FAIL ( ChipIOUp_Frame_Manager_Status_LSM_Old_Port | ChipIOUp_Frame_Manager_Status_PSM_LF2 | ChipIOUp_Frame_Manager_Status_OS )

#define FRAMEMGR_NPORT_NO_CABLE ( ChipIOUp_Frame_Manager_Status_LSM_Old_Port | ChipIOUp_Frame_Manager_Status_PSM_Offline )

#define BB_CREDIT_SHIFTED( BB_CREDIT) (BB_CREDIT <<  ChipIOUp_Frame_Manager_Configuration_BB_Credit_SHIFT)

/*+
Forward Typedef's
-*/

typedef struct SFThread_s
               SFThread_t;

typedef struct CDBThread_s
               CDBThread_t;

typedef struct DevThread_s
               DevThread_t;

typedef struct TgtThread_s
               TgtThread_t;

#ifdef _DvrArch_1_30_

typedef struct IPThread_s
               IPThread_t;

typedef struct PktThread_s
               PktThread_t;

#endif /* _DvrArch_1_30_ was defined */

typedef struct CThread_s
               CThread_t;

/*+
Linked List Structure Declaration
-*/

typedef struct fiList_s
               fiList_t;

struct fiList_s {
                  fiList_t *flink;
                  fiList_t *blink;
                };
/*+
agTimeOutValue_t Type Declaration
-*/

typedef struct agTimeOutValue_s
               agTimeOutValue_t;

struct agTimeOutValue_s {
                            os_bit32 RT_Tov;
                            os_bit32 ED_Tov;
                            os_bit32 LP_Tov;
                            os_bit32 AL_Time;
                        };


/*+
SFThread Request Type Declaration
-*/

enum SFThread_Request_State_e
     {
       SFThread_Request_InActive,
       SFThread_Request_Pending,
       SFThread_Request_Granted
     };

typedef enum SFThread_Request_State_e
             SFThread_Request_State_t;

typedef struct SFThread_Request_s
               SFThread_Request_t;

struct SFThread_Request_s {
                            fiList_t                  SFThread_Wait_Link;
                            eventRecord_t             eventRecord_to_send;
                            SFThread_t               *SFThread;
                            SFThread_Request_State_t  State;
                          };

/*+
ESGL Request Type Declaration
-*/

enum ESGL_State_e
     {
       ESGL_Request_InActive,
       ESGL_Request_Pending,
       ESGL_Request_Granted
     };

typedef enum ESGL_State_e
             ESGL_State_t;

typedef struct ESGL_Request_s
               ESGL_Request_t;

struct ESGL_Request_s {
                        fiList_t      ESGL_Wait_Link;
                        eventRecord_t eventRecord_to_send;
                        os_bit32      num_ESGL;
                        os_bit32      offsetToFirst;
                        ESGL_State_t  State;
                      };

/*+
Timer Request Type Declaration
-*/

typedef struct fiTime_s
               fiTime_t;

struct fiTime_s {
                  os_bit32 Lo;
                  os_bit32 Hi;
                };

typedef struct fiTimer_Request_s
               fiTimer_Request_t;

struct fiTimer_Request_s {
                           fiList_t      TimerQ_Link;
                           eventRecord_t eventRecord_to_send;
                           fiTime_t      Deadline;
                           agBOOLEAN       Active;
                         };

/*-
Device Slot (Position in Device Handle Array) Type Declaration
-*/

typedef os_bit32 DevSlot_t;

#define DevSlot_Invalid 0xFFFFFFFF

/*-
Device Slot to WWN Mapping Type Declaration
-*/

typedef struct SlotWWN_s
               SlotWWN_t;

struct SlotWWN_s {
                   os_bit8        Slot_Status;
                   os_bit8        Slot_Domain_Address;
                   os_bit8        Slot_Area_Address;
                   os_bit8        Slot_Loop_Address;
                   FC_Port_Name_t Slot_PortWWN;
                 };

#define SlotWWN_Slot_Status_Empty 0
#define SlotWWN_Slot_Status_InUse 1
#define SlotWWN_Slot_Status_Stale 2

/*+
Thread Type Declaration
-*/

#define threadType_SFThread  1
#define threadType_CDBThread 2
#define threadType_DevThread 3
#define threadType_TgtThread 4
#define threadType_CThread   5
#ifdef _DvrArch_1_30_
#define threadType_IPThread  6
#define threadType_PktThread 7
#endif /* _DvrArch_1_30_ was defined */



/*+
SF Thread Structure Declaration
-*/


#define SFThread_SF_CMND_Class_NULL             0x00
#define SFThread_SF_CMND_Class_LinkSvc          0x01
#define SFThread_SF_CMND_Class_SF_FCP           0x02
#define SFThread_SF_CMND_Class_CDB_FCP          0x03
#define SFThread_SF_CMND_Class_CT               0x04
#define SFThread_SF_CMND_Class_FC_Tape          0x05

/* SF ELS types are 0x01 to 0x11 */
#define SFThread_SF_CMND_Type_NULL              0x00
#define SFThread_SF_CMND_Type_CDB               0x81
#define SFThread_SF_CMND_Type_CDB_FC_Tape       0x82

#define SFThread_SF_CMND_State_NULL                     0x00
#define SFThread_SF_CMND_State_CDB_FC_Tape_AllocREC     0x05
#define SFThread_SF_CMND_State_CDB_FC_Tape_REC          0x06
#define SFThread_SF_CMND_State_CDB_FC_Tape_REC2         0x07
#define SFThread_SF_CMND_State_CDB_FC_Tape_SRR          0x08
#define SFThread_SF_CMND_State_CDB_FC_Tape_SRR2         0x09
#define SFThread_SF_CMND_State_CDB_FC_Tape_ReSend       0x0a
#define SFThread_SF_CMND_State_CDB_FC_Tape_GotXRDY      0x0b

#define SFThread_SF_CMND_Status_NULL                        0x00
#define SFThread_SF_CMND_Status_CDB_FC_TapeTargetReSendData 0x11
#define SFThread_SF_CMND_Status_CDB_FC_TapeSRR_Success      0x12
#define SFThread_SF_CMND_Status_CDB_FC_TapeGet_Data         0x13
#define SFThread_SF_CMND_Status_CDB_FC_TapeGet_RSP          0x14
#define SFThread_SF_CMND_Status_CDB_FC_TapeInitiatorReSend_Data        0x15

struct SFThread_s {
                    fi_thread__t                     thread_hdr;
                    fiList_t                         SFLink;
                    union    {
                               fi_thread__t    *unknown;
#ifdef _DvrArch_1_30_
                               PktThread_t *IPPkt;
#endif /* _DvrArch_1_30_ was defined */
                               CDBThread_t *CDB;
                               DevThread_t *Device;
                               TgtThread_t *Target;
                               CThread_t   *Channel;
                             }                       parent;
                    X_ID_t                           X_ID;
                    FCHS_t                          *SF_CMND_Ptr;
                    os_bit32                            SF_CMND_Offset;
                    os_bit32                            SF_CMND_Lower32;
                    os_bit8                             SF_CMND_Class;
                    os_bit8                             SF_CMND_Type;
                    os_bit8                             SF_CMND_State;
                    os_bit8                             SF_CMND_Status;
                    fiTimer_Request_t                Timer_Request;
                    event_t                          QueuedEvent;
                    os_bit8                             SF_REJ_RETRY_COUNT;
                    os_bit8                             RejectReasonCode;
                    os_bit8                             RejectExplanation;

                  };

/*+
CDB Thread Structure Declaration
-*/

#define CDBThread_Read  0
#define CDBThread_Write 1

struct CDBThread_s {
                    fi_thread__t         thread_hdr;
                    fiList_t             CDBLink;
                    DevThread_t        * Device;
                    X_ID_t               X_ID;
                    FCHS_t             * FCP_CMND_Ptr;
                    os_bit32             FCP_CMND_Offset;
                    os_bit32             FCP_CMND_Lower32;
                    os_bit8              CDB_CMND_Class;
                    os_bit8              CDB_CMND_Type;
                    os_bit8              CDB_CMND_State;
                    os_bit8              CDB_CMND_Status;
                    agBOOLEAN            Active; /* Maintain Alignment of structure above these fields with SFThread */
                    agBOOLEAN            ExchActive;
                    agIORequest_t      * hpIORequest;
                    agCDBRequest_t     * CDBRequest;
                    os_bit32             ReadWrite;
                    os_bit32             DataLength;
                    os_bit32             TimeStamp;

                    agBOOLEAN            ReSentIO;
                    agBOOLEAN            ActiveDuringLinkEvent;
                    os_bit32             SentERQ;
                    agBOOLEAN            FC_Tape_Active;
                    os_bit32             FC_Tape_RXID;
                    os_bit32             FC_Tape_HBA_Has_SequenceInitiative;
                    os_bit32             FC_Tape_Last_Count;
                    os_bit32             FC_Tape_REC_Reject_Count;
                    os_bit32             FC_Tape_ExchangeStatusBlock;
                    os_bit32             FC_Tape_CompletionStatus;

                    fiTime_t             CDBStartTimeBase;
                    os_bit32             Lun;
                    os_bit32             CCC_pollingCount;
                    os_bit32             CompletionStatus;
                    SEST_t             * SEST_Ptr;
                    os_bit32             SEST_Offset;
                    FCHS_t             * FCP_RESP_Ptr;
                    os_bit32             FCP_RESP_Offset;
                    os_bit32             FCP_RESP_Lower32;
                    ESGL_Request_t       ESGL_Request;
                    fiList_t             ESGL_Wait_Link;
                    fiTimer_Request_t    Timer_Request;
                    SFThread_Request_t   SFThread_Request;
                    os_bit32             SG_Cache_Offset;
                    os_bit32             SG_Cache_Used;
                    SG_Element_t         SG_Cache[MemMap_SizeCachedSGLs_MIN];
                   };

#define CDBThread_ptr(hpIORequest) ((CDBThread_t *)((hpIORequest)->fcData))

/*+
Device Thread Structure Declaration
-*/

#ifdef Device_IO_Throttle

#define Device_IO_Throttle_Increment pDevThread->DevActive_pollingCount++;
#define Device_IO_Throttle_Initialize pDevThread->DevActive_pollingCount=0;
#define Device_IO_Throttle_Decrement pDevThread->DevActive_pollingCount--;
#define Device_IO_Throttle_Declareation  os_bit32 DevActive_pollingCount;
#define Device_IO_Throttle_MAX_Outstanding_IO       1

#else /* Device_IO_Throttle Not defined */

#define Device_IO_Throttle_Increment
#define Device_IO_Throttle_Initialize
#define Device_IO_Throttle_Decrement
#define Device_IO_Throttle_Declareation

#endif /* Device_IO_Throttle */

struct DevThread_s {
                     fi_thread__t        thread_hdr;
                     fiList_t            DevLink;
                     CThread_t          *Channel;
                     fiList_t            Awaiting_Login_CDBLink;
                     fiList_t            Send_IO_CDBLink;
                     fiList_t            Active_CDBLink_0;
                     fiList_t            Active_CDBLink_1;
                     fiList_t            Active_CDBLink_2;
                     fiList_t            Active_CDBLink_3;
                     fiList_t            TimedOut_CDBLink;
                     DevSlot_t           DevSlot;
                     agFCDevInfo_t       DevInfo;
                     os_bit32            pollingCount;
                     Device_IO_Throttle_Declareation
                     os_bit32            Plogi_Reason_Code;
                     agBOOLEAN           FC_TapeDevice;
                     agBOOLEAN           PRLI_rejected;
                     fiTimer_Request_t   Timer_Request;
                     SFThread_Request_t  SFThread_Request;
                     os_bit32            Failed_Reset_Count;
                     os_bit32            Prev_Active_Device_FLAG;
                     os_bit32            In_Verify_ALPA_FLAG;
                     os_bit32            Lun_Active_Bitmask;
                     FCHS_t              Template_FCHS;
                     IRE_t               Template_SEST_IRE;
                     IWE_t               Template_SEST_IWE;
                     agBOOLEAN           OtherAgilentHBA;
#ifdef __TACHYON_XL_CLASS2
                     agBOOLEAN             GoingClass2;
#endif
#ifdef _DvrArch_1_30_
                     X_ID_t              IP_X_ID;
                     BOOLEAN             NewIPExchange;
#endif /* _DvrArch_1_30_ was defined */
                   };

#define DevThread_ptr(hpFCDev) ((DevThread_t *)(hpFCDev))

#define fiComputeDevThread_D_ID(DevThread)                \
    (  (DevThread->DevInfo.CurrentAddress.Domain << 16)   \
     | (DevThread->DevInfo.CurrentAddress.Area   <<  8)   \
     |  DevThread->DevInfo.CurrentAddress.AL_PA         )

/*+
Target Thread Structure Declaration
-*/

struct TgtThread_s {
                     fi_thread__t            thread_hdr;
                     fiList_t            TgtLink;
                     CThread_t          *Channel;
                     fiTimer_Request_t   Timer_Request;
                     SFThread_Request_t  SFThread_Request;
                     os_bit32               TgtCmnd_Length;
                     FCHS_t              TgtCmnd_FCHS;
                   };

#ifdef _DvrArch_1_30_
/*+
IP Thread Structure Declaration
-*/

struct IPThread_s {
                    fi_thread__t  thread_hdr;
                    DevThread_t  *BroadcastDevice;
                    fiList_t      OutgoingLink;
                    fiList_t      IncomingBufferLink;
		    PktThread_t  *CompletedPkt;
		    void         *osData;
		    struct {
		        os_bit32     LastReported;
		        os_bit32     MostRecent;
		        void         *osData;
		    } LinkStatus;
                  };

/*+
Packet Thread Structure Declaration
-*/

struct PktThread_s {
                     fi_thread__t                     thread_hdr;
                     fiList_t                         PktLink;
                     DevThread_t                     *Device;
                     FCHS_t                          *Pkt_CMND_Ptr;
                     os_bit32                         Pkt_CMND_Offset;
                     os_bit32                         Pkt_CMND_Lower32;
		     os_bit32                         status;
		     void                            *osData;
		     os_bit32                         DataLength;
                     fiTimer_Request_t                Timer_Request;
                     SFThread_Request_t               SFThread_Request;
                   };

#endif /* _DvrArch_1_30_ was defined */

/*+
Declaration of Function Pointers used by Channel Thread Structure
-*/

typedef ERQConsIndex_t (*GetERQConsIndex_t)(
                                             agRoot_t *hpRoot
                                           );

typedef IMQProdIndex_t (*GetIMQProdIndex_t)(
                                             agRoot_t *hpRoot
                                           );

typedef void (*fiFillInFCP_CMND_t)(
                                    CDBThread_t *CDBThread
                                  );

typedef void (*fiFillInFCP_RESP_t)(
                                    CDBThread_t *CDBThread
                                  );

typedef void (*fiFillInFCP_SEST_t)(
                                    CDBThread_t *CDBThread
                                  );

typedef void (*ESGLAlloc_t)(
                             agRoot_t       *hpRoot,
                             ESGL_Request_t *ESGL_Request
                           );

typedef void (*ESGLAllocCancel_t)(
                                   agRoot_t       *hpRoot,
                                   ESGL_Request_t *ESGL_Request
                                 );

typedef void (*ESGLFree_t)(
                            agRoot_t       *hpRoot,
                            ESGL_Request_t *ESGL_Request
                          );

typedef void (*WaitForERQ_t)(
                              agRoot_t *hpRoot
                            );

typedef void (*WaitForERQEmpty_t)(
                                   agRoot_t *hpRoot
                                 );

typedef os_bit32 (*fiFillInPLOGI_t)(
                                  SFThread_t *SFThread
                                );

typedef os_bit32 (*fiFillInFLOGI_t)(
                                  SFThread_t *SFThread
                                );

typedef os_bit32 (*fiFillInLOGO_t)(
                                 SFThread_t *SFThread
                               );

typedef os_bit32 (*fiFillInPRLI_t)(
                                 SFThread_t *SFThread
                               );

typedef os_bit32 (*fiFillInPRLO_t)(
                                 SFThread_t *SFThread
                               );

typedef os_bit32 (*fiFillInADISC_t)(
                                  SFThread_t *SFThread
                                );

typedef os_bit32 (*fiFillInSCR_t)(
                                  SFThread_t *SFThread
                                );

typedef os_bit32 (*fiFillInSRR_t)(
                                  SFThread_t *SFThread,
                                  os_bit32     OXID,
                                  os_bit32     RXID,
                                  os_bit32     Relative_Offset,
                                  os_bit32     R_CTL
                                );
typedef os_bit32 (*fiFillInREC_t)(
                                  SFThread_t *SFThread,
                                  os_bit32       OXID,
                                  os_bit32       RXID
                                );

typedef os_bit32 (*fiLinkSvcProcessSFQ_t)(
                                        agRoot_t        *hpRoot,
                                        SFQConsIndex_t   SFQConsIndex,
                                        os_bit32            Frame_Length,
                                        fi_thread__t       **Thread_to_return
                                      );

typedef os_bit32 (*fiSF_FCP_ProcessSFQ_t)(
                                        agRoot_t        *hpRoot,
                                        SFQConsIndex_t   SFQConsIndex,
                                        os_bit32            Frame_Length,
                                        fi_thread__t       **Thread_to_return
                                      );

typedef os_bit32 (*fiCTProcessSFQ_t)(
                                        agRoot_t        *hpRoot,
                                        SFQConsIndex_t   SFQConsIndex,
                                        os_bit32            Frame_Length,
                                        fi_thread__t       **Thread_to_return
                                      );

typedef void (*updateSESTwithESGLptr_t)(
                                  CDBThread_t *CDBFThread
                                );

typedef void (*fillESGL_t)(
                                  CDBThread_t *CDBFThread
                                );
typedef void (*fillLocalSGL_t)(
                                  CDBThread_t *CDBFThread
                                );

typedef void (*CDBFuncIRB_Init_t)(
                                  CDBThread_t *CDBFThread
                                );


typedef agBOOLEAN (*ProccessIMQ_t)(
                              agRoot_t *hpRoot
                            );

typedef void (*FCPCompletion_t)(

                              agRoot_t *hpRoot,
                              os_bit32 status
                            );

typedef void (*SF_IRB_fill_t)(
                             SFThread_t  * SFThread,
                             os_bit32         SFS_Len,
                             os_bit32         D_ID,
                             os_bit32         DCM_Bit
                            );

#ifdef _DvrArch_1_30_
typedef void (*Pkt_IRB_fill_t)(
                             PktThread_t  * PktThread,
                             os_bit32         PktS_Len,
                             os_bit32         D_ID,
                             os_bit32         DCM_Bit
                            );
#endif /* _DvrArch_1_30_ was defined */

typedef struct CThreadFuncPtrs_s
               CThreadFuncPtrs_t;


struct CThreadFuncPtrs_s {
                           GetERQConsIndex_t       GetERQConsIndex;
                           GetIMQProdIndex_t       GetIMQProdIndex;
                           fiFillInFCP_CMND_t      fiFillInFCP_CMND;
                           fiFillInFCP_RESP_t      fiFillInFCP_RESP;
                           fiFillInFCP_SEST_t      fiFillInFCP_SEST;
                           ESGLAlloc_t             ESGLAlloc;
                           ESGLAllocCancel_t       ESGLAllocCancel;
                           ESGLFree_t              ESGLFree;
                           WaitForERQ_t            WaitForERQ;
                           WaitForERQEmpty_t       WaitForERQEmpty;
                           fiFillInPLOGI_t         fiFillInPLOGI;
                           fiFillInFLOGI_t         fiFillInFLOGI;
                           fiFillInLOGO_t          fiFillInLOGO;
                           fiFillInPRLI_t          fiFillInPRLI;
                           fiFillInPRLO_t          fiFillInPRLO;
                           fiFillInADISC_t         fiFillInADISC;
                           fiFillInSCR_t           fiFillInSCR;                           
                           fiFillInSRR_t           fiFillInSRR;
                           fiFillInREC_t           fiFillInREC;
                           fiLinkSvcProcessSFQ_t   fiLinkSvcProcessSFQ;
                           fiSF_FCP_ProcessSFQ_t   fiSF_FCP_ProcessSFQ;
                           fiCTProcessSFQ_t        fiCTProcessSFQ;
                           updateSESTwithESGLptr_t upSEST;
                           fillESGL_t              fillESGL;
                           fillLocalSGL_t          fillLocalSGL;
                           CDBFuncIRB_Init_t       CDBFuncIRB_Init;
                           ProccessIMQ_t           Proccess_IMQ;
                           FCPCompletion_t         FCP_Completion;
                           SF_IRB_fill_t           SF_IRB_Init;
#ifdef _DvrArch_1_30_
                           Pkt_IRB_fill_t          Pkt_IRB_Init;
#endif /* _DvrArch_1_30_ was defined */
                         };

/* DeviceDiscoveryMethod */
#define DDiscoveryScanAllALPAs            0x00000000
#define DDiscoveryLoopMapReceived         0x00000010
#define DDiscoveryQueriedNameService      0x00000100
#define DDiscoveryPtToPtConnection        0x00001000
#define DDiscoveryMethodInvalid           0xFFFF

/*+
Channel Thread Structure Declaration
-*/

struct CThread_s {
                   fi_thread__t             thread_hdr;
                   DevThread_t             *DeviceSelf;
#ifdef _DvrArch_1_30_
                   IPThread_t              *IP;
#endif /* _DvrArch_1_30_ was defined */
                   fiList_t                 Active_DevLink;
                   fiList_t                 Unknown_Slot_DevLink;
                   fiList_t                 AWaiting_Login_DevLink;
                   fiList_t                 AWaiting_ADISC_DevLink;
                   fiList_t                 Slot_Searching_DevLink;
                   fiList_t                 Prev_Active_DevLink;
                   fiList_t                 Prev_Unknown_Slot_DevLink;
                   fiList_t                 DevSelf_NameServer_DevLink;
                   fiList_t                 RSCN_Recieved_NameServer_DevLink;

                   fiList_t                 QueueFrozenWaitingSFLink;
#ifdef _DvrArch_1_30_
                   fiList_t                 Free_PktLink;
#endif /* _DvrArch_1_30_ was defined */
                   fiList_t                 Free_TgtLink;
                   fiList_t                 Free_DevLink;
                   fiList_t                 Free_CDBLink;
                   fiList_t                 SFThread_Wait_Link;
                   fiList_t                 Free_SFLink;
                   fiList_t                 ESGL_Wait_Link;
                   os_bit32                 Free_ESGL_count;
                   os_bit32                 offsetToFirstFree_ESGL;
                   ERQProdIndex_t           HostCopy_ERQProdIndex;
                   IMQConsIndex_t           HostCopy_IMQConsIndex;
                   agBOOLEAN                sysIntsActive;
                   agBOOLEAN                sysIntsActive_before_fcLeavingOS_call;

                   agBOOLEAN                LaserEnable;
                   agTimeOutValue_t         TimeOutValues;
                   os_bit32                 sysIntsLogicallyEnabled;

                   os_bit32                 From_IMQ_Frame_Manager_Status;
                   os_bit32                 Last_IMQ_Frame_Manager_Status_Message;
                   os_bit32                 CDBpollingCount; /* Removable */
                   os_bit32                 SFpollingCount;
                   os_bit32                 FM_pollingCount; /* Removable */
                   os_bit32                 FindDEV_pollingCount;
                   os_bit32                 NumberOfPlogiTimeouts;
                   os_bit32                 NumberOfFLOGITimeouts;
                   os_bit32                 DEVReset_pollingCount;
                   os_bit32                 ADISC_pollingCount;
                   os_bit32                 FLOGI_pollingCount;
                   os_bit32                 Fabric_pollingCount;
                   agBOOLEAN                Flogi_AllocDone;
                   agBOOLEAN                FlogiTimedOut;

                   agBOOLEAN                PreviouslyAquiredALPA;
                   agBOOLEAN                ALPA_Changed_OnLinkEvent;

                   agBOOLEAN                ProcessingIMQ;
                   agBOOLEAN                LoopPreviousSuccess;
                   agBOOLEAN                Green_LED_State;
                   agBOOLEAN                Yellow_LED_State;
                   agBOOLEAN                flashPresent;

                   agBOOLEAN                JANUS; /* Janus Board type */

                   fiTime_t                 TimeBase;
                   fiTime_t                 LinkDownTime;
                   fiList_t                 TimerQ;
                   fiTimer_Request_t        Timer_Request;

                   agBOOLEAN                InterruptsDelayed;
                   agBOOLEAN                InterruptDelaySuspended;
                   agBOOLEAN                NoStallTimerTickActive;
                   agBOOLEAN                TimerTickActive;
                   os_bit32                 IOsStartedThisTimerTick;
                   os_bit32                 IOsCompletedThisTimerTick;
                   os_bit32                 IOsIntCompletedThisTimerTick;
                   os_bit32                 IOsActive;
                   os_bit32                 IOsActive_LastTick;
                   os_bit32                 IOsActive_No_ProgressCount;
                   os_bit32                 IOsStartedSinceISR;
                   agBOOLEAN                DelayedInterruptActive;

#ifdef __FC_Layer_Loose_IOs
                   os_bit32                 IOsTotalCompleted;
                   os_bit32                 IOsFailedCompeted;
#endif /*  __FC_Layer_Loose_IOs  */

#ifdef _SANMARK_LIP_BACKOFF
                   os_bit32                 TicksTillLIP_Count;
#endif /* _SANMARK_LIP_BACKOFF */ 


#ifdef _Enforce_MaxCommittedMemory_
                   os_bit32                 CommittedMemory;
#endif /* _Enforce_MaxCommittedMemory_ was defined */
                   /* Loopmap derived information */
                   agBOOLEAN                LoopMapFabricFound;
                   agBOOLEAN                LoopMapErrataFound;

                   agBOOLEAN                LoopMapNPortPossible;
                   agBOOLEAN                LoopMapLIRP_Received;

                   agBOOLEAN                XL2DelayActive;

                   os_bit8                  Elastic_Store_ERROR_Count;
                   os_bit8                  Lip_F7_In_tick;
                   os_bit8                  Link_Failures_In_tick;
                   os_bit8                  Lost_Signal_In_tick;

                   os_bit8                  Node_By_Passed_In_tick;
                   os_bit8                  Lost_sync_In_tick;
                   os_bit8                  Transmit_PE_In_tick;
                   os_bit8                  Link_Fault_In_tick;
                   os_bit32                 Loop_State_TimeOut_In_tick;
                   os_bit32                 DeviceDiscoveryMethod;

                   agBOOLEAN                PrimitiveReceived;
                   agBOOLEAN                FoundActiveDevicesBefore;

                   os_bit32                 Loop_Reset_Event_to_Send;
                   os_bit32                 AquiredCredit_Shifted;

                   agBOOLEAN                DirectoryServicesStarted;
                   agBOOLEAN                DirectoryServicesFailed;
                   agBOOLEAN                ReScanForDevices;

                   agBOOLEAN                LOOP_DOWN;
                   agBOOLEAN                IDLE_RECEIVED;
                   agBOOLEAN                OUTBOUND_RECEIVED;
                   agBOOLEAN                ERQ_FROZEN;
                   agBOOLEAN                FCP_FROZEN;
                   agBOOLEAN                FabricLoginRequired;
                   agBOOLEAN                FlogiSucceeded;
                   agBOOLEAN                InitAsNport;
/*
                   agBOOLEAN                RelyOnLossSyncStatus;
*/
                   agBOOLEAN                ConnectedToNportOrFPort;
                   agBOOLEAN                ExpectMoreNSFrames;
                   agBOOLEAN                NS_CurrentBit32Index;
                   agBOOLEAN                RSCNProcessingPending;
                   agBOOLEAN                RSCNreceived;
                   agBOOLEAN                FlogiRcvdFromTarget;
                   agBOOLEAN                TwoGigSuccessfull;
                   os_bit32                 NumberTwoGigFailures;

                   SFThread_Request_t       SFThread_Request;
                   DevThread_t              DirDevThread;
                   os_bit32                 NOS_DetectedInIMQ;

                   os_bit32                 NumberOutstandingFindDevice;
                   os_bit32                 LastSingleThreadedEnterCaller;
                   os_bit32                 LastSingleThreadedLeaveCaller;
                   os_bit32                 LastAsyncSingleThreadedEnterCaller;

                   os_bit32                 VENDID;
                   os_bit32                 DEVID;
                   os_bit32                 REVID;
                   os_bit32                 SVID;

                   FC_F_Port_Name_t         F_Port_Name;
                   FC_Fabric_Name_t         Fabric_Name;
                   FC_F_Port_Common_Parms_t F_Port_Common_Parms;
                   FC_F_Port_Class_Parms_t  F_Port_Class_1_Parms;
                   FC_F_Port_Class_Parms_t  F_Port_Class_2_Parms;
                   FC_F_Port_Class_Parms_t  F_Port_Class_3_Parms;

                   agFCChanInfo_t           ChanInfo;

                   CThreadFuncPtrs_t        FuncPtrs;

                   fiMemMapCalculation_t    Calculation;
                 };

#define CThread_ptr(hpRoot) ((CThread_t *)((hpRoot)->fcData))

#define fiComputeCThread_S_ID(CThread)                   \
    (  (CThread->ChanInfo.CurrentAddress.Domain << 16)   \
     | (CThread->ChanInfo.CurrentAddress.Area   <<  8)   \
     |  CThread->ChanInfo.CurrentAddress.AL_PA         )

/*+
Thread Union Declaration
-*/

typedef union AllThreads_u
              AllThreads_t;

union AllThreads_u {
                     SFThread_t  SFThread;
                     CDBThread_t CDBThread;
                     DevThread_t DevThread;
                     TgtThread_t TgtThread;
#ifdef _DvrArch_1_30_
                     IPThread_t  IPThread;
                     PktThread_t PktThread;
#endif /* _DvrArch_1_30_ was defined */
                     CThread_t   CThread;
                   };


#ifndef _Partial_Log_Debug_String_

#define fiLogDebugString(agRoot,detailLevel,formatString,firstString,secondString,firstPtr,secondPtr,\
                firstBit32,secondBit32,thirdBit32,fourthBit32,                      \
                fifthBit32,sixthBit32,seventhBit32, eighthBit32)                    \
                                                                                    \
    osLogDebugString( agRoot,detailLevel,formatString,firstString,secondString,firstPtr,secondPtr,   \
                firstBit32,secondBit32,thirdBit32,fourthBit32,                      \
                fifthBit32,sixthBit32,seventhBit32, eighthBit32)                    \

#define fiLogString(agRoot,formatString,firstString,secondString,firstPtr,secondPtr,\
                firstBit32,secondBit32,thirdBit32,fourthBit32,                      \
                fifthBit32,sixthBit32,seventhBit32, eighthBit32)                    \
                                                                                    \
    osLogString( agRoot,formatString,firstString,secondString,firstPtr,secondPtr,   \
                firstBit32,secondBit32,thirdBit32,fourthBit32,                      \
                fifthBit32,sixthBit32,seventhBit32, eighthBit32)                    \

#else /* Not _Full_Log_Debug_String_ */

#define fiLogDebugString(agRoot,detailLevel,formatString,firstString,secondString,firstPtr,secondPtr,\
                firstBit32,secondBit32,thirdBit32,fourthBit32,                      \
                fifthBit32,sixthBit32,seventhBit32, eighthBit32)                    \
                                                                                    \

/*                                                                                    \
    osLogDebugString( agRoot,detailLevel,formatString,firstString,secondString,firstPtr,secondPtr,   \
                firstBit32,secondBit32,thirdBit32,fourthBit32,                      \
                fifthBit32,sixthBit32,seventhBit32, eighthBit32)                    \

*/

#define fiLogString(agRoot,formatString,firstString,secondString,firstPtr,secondPtr,\
                firstBit32,secondBit32,thirdBit32,fourthBit32,                      \
                fifthBit32,sixthBit32,seventhBit32, eighthBit32)                    \
                                                                                    \
    osLogString( agRoot,formatString,firstString,secondString,firstPtr,secondPtr,   \
                firstBit32,secondBit32,thirdBit32,fourthBit32,                      \
                fifthBit32,sixthBit32,seventhBit32, eighthBit32)                    \

/*  
    osLogDebugString( agRoot,FCMainLogErrorLevel,formatString,firstString,secondString,firstPtr,secondPtr,   \
                firstBit32,secondBit32,thirdBit32,fourthBit32,                      \
                fifthBit32,sixthBit32,seventhBit32, eighthBit32)                    \
              
*/                                                                                   \

#endif /* End Not _Full_Log_Debug_String_ */

#define fdAbortIO                   1001
#define fdDelayedInterruptHandler   1002
#define fdEnteringOS                1003
#define fdGetChannelInfo            1004
#define fdGetDeviceHandles          1005
#define fdGetDeviceInfo             1006
#define fdInitializeChannel         1007
#define fdLeavingOS                 1008
#define fdResetChannel              1009
#define fdResetDevice               1010
#define fdShutdownChannel           1011
#define fdStartIO                   1012
#define fdSystemInterruptsActive    1013
#define fdTimerTick                 1014
/*
 
#define
*/
#ifndef SingleThreadedDebug
#define fiSingleThreadedEnter(hproot, Caller ) osSingleThreadedEnter( hproot )
#define fiSingleThreadedLeave(hpRoot, Caller ) osSingleThreadedLeave( hpRoot )
#define faSingleThreadedEnter(hproot, Caller ) osSingleThreadedEnter( hproot )
#define faSingleThreadedLeave(hpRoot, Caller ) osSingleThreadedLeave( hpRoot )

#else /* SingleThreadedDebug */

#define fiSingleThreadedEnter(hproot, Caller ) internSingleThreadedEnter( hproot, Caller )
#define fiSingleThreadedLeave(hpRoot, Caller ) internSingleThreadedLeave( hpRoot, Caller )

#define faSingleThreadedEnter(hproot, Caller ) internAsyncSingleThreadedEnter( hproot, Caller )
#define faSingleThreadedLeave(hpRoot, Caller ) internAsyncSingleThreadedLeave( hpRoot, Caller )

#endif /* SingleThreadedDebug */


#endif /* __FCMain_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\fcstruct.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/C/FCStruct.C $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 8/29/00 11:27a  $ (Last Modified)

Purpose:

  This file validates the typedef declarations in ../H/FCStruct.H

--*/
#ifndef _New_Header_file_Layout_
#include "../h/globals.h"
#include "../h/fcstruct.h"
#else /* _New_Header_file_Layout_ */
#include "globals.h"
#include "fcstruct.h"
#endif  /* _New_Header_file_Layout_ */


/*+
Function:  FCStructASSERTs()

Purpose:   Returns the number of FCStruct.H typedefs which are not the correct size.

Algorithm: Each typedef in FCStruct.H is checked for having the correct size.  While
           this property doesn't guarantee correct packing of the fields within, it
           is a pretty good indicator that the typedef has the intended layout.

           The total number of typedefs which are not of correct size is returned from
           this function.  Hence, if the return value is non-zero, the declarations
           can not be trusted to match the various Fibre Channel specifications.
-*/

os_bit32 FCStructASSERTs(
                       void
                     )
{
    os_bit32 to_return = 0;

    if ( sizeof(FC_Port_ID_Bit32_Form_t)                      !=                      FC_Port_ID_Bit32_Form_t_SIZE ) to_return++;
    if ( sizeof(FC_Port_ID_Struct_Form_t)                     !=                     FC_Port_ID_Struct_Form_t_SIZE ) to_return++;
    if ( sizeof(FC_Port_ID_t)                                 !=                                 FC_Port_ID_t_SIZE ) to_return++;
    if ( sizeof(FC_Frame_Header_t)                            !=                            FC_Frame_Header_t_SIZE ) to_return++;
    if ( sizeof(FC_BA_ACC_Payload_t)                          !=                          FC_BA_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_BA_RJT_Payload_t)                          !=                          FC_BA_RJT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_N_Port_Common_Parms_t)                     !=                     FC_N_Port_Common_Parms_t_SIZE ) to_return++;
    if ( sizeof(FC_N_Port_Class_Parms_t)                      !=                      FC_N_Port_Class_Parms_t_SIZE ) to_return++;
    if ( sizeof(FC_F_Port_Common_Parms_t)                     !=                     FC_F_Port_Common_Parms_t_SIZE ) to_return++;
    if ( sizeof(FC_F_Port_Class_Parms_t)                      !=                      FC_F_Port_Class_Parms_t_SIZE ) to_return++;
    if ( sizeof(FC_Port_Name_t)                               !=                               FC_Port_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_N_Port_Name_t)                             !=                             FC_N_Port_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_F_Port_Name_t)                             !=                             FC_F_Port_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_Node_or_Fabric_Name_t)                     !=                     FC_Node_or_Fabric_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_Node_Name_t)                               !=                               FC_Node_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_Fabric_Name_t)                             !=                             FC_Fabric_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_Vendor_Version_Level_t)                    !=                    FC_Vendor_Version_Level_t_SIZE ) to_return++;
    if ( sizeof(FC_Association_Header_t)                      !=                      FC_Association_Header_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_Unknown_Payload_t)                     !=                     FC_ELS_Unknown_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_LS_RJT_Payload_t)                      !=                      FC_ELS_LS_RJT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_Unknown_Payload_t)                 !=                 FC_ELS_ACC_Unknown_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_PLOGI_Payload_t)                       !=                       FC_ELS_PLOGI_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_PLOGI_Payload_t)                   !=                   FC_ELS_ACC_PLOGI_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_FLOGI_Payload_t)                       !=                       FC_ELS_FLOGI_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_FLOGI_Payload_t)                   !=                   FC_ELS_ACC_FLOGI_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_LOGO_Payload_t)                        !=                        FC_ELS_LOGO_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_LOGO_Payload_t)                    !=                    FC_ELS_ACC_LOGO_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_SRR_Payload_t)                         !=                        FC_ELS_SRR_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_REC_Payload_t)                         !=                        FC_ELS_REC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_REC_ACC_Payload_t)                     !=                    FC_ELS_REC_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ABTX_Payload_t)                        !=                        FC_ELS_ABTX_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_ABTX_Payload_t)                    !=                    FC_ELS_ACC_ABTX_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_RCS_Payload_t)                         !=                         FC_ELS_RCS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_RCS_Payload_t)                     !=                     FC_ELS_ACC_RCS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_RES_Payload_t)                         !=                         FC_ELS_RES_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_RES_Payload_t)                     !=                     FC_ELS_ACC_RES_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_RSS_Payload_t)                         !=                         FC_ELS_RSS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_RSS_Payload_t)                     !=                     FC_ELS_ACC_RSS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_RSI_Payload_t)                         !=                         FC_ELS_RSI_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_RSI_Payload_t)                     !=                     FC_ELS_ACC_RSI_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ESTS_Payload_t)                        !=                        FC_ELS_ESTS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_ESTS_Payload_t)                    !=                    FC_ELS_ACC_ESTS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ESTC_Payload_t)                        !=                        FC_ELS_ESTC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ADVC_Payload_t)                        !=                        FC_ELS_ADVC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_ADVC_Payload_t)                    !=                    FC_ELS_ACC_ADVC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_RTV_Payload_t)                         !=                         FC_ELS_RTV_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_RTV_Payload_t)                     !=                     FC_ELS_ACC_RTV_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_RLS_Payload_t)                         !=                         FC_ELS_RLS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_RLS_Payload_t)                     !=                     FC_ELS_ACC_RLS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ECHO_Payload_t)                        !=                        FC_ELS_ECHO_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_ECHO_Payload_t)                    !=                    FC_ELS_ACC_ECHO_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_TEST_Payload_t)                        !=                        FC_ELS_TEST_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_RRQ_Payload_t)                         !=                         FC_ELS_RRQ_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_RRQ_Payload_t)                     !=                     FC_ELS_ACC_RRQ_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_PRLI_Parm_Page_t)                      !=                      FC_ELS_PRLI_Parm_Page_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_PRLI_Payload_t)                        !=                        FC_ELS_PRLI_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_PRLI_Parm_Page_t)                  !=                  FC_ELS_ACC_PRLI_Parm_Page_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_PRLI_Payload_t)                    !=                    FC_ELS_ACC_PRLI_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_PRLO_Parm_Page_t)                      !=                      FC_ELS_PRLO_Parm_Page_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_PRLO_Payload_t)                        !=                        FC_ELS_PRLO_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_PRLO_Parm_Page_t)                  !=                  FC_ELS_ACC_PRLO_Parm_Page_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_PRLO_Payload_t)                    !=                    FC_ELS_ACC_PRLO_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_SCN_Affected_N_Port_ID_t)              !=              FC_ELS_SCN_Affected_N_Port_ID_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_SCN_Payload_t)                         !=                         FC_ELS_SCN_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_TPLS_Image_Pair_t)                     !=                     FC_ELS_TPLS_Image_Pair_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_TPLS_Payload_t)                        !=                        FC_ELS_TPLS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_TPLS_Image_Pair_t)                 !=                 FC_ELS_ACC_TPLS_Image_Pair_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_TPLS_Payload_t)                    !=                    FC_ELS_ACC_TPLS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_TPRLO_Parm_Page_t)                     !=                     FC_ELS_TPRLO_Parm_Page_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_TPRLO_Payload_t)                       !=                       FC_ELS_TPRLO_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_TPRLO_Payload_t)                   !=                   FC_ELS_ACC_TPRLO_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_Alias_Token_t)                         !=                         FC_ELS_Alias_Token_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_Alias_SP_t)                            !=                            FC_ELS_Alias_SP_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_NP_List_Element_t)                     !=                     FC_ELS_NP_List_Element_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_Alias_ID_t)                            !=                            FC_ELS_Alias_ID_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_GAID_Payload_t)                        !=                        FC_ELS_GAID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_GAID_Payload_t)                    !=                    FC_ELS_ACC_GAID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_FACT_Payload_t)                        !=                        FC_ELS_FACT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_FACT_Payload_t)                    !=                    FC_ELS_ACC_FACT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_FDACT_Payload_t)                       !=                       FC_ELS_FDACT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_FDACT_Payload_t)                   !=                   FC_ELS_ACC_FDACT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_NACT_Payload_t)                        !=                        FC_ELS_NACT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_NACT_Payload_t)                    !=                    FC_ELS_ACC_NACT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_NDACT_Payload_t)                       !=                       FC_ELS_NDACT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_NDACT_Payload_t)                   !=                   FC_ELS_ACC_NDACT_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_QoSR_Payload_t)                        !=                        FC_ELS_QoSR_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_QoSR_Payload_t)                    !=                    FC_ELS_ACC_QoSR_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_RVCS_Payload_t)                        !=                        FC_ELS_RVCS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_RVCS_Class_4_Status_Block_t)       !=       FC_ELS_ACC_RVCS_Class_4_Status_Block_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_RVCS_Payload_t)                    !=                    FC_ELS_ACC_RVCS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_PDISC_Payload_t)                       !=                       FC_ELS_PDISC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_PDISC_Payload_t)                   !=                   FC_ELS_ACC_PDISC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_FDISC_Payload_t)                       !=                       FC_ELS_FDISC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_FDISC_Payload_t)                   !=                   FC_ELS_ACC_FDISC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ADISC_Payload_t)                       !=                       FC_ELS_ADISC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_ADISC_Payload_t)                   !=                   FC_ELS_ACC_ADISC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_ACC_Payload_t)                         !=                         FC_ELS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_Payload_t)                             !=                             FC_ELS_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_LoopInit_Unknown_Payload_t)            !=            FC_ELS_LoopInit_Unknown_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_LoopInit_Port_Name_Payload_t)          !=          FC_ELS_LoopInit_Port_Name_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_SRR_Payload_t)                         !=          FC_ELS_SRR_Payload_t_SIZE )                to_return++;
    if ( sizeof(FC_ELS_RSS_Payload_t)                         !=          FC_ELS_RSS_Payload_t_SIZE )                to_return++;
    if ( sizeof(FC_ELS_LoopInit_AL_PA_Bit_Map_Payload_t)      !=      FC_ELS_LoopInit_AL_PA_Bit_Map_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t) != FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_CT_IU_HDR_t)                               !=                               FC_CT_IU_HDR_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_Port_Type_t)                            !=                            FC_NS_Port_Type_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_Port_ID_t)                              !=                              FC_NS_Port_ID_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_Control_Port_ID_t)                      !=                      FC_NS_Control_Port_ID_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_Port_Name_t)                            !=                            FC_NS_Port_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_Node_Name_t)                            !=                            FC_NS_Node_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_Symbolic_Port_Name_t)                   !=                   FC_NS_Symbolic_Port_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_Symbolic_Node_Name_t)                   !=                   FC_NS_Symbolic_Node_Name_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_IPA_t)                                  !=                                  FC_NS_IPA_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_IP_Address_t)                           !=                           FC_NS_IP_Address_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_Class_of_Service_t)                     !=                     FC_NS_Class_of_Service_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_FC_4_Type_Code_t)                       !=                       FC_NS_FC_4_Type_Code_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_FC_4_Types_t)                           !=                           FC_NS_FC_4_Types_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GA_NXT_Request_Payload_t)            !=            FC_NS_DU_GA_NXT_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GA_NXT_FS_ACC_Payload_t)             !=             FC_NS_DU_GA_NXT_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GPN_ID_Request_Payload_t)            !=            FC_NS_DU_GPN_ID_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GPN_ID_FS_ACC_Payload_t)             !=             FC_NS_DU_GPN_ID_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GNN_ID_Request_Payload_t)            !=            FC_NS_DU_GNN_ID_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GNN_ID_FS_ACC_Payload_t)             !=             FC_NS_DU_GNN_ID_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GCS_ID_Request_Payload_t)            !=            FC_NS_DU_GCS_ID_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GCS_ID_FS_ACC_Payload_t)             !=             FC_NS_DU_GCS_ID_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GFT_ID_Request_Payload_t)            !=            FC_NS_DU_GFT_ID_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GFT_ID_FS_ACC_Payload_t)             !=             FC_NS_DU_GFT_ID_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GSPN_ID_Request_Payload_t)           !=           FC_NS_DU_GSPN_ID_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GSPN_ID_FS_ACC_Payload_t)            !=            FC_NS_DU_GSPN_ID_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GPT_ID_Request_Payload_t)            !=            FC_NS_DU_GPT_ID_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GPT_ID_FS_ACC_Payload_t)             !=             FC_NS_DU_GPT_ID_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIPP_ID_Request_Payload_t)           !=           FC_NS_DU_GIPP_ID_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIPP_ID_FS_ACC_Payload_t)            !=            FC_NS_DU_GIPP_ID_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_PN_Request_Payload_t)            !=            FC_NS_DU_GID_PN_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_PN_FS_ACC_Payload_t)             !=             FC_NS_DU_GID_PN_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIPP_PN_Request_Payload_t)           !=           FC_NS_DU_GIPP_PN_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIPP_PN_FS_ACC_Payload_t)            !=            FC_NS_DU_GIPP_PN_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_NN_Request_Payload_t)            !=            FC_NS_DU_GID_NN_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_NN_FS_ACC_Payload_t)             !=             FC_NS_DU_GID_NN_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIP_NN_Request_Payload_t)            !=            FC_NS_DU_GIP_NN_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIP_NN_FS_ACC_Payload_t)             !=             FC_NS_DU_GIP_NN_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIPA_NN_Request_Payload_t)           !=           FC_NS_DU_GIPA_NN_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIPA_NN_FS_ACC_Payload_t)            !=            FC_NS_DU_GIPA_NN_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GSNN_NN_Request_Payload_t)           !=           FC_NS_DU_GSNN_NN_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GSNN_NN_FS_ACC_Payload_t)            !=            FC_NS_DU_GSNN_NN_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GNN_IP_Request_Payload_t)            !=            FC_NS_DU_GNN_IP_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GNN_IP_FS_ACC_Payload_t)             !=             FC_NS_DU_GNN_IP_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIPA_IP_Request_Payload_t)           !=           FC_NS_DU_GIPA_IP_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GIPA_IP_FS_ACC_Payload_t)            !=            FC_NS_DU_GIPA_IP_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_FT_Request_Payload_t)            !=            FC_NS_DU_GID_FT_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_FT_FS_ACC_Payload_t)             !=             FC_NS_DU_GID_FT_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_PT_Request_Payload_t)            !=            FC_NS_DU_GID_PT_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_PT_FS_ACC_Payload_t)             !=             FC_NS_DU_GID_PT_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_IPP_Request_Payload_t)           !=           FC_NS_DU_GID_IPP_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GID_IPP_FS_ACC_Payload_t)            !=            FC_NS_DU_GID_IPP_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GPN_IPP_Request_Payload_t)           !=           FC_NS_DU_GPN_IPP_Request_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_GPN_IPP_FS_ACC_Payload_t)            !=            FC_NS_DU_GPN_IPP_FS_ACC_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RPN_ID_Payload_t)                    !=                    FC_NS_DU_RPN_ID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RNN_ID_Payload_t)                    !=                    FC_NS_DU_RNN_ID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RCS_ID_Payload_t)                    !=                    FC_NS_DU_RCS_ID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RFT_ID_Payload_t)                    !=                    FC_NS_DU_RFT_ID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RSPN_ID_Payload_t)                   !=                   FC_NS_DU_RSPN_ID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RPT_ID_Payload_t)                    !=                    FC_NS_DU_RPT_ID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RIPP_ID_Payload_t)                   !=                   FC_NS_DU_RIPP_ID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RIP_NN_Payload_t)                    !=                    FC_NS_DU_RIP_NN_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RIPA_NN_Payload_t)                   !=                   FC_NS_DU_RIPA_NN_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_RSNN_NN_Payload_t)                   !=                   FC_NS_DU_RSNN_NN_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_NS_DU_DA_ID_Payload_t)                     !=                     FC_NS_DU_DA_ID_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_FCP_CMND_FcpLun_LEVEL_t)                   !=                   FC_FCP_CMND_FcpLun_LEVEL_t_SIZE ) to_return++;
    if ( sizeof(FC_FCP_CMND_FcpCntl_t)                        !=                        FC_FCP_CMND_FcpCntl_t_SIZE ) to_return++;
    if ( sizeof(FC_FCP_CMND_Payload_t)                        !=                        FC_FCP_CMND_Payload_t_SIZE ) to_return++;
    if ( sizeof(FC_FCP_RSP_FCP_STATUS_t)                      !=                      FC_FCP_RSP_FCP_STATUS_t_SIZE ) to_return++;
    if ( sizeof(FC_FCP_RSP_Payload_t)                         !=                         FC_FCP_RSP_Payload_t_SIZE ) to_return++;

    return to_return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\fcstruct.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/FCStruct.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 10/03/00 1:55p  $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures generic to Fibre Channel

Reference Documents:

  Fibre Channel       - Physical And Signaling Interface (FC-PH)         - Rev      4.3 - June 1, 1994
  Fibre Channel       - Physical And Signaling Interface - 2 (FC-PH-2)   - Rev      7.4 - September 10, 1996
  Fibre Channel       - Generic Services - 2 (FC-GS-2)                   - dpANS X3.288-199x
  Fibre Channel       - Arbitrated Loop (FC-AL)                          - Rev      4.5
  Fibre Channel       - Arbitrated Loop (FC-AL-2)                        - Rev      5.4
  Information Technology - FibreChannel Protocol for SCSI                - Rev 2 (FCP-2) March 30, 1999
  Information Systems - dpANS Fibre Channel Protocol for SCSI (FCP-SCSI) - Revision 012 - May 30, 1995

--*/

#ifndef __FCStruct_H__
#define __FCStruct_H__

/*+
Frame Format (Section 17, FC-PH)
-*/

#define FC_Frame_Data_Size_Max 2112

/*+
Port ID (Section 18.3, FC-PH
   and Section 18.3, FC-PH-2)
-*/

typedef os_bit32 FC_Port_ID_Bit32_Form_t;

#define FC_Port_ID_Bit32_Form_t_SIZE                                      0x00000004

typedef struct FC_Port_ID_Struct_Form_s
               FC_Port_ID_Struct_Form_t;

#define FC_Port_ID_Struct_Form_t_SIZE                                     0x00000004

struct FC_Port_ID_Struct_Form_s {
                                  os_bit8 reserved;
                                  os_bit8 Domain;
                                  os_bit8 Area;
                                  os_bit8 AL_PA;
                                };

typedef union FC_Port_ID_u
              FC_Port_ID_t;

#define FC_Port_ID_t_SIZE                                                 0x00000004

union FC_Port_ID_u {
                     FC_Port_ID_Bit32_Form_t  Bit32_Form;
                     FC_Port_ID_Struct_Form_t Struct_Form;
                   };

#define FC_Well_Known_Port_ID_Alias_Server                                0x00FFFFF8
#define FC_Well_Known_Port_ID_Quality_of_Service_Facilitator_Class_4      0x00FFFFF9
#define FC_Well_Known_Port_ID_Management_Server                           0x00FFFFFA
#define FC_Well_Known_Port_ID_Time_Server                                 0x00FFFFFB
#define FC_Well_Known_Port_ID_Directory_Server                            0x00FFFFFC
#define FC_Well_Known_Port_ID_Fabric_Controller                           0x00FFFFFD
#define FC_Well_Known_Port_ID_Fabric_F_Port                               0x00FFFFFE
#define FC_Well_Known_Port_ID_Broadcast_Alias_ID                          0x00FFFFFF
#ifdef _DvrArch_1_30_
#define FC_Broadcast_Replicate_AL_PA                                      0x000000FF
#endif /* _DvrArch_1_30_ was defined */

/*+
Frame Header (Section 18, FC-PH
        and Section 18, FC-PH-2)
-*/

typedef struct FC_Frame_Header_s
               FC_Frame_Header_t;

#define FC_Frame_Header_t_SIZE                                            0x00000018

struct FC_Frame_Header_s
       {
         os_bit32 R_CTL__D_ID;
         os_bit32 CS_CTL__S_ID;
         os_bit32 TYPE__F_CTL;
         os_bit32 SEQ_ID__DF_CTL__SEQ_CNT;
         os_bit32 OX_ID__RX_ID;
         os_bit32 Parameter;
       };

#define FC_Frame_Header_R_CTL_Hi_MASK                                     0xF0000000
#define FC_Frame_Header_R_CTL_Lo_MASK                                     0x0F000000
#define FC_Frame_Header_R_CTL_MASK                                        (FC_R_CTL_Hi_MASK | FC_R_CTL_Lo_MASK)

#define FC_Frame_Header_R_CTL_Hi_FC_4_Device_Data_Frame                   0x00000000
#define FC_Frame_Header_R_CTL_Hi_Extended_Link_Data_Frame                 0x20000000
#define FC_Frame_Header_R_CTL_Hi_FC_4_Link_Data_Frame                     0x30000000
#define FC_Frame_Header_R_CTL_Hi_Video_Data_Frame                         0x40000000
#define FC_Frame_Header_R_CTL_Hi_Basic_Link_Data_Frame                    0x80000000
#define FC_Frame_Header_R_CTL_Hi_Link_Control_Frame                       0xC0000000

#define FC_Frame_Header_R_CTL_Lo_Uncategorized_Information                0x00000000
#define FC_Frame_Header_R_CTL_Lo_Solicited_Data                           0x01000000
#define FC_Frame_Header_R_CTL_Lo_Unsolicited_Control                      0x02000000
#define FC_Frame_Header_R_CTL_Lo_Solicited_Control                        0x03000000
#define FC_Frame_Header_R_CTL_Lo_Unsolicited_Data                         0x04000000
#define FC_Frame_Header_R_CTL_Lo_Data_Descriptor                          0x05000000
#define FC_Frame_Header_R_CTL_Lo_Unsolicited_Command                      0x06000000
#define FC_Frame_Header_R_CTL_Lo_Command_Status                           0x07000000

#define FC_Frame_Header_R_CTL_Lo_BLS_NOP                                  0x00000000
#define FC_Frame_Header_R_CTL_Lo_BLS_ABTS                                 0x01000000
#define FC_Frame_Header_R_CTL_Lo_BLS_RMC                                  0x02000000
#define FC_Frame_Header_R_CTL_Lo_BLS_BA_ACC                               0x04000000
#define FC_Frame_Header_R_CTL_Lo_BLS_BA_RJT                               0x05000000

#define FC_Frame_Header_R_CTL_Lo_LC_ACK_1                                 0x00000000
#define FC_Frame_Header_R_CTL_Lo_LC_ACK_N                                 0x01000000
#define FC_Frame_Header_R_CTL_Lo_LC_ACK_0                                 0x01000000
#define FC_Frame_Header_R_CTL_Lo_LC_P_RJT                                 0x02000000
#define FC_Frame_Header_R_CTL_Lo_LC_F_RJT                                 0x03000000
#define FC_Frame_Header_R_CTL_Lo_LC_P_BSY                                 0x04000000
#define FC_Frame_Header_R_CTL_Lo_LC_F_BSY_to_Data_Frame                   0x05000000
#define FC_Frame_Header_R_CTL_Lo_LC_F_BSY_to_Link_Control_Frame           0x06000000
#define FC_Frame_Header_R_CTL_Lo_LC_LCR                                   0x07000000

#define FC_Frame_Header_CS_CTL_MASK                                       0xFF000000

#define FC_Frame_Header_CS_CTL_Class_1_Simplex                            0x80000000
#define FC_Frame_Header_CS_CTL_Class_1_SCR                                0x40000000
#define FC_Frame_Header_CS_CTL_Class_1_COR                                0x20000000
#define FC_Frame_Header_CS_CTL_Class_1_BCR                                0x10000000

#define FC_Frame_Header_S_ID_MASK                                         0x00FFFFFF

#define FC_Frame_Header_D_ID_MASK                                         0x00FFFFFF

#define FC_Frame_Header_TYPE_MASK                                         0xFF000000

#define FC_Frame_Header_TYPE_BLS                                          0x00000000 /* FC_R_CTL_Hi_Basic_Link_Data_Frame or */
#define FC_Frame_Header_TYPE_ELS                                          0x01000000 /* FC_R_CTL_Hi_Extended_Link_Data_Frame */

#define FC_Frame_Header_TYPE_8802_2_LLC_In_Order                          0x04000000 /* FC_R_CTL_Hi_FC_4_Link_Data_Frame  or */
#define FC_Frame_Header_TYPE_8802_2_LLC_SNAP                              0x05000000 /* FC_R_CTL_Hi_FC_4_Device_Data_Frame   */
#define FC_Frame_Header_TYPE_SCSI_FCP                                     0x08000000 /*            "            "            */
#define FC_Frame_Header_TYPE_SCSI_GPP                                     0x09000000 /*            "            "            */
#define FC_Frame_Header_TYPE_IPI_3_Master                                 0x11000000 /*            "            "            */
#define FC_Frame_Header_TYPE_IPI_3_Slave                                  0x12000000 /*            "            "            */
#define FC_Frame_Header_TYPE_IPI_3_Peer                                   0x13000000 /*            "            "            */
#define FC_Frame_Header_TYPE_CP_IPI_3_Master                              0x15000000 /*            "            "            */
#define FC_Frame_Header_TYPE_CP_IPI_3_Slave                               0x16000000 /*            "            "            */
#define FC_Frame_Header_TYPE_CP_IPI_3_Peer                                0x17000000 /*            "            "            */
#define FC_Frame_Header_TYPE_SBCCS_Channel                                0x19000000 /*            "            "            */
#define FC_Frame_Header_TYPE_SBCCS_Control_Unit                           0x1A000000 /*            "            "            */
#define FC_Frame_Header_TYPE_Fibre_Channel_Services                       0x20000000 /*            "            "            */
#define FC_Frame_Header_TYPE_FC_FG                                        0x21000000 /*            "            "            */
#define FC_Frame_Header_TYPE_FC_XS                                        0x22000000 /*            "            "            */
#define FC_Frame_Header_TYPE_FC_AL                                        0x23000000 /*            "            "            */
#define FC_Frame_Header_TYPE_SNMP                                         0x24000000 /*            "            "            */
#define FC_Frame_Header_TYPE_HIPPI_FP                                     0x40000000 /*            "            "            */
#define FC_Frame_Header_TYPE_Fabric_Controller                            0x5D000000 /*            "            "            */

#define FC_Frame_Header_F_CTL_MASK                                        0x00FFFFFF

#define FC_Frame_Header_F_CTL_Exchange_Context_Originator                 0x00000000
#define FC_Frame_Header_F_CTL_Exchange_Context_Responder                  0x00800000
#define FC_Frame_Header_F_CTL_Exchange_Context_Originator_Responder_MASK  (FC_Frame_Header_F_CTL_Exchange_Context_Originator | FC_Frame_Header_F_CTL_Exchange_Context_Responder)

#define FC_Frame_Header_F_CTL_Sequence_Context_Initiator                  0x00000000
#define FC_Frame_Header_F_CTL_Sequence_Context_Recipient                  0x00400000
#define FC_Frame_Header_F_CTL_Sequence_Context_Initiator_Recipient_MASK   (FC_Frame_Header_F_CTL_Sequence_Context_Initiator | FC_Frame_Header_F_CTL_Sequence_Context_Recipient)

#define FC_Frame_Header_F_CTL_First_Sequence                              0x00200000

#define FC_Frame_Header_F_CTL_Last_Sequence                               0x00100000

#define FC_Frame_Header_F_CTL_End_Sequence                                0x00080000

#define FC_Frame_Header_F_CTL_End_Connection                              0x00040000
#define FC_Frame_Header_F_CTL_Deactivate_Class_4_Circuit                  0x00040000

#define FC_Frame_Header_F_CTL_Sequence_Initiative_Hold                    0x00000000
#define FC_Frame_Header_F_CTL_Sequence_Initiative_Transfer                0x00010000

#define FC_Frame_Header_F_CTL_X_ID_Reassigned                             0x00008000

#define FC_Frame_Header_F_CTL_Invalidate_X_ID                             0x00004000

#define FC_Frame_Header_F_CTL_ACK_Form_MASK                               0x00003000
#define FC_Frame_Header_F_CTL_ACK_Form_No_Assistance_Provided             0x00000000
#define FC_Frame_Header_F_CTL_ACK_Form_ACK_1_Required                     0x00001000
#define FC_Frame_Header_F_CTL_ACK_Form_ACK_N_Required                     0x00002000
#define FC_Frame_Header_F_CTL_ACK_Form_ACK_0_Required                     0x00003000

#define FC_Frame_Header_F_CTL_Compressed_Payload                          0x00000800

#define FC_Frame_Header_F_CTL_Retransmitted_Sequence                      0x00000200

#define FC_Frame_Header_F_CTL_Unidirectional_Transmit                     0x00000100
#define FC_Frame_Header_F_CTL_Remove_Class_4_Circuit                      0x00000100

#define FC_Frame_Header_F_CTL_Continue_Sequence_Condition_MASK            0x000000C0
#define FC_Frame_Header_F_CTL_No_Information                              0x00000000
#define FC_Frame_Header_F_CTL_Sequence_to_follow_immediately              0x00000040
#define FC_Frame_Header_F_CTL_Sequence_to_follow_soon                     0x00000080
#define FC_Frame_Header_F_CTL_Sequence_to_follow_delayed                  0x000000C0

#define FC_Frame_Header_F_CTL_Abort_Sequence_Condition_MASK               0x00000030
#define FC_Frame_Header_F_CTL_Continue_Sequence                           0x00000000 /* ACK Frame - Sequence Recipient  */
#define FC_Frame_Header_F_CTL_Abort_Sequence_Perform_ABTS                 0x00000010 /*     "          "         "      */
#define FC_Frame_Header_F_CTL_Stop_Sequence                               0x00000020 /*     "          "         "      */
#define FC_Frame_Header_F_CTL_Immediate_Sequence_Retransmission_Requested 0x00000030 /*     "          "         "      */
#define FC_Frame_Header_F_CTL_Abort_Discard_Multiple_Sequences            0x00000000 /* Data Frame - Sequence Initiator */
#define FC_Frame_Header_F_CTL_Abort_Discard_Single_Sequence               0x00000010 /*     "          "         "      */
#define FC_Frame_Header_F_CTL_Process_Policy_with_Infinite_Buffers        0x00000020 /*     "          "         "      */
#define FC_Frame_Header_F_CTL_Discard_Multiple_Sequences                  0x00000030 /*     "          "         "      */

#define FC_Frame_Header_F_CTL_Relative_Offset_Present                     0x00000008

#define FC_Frame_Header_F_CTL_Fill_Data_Bytes_MASK                        0x00000003
#define FC_Frame_Header_F_CTL_0_Fill_Bytes                                0x00000000
#define FC_Frame_Header_F_CTL_1_Fill_Byte                                 0x00000001
#define FC_Frame_Header_F_CTL_2_Fill_Bytes                                0x00000002
#define FC_Frame_Header_F_CTL_3_Fill_Bytes                                0x00000003

#define FC_Frame_Header_SEQ_ID_MASK                                       0xFF000000

#define FC_Frame_Header_DF_CTL_MASK                                       0x00FF0000

#define FC_Frame_Header_DF_CTL_Expiration_Security_Header                 0x00400000
#define FC_Frame_Header_DF_CTL_Network_Header                             0x00200000
#define FC_Frame_Header_DF_CTL_Association_Header                         0x00100000

#define FC_Frame_Header_DF_CTL_Device_Header_MASK                         0x00030000
#define FC_Frame_Header_DF_CTL_No_Device_Header                           0x00000000
#define FC_Frame_Header_DF_CTL_16_Byte_Device_Header                      0x00010000
#define FC_Frame_Header_DF_CTL_32_Byte_Device_Header                      0x00020000
#define FC_Frame_Header_DF_CTL_64_Byte_Device_Header                      0x00030000

#define FC_Frame_Header_SEQ_CNT_MASK                                      0x0000FFFF

#define FC_Frame_Header_OX_ID_MASK                                        0xFFFF0000
#define FC_Frame_Header_OX_ID_SHIFT                                             0x10

#define FC_Frame_Header_RX_ID_MASK                                        0x0000FFFF
#define FC_Frame_Header_RX_ID_SHIFT                                             0x00

/*+
Basic Link Services (Section 21.2, FC-PH)
-*/

typedef struct FC_BA_ACC_Payload_s
               FC_BA_ACC_Payload_t;

#define FC_BA_ACC_Payload_t_SIZE                                          0x0000000C

struct FC_BA_ACC_Payload_s
       {
         os_bit32 SEQ_ID_Validity__SEQ_ID__Reserved;
         os_bit32 OX_ID__RX_ID;
         os_bit32 Low_SEQ_CNT__High_SEQ_CNT;
       };

#define FC_BA_ACC_Payload_SEQ_ID_Validity_MASK                            0xFF000000
#define FC_BA_ACC_Payload_SEQ_ID_Invalid                                  0x00000000
#define FC_BA_ACC_Payload_SEQ_ID_Valid                                    0x80000000

#define FC_BA_ACC_Payload_SEQ_ID_MASK                                     0x00FF0000

#define FC_BA_ACC_Payload_OX_ID_MASK                                      0xFFFF0000
#define FC_BA_ACC_Payload_OX_ID_SHIFT                                           0x10

#define FC_BA_ACC_Payload_RX_ID_MASK                                      0x0000FFFF
#define FC_BA_ACC_Payload_RX_ID_SHIFT                                           0x00

#define FC_BA_ACC_Payload_Low_SEQ_CNT_MASK                                0xFFFF0000
#define FC_BA_ACC_Payload_Low_SEQ_CNT_SHIFT                                     0x10

#define FC_BA_ACC_Payload_High_SEQ_CNT_MASK                               0x0000FFFF
#define FC_BA_ACC_Payload_High_SEQ_CNT_SHIFT                                    0x00

typedef struct FC_BA_RJT_Payload_s
               FC_BA_RJT_Payload_t;

#define FC_BA_RJT_Payload_t_SIZE                                          0x00000004

struct FC_BA_RJT_Payload_s
       {
         os_bit32 Reserved__Reason_Code__Reason_Explanation__Vendor_Unique;
       };

#define FC_BA_RJT_Payload_Reason_Code_MASK                                0x00FF0000
#define FC_BA_RJT_Payload_Reason_Code_Invalid_Command_Code                0x00010000
#define FC_BA_RJT_Payload_Reason_Code_Logical_Error                       0x00030000
#define FC_BA_RJT_Payload_Reason_Code_Logical_Busy                        0x00050000
#define FC_BA_RJT_Payload_Reason_Code_Protocol_Error                      0x00070000
#define FC_BA_RJT_Payload_Reason_Code_Unable_To_Perform                   0x00090000
#define FC_BA_RJT_Payload_Reason_Code_Vendor_Unique_Error                 0x00FF0000

#define FC_BA_RJT_Payload_Reason_Explanation_MASK                         0x0000FF00
#define FC_BA_RJT_Payload_Reason_Explanation_No_Additional_Explanation    0x00000000
#define FC_BA_RJT_Payload_Reason_Explanation_Invalid_OX_ID_RX_ID_Combo    0x00000300
#define FC_BA_RJT_Payload_Reason_Explanation_Sequence_Aborted__No_Info    0x00000500

/*+
Login and Service Parameters (Section 23, FC-PH
                        and Section 23, FC-PH-2)
-*/

typedef struct FC_N_Port_Common_Parms_s
               FC_N_Port_Common_Parms_t;

#define FC_N_Port_Common_Parms_t_SIZE                                     0x00000010

struct FC_N_Port_Common_Parms_s
       {
         os_bit32 FC_PH_Version__BB_Credit;
         os_bit32 Common_Features__BB_Recv_Data_Field_Size;
         os_bit32 N_Port_Total_Concurrent_Sequences__RO_by_Info_Category;
         os_bit32 E_D_TOV;
       };

#define FC_N_Port_Common_Parms_Highest_Version_MASK                       0xFF000000
#define FC_N_Port_Common_Parms_Highest_Version_SHIFT                            0x18

#define FC_N_Port_Common_Parms_Lowest_Version_MASK                        0x00FF0000
#define FC_N_Port_Common_Parms_Lowest_Version_SHIFT                             0x10

#define FC_N_Port_Common_Parms_Version_4_0                                      0x06
#define FC_N_Port_Common_Parms_Version_4_1                                      0x07
#define FC_N_Port_Common_Parms_Version_4_2                                      0x08
#define FC_N_Port_Common_Parms_Version_4_3                                      0x09
/*
was  #define FC_N_Port_Common_Parms_Version_FC_PH_2                             0x10
*/
#define FC_N_Port_Common_Parms_Version_FC_PH_2                                  0x20

#define FC_N_Port_Common_Parms_BB_Credit_MASK                             0x0000FFFF
#define FC_N_Port_Common_Parms_BB_Credit_SHIFT                                  0x00

#define FC_N_Port_Common_Parms_Continuously_Increasing_Supported          0x80000000
#define FC_N_Port_Common_Parms_Random_Relative_Offset_Supported           0x40000000
#define FC_N_Port_Common_Parms_Valid_Vendor_Version_Level                 0x20000000

#define FC_N_Port_Common_Parms_N_Port_F_Port_MASK                         0x10000000
#define FC_N_Port_Common_Parms_N_Port                                     0x00000000
#define FC_N_Port_Common_Parms_F_Port                                     0x10000000

#define FC_N_Port_Common_Parms_Alternate_BB_Credit_Management             0x08000000
#define FC_N_Port_Common_Parms_Multicast_Supported                        0x02000000
#define FC_N_Port_Common_Parms_Broadcast_Supported                        0x01000000
#define FC_N_Port_Common_Parms_Dedicated_Simplex_Supported                0x00400000

#define FC_N_Port_Common_Parms_BB_Recv_Data_Field_Size_MASK               0x00000FFF
#define FC_N_Port_Common_Parms_BB_Recv_Data_Field_Size_SHIFT                    0x00

#define FC_N_Port_Common_Parms_Total_Concurrent_Sequences_MASK            0x00FF0000
#define FC_N_Port_Common_Parms_Total_Concurrent_Sequences_SHIFT                 0x10

#define FC_N_Port_Common_Parms_RO_by_Info_Category_MASK                   0x0000FFFF
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_1111                 0x00008000
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_1110                 0x00004000
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_1101                 0x00002000
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_1100                 0x00001000
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_1011                 0x00000800
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_1010                 0x00000400
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_1001                 0x00000200
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_1000                 0x00000100
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_0111                 0x00000080
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_0110                 0x00000040
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_0101                 0x00000020
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_0100                 0x00000010
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_0011                 0x00000008
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_0010                 0x00000004
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_0001                 0x00000002
#define FC_N_Port_Common_Parms_RO_Valid_for_Category_0000                 0x00000001

typedef struct FC_N_Port_Class_Parms_s
               FC_N_Port_Class_Parms_t;

#define FC_N_Port_Class_Parms_t_SIZE                                      0x00000010

struct FC_N_Port_Class_Parms_s
       {
         os_bit32 Class_Validity__Service_Options__Initiator_Control_Flags;
         os_bit32 Recipient_Control_Flags__Receive_Data_Size;
         os_bit32 Concurrent_Sequences__EE_Credit;
         os_bit32 Open_Sequences_per_Exchange;
       };

#define FC_N_Port_Class_Parms_Class_Validity                              0x80000000

#define FC_N_Port_Class_Parms_Service_Options_MASK                        0x7FFF0000
#define FC_N_Port_Class_Parms_Intermix_Requested_or_Functional            0x40000000
#define FC_N_Port_Class_Parms_Stacked_Connect_Requests_Transparent_Mode   0x20000000
#define FC_N_Port_Class_Parms_Stacked_Connect_Requests_Lock_Down_Mode     0x10000000

#define FC_F_Port_Class_Parms_SCR_Support_MASK                            0x30000000
#define FC_F_Port_Class_Parms_SCR_Not_Supported                           0x00000000
#define FC_F_Port_Class_Parms_SCR_Lock_Down_Mode                          0x10000000
#define FC_F_Port_Class_Parms_SCR_Transparent_Mode                        0x20000000
#define FC_F_Port_Class_Parms_SCR_Invalid                                 0x30000000

#define FC_N_Port_Class_Parms_Sequential_Delivery_Requested               0x08000000
#define FC_N_Port_Class_Parms_Dedicated_Simplex_Supported                 0x04000000
#define FC_N_Port_Class_Parms_Dedicated_Camp_On_Supported                 0x02000000
#define FC_N_Port_Class_Parms_Buffered_Class_1_Requested_or_Supported     0x01000000

#define FC_N_Port_Class_Parms_Initiator_Control_MASK                      0x0000FFFF

#define FC_N_Port_Class_Parms_X_ID_Reassignment_MASK                      0x0000C000
#define FC_N_Port_Class_Parms_X_ID_Reassignment_Not_Supported             0x00000000
#define FC_N_Port_Class_Parms_X_ID_Reassignment_Supported                 0x00004000
#define FC_N_Port_Class_Parms_X_ID_Reassignment_Required                  0x0000C000

#define FC_N_Port_Class_Parms_Initial_Process_Associator_MASK             0x00003000
#define FC_N_Port_Class_Parms_Initial_Process_Associator_Not_Supported    0x00000000
#define FC_N_Port_Class_Parms_Initial_Process_Associator_Supported        0x00001000
#define FC_N_Port_Class_Parms_Initial_Process_Associator_Required         0x00003000

#define FC_N_Port_Class_Parms_Initiator_ACK_0_Capable                     0x00000800

#define FC_N_Port_Class_Parms_Initiator_ACK_N_Capable                     0x00000400

#define FC_N_Port_Class_Parms_Recipient_Control_MASK                      0xFFFF0000

#define FC_N_Port_Class_Parms_Recipient_ACK_0_Capable                     0x80000000

#define FC_N_Port_Class_Parms_Recipient_ACK_N_Capable                     0x40000000

#define FC_N_Port_Class_Parms_X_ID_Interlock_Required                     0x20000000

#define FC_N_Port_Class_Parms_Error_Policy_Supported_MASK                 0x18000000
#define FC_N_Port_Class_Parms_Only_Discard_Supported                      0x00000000
#define FC_N_Port_Class_Parms_Both_Discard_and_Process_Supported          0x18000000

#define FC_N_Port_Class_Parms_Categories_per_Sequence_MASK                0x03000000
#define FC_N_Port_Class_Parms_1_Category_per_Sequence                     0x00000000
#define FC_N_Port_Class_Parms_2 Categories_per_Sequence                   0x01000000
#define FC_N_Port_Class_Parms_More_than_2_Categories_per_Sequence         0x03000000

#define FC_N_Port_Class_Parms_Receive_Data_Size_MASK                      0x0000FFFF
#define FC_N_Port_Class_Parms_Receive_Data_Size_SHIFT                           0x00

#define FC_N_Port_Class_Parms_Concurrent_Sequences_MASK                   0xFFFF0000
#define FC_N_Port_Class_Parms_Concurrent_Sequences_SHIFT                        0x10

#define FC_N_Port_Class_Parms_EE_Credit_MASK                              0x00007FFF
#define FC_N_Port_Class_Parms_EE_Credit_SHIFT                                   0x00

#define FC_N_Port_Class_Parms_Open_Sequences_per_Exchange_MASK            0x00FF0000
#define FC_N_Port_Class_Parms_Open_Sequences_per_Exchange_SHIFT                 0x10

typedef struct FC_F_Port_Common_Parms_s
               FC_F_Port_Common_Parms_t;

#define FC_F_Port_Common_Parms_t_SIZE                                     0x00000010

struct FC_F_Port_Common_Parms_s
       {
         os_bit32 FC_PH_Version__BB_Credit;
         os_bit32 Common_Features__BB_Recv_Data_Field_Size;
         os_bit32 R_A_TOV;
         os_bit32 E_D_TOV;
       };

#define FC_F_Port_Common_Parms_Highest_Version_MASK                       0xFF000000
#define FC_F_Port_Common_Parms_Highest_Version_SHIFT                            0x18

#define FC_F_Port_Common_Parms_Lowest_Version_MASK                        0x00FF0000
#define FC_F_Port_Common_Parms_Lowest_Version_SHIFT                             0x10

#define FC_F_Port_Common_Parms_Version_4_0                                      0x06
#define FC_F_Port_Common_Parms_Version_4_1                                      0x07
#define FC_F_Port_Common_Parms_Version_4_2                                      0x08
#define FC_F_Port_Common_Parms_Version_4_3                                      0x09
#define FC_F_Port_Common_Parms_Version_FC_PH_2                                  0x10

#define FC_F_Port_Common_Parms_BB_Credit_MASK                             0x0000FFFF
#define FC_F_Port_Common_Parms_BB_Credit_SHIFT                                  0x00

#define FC_F_Port_Common_Parms_Continuously_Increasing_Supported          0x80000000
#define FC_F_Port_Common_Parms_Random_Relative_Offset_Supported           0x40000000
#define FC_F_Port_Common_Parms_Valid_Vendor_Version_Level                 0x20000000

#define FC_F_Port_Common_Parms_N_Port_F_Port_MASK                         0x10000000
#define FC_F_Port_Common_Parms_N_Port                                     0x00000000
#define FC_F_Port_Common_Parms_F_Port                                     0x10000000

#define FC_F_Port_Common_Parms_Alternate_BB_Credit_Management             0x08000000
#define FC_F_Port_Common_Parms_Multicast_Supported                        0x02000000
#define FC_F_Port_Common_Parms_Broadcast_Supported                        0x01000000
#define FC_F_Port_Common_Parms_Dedicated_Simplex_Supported                0x00400000

#define FC_F_Port_Common_Parms_BB_Recv_Data_Field_Size_MASK               0x00000FFF
#define FC_F_Port_Common_Parms_BB_Recv_Data_Field_Size_SHIFT                    0x00

typedef struct FC_F_Port_Class_Parms_s
               FC_F_Port_Class_Parms_t;

#define FC_F_Port_Class_Parms_t_SIZE                                      0x00000010

struct FC_F_Port_Class_Parms_s
       {
         os_bit32 Class_Validity__Service_Options;
         os_bit32 Reserved_1;
         os_bit32 Reserved_2;
         os_bit32 CR_TOV;
       };

#define FC_F_Port_Class_Parms_Class_Validity                              0x80000000

#define FC_F_Port_Class_Parms_Service_Options_MASK                        0x7FFF0000
#define FC_F_Port_Class_Parms_Intermix_Requested_or_Functional            0x40000000
#define FC_F_Port_Class_Parms_Stacked_Connect_Requests_Transparent_Mode   0x20000000
#define FC_F_Port_Class_Parms_Stacked_Connect_Requests_Lock_Down_Mode     0x10000000

#define FC_F_Port_Class_Parms_SCR_Support_MASK                            0x30000000
#define FC_F_Port_Class_Parms_SCR_Not_Supported                           0x00000000
#define FC_F_Port_Class_Parms_SCR_Lock_Down_Mode                          0x10000000
#define FC_F_Port_Class_Parms_SCR_Transparent_Mode                        0x20000000
#define FC_F_Port_Class_Parms_SCR_Invalid                                 0x30000000

#define FC_F_Port_Class_Parms_Sequential_Delivery_Requested               0x08000000
#define FC_F_Port_Class_Parms_Dedicated_Simplex_Supported                 0x04000000
#define FC_F_Port_Class_Parms_Dedicated_Camp_On_Supported                 0x02000000
#define FC_F_Port_Class_Parms_Buffered_Class_1_Requested_or_Supported     0x01000000

typedef os_bit8 FC_Port_Name_t            [ 8];
typedef os_bit8 FC_N_Port_Name_t          [ 8];
typedef os_bit8 FC_F_Port_Name_t          [ 8];

typedef os_bit8 FC_Node_or_Fabric_Name_t  [ 8];
typedef os_bit8 FC_Node_Name_t            [ 8];
typedef os_bit8 FC_Fabric_Name_t          [ 8];

typedef os_bit8 FC_Vendor_Version_Level_t [16];

#define FC_Port_Name_t_SIZE                                               0x00000008
#define FC_N_Port_Name_t_SIZE                                             0x00000008
#define FC_F_Port_Name_t_SIZE                                             0x00000008

#define FC_Node_or_Fabric_Name_t_SIZE                                     0x00000008
#define FC_Node_Name_t_SIZE                                               0x00000008
#define FC_Fabric_Name_t_SIZE                                             0x00000008

#define FC_Vendor_Version_Level_t_SIZE                                    0x00000010

/*+
Association Header (Section 19.4, FC-PH)
-*/

typedef struct FC_Association_Header_s
               FC_Association_Header_t;

#define FC_Association_Header_t_SIZE                                      0x00000020

struct FC_Association_Header_s
       {
         os_bit32 Validity_Bits;
         os_bit32 Originator_Process_Associator;
         os_bit32 Reserved;
         os_bit32 Responder_Process_Associator;
         os_bit32 Originator_Operation_Associator_Hi;
         os_bit32 Originator_Operation_Associator_Lo;
         os_bit32 Responder_Operation_Associator_Hi;
         os_bit32 Responder_Operation_Associator_Lo;
       };

#define FC_Association_Header_Originator_Process_Associator_Meaningful    0x80000000
#define FC_Association_Header_Responder_Process_Associator_Meaningful     0x40000000
#define FC_Association_Header_Originator_Operation_Associator_Meaningful  0x20000000
#define FC_Association_Header_Responder_Operation_Associator_Meaningful   0x10000000

/*+
Extended Link Services (Sections 21.3-21.5, FC-PH
                 and Sections 21.3-21.19, FC-PH-2
                          and Section 6, FCP-SCSI
                            and Annex A, FCP-SCSI)
-*/

#define FC_ELS_Type_MASK                                                  0xFF000000
#define FC_ELS_Type_LS_RJT                                                0x01000000
#define FC_ELS_Type_ACC                                                   0x02000000
#define FC_ELS_Type_PLOGI                                                 0x03000000
#define FC_ELS_Type_FLOGI                                                 0x04000000
#define FC_ELS_Type_LOGO                                                  0x05000000
#define FC_ELS_Type_ABTX                                                  0x06000000
#define FC_ELS_Type_RCS                                                   0x07000000
#define FC_ELS_Type_RES                                                   0x08000000
#define FC_ELS_Type_RSS                                                   0x09000000
#define FC_ELS_Type_RSI                                                   0x0A000000
#define FC_ELS_Type_ESTS                                                  0x0B000000
#define FC_ELS_Type_ESTC                                                  0x0C000000
#define FC_ELS_Type_ADVC                                                  0x0D000000
#define FC_ELS_Type_RTV                                                   0x0E000000
#define FC_ELS_Type_RLS                                                   0x0F000000
#define FC_ELS_Type_ECHO                                                  0x10000000
#define FC_ELS_Type_TEST                                                  0x11000000
#define FC_ELS_Type_RRQ                                                   0x12000000
#define FC_ELS_Type_REC                                                   0x13000000
#define FC_ELS_Type_SRR                                                   0x14000000
#define FC_ELS_Type_PRLI                                                  0x20000000
#define FC_ELS_Type_PRLO                                                  0x21000000
#define FC_ELS_Type_SCN                                                   0x22000000
#define FC_ELS_Type_TPLS                                                  0x23000000
#define FC_ELS_Type_TPRLO                                                 0x24000000
#define FC_ELS_Type_GAID                                                  0x30000000
#define FC_ELS_Type_FACT                                                  0x31000000
#define FC_ELS_Type_FDACT                                                 0x32000000
#define FC_ELS_Type_NACT                                                  0x33000000
#define FC_ELS_Type_NDACT                                                 0x34000000
#define FC_ELS_Type_QoSR                                                  0x40000000
#define FC_ELS_Type_RVCS                                                  0x41000000
#define FC_ELS_Type_PDISC                                                 0x50000000
#define FC_ELS_Type_FDISC                                                 0x51000000
#define FC_ELS_Type_ADISC                                                 0x52000000
#ifdef _DvrArch_1_30_
#define FC_ELS_Type_FARP_REQ                                              0x54000000
#define FC_ELS_Type_FARP_REPLY                                            0x55000000
#endif /* _DvrArch_1_30_ was defined */

#define FC_ELS_Type_FAN                                                   0x60000000

#define FC_ELS_Type_RSCN                                                  0x61000000
#define FC_ELS_Type_SCR                                                   0x62000000


typedef struct FC_ELS_Unknown_Payload_s
               FC_ELS_Unknown_Payload_t;

#define FC_ELS_Unknown_Payload_t_SIZE                                     0x00000004

struct FC_ELS_Unknown_Payload_s
       {
         os_bit32 ELS_Type; /* & FC_ELS_Type_MASK == FC_ELS_Type_XXX */
       };

typedef struct FC_ELS_LS_RJT_Payload_s
               FC_ELS_LS_RJT_Payload_t;

#define FC_ELS_LS_RJT_Payload_t_SIZE                                      0x00000008

struct FC_ELS_LS_RJT_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_LS_RJT */
         os_bit32 Reason_Code__Reason_Explanation__Vendor_Unique;
       };

#define FC_ELS_LS_RJT_Reason_Code_MASK                                    0x00FF0000
#define FC_ELS_LS_RJT_Reason_Code_Shift                                   16
#define FC_ELS_LS_RJT_Invalid_LS_Command_Code                             0x00010000
#define FC_ELS_LS_RJT_Logical_Error                                       0x00030000
#define FC_ELS_LS_RJT_Logical_Busy                                        0x00050000
#define FC_ELS_LS_RJT_Protocol_Error                                      0x00070000
#define FC_ELS_LS_RJT_Unable_to_perform_command_request                   0x00090000
#define FC_ELS_LS_RJT_Command_Not_Supported                               0x000B0000
#define FC_ELS_LS_RJT_Vendor_Unique_Error                                 0x00FF0000

#define FC_ELS_LS_RJT_Shifted_Invalid_LS_Command_Code              (FC_ELS_LS_RJT_Invalid_LS_Command_Code               >> FC_ELS_LS_RJT_Reason_Code_Shift )
#define FC_ELS_LS_RJT_Shifted_Logical_Error                        (FC_ELS_LS_RJT_Logical_Error                         >> FC_ELS_LS_RJT_Reason_Code_Shift )
#define FC_ELS_LS_RJT_Shifted_Logical_Busy                         (FC_ELS_LS_RJT_Logical_Busy                          >> FC_ELS_LS_RJT_Reason_Code_Shift )
#define FC_ELS_LS_RJT_Shifted_Protocol_Error                       (FC_ELS_LS_RJT_Protocol_Error                        >> FC_ELS_LS_RJT_Reason_Code_Shift )
#define FC_ELS_LS_RJT_Shifted_Unable_to_perform_command_request    (FC_ELS_LS_RJT_Unable_to_perform_command_request     >> FC_ELS_LS_RJT_Reason_Code_Shift )
#define FC_ELS_LS_RJT_Shifted_Command_Not_Supported                (FC_ELS_LS_RJT_Command_Not_Supported                 >> FC_ELS_LS_RJT_Reason_Code_Shift )
#define FC_ELS_LS_RJT_Shifted_Vendor_Unique_Error                  (FC_ELS_LS_RJT_Vendor_Unique_Error                   >> FC_ELS_LS_RJT_Reason_Code_Shift )

#define FC_ELS_LS_RJT_Reason_Explanation_Shift                            8
#define FC_ELS_LS_RJT_Reason_Explanation_MASK                             0x0000FF00
#define FC_ELS_LS_RJT_No_Additional_Explanation                           0x00000000
#define FC_ELS_LS_RJT_Service_Parm_Error_Options                          0x00000100
#define FC_ELS_LS_RJT_Service_Parm_Error_Initiator_Ctl                    0x00000300
#define FC_ELS_LS_RJT_Service_Parm_Error_Recipient_Ctl                    0x00000500
#define FC_ELS_LS_RJT_Service_Parm_Error_Rec_Data_Field_Size              0x00000700
#define FC_ELS_LS_RJT_Service_Parm_Error_Concurrent_Seq                   0x00000900
#define FC_ELS_LS_RJT_Service_Parm_Error_Credit                           0x00000B00
#define FC_ELS_LS_RJT_Invalid_N_Port_F_Port_Name                          0x00000D00
#define FC_ELS_LS_RJT_Invalid_Node_Fabric_Name                            0x00000E00
#define FC_ELS_LS_RJT_Invalid_Common_Service_Parameters                   0x00000F00
#define FC_ELS_LS_RJT_Invalid_Association_Header                          0x00001100
#define FC_ELS_LS_RJT_Association_Header_Required                         0x00001300
#define FC_ELS_LS_RJT_Invalid_Originator_S_ID                             0x00001500
#define FC_ELS_LS_RJT_Invalid_OX_ID_RX_ID_Combination                     0x00001700
#define FC_ELS_LS_RJT_Command_Request_Already_In_Progress                 0x00001900
#define FC_ELS_LS_RJT_Invalid_N_Port_Identifier                           0x00001F00
#define FC_ELS_LS_RJT_Invalid_SEQ_ID                                      0x00002100
#define FC_ELS_LS_RJT_Attempt_to_Abort_Invalid_Exchange                   0x00002300
#define FC_ELS_LS_RJT_Attempt_to_Abort_Inactive_Exchange                  0x00002500
#define FC_ELS_LS_RJT_Recovery_Qualifier_Required                         0x00002700
#define FC_ELS_LS_RJT_Insufficient_Resources_to_Support_Login             0x00002900
#define FC_ELS_LS_RJT_Unable_to_Supply_Requested_Data                     0x00002A00
#define FC_ELS_LS_RJT_Request_Not_Supported                               0x00002C00
#define FC_ELS_LS_RJT_No_Alias_IDs_Available_for_this_Alias_Type          0x00003000
#define FC_ELS_LS_RJT_Alias_ID_Cannot_Be_Activated__No_Resources          0x00003100
#define FC_ELS_LS_RJT_Alias_ID_Cannot_Be_Activated__Invalid_Alias_ID      0x00003200
#define FC_ELS_LS_RJT_Alias_ID_Cannot_Be_Activated__Does_Not_Exist        0x00003300
#define FC_ELS_LS_RJT_Alias_ID_Cannot_Be_Activated__Resource_Problem      0x00003400
#define FC_ELS_LS_RJT_Service_Parameter_Conflict                          0x00003500
#define FC_ELS_LS_RJT_Invalid_Alias_Token                                 0x00003600
#define FC_ELS_LS_RJT_Unsupported_Alias_Token                             0x00003700
#define FC_ELS_LS_RJT_Alias_Group_Can_Not_Be_Formed                       0x00003800
#define FC_ELS_LS_RJT_QoS_Parm_Error                                      0x00004000
#define FC_ELS_LS_RJT_VC_ID_Not_Found                                     0x00004100
#define FC_ELS_LS_RJT_Insufficient_Resources_For_Class_4_Connection       0x00004200

#define FC_ELS_LS_RJT_Shifted_No_Additional_Explanation                           (FC_ELS_LS_RJT_No_Additional_Explanation >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Service_Parm_Error_Options                          (FC_ELS_LS_RJT_Service_Parm_Error_Options>> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Service_Parm_Error_Initiator_Ctl                    (FC_ELS_LS_RJT_Service_Parm_Error_Initiator_Ctl>> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Service_Parm_Error_Recipient_Ctl                    (FC_ELS_LS_RJT_Service_Parm_Error_Recipient_Ctl >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Service_Parm_Error_Rec_Data_Field_Size              (FC_ELS_LS_RJT_Service_Parm_Error_Rec_Data_Field_Size>> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Service_Parm_Error_Concurrent_Seq                   (FC_ELS_LS_RJT_Service_Parm_Error_Concurrent_Seq >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Service_Parm_Error_Credit                           (FC_ELS_LS_RJT_Service_Parm_Error_Credit >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Invalid_N_Port_F_Port_Name                          (FC_ELS_LS_RJT_Invalid_N_Port_F_Port_Name >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Invalid_Node_Fabric_Name                            (FC_ELS_LS_RJT_Invalid_Node_Fabric_Name >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Invalid_Common_Service_Parameters                   (FC_ELS_LS_RJT_Invalid_Common_Service_Parameters >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Invalid_Association_Header                          (FC_ELS_LS_RJT_Invalid_Association_Header >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Association_Header_Required                         (FC_ELS_LS_RJT_Association_Header_Required >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Invalid_Originator_S_ID                             (FC_ELS_LS_RJT_Invalid_Originator_S_ID >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Invalid_OX_ID_RX_ID_Combination                     (FC_ELS_LS_RJT_Invalid_OX_ID_RX_ID_Combination >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Command_Request_Already_In_Progress                 (FC_ELS_LS_RJT_Command_Request_Already_In_Progress >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Invalid_N_Port_Identifier                           (FC_ELS_LS_RJT_Invalid_N_Port_Identifier >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Invalid_SEQ_ID                                      (FC_ELS_LS_RJT_Invalid_SEQ_ID >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Attempt_to_Abort_Invalid_Exchange                   (FC_ELS_LS_RJT_Attempt_to_Abort_Invalid_Exchange >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Attempt_to_Abort_Inactive_Exchange                  (FC_ELS_LS_RJT_Attempt_to_Abort_Inactive_Exchange >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Recovery_Qualifier_Required                         (FC_ELS_LS_RJT_Recovery_Qualifier_Required >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Insufficient_Resources_to_Support_Login             (FC_ELS_LS_RJT_Insufficient_Resources_to_Support_Login >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Unable_to_Supply_Requested_Data                     (FC_ELS_LS_RJT_Unable_to_Supply_Requested_Data >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Request_Not_Supported                               (FC_ELS_LS_RJT_Request_Not_Supported >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_No_Alias_IDs_Available_for_this_Alias_Type          (FC_ELS_LS_RJT_No_Alias_IDs_Available_for_this_Alias_Type >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Alias_ID_Cannot_Be_Activated__No_Resources          (FC_ELS_LS_RJT_Alias_ID_Cannot_Be_Activated__No_Resources >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Alias_ID_Cannot_Be_Activated__Invalid_Alias_ID      (FC_ELS_LS_RJT_Alias_ID_Cannot_Be_Activated__Invalid_Alias_ID >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Alias_ID_Cannot_Be_Activated__Does_Not_Exist        (FC_ELS_LS_RJT_Alias_ID_Cannot_Be_Activated__Does_Not_Exist >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Alias_ID_Cannot_Be_Activated__Resource_Problem      (FC_ELS_LS_RJT_Alias_ID_Cannot_Be_Activated__Resource_Problem >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Service_Parameter_Conflict                          (FC_ELS_LS_RJT_Service_Parameter_Conflict >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Invalid_Alias_Token                                 (FC_ELS_LS_RJT_Invalid_Alias_Token >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Unsupported_Alias_Token                             (FC_ELS_LS_RJT_Unsupported_Alias_Token >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Alias_Group_Can_Not_Be_Formed                       (FC_ELS_LS_RJT_Alias_Group_Can_Not_Be_Formed >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_QoS_Parm_Error                                      (FC_ELS_LS_RJT_QoS_Parm_Error >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_VC_ID_Not_Found                                     (FC_ELS_LS_RJT_VC_ID_Not_Found >> FC_ELS_LS_RJT_Reason_Explanation_Shift)
#define FC_ELS_LS_RJT_Shifted_Insufficient_Resources_For_Class_4_Connection       (FC_ELS_LS_RJT_Insufficient_Resources_For_Class_4_Connection >> FC_ELS_LS_RJT_Reason_Explanation_Shift)

#define FC_ELS_LS_RJT_Vendor_Unique_MASK                                  0x000000FF

typedef struct FC_ELS_ACC_Unknown_Payload_s
               FC_ELS_ACC_Unknown_Payload_t;

#define FC_ELS_ACC_Unknown_Payload_t_SIZE                                 0x00000004

struct FC_ELS_ACC_Unknown_Payload_s
       {
         os_bit32 ELS_Type; /* & FC_ELS_Type_MASK == FC_ELS_Type_ACC */
       };

typedef struct FC_ELS_PLOGI_Payload_s
               FC_ELS_PLOGI_Payload_t;

#define FC_ELS_PLOGI_Payload_t_SIZE                                       0x00000074

struct FC_ELS_PLOGI_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_PLOGI */
         FC_N_Port_Common_Parms_t  Common_Service_Parameters;
         FC_N_Port_Name_t          N_Port_Name;
         FC_Node_Name_t            Node_Name;
         FC_N_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_ACC_PLOGI_Payload_s
               FC_ELS_ACC_PLOGI_Payload_t;

#define FC_ELS_ACC_PLOGI_Payload_t_SIZE                                   0x00000074

struct FC_ELS_ACC_PLOGI_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_ACC */
         FC_N_Port_Common_Parms_t  Common_Service_Parameters;
         FC_N_Port_Name_t          N_Port_Name;
         FC_Node_Name_t            Node_Name;
         FC_N_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_FLOGI_Payload_s
               FC_ELS_FLOGI_Payload_t;

#define FC_ELS_FLOGI_Payload_t_SIZE                                       0x00000074

struct FC_ELS_FLOGI_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_FLOGI */
         FC_N_Port_Common_Parms_t  Common_Service_Parameters;
         FC_N_Port_Name_t          N_Port_Name;
         FC_Node_Name_t            Node_Name;
         FC_N_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_ACC_FLOGI_Payload_s
               FC_ELS_ACC_FLOGI_Payload_t;

#define FC_ELS_ACC_FLOGI_Payload_t_SIZE                                   0x00000074

struct FC_ELS_ACC_FLOGI_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_ACC */
         FC_F_Port_Common_Parms_t  Common_Service_Parameters;
         FC_F_Port_Name_t          F_Port_Name;
         FC_Fabric_Name_t          Fabric_Name;
         FC_F_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_F_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_F_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_LOGO_Payload_s
               FC_ELS_LOGO_Payload_t;

#define FC_ELS_LOGO_Payload_t_SIZE                                        0x00000010

struct FC_ELS_LOGO_Payload_s
       {
         os_bit32          ELS_Type; /* == FC_ELS_Type_LOGO */
         os_bit32          N_Port_Identifier;
         FC_Port_Name_t Port_Name;
       };

#define FC_ELS_LOGO_N_Port_Identifier_MASK                                0x00FFFFFF

typedef struct FC_ELS_ACC_LOGO_Payload_s
               FC_ELS_ACC_LOGO_Payload_t;

#define FC_ELS_ACC_LOGO_Payload_t_SIZE                                    0x00000004

struct FC_ELS_ACC_LOGO_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
       };
typedef struct FC_ELS_GENERIC_ACC_Payload_s
               FC_ELS_GENERIC_ACC_Payload_t;

#define FC_ELS_GENERIC_ACC_Payload_t_SIZE                                    0x00000004

struct FC_ELS_GENERIC_ACC_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
       };
typedef struct FC_ELS_ABTX_Payload_s
               FC_ELS_ABTX_Payload_t;

#define FC_ELS_ABTX_Payload_t_SIZE                                        0x0000002C

struct FC_ELS_ABTX_Payload_s
       {
         os_bit32                   ELS_Type; /* == FC_ELS_Type_ABTX */
         os_bit32                   Recovery_Qualifier__Originator_S_ID;
         os_bit32                   OX_ID__RX_ID;
         FC_Association_Header_t Association_Header;
       };

#define FC_ELS_ABTX_Recovery_Qualifier_MASK                               0xFF000000
#define FC_ELS_ABTX_No_Recovery_Qualifier                                 0x00000000
#define FC_ELS_ABTX_Recovery_Qualifier_Required                           0x80000000

#define FC_ELS_ABTX_Originator_S_ID_MASK                                  0x00FFFFFF
#define FC_ELS_ABTX_Originator_S_ID_SHIFT                                       0x00

#define FC_ELS_ABTX_OX_ID_MASK                                            0xFFFF0000
#define FC_ELS_ABTX_OX_ID_SHIFT                                                 0x10

#define FC_ELS_ABTX_RX_ID_MASK                                            0x0000FFFF
#define FC_ELS_ABTX_RX_ID_SHIFT                                                 0x00

typedef struct FC_ELS_ACC_ABTX_Payload_s
               FC_ELS_ACC_ABTX_Payload_t;

#define FC_ELS_ACC_ABTX_Payload_t_SIZE                                    0x00000004

struct FC_ELS_ACC_ABTX_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
       };

typedef struct FC_ELS_RCS_Payload_s
               FC_ELS_RCS_Payload_t;

#define FC_ELS_RCS_Payload_t_SIZE                                         0x00000008

struct FC_ELS_RCS_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_RCS */
         os_bit32 N_Port_Identifier;
       };

#define FC_ELS_RCS_N_Port_Identifier_MASK                                 0x00FFFFFF

typedef struct FC_ELS_ACC_RCS_Payload_s
               FC_ELS_ACC_RCS_Payload_t;

#define FC_ELS_ACC_RCS_Payload_t_SIZE                                     0x00000008

struct FC_ELS_ACC_RCS_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
         os_bit32 Completion_Status__N_Port_Identifier;
       };

#define FC_ELS_ACC_RCS_Completion_Status_MASK                             0xFF000000
#define FC_ELS_ACC_RCS_Connect_Request_Delivered                          0x80000000
#define FC_ELS_ACC_RCS_Connect_Request_Stacked                            0x40000000
#define FC_ELS_ACC_RCS_Connection_Established                             0x20000000
#define FC_ELS_ACC_RCS_Intermix_Mode                                      0x10000000

#define FC_ELS_ACC_RCS_N_Port_Identifier_MASK                             0x00FFFFFF

typedef struct FC_ELS_RES_Payload_s
               FC_ELS_RES_Payload_t;

#define FC_ELS_RES_Payload_t_SIZE                                         0x0000002C

struct FC_ELS_RES_Payload_s
       {
         os_bit32                   ELS_Type; /* == FC_ELS_Type_RES */
         os_bit32                   Originator_S_ID;
         os_bit32                   OX_ID__RX_ID;
         FC_Association_Header_t Association_Header;
       };

#define FC_ELS_RES_Originator_S_ID_MASK                                   0x00FFFFFF
#define FC_ELS_RES_Originator_S_ID_SHIFT                                        0x00

#define FC_ELS_RES_OX_ID_MASK                                             0xFFFF0000
#define FC_ELS_RES_OX_ID_SHIFT                                                  0x10

#define FC_ELS_RES_RX_ID_MASK                                             0x0000FFFF
#define FC_ELS_RES_RX_ID_SHIFT                                                  0x00

typedef struct FC_ELS_ACC_RES_Payload_s
               FC_ELS_ACC_RES_Payload_t;

#define FC_ELS_ACC_RES_Payload_t_SIZE                                     0x00000024

struct FC_ELS_ACC_RES_Payload_s
       {
         os_bit32                   ELS_Type; /* == FC_ELS_Type_ACC */
                                 /* Dynamically-sized Exchange Status Block goes here */
         FC_Association_Header_t Association_Header;
       };

typedef struct FC_ELS_RSS_Payload_s
               FC_ELS_RSS_Payload_t;

#define FC_ELS_RSS_Payload_t_SIZE                                         0x0000000C

struct FC_ELS_RSS_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_RSS */
         os_bit32 SEQ_ID__Originator_S_ID;
         os_bit32 OX_ID__RX_ID;
       };

#define FC_ELS_RSS_SEQ_ID_MASK                                            0xFF000000
#define FC_ELS_RSS_SEQ_ID_SHIFT                                                 0x18

#define FC_ELS_RSS_Originator_S_ID_MASK                                   0x00FFFFFF
#define FC_ELS_RSS_Originator_S_ID_SHIFT                                        0x00

#define FC_ELS_RSS_OX_ID_MASK                                             0xFFFF0000
#define FC_ELS_RSS_OX_ID_SHIFT                                                  0x10

#define FC_ELS_RSS_RX_ID_MASK                                             0x0000FFFF
#define FC_ELS_RSS_RX_ID_SHIFT                                                  0x00

typedef struct FC_ELS_ACC_RSS_Payload_s
               FC_ELS_ACC_RSS_Payload_t;

#define FC_ELS_ACC_RSS_Payload_t_SIZE                                     0x00000004

struct FC_ELS_ACC_RSS_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
               /* Dynamically-sized Sequence Status Block goes here */
       };

typedef struct FC_ELS_RSI_Payload_s
               FC_ELS_RSI_Payload_t;

#define FC_ELS_RSI_Payload_t_SIZE                                         0x0000002C

struct FC_ELS_RSI_Payload_s
       {
         os_bit32                   ELS_Type; /* == FC_ELS_Type_RSI */
         os_bit32                   Originator_S_ID;
         os_bit32                   OX_ID__RX_ID;
         FC_Association_Header_t Association_Header;
       };

#define FC_ELS_RSI_Originator_S_ID_MASK                                   0x00FFFFFF
#define FC_ELS_RSI_Originator_S_ID_SHIFT                                        0x00

#define FC_ELS_RSI_OX_ID_MASK                                             0xFFFF0000
#define FC_ELS_RSI_OX_ID_SHIFT                                                  0x10

#define FC_ELS_RSI_RX_ID_MASK                                             0x0000FFFF
#define FC_ELS_RSI_RX_ID_SHIFT                                                  0x00

typedef struct FC_ELS_ACC_RSI_Payload_s
               FC_ELS_ACC_RSI_Payload_t;

#define FC_ELS_ACC_RSI_Payload_t_SIZE                                     0x00000004

struct FC_ELS_ACC_RSI_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
       };

typedef struct FC_ELS_ESTS_Payload_s
               FC_ELS_ESTS_Payload_t;

#define FC_ELS_ESTS_Payload_t_SIZE                                        0x00000004

struct FC_ELS_ESTS_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ESTS */
       };

typedef struct FC_ELS_ACC_ESTS_Payload_s
               FC_ELS_ACC_ESTS_Payload_t;

#define FC_ELS_ACC_ESTS_Payload_t_SIZE                                    0x00000074

struct FC_ELS_ACC_ESTS_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_ACC */
         FC_N_Port_Common_Parms_t  Common_Service_Parameters;
         FC_N_Port_Name_t          N_Port_Name;
         FC_Node_Name_t            Node_Name;
         FC_N_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_ESTC_Payload_s
               FC_ELS_ESTC_Payload_t;

#define FC_ELS_ESTC_Payload_t_SIZE                                        FC_Frame_Data_Size_Max

struct FC_ELS_ESTC_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ESTC */
         os_bit8  Any_Data[FC_Frame_Data_Size_Max - sizeof(os_bit32)];
       };

typedef struct FC_ELS_ADVC_Payload_s
               FC_ELS_ADVC_Payload_t;

#define FC_ELS_ADVC_Payload_t_SIZE                                        0x00000074

struct FC_ELS_ADVC_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_ADVC */
         FC_N_Port_Common_Parms_t  Common_Service_Parameters;
         FC_N_Port_Name_t          N_Port_Name;
         FC_Node_Name_t            Node_Name;
         FC_N_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_ACC_ADVC_Payload_s
               FC_ELS_ACC_ADVC_Payload_t;

#define FC_ELS_ACC_ADVC_Payload_t_SIZE                                    0x00000074

struct FC_ELS_ACC_ADVC_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_ACC */
         FC_N_Port_Common_Parms_t  Common_Service_Parameters;
         FC_N_Port_Name_t          N_Port_Name;
         FC_Node_Name_t            Node_Name;
         FC_N_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_RTV_Payload_s
               FC_ELS_RTV_Payload_t;

#define FC_ELS_RTV_Payload_t_SIZE                                         0x00000004

struct FC_ELS_RTV_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_RTV */
       };

typedef struct FC_ELS_ACC_RTV_Payload_s
               FC_ELS_ACC_RTV_Payload_t;

#define FC_ELS_ACC_RTV_Payload_t_SIZE                                     0x0000000C

struct FC_ELS_ACC_RTV_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
         os_bit32 R_A_TOV;
         os_bit32 E_D_TOV;
       };

typedef struct FC_ELS_RLS_Payload_s
               FC_ELS_RLS_Payload_t;

#define FC_ELS_RLS_Payload_t_SIZE                                         0x00000008

struct FC_ELS_RLS_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_RLS */
         os_bit32 Port_Identifier;
       };

#define FC_ELS_RLS_Port_Identifier_MASK                                   0x00FFFFFF

typedef struct FC_ELS_ACC_RLS_Payload_s
               FC_ELS_ACC_RLS_Payload_t;

#define FC_ELS_ACC_RLS_Payload_t_SIZE                                     0x00000004

struct FC_ELS_ACC_RLS_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
               /* Link Error Status Block goes here */
       };

typedef struct FC_ELS_ECHO_Payload_s
               FC_ELS_ECHO_Payload_t;

#define FC_ELS_ECHO_Payload_t_SIZE                                        FC_Frame_Data_Size_Max

struct FC_ELS_ECHO_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ECHO */
         os_bit8  Echo_Data[FC_Frame_Data_Size_Max - sizeof(os_bit32)];
       };

typedef struct FC_ELS_ACC_ECHO_Payload_s
               FC_ELS_ACC_ECHO_Payload_t;

#define FC_ELS_ACC_ECHO_Payload_t_SIZE                                    FC_Frame_Data_Size_Max

struct FC_ELS_ACC_ECHO_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
         os_bit8  Echo_Data[FC_Frame_Data_Size_Max - sizeof(os_bit32)];
       };

typedef struct FC_ELS_TEST_Payload_s
               FC_ELS_TEST_Payload_t;

#define FC_ELS_TEST_Payload_t_SIZE                                        FC_Frame_Data_Size_Max

struct FC_ELS_TEST_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_TEST */
         os_bit8  Test_Data[FC_Frame_Data_Size_Max - sizeof(os_bit32)];
       };

typedef struct FC_ELS_RRQ_Payload_s
               FC_ELS_RRQ_Payload_t;

#define FC_ELS_RRQ_Payload_t_SIZE                                         0x0000002C

struct FC_ELS_RRQ_Payload_s
       {
         os_bit32                   ELS_Type; /* == FC_ELS_Type_RRQ */
         os_bit32                   Originator_S_ID;
         os_bit32                   OX_ID__RX_ID;
         FC_Association_Header_t Association_Header;
       };

#define FC_ELS_RRQ_Originator_S_ID_MASK                                   0x00FFFFFF
#define FC_ELS_RRQ_Originator_S_ID_SHIFT                                        0x00

#define FC_ELS_RRQ_OX_ID_MASK                                             0xFFFF0000
#define FC_ELS_RRQ_OX_ID_SHIFT                                                  0x10

#define FC_ELS_RRQ_RX_ID_MASK                                             0x0000FFFF
#define FC_ELS_RRQ_RX_ID_SHIFT                                                  0x00

typedef struct FC_ELS_ACC_RRQ_Payload_s
               FC_ELS_ACC_RRQ_Payload_t;

#define FC_ELS_ACC_RRQ_Payload_t_SIZE                                     0x00000004

struct FC_ELS_ACC_RRQ_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
       };

typedef struct FC_ELS_PRLI_Parm_Page_s
               FC_ELS_PRLI_Parm_Page_t;

#define FC_ELS_PRLI_Parm_Page_t_SIZE                                      0x00000010

struct FC_ELS_PRLI_Parm_Page_s
       {
         os_bit32 Type__Type_Extension__Flags;
         os_bit32 Originator_Process_Associator;
         os_bit32 Responder_Process_Associator;
         os_bit32 Service_Parameters;
       };

#define FC_ELS_PRLI_Parm_Type_MASK                                        0xFF000000
#define FC_ELS_PRLI_Parm_Type_SCSI_FCP                                    0x08000000

#define FC_ELS_PRLI_Parm_Type_Extension_MASK                              0x00FF0000

#define FC_ELS_PRLI_Parm_Flags_MASK                                       0x0000FFFF
#define FC_ELS_PRLI_Parm_Originator_Process_Associator_Valid              0x00008000
#define FC_ELS_PRLI_Parm_Responder_Process_Associator_Valid               0x00004000
#define FC_ELS_PRLI_Parm_Establish_Image_Pair                             0x00002000

#define FC_ELS_PRLI_Parm_Confirmed_Completion_Allowed                     0x00000080
#define FC_ELS_PRLI_Parm_Data_Overlay_Allowed                             0x00000040
#define FC_ELS_PRLI_Parm_Initiator_Function                               0x00000020
#define FC_ELS_PRLI_Parm_Target_Function                                  0x00000010
#define FC_ELS_PRLI_Parm_Command_Data_Mixed_Allowed                       0x00000008
#define FC_ELS_PRLI_Parm_Data_Response_Mixed_Allowed                      0x00000004
#define FC_ELS_PRLI_Parm_Read_XFER_RDY_Disabled                           0x00000002
#define FC_ELS_PRLI_Parm_Write_XFER_RDY_Disabled                          0x00000001

#define FC_PRLI_Parm_Pages_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_PRLI_Parm_Page_t))

typedef struct FC_ELS_PRLI_Payload_s
               FC_ELS_PRLI_Payload_t;

#define FC_ELS_PRLI_Payload_t_SIZE                                        (FC_Frame_Data_Size_Max - FC_ELS_PRLI_Parm_Page_t_SIZE + 4)

struct FC_ELS_PRLI_Payload_s
       {
         os_bit32                   ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_PRLI */
         FC_ELS_PRLI_Parm_Page_t Parm_Page[FC_PRLI_Parm_Pages_MAX];
       };

#define FC_ELS_PRLI_Page_Length_MASK                                      0x00FF0000
#define FC_ELS_PRLI_Page_Length_SHIFT                                           0x10

#define FC_ELS_PRLI_Payload_Length_MASK                                   0x0000FFFF
#define FC_ELS_PRLI_Payload_Length_SHIFT                                        0x00

typedef struct FC_ELS_ACC_PRLI_Parm_Page_s
               FC_ELS_ACC_PRLI_Parm_Page_t;

#define FC_ELS_ACC_PRLI_Parm_Page_t_SIZE                                  0x00000010

struct FC_ELS_ACC_PRLI_Parm_Page_s
       {
         os_bit32 Type__Type_Extension__Flags;
         os_bit32 Originator_Process_Associator;
         os_bit32 Responder_Process_Associator;
         os_bit32 Service_Parameters;
       };

#define FC_ELS_ACC_PRLI_Parm_Type_MASK                                    0xFF000000
#define FC_ELS_ACC_PRLI_Parm_Type_SCSI_FCP                                0x08000000

#define FC_ELS_ACC_PRLI_Parm_Type_Extension_MASK                          0x00FF0000

#define FC_ELS_ACC_PRLI_Parm_Flags_MASK                                   0x0000FFFF
#define FC_ELS_ACC_PRLI_Parm_Originator_Process_Associator_Valid          0x00008000
#define FC_ELS_ACC_PRLI_Parm_Responder_Process_Associator_Valid           0x00004000
#define FC_ELS_ACC_PRLI_Parm_Image_Pair_Established                       0x00002000

#define FC_ELS_ACC_PRLI_Parm_Flags_Response_Code_MASK                     0x00000F00
#define FC_ELS_ACC_PRLI_Parm_Flags_Response_Request_Executed              0x00000100
#define FC_ELS_ACC_PRLI_Parm_Flags_Response_No_Resources_Available        0x00000200
#define FC_ELS_ACC_PRLI_Parm_Flags_Response_Initialization_Not_Completed  0x00000300
#define FC_ELS_ACC_PRLI_Parm_Flags_Response_Target_Image_Does_Not_Exist   0x00000400
#define FC_ELS_ACC_PRLI_Parm_Flags_Response_Target_Image_Precluded        0x00000500
#define FC_ELS_ACC_PRLI_Parm_Flags_Response_Executed_Conditionally        0x00000600
#define FC_ELS_ACC_PRLI_Parm_Flags_Response_Multiple_Not_Supported        0x00000700

#define FC_ELS_ACC_PRLI_Parm_Initiator_Function                           0x00000020
#define FC_ELS_ACC_PRLI_Parm_Target_Function                              0x00000010
#define FC_ELS_ACC_PRLI_Parm_Command_Data_Mixed_Allowed                   0x00000008
#define FC_ELS_ACC_PRLI_Parm_Data_Response_Mixed_Allowed                  0x00000004
#define FC_ELS_ACC_PRLI_Parm_Read_XFER_RDY_Disabled                       0x00000002
#define FC_ELS_ACC_PRLI_Parm_Write_XFER_RDY_Disabled                      0x00000001

#define FC_ACC_PRLI_Parm_Pages_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_ACC_PRLI_Parm_Page_t))

typedef struct FC_ELS_ACC_PRLI_Payload_s
               FC_ELS_ACC_PRLI_Payload_t;

#define FC_ELS_ACC_PRLI_Payload_t_SIZE                                    (FC_Frame_Data_Size_Max - FC_ELS_ACC_PRLI_Parm_Page_t_SIZE + 4)

struct FC_ELS_ACC_PRLI_Payload_s
       {
         os_bit32                       ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_ACC */
         FC_ELS_ACC_PRLI_Parm_Page_t Parm_Page[FC_ACC_PRLI_Parm_Pages_MAX];
       };

#define FC_ELS_ACC_PRLI_Page_Length_MASK                                  0x00FF0000
#define FC_ELS_ACC_PRLI_Page_Length_SHIFT                                       0x10

#define FC_ELS_ACC_PRLI_Payload_Length_MASK                               0x0000FFFF
#define FC_ELS_ACC_PRLI_Payload_Length_SHIFT                                    0x00

typedef struct FC_ELS_PRLO_Parm_Page_s
               FC_ELS_PRLO_Parm_Page_t;

#define FC_ELS_PRLO_Parm_Page_t_SIZE                                      0x00000010

struct FC_ELS_PRLO_Parm_Page_s
       {
         os_bit32 Type__Type_Extension__Flags;
         os_bit32 Originator_Process_Associator;
         os_bit32 Responder_Process_Associator;
         os_bit32 Reserved;
       };

#define FC_ELS_PRLO_Parm_Type_MASK                                        0xFF000000
#define FC_ELS_PRLO_Parm_Type_SCSI_FCP                                    0x08000000

#define FC_ELS_PRLO_Parm_Type_Extension_MASK                              0x00FF0000

#define FC_ELS_PRLO_Parm_Flags_MASK                                       0x0000FFFF
#define FC_ELS_PRLO_Parm_Originator_Process_Associator_Valid              0x00008000
#define FC_ELS_PRLO_Parm_Responder_Process_Associator_Valid               0x00004000

#define FC_PRLO_Parm_Pages_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_PRLO_Parm_Page_t))

typedef struct FC_ELS_PRLO_Payload_s
               FC_ELS_PRLO_Payload_t;

#define FC_ELS_PRLO_Payload_t_SIZE                                        (FC_Frame_Data_Size_Max - FC_ELS_PRLO_Parm_Page_t_SIZE + 4)

struct FC_ELS_PRLO_Payload_s
       {
         os_bit32                   ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_PRLO */
         FC_ELS_PRLO_Parm_Page_t Parm_Page[FC_PRLO_Parm_Pages_MAX];
       };

#define FC_ELS_PRLO_Page_Length_MASK                                      0x00FF0000
#define FC_ELS_PRLO_Page_Length_SHIFT                                           0x10

#define FC_ELS_PRLO_Payload_Length_MASK                                   0x0000FFFF
#define FC_ELS_PRLO_Payload_Length_SHIFT                                        0x00

typedef struct FC_ELS_ACC_PRLO_Parm_Page_s
               FC_ELS_ACC_PRLO_Parm_Page_t;

#define FC_ELS_ACC_PRLO_Parm_Page_t_SIZE                                  0x00000010

struct FC_ELS_ACC_PRLO_Parm_Page_s
       {
         os_bit32 Type__Type_Extension__Flags;
         os_bit32 Originator_Process_Associator;
         os_bit32 Responder_Process_Associator;
         os_bit32 Reserved;
       };

#define FC_ELS_ACC_PRLO_Parm_Type_MASK                                    0xFF000000
#define FC_ELS_ACC_PRLO_Parm_Type_SCSI_FCP                                0x08000000

#define FC_ELS_ACC_PRLO_Parm_Type_Extension_MASK                          0x00FF0000

#define FC_ELS_ACC_PRLO_Parm_Flags_MASK                                   0x0000FFFF
#define FC_ELS_ACC_PRLO_Parm_Originator_Process_Associator_Valid          0x00008000
#define FC_ELS_ACC_PRLO_Parm_Responder_Process_Associator_Valid           0x00004000

#define FC_ELS_ACC_PRLO_Parm_Flags_Response_Code_MASK                     0x00000F00
#define FC_ELS_ACC_PRLO_Parm_Flags_Response_Request_Executed              0x00000100
#define FC_ELS_ACC_PRLO_Parm_Flags_Response_Target_Image_Does_Not_Exist   0x00000400
#define FC_ELS_ACC_PRLO_Parm_Flags_Response_Multiple_Not_Supported        0x00000700

#define FC_ACC_PRLO_Parm_Pages_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_ACC_PRLO_Parm_Page_t))

typedef struct FC_ELS_ACC_PRLO_Payload_s
               FC_ELS_ACC_PRLO_Payload_t;

#define FC_ELS_ACC_PRLO_Payload_t_SIZE                                    (FC_Frame_Data_Size_Max - FC_ELS_ACC_PRLO_Parm_Page_t_SIZE + 4)

struct FC_ELS_ACC_PRLO_Payload_s
       {
         os_bit32                       ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_ACC */
         FC_ELS_ACC_PRLO_Parm_Page_t Parm_Page[FC_ACC_PRLO_Parm_Pages_MAX];
       };

#define FC_ELS_ACC_PRLO_Page_Length_MASK                                  0x00FF0000
#define FC_ELS_ACC_PRLO_Page_Length_SHIFT                                       0x10

#define FC_ELS_ACC_PRLO_Payload_Length_MASK                               0x0000FFFF
#define FC_ELS_ACC_PRLO_Payload_Length_SHIFT                                    0x00

typedef os_bit32 FC_ELS_SCN_Affected_N_Port_ID_t;

#define FC_ELS_SCN_Affected_N_Port_ID_t_SIZE                              0x00000004

#define FC_ELS_SCN_Affected_N_Port_IDs_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_SCN_Affected_N_Port_ID_t))

typedef struct FC_ELS_SCN_Payload_s
               FC_ELS_SCN_Payload_t;

#define FC_ELS_SCN_Payload_t_SIZE                                         FC_Frame_Data_Size_Max

struct FC_ELS_SCN_Payload_s
       {
         os_bit32                           ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_SCN */
         FC_ELS_SCN_Affected_N_Port_ID_t Affected_N_Port_ID[FC_ELS_SCN_Affected_N_Port_IDs_MAX];
       };

#define FC_ELS_SCN_Page_Length_MASK                                       0x00FF0000
#define FC_ELS_SCN_Page_Length_SHIFT                                            0x10

#define FC_ELS_SCN_Payload_Length_MASK                                    0x0000FFFF
#define FC_ELS_SCN_Payload_Length_SHIFT                                         0x00


typedef os_bit32 FC_ELS_RSCN_Affected_N_Port_ID_t;

#define FC_ELS_RSCN_Affected_N_Port_ID_t_SIZE                              0x00000004

#define FC_ELS_RSCN_Affected_N_Port_IDs_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_RSCN_Affected_N_Port_ID_t))

typedef struct FC_ELS_RSCN_Payload_s
               FC_ELS_RSCN_Payload_t;

#define FC_ELS_RSCN_Payload_t_SIZE                                         FC_Frame_Data_Size_Max

struct FC_ELS_RSCN_Payload_s
       {
         os_bit32                           ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_RSCN */
         FC_ELS_RSCN_Affected_N_Port_ID_t Affected_N_Port_ID[FC_ELS_RSCN_Affected_N_Port_IDs_MAX];
       };

#define FC_ELS_RSCN_Page_Length_MASK                                       0x00FF0000
#define FC_ELS_RSCN_Page_Length_SHIFT                                            0x10

#define FC_ELS_RSCN_Payload_Length_MASK                                    0x0000FFFF
#define FC_ELS_RSCN_Payload_Length_SHIFT                                         0x00


typedef os_bit32  FC_ELS_SCR_Registration_Function_t;

typedef struct FC_ELS_SCR_Payload_s
               FC_ELS_SCR_Payload_t;

#define FC_ELS_SCR_Payload_t_SIZE                                          0x00000008

struct FC_ELS_SCR_Payload_s
    {
        os_bit32                               ELS_Type_Command;
        FC_ELS_SCR_Registration_Function_t  Reserved_Registration_Function;
    };
 
#define FC_ELS_SCR_Registration_Function_MASK                                 0x0000000F
#define FC_ELS_SCR_Fabric_Detected_Registration                               0x00000001
#define FC_ELS_SCR_N_Port_Detected_Registration                               0x00000002
#define FC_ELS_SCR_Full_Registration                                          0x00000003


typedef struct FC_ELS_ACC_SCR_Payload_s
               FC_ELS_ACC_SCR_Payload_t;

#define FC_ELS_ACC_SCR_Payload_t_SIZE                                   0x0000004

struct FC_ELS_ACC_SCR_Payload_s
       {
         os_bit32            ELS_Type; /* == FC_ELS_Type_ACC */
       };

typedef struct FC_ELS_SRR_Payload_s
               FC_ELS_SRR_Payload_t;

#define FC_ELS_ACC_SRR_Payload_t_SIZE                                   0x0000004
#define FC_ELS_SRR_OXID_MASK            0xFFFF0000
#define FC_ELS_SRR_OXID_SHIFT           0x10

#define FC_ELS_SRR_RXID_MASK            0x0000FFFF
#define FC_ELS_SRR_RXID_SHIFT           0x0

/* The RCTL that goes here is as described in FC-PH
   for FCP_XFER_RDY, it is 05, FCP_RSP 07 and FCP_DATA
   01 */
#define FC_ELS_SRR_Payload_t_SIZE                                   0x0000010
#define FC_ELS_R_CTL_MASK                       0xFF000000
#define FC_ELS_R_CTL_FOR_IU_SHIFT               0x18

           
struct FC_ELS_SRR_Payload_s
    {
        os_bit32                           ELS_Type;
        os_bit32                           OXID_RXID;
        os_bit32                           Relative_Offset;
        os_bit32                           R_CTL_For_IU_Reserved;
    }; 

#define FC_ELS_ACC_SRR_RJT_CODE         0x00052A00


/* Read Exchange Context REC - Requests an NPort to return exchange information
   for the RX_ID or OX_ID originated by the S)ID specified in the payload of the request
   sequence */

#define FC_ELS_REC_Payload_t_SIZE                                   0x00000C
typedef struct FC_ELS_REC_Payload_s
                FC_ELS_REC_Payload_t;

#define FC_ELS_REC_ExChOriginatorSid_MASK          0x00FFFFFF
#define FC_ELS_REC_ExChOriginatorSid_SHIFT         0x0
#define FC_ELS_REC_OXID_MASK                       0xFFFF0000
#define FC_ELS_REC_OXID_SHIFT                      0x10
#define FC_ELS_REC_RXID_MASK                       0x0000FFFF
#define FC_ELS_REC_RXID_SHIFT                      0x0

struct FC_ELS_REC_Payload_s
    {
        os_bit32                           ELS_Type;
        os_bit32                           Reserved_ExChOriginatorSid;
        os_bit32                           OXID_RXID;
    };

typedef struct FC_ELS_REC_ACC_Payload_s
               FC_ELS_REC_ACC_Payload_t;

#define FC_ELS_REC_ACC_OXID_MASK                            0xFFFF0000
#define FC_ELS_REC_ACC_OXID_SHIFT                           0x10
#define FC_ELS_REC_ACC_RXID_MASK                            0x0000FFFF
#define FC_ELS_REC_ACC_RXID_SHIFT                           0x0

#define FC_REC_ESTAT_VALID_VALUE_MASK                       0x06000000
#define FC_REC_ESTAT_VALID_VALUE_SHIFT                      0x20
#define FC_REC_ESTAT_VALID_VALUE                            0x00000003

#define FC_REC_ESTAT_Mask                                   0x003FFFFF
#define FC_REC_ESTAT_ESB_OWNER_Responder                    0x80000000
#define FC_REC_ESTAT_SequenceInitiativeThisPort             0x40000000
#define FC_REC_ESTAT_ExchangeCompletion                     0x20000000
#define FC_REC_ESTAT_EndingConditionAbnormal                0x10000000
#define FC_REC_ESTAT_ErrorTypeAbnormal                      0x08000000
#define FC_REC_ESTAT_RecoveryQualiferActive                 0x04000000
#define FC_REC_ESTAT_ExchangePolicy_AbortDiscardMultiple    0x00000000
#define FC_REC_ESTAT_ExchangePolicy_AbortDiscardSingle      0x01000000
#define FC_REC_ESTAT_ExchangePolicy_Processinfinite         0x02000000
#define FC_REC_ESTAT_ExchangePolicy_DiscardMultipleRetry    0x03000000
#define FC_REC_ESTAT_ExchangePolicy_MASK                    0x03000000

#define FC_REC_ESTAT_Originator_X_ID_invalid                0x00800000
#define FC_REC_ESTAT_Responder_X_ID_invalid                 0x00400000



#define FC_ELS_REC_ACC_Payload_t_SIZE                                   0x000018
struct FC_ELS_REC_ACC_Payload_s
    {
        os_bit32       ELS_Type_Command;
        os_bit32       OXID_RXID;
        os_bit32       OriginatorAddressIdentifier;
        os_bit32       ResponderAddressIdentifier;
        os_bit32       DataTransferCount;
        os_bit32       ESTAT;
    };

typedef struct FC_ELS_TPLS_Image_Pair_s
               FC_ELS_TPLS_Image_Pair_t;

#define FC_ELS_TPLS_Image_Pair_t_SIZE                                     0x00000010

struct FC_ELS_TPLS_Image_Pair_s
       {
         os_bit32 Flags;
         os_bit32 Originator_Process_Associator;
         os_bit32 Responder_Process_Associator;
         os_bit32 Reserved;
       };

#define FC_ELS_TPLS_Image_Pair_Flags_MASK                                 0x0000FFFF

#define FC_ELS_TPLS_Image_Pair_Originator_Process_Associator_Valid        0x00008000
#define FC_ELS_TPLS_Image_Pair_Responder_Process_Associator_Valid         0x00004000

#define FC_ELS_TPLS_Image_Pairs_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_TPLS_Image_Pair_t))

typedef struct FC_ELS_TPLS_Payload_s
               FC_ELS_TPLS_Payload_t;

#define FC_ELS_TPLS_Payload_t_SIZE                                        (FC_Frame_Data_Size_Max - FC_ELS_TPLS_Image_Pair_t_SIZE + 4)

struct FC_ELS_TPLS_Payload_s
       {
         os_bit32                    ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_TPLS */
         FC_ELS_TPLS_Image_Pair_t Image_Pair[FC_ELS_TPLS_Image_Pairs_MAX];
       };

#define FC_ELS_TPLS_Page_Length_MASK                                      0x00FF0000
#define FC_ELS_TPLS_Page_Length_SHIFT                                           0x10

#define FC_ELS_TPLS_Payload_Length_MASK                                   0x0000FFFF
#define FC_ELS_TPLS_Payload_Length_SHIFT                                        0x00

typedef struct FC_ELS_ACC_TPLS_Image_Pair_s
               FC_ELS_ACC_TPLS_Image_Pair_t;

#define FC_ELS_ACC_TPLS_Image_Pair_t_SIZE                                 0x00000010

struct FC_ELS_ACC_TPLS_Image_Pair_s
       {
         os_bit32 Flags;
         os_bit32 Originator_Process_Associator;
         os_bit32 Responder_Process_Associator;
         os_bit32 Reserved;
       };

#define FC_ELS_TPLS_Image_Pair_Flags_MASK                                 0x0000FFFF

#define FC_ELS_ACC_TPLS_Image_Pair_Originator_Process_Associator_Valid    0x00008000
#define FC_ELS_ACC_TPLS_Image_Pair_Responder_Process_Associator_Valid     0x00004000

#define FC_ELS_ACC_TPLS_Pair_Flags_Response_Code_MASK                     0x00000F00
#define FC_ELS_ACC_TPLS_Pair_Flags_Response_Request_Executed              0x00000100
#define FC_ELS_ACC_TPLS_Pair_Flags_Response_Multiple_Not_Supported        0x00000700

#define FC_ELS_ACC_TPLS_Image_Pairs_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_ACC_TPLS_Image_Pair_t))

typedef struct FC_ELS_ACC_TPLS_Payload_s
               FC_ELS_ACC_TPLS_Payload_t;

#define FC_ELS_ACC_TPLS_Payload_t_SIZE                                    (FC_Frame_Data_Size_Max - FC_ELS_ACC_TPLS_Image_Pair_t_SIZE + 4)

struct FC_ELS_ACC_TPLS_Payload_s
       {
         os_bit32                        ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_ACC */
         FC_ELS_ACC_TPLS_Image_Pair_t Image_Pair[FC_ELS_ACC_TPLS_Image_Pairs_MAX];
       };

#define FC_ELS_ACC_TPLS_Page_Length_MASK                                  0x00FF0000
#define FC_ELS_ACC_TPLS_Page_Length_SHIFT                                       0x10

#define FC_ELS_ACC_TPLS_Payload_Length_MASK                               0x0000FFFF
#define FC_ELS_ACC_TPLS_Payload_Length_SHIFT                                    0x00

typedef struct FC_ELS_TPRLO_Parm_Page_s
               FC_ELS_TPRLO_Parm_Page_t;

#define FC_ELS_TPRLO_Parm_Page_t_SIZE                                     0x00000010

struct FC_ELS_TPRLO_Parm_Page_s
       {
         os_bit32 Flags;
         os_bit32 Originator_Process_Associator;
         os_bit32 Responder_Process_Associator;
         os_bit32 Third_Party_N_Port_ID;
       };

#define FC_ELS_TPRLO_Parm_Page_Flags_MASK                                 0x0000FFFF

#define FC_ELS_TPRLO_Parm_Page_Originator_Process_Associator_Valid        0x00008000
#define FC_ELS_TPRLO_Parm_Page_Responder_Process_Associator_Valid         0x00004000
#define FC_ELS_TPRLO_Parm_Page_Third_Party_N_Port_Valid                   0x00002000
#define FC_ELS_TPRLO_Parm_Page_Global_Process_Logout                      0x00001000

#define FC_ELS_TPRLO_Parm_Page_Third_Party_N_Port_ID_MASK                 0x00FFFFFF

#define FC_ELS_TPRLO_Parm_Pages_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_TPRLO_Parm_Page_t))

typedef struct FC_ELS_TPRLO_Payload_s
               FC_ELS_TPRLO_Payload_t;

#define FC_ELS_TPRLO_Payload_t_SIZE                                       (FC_Frame_Data_Size_Max - FC_ELS_TPRLO_Parm_Page_t_SIZE + 4)

struct FC_ELS_TPRLO_Payload_s
       {
         os_bit32                    ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_TPRLO */
         FC_ELS_TPRLO_Parm_Page_t Parm_Page[FC_ELS_TPRLO_Parm_Pages_MAX];
       };

#define FC_ELS_TPRLO_Page_Length_MASK                                     0x00FF0000
#define FC_ELS_TPRLO_Page_Length_SHIFT                                          0x10

#define FC_ELS_TPRLO_Payload_Length_MASK                                  0x0000FFFF
#define FC_ELS_TPRLO_Payload_Length_SHIFT                                       0x00

typedef struct FC_ELS_ACC_TPRLO_Payload_s
               FC_ELS_ACC_TPRLO_Payload_t;

#define FC_ELS_ACC_TPRLO_Payload_t_SIZE                                   (FC_Frame_Data_Size_Max - FC_ELS_TPRLO_Parm_Page_t_SIZE + 4)

struct FC_ELS_ACC_TPRLO_Payload_s
       {
         os_bit32                    ELS_Type__Page_Length__Payload_Length; /* & FC_ELS_Type_MASK == FC_ELS_Type_ACC */
         FC_ELS_TPRLO_Parm_Page_t Parm_Page[FC_ELS_TPRLO_Parm_Pages_MAX];
       };

#define FC_ELS_ACC_TPRLO_Page_Length_MASK                                 0x00FF0000
#define FC_ELS_ACC_TPRLO_Page_Length_SHIFT                                      0x10

#define FC_ELS_ACC_TPRLO_Payload_Length_MASK                              0x0000FFFF
#define FC_ELS_ACC_TPRLO_Payload_Length_SHIFT                                   0x00

typedef os_bit8 FC_ELS_Alias_Token_t [12];
typedef os_bit8 FC_ELS_Alias_SP_t    [80];

#define FC_ELS_Alias_Token_t_SIZE                                         0x0000000C
#define FC_ELS_Alias_SP_t_SIZE                                            0x00000050

typedef os_bit32 FC_ELS_NP_List_Element_t;

#define FC_ELS_NP_List_Element_t_SIZE                                     0x00000004

typedef os_bit32 FC_ELS_Alias_ID_t;

#define FC_ELS_Alias_ID_t_SIZE                                            0x00000004

#define FC_ELS_GAID_Payload_NP_List_Size_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32) - sizeof(FC_ELS_Alias_Token_t) - sizeof(FC_ELS_Alias_SP_t) - sizeof(os_bit32))/sizeof(FC_ELS_NP_List_Element_t))

typedef struct FC_ELS_GAID_Payload_s
               FC_ELS_GAID_Payload_t;

#define FC_ELS_GAID_Payload_t_SIZE                                        FC_Frame_Data_Size_Max

struct FC_ELS_GAID_Payload_s
       {
         os_bit32                    ELS_Type; /* == FC_ELS_Type_GAID */
         FC_ELS_Alias_Token_t     Alias_Token;
         FC_ELS_Alias_SP_t        Alias_SP;
         os_bit32                    NP_List_Length;
         FC_ELS_NP_List_Element_t NP_List[FC_ELS_GAID_Payload_NP_List_Size_MAX];
       };

typedef struct FC_ELS_ACC_GAID_Payload_s
               FC_ELS_ACC_GAID_Payload_t;

#define FC_ELS_ACC_GAID_Payload_t_SIZE                                    (FC_ELS_Alias_ID_t_SIZE + 4)

struct FC_ELS_ACC_GAID_Payload_s
       {
         os_bit32             ELS_Type; /* == FC_ELS_Type_ACC */
         FC_ELS_Alias_ID_t Alias_ID;
       };

#define FC_ELS_FACT_Payload_NP_List_Size_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32) - sizeof(FC_ELS_Alias_ID_t) - sizeof(os_bit32))/sizeof(FC_ELS_NP_List_Element_t))

typedef struct FC_ELS_FACT_Payload_s
               FC_ELS_FACT_Payload_t;

#define FC_ELS_FACT_Payload_t_SIZE                                        FC_Frame_Data_Size_Max

struct FC_ELS_FACT_Payload_s
       {
         os_bit32                    ELS_Type; /* == FC_ELS_Type_FACT */
         FC_ELS_Alias_ID_t        Alias_ID;
         os_bit32                    NP_List_Length;
         FC_ELS_NP_List_Element_t NP_List[FC_ELS_FACT_Payload_NP_List_Size_MAX];
       };

typedef struct FC_ELS_ACC_FACT_Payload_s
               FC_ELS_ACC_FACT_Payload_t;

#define FC_ELS_ACC_FACT_Payload_t_SIZE                                    0x00000004

struct FC_ELS_ACC_FACT_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
       };

#define FC_ELS_FDACT_Payload_NP_List_Size_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32) - sizeof(FC_ELS_Alias_ID_t) - sizeof(os_bit32))/sizeof(FC_ELS_NP_List_Element_t))

typedef struct FC_ELS_FDACT_Payload_s
               FC_ELS_FDACT_Payload_t;

#define FC_ELS_FDACT_Payload_t_SIZE                                       FC_Frame_Data_Size_Max

struct FC_ELS_FDACT_Payload_s
       {
         os_bit32                    ELS_Type; /* == FC_ELS_Type_FDACT */
         FC_ELS_Alias_ID_t        Alias_ID;
         os_bit32                    NP_List_Length;
         FC_ELS_NP_List_Element_t NP_List[FC_ELS_FDACT_Payload_NP_List_Size_MAX];
       };

typedef struct FC_ELS_ACC_FDACT_Payload_s
               FC_ELS_ACC_FDACT_Payload_t;

#define FC_ELS_ACC_FDACT_Payload_t_SIZE                                   0x00000004

struct FC_ELS_ACC_FDACT_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
       };

typedef struct FC_ELS_NACT_Payload_s
               FC_ELS_NACT_Payload_t;

#define FC_ELS_NACT_Payload_t_SIZE                                        (FC_ELS_Alias_Token_t_SIZE + FC_ELS_Alias_ID_t_SIZE + FC_ELS_Alias_SP_t_SIZE + 4)

struct FC_ELS_NACT_Payload_s
       {
         os_bit32                ELS_Type; /* == FC_ELS_Type_NACT */
         FC_ELS_Alias_Token_t Alias_Token;
         FC_ELS_Alias_ID_t    Alias_ID;
         FC_ELS_Alias_SP_t    Alias_SP;
       };

typedef struct FC_ELS_ACC_NACT_Payload_s
               FC_ELS_ACC_NACT_Payload_t;

#define FC_ELS_ACC_NACT_Payload_t_SIZE                                    0x00000004

struct FC_ELS_ACC_NACT_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
       };

typedef struct FC_ELS_NDACT_Payload_s
               FC_ELS_NDACT_Payload_t;

#define FC_ELS_NDACT_Payload_t_SIZE                                       (FC_ELS_Alias_ID_t_SIZE + 4)

struct FC_ELS_NDACT_Payload_s
       {
         os_bit32             ELS_Type; /* == FC_ELS_Type_NDACT */
         FC_ELS_Alias_ID_t Alias_ID;
       };

typedef struct FC_ELS_ACC_NDACT_Payload_s
               FC_ELS_ACC_NDACT_Payload_t;

#define FC_ELS_ACC_NDACT_Payload_t_SIZE                                   0x00000004

struct FC_ELS_ACC_NDACT_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
       };

typedef struct FC_ELS_QoSR_Payload_s
               FC_ELS_QoSR_Payload_t;

#define FC_ELS_QoSR_Payload_t_SIZE                                        0x0000004C

struct FC_ELS_QoSR_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_QoSR */
         os_bit32 Reserved_1;
         os_bit32 CTI_VC_ID__CTI_Address_Identifier;
         os_bit32 CTI_Maximum_Bandwidth;
         os_bit32 CTI_Minimum_Bandwidth;
         os_bit32 CTI_Maximum_Delay;
         os_bit32 CTI_VC_Data_Field_Size;
         os_bit32 Reserved_2;
         os_bit32 Reserved_3;
         os_bit32 Reserved_4;
         os_bit32 CTR_VC_ID__CTR_Address_Identifier;
         os_bit32 CTR_Maximum_Bandwidth;
         os_bit32 CTR_Minimum_Bandwidth;
         os_bit32 CTR_Maximum_Delay;
         os_bit32 CTR_VC_Data_Field_Size;
         os_bit32 Reserved_5;
         os_bit32 Reserved_6;
         os_bit32 Reserved_7;
         os_bit32 Live_VC_Credit_Limit__Class_4_End_to_End_Credit;
       };

#define FC_ELS_QoSR_CTI_VC_ID_MASK                                        0xFF000000
#define FC_ELS_QoSR_CTI_VC_ID_SHIFT                                             0x18

#define FC_ELS_QoSR_CTI_Address_Identifier_MASK                           0x00FFFFFF
#define FC_ELS_QoSR_CTI_Address_Identifier_SHIFT                                0x00

#define FC_ELS_QoSR_CTR_VC_ID_MASK                                        0xFF000000
#define FC_ELS_QoSR_CTR_VC_ID_SHIFT                                             0x18

#define FC_ELS_QoSR_CTR_Address_Identifier_MASK                           0x00FFFFFF
#define FC_ELS_QoSR_CTR_Address_Identifier_SHIFT                                0x00

#define FC_ELS_QoSR_Live_VC_Credit_Limit_MASK                             0x00FF0000
#define FC_ELS_QoSR_Live_VC_Credit_Limit_SHIFT                                  0x10

#define FC_ELS_QoSR_Live_Class_4_End_to_End_Credit_MASK                   0x0000FFFF
#define FC_ELS_QoSR_Live_Class_4_End_to_End_Credit_SHIFT                        0x00

typedef struct FC_ELS_ACC_QoSR_Payload_s
               FC_ELS_ACC_QoSR_Payload_t;

#define FC_ELS_ACC_QoSR_Payload_t_SIZE                                    0x0000004C

struct FC_ELS_ACC_QoSR_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_ACC */
         os_bit32 Reserved_1;
         os_bit32 CTI_VC_ID__CTI_Address_Identifier;
         os_bit32 CTI_Maximum_Bandwidth;
         os_bit32 CTI_Minimum_Bandwidth;
         os_bit32 CTI_Maximum_Delay;
         os_bit32 CTI_VC_Data_Field_Size;
         os_bit32 Reserved_2;
         os_bit32 Reserved_3;
         os_bit32 Reserved_4;
         os_bit32 CTR_VC_ID__CTR_Address_Identifier;
         os_bit32 CTR_Maximum_Bandwidth;
         os_bit32 CTR_Minimum_Bandwidth;
         os_bit32 CTR_Maximum_Delay;
         os_bit32 CTR_VC_Data_Field_Size;
         os_bit32 Reserved_5;
         os_bit32 Reserved_6;
         os_bit32 Reserved_7;
         os_bit32 Live_VC_Credit_Limit__Class_4_End_to_End_Credit;
       };

#define FC_ELS_ACC_QoSR_CTI_VC_ID_MASK                                    0xFF000000
#define FC_ELS_ACC_QoSR_CTI_VC_ID_SHIFT                                         0x18

#define FC_ELS_ACC_QoSR_CTI_Address_Identifier_MASK                       0x00FFFFFF
#define FC_ELS_ACC_QoSR_CTI_Address_Identifier_SHIFT                            0x00

#define FC_ELS_ACC_QoSR_CTR_VC_ID_MASK                                    0xFF000000
#define FC_ELS_ACC_QoSR_CTR_VC_ID_SHIFT                                         0x18

#define FC_ELS_ACC_QoSR_CTR_Address_Identifier_MASK                       0x00FFFFFF
#define FC_ELS_ACC_QoSR_CTR_Address_Identifier_SHIFT                            0x00

#define FC_ELS_ACC_QoSR_Live_VC_Credit_Limit_MASK                         0x00FF0000
#define FC_ELS_ACC_QoSR_Live_VC_Credit_Limit_SHIFT                              0x10

#define FC_ELS_ACC_QoSR_Live_Class_4_End_to_End_Credit_MASK               0x0000FFFF
#define FC_ELS_ACC_QoSR_Live_Class_4_End_to_End_Credit_SHIFT                    0x00

typedef struct FC_ELS_RVCS_Payload_s
               FC_ELS_RVCS_Payload_t;

#define FC_ELS_RVCS_Payload_t_SIZE                                        0x00000008

struct FC_ELS_RVCS_Payload_s
       {
         os_bit32 ELS_Type; /* == FC_ELS_Type_RVCS */
         os_bit32 N_Port_Identifier;
       };

#define FC_ELS_RVCS_N_Port_Identifier_MASK                                0x00FFFFFF
#define FC_ELS_RVCS_N_Port_Identifier_SHIFT                                     0x00

typedef struct FC_ELS_ACC_RVCS_Class_4_Status_Block_s
               FC_ELS_ACC_RVCS_Class_4_Status_Block_t;

#define FC_ELS_ACC_RVCS_Class_4_Status_Block_t_SIZE                       0x00000008

struct FC_ELS_ACC_RVCS_Class_4_Status_Block_s
       {
         os_bit32 CTI_VC_ID__CTI_Address_Identifier;
         os_bit32 CTR_VC_ID__CTR_Address_Identifier;
       };

#define FC_ELS_ACC_RVCS_Class_4_Status_Block_CTI_VC_ID_MASK               0xFF000000
#define FC_ELS_ACC_RVCS_Class_4_Status_Block_CTI_VC_ID_SHIFT                    0x18

#define FC_ELS_ACC_RVCS_Class_4_Status_Block_CTI_Address_Identifier_MASK  0x00FFFFFF
#define FC_ELS_ACC_RVCS_Class_4_Status_Block_CTI_Address_Identifier_SHIFT       0x00

#define FC_ELS_ACC_RVCS_Class_4_Status_Block_CTR_VC_ID_MASK               0xFF000000
#define FC_ELS_ACC_RVCS_Class_4_Status_Block_CTR_VC_ID_SHIFT                    0x18

#define FC_ELS_ACC_RVCS_Class_4_Status_Block_CTR_Address_Identifier_MASK  0x00FFFFFF
#define FC_ELS_ACC_RVCS_Class_4_Status_Block_CTR_Address_Identifier_SHIFT       0x00

#define FC_ELS_ACC_RVCS_Class_4_Status_Blocks_MAX ((FC_Frame_Data_Size_Max - sizeof(os_bit32))/sizeof(FC_ELS_ACC_RVCS_Class_4_Status_Block_t))

typedef struct FC_ELS_ACC_RVCS_Payload_s
               FC_ELS_ACC_RVCS_Payload_t;

#define FC_ELS_ACC_RVCS_Payload_t_SIZE                                    FC_Frame_Data_Size_Max

struct FC_ELS_ACC_RVCS_Payload_s
       {
         os_bit32                                  ELS_Type; /* == FC_ELS_Type_ACC */
         os_bit32                                  Reserved;
         FC_ELS_ACC_RVCS_Class_4_Status_Block_t Status_Block[FC_ELS_ACC_RVCS_Class_4_Status_Blocks_MAX];
       };

typedef struct FC_ELS_PDISC_Payload_s
               FC_ELS_PDISC_Payload_t;

#define FC_ELS_PDISC_Payload_t_SIZE                                       0x00000074

struct FC_ELS_PDISC_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_PDISC */
         FC_N_Port_Common_Parms_t  Common_Service_Parameters;
         FC_N_Port_Name_t          N_Port_Name;
         FC_Node_Name_t            Node_Name;
         FC_N_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_ACC_PDISC_Payload_s
               FC_ELS_ACC_PDISC_Payload_t;

#define FC_ELS_ACC_PDISC_Payload_t_SIZE                                   0x00000074

struct FC_ELS_ACC_PDISC_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_ACC */
         FC_N_Port_Common_Parms_t  Common_Service_Parameters;
         FC_N_Port_Name_t          N_Port_Name;
         FC_Node_Name_t            Node_Name;
         FC_N_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_FDISC_Payload_s
               FC_ELS_FDISC_Payload_t;

#define FC_ELS_FDISC_Payload_t_SIZE                                       0x00000074

struct FC_ELS_FDISC_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_FDISC */
         FC_N_Port_Common_Parms_t  Common_Service_Parameters;
         FC_N_Port_Name_t          N_Port_Name;
         FC_Node_Name_t            Node_Name;
         FC_N_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_N_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_ACC_FDISC_Payload_s
               FC_ELS_ACC_FDISC_Payload_t;

#define FC_ELS_ACC_FDISC_Payload_t_SIZE                                   0x00000074

struct FC_ELS_ACC_FDISC_Payload_s
       {
         os_bit32                     ELS_Type; /* == FC_ELS_Type_ACC */
         FC_F_Port_Common_Parms_t  Common_Service_Parameters;
         FC_F_Port_Name_t          F_Port_Name;
         FC_Fabric_Name_t          Fabric_Name;
         FC_F_Port_Class_Parms_t   Class_1_Service_Parameters;
         FC_F_Port_Class_Parms_t   Class_2_Service_Parameters;
         FC_F_Port_Class_Parms_t   Class_3_Service_Parameters;
         os_bit8                      Reserved[16];
         FC_Vendor_Version_Level_t Vendor_Version_Level;
       };

typedef struct FC_ELS_FAN_Payload_s
               FC_ELS_FAN_Payload_t;

#define FC_ELS_FAN_Payload_t_SIZE                                         0x00000006

struct FC_ELS_FAN_Payload_s
       {
         os_bit32            ELS_Type; /* == FC_ELS_Type_FAN */
         os_bit32            FabricLoopAddress;
         FC_Node_Name_t   Fabric_Port_Name;
         FC_Node_Name_t   Fabric_Name;
       };

typedef struct FC_ELS_ADISC_Payload_s
               FC_ELS_ADISC_Payload_t;

#define FC_ELS_ADISC_Payload_t_SIZE                                       0x0000001C

struct FC_ELS_ADISC_Payload_s
       {
         os_bit32            ELS_Type; /* == FC_ELS_Type_ADISC */
         os_bit32            Hard_Address_of_Originator;
         FC_N_Port_Name_t Port_Name_of_Originator;
         FC_Node_Name_t   Node_Name_of_Originator;
         os_bit32            N_Port_ID_of_Originator;
       };

#define FC_ELS_ADISC_Hard_Address_of_Originator_MASK                      0x00FFFFFF
#define FC_ELS_ADISC_Hard_Address_of_Originator_SHIFT                           0x00

#define FC_ELS_ADISC_N_Port_ID_of_Originator_MASK                         0x00FFFFFF
#define FC_ELS_ADISC_N_Port_ID_of_Originator_SHIFT                              0x00

typedef struct FC_ELS_ACC_ADISC_Payload_s
               FC_ELS_ACC_ADISC_Payload_t;

#define FC_ELS_ACC_ADISC_Payload_t_SIZE                                   0x0000001C

struct FC_ELS_ACC_ADISC_Payload_s
       {
         os_bit32            ELS_Type; /* == FC_ELS_Type_ACC */
         os_bit32            Hard_Address_of_Responder;
         FC_N_Port_Name_t Port_Name_of_Responder;
         FC_Node_Name_t   Node_Name_of_Responder;
         os_bit32            N_Port_ID_of_Responder;
       };

#define FC_ELS_ACC_ADISC_Hard_Address_of_Responder_MASK                   0x00FFFFFF
#define FC_ELS_ACC_ADISC_Hard_Address_of_Responder_SHIFT                        0x00

#define FC_ELS_ACC_ADISC_N_Port_ID_of_Responder_MASK                      0x00FFFFFF
#define FC_ELS_ACC_ADISC_N_Port_ID_of_Responder_SHIFT                           0x00
#ifdef _DvrArch_1_30_
typedef struct FC_ELS_FARP_REQ_Payload_s
               FC_ELS_FARP_REQ_Payload_t;

#define FC_ELS_FARP_Payload_t_SIZE                                       0x0000004C

struct FC_ELS_FARP_REQ_Payload_s
       {
         os_bit32            ELS_Type; /* == FC_ELS_Type_FARP_REQ */
         os_bit32            Match_Code_Requester_Port_ID;
         os_bit32            Flags_Responder_Port_ID;
         FC_N_Port_Name_t    Port_Name_of_Requester;
         FC_Node_Name_t      Node_Name_of_Requester;
         FC_N_Port_Name_t    Port_Name_of_Responder;
         FC_Node_Name_t      Node_Name_of_Responder;
         os_bit8             IP_Address_of_Requester[16];
         os_bit8             IP_Address_of_Responder[16];
       };

#define FC_ELS_FARP_REQ_Match_Code_Points_MASK                            0xFF000000
#define FC_ELS_FARP_REQ_Match_Code_Points_SHIFT                                 0x18

#define FC_ELS_FARP_REQ_Match_Code_Points_Match_WW_PN                           0x01
#define FC_ELS_FARP_REQ_Match_Code_Points_Match_WW_NN                           0x02
#define FC_ELS_FARP_REQ_Match_Code_Points_Match_IPv4                            0x04

#define FC_ELS_FARP_REQ_Port_ID_of_Requester_MASK                         0x00FFFFFF
#define FC_ELS_FARP_REQ_Port_ID_of_Requester_SHIFT                              0x00

#define FC_ELS_FARP_REQ_Responder_Flags_MASK                              0xFF000000
#define FC_ELS_FARP_REQ_Responder_Flags_SHIFT                                   0x18

#define FC_ELS_FARP_REQ_Responder_Flags_Init_Plogi                              0x01
#define FC_ELS_FARP_REQ_Responder_Flags_Init_Reply                              0x02

#define FC_ELS_FARP_REQ_Port_ID_of_Responder_MASK                         0x00FFFFFF
#define FC_ELS_FARP_REQ_Port_ID_of_Responder_SHIFT                              0x00

typedef struct FC_ELS_FARP_REPLY_Payload_s
               FC_ELS_FARP_REPLY_Payload_t;

#define FC_ELS_ACC_FARP_Payload_t_SIZE                                   0x0000004C

struct FC_ELS_FARP_REPLY_Payload_s
       {
         os_bit32            ELS_Type; /* == FC_ELS_Type_FARP_REPLY */
         os_bit32            Match_Code_Requester_Port_ID;
         os_bit32            Flags_Responder_Port_ID;
         FC_N_Port_Name_t    Port_Name_of_Requester;
         FC_Node_Name_t      Node_Name_of_Requester;
         FC_N_Port_Name_t    Port_Name_of_Responder;
         FC_Node_Name_t      Node_Name_of_Responder;
         os_bit8             IP_Address_of_Requester[16];
         os_bit8             IP_Address_of_Responder[16];
       };
#endif /* _DvrArch_1_30_ was defined */

typedef union FC_ELS_ACC_Payload_u
              FC_ELS_ACC_Payload_t;

#define FC_ELS_ACC_Payload_t_SIZE                                         FC_Frame_Data_Size_Max

union FC_ELS_ACC_Payload_u
      {
        FC_ELS_ACC_Unknown_Payload_t Unknown;
        FC_ELS_ACC_PLOGI_Payload_t   PLOGI;
        FC_ELS_ACC_FLOGI_Payload_t   FLOGI;
        FC_ELS_ACC_LOGO_Payload_t    LOGO;
        FC_ELS_GENERIC_ACC_Payload_t ACC;
        FC_ELS_ACC_ABTX_Payload_t    ABTX;
        FC_ELS_ACC_RCS_Payload_t     RCS;
        FC_ELS_ACC_RES_Payload_t     RES;
        FC_ELS_ACC_RSS_Payload_t     RSS;
        FC_ELS_ACC_RSI_Payload_t     RSI;
        FC_ELS_ACC_ESTS_Payload_t    ESTS;
        FC_ELS_ACC_ADVC_Payload_t    ADVC;
        FC_ELS_ACC_RTV_Payload_t     RTV;
        FC_ELS_ACC_RLS_Payload_t     RLS;
        FC_ELS_ACC_ECHO_Payload_t    FC_ECHO;
        FC_ELS_ACC_RRQ_Payload_t     RRQ;
        FC_ELS_ACC_PRLI_Payload_t    PRLI;
        FC_ELS_ACC_PRLO_Payload_t    PRLO;
        FC_ELS_ACC_TPLS_Payload_t    TPLS;
        FC_ELS_ACC_GAID_Payload_t    GAID;
        FC_ELS_ACC_FACT_Payload_t    FACT;
        FC_ELS_ACC_FDACT_Payload_t   FDACT;
        FC_ELS_ACC_NACT_Payload_t    NACT;
        FC_ELS_ACC_NDACT_Payload_t   NDACT;
        FC_ELS_ACC_QoSR_Payload_t    QoSR;
        FC_ELS_ACC_RVCS_Payload_t    RVCS;
        FC_ELS_ACC_PDISC_Payload_t   PDISC;
        FC_ELS_ACC_FDISC_Payload_t   FDISC;
        FC_ELS_ACC_ADISC_Payload_t   ADISC;
        FC_ELS_ACC_TPRLO_Payload_t   TPRLO;
#ifdef _DvrArch_1_30_
        FC_ELS_FARP_REPLY_Payload_t  FARP;
#endif /* _DvrArch_1_30_ was defined */
      };

typedef union FC_ELS_Payload_u
              FC_ELS_Payload_t;

#define FC_ELS_Payload_t_SIZE                                             FC_Frame_Data_Size_Max

union FC_ELS_Payload_u
      {
        FC_ELS_Unknown_Payload_t            Unknown;
        FC_ELS_LS_RJT_Payload_t             LS_RJT;
        FC_ELS_GENERIC_ACC_Payload_t        ACC;
        FC_ELS_PLOGI_Payload_t              PLOGI;
        FC_ELS_FLOGI_Payload_t              FLOGI;
        FC_ELS_LOGO_Payload_t               LOGO;
        FC_ELS_ABTX_Payload_t               ABTX;
        FC_ELS_RCS_Payload_t                RCS;
        FC_ELS_RES_Payload_t                RES;
        FC_ELS_RSS_Payload_t                RSS;
        FC_ELS_RSI_Payload_t                RSI;
        FC_ELS_ESTS_Payload_t               ESTS;
        FC_ELS_ESTC_Payload_t               ESTC;
        FC_ELS_ADVC_Payload_t               ADVC;
        FC_ELS_RTV_Payload_t                RTV;
        FC_ELS_RLS_Payload_t                RLS;
        FC_ELS_ECHO_Payload_t               FC_ECHO;
        FC_ELS_TEST_Payload_t               TEST;
        FC_ELS_RRQ_Payload_t                RRQ;
        FC_ELS_PRLI_Payload_t               PRLI;
        FC_ELS_PRLO_Payload_t               PRLO;
        FC_ELS_SCN_Payload_t                SCN;
        FC_ELS_TPLS_Payload_t               TPLS;
        FC_ELS_GAID_Payload_t               GAID;
        FC_ELS_FACT_Payload_t               FACT;
        FC_ELS_FDACT_Payload_t              FDACT;
        FC_ELS_NACT_Payload_t               NACT;
        FC_ELS_NDACT_Payload_t              NDACT;
        FC_ELS_QoSR_Payload_t               QoSR;
        FC_ELS_RVCS_Payload_t               RVCS;
        FC_ELS_PDISC_Payload_t              PDISC;
        FC_ELS_FDISC_Payload_t              FDISC;
        FC_ELS_ADISC_Payload_t              ADISC;
        FC_ELS_TPRLO_Payload_t              TPRLO;
        FC_ELS_RSCN_Payload_t               RSCN;
        FC_ELS_SCR_Payload_t                SCR; 
        FC_ELS_SRR_Payload_t                SRR;
        FC_ELS_FAN_Payload_t                FAN;
#ifdef _DvrArch_1_30_
        FC_ELS_FARP_REQ_Payload_t           FARP;
#endif /* _DvrArch_1_30_ was defined */
      };

/*+
Loop Initialization (Section 10.4, FC-AL
                 and Section 10.4, FC-AL-2)
-*/

/*
 * Note: LoopInit ELS overloads TEST ELS
 *
 *       Check FC_ELS_TEST_Payload_t.ELS_Type os_bit32 for exact
 *       equality to FC_ELS_Type_TEST to detect a LoopInit ELS
 *
 *       In other words, while ELS_Type & FC_ELS_Type_MASK
 *       may be equal to FC_ELS_Type_TEST, ELS_Type may not be
 *       which would indicate this is some sort of LoopInit ELS
 */

#define FC_ELS_Type_LoopInit_Code_MASK                                    0xFFFF0000
#define FC_ELS_Type_LoopInit_Flags_MASK                                   0x0000FFFF

#define FC_ELS_Type_LoopInit_Code_LISM                                    0x11010000
#define FC_ELS_Type_LoopInit_Code_LIFA                                    0x11020000
#define FC_ELS_Type_LoopInit_Code_LIPA                                    0x11030000
#define FC_ELS_Type_LoopInit_Code_LIHA                                    0x11040000
#define FC_ELS_Type_LoopInit_Code_LISA                                    0x11050000
#define FC_ELS_Type_LoopInit_Code_LIRP                                    0x11060000
#define FC_ELS_Type_LoopInit_Code_LILP                                    0x11070000

#define FC_ELS_Type_LoopInit_LISA_Flag_LIRP_And_LILP_Supported            0x00000100

typedef struct FC_ELS_LoopInit_Unknown_Payload_s
               FC_ELS_LoopInit_Unknown_Payload_t;

#define FC_ELS_LoopInit_Unknown_Payload_t_SIZE                            0x00000004

struct FC_ELS_LoopInit_Unknown_Payload_s
       {
         os_bit32 Code_Flags; /* & FC_ELS_Type_MASK == FC_ELS_Type_TEST */
       };

typedef struct FC_ELS_LoopInit_Port_Name_Payload_s
               FC_ELS_LoopInit_Port_Name_Payload_t;

#define FC_ELS_LoopInit_Port_Name_Payload_t_SIZE                          0x0000000C

struct FC_ELS_LoopInit_Port_Name_Payload_s
       {
         os_bit32            Code_Flags; /* & FC_ELS_Type_LoopInit_Code_MASK == FC_ELS_Type_LoopInit_Code_LISM */
         FC_N_Port_Name_t Port_Name;
       };

#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_L_Bit                        0x80000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x00                         0x40000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x01                         0x20000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x02                         0x10000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x04                         0x08000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x08                         0x04000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x0F                         0x02000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x10                         0x01000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x17                         0x00800000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x18                         0x00400000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x1B                         0x00200000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x1D                         0x00100000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x1E                         0x00080000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x1F                         0x00040000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x23                         0x00020000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x25                         0x00010000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x26                         0x00008000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x27                         0x00004000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x29                         0x00002000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x2A                         0x00001000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x2B                         0x00000800
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x2C                         0x00000400
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x2D                         0x00000200
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x2E                         0x00000100
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x31                         0x00000080
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x32                         0x00000040
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x33                         0x00000020
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x34                         0x00000010
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x35                         0x00000008
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x36                         0x00000004
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x39                         0x00000002
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_0_0x3A                         0x00000001

#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x3C                         0x80000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x43                         0x40000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x45                         0x20000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x46                         0x10000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x47                         0x08000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x49                         0x04000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x4A                         0x02000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x4B                         0x01000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x4C                         0x00800000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x4D                         0x00400000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x4E                         0x00200000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x51                         0x00100000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x52                         0x00080000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x53                         0x00040000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x54                         0x00020000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x55                         0x00010000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x56                         0x00008000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x59                         0x00004000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x5A                         0x00002000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x5C                         0x00001000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x63                         0x00000800
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x65                         0x00000400
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x66                         0x00000200
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x67                         0x00000100
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x69                         0x00000080
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x6A                         0x00000040
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x6B                         0x00000020
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x6C                         0x00000010
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x6D                         0x00000008
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x6E                         0x00000004
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x71                         0x00000002
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_1_0x72                         0x00000001

#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x73                         0x80000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x74                         0x40000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x75                         0x20000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x76                         0x10000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x79                         0x08000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x7A                         0x04000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x7C                         0x02000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x80                         0x01000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x81                         0x00800000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x82                         0x00400000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x84                         0x00200000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x88                         0x00100000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x8F                         0x00080000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x90                         0x00040000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x97                         0x00020000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x98                         0x00010000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x9B                         0x00008000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x9D                         0x00004000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x9E                         0x00002000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0x9F                         0x00001000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xA3                         0x00000800
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xA5                         0x00000400
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xA6                         0x00000200
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xA7                         0x00000100
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xA9                         0x00000080
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xAA                         0x00000040
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xAB                         0x00000020
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xAC                         0x00000010
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xAD                         0x00000008
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xAE                         0x00000004
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xB1                         0x00000002
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_2_0xB2                         0x00000001

#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xB3                         0x80000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xB4                         0x40000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xB5                         0x20000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xB6                         0x10000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xB9                         0x08000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xBA                         0x04000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xBC                         0x02000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xC3                         0x01000000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xC5                         0x00800000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xC6                         0x00400000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xC7                         0x00200000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xC9                         0x00100000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xCA                         0x00080000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xCB                         0x00040000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xCC                         0x00020000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xCD                         0x00010000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xCE                         0x00008000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xD1                         0x00004000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xD2                         0x00002000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xD3                         0x00001000
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xD4                         0x00000800
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xD5                         0x00000400
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xD6                         0x00000200
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xD9                         0x00000100
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xDA                         0x00000080
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xDC                         0x00000040
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xE0                         0x00000020
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xE1                         0x00000010
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xE2                         0x00000008
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xE4                         0x00000004
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xE8                         0x00000002
#define FC_ELS_LoopInit_AL_PA_Bit_Map_Word_3_0xEF                         0x00000001

typedef struct FC_ELS_LoopInit_AL_PA_Bit_Map_Payload_s
               FC_ELS_LoopInit_AL_PA_Bit_Map_Payload_t;

#define FC_ELS_LoopInit_AL_PA_Bit_Map_Payload_t_SIZE                      0x00000014

struct FC_ELS_LoopInit_AL_PA_Bit_Map_Payload_s
       {
         os_bit32 Code_Flags; /* & FC_ELS_Type_LoopInit_Code_MASK == FC_ELS_Type_LoopInit_Code_LIFA
                                                               or FC_ELS_Type_LoopInit_Code_LIPA
                                                               or FC_ELS_Type_LoopInit_Code_LIHA
                                                               or FC_ELS_Type_LoopInit_Code_LISA */
         os_bit32 AL_PA_Bit_Map_Word_0;
         os_bit32 AL_PA_Bit_Map_Word_1;
         os_bit32 AL_PA_Bit_Map_Word_2;
         os_bit32 AL_PA_Bit_Map_Word_3;
       };

#define FC_ELS_LoopInit_AP_PA_Position_Map_Slots                                0x7F

typedef struct FC_ELS_LoopInit_AL_PA_Position_Map_Payload_s
               FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t;

#define FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t_SIZE                 0x00000084

struct FC_ELS_LoopInit_AL_PA_Position_Map_Payload_s
       {
         os_bit32 Code_Flags; /* & FC_ELS_Type_LoopInit_Code_MASK == FC_ELS_Type_LoopInit_Code_LIRP
                                                               or FC_ELS_Type_LoopInit_Code_LILP */
         os_bit8  AL_PA_Index;
         os_bit8  AL_PA_Slot[FC_ELS_LoopInit_AP_PA_Position_Map_Slots];
       };

typedef union FC_ELS_LoopInit_Payload_u
              FC_ELS_LoopInit_Payload_t;

union FC_ELS_LoopInit_Payload_u
      {
        FC_ELS_LoopInit_Unknown_Payload_t            Unknown;
        FC_ELS_LoopInit_Port_Name_Payload_t          Port_Name;
        FC_ELS_LoopInit_AL_PA_Bit_Map_Payload_t      AL_PA_Bit_Map;
        FC_ELS_LoopInit_AL_PA_Position_Map_Payload_t AL_PA_Position_Map;
      };

/*+
Name Server (FC-GS-2)
-*/

typedef struct FC_CT_IU_HDR_s
               FC_CT_IU_HDR_t;

#define FC_CT_IU_HDR_t_SIZE                                               0x00000010

struct FC_CT_IU_HDR_s
       {
         os_bit32 Revision__IN_ID;
         os_bit32 FS_Type__FS_Subtype__Options;
         os_bit32 CommandResponse_Code__MaximumResidual_Size;
         os_bit32 Reason_Code__Reason_Code_Explanation__Vendor_Unique;
       };

#define FC_CT_IU_HDR_Revision_MASK                                        0xFF000000

#define FC_CT_IU_HDR_Revision_First_Revision                              0x01000000


#define FC_CT_IU_HDR_IN_ID_MASK                                           0x00FFFFFF

#define FC_CT_IU_HDR_FS_Type_MASK                                         0xFF000000
#define FC_CT_IU_HDR_FS_Type_Alias_Server_Application                     0xF8000000
#define FC_CT_IU_HDR_FS_Type_Management_Service_Application               0xFA000000
#define FC_CT_IU_HDR_FS_Type_Time_Service_Application                     0xFB000000
#define FC_CT_IU_HDR_FS_Type_Directory_Service_Application                0xFC000000
#define FC_CT_IU_HDR_FS_Type_Reserved_Fabric_Controller_Service           0xFD000000

#define FC_CT_IU_HDR_FS_Subtype_MASK                                      0x00FF0000
#define FC_CT_IU_HDR_FS_Subtype_Directory_Name_Service                    0x00020000

#define FC_CT_IU_HDR_Options_MASK                                         0x0000FF00
#define FC_CT_IU_HDR_Options_X_Bit_MASK                                   0x00008000
#define FC_CT_IU_HDR_Options_X_Bit_Single_Exchange                        0x00000000
#define FC_CT_IU_HDR_Options_X_Bit_Multiple_Exchanges                     0x00008000

#define FC_CT_IU_HDR_CommandResponse_Code_MASK                            0xFFFF0000
#define FC_CT_IU_HDR_CommandResponse_Code_Non_FS_IU                       0x00000000
#define FC_CT_IU_HDR_CommandResponse_Code_FS_REQ_IU_First                 0x00010000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GA_NXT                   0x01000000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GPN_ID                   0x01120000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GNN_ID                   0x01130000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GCS_ID                   0x01140000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GFT_ID                   0x01170000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GSPN_ID                  0x01180000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GPT_ID                   0x011A0000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GIPP_ID                  0x011B0000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GID_PN                   0x01210000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GIPP_PN                  0x012B0000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GID_NN                   0x01310000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GIP_NN                   0x01350000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GIPA_NN                  0x01360000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GSNN_NN                  0x01390000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GNN_IP                   0x01530000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GIPA_IP                  0x01560000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GID_FT                   0x01710000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GID_PT                   0x01A10000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GID_IPP                  0x01B10000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_GPN_IPP                  0x01B20000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RPN_ID                   0x02120000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RNN_ID                   0x02130000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RCS_ID                   0x02140000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RFT_ID                   0x02170000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RSPN_ID                  0x02180000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RPT_ID                   0x021A0000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RIPP_ID                  0x021B0000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RIP_NN                   0x02350000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RIPA_NN                  0x02360000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_RSNN_NN                  0x02390000
#define FC_CT_IU_HDR_CommandResponse_Code_NS_REQ_DA_ID                    0x03000000
#define FC_CT_IU_HDR_CommandResponse_Code_FS_REQ_IU_Last                  0x7FFF0000
#define FC_CT_IU_HDR_CommandResponse_Code_FS_RJT_IU                       0x80010000
#define FC_CT_IU_HDR_CommandResponse_Code_FS_ACC_IU                       0x80020000

#define FC_CT_IU_HDR_MaximumResidual_Size_MASK                            0x0000FFFF
#define FC_CT_IU_HDR_MaximumResidual_Size_FS_REQ_No_Maximum               0x00000000
#define FC_CT_IU_HDR_MaximumResidual_Size_FS_REQ_Reserved                 0x0000FFFF
#define FC_CT_IU_HDR_MaximumResidual_Size_FS_ACC_All_Info_Returned        0x00000000
#define FC_CT_IU_HDR_MaximumResidual_Size_FS_ACC_More_Than_65534          0x0000FFFF

#define FC_CT_IU_HDR_Reason_Code_MASK                                     0x00FF0000
#define FC_CT_IU_HDR_Reason_Code_Unused                                   0x00000000
#define FC_CT_IU_HDR_Reason_Code_Invalid_Command_Code                     0x00010000
#define FC_CT_IU_HDR_Reason_Code_Invalid_Version_Level                    0x00020000
#define FC_CT_IU_HDR_Reason_Code_Logical_Error                            0x00030000
#define FC_CT_IU_HDR_Reason_Code_Invalid_IU_Size                          0x00040000
#define FC_CT_IU_HDR_Reason_Code_Logical_Busy                             0x00050000
#define FC_CT_IU_HDR_Reason_Code_Protocol_Error                           0x00070000
#define FC_CT_IU_HDR_Reason_Code_Unable_To_Perform_Command_Request        0x00090000
#define FC_CT_IU_HDR_Reason_Code_Command_Not_Supported                    0x000B0000
#define FC_CT_IU_HDR_Reason_Code_Vendor_Unique_Error                      0x00FF0000

#define FC_CT_IU_HDR_Reason_Code_Explanation_MASK                         0x0000FF00
#define FC_CT_IU_HDR_Reason_Code_Explanation_Unused                       0x00000000
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_No_Additional         0x00000000
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_PortID_Not_Reg        0x00000100
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_PortName_Not_Reg      0x00000200
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_NodeName_Not_Reg      0x00000300
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_Class_Not_Reg         0x00000400
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_Node_IP_Not_Reg       0x00000500
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_IPA_Not_Reg           0x00000600
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_FC_4_TYPEs_Not_Reg    0x00000700
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_Sym_PortName_Not_Reg  0x00000800
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_Sym_NodeName_Not_Reg  0x00000900
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_Port_Type_Not_Reg     0x00000A00
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_Port_IP_Not_Reg       0x00000B00
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_Access_Denied         0x00001000
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_Unacceptable_PortID   0x00001100
#define FC_CT_IU_HDR_Reason_Code_Explanation_NS_RJC_Database_Empty        0x00001200

#define FC_CT_IU_HDR_Vendor_Unique_MASK                                   0x000000FF
#define FC_CT_IU_HDR_Vendor_Unique_Unused                                 0x00000000

typedef os_bit8 FC_NS_Port_Type_t;

#define FC_NS_Port_Type_t_SIZE                                            0x00000001

#define FC_NS_Port_Type_Unidentified                                            0x00
#define FC_NS_Port_Type_N_Port                                                  0x01
#define FC_NS_Port_Type_NL_Port                                                 0x02
#define FC_NS_Port_Type_FNL_Port                                                0x03
#define FC_NS_Port_Type_Nx_Port                                                 0x7F
#define FC_NS_Port_Type_F_Port                                                  0x81
#define FC_NS_Port_Type_FL_Port                                                 0x82
#define FC_NS_Port_Type_E_Port                                                  0x84

typedef os_bit8 FC_NS_Port_ID_t            [3];

#define FC_NS_Port_ID_t_SIZE                                              0x00000003

typedef struct FC_NS_Control_Port_ID_s
               FC_NS_Control_Port_ID_t;

#define FC_NS_Control_Port_ID_t_SIZE                                      0x00000004

struct FC_NS_Control_Port_ID_s
       {
         os_bit8            Control;
         FC_NS_Port_ID_t Port_ID;
       };

#define FC_NS_Control_Port_ID_Control_MASK                                      0x80
#define FC_NS_Control_Port_ID_Control_Not_Last_Port_ID                          0x00
#define FC_NS_Control_Port_ID_Control_Last_Port_ID                              0x80

#define FC_NS_Control_Port_ID_MAX                                               0x80

typedef os_bit8 FC_NS_Port_Name_t          [8];

#define FC_NS_Port_Name_t_SIZE                                            0x00000008

typedef os_bit8 FC_NS_Node_Name_t          [8];

#define FC_NS_Node_Name_t_SIZE                                            0x00000008

#define FC_NS_Symbolic_Port_Name_Len_MAX                                        0xFF

typedef os_bit8 FC_NS_Symbolic_Port_Name_t [FC_NS_Symbolic_Port_Name_Len_MAX];

#define FC_NS_Symbolic_Port_Name_t_SIZE                                   FC_NS_Symbolic_Port_Name_Len_MAX

#define FC_NS_Symbolic_Node_Name_Len_MAX                                        0xFF

typedef os_bit8 FC_NS_Symbolic_Node_Name_t [FC_NS_Symbolic_Node_Name_Len_MAX];

#define FC_NS_Symbolic_Node_Name_t_SIZE                                   FC_NS_Symbolic_Node_Name_Len_MAX

typedef os_bit8 FC_NS_IPA_t                [8];

#define FC_NS_IPA_t_SIZE                                                  0x00000008

typedef os_bit8 FC_NS_IP_Address_t         [16];

#define FC_NS_IP_Address_t_SIZE                                           0x00000010

typedef os_bit8 FC_NS_Class_of_Service_t   [4];

#define FC_NS_Class_of_Service_t_SIZE                                     0x00000004

typedef os_bit32 FC_NS_FC_4_Type_Code_t;

#define FC_NS_FC_4_Type_Code_t_SIZE                                       0x00000004

typedef os_bit8 FC_NS_FC_4_Types_t         [32];

#define FC_NS_FC_4_Types_t_SIZE                                           0x00000020

typedef struct FC_NS_DU_GA_NXT_Request_Payload_s
               FC_NS_DU_GA_NXT_Request_Payload_t;

#define FC_NS_DU_GA_NXT_Request_Payload_t_SIZE                            0x00000004

struct FC_NS_DU_GA_NXT_Request_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GA_NXT_FS_ACC_Payload_s
               FC_NS_DU_GA_NXT_FS_ACC_Payload_t;

#define FC_NS_DU_GA_NXT_FS_ACC_Payload_t_SIZE                             0x00000260

struct FC_NS_DU_GA_NXT_FS_ACC_Payload_s
       {
         FC_NS_Port_Type_t          Port_Type;
         FC_NS_Port_ID_t            Port_ID;
         FC_NS_Port_Name_t          Port_Name;
         os_bit8                       Symbolic_Port_Name_LEN;
         FC_NS_Symbolic_Port_Name_t Symbolic_Port_Name;
         FC_NS_Node_Name_t          Node_Name;
         os_bit8                       Symbolic_Node_Name_LEN;
         FC_NS_Symbolic_Node_Name_t Symbolic_Node_Name;
         FC_NS_IPA_t                IPA;
         FC_NS_IP_Address_t         Node_IP_Address;
         FC_NS_Class_of_Service_t   Class_of_Service;
         FC_NS_FC_4_Types_t         FC_4_Types;
         FC_NS_IP_Address_t         Port_IP_Address;
       };

typedef struct FC_NS_DU_GPN_ID_Request_Payload_s
               FC_NS_DU_GPN_ID_Request_Payload_t;

#define FC_NS_DU_GPN_ID_Request_Payload_t_SIZE                            0x00000004

struct FC_NS_DU_GPN_ID_Request_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GPN_ID_FS_ACC_Payload_s
               FC_NS_DU_GPN_ID_FS_ACC_Payload_t;

#define FC_NS_DU_GPN_ID_FS_ACC_Payload_t_SIZE                             0x00000008

struct FC_NS_DU_GPN_ID_FS_ACC_Payload_s
       {
         FC_NS_Port_Name_t Port_Name;
       };

typedef struct FC_NS_DU_GNN_ID_Request_Payload_s
               FC_NS_DU_GNN_ID_Request_Payload_t;

#define FC_NS_DU_GNN_ID_Request_Payload_t_SIZE                            0x00000004

struct FC_NS_DU_GNN_ID_Request_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GNN_ID_FS_ACC_Payload_s
               FC_NS_DU_GNN_ID_FS_ACC_Payload_t;

#define FC_NS_DU_GNN_ID_FS_ACC_Payload_t_SIZE                             0x00000008

struct FC_NS_DU_GNN_ID_FS_ACC_Payload_s
       {
         FC_NS_Node_Name_t Node_Name;
       };

typedef struct FC_NS_DU_GCS_ID_Request_Payload_s
               FC_NS_DU_GCS_ID_Request_Payload_t;

#define FC_NS_DU_GCS_ID_Request_Payload_t_SIZE                            0x00000004

struct FC_NS_DU_GCS_ID_Request_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GCS_ID_FS_ACC_Payload_s
               FC_NS_DU_GCS_ID_FS_ACC_Payload_t;

#define FC_NS_DU_GCS_ID_FS_ACC_Payload_t_SIZE                             0x00000004

struct FC_NS_DU_GCS_ID_FS_ACC_Payload_s
       {
         FC_NS_Class_of_Service_t Class_of_Service;
       };

typedef struct FC_NS_DU_GFT_ID_Request_Payload_s
               FC_NS_DU_GFT_ID_Request_Payload_t;

#define FC_NS_DU_GFT_ID_Request_Payload_t_SIZE                            0x00000004

struct FC_NS_DU_GFT_ID_Request_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GFT_ID_FS_ACC_Payload_s
               FC_NS_DU_GFT_ID_FS_ACC_Payload_t;

#define FC_NS_DU_GFT_ID_FS_ACC_Payload_t_SIZE                             0x00000020

struct FC_NS_DU_GFT_ID_FS_ACC_Payload_s
       {
         FC_NS_FC_4_Types_t FC_4_Types;
       };

typedef struct FC_NS_DU_GSPN_ID_Request_Payload_s
               FC_NS_DU_GSPN_ID_Request_Payload_t;

#define FC_NS_DU_GSPN_ID_Request_Payload_t_SIZE                           0x00000004

struct FC_NS_DU_GSPN_ID_Request_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GSPN_ID_FS_ACC_Payload_s
               FC_NS_DU_GSPN_ID_FS_ACC_Payload_t;

#define FC_NS_DU_GSPN_ID_FS_ACC_Payload_t_SIZE                            0x00000100

struct FC_NS_DU_GSPN_ID_FS_ACC_Payload_s
       {
         os_bit8                    Symbolic_Port_Name_LEN;
         FC_NS_Symbolic_Port_Name_t Symbolic_Port_Name;
       };

typedef struct FC_NS_DU_GPT_ID_Request_Payload_s
               FC_NS_DU_GPT_ID_Request_Payload_t;

#define FC_NS_DU_GPT_ID_Request_Payload_t_SIZE                            0x00000004

struct FC_NS_DU_GPT_ID_Request_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GPT_ID_FS_ACC_Payload_s
               FC_NS_DU_GPT_ID_FS_ACC_Payload_t;

#define FC_NS_DU_GPT_ID_FS_ACC_Payload_t_SIZE                             0x00000004

struct FC_NS_DU_GPT_ID_FS_ACC_Payload_s
       {
         FC_NS_Port_Type_t Port_Type;
         os_bit8              Reserved[3];
       };

typedef struct FC_NS_DU_GIPP_ID_Request_Payload_s
               FC_NS_DU_GIPP_ID_Request_Payload_t;

#define FC_NS_DU_GIPP_ID_Request_Payload_t_SIZE                           0x00000004

struct FC_NS_DU_GIPP_ID_Request_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GIPP_ID_FS_ACC_Payload_s
               FC_NS_DU_GIPP_ID_FS_ACC_Payload_t;

#define FC_NS_DU_GIPP_ID_FS_ACC_Payload_t_SIZE                            0x00000010

struct FC_NS_DU_GIPP_ID_FS_ACC_Payload_s
       {
         FC_NS_IP_Address_t Port_IP_Address;
       };

typedef struct FC_NS_DU_GID_PN_Request_Payload_s
               FC_NS_DU_GID_PN_Request_Payload_t;

#define FC_NS_DU_GID_PN_Request_Payload_t_SIZE                            0x00000008

struct FC_NS_DU_GID_PN_Request_Payload_s
       {
         FC_NS_Port_Name_t Port_Name;
       };

typedef struct FC_NS_DU_GID_PN_FS_ACC_Payload_s
               FC_NS_DU_GID_PN_FS_ACC_Payload_t;

#define FC_NS_DU_GID_PN_FS_ACC_Payload_t_SIZE                             0x00000004

struct FC_NS_DU_GID_PN_FS_ACC_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GIPP_PN_Request_Payload_s
               FC_NS_DU_GIPP_PN_Request_Payload_t;

#define FC_NS_DU_GIPP_PN_Request_Payload_t_SIZE                           0x00000008

struct FC_NS_DU_GIPP_PN_Request_Payload_s
       {
         FC_NS_Port_Name_t Port_Name;
       };

typedef struct FC_NS_DU_GIPP_PN_FS_ACC_Payload_s
               FC_NS_DU_GIPP_PN_FS_ACC_Payload_t;

#define FC_NS_DU_GIPP_PN_FS_ACC_Payload_t_SIZE                            0x00000010

struct FC_NS_DU_GIPP_PN_FS_ACC_Payload_s
       {
         FC_NS_IP_Address_t Port_IP_Address;
       };

typedef struct FC_NS_DU_GID_NN_Request_Payload_s
               FC_NS_DU_GID_NN_Request_Payload_t;

#define FC_NS_DU_GID_NN_Request_Payload_t_SIZE                            0x00000008

struct FC_NS_DU_GID_NN_Request_Payload_s
       {
         FC_NS_Node_Name_t Node_Name;
       };

typedef struct FC_NS_DU_GID_NN_FS_ACC_Payload_s
               FC_NS_DU_GID_NN_FS_ACC_Payload_t;

#define FC_NS_DU_GID_NN_FS_ACC_Payload_t_SIZE                             0x00000200

struct FC_NS_DU_GID_NN_FS_ACC_Payload_s
       {
         FC_NS_Control_Port_ID_t Control_Port_ID[FC_NS_Control_Port_ID_MAX];
       };

typedef struct FC_NS_DU_GIP_NN_Request_Payload_s
               FC_NS_DU_GIP_NN_Request_Payload_t;

#define FC_NS_DU_GIP_NN_Request_Payload_t_SIZE                            0x00000008

struct FC_NS_DU_GIP_NN_Request_Payload_s
       {
         FC_NS_Node_Name_t Node_Name;
       };

typedef struct FC_NS_DU_GIP_NN_FS_ACC_Payload_s
               FC_NS_DU_GIP_NN_FS_ACC_Payload_t;

#define FC_NS_DU_GIP_NN_FS_ACC_Payload_t_SIZE                             0x00000010

struct FC_NS_DU_GIP_NN_FS_ACC_Payload_s
       {
         FC_NS_IP_Address_t Node_IP_Address;
       };

typedef struct FC_NS_DU_GIPA_NN_Request_Payload_s
               FC_NS_DU_GIPA_NN_Request_Payload_t;

#define FC_NS_DU_GIPA_NN_Request_Payload_t_SIZE                           0x00000008

struct FC_NS_DU_GIPA_NN_Request_Payload_s
       {
         FC_NS_Node_Name_t Node_Name;
       };

typedef struct FC_NS_DU_GIPA_NN_FS_ACC_Payload_s
               FC_NS_DU_GIPA_NN_FS_ACC_Payload_t;

#define FC_NS_DU_GIPA_NN_FS_ACC_Payload_t_SIZE                            0x00000008

struct FC_NS_DU_GIPA_NN_FS_ACC_Payload_s
       {
         FC_NS_IPA_t IPA;
       };

typedef struct FC_NS_DU_GSNN_NN_Request_Payload_s
               FC_NS_DU_GSNN_NN_Request_Payload_t;

#define FC_NS_DU_GSNN_NN_Request_Payload_t_SIZE                           0x00000008

struct FC_NS_DU_GSNN_NN_Request_Payload_s
       {
         FC_NS_Node_Name_t Node_Name;
       };

typedef struct FC_NS_DU_GSNN_NN_FS_ACC_Payload_s
               FC_NS_DU_GSNN_NN_FS_ACC_Payload_t;

#define FC_NS_DU_GSNN_NN_FS_ACC_Payload_t_SIZE                            0x00000100

struct FC_NS_DU_GSNN_NN_FS_ACC_Payload_s
       {
         os_bit8                       Symbolic_Node_Name_LEN;
         FC_NS_Symbolic_Node_Name_t Symbolic_Node_Name;
       };

typedef struct FC_NS_DU_GNN_IP_Request_Payload_s
               FC_NS_DU_GNN_IP_Request_Payload_t;

#define FC_NS_DU_GNN_IP_Request_Payload_t_SIZE                            0x00000010

struct FC_NS_DU_GNN_IP_Request_Payload_s
       {
         FC_NS_IP_Address_t Node_IP_Address;
       };

typedef struct FC_NS_DU_GNN_IP_FS_ACC_Payload_s
               FC_NS_DU_GNN_IP_FS_ACC_Payload_t;

#define FC_NS_DU_GNN_IP_FS_ACC_Payload_t_SIZE                             0x00000008

struct FC_NS_DU_GNN_IP_FS_ACC_Payload_s
       {
         FC_NS_Node_Name_t Node_Name;
       };

typedef struct FC_NS_DU_GIPA_IP_Request_Payload_s
               FC_NS_DU_GIPA_IP_Request_Payload_t;

#define FC_NS_DU_GIPA_IP_Request_Payload_t_SIZE                           0x00000010

struct FC_NS_DU_GIPA_IP_Request_Payload_s
       {
         FC_NS_IP_Address_t Node_IP_Address;
       };

typedef struct FC_NS_DU_GIPA_IP_FS_ACC_Payload_s
               FC_NS_DU_GIPA_IP_FS_ACC_Payload_t;

#define FC_NS_DU_GIPA_IP_FS_ACC_Payload_t_SIZE                            0x00000008

struct FC_NS_DU_GIPA_IP_FS_ACC_Payload_s
       {
         FC_NS_IPA_t IPA;
       };

typedef struct FC_NS_DU_GID_FT_Request_Payload_s
               FC_NS_DU_GID_FT_Request_Payload_t;

#define FC_NS_DU_GID_FT_Request_Payload_t_SIZE                            0x00000004

struct FC_NS_DU_GID_FT_Request_Payload_s
       {
         FC_NS_FC_4_Type_Code_t FC_4_Type_Code;
       };

#define FC_NS_DU_GID_FT_FC_Frame_Header_TYPE_SCSI_FCP_Shift               0x18

typedef struct FC_NS_DU_GID_FT_FS_ACC_Payload_s
               FC_NS_DU_GID_FT_FS_ACC_Payload_t;

#define FC_NS_DU_GID_FT_FS_ACC_Payload_t_SIZE                             0x00000200

struct FC_NS_DU_GID_FT_FS_ACC_Payload_s
       {
         FC_NS_Control_Port_ID_t Control_Port_ID[FC_NS_Control_Port_ID_MAX];
       };

typedef struct FC_NS_DU_GID_PT_Request_Payload_s
               FC_NS_DU_GID_PT_Request_Payload_t;

#define FC_NS_DU_GID_PT_Request_Payload_t_SIZE                            0x00000004

struct FC_NS_DU_GID_PT_Request_Payload_s
       {
         FC_NS_Port_Type_t Port_Type;
         os_bit8              Reserved[3];
       };

typedef struct FC_NS_DU_GID_PT_FS_ACC_Payload_s
               FC_NS_DU_GID_PT_FS_ACC_Payload_t;

#define FC_NS_DU_GID_PT_FS_ACC_Payload_t_SIZE                             0x00000200

struct FC_NS_DU_GID_PT_FS_ACC_Payload_s
       {
         FC_NS_Control_Port_ID_t Control_Port_ID[FC_NS_Control_Port_ID_MAX];
       };

typedef struct FC_NS_DU_GID_IPP_Request_Payload_s
               FC_NS_DU_GID_IPP_Request_Payload_t;

#define FC_NS_DU_GID_IPP_Request_Payload_t_SIZE                           0x00000010

struct FC_NS_DU_GID_IPP_Request_Payload_s
       {
         FC_NS_IP_Address_t Port_IP_Address;
       };

typedef struct FC_NS_DU_GID_IPP_FS_ACC_Payload_s
               FC_NS_DU_GID_IPP_FS_ACC_Payload_t;

#define FC_NS_DU_GID_IPP_FS_ACC_Payload_t_SIZE                            0x00000004

struct FC_NS_DU_GID_IPP_FS_ACC_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
       };

typedef struct FC_NS_DU_GPN_IPP_Request_Payload_s
               FC_NS_DU_GPN_IPP_Request_Payload_t;

#define FC_NS_DU_GPN_IPP_Request_Payload_t_SIZE                           0x00000010

struct FC_NS_DU_GPN_IPP_Request_Payload_s
       {
         FC_NS_IP_Address_t Port_IP_Address;
       };

typedef struct FC_NS_DU_GPN_IPP_FS_ACC_Payload_s
               FC_NS_DU_GPN_IPP_FS_ACC_Payload_t;

#define FC_NS_DU_GPN_IPP_FS_ACC_Payload_t_SIZE                            0x00000008

struct FC_NS_DU_GPN_IPP_FS_ACC_Payload_s
       {
         FC_NS_Port_Name_t Port_Name;
       };

typedef struct FC_NS_DU_RPN_ID_Payload_s
               FC_NS_DU_RPN_ID_Payload_t;

#define FC_NS_DU_RPN_ID_Payload_t_SIZE                                    0x0000000C

struct FC_NS_DU_RPN_ID_Payload_s
       {
         FC_Port_ID_Struct_Form_t   Port_ID;
         FC_NS_Port_Name_t          Port_Name;
       };

typedef struct FC_NS_DU_RNN_ID_Payload_s
               FC_NS_DU_RNN_ID_Payload_t;

#define FC_NS_DU_RNN_ID_Payload_t_SIZE                                    0x0000000C

struct FC_NS_DU_RNN_ID_Payload_s
       {
            FC_Port_ID_Struct_Form_t Port_ID;
            FC_NS_Node_Name_t        Node_Name;
       };

typedef struct FC_NS_DU_RCS_ID_Payload_s
               FC_NS_DU_RCS_ID_Payload_t;

#define FC_NS_DU_RCS_ID_Payload_t_SIZE                                    0x00000008

struct FC_NS_DU_RCS_ID_Payload_s
       {
         FC_Port_ID_Struct_Form_t Port_ID;
         FC_NS_Class_of_Service_t Class_of_Service;
       };

typedef struct FC_NS_DU_RFT_ID_Payload_s
               FC_NS_DU_RFT_ID_Payload_t;

#define FC_NS_DU_RFT_ID_Payload_t_SIZE                                    0x00000024

struct FC_NS_DU_RFT_ID_Payload_s
       {
         FC_Port_ID_Struct_Form_t Port_ID;
         FC_NS_FC_4_Types_t FC_4_Types;
       };

typedef struct FC_NS_DU_RSPN_ID_Payload_s
               FC_NS_DU_RSPN_ID_Payload_t;

#define FC_NS_DU_RSPN_ID_Payload_t_SIZE                                   0x00000104

struct FC_NS_DU_RSPN_ID_Payload_s
       {
         FC_Port_ID_Struct_Form_t Port_ID;
         os_bit8                   Symbolic_Port_Name_LEN;
         FC_NS_Symbolic_Port_Name_t Symbolic_Port_Name;
       };

typedef struct FC_NS_DU_RPT_ID_Payload_s
               FC_NS_DU_RPT_ID_Payload_t;

#define FC_NS_DU_RPT_ID_Payload_t_SIZE                                    0x00000008

struct FC_NS_DU_RPT_ID_Payload_s
       {
         FC_Port_ID_Struct_Form_t Port_ID;
         FC_NS_Port_Type_t Port_Type;
         os_bit8              Reserved_2[3];
       };

typedef struct FC_NS_DU_RIPP_ID_Payload_s
               FC_NS_DU_RIPP_ID_Payload_t;

#define FC_NS_DU_RIPP_ID_Payload_t_SIZE                                   0x00000014

struct FC_NS_DU_RIPP_ID_Payload_s
       {
         FC_Port_ID_Struct_Form_t Port_ID;
         FC_NS_IP_Address_t Port_IP_Address;
       };

typedef struct FC_NS_DU_RIP_NN_Payload_s
               FC_NS_DU_RIP_NN_Payload_t;

#define FC_NS_DU_RIP_NN_Payload_t_SIZE                                    0x00000018

struct FC_NS_DU_RIP_NN_Payload_s
       {
         FC_NS_Node_Name_t  Node_Name;
         FC_NS_IP_Address_t Node_IP_Address;
       };

typedef struct FC_NS_DU_RIPA_NN_Payload_s
               FC_NS_DU_RIPA_NN_Payload_t;

#define FC_NS_DU_RIPA_NN_Payload_t_SIZE                                   0x00000010

struct FC_NS_DU_RIPA_NN_Payload_s
       {
         FC_NS_Node_Name_t Node_Name;
         FC_NS_IPA_t       IPA;
       };

typedef struct FC_NS_DU_RSNN_NN_Payload_s
               FC_NS_DU_RSNN_NN_Payload_t;

#define FC_NS_DU_RSNN_NN_Payload_t_SIZE                                   0x00000108

struct FC_NS_DU_RSNN_NN_Payload_s
       {
         FC_NS_Node_Name_t          Node_Name;
         os_bit8                       Symbolic_Node_Name_LEN;
         FC_NS_Symbolic_Node_Name_t Symbolic_Node_Name;
       };

typedef struct FC_NS_DU_DA_ID_Payload_s
               FC_NS_DU_DA_ID_Payload_t;

#define FC_NS_DU_DA_ID_Payload_t_SIZE                                     0x00000004

struct FC_NS_DU_DA_ID_Payload_s
       {
         FC_Port_ID_Struct_Form_t Port_ID;
       };

/*+
FCP Services (Section 7, FCP-SCSI
            and Annex C, FCP-SCSI)
-*/

#define FC_FCP_CMND_FcpLun_LEVELS                                                  4

#define FC_FCP_CMND_FCP_LUN_0                                                      0
#define FC_FCP_CMND_FCP_LUN_1                                                      1
#define FC_FCP_CMND_FCP_LUN_2                                                      2
#define FC_FCP_CMND_FCP_LUN_3                                                      3

#define FC_FCP_CMND_FcpLun_LEVEL_1                                        FC_FCP_CMND_FCP_LUN_0
#define FC_FCP_CMND_FcpLun_LEVEL_2                                        FC_FCP_CMND_FCP_LUN_1
#define FC_FCP_CMND_FcpLun_LEVEL_3                                        FC_FCP_CMND_FCP_LUN_2
#define FC_FCP_CMND_FcpLun_LEVEL_4                                        FC_FCP_CMND_FCP_LUN_3

typedef struct FC_FCP_CMND_FcpLun_LEVEL_s
               FC_FCP_CMND_FcpLun_LEVEL_t;

#define FC_FCP_CMND_FcpLun_LEVEL_t_SIZE                                   0x00000002

struct FC_FCP_CMND_FcpLun_LEVEL_s
       {
         os_bit8 Byte_0;
         os_bit8 Byte_1;
       };

#define FC_FCP_CMND_FcpLun_LEVEL_Byte_0_AddessMethod_MASK                       0xC0
#define FC_FCP_CMND_FcpLun_LEVEL_Byte_0_AddessMethod_Peripheral                 0x00
#define FC_FCP_CMND_FcpLun_LEVEL_Byte_0_AddessMethod_VolumeSet                  0x40
#define FC_FCP_CMND_FcpLun_LEVEL_Byte_0_AddessMethod_LUN                        0x80
#define FC_FCP_CMND_FcpLun_LEVEL_Byte_0_AddessMethod_Reserved                   0xC0

/*
   Peripheral AddressMethod

                    bit number
              7  6  5  4  3  2  1  0
            +-=--=--=--=--=--=--=--=
          0 | 0  0  ----------Bus---   If Bus == 0, Byte 1 contains LUN
     byte   |
          1 | ---------Target/LUN---   If Bus != 0, Byte 1 contains Target
*/

#define FC_FCP_CMND_FcpLun_LEVEL_Peripheral_AM_Byte_0_Bus_MASK                  0x3F
#define FC_FCP_CMND_FcpLun_LEVEL_Peripheral_AM_Byte_0_Bus_SHIFT                 0x00

#define FC_FCP_CMND_FcpLun_LEVEL_Peripheral_AM_Byte_1_Target_MASK               0xFF
#define FC_FCP_CMND_FcpLun_LEVEL_Peripheral_AM_Byte_1_Target_SHIFT              0x00

#define FC_FCP_CMND_FcpLun_LEVEL_Peripheral_AM_Byte_1_LUN_MASK                  0xFF
#define FC_FCP_CMND_FcpLun_LEVEL_Peripheral_AM_Byte_1_LUN_SHIFT                 0x00

/*
   VolumeSet AddressMethod

                    bit number
              7  6  5  4  3  2  1  0
            +-=--=--=--=--=--=--=--=
          0 | 0  1  ----LUN[13:8]---
     byte   |
          1 | -----------LUN[7:0]---
*/

#define FC_FCP_CMND_FcpLun_LEVEL_VolumeSet_AM_LUN_Hi_Part_MASK                0x3F00
#define FC_FCP_CMND_FcpLun_LEVEL_VolumeSet_AM_LUN_Hi_Part_SHIFT                 0x08

#define FC_FCP_CMND_FcpLun_LEVEL_VolumeSet_AM_LUN_Lo_Part_MASK                0x00FF
#define FC_FCP_CMND_FcpLun_LEVEL_VolumeSet_AM_LUN_Lo_Part_SHIFT                 0x00

#define FC_FCP_CMND_FcpLun_LEVEL_VolumeSet_AM_Byte_0_LUN_Hi_MASK                0x3F
#define FC_FCP_CMND_FcpLun_LEVEL_VolumeSet_AM_Byte_0_LUN_Hi_SHIFT               0x00

#define FC_FCP_CMND_FcpLun_LEVEL_VolumeSet_AM_Byte_1_LUN_Lo_MASK                0xFF
#define FC_FCP_CMND_FcpLun_LEVEL_VolumeSet_AM_Byte_1_LUN_Lo_SHIFT               0x00

/*
   LUN AddressMethod

                    bit number
              7  6  5  4  3  2  1  0
            +-=--=--=--=--=--=--=--=
          0 | 1  0  -------Target---
     byte   |
          1 | --Bus--  -------LUN---
*/

#define FC_FCP_CMND_FcpLun_LEVEL_LUN_AM_Byte_0_Target_MASK                      0x3F
#define FC_FCP_CMND_FcpLun_LEVEL_LUN_AM_Byte_0_Target_SHIFT                     0x00

#define FC_FCP_CMND_FcpLun_LEVEL_LUN_AM_Byte_1_Bus_MASK                         0xE0
#define FC_FCP_CMND_FcpLun_LEVEL_LUN_AM_Byte_1_Bus_SHIFT                        0x05

#define FC_FCP_CMND_FcpLun_LEVEL_LUN_AM_Byte_1_LUN_MASK                         0x1F
#define FC_FCP_CMND_FcpLun_LEVEL_LUN_AM_Byte_1_LUN_SHIFT                        0x00

typedef struct FC_FCP_CMND_FcpCntl_s
               FC_FCP_CMND_FcpCntl_t;

#define FC_FCP_CMND_FcpCntl_t_SIZE                                        0x00000004

struct FC_FCP_CMND_FcpCntl_s
       {
         os_bit8 Reserved_Bit8;
         os_bit8 TaskCodes;
         os_bit8 TaskManagementFlags;
         os_bit8 ExecutionManagementCodes;
       };

#define FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_MASK                        0x07
#define FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_SIMPLE_Q                    0x00
#define FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_HEAD_OF_Q                   0x01
#define FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_ORDERED_Q                   0x02
#define FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_ACA_Q                       0x04
#define FC_FCP_CMND_FcpCntl_TaskCodes_TaskAttribute_UNTAGGED                    0x05

#define FC_FCP_CMND_FcpCntl_TaskManagementFlags_TERMINATE_TASK                  0x80
#define FC_FCP_CMND_FcpCntl_TaskManagementFlags_CLEAR_ACA                       0x40
#define FC_FCP_CMND_FcpCntl_TaskManagementFlags_TARGET_RESET                    0x20
#define FC_FCP_CMND_FcpCntl_TaskManagementFlags_CLEAR_TASK_SET                  0x04
#define FC_FCP_CMND_FcpCntl_TaskManagementFlags_ABORT_TASK_SET                  0x02

#define FC_FCP_CMND_FcpCntl_ExecutionManagementCodes_READ_DATA                  0x02
#define FC_FCP_CMND_FcpCntl_ExecutionManagementCodes_WRITE_DATA                 0x01

typedef struct FC_FCP_CMND_Payload_s
               FC_FCP_CMND_Payload_t;

#define FC_FCP_CMND_Payload_t_SIZE                                        0x00000020

struct FC_FCP_CMND_Payload_s
       {
         FC_FCP_CMND_FcpLun_LEVEL_t FcpLun[FC_FCP_CMND_FcpLun_LEVELS];
         FC_FCP_CMND_FcpCntl_t      FcpCntl;
         os_bit8                       FcpCdb[16];
         os_bit32                      FcpDL;
       };

typedef struct FC_FCP_RSP_FCP_STATUS_s
               FC_FCP_RSP_FCP_STATUS_t;

#define FC_FCP_RSP_FCP_STATUS_t_SIZE                                      0x00000004

struct FC_FCP_RSP_FCP_STATUS_s
       {
         os_bit8 Reserved_Bit8_0;
         os_bit8 Reserved_Bit8_1;
         os_bit8 ValidityStatusIndicators;
         os_bit8 SCSI_status_byte;
       };

#define FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RESID_UNDER          0x08
#define FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RESID_OVER           0x04
#define FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_SNS_LEN_VALID        0x02
#define FC_FCP_RSP_FCP_STATUS_ValidityStatusIndicators_FCP_RSP_LEN_VALID        0x01

typedef struct FC_FCP_RSP_Payload_s
               FC_FCP_RSP_Payload_t;

#define FC_FCP_RSP_Payload_t_SIZE                                         0x00000018

struct FC_FCP_RSP_Payload_s
       {
         os_bit32                   Reserved_Bit32_0;
         os_bit32                   Reserved_Bit32_1;
         FC_FCP_RSP_FCP_STATUS_t FCP_STATUS;
         os_bit32                   FCP_RESID;
         os_bit32                   FCP_SNS_LEN;
         os_bit32                   FCP_RSP_LEN;
       };

/*+
Function:  FCStructASSERTs()

Purpose:   Returns the number of FCStruct.H typedefs which are not the correct size.

Algorithm: Each typedef in FCStruct.H is checked for having the correct size.  While
           this property doesn't guarantee correct packing of the fields within, it
           is a pretty good indicator that the typedef has the intended layout.

           The total number of typedefs which are not of correct size is returned from
           this function.  Hence, if the return value is non-zero, the declarations
           can not be trusted to match the various Fibre Channel specifications.
-*/

osGLOBAL os_bit32 FCStructASSERTs(
                              void
                            );

#endif /* __FCStruct_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\flashsvc.h ===
/*++

Copyright (c) 2000 Agilent Technologies.

Version Control Information:

   $Archive: /Drivers/Common/AU00/H/FlashSvc.H $

  $Revision:: 2               $
      $Date:: 3/20/01 3:36p   $ (Last Check-In)
   $Modtime:: 10/24/00 6:54p  $ (Last Modified)

Purpose:

  This file defines the macros, types, and data structures used by ../C/FlashSvc.C

--*/

#ifndef __FlashSvc_H__
#define __FlashSvc_H__

#define FlashChip Am29F010

/* Sector Layout */

#define Am29F010_Num_Sectors                                              8

#define Am29F010_Sector_MASK                                     0x0001C000
#define Am29F010_Sector_SHIFT                                          0x0E
#define Am29F010_Sector_SIZE                                     0x00004000
#define Am29F010_Sector_Offset_MASK                              0x00003FFF

#define Am29F010_SIZE                                            (Am29F010_Num_Sectors * Am29F010_Sector_SIZE)

/* Reset */

#define Am29F010_Reset_Cmd1_OFFSET                               0x00000000
#define Am29F010_Reset_Cmd1_DATA                                       0xF0

/* Autoselect */

#define Am29F010_Autoselect_Cmd1_OFFSET                          0x00005555
#define Am29F010_Autoselect_Cmd1_DATA                                  0xAA

#define Am29F010_Autoselect_Cmd2_OFFSET                          0x00002AAA
#define Am29F010_Autoselect_Cmd2_DATA                                  0x55

#define Am29F010_Autoselect_Cmd3_OFFSET                          0x00005555
#define Am29F010_Autoselect_Cmd3_DATA                                  0x90

#define Am29F010_Autoselect_ManufacturerID_OFFSET                0x00000000
#define Am29F010_Autoselect_ManafacturerID_DATA                        0x01

#define Am29F010_Autoselect_DeviceID_OFFSET                      0x00000001
#define Am29F010_Autoselect_DeviceID_DATA                              0x20

#define Am29F010_Autoselect_SectorProtectVerify_OFFSET_by_Sector_Number(SectorNumber) \
            (((SectorNumber) << Am29F010_Sector_SHIFT) | 0x00000002)

#define Am29F010_Autoselect_SectorProtectVerify_OFFSET_by_Sector_Base(SectorBase) \
            (((SectorBase) & Am29F010_Sector_MASK) | 0x00000002)

#define Am29F010_Autoselect_SectorProtectVerify_DATA_Unprotected       0x00
#define Am29F010_Autoselect_SectorProtectVerify_DATA_Protected         0x01

/* Program */

#define Am29F010_Program_Cmd1_OFFSET                             0x00005555
#define Am29F010_Program_Cmd1_DATA                                     0xAA

#define Am29F010_Program_Cmd2_OFFSET                             0x00002AAA
#define Am29F010_Program_Cmd2_DATA                                     0x55

#define Am29F010_Program_Cmd3_OFFSET                             0x00005555
#define Am29F010_Program_Cmd3_DATA                                     0xA0

/* Erased-to Value */

#define Am29F010_Erased_Bit8                                           0xFF
#define Am29F010_Erased_Bit16                                        0xFFFF
#define Am29F010_Erased_Bit32                                    0xFFFFFFFF

/* Chip Erase */

#define Am29F010_Chip_Erase_Cmd1_OFFSET                          0x00005555
#define Am29F010_Chip_Erase_Cmd1_DATA                                  0xAA

#define Am29F010_Chip_Erase_Cmd2_OFFSET                          0x00002AAA
#define Am29F010_Chip_Erase_Cmd2_DATA                                  0x55

#define Am29F010_Chip_Erase_Cmd3_OFFSET                          0x00005555
#define Am29F010_Chip_Erase_Cmd3_DATA                                  0x80

#define Am29F010_Chip_Erase_Cmd4_OFFSET                          0x00005555
#define Am29F010_Chip_Erase_Cmd4_DATA                                  0xAA

#define Am29F010_Chip_Erase_Cmd5_OFFSET                          0x00002AAA
#define Am29F010_Chip_Erase_Cmd5_DATA                                  0x55

#define Am29F010_Chip_Erase_Cmd6_OFFSET                          0x00005555
#define Am29F010_Chip_Erase_Cmd6_DATA                                  0x10

/* Sector Erase */

#define Am29F010_Sector_Erase_Cmd1_OFFSET                        0x00005555
#define Am29F010_Sector_Erase_Cmd1_DATA                                0xAA

#define Am29F010_Sector_Erase_Cmd2_OFFSET                        0x00002AAA
#define Am29F010_Sector_Erase_Cmd2_DATA                                0x55

#define Am29F010_Sector_Erase_Cmd3_OFFSET                        0x00005555
#define Am29F010_Sector_Erase_Cmd3_DATA                                0x80

#define Am29F010_Sector_Erase_Cmd4_OFFSET                        0x00005555
#define Am29F010_Sector_Erase_Cmd4_DATA                                0xAA

#define Am29F010_Sector_Erase_Cmd5_OFFSET                        0x00002AAA
#define Am29F010_Sector_Erase_Cmd5_DATA                                0x55

#define Am29F010_Sector_Erase_Cmd6_OFFSET_by_Sector_Number(SectorNumber) \
            ((SectorNumber) << Am29F010_Sector_SHIFT)

#define Am29F010_Sector_Erase_Cmd6_OFFSET_by_Sector_Base(SectorBase) \
            ((SectorBase) & Am29F010_Sector_MASK)

#define Am29F010_Sector_Erase_Cmd6_DATA                                0x30

/* Write Operation Status */

#define Am29F010_Polling_Bit_MASK                                      0x80
#define Am29F010_Toggle_Bit_MASK                                       0x40
#define Am29F010_Exceeded_Timing_Limits_MASK                           0x20
#define Am29F010_Sector_Erase_Timer_MASK                               0x08

/* Byte Order Preservation Typedefs */

typedef union fiFlashBit16ToBit8s_u
              fiFlashBit16ToBit8s_t;

union fiFlashBit16ToBit8s_u {
                              os_bit16 bit_16_form;
                              os_bit8  bit_8s_form[sizeof(os_bit16)];
                            };

typedef union fiFlashBit32ToBit8s_u
              fiFlashBit32ToBit8s_t;

union fiFlashBit32ToBit8s_u {
                              os_bit32 bit_32_form;
                              os_bit8  bit_8s_form[sizeof(os_bit32)];
                            };

/* Flash Image Layout */

typedef struct fiFlashSector_Bit8_Form_s
               fiFlashSector_Bit8_Form_t;

struct fiFlashSector_Bit8_Form_s {
                                   os_bit8 Bit8[Am29F010_Sector_SIZE/sizeof(os_bit8)];
                                 };

typedef struct fiFlashSector_Bit16_Form_s
               fiFlashSector_Bit16_Form_t;

struct fiFlashSector_Bit16_Form_s {
                                    os_bit16 Bit16[Am29F010_Sector_SIZE/sizeof(os_bit16)];
                                  };

typedef struct fiFlashSector_Bit32_Form_s
               fiFlashSector_Bit32_Form_t;

struct fiFlashSector_Bit32_Form_s {
                                    os_bit32 Bit32[Am29F010_Sector_SIZE/sizeof(os_bit32)];
                                  };

/* fiFlash_Card_Assembly_Info_t is simply a buffer reserved to
     hold manufacturing info                                   */

typedef os_bit8 fiFlash_Card_Assembly_Info_t [32];

/* fiFlash_Card_Domain/Area/Loop_Address are each one byte fields
     used to specify a Hard Address (or, rather, a Default Address) */

#define fiFlash_Card_Unassigned_Domain_Address 0xFF
#define fiFlash_Card_Unassigned_Area_Address   0xFF
#define fiFlash_Card_Unassigned_Loop_Address   0xFF

/* fiFlash_Sector_Sentinel_Byte is just a single byte used to know that
     the Flash has been programmed.  Eventually, this should be replaced
     or augmented by a checksum (using the 3 neighboring filler bytes).  */

#define fiFlash_Sector_Sentinel_Byte 0xED

/* fiFlash_Card_WWN_t is of the form: 0x50 0x06 0x0B 0xQR 0xST 0xUV 0xWX 0xYZ
     where Q,R,S,T,U,V,W,X,Y, & Z are hex digits (0-F)                        */

typedef os_bit8 fiFlash_Card_WWN_t [8];


#define fiFlash_Card_WWN_0_HP              0x50
#define fiFlash_Card_WWN_1_HP              0x06
#define fiFlash_Card_WWN_2_HP              0x0B
#define fiFlash_Card_WWN_3_HP              0x0

#define fiFlash_Card_WWN_0_Agilent         0x50
#define fiFlash_Card_WWN_1_Agilent         0x03
#define fiFlash_Card_WWN_2_Agilent         0x0D
#define fiFlash_Card_WWN_3_Agilent         0x30

#define fiFlash_Card_WWN_0_Adaptec         0x50
#define fiFlash_Card_WWN_1_Adaptec         0x03
#define fiFlash_Card_WWN_2_Adaptec         0x0D
#define fiFlash_Card_WWN_3_Adaptec         0x30

#ifdef _ADAPTEC_HBA
#define fiFlash_Card_WWN_0 fiFlash_Card_WWN_0_Adaptec
#define fiFlash_Card_WWN_1 fiFlash_Card_WWN_1_Adaptec
#define fiFlash_Card_WWN_2 fiFlash_Card_WWN_2_Adaptec
#define fiFlash_Card_WWN_3 fiFlash_Card_WWN_3_Adaptec
#endif /* _ADAPTEC_HBA */

#ifdef _AGILENT_HBA
#define fiFlash_Card_WWN_0 fiFlash_Card_WWN_0_Agilent
#define fiFlash_Card_WWN_1 fiFlash_Card_WWN_1_Agilent
#define fiFlash_Card_WWN_2 fiFlash_Card_WWN_2_Agilent
#define fiFlash_Card_WWN_3 fiFlash_Card_WWN_3_Agilent
#endif /* _AGILENT_HBA */

#ifdef _GENERIC_HBA
#define fiFlash_Card_WWN_0 fiFlash_Card_WWN_0_HP
#define fiFlash_Card_WWN_1 fiFlash_Card_WWN_1_HP
#define fiFlash_Card_WWN_2 fiFlash_Card_WWN_2_HP
#define fiFlash_Card_WWN_3 fiFlash_Card_WWN_3_HP

#endif /* _GENERIC_HBA */


#define fiFlash_Card_WWN_0_DEFAULT(agRoot) fiFlash_Card_WWN_0
#define fiFlash_Card_WWN_1_DEFAULT(agRoot) fiFlash_Card_WWN_1
#define fiFlash_Card_WWN_2_DEFAULT(agRoot) fiFlash_Card_WWN_2
#define fiFlash_Card_WWN_3_DEFAULT(agRoot) fiFlash_Card_WWN_3

#define fiFlash_Card_WWN_4_DEFAULT(agRoot) ((os_bit8)((((os_bitptr)(agRoot)) & 0xFF000000) >> 0x18))
#define fiFlash_Card_WWN_5_DEFAULT(agRoot) ((os_bit8)((((os_bitptr)(agRoot)) & 0x00FF0000) >> 0x10))
#define fiFlash_Card_WWN_6_DEFAULT(agRoot) ((os_bit8)((((os_bitptr)(agRoot)) & 0x0000FF00) >> 0x08))
#define fiFlash_Card_WWN_7_DEFAULT(agRoot) ((os_bit8)((((os_bitptr)(agRoot)) & 0x000000FF) >> 0x00))

/* fiFlash_Card_SVID_t is of the form: 0xGHIJ103C (LittleEndian)
     where I,J,G, & H are hex digits (0-F) and make up the SubSystemID
     whereas the 0x103C serves as the SubsystemVendorID                */

typedef os_bit32 fiFlash_Card_SVID_t;

#define fiFlashSector_Last_Form_Fill_Bytes (   Am29F010_Sector_SIZE                 \
                                             - sizeof(fiFlash_Card_Assembly_Info_t) \
                                             - sizeof(os_bit8)                         \
                                             - sizeof(os_bit8)                         \
                                             - sizeof(os_bit8)                         \
                                             - sizeof(os_bit8)                         \
                                             - sizeof(fiFlash_Card_WWN_t)           \
                                             - sizeof(fiFlash_Card_SVID_t)          )

typedef struct fiFlashSector_Last_Form_s
               fiFlashSector_Last_Form_t;

struct fiFlashSector_Last_Form_s {
                                   os_bit8                      Bit8[fiFlashSector_Last_Form_Fill_Bytes];
                                   fiFlash_Card_Assembly_Info_t Assembly_Info;
                                   os_bit8                      Hard_Domain_Address;
                                   os_bit8                      Hard_Area_Address;
                                   os_bit8                      Hard_Loop_Address;
                                   os_bit8                      Sentinel;
                                   fiFlash_Card_WWN_t           Card_WWN;
                                   fiFlash_Card_SVID_t          Card_SVID;
                                 };

#define fiFlashSector_Last (Am29F010_Num_Sectors - 1)

typedef union fiFlashSector_u
              fiFlashSector_t;

union fiFlashSector_u {
                        fiFlashSector_Bit8_Form_t  Bit8_Form;
                        fiFlashSector_Bit16_Form_t Bit16_Form;
                        fiFlashSector_Bit32_Form_t Bit32_Form;
                        fiFlashSector_Last_Form_t  Last_Form;
                      };

#ifndef __FlashSvc_H__64KB_Struct_Size_Limited__
#ifdef OSLayer_BIOS
#define __FlashSvc_H__64KB_Struct_Size_Limited__
#endif /* OSLayer_BIOS was defined */
#ifdef OSLayer_I2O
#define __FlashSvc_H__64KB_Struct_Size_Limited__
#endif /* OSLayer_I2O was defined */
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

#ifndef __FlashSvc_H__64KB_Struct_Size_Limited__
typedef struct fiFlashStructure_s
               fiFlashStructure_t;

struct fiFlashStructure_s {
                            fiFlashSector_t Sector[Am29F010_Num_Sectors];
                          };
#endif /* __FlashSvc_H__64KB_Struct_Size_Limited__ was not defined */

/* Function Prototypes */

osGLOBAL os_bit32 fiFlashSvcASSERTs(
                                     void
                                   );

osGLOBAL agBOOLEAN fiFlashSvcInitialize(
                                    agRoot_t *agRoot
                                  );

osGLOBAL void fiFlashDumpLastSector(
                                     agRoot_t *agRoot
                                   );

osGLOBAL void fiFlashInitializeChip(
                                     agRoot_t *agRoot
                                   );

osGLOBAL void fiFlashFill_Assembly_Info( fiFlashSector_Last_Form_t    *Last_Sector,
                                         fiFlash_Card_Assembly_Info_t *Assembly_Info
                                       );

osGLOBAL void fiFlashFill_Hard_Address( fiFlashSector_Last_Form_t *Last_Sector,
                                        os_bit8                    Hard_Domain_Address,
                                        os_bit8                    Hard_Area_Address,
                                        os_bit8                    Hard_Loop_Address
                                      );

osGLOBAL void fiFlashFill_Card_WWN( fiFlashSector_Last_Form_t *Last_Sector,
                                    fiFlash_Card_WWN_t        *Card_WWN
                                  );

osGLOBAL void fiFlashFill_Card_SVID( fiFlashSector_Last_Form_t *Last_Sector,
                                     fiFlash_Card_SVID_t        Card_SVID
                                   );

osGLOBAL void fiFlashGet_Last_Sector(
                                      agRoot_t                  *agRoot,
                                      fiFlashSector_Last_Form_t *Last_Sector
                                    );

osGLOBAL void fiFlashGet_Assembly_Info(
                                        agRoot_t                     *agRoot,
                                        fiFlash_Card_Assembly_Info_t *Assembly_Info
                                      );

osGLOBAL void fiFlashGet_Hard_Address(
                                       agRoot_t *agRoot,
                                       os_bit8  *Hard_Domain_Address,
                                       os_bit8  *Hard_Area_Address,
                                       os_bit8  *Hard_Loop_Address
                                     );

osGLOBAL void fiFlashGet_Card_WWN(
                                   agRoot_t           *agRoot,
                                   fiFlash_Card_WWN_t *Card_WWN
                                 );

osGLOBAL void fiFlashGet_Card_SVID(
                                    agRoot_t            *agRoot,
                                    fiFlash_Card_SVID_t *Card_SVID
                                  );

osGLOBAL void fiFlashSet_Assembly_Info(
                                        agRoot_t                     *agRoot,
                                        fiFlash_Card_Assembly_Info_t *Assembly_Info
                                      );

osGLOBAL void fiFlashSet_Hard_Address(
                                       agRoot_t *agRoot,
                                       os_bit8   Hard_Domain_Address,
                                       os_bit8   Hard_Area_Address,
                                       os_bit8   Hard_Loop_Address
                                     );

osGLOBAL void fiFlashSet_Card_WWN(
                                   agRoot_t           *agRoot,
                                   fiFlash_Card_WWN_t *Card_WWN
                                 );

osGLOBAL void fiFlashSet_Card_SVID(
                                    agRoot_t            *agRoot,
                                    fiFlash_Card_SVID_t  Card_SVID
                                  );

osGLOBAL void fiFlashUpdate_Last_Sector(
                                         agRoot_t                  *agRoot,
                                         fiFlashSector_Last_Form_t *Last_Sector
                                       );

osGLOBAL void fiFlashEraseChip(
                                agRoot_t *agRoot
                              );

osGLOBAL void fiFlashEraseSector(
                                  agRoot_t *agRoot,
                                  os_bit32  EraseSector
                                );

osGLOBAL os_bit8 fiFlashReadBit8(
                                  agRoot_t *agRoot,
                                  os_bit32  flashOffset
                                );

osGLOBAL os_bit16 fiFlashReadBit16(
                                    agRoot_t *agRoot,
                                    os_bit32  flashOffset
                                  );

osGLOBAL os_bit32 fiFlashReadBit32(
                                    agRoot_t *agRoot,
                                    os_bit32  flashOffset
                                  );

osGLOBAL void fiFlashReadBlock(
                                agRoot_t *agRoot,
                                os_bit32  flashOffset,
                                void     *flashBuffer,
                                os_bit32  flashBufLen
                              );

osGLOBAL void fiFlashWriteBit8(
                                agRoot_t *agRoot,
                                os_bit32  flashOffset,
                                os_bit8   flashValue
                              );

osGLOBAL void fiFlashWriteBit16(
                                 agRoot_t *agRoot,
                                 os_bit32  flashOffset,
                                 os_bit16  flashValue
                               );

osGLOBAL void fiFlashWriteBit32(
                                 agRoot_t *agRoot,
                                 os_bit32  flashOffset,
                                 os_bit32  flashValue
                               );

osGLOBAL void fiFlashWriteBlock(
                                 agRoot_t *agRoot,
                                 os_bit32  flashOffset,
                                 void     *flashBuffer,
                                 os_bit32  flashBufLen
                               );

#endif /* __FlashSvc_H__ was not defined */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\storage\port\scsi\miniport\agilent\afc\findadap.c ===
/*++

Copyright (c) 2000 Agilent Technologies.

Module Name:

    FindAdap.c

Abstract:

    This is the miniport driver for the Agilent
    PCI to Fibre Channel Host Bus Adapter (HBA).

Authors:

    MB - Michael Bessire
    DL - Dennis Lindfors FC Layer support
    IW - Ie Wei Njoo
    LP - Leopold Purwadihardja
    KR - Kanna Rajagopal

Environment:

    kernel mode only

Version Control Information:

    $Archive: /Drivers/Win2000/Trunk/OSLayer/C/FINDADAP.C $

Revision History:
    $Revision: 9 $
    $Date: 11/10/00 5:51p $
    $Modtime:: 11/09/00 8:21p          $

Notes:

--*/


#include "buildop.h"
#include "osflags.h"
#include "err_code.h"
#if defined(HP_PCI_HOT_PLUG)
   #include "HotPlug4.h"      // NT 4.0 PCI Hot-Plug header file
#endif


//
// Remove the use of static global, NT50 PnP support.
//

/*
PCARD_EXTENSION hpTLCards [MAX_ADAPTERS];
int hpTLNumCards = 0;   
*/

#ifdef _DEBUG_EVENTLOG_
extern PVOID gDriverObject;
#endif

extern ULONG gMultiMode;
extern ULONG gMaximumTransferLength; 
extern ULONG gGlobalIOTimeout;
extern ULONG gCrashDumping;
extern ULONG hpFcConsoleLevel;

void ScanRegistry(IN PCARD_EXTENSION pCard,PUCHAR param);

/*++

Routine Description:

    This function is called by the OS-specific port driver after
    the necessary storage has been allocated, to gather information
    about the HBA's configuration.

Arguments:

    pCard - HBA miniport driver's adapter data storage
    Context         - address of HwContext value pass in the
                     ScsiPortInitialize routine
    BusInformation  - address of bus-type-specific info that the port driver
                     has gathered
    ArgumentString  - address of a zero-terminated ASCII string
    ConfigInfo      - Configuration information structure describing HBA
    Again           - set to TRUE if the driver can support more than one HBA
                     and we want the ScsiPortxxx driver to call again with a
                     new pCard.

Return Value:

    SP_RETURN_FOUND if HBA present in system
    SP_RETURN_ERROR on error

--*/
ULONG
HPFibreFindAdapter(
    IN PCARD_EXTENSION pCard,
    IN PVOID Context,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    )
{
    ULONG range;
    ULONG rangeNT;
    PVOID ranges[NUMBER_ACCESS_RANGES];
    ULONG Lengths[NUMBER_ACCESS_RANGES];
    UCHAR IOorMEM[NUMBER_ACCESS_RANGES];
    ULONG cachedMemoryNeeded;
    ULONG cachedMemoryAlign;
    ULONG dmaMemoryNeeded;
    ULONG dmaMemoryPhyAlign;
    ULONG nvMemoryNeeded;
    ULONG usecsPerTick=0;
    ULONG error=FALSE;
    ULONG x;
    ULONG num_access_range =  NUMBER_ACCESS_RANGES;
    ULONG Mem_needed;
    SCSI_PHYSICAL_ADDRESS phys_addr;
    ULONG length;
    agRoot_t *phpRoot;
    ULONG return_value;
    agBOOLEAN cardSupported;
    ULONG dmaMemoryPtrAlign;
    int i;

    //
    //  KC: Cacheline Update
    //
    ULONG SSvID;
    ULONG RetrnWal;
    ULONG pciCfgData[NUM_PCI_CONFIG_DATA_ELEMENTS];
    ULONG bus, device, function;
    PCI_SLOT_NUMBER slotnum;
    ULONG BusStuff;
    ULONG CLine;
    ULONG SecondaryBus;
    ULONG offset;
    USHORT ConfigReg16;
    UCHAR  ConfigReg8;
    ULONG  ConfigReg32;

    #if defined(HP_PCI_HOT_PLUG)
    PHOT_PLUG_CONTEXT pHotPlugContext = (PHOT_PLUG_CONTEXT) Context;
    #endif


    // the following is the AccessRanges[] representation of the PCI
    // configuration registers filled in by the scsiport driver.
    //      0x10: Reserved
    //      0x14: IOBASEL  - AccessRanges[0].RangeStart
    //      0x18: IOBASEU  - AccessRanges[1].RangeStart
    //      0x1C: MEMBASE  - AccessRanges[2].RangeStart
    //
    // Reserved register 0x10 ignored by scsiport driver.
    #ifndef YAM2_1
    osZero (pCard, sizeof(CARD_EXTENSION));
    #else
    osZero (pCard, OSDATA_SIZE);
    #endif

    pCard->signature = 0xfcfc5100;

    *Again = TRUE;
   
    //
    // KC: Cacheline Update
    //
    slotnum.u.AsULONG = 0;

    //
    // Remove the use of static global, NT50 PnP support
    //

    /****
    * For debugging purpose....
    *
    hpTLCards [hpTLNumCards] = pCard;
    hpTLNumCards++; 

    if (hpTLNumCards >= MAX_ADAPTERS)
        *Again = FALSE;
    else
        *Again = TRUE;
        
    osDEBUGPRINT((ALWAYS_PRINT, "&hpTLCards = %x hpTLNumCards = %d pCard = %x\n", 
                        &hpTLCards, hpTLNumCards, pCard));
    */

    osDEBUGPRINT((ALWAYS_PRINT, "HPFibreFindAdapter: IN\n"));

    phpRoot = &pCard->hpRoot;

    pCard->State |= CS_DURING_FINDADAPTER;

    // Initialize osdata
    phpRoot->osData = pCard;
    pCard->AdapterQ.Head = NULL;
    pCard->AdapterQ.Tail = NULL;
    //--LP101000   pCard->TimedOutIO=0;
    pCard->RootSrbExt = NULL;
    pCard->inDriver = FALSE;
    pCard->inTimer = FALSE;
    pCard->ForceTag = TRUE;


    ScsiPortGetBusData(pCard,
                        PCIConfiguration,
                        ConfigInfo->SystemIoBusNumber,
                        ConfigInfo->SlotNumber,
                        &pCard->pciConfigData,
                        PCI_CONFIG_DATA_SIZE);

    //
    // Get the parameter entry "DriverParameters"
    //
    if (ArgumentString) 
    {
        osDEBUGPRINT(( ALWAYS_PRINT,"HPFibreFindAdapter: FindAdapter ArgumentString = (%s)\n", ArgumentString));

        pCard->ArgumentString = ArgumentString;
        
        // Scan and set OSLayer changeble parameter
        ScanRegistry(pCard, ArgumentString);

        #ifdef DBG
        if (gCrashDumping)
        {   
            #ifdef _DEBUG_EVENTLOG_
            gEventLogCount = 0;
            LogLevel = 0;
            #endif

            osDEBUGPRINT(( ALWAYS_PRINT,"FindAdapter: !!!!!!! CRASH DUMP MODE !!!!!!!!!!\n"));        
            gDbgPrintIo = DBGPRINT_HPFibreStartIo|DBGPRINT_START|DBGPRINT_DONE|DBGPRINT_SCSIPORT_RequestComplete|DBGPRINT_SCSIPORT_ScsiportCompleteRequest;
//          hpFcConsoleLevel=0xf;
        }
        #endif
    } // if (ArgumentString) 
    else
        osDEBUGPRINT(( ALWAYS_PRINT,"HPFibreFindAdapter: No Argument String.\n"));

    #if DBG_TRACE
    pCard->traceBufferLen = HP_FC_TRACE_BUFFER_LEN;
    pCard->curTraceBufferPtr = &pCard->traceBuffer[0];
    // Note that traceBuffer was already zeroed in call to zeroing CARD_EXTENSION above.
    #endif

    cardSupported = fcCardSupported (phpRoot);
    if (cardSupported == agFALSE) 
    {
        pCard->State &= ~CS_DURING_FINDADAPTER;
        osDEBUGPRINT((ALWAYS_PRINT, "HPFibreFindAdapter: returning SP_RETURN_NOT_FOUND\n"));
        return SP_RETURN_NOT_FOUND;
    }

    #if DBG > 2
    dump_pCard( pCard);
    #endif

    osDEBUGPRINT(( DMOD,"Num Config Ranges %lx @ %x\n",ConfigInfo->NumberOfAccessRanges, osTimeStamp(0) ));

    pCard->SystemIoBusNumber = ConfigInfo->SystemIoBusNumber;
    pCard->SlotNumber        = ConfigInfo->SlotNumber;

    // Initialize Memory or IO port switch
    IOorMEM[0] = TRUE;
    IOorMEM[1] = TRUE;

    for( range=2; range < NUMBER_ACCESS_RANGES; range++)
    {
        IOorMEM[range] = FALSE;
    }

    for( range=0; range < NUMBER_ACCESS_RANGES; range++)
    {
        ranges[range] = NULL;
        Lengths[range] = 0;
        osDEBUGPRINT(( DMOD,"ranges[%x] = %lx IOorMEM[%x] %x\n",
                    range, ranges[range],range,IOorMEM[range] ));
    }

    for( range=0,rangeNT=0; range < num_access_range; range++,rangeNT++)
    {
        if ((range==3)&&(!osChipConfigReadBit32(phpRoot,0x20)))
        {
            rangeNT -= 1;
            continue;
        }
        if ((range==4)&&(!osChipConfigReadBit32(phpRoot,0x24)))
        {
            rangeNT -= 1;
            continue;
        }
        osDEBUGPRINT(( DMOD,"Before ScsiPortGetDeviceBase %x\n",(*ConfigInfo->AccessRanges)[range].RangeStart));

        // Check if we could safely access the range
        if(ScsiPortValidateRange(pCard,
                        ConfigInfo->AdapterInterfaceType,
                        ConfigInfo->SystemIoBusNumber,
                        (*ConfigInfo->AccessRanges)[rangeNT].RangeStart,
                        (*ConfigInfo->AccessRanges)[rangeNT].RangeLength,
                        IOorMEM[range])) 
        {
            // It is safe to access the range        
            if((ranges[range] = ScsiPortGetDeviceBase(pCard,
                     ConfigInfo->AdapterInterfaceType,
                     ConfigInfo->SystemIoBusNumber,
                     (*ConfigInfo->AccessRanges)[rangeNT].RangeStart,
                     (*ConfigInfo->AccessRanges)[rangeNT].RangeLength,
                     IOorMEM[range])) == pNULL) 
            {
                osDEBUGPRINT(( DMOD,"Get Device Failed ranges[%x] = %lx IOorMEM[%x] %x\n", range, ranges[range],range,IOorMEM[range] ));
                if(range <= 2 ) 
                {
                    error = TRUE;
                    osDEBUGPRINT((ALWAYS_PRINT,"ERROR mapping base address.\n"));
                    // Log error.
                    #ifdef TAKEN_OUT_012100             
                    #ifdef _DvrArch_1_20_
                    osLogString(phpRoot,
                     "%X",               // FS
                     "ERR_MAP_IOLBASE",  // S1
                     0,                  // S2
                     agNULL,agNULL,
                     0,                  // 1
                     0,                  // 2
                     0,                  // 3
                     0,                  // 4
                     SP_INTERNAL_ADAPTER_ERROR, // 5
                     ERR_MAP_IOLBASE,    // 6
                     0,                  // 7
                     0 );                // 8

                    #else /* _DvrArch_1_20_ was not defined */

                    osLogString(phpRoot,
                     "%X",               // FS
                     "ERR_MAP_IOLBASE",  // S1
                     0,                  // S2
                     0,                  // 1
                     0,                  // 2
                     0,                  // 3
                     0,                  // 4
                     SP_INTERNAL_ADAPTER_ERROR, // 5
                     ERR_MAP_IOLBASE,    // 6
                     0,                  // 7
                     0 );                // 8


                    #endif   /* _DvrArch_1_20_ was not defined */
                    #endif
                }
                break;
            }
        }

        // Not safe to access the range
        else
        {
            error = TRUE;
            osDEBUGPRINT((ALWAYS_PRINT,"ScsiPortValidateRange FAILED.\n"));
            // Log error.
            #ifdef TAKEN_OUT_012100             
            #ifdef _DvrArch_1_20_
            osLogString(phpRoot,
                  "%X",             // FS
                  "ERR_VALIDATE_IOLBASE", // S1
                  0,                // S2
                  agNULL,agNULL,
                  0,                // 1
                  0,                // 2
                  0,                // 3
                  0,                // 4
                  SP_INTERNAL_ADAPTER_ERROR, // 5
                  ERR_VALIDATE_IOLBASE,   // 6
                  0,                // 7
                  0 );              // 8
            #else /* _DvrArch_1_20_ was not defined */
            osLogString(phpRoot,
                  "%X",             // FS
                  "ERR_VALIDATE_IOLBASE", // S1
                  0,                // S2
                  0,                // 1
                  0,                // 2
                  0,                // 3
                  0,                // 4
                  SP_INTERNAL_ADAPTER_ERROR, // 5
                  ERR_VALIDATE_IOLBASE,   // 6
                  0,                // 7
                  0 );              // 8
            #endif   /* _DvrArch_1_20_ was not defined */
            #endif
            break;
        }

        osDEBUGPRINT(( DMOD,"ranges[%x] = %lx\n", range, ranges[range]  ));
        Lengths[range] = (*ConfigInfo->AccessRanges)[rangeNT].RangeLength;
    } // for loop

    if (error == TRUE)
        goto error;

    pCard->IoLBase      = ranges[0];
    pCard->IoUpBase     = ranges[1];
    pCard->MemIoBase    = ranges[2];
    pCard->RamBase      = ranges[3];
    pCard->RomBase      = ranges[4];
    pCard->RamLength    = Lengths[3];
    pCard->RomLength    = Lengths[4];

    pCard->AltRomBase = NULL; // this should be filled by reading config space
    pCard->AltRomLength = 0;  // this should be obtained from config space info

    osDEBUGPRINT(( DMOD,"HPFibreFindAdapter: IoLAddrBase   address is %x\n",pCard->IoLBase   ));
    osDEBUGPRINT(( DMOD,"HPFibreFindAdapter: IoUpAddrBase  address is %x\n",pCard->IoUpBase  ));
    osDEBUGPRINT(( DMOD,"HPFibreFindAdapter: MemIoAddrBase address is %x\n",pCard->MemIoBase ));
    osDEBUGPRINT(( DMOD,"HPFibreFindAdapter: RamAddrBase   address is %x\n",pCard->RamBase   ));
    osDEBUGPRINT(( DMOD,"HPFibreFindAdapter: RomAddrBase   address is %x\n",pCard->RomBase   ));

    pCard->cardRomUpper = 0;
    pCard->cardRamUpper = 0;

    pCard->cardRamLower = osChipConfigReadBit32( phpRoot,0x20 );
    pCard->cardRomLower = osChipConfigReadBit32( phpRoot,0x24 );

    // 
    // When on-card-RAM is not present, current TL boards indicate
    // that on-card-RAM is present in the PCI config space.
    // So here test the on-card-RAM.
    //
    if (TestOnCardRam (phpRoot) == FALSE)
        pCard->RamLength = 0;

    pCard->cardRamLower &= 0xFFFFFFF0;
    pCard->cardRomLower &= 0xFFFFFFF0;


    #ifdef __REGISTERFORSHUTDOWN__
    if (gRegisterForShutdown)
    {
        ConfigInfo->CachesData = TRUE;
    }
    #endif


    // FC Layer does not have any alignment restriction.
    ConfigInfo->AlignmentMask = 0x0;

    // indicate bus master support
    ConfigInfo->Master = TRUE;

    // Want to snoop at the buffer
    ConfigInfo->MapBuffers = TRUE;

    // maximum number of Target ID's supported.
    #ifndef YAM2_1
    ConfigInfo->MaximumNumberOfTargets = MAXIMUM_TID;
    #else
    ConfigInfo->MaximumNumberOfTargets = (UCHAR)gMaximumTargetIDs;
    #endif

    // number of FC busses the HBA supports
    // For NT4.0 we will claim we support more than 1 bus to get the scsiport
    // driver to support 4*MAXIMUM_TID=128 target id's. Then map to the
    // appropriate alpa based on the bus, tid and lun requested.

    ConfigInfo->NumberOfBuses = NUMBER_OF_BUSES;

    #if defined(HP_NT50)
    // whisler requires that this param is set to a number, else SP will scan only 9 luns
    ConfigInfo->MaximumNumberOfLogicalUnits = 255;
    if (gCrashDumping)
        ConfigInfo->MaximumNumberOfLogicalUnits = 1;
    #endif

    if (gMaximumTransferLength)
        ConfigInfo->MaximumTransferLength = gMaximumTransferLength;
    //else use the default value that SP set (4GB)
   
    if (gCrashDumping)
    {
        ConfigInfo->MaximumTransferLength = 512;
        ConfigInfo->ScatterGather = FALSE;
        ConfigInfo->NumberOfPhysicalBreaks =0;
    }
    else
    {
    // Indicate maximum number of physical segments.
    // If the port driver sets a value for this member, the miniport driver can 
    // adjust the value to lower but no higher.

    if (    ConfigInfo->NumberOfPhysicalBreaks == SP_UNINITIALIZED_VALUE || 
            ConfigInfo->NumberOfPhysicalBreaks > (osSGL_NUM_ENTRYS - 1))
        ConfigInfo->NumberOfPhysicalBreaks =  osSGL_NUM_ENTRYS - 1;
    ConfigInfo->ScatterGather = TRUE;
    }

    osDEBUGPRINT(( ALWAYS_PRINT,"HPFibreFindAdapter: MaxXLen=%x SGSup=%x PhyBreaks=%x\n",
       ConfigInfo->MaximumTransferLength,
       ConfigInfo->ScatterGather,
       ConfigInfo->NumberOfPhysicalBreaks));

    #if defined(HP_NT50)
    //
    // Check if System supports 64bit DMA  
    //
    if (ConfigInfo->Dma64BitAddresses & SCSI_DMA64_SYSTEM_SUPPORTED ) 
    {
        ConfigInfo->Dma64BitAddresses |= SCSI_DMA64_MINIPORT_SUPPORTED;
    }
    #endif


    for (i = 0; i < NUMBER_OF_BUSES; i++)
        ConfigInfo->InitiatorBusId[i] = (UCHAR) INITIATOR_BUS_ID;

    return_value = fcInitializeDriver (phpRoot,
                                        &cachedMemoryNeeded,
                                        &cachedMemoryAlign,
                                        &dmaMemoryNeeded,
                                        &dmaMemoryPtrAlign,
                                        &dmaMemoryPhyAlign,
                                        &nvMemoryNeeded,
                                        &usecsPerTick);
    if (dmaMemoryPhyAlign < dmaMemoryPtrAlign)
        dmaMemoryPhyAlign = dmaMemoryPtrAlign;

    // IWN, IA-64 need 8 byte aligned
    cachedMemoryAlign = 8;

    pCard->cachedMemoryNeeded =   cachedMemoryNeeded;
    pCard->cachedMemoryAlign  =   cachedMemoryAlign;
    pCard->dmaMemoryNeeded    =   dmaMemoryNeeded;
    pCard->usecsPerTick   =       usecsPerTick;

    osDEBUGPRINT(( ALWAYS_PRINT,"HPFibreFindAdapter: cachedMemoryNeeded %lx Align %lx\n",cachedMemoryNeeded, cachedMemoryAlign));
    osDEBUGPRINT(( ALWAYS_PRINT,"HPFibreFindAdapter: dmaMemoryNeeded    %lx Align %lx\n",dmaMemoryNeeded, dmaMemoryPhyAlign));


    // allocate uncached memory for DMA/shared memory purposes. Only
    // one call to ScsiPortGetUncachedExtension is allowed within the
    // HwFindAdapter routine for each HBA supported and it must occur
    // after the ConfigInfo buffer has been filled out. The
    // ScsiPortGetUncachedExtension returns a virtual address to the
    // uncached extension.

    Mem_needed = OSDATA_UNCACHED_SIZE + cachedMemoryNeeded + cachedMemoryAlign;
    if (pCard->dmaMemoryNeeded) 
    {
        Mem_needed += pCard->dmaMemoryNeeded + dmaMemoryPhyAlign;
    }

    #ifdef DOUBLE_BUFFER_CRASHDUMP
    if(gCrashDumping)
    {
        // add space for the local DMA buffer also,
        // for use in startio
        Mem_needed += (8 * 1024) + 0x512; // lets just make it 512 byte aligned.. 
    }
    #endif

    //if ((pCard->dmaMemoryPtr = ScsiPortGetUncachedExtension(pCard,
    if ((pCard->UncachedMemoryPtr = ScsiPortGetUncachedExtension(pCard,
                                       ConfigInfo,
                                       Mem_needed
                                       )) == NULL) 
    {
         osDEBUGPRINT((ALWAYS_PRINT,"HPFibreFindAdapter: ScsiPortGetUncachedExtension FAILED.\n"));
         // Log error.
        #ifdef TAKEN_OUT_012100             
        #ifdef _DvrArch_1_20_
        osLogString(phpRoot,
                  "%X",                // FS
                  "ERR_UNCACHED_EXTENSION",  // S1
                  0,                   // S2
                  agNULL,agNULL,
                  0,                   // 1
                  0,                   // 2
                  0,                   // 3
                  0,                   // 4
                  SP_INTERNAL_ADAPTER_ERROR, // 5
                  ERR_UNCACHED_EXTENSION,    // 6
                  0,                   // 7
                  0 );                 // 8
        #else /* _DvrArch_1_20_ was not defined */
        osLogString(phpRoot,
                  "%X",                // FS
                  "ERR_UNCACHED_EXTENSION",  // S1
                  0,                   // S2
                  0,                   // 1
                  0,                   // 2
                  0,                   // 3
                  0,                   // 4
                  SP_INTERNAL_ADAPTER_ERROR, // 5
                  ERR_UNCACHED_EXTENSION,    // 6
                  0,                   // 7
                  0 );                 // 8
        #endif   /* _DvrArch_1_20_ was not defined */
        #endif
        goto error;
      
    }

    osDEBUGPRINT(( ALWAYS_PRINT,"HPFibreFindAdapter: pCard->dmaMemoryPtr is %x needed = %x\n",pCard->dmaMemoryPtr,Mem_needed));

    //  Moved all 
    pCard->Dev = (DEVICE_ARRAY *)( ((char *)pCard->UncachedMemoryPtr) + PADEV_OFFSET);
    pCard->hpFCDev = (agFCDev_t*) ( ((char *)pCard->UncachedMemoryPtr) + FCDEV_OFFSET );
    pCard->nodeInfo = (NODE_INFO*) ( ((char *)pCard->UncachedMemoryPtr) + FCNODE_INFO_OFFSET);
    #ifdef _DEBUG_EVENTLOG_
    pCard->Events = (EVENTLOG_BUFFER*)( ((char*)pCard->UncachedMemoryPtr)+ EVENTLOG_OFFSET);
    #endif
    pCard->cachedMemoryPtr = (PULONG) ((PUCHAR)pCard->UncachedMemoryPtr+CACHE_OFFSET);
   
    #if defined(HP_NT50)
    //WIN64 compliant
    pCard->cachedMemoryPtr = 
        (PULONG) ( ((UINT_PTR)pCard->cachedMemoryPtr + (UINT_PTR)cachedMemoryAlign - 1) & 
                (~((UINT_PTR)cachedMemoryAlign - 1)));
    #else
    pCard->cachedMemoryPtr =  
        (PULONG) (((ULONG)pCard->cachedMemoryPtr +cachedMemoryAlign - 1) & (~(cachedMemoryAlign - 1)));
    #endif

    if (pCard->dmaMemoryNeeded) 
    {
        pCard->dmaMemoryPtr = (PULONG) (((char *)pCard->cachedMemoryPtr) + cachedMemoryNeeded + cachedMemoryAlign);

    
        phys_addr = ScsiPortGetPhysicalAddress(pCard,
                                         NULL, // only for uncached extension
                                         pCard->dmaMemoryPtr,
                                         &length);

        pCard->dmaMemoryUpper32 = phys_addr.HighPart;
        pCard->dmaMemoryLower32 = phys_addr.LowPart;

        osDEBUGPRINT(( ALWAYS_PRINT,"Before Ptr %lx pCard->dmaMemoryUpper32 is %lx Lower %lx Length %x Needed %x\n",
            pCard->dmaMemoryPtr,
            pCard->dmaMemoryUpper32,
            pCard->dmaMemoryLower32,
            length,
            pCard->dmaMemoryNeeded+dmaMemoryPhyAlign));

        Mem_needed = pCard->dmaMemoryLower32 & (dmaMemoryPhyAlign -1) ;
        Mem_needed = dmaMemoryPhyAlign - Mem_needed;
        pCard->dmaMemoryLower32 += Mem_needed;
        pCard->dmaMemoryPtr = (ULONG *)((UCHAR *)pCard->dmaMemoryPtr+Mem_needed);

        osDEBUGPRINT(( ALWAYS_PRINT,"New Ptr %lx  pCard->dmaMemoryUpper32 is %lx Lower %lx Length %x Needed %x\n",
            pCard->dmaMemoryPtr,
            pCard->dmaMemoryUpper32,
            pCard->dmaMemoryLower32,
            length,
            pCard->dmaMemoryNeeded ));
    }
    
    osDEBUGPRINT((ALWAYS_PRINT,"HPFibreFindAdapter: Dev = %x  hpFCDev = %x  nodeInfo  = %x  dma = %x  cachedMemoryPtr = %lx\n",
                                pCard->Dev,
                                pCard->hpFCDev,
                                pCard->nodeInfo,
                                pCard->dmaMemoryPtr,
                                pCard->cachedMemoryPtr));

    #ifdef DBG
    {
        ULONG       xx;
        PA_DEVICE   *dbgPaDev;
        char        *dbgTemp;
        agFCDev_t   *dbgFcDev;
        NODE_INFO   *dbgNodeInfo;

        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreFindAdapter: DEV_ARRAY_SIZE=%x  PADEV_SIZE=%x  FCDEV_SIZE=%x  FCNODE_INFO_SIZE=%x  EVENTLOG_SIZE=%x  OSDATA_SIZE=%x  OSDATA_UNCACHED_SIZE=%x\n",
            DEV_ARRAY_SIZE,
            PADEV_SIZE,
            FCDEV_SIZE,
            FCNODE_INFO_SIZE, 
            EVENTLOG_SIZE,
            OSDATA_SIZE,
            OSDATA_UNCACHED_SIZE));


        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreFindAdapter: PADEV_OFFSET=%x  FCDEV_OFFSET=%x  FCNODE_INFO_OFFSET=%x  EVENTLOG_OFFSET=%x  CACHE_OFFSET=%x\n",
            PADEV_OFFSET,
            FCDEV_OFFSET,
            FCNODE_INFO_OFFSET,
            EVENTLOG_OFFSET, 
            CACHE_OFFSET));

        /* Count the Devices */
        dbgPaDev = pCard->Dev->PaDevice; 
        dbgTemp = (char*)dbgPaDev;
        for (xx=0;xx < gMaxPaDevices;xx++)
            dbgPaDev++;
        
        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreFindAdapter: Dev=%x  Dev->PaDev[0]=%x  Dev->PaDev[%d]=%x\n",
                                pCard->Dev,
                                dbgTemp,
                                gMaxPaDevices,
                                dbgPaDev));
        
        dbgFcDev = pCard->hpFCDev;
        for (xx=0;xx < gMaxPaDevices;xx++)
            dbgFcDev++;

        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreFindAdapter: hpFCDev[0]=%x  hpFCDev[%d]=%x\n",
                                pCard->hpFCDev,
                                gMaxPaDevices,
                                dbgFcDev));

        dbgNodeInfo = pCard->nodeInfo;
        for (xx=0;xx < gMaxPaDevices;xx++)
            dbgNodeInfo++;
        
        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreFindAdapter: nodeInfo[0]=%x  nodeInfo[%d]=%x  cachedMemoryPtr=%x\n",
                                pCard->nodeInfo,
                                gMaxPaDevices,
                                dbgNodeInfo,
                                pCard->cachedMemoryPtr));
    }
    #endif

    #ifdef DOUBLE_BUFFER_CRASHDUMP
    if (gCrashDumping)
    {
        // grab the local DMA buffer and align it..
        pCard->localDataBuffer = (PULONG)((PUCHAR)pCard->dmaMemoryPtr + pCard->dmaMemoryNeeded + dmaMemoryPhyAlign);
        phys_addr = ScsiPortGetPhysicalAddress(pCard,
                                         NULL, // only for uncached extension
                                         pCard->localDataBuffer,
                                         &length);
        Mem_needed = phys_addr.LowPart & (0x512 - 1) ;
        Mem_needed = (0x512 - 1) - Mem_needed;
        pCard->localDataBuffer = (PULONG)((PUCHAR)pCard->localDataBuffer + Mem_needed);
        osDEBUGPRINT((ALWAYS_PRINT,"HPFibreFindAdapter: localDataBuffer = %x\n", pCard->localDataBuffer));
    }
    #endif

    // fill in queue ptrs that are aligned on the size of queue
    // within the buffers.

    // initialize the PCI registers (ie. bus master,parity error response, etc)
    // NT enables the PCI configuration command register to 0x0117.
    // InitPCIRegisters(pCard, ConfigInfo);

    // set this to true for each HBA installed.
    pCard->IsFirstTime = TRUE;

    // for the first time through indicate reset type required. It appears
    // a hard reset is required if the NT system is rebooted without a reset
    // or power cycle for initialization to properly occur.
    pCard->ResetType = HARD_RESET;

    // set pointer to ConfigInfo. Used to call InitPCIRegisters().
    // pCard->pConfigInfo = ConfigInfo;

    // set status to not logged in
    // InitLunExtensions(pCard);

    #if DBG > 2
    dump_pCard( pCard);
    #endif

    osDEBUGPRINT(( DLOW,"HPFibreFindAdapter: SP_RETURN_FOUND\n"));

    pCard->State &= ~CS_DURING_FINDADAPTER;

    //----------------------------------------------------------------------------
    #if defined(HP_PCI_HOT_PLUG)
    //
    // Load pointer to pCard in PSUEDO table for PCI Hot Plug option.
    //
    pHotPlugContext->extensions[0] += 1;      // Number of HBAs.
    pHotPlugContext->extensions[pHotPlugContext->extensions[0]] = (ULONG) pCard;
    //
    // Set the required fields for the PCI Hot Plug support.
    //
    pCard->rcmcData.numAccessRanges = (UCHAR)rangeNT;     // Save # of PCI access ranges used
    pCard->rcmcData.accessRangeLength[0]= 0x100; // I/O base address lo
    pCard->rcmcData.accessRangeLength[1]= 0x100; // I/O base address upper
    pCard->rcmcData.accessRangeLength[2]= 0x200; // Mem base address
    if (pCard->RamLength != 0 )
    {
        pCard->rcmcData.accessRangeLength[3] = pCard->RamLength;
        if (pCard->RomLength !=0 )
            pCard->rcmcData.accessRangeLength[4] = pCard->RomLength;
    }
    else 
        if (pCard->RomLength !=0 )
            pCard->rcmcData.accessRangeLength[3]= pCard->RomLength;

    #endif
    //----------------------------------------------------------------------------

    #ifdef YAM2_1
    InitializeDeviceTable(pCard);
    #endif
   
    #ifdef _DEBUG_EVENTLOG_
    {
        ULONG    ix;

        pCard->EventLogBufferIndex = MAX_CARDS_SUPPORTED;        /* initialize it */
   
        ix = AllocEventLogBuffer(gDriverObject, (PVOID) pCard);
        if (ix < MAX_CARDS_SUPPORTED)
        {
            pCard->EventLogBufferIndex = ix;                      /* store it */
            StartEventLogTimer(gDriverObject,pCard);
        }
    }
    #endif
    return SP_RETURN_FOUND;


error:
    for (range=0; range <  num_access_range; range++) 
    {
        if (ranges[range])
            ScsiPortFreeDeviceBase(pCard, ranges[range]);
    }

    *Again = FALSE;
    pCard->State &= ~CS_DURING_FINDADAPTER;
    osDEBUGPRINT((ALWAYS_PRINT, "HPFibreFindAdapter: returning SP_RETURN_ERROR\n"));
    return SP_RETURN_ERROR;

} // end HPFibreFindAdapter()

/*++

Routine Description:

    Tests on-card-RAM.

Arguments:

    hpRoot - HBA miniport driver's data adapter storage

Return Value:

    TRUE:  If the on-card-RAM test is successful
    FALSE: If the on-card-RAM test fails

--*/

int
TestOnCardRam (agRoot_t *hpRoot)
{
    PCARD_EXTENSION pCard = (PCARD_EXTENSION)hpRoot->osData;
    ULONG           x;

    for (x = 0; x < pCard->RamLength; x = x + 4) 
    {
        osCardRamWriteBit32 (hpRoot, x, 0x55aa55aa);
        if (osCardRamReadBit32 (hpRoot, x) != 0x55aa55aa) 
        {
            osDEBUGPRINT((ALWAYS_PRINT, "TestOnCardRam: ON-CARD-RAM test failed\n"));
            return FALSE;
        }

        osCardRamWriteBit32 (hpRoot, x, 0xaa55aa55);
        if (osCardRamReadBit32 (hpRoot, x) != 0xaa55aa55) 
        {
            osDEBUGPRINT((ALWAYS_PRINT, "TestOnCardRam: ON-CARD-RAM test failed\n"));
    