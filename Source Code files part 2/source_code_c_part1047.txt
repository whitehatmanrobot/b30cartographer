    // file that needs to be updated
            ReintKdPrint(MERGE, ("Opening %ws\n", szSrcName));
            hfDst = CreateFile(
                            szSrcName,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            (lpbitmap == NULL) ? TRUNCATE_EXISTING : OPEN_EXISTING,
                            0,
                            NULL);

            if (hfDst == INVALID_HANDLE_VALUE) {
                dwError = GetLastError();
                ReintKdPrint(MERGE, ("open failed %d\n", dwError));
                SetLastError(dwError);
                goto error;
            }

            if (lpbitmap != NULL) {

                // Resize the destination file
                fileSizeHigh = 0;
                fileSize = GetFileSize(hfSrc, &fileSizeHigh);
                if (fileSize == 0xFFFFFFFF && GetLastError() != NO_ERROR) {
                    ReintKdPrint(BADERRORS, ("Error getting source file size\n"));
                    goto error;
                }
                ReintKdPrint(MERGE, ("Source FileSize %u\n", fileSize));
                if (SetFilePointer(
                            hfDst,
                            fileSize,
                            &fileSizeHigh,
                            FILE_BEGIN) == INVALID_SET_FILE_POINTER
                                &&
                            GetLastError() != NO_ERROR
                ) {
                    ReintKdPrint(BADERRORS, ("Error setting destination file pointer\n"));
                    goto error;
                }
                if (!SetEndOfFile(hfDst)) {
                            ReintKdPrint(BADERRORS,
                    ("Error setting EOF info of destination file\n"));
                    goto error;
                }

                ReintKdPrint(MERGE, ("Resized Destination FileSize %u\n",
                GetFileSize(hfDst, NULL)));

                if (fileSizeHigh != 0 && lpbitmap) {
                    // file size cannot be represented by 32 bit (> 4Gb)
                    // do not use CSCBmp
                    CSC_BitmapDelete(&lpbitmap);
                    lpbitmap = NULL;
                }
            }
        }

        if (hfDst ==  INVALID_HANDLE_VALUE)
        {
            goto error;
        }

        // let us append
        if((lOffset = SetFilePointer(hfDst, 0, NULL, FILE_END))==0xffffffff) {
            goto error;
        }

        ReintKdPrint(MERGE, ("Copying back %ls to %ls%ls \r\n"
            , lpCP->lpLocalPath
            , lpCP->lpSharePath
            , lpCP->lpRemotePath
            ));

        do {
            unsigned cbRead;
            if (lpbitmap) {
                // Use CSC_BitmapReint Function
                cscReintRet = CSC_BitmapReint(
                                    lpbitmap,
                                    hfSrc,
                                    hfDst,
                                    lprwBuff,
                                    FILL_BUF_SIZE_LAN,
                                    &cbRead);
                if (cscReintRet == CSC_BITMAPReintCont) {
                    NOTHING;
                } else if (cscReintRet == CSC_BITMAPReintDone) {
                    ReintKdPrint(
                        MERGE,
                        ("Done reint\n"));
                    break;
                } else if (cscReintRet == CSC_BITMAPReintInvalid) {
                    ReintKdPrint(
                        BADERRORS,
                        ("Invalid param in calling CSC_BitmapReint\n"));
                    goto error;
                } else if (cscReintRet == CSC_BITMAPReintError) {
                    ReintKdPrint(
                        BADERRORS,
                        ("Error in transferring data\n"));
                    goto error;
                } else {
                    ReintKdPrint(
                        BADERRORS,
                        ("Unrecognized CSC_BitmapReint return code\n"));
                    goto error;
                }
            } else {
                if (!ReadFile(hfSrc, lprwBuff, FILL_BUF_SIZE_LAN, &cbRead, NULL)) {
                    goto error;
                }
                // ReintKdPrint(BADERRORS, ("Read %d bytes \r\n", cbRead));
                if (!cbRead) {
                    break;
                }
                if(!WriteFile(hfDst, (LPBYTE)lprwBuff, cbRead, &cbRead, NULL)){
                    goto error;
                }
                dwTotal += cbRead;
            }
            
            if (lpfnMergeProgress)
            {
                dwRet = (*lpfnMergeProgress)(
                                    szSrcName,
                                    lpSI->uStatus,
                                    lpSI->ulHintFlags,
                                    lpSI->ulHintPri,
                                    lpFind32Local,
                                    CSCPROC_REASON_MORE_DATA,
                                    cbRead,
                                    0,
                                    dwContext);

                if (dwRet != CSCPROC_RETURN_CONTINUE)
                {
                    SetLastError(ERROR_OPERATION_ABORTED);
                    goto bailout;
                }

            }
            

            if (FAbortOperation())
            {
                SetLastError(ERROR_OPERATION_ABORTED);
                goto error;
            }
        } while(TRUE);

        CloseHandle(hfSrc);
        hfSrc = 0;


        CloseHandle(hfDst);
        hfDst = 0;


        // if we are not overwriting the original file, then we must make sure to cleanup
        if (!fOverWrite)
        {
            // nuke the remote one if it exists
            if (fFileExists){
                if(!SetFileAttributes(szSrcName, FILE_ATTRIBUTE_NORMAL)
                || !DeleteFile(szSrcName)){
                    goto error;
                }
            }

            // Now rename the temp file to the real filename
            if(!MoveFile(szDstName, szSrcName)){
                ReintKdPrint(BADERRORS, ("Error #%ld Renaming %ls to %ls%ls\r\n"
                   , GetLastError()
                   , szSrcName
                   , lpCP->lpSharePath
                   , lpCP->lpRemotePath
                   ));
                goto error;
            }

            ReintKdPrint(MERGE, ("Renamed %ls to %ls%ls\r\n"
                , szDstName
                , lpCP->lpSharePath
                , lpCP->lpRemotePath));
        }
    }

    if (fForceAttribute ||
        mShadowAttribChange((lpSI->uStatus))||
        mShadowTimeChange((lpSI->uStatus))){

        if(!SetFileAttributes(szSrcName, FILE_ATTRIBUTE_NORMAL)) {
            goto error;
        }

        if (mShadowTimeChange((lpSI->uStatus))){

            if((hDst = CreateFile(szSrcName,
                                 GENERIC_WRITE,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL
                                 ))!=INVALID_HANDLE_VALUE){
                fRet = SetFileTime( hDst, NULL,
                                    NULL, &(lpFind32Local->ftLastWriteTime));
            }
            CloseHandle(hDst);
            hDst = 0;

            if (!fRet) {
                goto error;
            }
        }

        if(!SetFileAttributes(szSrcName, lpFind32Local->dwFileAttributes)){
            goto error;
        }
    }

    // Get the latest timestamps/attributes/LFN/SFN on the file we just copied back
    if (!GetWin32Info(szSrcName, &sFind32Remote)) {
        goto error;
    }

    lpSI->uStatus &= (unsigned long)(~(SHADOW_MODFLAGS));

    if (!SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, &sFind32Remote, ~(SHADOW_MODFLAGS), SHADOW_FLAGS_AND|SHADOW_FLAGS_CHANGE_83NAME))
    {
        goto error;
    }
    else
    {
        dwError = NO_ERROR;
        goto bailout;
    }

error:
    dwError = GetLastError();
    ReportLastError();

#if 0
    LogReintError(  dwError,
                    lpCP->lpSharePath,
                    lpCP->lpRemotePath);
#endif

bailout:

    if (hfSrc != INVALID_HANDLE_VALUE)
        CloseHandle(hfSrc);

    if (hfDst != INVALID_HANDLE_VALUE) {

        CloseHandle(hfDst);

        // if we failed,
        if (dwError != ERROR_SUCCESS)
            DeleteFile(szDstName);
    }

    if (lptzLocalPath) {
        DeleteFile(lptzLocalPath);
        LocalFree(lptzLocalPath);
    }

    if (lprwBuff)
        LocalFree(lprwBuff);

    if (lptzLocalPathCscBmp)
      LocalFree(lptzLocalPathCscBmp);

    if (lpbitmap)
      CSC_BitmapDelete(&lpbitmap);

    ReintKdPrint(MERGE, ("DoObjectEdit returning %d\n", dwError));
    return (dwError);
}

DWORD
PRIVATE
DoCreateDir(
    HANDLE              hShadowDB,
    _TCHAR *            lpDrive,
    _TCHAR *            lptzFullPath,
    LPCOPYPARAMS        lpCP,
    LPSHADOWINFO        lpSI,
    LPWIN32_FIND_DATA   lpFind32Local,
    LPWIN32_FIND_DATA   lpFind32Remote,
    int                 iShadowStatus,
    int                 iFileStatus,
    int                 uAction,
    DWORD               dwFileSystemFlags,
    LPCSCPROC           lpfnMergeProgress,
    DWORD_PTR           dwContext
    )
/*++

Routine Description:

    This routine does the actual merge for directories

Arguments:

    hShadowDB           Handle to the redir to call issue ioctl calls

    lpDrive             drivemapping to bypass CSC while making changes on the remote

    lptzFullPath        Fully qualified path

    lpCP                Copy parameters, contain share name, path relative to the share and the
                        the name in the local database

    lpSI                info such as pincount and pinflags

    lpFind32Local       win32 info for the local replica

    lpFind32Remote      win32 infor for the origianl, NULL if the original doesn't exist

    iShadowStatus       status of the local copy

    iFileStatus         status of the remote copy

    uAction             action to be performed

    dwFileSystemFlags   filesystem flags to do special things for NTFS

    lpfnMergeProgress   progress callback

    dwContext           callback context


Returns:

    error code as defined in winerror.h

Notes:


--*/
{
    DWORD dwError=ERROR_FILE_NOT_FOUND;
    WIN32_FIND_DATA sFind32Remote;
    BOOL fCreateDir = FALSE;
    _TCHAR szSrcName[MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC+10];
    _TCHAR *lprwBuff = NULL;

    lprwBuff = LocalAlloc(LPTR, FILL_BUF_SIZE_LAN);

    if (!lprwBuff)
    {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    // Let us create the real name x:\foo\bar
    lstrcpy(szSrcName, lpDrive);
    lstrcat(szSrcName, lpCP->lpRemotePath);

    if(lpFind32Remote &&
        !(lpFind32Remote->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)){

        if (lpSI->uStatus & SHADOW_REUSED){

            // we now know that a file by this name has been deleted
            // and a directory has been created in it's place
            // we try to delete the file before createing the directory
            // NB, the other way is not possible because we don't allow directory deletes
            // in disconnected mode
            dwError = (!DeleteFile(szSrcName)) ? GetLastError(): NO_ERROR;

            if ((dwError==NO_ERROR)||
                (dwError==ERROR_FILE_NOT_FOUND)||
                (dwError==ERROR_PATH_NOT_FOUND)){
                lstrcpy(lprwBuff, szSrcName);
                dwError = NO_ERROR;
            }
        }

        if (dwError != NO_ERROR){
#if 0
            LogReintError(ERROR_ATTRIBUTE_CONFLICT, lpCP->lpSharePath, lpCP->lpRemotePath);
#endif
            dwError = GetUniqueName(szSrcName, lprwBuff);
        }

        if (dwError == NO_ERROR){
            if ((dwError = InbCreateDir(    lprwBuff,
                                             (mShadowAttribChange(lpSI->uStatus)
                                             ? lpFind32Local->dwFileAttributes
                                             : 0xffffffff)
                                            ))==NO_ERROR)
            {
                if(!GetWin32Info(lprwBuff, &sFind32Remote)){
                    dwError = GetLastError();
                }
                else{
#if 0
                    lpLeaf1 = GetLeafPtr(szSrcName);
                    lpLeaf2 = GetLeafPtr(lprwBuff);
                    wsprintf(lprwBuff+512
                     , "Directory Name changed from %s to %s on %s\r\n"
                     , lpLeaf1, lpLeaf2, lpCP->lpSharePath);
                    WriteLog(lprwBuff+512);
#endif
                }
            }
        }
    }
    else{
        if ((dwError = InbCreateDir(szSrcName,
                                             (mShadowAttribChange(lpSI->uStatus)
                                             ? lpFind32Local->dwFileAttributes
                                             : 0xffffffff)
                                            ))==NO_ERROR){
            if (!GetWin32Info(szSrcName, &sFind32Remote)){
                dwError = GetLastError();
            }
         }
    }

    if (dwError == NO_ERROR){

        if(!SetShadowInfo(hShadowDB, lpSI->hDir, lpSI->hShadow, &sFind32Remote, (unsigned)(~SHADOW_MODFLAGS), SHADOW_FLAGS_AND))
        {
            dwError = GetLastError();
        }
        else
        {
            ReintKdPrint(MERGE, ("Created directory %s%s", lpCP->lpSharePath, lpCP->lpRemotePath));
        }
    }
    else{
#if 0
        wsprintf(lprwBuff, "Error merging %s%s\r\n"
                    , lpCP->lpSharePath
                    , lpCP->lpRemotePath);
        WriteLog(lprwBuff);
#endif
    }

    if (lprwBuff)
    {
        LocalFree(lprwBuff);

    }
    return (dwError);
}

VOID
CleanupReintState(
    VOID
    )
{
    if (vsRei.hShare)
    {

        ReintKdPrint(MERGE, ("CSCDLL.CleanupReintState: ending reint on hShare=%x\r\n", vsRei.hShare));
//        EndReint(INVALID_HANDLE_VALUE, vsRei.hShare);

        if (vsRei.tzDrive[0])
        {
            ReintKdPrint(MERGE, ("CSCDLL.CleanupReintState: unmapping merge drive\r\n"));
            DWDisconnectDriveMappedNet(vsRei.tzDrive, TRUE);
            vsRei.tzDrive[0] = 0;
        }

        vsRei.hShare = 0;

    }
}

HANDLE
CreateTmpFileWithSourceAcls(
    _TCHAR  *lptzSrc,
    _TCHAR  *lptzDst
    )
/*++

Routine Description:

    This routine is used by DoObjectEdit while pushing back a file during merge.
    It's job is to get the descritionary ACLs from the source file and use
    them to create a temp file to which we are going to copy the data before renaming it to
    the source

Arguments:


Returns:

    file handle is successful, INVALID_HANDLE_VALUE if failed. In case of failure,
    GetLastError() tells the specific error code.


Notes:

--*/
{
    char buff[1];
    BOOL fRet = FALSE;
    SECURITY_ATTRIBUTES sSA;
    DWORD   dwSize = 0;
    HANDLE  hDst = INVALID_HANDLE_VALUE;

    memset(&sSA, 0, sizeof(sSA));

    sSA.lpSecurityDescriptor = buff;
    dwSize = 0;

    if(!GetFileSecurity(
        lptzSrc,
        DACL_SECURITY_INFORMATION,
        sSA.lpSecurityDescriptor,
        0,
        &dwSize))
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            sSA.lpSecurityDescriptor = LocalAlloc(LPTR, dwSize);

            if (sSA.lpSecurityDescriptor)
            {
                if(GetFileSecurity(
                    lptzSrc,
                    DACL_SECURITY_INFORMATION,
                    sSA.lpSecurityDescriptor,
                    dwSize,
                    &sSA.nLength))
                {
                    sSA.nLength = sizeof(sSA);
                    fRet = TRUE;
                }
                else
                {
                    dwSize = GetLastError();
                    LocalFree(sSA.lpSecurityDescriptor);
                    SetLastError(dwSize);
                }
            }
        }
    }
    else
    {
        fRet = TRUE;
    }

    if (fRet)
    {
        hDst = CreateFile(lptzDst,
                                 GENERIC_WRITE,
                                 0,
                                 &sSA,
                                 CREATE_ALWAYS,
                                 0,
                                 NULL);

        if (hDst == INVALID_HANDLE_VALUE)
        {
            dwSize = GetLastError();
        }

        if (sSA.lpSecurityDescriptor)
        {
            LocalFree(sSA.lpSecurityDescriptor);
        }
        if (hDst == INVALID_HANDLE_VALUE)
        {
            SetLastError(dwSize);
        }

    }

    return hDst;
}

BOOL
HasMultipleStreams(
    _TCHAR  *lpExistingFileName,
    BOOL    *lpfTrueFalse
    )
/*++

Routine Description:

    This routine is used by DoObjectEdit while pushing back a file during merge.
    It looks to see whether the destination file has multiple streams.

Arguments:

    lpExistingFileName  Name of an existing file
    lpfTrueFalse        output parameter, returns TRUE is the call succeedes and there are multiple streams

Returns:

    returns TRUE if successful

Notes:

--*/
{
    HANDLE SourceFile = INVALID_HANDLE_VALUE;
    PFILE_STREAM_INFORMATION StreamInfoBase = NULL;
    ULONG StreamInfoSize;
    IO_STATUS_BLOCK IoStatus;
    BOOL    fRet = FALSE;
    DWORD   Status;

    *lpfTrueFalse = FALSE;

    SourceFile = CreateFile(
                    lpExistingFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );
    if (SourceFile == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }
    //
    //  Obtain the full set of streams we have to copy.  Since the Io subsystem does
    //  not provide us a way to find out how much space this information will take,
    //  we must iterate the call, doubling the buffer size upon each failure.
    //
    //  If the underlying file system does not support stream enumeration, we end up
    //  with a NULL buffer.  This is acceptable since we have at least a default
    //  data stream,
    //

    StreamInfoSize = 4096;
    do {
        StreamInfoBase = LocalAlloc(LPTR, StreamInfoSize );

        if ( !StreamInfoBase ) {
            SetLastError( STATUS_NO_MEMORY );
            goto bailout;
        }

        Status = NtQueryInformationFile(
                    SourceFile,
                    &IoStatus,
                    (PVOID) StreamInfoBase,
                    StreamInfoSize,
                    FileStreamInformation
                    );

        if (Status != STATUS_SUCCESS) {
            //
            //  We failed the call.  Free up the previous buffer and set up
            //  for another pass with a buffer twice as large
            //

            LocalFree(StreamInfoBase);
            StreamInfoBase = NULL;
            StreamInfoSize *= 2;
        }

    } while ( Status == STATUS_BUFFER_OVERFLOW || Status == STATUS_BUFFER_TOO_SMALL );

    if (Status == STATUS_SUCCESS)
    {
        fRet = TRUE;

        if (StreamInfoBase)
        {
            if (StreamInfoBase->NextEntryOffset)
            {
                *lpfTrueFalse = TRUE;
            }
        }
    }

bailout:

    if (SourceFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(SourceFile);
    }

    if (StreamInfoBase)
    {
        LocalFree(StreamInfoBase);
    }

    return fRet;
}

#ifdef DEBUG

BOOL
CompareFilePrefixes(
    _TCHAR  *lptzRemotePath,
    _TCHAR  *lptzLocalPath,
    SHADOWINFO      *lpSI,
    WIN32_FIND_DATA *lpFind32,
    LPCSCPROC   lpfnMergeProgress,
    DWORD_PTR   dwContext
    )
{

    HANDLE hfSrc = INVALID_HANDLE_VALUE, hfDst = INVALID_HANDLE_VALUE;
    LPVOID  lpvSrc = NULL, lpvDst = NULL;
    unsigned cbSrcTotal = 0, cbDstTotal = 0;
    DWORD   dwError = NO_ERROR, dwRemoteSize;

    if (lpfnMergeProgress)
    {
        (*lpfnMergeProgress)(lptzRemotePath, lpSI->uStatus, lpSI->ulHintFlags, lpSI->ulHintPri, lpFind32, CSCPROC_REASON_BEGIN, 0, 0, dwContext);
    }

    ReintKdPrint(ALWAYS, ("Comparing %ls with %ls \r\n", lptzLocalPath, lptzRemotePath));

    lpvSrc = LocalAlloc(LPTR, FILL_BUF_SIZE_LAN);

    if (!lpvSrc)
    {
        ReintKdPrint(BADERRORS, ("CompareFilesPrefix: Memory Allocation Error\r\n"));
        goto bailout;
    }

    lpvDst = LocalAlloc(LPTR, FILL_BUF_SIZE_LAN);

    if (!lpvDst)
    {
        ReintKdPrint(BADERRORS, ("CompareFilesPrefix: Memory Allocation Error\r\n"));
        goto bailout;
    }

    hfSrc = CreateFile(lptzLocalPath,
                                 GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL);

    if (hfSrc ==  INVALID_HANDLE_VALUE)
    {
        ReintKdPrint(BADERRORS, ("Failed to open database file for Inode=%x\r\n", lpSI->hShadow));
        goto bailout;
    }

    hfDst = CreateFile(lptzRemotePath,
                                 GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL);

    if (hfDst ==  INVALID_HANDLE_VALUE)
    {
        ReintKdPrint(BADERRORS, ("Failed to open remote file for Inode=%x\r\n", lpSI->hShadow));
        goto error;
    }

    dwRemoteSize = GetFileSize(hfDst, NULL);

    if (dwRemoteSize == 0xffffffff)
    {
        ReintKdPrint(BADERRORS, ("Failed to get size for remote file for Inode=%x\r\n", lpSI->hShadow));
        goto error;
    }

    if (dwRemoteSize != lpFind32->nFileSizeLow)
    {
        ReintKdPrint(BADERRORS, ("mismatched local and remote sizes for Inode=%x\r\n", lpSI->hShadow));
        SetLastError(ERROR_INVALID_DATA);
        goto error;
    }

    do{
        unsigned cbReadSrc, cbReadDst;

        if (!ReadFile(hfSrc, lpvSrc, FILL_BUF_SIZE_LAN, &cbReadSrc, NULL)){
            goto error;
        }

        if (!cbReadSrc) {
           break;
        }

        cbSrcTotal += cbReadSrc;

        if(!ReadFile(hfDst, (LPBYTE)lpvDst, cbReadSrc, &cbReadDst, NULL)){
            goto error;
        }

        cbDstTotal += cbReadDst;

        if (cbReadSrc > cbReadDst)
        {
            ReintKdPrint(ALWAYS, ("CompareFilesPrefix: RemoteFile sized is smaller than Local Size\r\n"));
            SetLastError(ERROR_INVALID_DATA);
            goto error;
        }

        if (memcmp(lpvSrc, lpvDst, cbReadSrc))
        {
            ReintKdPrint(ALWAYS, ("mismatched!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n"));
            SetLastError(ERROR_INVALID_DATA);
            goto error;
        }

    } while(TRUE);

    goto bailout;

error:
    dwError = GetLastError();
    ReintKdPrint(BADERRORS, ("Error=%d\r\n", dwError));

bailout:
    if (hfSrc != INVALID_HANDLE_VALUE) {
        CloseHandle(hfSrc);
    }

    if (hfDst != INVALID_HANDLE_VALUE) {

        CloseHandle(hfDst);
    }

    if (lpvSrc)
    {
        FreeMem(lpvSrc);
    }

    if (lpvDst)
    {
        FreeMem(lpvDst);
    }

    if (lpfnMergeProgress)
    {
        (*lpfnMergeProgress)(lptzRemotePath, lpSI->uStatus, lpSI->ulHintFlags, lpSI->ulHintPri, lpFind32, CSCPROC_REASON_END, cbDstTotal, dwError, dwContext);
    }

    return TRUE;
}

int
CheckCSCDirCallback(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    LPTSTR          lptzFullPath,
    DWORD           dwCallbackReason,
    WIN32_FIND_DATA *lpFind32,
    SHADOWINFO      *lpSI,
    LPREINT_INFO     lpRei
    )
{
    int retCode = TOD_CONTINUE;
    LPCOPYPARAMS lpCP = NULL;
    BOOL   fInsertInList = FALSE, fIsFile;
    _TCHAR *lptzLocalPath = NULL;
    _TCHAR szRemoteName[MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC+10];

    if (dwCallbackReason != TOD_CALLBACK_REASON_NEXT_ITEM)
    {
        return retCode;
    }
    fIsFile = ((lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0);

    if (!fIsFile)
    {
        return retCode;
    }

    lpCP = LpAllocCopyParams();

    if (!lpCP){
        ReintKdPrint(BADERRORS, ("CheckCSCDirCallback: Allocation of copyparam buffer failed\n"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        retCode = TOD_ABORT;
        goto bailout;
    }

    if(!GetUNCPath(hShadowDB, lpSI->hShare, lpSI->hDir, lpSI->hShadow, lpCP)){

        ReintKdPrint(BADERRORS, ("CheckCSCDirCallback: GetUNCPath failed\n"));
        Assert(FALSE);
        retCode =  TOD_CONTINUE;
        goto bailout;
    }

    Assert(lpRei);

    if (!(lptzLocalPath = GetTempFileForCSC(NULL)))
    {
        ReintKdPrint(BADERRORS, ("CheckCSCDirCallback: failed to get temp file\r\n"));
        goto bailout;
    }

    if (!CopyShadow(hShadowDB, lpSI->hDir, lpSI->hShadow, lptzLocalPath))
    {
        ReintKdPrint(BADERRORS, ("CheckCSCDirCallback: failed to make local copy\r\n"));
        goto bailout;
    }

    // Let us create the real name x:\foo\bar
    lstrcpy(szRemoteName, lpRei->tzDrive);
    lstrcat(szRemoteName, lpCP->lpRemotePath);
    CompareFilePrefixes(
        szRemoteName,
        lptzLocalPath,
        lpSI,
        lpFind32,
        lpRei->lpfnMergeProgress,
        lpRei->dwContext
        );


bailout:
    if (lptzLocalPath)
    {
        DeleteFile(lptzLocalPath);
        LocalFree(lptzLocalPath);
    }
    if (lpCP) {
        FreeCopyParams(lpCP);
    }

    return retCode;
}

BOOL
PUBLIC
CheckCSCShare(
    _TCHAR      *lptzShare,
    LPCSCPROC   lpfnMergeProgress,
    DWORD       dwContext
    )
/*++

Routine Description:


Arguments:


Returns:


Notes:

--*/

{
    BOOL fConnected=FALSE, fDone = FALSE;
    BOOL fStamped = FALSE, fInsertInList = FALSE, fBeginReint = FALSE, fDisabledShadowing = FALSE;
    HANDLE      hShadowDB;
    SHADOWINFO  sSI;
    int iRet;
    DWORD   dwError=NO_ERROR;
    TCHAR   tzFullPath[MAX_PATH+1];
    WIN32_FIND_DATA sFind32;
    REINT_INFO  sRei;

    if (!LpBreakPath(lptzShare, TRUE, &fDone) && !fDone)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    fDone = FALSE;

    memset(&sRei, 0, sizeof(sRei));
    sRei.lpfnMergeProgress = lpfnMergeProgress;
    sRei.dwContext = dwContext;
    memset(sRei.tzDrive, 0, sizeof(sRei.tzDrive));

    if ((hShadowDB = OpenShadowDatabaseIO()) ==INVALID_HANDLE_VALUE)
    {
        ReintKdPrint(BADERRORS, ("CheckShare: failed to open database\r\n"));
        goto bailout;
    }

    memset(&sFind32, 0, sizeof(sFind32));
    lstrcpy(sFind32.cFileName, lptzShare);

    if(!GetShadowEx(hShadowDB, 0, &sFind32, &sSI)||(!sSI.hShadow))
    {
        ReintKdPrint(BADERRORS, ("CheckShare: failed to get the share info\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        goto bailout;
    }

    lstrcpy(tzFullPath, lptzShare);

    dwError = DWConnectNet(lptzShare, sRei.tzDrive, NULL, NULL, NULL, 0, NULL);
    if ((dwError != WN_SUCCESS) && (dwError != WN_CONNECTED_OTHER_PASSWORD_DEFAULT))
    {
        ReintKdPrint(BADERRORS, ("CheckCSCOneShare: Error %d, couldn't connect to %s\r\n", dwError, lptzShare));
        SetLastError(dwError);
        goto bailout;

    }

    ReintKdPrint(MERGE, ("CSC.CheckShare: mapped drive letter %ls \r\n", sRei.tzDrive));

    if (lpfnMergeProgress)
    {
        (*lpfnMergeProgress)(lptzShare, 0, 0, 0, NULL, CSCPROC_REASON_BEGIN, 0, 0, dwContext);
    }

    fConnected = TRUE;

    iRet = TraverseOneDirectory(hShadowDB, NULL, 0, sSI.hShadow, tzFullPath, CheckCSCDirCallback, &sRei);

    if (lpfnMergeProgress)
    {
        (*lpfnMergeProgress)(lptzShare, 0, 0, 0, NULL, CSCPROC_REASON_END, 0, 0, dwContext);
    }

    fDone = TRUE;

bailout:

    CloseShadowDatabaseIO(hShadowDB);

    if (fConnected) {

        if(DWDisconnectDriveMappedNet(sRei.tzDrive, TRUE))
        {
            ReintKdPrint(BADERRORS, ("Failed disconnection of merge drive \r\n"));
        }
        else
        {
            ReintKdPrint(MERGE, ("Disconnected merge drive \r\n"));
        }
    }

    return (fDone);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\shdchk.c ===
#define DEFINED_UNICODE

#include "pch.h"
#ifdef CSC_ON_NT
#pragma hdrstop

#include <winioctl.h>
#endif //CSC_ON_NT

#include "shdcom.h"
#include "shdsys.h"
#include "reint.h"
#include "lib3.h"
#include "strings.h"
#include "oslayeru.h"
#include "record.h"
#include "utils.h"

#define  MAX_SHADOW_DIR_NAME  16
typedef unsigned long ulong;
typedef unsigned short ushort;
typedef VOID (*PRINTPROC)(LPSTR);

typedef struct tagRBA
{
    unsigned        ulidShadow;                 // Inode which is represented by this structure
    GENERICHEADER   sGH;                        // it's header
    CSCHFILE           hf;                         // open handle to the file
    DWORD           cntRBE;                     // count of buffer entries in the array
    DWORD           cntRecsPerRBE;              // #of records per buffer entry
    DWORD           cbRBE;                      // size in bytes of each buffer entry
    LPBYTE          rgRBE[];                    // buffer entry array
}
RBA, *LPRBA;    // stands for RecordBuffArray

#define MAX_RECBUFF_ENTRY_SIZE  (0x10000-0x100)
#define MAX_RBES_EXPECTED       1024


#define INODE_NULL        0L
#define UPDATE_REC        1
#define FIND_REC          2
#define DELETE_REC        3
#define ALLOC_REC         4
#define SHADOW_FILE_NAME_SIZE   8

extern BOOL vfCSCEnabled;
extern DWORD   vdwAgentThreadId;
extern char vszDBDir[MAX_PATH];

static char szBackslash[] = "\\";
static const char vszWorstCaseDefDir[] ="c:\\csc\\";
// directory name where the CSC database lives
// subdirectories under CSC directory
char szStarDotStar[]="*.*";
char vchBuff[256], vchPrintBuff[1024];

extern DWORD vdwDBCapacity, vdwClusterSize;

#define RecFromInode(hShadow)       ((hShadow & 0x7fffffff) - (ULID_FIRST_USER_DIR-1))

AssertData;
AssertError;


int DoDBMaintenance(VOID);
int CALLBACK CheckDBProc(
    int cntDrives,
    DWORD dwCookie
    );
int PUBLIC CheckPQ(VOID);
int CountProc(HANDLE hf, LPQHEADER    lpQH, LPQREC        lpQR, unsigned *lpcnt);

BOOL
FindCreateDBDir(
    BOOL    *lpfCreated,
    BOOL    fCleanup    // empty the directory if found
    );

BOOL
DeleteDirectoryFiles(
    LPCSTR  lpszDir
);

int ClearShadowCache();
int CALLBACK ReinitShadowDBProc(
    int cntDrives,
    DWORD dwCookie
    );
BOOL IsValidName(LPSTR lpName);
int SetDefaultSpace(LPSTR lpShadowDir);

VOID
PrintShareHeader(
    LPSHAREHEADER lpSH,
    PRINTPROC lpfnPrintProc
    );

VOID
PrintPQHeader(
    LPQHEADER   lpQH,
    PRINTPROC lpfnPrintProc
    );

VOID
PrintFileHeader(
    LPFILEHEADER lpFH,
    unsigned    ulSpaces,
    PRINTPROC lpfnPrintProc
    );

VOID PrintShareRec(
    unsigned ulRec,
    LPSHAREREC lpSR,
    PRINTPROC lpfnPrintProc
    );

VOID PrintFilerec(
    unsigned ulRec,
    LPFILERECEXT    lpFR,
    unsigned    ulSpaces,
    PRINTPROC lpfnPrintProc
    );

VOID
PrintPQrec(
    unsigned    ulRec,
    LPQREC  lpQrec,
    PRINTPROC lpfnPrintProc
    );

int
PrintSpaces(
    LPSTR   lpBuff,
    unsigned    ulSpaces
    );

#ifdef CSC_ON_NT
BOOL
PUBLIC
CheckCSCShare(
    USHORT  *lptzShare,
    LPCSCPROC   lpfnMergeProgress,
    DWORD       dwContext
    );
#else
BOOL
PUBLIC
CheckCSCShare(
    LPSTR   lptzShare,
    LPCSCPROC   lpfnMergeProgress,
    DWORD       dwContext
    );
#endif

#ifndef CSC_ON_NT

BOOL
CheckCSCDatabaseVersion(
    BOOL    *lpfWasDirty
)
{

    char *lpszName = NULL;
    SHAREHEADER sSH;
    PRIQHEADER    sPQ;

    CSCHFILE hfShare = 0, hfPQ=0;
    BOOL    fOK = FALSE;
    DWORD   dwErrorShare=NO_ERROR, dwErrorPQ=NO_ERROR;

//    OutputDebugStringA("Checking version...\r\n");
    lpszName = FormNameString(vszDBDir, ULID_SHARE);

    if (!lpszName)
    {
        return FALSE;
    }

    if(!(hfShare = OpenFileLocal(lpszName)))
    {
        dwErrorShare = GetLastError();
    }


    FreeNameString(lpszName);

    lpszName = FormNameString(vszDBDir, ULID_PQ);

    if (!lpszName)
    {
        goto bailout;
    }


    if(!(hfPQ = OpenFileLocal(lpszName)))
    {
        dwErrorPQ = GetLastError();
    }

    FreeNameString(lpszName);
    lpszName = NULL;

    if ((dwErrorShare == NO_ERROR)&&(dwErrorPQ==NO_ERROR))
    {
        if(ReadFileLocal(hfShare, 0, &sSH, sizeof(SHAREHEADER))!=sizeof(SHAREHEADER))
        {
            //error message
            goto bailout;
        }

        if (sSH.ulVersion != CSC_DATABASE_VERSION)
        {
            goto bailout;
        }

        if (lpfWasDirty)
        {
            *lpfWasDirty = ((sSH.uFlags & FLAG_SHAREHEADER_DATABASE_OPEN) != 0);
        }

        // reset the database open flag
        sSH.uFlags &= ~FLAG_SHAREHEADER_DATABASE_OPEN;

        // don't worry about any errors here
        WriteFileLocal(hfShare, 0, &sSH, sizeof(SHAREHEADER));

        if(ReadFileLocal(hfPQ, 0, &sPQ, sizeof(PRIQHEADER))!=sizeof(PRIQHEADER))
        {
            //error message
            goto bailout;
        }

        if (sPQ.ulVersion != CSC_DATABASE_VERSION)
        {
            goto bailout;
        }

        fOK = TRUE;
    }
    else
    {
        if (((dwErrorShare == ERROR_FILE_NOT_FOUND)&&(dwErrorPQ==ERROR_FILE_NOT_FOUND))||
            ((dwErrorShare == ERROR_PATH_NOT_FOUND)&&(dwErrorPQ==ERROR_PATH_NOT_FOUND)))
        {
            fOK = TRUE;
        }
    }

bailout:

    if (lpszName)
    {
        FreeNameString(lpszName);
    }

    if (hfShare)
    {
        CloseFileLocal(hfShare);
    }

    if (hfPQ)
    {
        CloseFileLocal(hfPQ);
    }

    return (fOK);
}

BOOL
UpgradeCSCDatabase(
    LPSTR   lpszDir

)
{
    BOOL    fCreated;

    return (FindCreateDBDir(&fCreated, TRUE)); // cleanup dirs if exist
}

BOOL
FindCreateDBDirEx(
    BOOL    *lpfCreated,
    BOOL    *lpfIncorrectSubdirs,
    BOOL    fCleanup    // empty the directory if found
    )
/*++

Routine Description:


Parameters:

Return Value:

Notes:

--*/
{
    DWORD    dwAttr;
    BOOL fRet = FALSE;
    char buff[MAX_PATH+1];
    int i;
    UINT lenDir;


    *lpfIncorrectSubdirs = *lpfCreated = FALSE;

    Assert(vszDBDir[0]);


    DEBUG_PRINT(("InbCreateDir: looking for %s \r\n", vszDBDir));

    if ((dwAttr = GetFileAttributesA(vszDBDir)) == 0xffffffff)
    {
        DEBUG_PRINT(("InbCreateDir: didnt' find the CSC directory trying to create one \r\n"));
        if(CreateDirectoryA(vszDBDir, NULL))
        {
            *lpfCreated = TRUE;
        }
        else
        {
            goto bailout;
        }
    }
    else
    {
        if (dwAttr & FILE_ATTRIBUTE_DIRECTORY)
        {
            if (fCleanup && !DeleteDirectoryFiles(vszDBDir))
            {
                goto bailout;
            }
        }
        else
        {
            goto bailout;
        }
    }


    strcpy(buff, vszDBDir);

    lenDir = strlen(buff);
    buff[lenDir++] = '\\';
    buff[lenDir++] = CSCDbSubdirFirstChar();
    buff[lenDir++] = '1';
    buff[lenDir] = 0;

    for (i=0; i<CSCDB_SUBDIR_COUNT; ++i)
    {
        if ((dwAttr = GetFileAttributesA(buff)) == 0xffffffff)
        {
            *lpfIncorrectSubdirs = TRUE;

            DEBUG_PRINT(("InbCreateDir: didnt' find the CSC directory trying to create one \r\n"));
            if(!CreateDirectoryA(buff, NULL))
            {
                goto bailout;
            }
        }
        else
        {
            if (!(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
            {
                goto bailout;
            }

            if (fCleanup && !DeleteDirectoryFiles(buff))
            {
                goto bailout;
            }

        }

        buff[lenDir-1]++;
    }

    fRet = TRUE;


bailout:

    return (fRet);
}

BOOL
FindCreateDBDir(
    BOOL    *lpfCreated,
    BOOL    fCleanup    // empty the directory if found
    )
/*++

Routine Description:


Parameters:

Return Value:

Notes:

--*/
{
    BOOL    fIncorrectSubdirs = FALSE, fRet;

    if (fRet = FindCreateDBDirEx(lpfCreated, &fIncorrectSubdirs, fCleanup))
    {
        // if the root directory wasn't created and there in correct subdirs
        // then we need to recreate the database.

        if (!*lpfCreated && fIncorrectSubdirs)
        {
            fRet = FindCreateDBDirEx(lpfCreated, &fIncorrectSubdirs, TRUE);
        }
    }
    return fRet;
}

BOOL
DeleteDirectoryFiles(
    LPCSTR  lpszDir
)
{
    WIN32_FIND_DATAA sFind32;
    char buff[MAX_PATH+32];
    HANDLE  hFind;
    int lenDir;
    BOOL fOK = TRUE;


    lstrcpyA(buff, lpszDir);
    lenDir = lstrlenA(buff);

    if (!lenDir)
    {
        return (FALSE);
    }

    if (buff[lenDir-1] != '\\')
    {
        buff[lenDir++] ='\\';
        buff[lenDir]=0;
    }


    lstrcatA(buff, szStarDotStar);


    if ((hFind = FindFirstFileA(buff, &sFind32))!=INVALID_HANDLE_VALUE)
    {
        do
        {
            buff[lenDir] = 0;

            if (!(sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                && IsValidName(sFind32.cFileName))
            {
                lstrcatA(buff, sFind32.cFileName);
                fOK = DeleteFileA(buff);
                if (!fOK)
                {
                    break;
                }
            }
        }
        while(FindNextFileA(hFind, &sFind32));

        FindClose(hFind);
    }
    return (fOK);
}


BOOL IsValidName(LPSTR lpName)
{
    int len = strlen(lpName), ch, i=0;

    if (len != INODE_STRING_LENGTH)
    {
        return FALSE;
    }

    while (len--)
    {
        ++i;

        ch = *lpName++;
        if (!(((ch>='0') && (ch <='9'))||
            ((ch>='A') && (ch <='F'))||
            ((ch>='a') && (ch <='f'))))
        {
            return FALSE;
        }
    }

    if (i != INODE_STRING_LENGTH)
    {
        return FALSE;
    }

    return (TRUE);
}

#endif



BOOL WINAPI CheckCSCEx(
    LPSTR       lpszShare,
    LPCSCPROC   lpfnProgress,
    DWORD       dwContext,
    DWORD       dwType
)
{
#ifdef DEBUG
#ifdef CSC_ON_NT
    USHORT uBuff[MAX_PATH];

    memset(uBuff, 0, sizeof(uBuff));
    if (MultiByteToWideChar(CP_ACP, 0, lpszShare, strlen(lpszShare), uBuff, sizeof(uBuff)))
    {
        return(CheckCSCShare(uBuff, lpfnProgress, dwContext));
    }
#else
    return(CheckCSCShare(lpszShare, lpfnProgress, dwContext));

#endif
#else
    return FALSE;
#endif
    return FALSE;
}

BOOL
WINAPI
CheckCSC(
    LPSTR       lpszDBDir,
    BOOL        fFix
    )
{
    LPVOID lpdbID = NULL;
    BOOL    fRet = FALSE;
    char    szDBDir[MAX_PATH+1];
    DWORD   dwDBCapacity;
    DWORD   dwClusterSize;
    ULONG   ulDatabaseStatus;
    
    // if we are the agent and CSC is enabled then bailout;
    if (vdwAgentThreadId)
    {
        if (vfCSCEnabled)
        {
            DEBUG_PRINT(("CheckCSC: CSC is enabled, cannot do database check\r\n"));
            return FALSE;
        }
    }
    else
    {
        unsigned ulSwitch = SHADOW_SWITCH_SHADOWING;
        if(ShadowSwitches(INVALID_HANDLE_VALUE, &ulSwitch, SHADOW_SWITCH_GET_STATE))
        {
            if((ulSwitch & SHADOW_SWITCH_SHADOWING)!=0)
            {
                DEBUG_PRINT(("CheckCSC: CSC is enabled, cannot do database check\r\n"));
                return FALSE;
            }
        }
    }

    if (InitValues(szDBDir, sizeof(szDBDir), &dwDBCapacity, &dwClusterSize))
    {
        if (!(lpdbID = OpenRecDB((lpszDBDir)?lpszDBDir:szDBDir, "Test", 0, dwDBCapacity, dwClusterSize, FALSE, NULL, &ulDatabaseStatus)))
        {
            DEBUG_PRINT(("CheckCSC: failed to open record database at %s\r\n", (lpszDBDir)?lpszDBDir:szDBDir));
            goto bailout;
        }

        fRet = TraverseHierarchy(lpdbID, fFix);
    }
bailout:
    if (lpdbID)
    {
        CloseRecDB(lpdbID);
    }

    return (fRet);
}




VOID
PrintShareHeader(
    LPSHAREHEADER lpSH,
    PRINTPROC lpfnPrintProc
    )
{
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += wsprintfA(vchPrintBuff,"****ShareHeader****\r\n" );

        iRet+=wsprintfA(vchPrintBuff+iRet,"Header: Flags=%xh Version=%lxh Records=%ld Size=%d \r\n",
                    lpSH->uchFlags, lpSH->ulVersion, lpSH->ulRecords, lpSH->uRecSize);

        iRet+=wsprintfA(vchPrintBuff+iRet,"Store: Max=%ld Current=%ld \r\n", lpSH->sMax.ulSize, lpSH->sCur.ulSize);

        iRet+=wsprintfA(vchPrintBuff+iRet,"\r\n");

        (lpfnPrintProc)(vchPrintBuff);
    }
}

VOID
PrintPQHeader(
    LPQHEADER   lpQH,
    PRINTPROC lpfnPrintProc
    )
{
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += wsprintfA(vchPrintBuff+iRet,"****PQHeader****\r\n" );

        iRet += wsprintfA(vchPrintBuff+iRet,"Flags=%xh Version=%lxh Records=%ld Size=%d head=%ld tail=%ld\r\n",
                    lpQH->uchFlags, lpQH->ulVersion, lpQH->ulRecords, lpQH->uRecSize, lpQH->ulrecHead, lpQH->ulrecTail);
        iRet += wsprintfA(vchPrintBuff+iRet,"\r\n");

        (lpfnPrintProc)(vchPrintBuff);
    }
}

VOID
PrintFileHeader(
    LPFILEHEADER lpFH,
    unsigned    ulSpaces,
    PRINTPROC lpfnPrintProc
    )
{

    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);
        iRet += wsprintfA(vchPrintBuff+iRet,"****FileHeader****\r\n" );

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);
        iRet += wsprintfA(vchPrintBuff+iRet,"Flags=%xh Version=%lxh Records=%ld Size=%d\r\n",
                    lpFH->uchFlags, lpFH->ulVersion, lpFH->ulRecords, lpFH->uRecSize);

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);
        iRet += wsprintfA(vchPrintBuff+iRet,"bytes=%ld entries=%d Share=%xh Dir=%xh\r\n",
                    lpFH->ulsizeShadow, lpFH->ucShadows, lpFH->ulidShare, lpFH->ulidDir);

        iRet += wsprintfA(vchPrintBuff+iRet,"\r\n");

        (lpfnPrintProc)(vchPrintBuff);
    }
}

VOID
PrintPQrec(
    unsigned    ulRec,
    LPQREC      lpQrec,
    PRINTPROC lpfnPrintProc
    )
{
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += wsprintfA(vchPrintBuff+iRet,"rec=%xh: Srvr=%xh dir=%xh shd=%xh prev=%xh next=%xh Stts=%xh, RfPr=%d PnCnt=%x PnFlgs=%xh DrEntr=%d\r\n"
                    ,ulRec
                    , lpQrec->ulidShare
                    , lpQrec->ulidDir
                    , lpQrec->ulidShadow
                    , lpQrec->ulrecPrev
                    , lpQrec->ulrecNext
                    , (unsigned long)(lpQrec->usStatus)
                    , (unsigned long)(lpQrec->uchRefPri)
                    , (unsigned long)(lpQrec->uchHintPri)
                    , (unsigned long)(lpQrec->uchHintFlags)
                    , lpQrec->ulrecDirEntry

            );

        (lpfnPrintProc)(vchPrintBuff);
    }
}

VOID PrintShareRec(
    unsigned ulRec,
    LPSHAREREC lpSR,
    PRINTPROC lpfnPrintProc
    )
{
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += wsprintfA(vchPrintBuff+iRet,"Type=%c Flags=%xh hShare=%lxh Root=%0lxh status=%xh Share=%s \r\n"
             , lpSR->uchType, (unsigned)lpSR->uchFlags, ulRec, lpSR->ulidShadow
             , lpSR->uStatus, lpSR->rgPath);
        iRet += wsprintfA(vchPrintBuff+iRet,"Hint: HintFlags=%xh\r\n",
                     (unsigned)(lpSR->uchHintFlags));

        iRet += wsprintfA(vchPrintBuff+iRet, "\r\n");

        (lpfnPrintProc)(vchPrintBuff+iRet);
    }
}

VOID PrintFilerec(
    unsigned ulRec,
    LPFILERECEXT    lpFR,
    unsigned    ulSpaces,
    PRINTPROC lpfnPrintProc
    )
{
    int i;
    int iRet=0;

    if (lpfnPrintProc)
    {
        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);

        iRet += wsprintfA(vchPrintBuff+iRet,"Type=%c Flags=%xh Inode=%0lxh status=%xh 83Name=%ls size=%ld attrib=%lxh \r\n",
            lpFR->sFR.uchType, (unsigned)lpFR->sFR.uchFlags, lpFR->sFR.ulidShadow,
            lpFR->sFR.uStatus, lpFR->sFR.rgw83Name, lpFR->sFR.ulFileSize, lpFR->sFR.dwFileAttrib);

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);

        iRet += wsprintfA(vchPrintBuff+iRet,"time: hi=%lxh lo=%lxh orgtime: hi=%lxh lo=%lxh\r\n"
                     , lpFR->sFR.ftLastWriteTime.dwHighDateTime,lpFR->sFR.ftLastWriteTime.dwLowDateTime
                     , lpFR->sFR.ftOrgTime.dwHighDateTime,lpFR->sFR.ftOrgTime.dwLowDateTime);

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);

        iRet += wsprintfA(vchPrintBuff+iRet,"Hint: HintFlags=%xh, RefPri=%d, HintPri=%d AliasInode=%0lxh \r\n",
                     (unsigned)(lpFR->sFR.uchHintFlags)
                     , (int)(lpFR->sFR.uchRefPri)
                     , (int)(lpFR->sFR.uchHintPri)
                     , lpFR->sFR.ulidShadowOrg);

        iRet += PrintSpaces(vchPrintBuff+iRet, ulSpaces);

        iRet += wsprintfA(vchPrintBuff+iRet,"LFN=%-14ls", lpFR->sFR.rgwName);

        for(i = 0; i < OvfCount(lpFR); ++i)
        {
            iRet += wsprintfA(vchPrintBuff+iRet,"%-74s", &(lpFR->sFR.ulidShadow));
        }

        iRet += wsprintfA(vchPrintBuff+iRet,"\r\n");

        (lpfnPrintProc)(vchPrintBuff);
    }
}

int
PrintSpaces(
    LPSTR   lpBuff,
    unsigned    ulSpaces
    )
{
    unsigned i;
    int iRet=0;

    for (i=0; i< ulSpaces; ++i)
    {
        iRet += wsprintfA(lpBuff+iRet," ");
    }
    return iRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\strings.h ===
//
// Global strings here.
//


extern LPCTSTR  vszReintClass;
extern LPCTSTR  vszReintWnd;
extern LPCTSTR  vszCreateOK ;
extern LPCTSTR  vszConnectError ;
extern LPCTSTR  vszConnectOK ;
extern LPCTSTR  vszPanic;
extern LPCTSTR  vszTimeDateFormat ;
extern LPCTSTR  vszLogFile;
extern LPCTSTR  vszReintWnd;

extern LPCTSTR  vszSeekErr;
extern LPCTSTR  vszReadErr;
extern LPCTSTR  vszWriteErr;
extern LPCTSTR  vszMinSparseFillPri;
extern LPCTSTR  vsz386Enh;
extern LPCTSTR  vszSystemIni;
extern LPCTSTR  vszConflictMsg;
extern LPCTSTR  vszSlash;
extern LPCTSTR  vszOpsInProgress ;
extern LPCTSTR  vszShadowReg;
extern LPCTSTR  vszExclHint;
extern LPCTSTR  vszExclDelim;
extern LPCTSTR  vszDoLogCopy;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\reint.h ===
#ifndef __REINTH
#define __REINTH


#define  ERROR_SHADOW_OP_FAILED  3000L
#define  ERROR_REINT_FAILED      3001L
#define  ERROR_STALE             3002L
#define  ERROR_REMOTE_OP_FAILED  3003L


#define  ERROR_CONFLICT_FIRST       3100L
#define  ERROR_CREATE_CONFLICT      3100L // A locally created file already exists
#define  ERROR_DELETE_CONFLICT      3101L // A lcally modified shadow has been deleted from the remote
#define  ERROR_UPDATE_CONFLICT      3102L // Updated on remote while client changed it when disconnected
#define  ERROR_ATTRIBUTE_CONFLICT   3103L
#define  ERROR_NO_CONFLICT_DIR      3104L
#define  ERROR_CONFLICT_LAST        3104L



// Force level fro refreshconnections

#define REFRESH_FORCE_UNC_ONLY      0   // nuke UNC connections if no outstanding ops
#define REFRESH_FORCE_GENTLE        1   // nuke all connections if no outstanding ops
#define REFRESH_FORCE_SHADOW        2   // nuke all shadow connections
#define REFRESH_FORCE_ALL           3   // nuke all connection


// Verbose level while nuking connections
#define REFRESH_SILENT              0
#define REFRESH_NOISY               1

#ifdef CSC_ON_NT

#define  FILL_BUF_SIZE_SLOWLINK 4096
#define  FILL_BUF_SIZE_LAN      (FILL_BUF_SIZE_SLOWLINK * 4)

#define MyStrChr            wcschr
#define MyPathIsUNC(lpT)    ((*(lpT)==_T('\\')) && (*(lpT+1)==_T('\\')))
#else

#define  FILL_BUF_SIZE_SLOWLINK 512
#define  FILL_BUF_SIZE_LAN      (4096-1024)

#define MyStrChr            StrChr
#define MyPathIsUNC(lpT)    PathIsUNC(lpT)

#endif

#define  PUBLIC   FAR   PASCAL
#define  PRIVATE  NEAR  PASCAL

/******************* Macros *************************************************/
#define  mModifiedOffline(ulStatus) ((ulStatus) & (SHADOW_DIRTY|SHADOW_TIME_CHANGE|SHADOW_ATTRIB_CHANGE))

/******************* Typedefs ***********************************************/

typedef struct tagERRMSG
   {
   DWORD dwError;
   unsigned uMessageID;
   }
ERRMSG;

typedef struct tagFAILINFO
   {
   struct tagFAILINFO FAR *lpnextFI;
   HSHARE  hShare;
   HSHADOW  hDir;
   HSHADOW  hShadow;
   unsigned short cntFail;
   unsigned short cntMaxFail;
   DWORD    dwFailTime;
#ifdef DEBUG
   _TCHAR    rgchPath[MAX_PATH+1];
#endif //DEBUG
   }
FAILINFO, FAR *LPFAILINFO;

typedef struct tagCONNECTINFO
   {
   struct tagCONNECTINFO *lpnextCI;
   unsigned uStatus;
#ifdef _WIN64
 __declspec(align(8))
#endif
   byte rgFill[];
   }
CONNECTINFO, FAR *LPCONNECTINFO;

typedef  int (CALLBACK *LPFNREFRESHPROC)(LPCONNECTINFO, DWORD);
typedef  int (CALLBACK *LPFNREFRESHEXPROC)(int, DWORD);
// In reint.c
int PRIVATE DisplayMessageBox(HWND, int, int, UINT);
int PRIVATE PurgeSkipQueue(
   BOOL fAll,
   HSHARE  hShare,
   HSHADOW  hDir,
   HSHADOW  hShadow
   );

int PUBLIC ReintAllShares(HWND hwndParent);

typedef struct tagUPDATEINFO
{
    HSHARE hShare;
    HWND hwndParent;
} UPDATEINFO, FAR * PUPDATEINFO;



//
// Pass in the Share to merge on
// and the parent window.
//
int PUBLIC ReintOneShare(HSHARE hShare, HSHADOW hRoot, _TCHAR *, _TCHAR *, _TCHAR *, ULONG, LPCSCPROC lpfnMergeProgress, DWORD_PTR dwContext);

BOOL FGetConnectionList(LPCONNECTINFO *, int *);
BOOL FGetConnectionListEx(LPCONNECTINFO *lplpHead, LPCTSTR  lptzShareName, BOOL fAllSharesOnServer, BOOL fForceOffline, int *lpcntDiscon);
int DisconnectList(LPCONNECTINFO *, LPFNREFRESHPROC lpfn, DWORD dwCookie);
int ReconnectList(LPCONNECTINFO *,HWND hwndParent);
VOID ClearConnectionList(LPCONNECTINFO *);
void DoFreeShadowSpace(void);
void GetLogCopyStatus(void);
_TCHAR * PRIVATE LpGetExclusionList( VOID );
VOID PRIVATE ReleaseExclusionList( LPVOID lpBuff);

DWORD
PRIVATE
DWConnectNet(
    _TCHAR  *lpSharePath,
    _TCHAR  *lpOutDrive,
    _TCHAR  *lpDomainName,
    _TCHAR  *lpUserName,
    _TCHAR  *lpPassword,
    DWORD   dwFlags,
    BOOL    *lpfIsDfsConnect
    );

DWORD DWDisconnectDriveMappedNet(
    LPTSTR  lptzDrive,
    BOOL    fForce
    );
#ifdef DEBUG
VOID EnterSkipQueue(
   HSHARE hShare,
   HSHADOW hDir,
   HSHADOW hShadow,
   _TCHAR * lpPath );
#else
VOID EnterSkipQueue(
   HSHARE hShare,
   HSHADOW hDir,
   HSHADOW hShadow);
#endif //DEBUG

BOOL GetWin32Info(
    _TCHAR * lpFile,
    LPWIN32_FIND_DATA lpFW32 );

LPCOPYPARAMS LpAllocCopyParams(VOID);
VOID FreeCopyParams( LPCOPYPARAMS lp );
BOOL CALLBACK ShdLogonProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

int BreakConnectionsInternal(
   int  force,
   BOOL verbose
   );

int RefreshConnectionsInternal(
   int  force,
   BOOL verbose
   );

int RefreshConnectionsEx(
   int  force,
   BOOL verbose,
   LPFNREFRESHEXPROC lpfn,
   DWORD dwCookie
   );


//Synchronization functions
int PUBLIC
EnterAgentCrit(
    VOID
    );

VOID PUBLIC
LeaveAgentCrit(
    VOID
    );


int
ExtractSpaceStats(
    IN GLOBALSTATUS *lpsGS,
    OUT unsigned long   *lpulMaxSpace,
    OUT unsigned long   *lpulCurSpace,
    OUT unsigned long   *lpulFreeSpace
    );

VOID
ReInt_DoFreeShadowSpace(
    GLOBALSTATUS *lpsGS,
    int fForce
    );

BOOL
CALLBACK
ShdLogonProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
TruncateAndMarkSparse(
    HANDLE,
    _TCHAR *,
    LPSHADOWINFO
    );

DWORD
DWConnectNetEx(
    _TCHAR * lpSharePath,
    _TCHAR * lpOutDrive,
    BOOL fInteractive
    );

int
AttemptCacheFill (
    HSHARE  hShare,
    int         type,
    BOOL        fFullSync,
    ULONG       ulPrincipalID,
    LPCSCPROC   lpfnFillProgress,
    DWORD_PTR   dwContext
);

DWORD
DoSparseFill(
    HANDLE      hShadowDB,
    _TCHAR      *,
    _TCHAR      *,
    LPSHADOWINFO,
    WIN32_FIND_DATA *,
    LPCOPYPARAMS    lpCP,
    BOOL    fStalenessCheck,
    ULONG       ulPrincipalID,
    LPCSCPROC,
    DWORD_PTR
    );

DWORD
DoRefresh(
    HANDLE    hShadowDB,
    LPCOPYPARAMS lpCP,
    _TCHAR *,
    LPSHADOWINFO,
    _TCHAR *
    );

VOID
ReportLastError(
    VOID
    );

int
CheckDirtyShares(
    VOID
    );

// Shadow Cache Maintenance Functions
int DoDBMaintenance(VOID);
int ClearShadowCache(VOID);

void CopyLogToShare(void);

BOOL
FStopAgent(
    VOID
    );

BOOL
UpdateExclusionList(
    VOID
    );

BOOL
UpdateBandwidthConservationList(
    VOID
    );

BOOL
SetAgentThreadImpersonation(
    HSHADOW hDir,
    HSHADOW hShadow,
    BOOL    fWrite
    );

BOOL
ResetAgentThreadImpersonation(
    VOID
    );

BOOL
FAbortOperation(
    VOID
    );

VOID
SetAgentShutDownRequest(
    VOID
    );

BOOL
HasAgentShutDown(
    VOID
    );

VOID
CleanupReintState(
    VOID
    );

BOOL
InitCSCUI(
    HANDLE  hToken
    );

VOID
TerminateCSCUI(
    VOID
    );

BOOL
GetWin32InfoForNT(
    _TCHAR * lpFile,
    LPWIN32_FIND_DATA lpFW32
    );

DWORD
DoNetUseAddForAgent(
    IN  LPTSTR  lptzShareName,
    IN  LPTSTR  lptzUseName,
    IN  LPTSTR  lptzDomainName,
    IN  LPTSTR  lptzUserName,
    IN  LPTSTR  lptzPassword,
    IN  DWORD   dwFlags,
    OUT BOOL    *lpfIsDfsConnect
    );

#define  DO_ONE_OBJECT               1
#define  DO_ONE_SHARE               2
#define  DO_ALL                      3

#define TOD_CALLBACK_REASON_BEGIN       0
#define TOD_CALLBACK_REASON_NEXT_ITEM   1
#define TOD_CALLBACK_REASON_END         2


#define TOD_CONTINUE        0
#define TOD_ABORT           1
#define TOD_SKIP_DIRECTORY  2

typedef int (*TRAVERSEFUNC)(
                    HANDLE,
                    LPSECURITYINFO,
                    _TCHAR *,
                    DWORD,
                    WIN32_FIND_DATA *,
                    LPSHADOWINFO,
                    LPVOID);

int
TraverseOneDirectory(
    HANDLE          hShadowDB,
    LPSECURITYINFO  pShareSecurityInfo,
    HSHADOW         hParentDir,
    HSHADOW         hDir,
    LPTSTR          lptzInputPath,
    TRAVERSEFUNC    lpfnTraverseDir,
    LPVOID          lpContext
    );


BOOL
GetCSCPrincipalID(
    ULONG *lpPrincipalID
    );

BOOL
GetCSCAccessMaskForPrincipal(
    unsigned long ulPrincipalID,
    HSHADOW hDir,
    HSHADOW hShadow,
    unsigned long *pulAccessMask
    );

BOOL
GetCSCAccessMaskForPrincipalEx(
    unsigned long ulPrincipalID,
    HSHADOW hDir,
    HSHADOW hShadow,
    unsigned long *pulAccessMask,
    unsigned long *pulActualMaskForUser,
    unsigned long *pulActualMaskForGuest
    );

BOOL
GetConnectionInfoForDriveBasedName(
    _TCHAR * lpName,
    LPDWORD lpdwSpeed
    );

BOOL
ReportTransitionToDfs(
    _TCHAR *lptServerName,
    BOOL    fOffline,
    DWORD   cbLen
    );

BOOL
CSCEnumForStatsInternal(
    IN  LPCTSTR     lpszShareName,
    IN  LPCSCPROC   lpfnEnumProgress,
    IN  BOOL        fPeruserInfo,
    IN  BOOL        fUpdateShareReintBit,
    IN  DWORD_PTR   dwContext
);

// interval in milliseconds between two sparsefill attempts
#define WAIT_INTERVAL_ATTEMPT_MS            (1000*60)   // 1  minute

// interval in milliseconds between two polls for global status
#define WAIT_INTERVAL_GLOBALSTATUS_MS       (1000*60*10)    // 10 minutes

// duration in milliseconds after which an entry that is in the skip queue is nuked
#define WAIT_INTERVAL_SKIP_MS               (1000*60*10)    // 10 minutes

// duration in milliseconds between two stalenesscheck iterations

#define WAIT_INTERVAL_BETWEEN_ITERATIONS_MS (1000*60*10)

// interval in milliseconds between two staleness check attempts
#define WAIT_INTERVAL_STALE_MS              (1000*5)        // 5 seconds

#define WAIT_INTERVAL_CHECK_SERVER_ONLINE_MS    (1000*60*8)     // 8 minutes
#define WAIT_INTERVAL_FILL_THROTTLE_MS          (1000*60*2)     // 2 minutes

// delay to wait for PNP to settle down
#define WAIT_INTERVAL_PNP                   (1000*15)   // 15 seconds

// for some Registry queries, this is the max len buffer that I want back
#define MAX_NAME_LEN    100
#define SZ_TRUE "true"
#define SZ_FALSE "false"

extern  _TCHAR *    vlpExclusionList;
extern  HANDLE  vhMutex;
extern  BOOL    vfLogCopying,vfCopying,allowAttempt;
extern  HCURSOR  vhcursor;
extern  HWND    vhdlgShdLogon;
extern  DWORD   dwVxDEvent;
extern  HWND    vhwndMain;
extern  HANDLE  vhShadowDB;
extern  DWORD   vdwAgentThreadId;
extern  DWORD   vdwAgentSessionId;
#ifdef CSC_ON_NT
extern  DWORD   vdwCopyChunkThreadId;
extern  HDESK   hdesktopUser;
#endif
extern  BOOL    fFillers;

#define RWM_UPDATE (WM_USER+0x200)
#define RWM_UPDATEALL (WM_USER+0x201)

#ifdef DEBUG
//dbgprint interface
#define ReintKdPrint(__bit,__x) {\
    if (((REINT_KDP_##__bit)==0) || (ReintKdPrintVector & (REINT_KDP_##__bit))) {\
    DEBUG_PRINT(__x);\
    }\
}
#define REINT_KDP_ALWAYS                0x00000000
#define REINT_KDP_BADERRORS             0x00000001
#define REINT_KDP_INIT                  0x00000002
#define REINT_KDP_MAINLOOP              0x00000004
#define REINT_KDP_FILL                  0x00000008
#define REINT_KDP_MERGE                 0x00000010
#define REINT_KDP_API                   0x00000020
#define REINT_KDP_SPACE                 0x00000040
#define REINT_KDP_STALENESS             0x00000080
#define REINT_KDP_SKIPQUEUE             0x00000100
#define REINT_KDP_SECURITY              0x00000200

#define REINT_KDP_GOOD_DEFAULT (REINT_KDP_BADERRORS)

extern ULONG ReintKdPrintVector;

#else

#define ReintKdPrint(__bit,__x) ;

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\sources.inc ===
SOURCES  = \
        ..\ui.c \
        ..\reint.c \
        ..\utils.c \
        ..\list.c \
        ..\strings.c\
        ..\shdchk.c \
        ..\exports.c \
        ..\api.c \
        ..\ntstuff.c \
        ..\reint.rc \
        ..\csc_bmpu.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\traynoti.c ===
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

#include "pch.h"

#include "traynoti.h"
#include "resource.h"

//
// Modifies the Tray notification icon.
//
BOOL Tray_Message(HWND hDlg, DWORD dwMessage, UINT uID, HICON hIcon, LPTSTR pszTip)
{
	NOTIFYICONDATA tnd;

	tnd.cbSize				= sizeof(NOTIFYICONDATA);
	tnd.hWnd				= hDlg;
	tnd.uID					= uID;

	tnd.uFlags				= NIF_MESSAGE|NIF_ICON;
	tnd.uCallbackMessage	= TRAY_NOTIFY;
	tnd.hIcon				= hIcon;

    // Work out what tip we sould use and set NIF_TIP
	*tnd.szTip=0;	
	if (pszTip)
	{
	    if(HIWORD(pszTip))
	    {
		    lstrcpyn(tnd.szTip, pszTip, sizeof(tnd.szTip));
		    tnd.uFlags |= NIF_TIP;
		}
		else
		{
		    if( LoadString(vhinstCur, LOWORD(pszTip), tnd.szTip, sizeof(tnd.szTip) ) )
    		    tnd.uFlags |= NIF_TIP;
	    }
    }

	return Shell_NotifyIcon(dwMessage, &tnd);
}

//
// Removes the icon from the Tray.
//
BOOL Tray_Delete(HWND hDlg)
{
	return Tray_Message(hDlg, NIM_DELETE, 0, NULL, NULL);
}

//
//
//
BOOL Tray_Add(HWND hDlg, UINT uIndex)
{
	HICON hIcon;

    DEBUG_PRINT(("Tray_Add used: Should use Tray_Modify instead"));

	if(!(hIcon = LoadImage(vhinstCur, MAKEINTRESOURCE(uIndex), IMAGE_ICON, 16, 16, 0)))
		return FALSE;
	return Tray_Message(hDlg, NIM_ADD, 0, hIcon, NULL);
}

//
// Will add the tray icon if its not already there. LPTSTR can be a MAKEINTRESOURCE
// If uIndex is NULL then we are to remove the tip
//
BOOL Tray_Modify(HWND hDlg, UINT uIndex, LPTSTR pszTip)
{
	HICON hIcon;

    if( !uIndex )
        return Tray_Delete(hDlg);

	if(!(hIcon = LoadImage(vhinstCur, MAKEINTRESOURCE(uIndex), IMAGE_ICON, 16, 16, 0)))
	{
	    DEBUG_PRINT(("Tray_Add: LoadIcon failed for icon %d\n",uIndex));
		return FALSE;
	}

    // If the notify fails, try adding the icon.
	if(!Tray_Message(hDlg, NIM_MODIFY, 0, hIcon, pszTip))
		return Tray_Message(hDlg, NIM_ADD, 0, hIcon, pszTip);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\strings.c ===
//
// Global strings here.
//

/******************* Includes and Controlling Defines ***********************/
#include "pch.h"

/***************  Initialized data ****************************************/

// #pragma data_seg(DATASEG_READONLY)

const _TCHAR szReintClass[] = _T("AgentClass");	// main window class name
const _TCHAR szReintWnd[] = _T("Agent");			// main window name
const _TCHAR szShadowDevice[] = _T("\\\\.\\shadow");
const _TCHAR szCreateError[] = _T("Couldn't create shadow device file");
const _TCHAR szCreateOK[] = _T("Created shadow device file");
const _TCHAR szConnectError[] = _T("Couldn't register with shadow device");
const _TCHAR szConnectOK[] = _T("Registered with shadow device");
const _TCHAR szPanic[]=_T("Panic");
const _TCHAR szTimeDateFormat[] = _T("\r\n%02d:%02d:%02.2d %02d-%02d-%02d\r\n");
const _TCHAR szSeekErr[]=_T("Seek Error");
const _TCHAR szReadErr[]=_T("Read Error");
const _TCHAR szWriteErr[]=_T("Write Error");
const _TCHAR szMinSparseFillPri[]=_T("SparseFillAbove");
const _TCHAR sz386Enh[]=_T("386enh");
const _TCHAR szSystemIni[]=_T("system.ini");
const _TCHAR szConflictMsg[]=_T("Errors/Conflicts while merging! Check c:\\merge.log");
const _TCHAR szLogFile[]=_T("C:\\merge.log");
const _TCHAR szConflictDir[]=_T("C:\\ConflictsWhileMerging");
const _TCHAR szSlash[]=_T("\\");
const _TCHAR szOpsInProgress[] = _T("Close all open files on %s");
const _TCHAR szShadowReg[]=_T("System\\CurrentControlSet\\Services\\VxD\\Shadow");
const _TCHAR szExclHint[]=_T("ExcludeExtensions");
const _TCHAR szExclDelim[]=_T(", ;");
const _TCHAR szDoLogCopy[]=_T("CopyLogToServer");

// #pragma data_seg()

const _TCHAR * vszReintClass=szReintClass;
const _TCHAR * vszReintWnd=szReintWnd;
const _TCHAR * vszShadowDevice=szShadowDevice;
const _TCHAR * vszCreateError=szCreateError;
const _TCHAR * vszCreateOK=szCreateOK;
const _TCHAR * vszConnectError=szConnectError;
const _TCHAR * vszConnectOK=szConnectOK;
const _TCHAR * vszPanic=szPanic;
const _TCHAR * vszTimeDateFormat=szTimeDateFormat;
const _TCHAR * vszSeekErr=szSeekErr;
const _TCHAR * vszReadErr=szReadErr;
const _TCHAR * vszWriteErr=szWriteErr;
const _TCHAR * vszMinSparseFillPri=szMinSparseFillPri;
const _TCHAR * vsz386Enh=sz386Enh;
const _TCHAR * vszSystemIni=szSystemIni;
const _TCHAR * vszConflictMsg=szConflictMsg;
const _TCHAR * vszLogFile=szLogFile;
const _TCHAR * vszConflictDir=szConflictDir;
const _TCHAR * vszSlash=szSlash;
const _TCHAR * vszOpsInProgress=szOpsInProgress;
const _TCHAR * vszShadowReg=szShadowReg;
const _TCHAR * vszExclHint=szExclHint;
const _TCHAR * vszExclDelim=szExclDelim;
const _TCHAR * vszDoLogCopy=szDoLogCopy;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\traynoti.h ===
extern HANDLE vhinstCur;			// current instance from reint.c

BOOL Tray_Delete(HWND hDlg);
BOOL Tray_Add(HWND hDlg, UINT uIndex);  // You should use Tray_Modify instead.
BOOL Tray_Modify(HWND hDlg, UINT uIndex, LPTSTR pszTip);

#define TRAY_NOTIFY		(WM_APP+100)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\utils.c ===
#include "pch.h"
#pragma hdrstop

#ifndef CSC_ON_NT
#ifndef DBG
#define DBG 0
#endif
#if DBG
#define DEBUG
#else
//if we don't do this DEBUG is defined in shdsys.h....sigh
#define NONDEBUG
#endif
#endif

#include "shdsys.h"
#include "utils.h"
#include "lib3.h"
#include "reint.h"
#include "regstr.h"
#include "record.h"
#include "oslayeru.h"

#define PUBLIC   FAR   PASCAL
#define PRIVATE  NEAR  PASCAL
#define cNull        0
#define SIGN_BIT 0x80000000
#define cBackSlash    _T('\\')
#define    DEFAULT_CACHE_PERCENTAGE    10


extern char vrgchBuff[1024];
extern HWND vhwndMain;

static TCHAR vszTemp[] = _TEXT("TEMP");
static TCHAR vszPrefix[] = _TEXT("C");
static const char vszCSCDirName[]="CSC";


AssertData;
AssertError;

static const _TCHAR szStarDotStar[] = _TEXT("\\*.*");

#ifdef CSC_ON_NT
#else
const TCHAR vszRNAKey[] = REGSTR_PATH_SERVICES "\\RemoteAccess";
const TCHAR vszRNAValue[] = "Remote Connection";
const TCHAR VREDIR_DEVICE_NAME[] = "\\\\.\\VREDIR";
#endif

PWCHAR TempDirs[] = {
        L"TEMP",
        L"TMP",
        L"USERPROFILE",
        NULL };

BOOL
GetCSCFixedDisk(
    TCHAR   *lptzDrive
    );


#ifdef LATER
LPSTR PUBLIC LpGetServerPart(
   LPSTR lpPath,
   LPSTR lpBuff,
   int cBuff
   )
   {
   LPSTR lp = lpPath;
   char c;
   int count;

   if ((*lp++ != cBackSlash)||(*lp++ != cBackSlash))
      return NULL;
   lp = MyStrChr(lp, cBackSlash);
   if (cBuff && lp)
      {
      count = (int)((unsigned long)lp, (unsigned long)lpPath)
      count = min(cBuff-1, count);

      // Nobody should give us bad cBuff values
      Assert(count >=0);
      strncpy(lpBuff, lpPath, count);
      lpBuff[count] = cNull;
      }
   return lp;  // Points to '\' if succeeded
   }
#endif //LATER

LPTSTR PUBLIC LpGetServerPart(
   LPTSTR lpPath,
   LPTSTR lpBuff,
   int cBuff
   )
{
    LPTSTR lp = lpPath;

    if (*(lp+1)!=_T(':'))
        return NULL;

    if (*(lp+2)!=_T('\\'))
        return NULL;

    if (cBuff)
    {
        *lpBuff = *lp;
        *(lpBuff+1) = *(lp+1);
        *(lpBuff+2) = cNull;
    }

    lp += 2;

    return lp;  // Points to '\' if succeeded
}

LPTSTR PUBLIC LpGetNextPathElement(
   LPTSTR lpPath,
   LPTSTR lpBuff,
   int cBuff
   )
{
    LPTSTR lp;
    int bytecount;

    if (*lpPath == cBackSlash)
        ++lpPath;

    lp = MyStrChr(lpPath, cBackSlash);

    if (cBuff)
    {
       // Is this a leaf?
        if (lp)
        {  // No
            Assert(*lp == cBackSlash);

            bytecount = (int)((ULONG_PTR)lp-(ULONG_PTR)lpPath);
            bytecount = min(cBuff-1, bytecount);
        }
        else  // Yes
            bytecount = lstrlen(lpPath) * sizeof(_TCHAR);

       Assert(bytecount >= 0);

       memcpy(lpBuff, lpPath, bytecount);

       lpBuff[bytecount/sizeof(_TCHAR)] = cNull;
    }

    return lp;
}

LPTSTR PUBLIC GetLeafPtr(
   LPTSTR lpPath
   )
   {
   LPTSTR lp, lpLeaf;

   // Prune the server part
   if (!(lp=LpGetServerPart(lpPath, NULL, 0)))
      lp = lpPath;

   for (;lp;)
      {
      // Step over the '\'
      if (*lp==cBackSlash)
         lp++;

      // call this the leaf, pending confirmation
      lpLeaf = lp;

      // See if there is another element
      lp = LpGetNextPathElement(lp, NULL, 0);
      }

   return (lpLeaf);
   }





//
//

LPTSTR
LpBreakPath(
    LPTSTR lpszNextPath,
    BOOL fFirstTime,
    BOOL *lpfDone
    )
{

    LPTSTR    lpT = lpszNextPath;

    if(fFirstTime)
    {
        if (MyPathIsUNC(lpT))
        {
            lpT +=2;    /* step over \ */

            /* look for \\server\ <------------- */
            lpT = MyStrChr(lpT, cBackSlash);

            if (lpT)
            {
                ++lpT; /* step over \ */

                lpT = MyStrChr(lpT, cBackSlash);

                if (!lpT)
                {
                    /* \\server\share */
                    *lpfDone = TRUE;
                }
                else
                {
                    /* \\server\\share\foo...... */
                    if (!*(lpT+1))
                    {
                        /* \\server\share\ */
                        *lpfDone = TRUE;
                    }

                    *lpT = 0;
                }
            }
        }
        else
        {
            lpT = NULL;
        }
    }
    else    // not the first time
    {
        Assert(*lpT != cBackSlash);

        lpT = MyStrChr(lpT, cBackSlash);

        if(!lpT)
        {
            *lpfDone=TRUE;
        }
        else
        {
            if(*(lpT+1) == 0)
            {// ends in a slash
                *lpfDone = TRUE;
            }

            *lpT = (char) 0;
        }
    }
    return (lpT);
}

void
RestorePath(
    LPTSTR    lpszPtr
)
{
    *lpszPtr = cBackSlash;

}


BOOL
FindCreateShadowFromPath(
    LPCTSTR                lpszFile,
    BOOL                fCreate,    // create if necessary
    LPWIN32_FIND_DATA   lpFind32,
    LPSHADOWINFO        lpSI,
    BOOL                *lpfCreated
    )
{
    HANDLE     hShadowDB = INVALID_HANDLE_VALUE, hFind;
    int done=0, first=1, fWasFirst;
    HSHADOW hDir=0, hShadow=0;
    TCHAR szParsePath[MAX_PATH], szSave[sizeof(szStarDotStar)];
    LPTSTR    lpszCurrent, lpszNext;
    BOOL    fInCreateMode = FALSE, fRet = FALSE, fDisabledShadowing = FALSE;
    DWORD    dwError = ERROR_SUCCESS, dwT;

    // do basic check
    if (lstrlen(lpszFile) >= MAX_PATH)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    hShadowDB = OpenShadowDatabaseIO();

    if (hShadowDB == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    if (lpfCreated)
    {
        *lpfCreated = FALSE;
    }

#ifndef CSC_ON_NT

    if (fCreate)
    {
        if (!DisableShadowingForThisThread(hShadowDB))
        {
            dwError = ERROR_NO_SYSTEM_RESOURCES;
            goto bailout;
        }

        fDisabledShadowing = TRUE;

    }
#endif

    // make a copy so we can party on it
    lstrcpy(szParsePath, lpszFile);
    lpszCurrent = szParsePath;

    do
    {
        hDir = hShadow;

        lpszNext = LpBreakPath(lpszCurrent, first, &done);

        if (!lpszNext && !done)
        {
                dwError = (ERROR_INVALID_PARAMETER);

                goto bailout;
        }

        fWasFirst = first;
        first = 0;    // not first anymore

        lstrcpy(lpFind32->cFileName, lpszCurrent);
        lpFind32->cAlternateFileName[0] = 0;    // !!!! very important, otherwise all CSC APIs
                                                //  may AV on win9x becuase of multibytetowidechar translation
                                                // in Find32AToFind32W in lib3\misc.c

        if (!fInCreateMode)
        {
            if (!GetShadowEx(hShadowDB, hDir, lpFind32, lpSI))
            {
                dwError = GetLastError();
                goto bailout;
            }
            else
            {
                if (!lpSI->hShadow)
                {
                    fInCreateMode = TRUE;
                }
                else
                {
                    Assert(hDir == lpSI->hDir);

                    hShadow = lpSI->hShadow;
                }
            }
        }

        if (fInCreateMode)
        {

            if (fCreate)
            {
                fInCreateMode = TRUE;

                if (fWasFirst)
                {
                    if (!GetWin32Info(szParsePath, lpFind32))
                    {
                        dwError = GetLastError();
                        goto bailout;
                    }

                    lstrcpy(lpFind32->cFileName, szParsePath);
                    lpFind32->cAlternateFileName[0] = 0;

                }
                else
                {
                    hFind = FindFirstFile(szParsePath, lpFind32);
                    // this would fail if we are in disconnected state
                    // becuase we don't have the shadow yet
                    if(INVALID_HANDLE_VALUE == hFind)
                    {
                        dwError = GetLastError();
                        goto bailout;
                    }
                    else
                    {
                        FindClose(hFind);
                    }
                }

                if (!CreateShadow(
                                     hShadowDB,
                                     hDir,
                                     lpFind32,
                                     SHADOW_SPARSE,
                                     &hShadow))
                {
                    dwError = GetLastError();
                    goto bailout;
                }

                // there can be a situation where, the share is also newly created, in which case
                // the hShare is not set. This is our way of doing that.

                if (!lpSI->hShare)
                {
                    if (!GetShadowEx(hShadowDB, hDir, lpFind32, lpSI))
                    {
                        dwError = GetLastError();
                        goto bailout;
                    }
                }

#ifdef CSC_ON_NT
                // on NT we open the file to get the right
                // security credentials
                if (!(lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                {
                    HANDLE hFile;

                    // this should be the last guy
                    hFile = CreateFile(szParsePath,
                                             GENERIC_READ,
                                             FILE_SHARE_READ,
                                             NULL,
                                             OPEN_EXISTING,
                                             0,
                                             NULL);
                    if (hFile != INVALID_HANDLE_VALUE)
                    {
                        CloseHandle(hFile);
                    }
                    else
                    {
                        dwError = GetLastError();
                        DeleteShadow(hShadowDB, hDir, hShadow);
                        goto bailout;
                    }
#endif
                }
            }
            else
            {
                // check if we were just supposed to report the status
                // of a connected share which is not in the database
                if (!(fWasFirst && done))
                {
                    dwError = ERROR_FILE_NOT_FOUND;
                }
                else if (lpSI->uStatus & SHARE_CONNECTED)
                {
                    fRet = TRUE;
                }
                goto bailout;
            }

            lpSI->hDir = hDir;
            lpSI->hShadow = hShadow;
            lpSI->uStatus = SHADOW_SPARSE;
            lpSI->ulHintPri = 0;
        }

        if (lpszNext)
        {
            RestorePath(lpszNext);

            lpszCurrent = lpszNext+1;
        }
        else
        {
            Assert(done);
        }

    } while (hShadow && !done);

    fRet = TRUE;

    if (lpfCreated)
    {
        *lpfCreated = fInCreateMode;
    }

bailout:

    if (fDisabledShadowing)
    {
        EnableShadowingForThisThread(hShadowDB);
    }

    CloseShadowDatabaseIO(hShadowDB);

    if (!fRet)
    {
        SetLastError(dwError);
    }

    return fRet;
}


BOOL
IsShareReallyConnected(
    LPCTSTR  lpszShareName
    )
{
    WIN32_FIND_DATA sFind32;
    HSHADOW hShadow;
    ULONG   uStatus;

    memset(&sFind32, 0, sizeof(sFind32));

    lstrcpyn(sFind32.cFileName, lpszShareName, MAX_PATH-1);

    if (GetShadow(INVALID_HANDLE_VALUE, 0, &hShadow, &sFind32, &uStatus))
    {
        if ((uStatus & SHARE_CONNECTED) && !(uStatus & SHARE_SHADOWNP))
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL
AnyActiveNets(
    BOOL *lpfSlowLink
    )
{
    BOOL fOffline;

    if(IsServerOfflineW(INVALID_HANDLE_VALUE, NULL, &fOffline)) {
        // DbgPrint("AnyActiveNets returning %d\n", fOffline);
        return fOffline;
    }
    // DbgPrint("AnyActiveNets: IsServerOffline errored out!!\n");
    return FALSE;
}

BOOL
GetWideStringFromRegistryString(
    IN  LPSTR   lpszKeyName,
    IN  LPSTR   lpszParameter,  // value name
    OUT LPWSTR  *lplpwzList,    // wide character string
    OUT LPDWORD lpdwLength      // length in bytes
    )

/*++

Routine Description:

    reads a registry string and converts it to widechar

Arguments:

    lpszParameter       - registry parameter

    lplpwzList          - wide character string

    lpdwLength          - size of the widechar string

Return Value:

    DWORD
        Success - TRUE

        Failure - FALSE, GetLastError() returns the actual error

--*/

{
    HKEY    hKey = NULL;
    DWORD   dwData=1;
    DWORD   dwLen = 0;
    LPSTR   lpszString = NULL;
    BOOL    fRet = FALSE;

    *lplpwzList = NULL;
    *lpdwLength = 0;

    ReintKdPrint(INIT, ("Opening key\r\n"));
    if (RegCreateKeyExA(HKEY_LOCAL_MACHINE,
                    (lpszKeyName)?lpszKeyName:REG_KEY_CSC_SETTINGS_A,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_READ,
                    NULL,
                    &hKey,
                    &dwData) == ERROR_SUCCESS)
    {
        ReintKdPrint(INIT, ("getting size for value %s\r\n", lpszParameter));

        if(RegQueryValueExA(hKey, lpszParameter, NULL, NULL, NULL, &dwLen)==
           ERROR_SUCCESS)
        {
            lpszString = (LPSTR)LocalAlloc(LPTR, dwLen+1);

            if (lpszString)
            {
                dwData = dwLen+1;

                ReintKdPrint(INIT, ("getting value %s\r\n", lpszParameter));
                if(RegQueryValueExA(hKey, lpszParameter, NULL, NULL, lpszString, &dwData)
                    ==ERROR_SUCCESS)
                {
                    ReintKdPrint(INIT, ("value for %s is %s\r\n", lpszParameter, lpszString));

                    *lplpwzList = LocalAlloc(LPTR, *lpdwLength = dwData * sizeof(WCHAR));

                    if (*lplpwzList)
                    {
                        if (MultiByteToWideChar(CP_ACP, 0, lpszString, dwLen, *lplpwzList, *lpdwLength))
                        {
                            fRet = TRUE;
                            ReintKdPrint(INIT, ("Unicode value for %s is %ls\r\n", lpszParameter, *lplpwzList));
                        }

                    }
                }

            }
        }
    }

    if (lpszString)
    {
        LocalFree(lpszString);
    }

    if(hKey)
    {
        RegCloseKey(hKey);
    }

    if (!fRet)
    {
        if (*lplpwzList)
        {
            LocalFree(*lplpwzList);
            *lplpwzList = NULL;
        }
    }

    return fRet;
}


LPTSTR
GetTempFileForCSC(
    LPTSTR  lpszBuff
)
/*++

Routine Description:

    Generates a temporary filename prototype.  Checks %temp%, %tmp% and then
    %userprofiles%.  The temp directory has to be local.

Arguments:

    lpszBuff    If NULL, the routine will allocate space for returning the path
                If non-NULL this must be big enough to fit MAX_PATH characters

Returns:

    returns NULL if failed
    returns pointer to the buffer containing the path to use.
            If lpszBuff was non-NULL, the return value is the same as lpszBuff



Notes:

--*/
{
    LPTSTR TempName = NULL;
    DWORD nRet = 0;
    ULONG i;
    WCHAR TmpPath[MAX_PATH];
    WCHAR TmpPrefix[32];
    WCHAR Drive[4] = L"X:\\";
    BOOLEAN GotOne = FALSE;

    // check if caller wants us to allocate
    if (lpszBuff) {
        TempName = lpszBuff;
    } else {
        // caller must free
        TempName = LocalAlloc(LPTR, MAX_PATH * sizeof(TCHAR));
        if (TempName == NULL)
            return NULL;
    }

    wsprintf(TmpPrefix, L"%ws%x", vszPrefix, (GetCurrentThreadId() & 0xff));

    //
    // Find the temp directory
    //
    for (i = 0; TempDirs[i] != NULL && GotOne == FALSE; i++) {
        // DbgPrint("Trying %ws\n", TempDirs[i]);
        nRet = GetEnvironmentVariable(TempDirs[i], TmpPath, MAX_PATH);
        if (nRet >= 4 && nRet <= MAX_PATH) {
            // DbgPrint("%ws=%ws\n", TempDirs[i], TmpPath);
            Drive[0] = TmpPath[0];
            if (
                TmpPath[1] == L':'
                    &&
                TmpPath[2] == L'\\'
                    &&
                GetDriveType(Drive) == DRIVE_FIXED
            ) {
                if (GetTempFileName(TmpPath, TmpPrefix, 0, TempName)) {
                    // DbgPrint("CSC TempName=%ws\n", TempName);
                    GotOne = TRUE;
                }
            }
        }
    }

    if (GotOne == FALSE) {
        // Cleanup if we failed
        LocalFree(TempName);
        TempName = NULL;
    } else {
        // Delete file on success, as it might be encrypted
        DeleteFile(TempName);
    }

    return TempName;
}

BOOL
GetCSCFixedDisk(
    TCHAR   *lptzDrive
    )
/*++

Routine Description:

    Looks for a fixed disk drive.

Arguments:

    lptzDrive   retruns drive letter if successful.

Returns:

    TRUE if successful, FALSE if no fixed disk is found

Notes:


    OBSOLETE uses a hacky way of finding out the fixed disk. RemoteBoot lies to us and tells us that
    c: is a fixed disk.


--*/
{
    int i;
    WIN32_FIND_DATA sFind32;

    if (GetShadowDatabaseLocation(INVALID_HANDLE_VALUE, &sFind32))
    {
        if (sFind32.cFileName[1] == _TEXT(':'))
        {
            lptzDrive[0] = sFind32.cFileName[0];
            lptzDrive[1] = sFind32.cFileName[1];
            lptzDrive[2] = sFind32.cFileName[2];
            lptzDrive[3] = 0;
            return TRUE;
        }
        else
        {
            lptzDrive[0] = _TEXT('d');
        }
        lptzDrive[1] = _TEXT(':');lptzDrive[2] = _TEXT('\\');lptzDrive[3] = 0;

        for (i=0; i<24; ++i)
        {
            if(GetDriveType(lptzDrive) == DRIVE_FIXED)
            {
                return TRUE;
            }
            lptzDrive[0]++;
        }
    }

    return FALSE;
}


BOOL
SetRegValueDWORDA(
    IN  HKEY    hKey,
    IN  LPCSTR  lpSubKey,
    IN  LPCSTR  lpValueName,
    IN  DWORD   dwValue
    )
/*++

Routine Description:

    Helper regsistry routine

Arguments:

Returns:

    TRUE if successful. If FALSE, GetLastError() gives the actual error code

Notes:

--*/
{
    HKEY    hSubKey = 0;
    DWORD   dwType;
    BOOL    fRet = FALSE;

    if(RegOpenKeyA(hKey, lpSubKey, &hSubKey) ==  ERROR_SUCCESS)
    {
        if (RegSetValueExA(hSubKey, lpValueName, 0, REG_DWORD, (PBYTE)&dwValue, sizeof(DWORD))
             == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }
        RegCloseKey(hSubKey);
    }
    return fRet;
}

BOOL
QueryRegValueDWORDA(
    IN  HKEY    hKey,
    IN  LPCSTR  lpSubKey,
    IN  LPCSTR  lpValueName,
    OUT LPDWORD lpdwValue
    )
/*++

Routine Description:

    Helper regsistry routine

Arguments:

Returns:

    TRUE if successful. If FALSE, GetLastError() gives the actual error code

Notes:

--*/
{

    HKEY    hSubKey;
    DWORD   dwType, dwSize;
    BOOL    fRet = FALSE;
    
    if(RegOpenKeyA(hKey, lpSubKey, &hSubKey) ==  ERROR_SUCCESS)
    {
        dwSize = sizeof(DWORD);

        if (RegQueryValueExA(hSubKey, lpValueName, 0, &dwType, (PBYTE)lpdwValue, &dwSize)
             == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }

        RegCloseKey(hSubKey);
    }
    return fRet;
}

BOOL
DeleteRegValueA(
    IN  HKEY    hKey,
    IN  LPCSTR  lpSubKey,
    IN  LPCSTR  lpValueName
    )
/*++

Routine Description:

    Helper regsistry routine

Arguments:

Returns:

    TRUE if successful. If FALSE, GetLastError() gives the actual error code

Notes:

--*/
{
    HKEY    hSubKey;
    BOOL    fRet = FALSE;
    
    if(RegOpenKeyA(hKey, lpSubKey, &hSubKey) ==  ERROR_SUCCESS)
    {
        if(RegDeleteValueA(hSubKey, lpValueName) == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }

        RegCloseKey(hSubKey);
    }

    return fRet;

}

BOOL
QueryFormatDatabase(
    VOID
    )
/*++

Routine Description:

    Helper regsistry routine

Arguments:

Returns:

    TRUE if successful. If FALSE, GetLastError() gives the actual error code

Notes:

--*/
{
    DWORD dwSize, dwTemp=0;
    HKEY hKey = NULL;
    BOOL    fFormat = FALSE;

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                    REG_STRING_NETCACHE_KEY,
                    0,
                    KEY_READ | KEY_WRITE,
                    &hKey
                    ) == ERROR_SUCCESS)
    {

        dwSize = sizeof(dwTemp);
        dwTemp = 0;

        if (RegQueryValueEx(hKey, REG_VALUE_FORMAT_DATABASE, NULL, NULL, (void *)&dwTemp, &dwSize) == ERROR_SUCCESS)
        {
            if(RegDeleteValue(hKey, REG_VALUE_FORMAT_DATABASE) != ERROR_SUCCESS)
            {
                // deliberte print to catch it in free builds as well
                OutputDebugStringA("Not Formatting.. Failed to delete  REG_VALUE_FORMAT_DATABASE_A \n");
            }
            else
            {
                fFormat = TRUE;
            }

        }
        RegCloseKey(hKey);
        hKey = NULL;
    }
    else
    {
        hKey = NULL;
    }


    if(hKey)
    {
        RegCloseKey(hKey);
    }
    return fFormat;
}


BOOL
InitValues(
    LPSTR   lpszDBDir,
    DWORD   cbDBDirSize,
    LPDWORD lpdwDBCapacity,
    LPDWORD lpdwClusterSize
    )
/*++

Routine Description:

    Returns init values to init CSC database and enable CSC

Arguments:

Returns:

    TRUE if successful. If FALSE, GetLastError() gives the actual error code

Notes:

--*/
 {
    HKEY hKeyShadow;
    int iSize;
    DWORD dwType;
    UINT lenDir;
    BOOL    fInitedDir = FALSE, fInitedSize=FALSE;
    unsigned uPercent;


    if(RegOpenKeyA(HKEY_LOCAL_MACHINE, REG_STRING_NETCACHE_KEY_A, &hKeyShadow) ==  ERROR_SUCCESS)
    {
        iSize = (int)cbDBDirSize;

        if(RegQueryValueExA(hKeyShadow, REG_STRING_DATABASE_LOCATION_A, NULL, &dwType, lpszDBDir, &iSize)==ERROR_SUCCESS)
        {
            if ((iSize+SUBDIR_STRING_LENGTH+2)<MAX_PATH)
            {
                iSize = sizeof(DWORD);

                fInitedDir = TRUE;

                if(RegQueryValueExA(hKeyShadow, REG_VALUE_DATABASE_SIZE_A, NULL, &dwType, (LPBYTE)&uPercent, &iSize)==ERROR_SUCCESS)
                {
                    if ((uPercent <= 100) &&
                        GetDiskSizeFromPercentage(lpszDBDir, uPercent, lpdwDBCapacity, lpdwClusterSize))
                    {
                        fInitedSize = TRUE;
                    }
                }

            }

        }

        RegCloseKey(hKeyShadow);
    }

    if (!fInitedDir)
    {
        // try the default

        if(!(lenDir=GetWindowsDirectoryA(lpszDBDir, cbDBDirSize)))
        {
            DEBUG_PRINT(("InitValuse: GetWindowsDirectory failed, error=%x \r\n", GetLastError()));
            Assert(FALSE);
            return FALSE;
        }
        else
        {
            if ((lenDir+SUBDIR_STRING_LENGTH+2)>=MAX_PATH)
            {
                DEBUG_PRINT(("InbCreateDir: Windows dir name too big\r\n"));
                Assert(FALSE);

                // if even the default fails do the worst case thing.
                // this may also not be good enough as apparently in Japan
                // c: is not mandatory

                return FALSE;
            }
            else
            {
                if (lpszDBDir[lenDir-1]!='\\')
                {
                    lpszDBDir[lenDir++] = '\\';
                    lpszDBDir[lenDir] = 0;
                }

                lstrcatA(lpszDBDir, vszCSCDirName);
            }

        }
    }

    Assert(lpszDBDir[1]==':');

    if (!fInitedSize)
    {
        if(!GetDiskSizeFromPercentage(lpszDBDir, DEFAULT_CACHE_PERCENTAGE, lpdwDBCapacity, lpdwClusterSize))
        {
            return FALSE;
        }

    }

//    DEBUG_PRINT(("InitValues: CSCDb at %s Size = %d \r\n", lpszDBDir, *lpdwDBCapacity));
    return TRUE;
}

BOOL
GetDiskSizeFromPercentage(
    LPSTR   lpszDir,
    unsigned    uPercent,
    DWORD       *lpdwSize,
    DWORD       *lpdwClusterSize
    )
{
    char szDrive[4];
    DWORD dwSPC, dwBPS, dwFreeC, dwTotalC;
    ULONGLONG   ullSize = 0;

    *lpdwSize = 0;

    memset(szDrive, 0, sizeof(szDrive));
    memcpy(szDrive, lpszDir, 3);

    if(!GetDiskFreeSpaceA(szDrive, &dwSPC, &dwBPS, &dwFreeC, &dwTotalC )){
        return FALSE;
    }
    else
    {
//        DEBUG_PRINT(("dwSPC=%d dwBPS=%d uPercent=%d dwTotalC=%d \r\n",
//                     dwSPC, dwBPS, uPercent, dwTotalC));

        ullSize = (((ULONGLONG)dwSPC * dwBPS * uPercent)/100)*dwTotalC;
        
        // our max limit is 2GB
        if (ullSize > 0x7fffffff)
        {
            *lpdwSize = 0x7fffffff;                        
        }
        else
        {
            *lpdwSize = (DWORD)ullSize;
        }
        *lpdwClusterSize = dwBPS * dwSPC;
    }
    return (TRUE);
}

#ifdef MAYBE_USEFULE
typedef struct tagCSC_NAME_CACHE_ENTRY
{
    DWORD   dwFlags;
    DWORD   dwTick;
    HSHADOW hDir;
    DWORD   dwSize;
    TCHAR  *lptzName;
}
CSC_NAME_CACHE_ENTRY, *LPCSC_NAME_CACHE_ENTRY;

CSC_NAME_CACHE_ENTRY rgCSCNameCache[16];

HANDLE vhNameCacheMutex;

#define CSC_NAME_CACHE_EXPIRY_DELTA 1000*10 // 10 seconds

BOOL
FindCreateCSCNameCacheEntry(
    LPTSTR  lptzName,
    DWORD   dwSize,
    HSHADOW *lphDir,
    BOOL    fCreate
    );

BOOL
FindCreateShadowFromPathEx(
    LPCTSTR                lpszFile,
    BOOL                fCreate,    // create if necessary
    LPWIN32_FIND_DATA   lpFind32,
    LPSHADOWINFO        lpSI,
    BOOL                *lpfCreated
    )
{
    BOOL fRet = FALSE, fIsShare, fFoundInCache = FALSE;
    TCHAR   *lpT;
    DWORD   cbSize;

    lpT = GetLeafPtr((LPTSTR)lpszFile);
    if (fIsShare = ((DWORD_PTR)lpT == (DWORD_PTR)lpszFile))
    {
        cbSize = lstrlen(lpT) * sizeof(_TCHAR);
    }
    else
    {
        cbSize = (DWORD_PTR)lpT - (DWORD_PTR)lpszFile - sizeof(_TCHAR);
    }

    if (!fIsShare)
    {
        if (!fCreate)
        {
            HSHADOW hDir;
            // just look it up first
            if (FindCreateCSCNameCacheEntry((LPTSTR)lpszFile, cbSize, &hDir, FALSE))
            {
                if (hDir != 0xffffffff)
                {
                    // found it
                    if (lpfCreated)
                    {
                        *lpfCreated = FALSE;
                    }
                    lstrcpy(lpFind32->cFileName, lpT);
                    lpFind32->cAlternateFileName[0] = 0;
                    fRet = GetShadowEx(INVALID_HANDLE_VALUE, hDir, lpFind32, lpSI);
                }
                else
                {
                    DbgPrint("Found negative cache entry %ls \n", lpszFile);
                }
                fFoundInCache = TRUE;
            }
        }

    }

    if (!fFoundInCache)
    {
        // not found, do the normal thing
        fRet = FindCreateShadowFromPath((LPTSTR)lpszFile, fCreate, lpFind32, lpSI, lpfCreated);

        if (!fRet)
        {
            lpSI->hDir = lpSI->hShadow = 0xffffffff;            
        }

        if (fRet || (GetLastError() == ERROR_FILE_NOT_FOUND))
        {
            FindCreateCSCNameCacheEntry((LPTSTR)lpszFile, cbSize, (lpSI->hDir)?&lpSI->hDir:&lpSI->hShadow, TRUE);
        }

    }
    return fRet;
}

BOOL
FindCreateCSCNameCacheEntry(
    LPTSTR  lptzName,
    DWORD   dwSize,
    HSHADOW *lphDir,
    BOOL    fCreate
    )
{
    int i, indx=-1;
    DWORD   dwTick = GetTickCount();
    BOOL    fRet = FALSE;

    if (!vhNameCacheMutex)
    {
        return FALSE;        
    }

    WaitForSingleObject(vhNameCacheMutex, INFINITE);
    
    for (i=0; i<(sizeof(rgCSCNameCache)/sizeof(CSC_NAME_CACHE_ENTRY)); ++i)
    {
        if (!rgCSCNameCache[i].dwSize)
        {
            if (indx == -1)
            {
                indx = i;
            }
        }
        else if ((rgCSCNameCache[i].dwSize == dwSize ))
        {
            //non-zero size must mean a string has been allocated
            Assert(rgCSCNameCache[i].lptzName);

            if ((dwTick < rgCSCNameCache[i].dwTick)||
                ((dwTick > (rgCSCNameCache[i].dwTick+CSC_NAME_CACHE_EXPIRY_DELTA))))
            {
                DbgPrint("%ls expired\n", rgCSCNameCache[i].lptzName);
                // the entry has expired, nuke it
                rgCSCNameCache[i].dwSize = 0;
                FreeMem(rgCSCNameCache[i].lptzName);
                rgCSCNameCache[i].lptzName = NULL;
                continue;
            }

            // do a caseinsensitve comparison
            if ((CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, 
                                            lptzName, dwSize/sizeof(_TCHAR),
                                            rgCSCNameCache[i].lptzName,dwSize/sizeof(_TCHAR))
                                            == CSTR_EQUAL))
            {
                // match found
                DbgPrint("Match Found %ls\n", rgCSCNameCache[i].lptzName);
                if (fCreate)
                {
                    rgCSCNameCache[i].hDir = *lphDir;
                    // update the tick count
                    rgCSCNameCache[i].dwTick = dwTick;
                }
                else
                {
                    // we want to find it, return the directory
                    *lphDir = rgCSCNameCache[i].hDir;
                }
                fRet = TRUE;
                break;
            }
        }
    }

    // didn't find it, we are supposed to create and there is an empty slot
    if (!fRet && fCreate && (indx >= 0) )
    {
        rgCSCNameCache[indx].lptzName = AllocMem(dwSize+sizeof(_TCHAR));
        if (rgCSCNameCache[indx].lptzName)
        {
            memcpy(rgCSCNameCache[indx].lptzName, lptzName, dwSize);
            rgCSCNameCache[indx].dwSize = dwSize;
            rgCSCNameCache[indx].dwTick = dwTick;
            rgCSCNameCache[indx].hDir = *lphDir;
            fRet = TRUE;
            DbgPrint("Inserted %ls\n", rgCSCNameCache[indx].lptzName);
        }
    }
    
    ReleaseMutex(vhNameCacheMutex);

    return fRet;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\ui.c ===
/*

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ui.c

Abstract:

    This file contains the mainloop for the Client Side Caching agent. The code has to mesh
    with the system startup, logon and logoff and these are different on NT and win9x.
    This file and all others in the reint directory have been written such that for NT they
    call the wide character win32 APIs while for win9x they call ANSI APIs.

    The agent runs as a thread in the context of winlogon.exe. CSCDLL.DLL resgisters itself
    to recieve a call from winlogon when a user logs on. The call is on a separate thread and
    is impersonated as the logged on user. This thread eventually calls reint_winmain which
    loops for ever, till the system is about to shutdown.

    file ntstuff.c contains the interface which is exposed to winlogon. On every logon
    this interface gets called, at which point, all the info necessary to impersonate the
    logged on user is obtained and kept in an in memory list of logged on users. The list
    also contains the SID for Local System.

    For doing sparse filling and Inode, the agent looks in the database to see which of
    the users on the list have read access right for the given file and uses that to fill
    the file.


Author(s):

    Trent Gray Donald/Felix Andrews/Shishir Pardikar

    1-9-1994

Environment:

    Win32 (user-mode) DLL

Revision History:

    NT source formatting
        
        Shishir Pardikar 2-19-97
    
    Winlogon Integration
    
        Shishir Pardikar 10-19-97

    

--*/

#include "pch.h"
#pragma hdrstop

#include "resource.h"
#include "traynoti.h"
#include <dbt.h>
#include "lib3.h"
#include "reint.h"
#include "utils.h"
#include "strings.h"
#include "cscuiext.h"
#include <userenv.h>
#include <safeboot.h>

//
// defines/macros useed in this file
//


#if (_TCHAR != wchar_t)
#error "Bad _TCHAR definition"
#endif

#if (_TEXT != L)
#error "BAD _Text definiton"
#endif

// Timer to deal with double clicks and stuff like that.
#define TRAY_ID 100

// timer ID to make sure the Tray icon appears!
#define TIMER_ADD_TRAY 101

#define minOfFour(one,two,three,four) (min(min(one,two),min(three,four)))

#define    FILE_OPEN_THRESHOLD    16
#define     CI_LOGON    1
#define     CI_LOGOFF   2
// #define     STWM_CSCCLOSEDIALOGS            (WM_USER + 212)

typedef HWND (WINAPI *CSCUIINITIALIZE)(HANDLE hToken, DWORD    dwFlags);
typedef LRESULT (WINAPI *CSCUISETSTATE)(UINT uMsg, WPARAM wParam, LPARAM lParam);

#define    REG_VALUE_NT_BUILD_NUMBER        _TEXT("NTBuildNumber")
#define    REG_VALUE_DISABLE_AUTOCHECK      _TEXT("DisableAutoCheck")
#define    REG_KEY_NETCACHE_SETTINGS        _TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\NetCache")

#define     AGENT_ALIVE                 (vfCSCEnabled && !vfStopRecieved)
#define     AGENT_ALIVE_AND_ACTIVE      (AGENT_ALIVE && !vfAgentQuiet)
#define     AGENT_ALIVE_AND_HAVE_NET    (AGENT_ALIVE && vcntNetDevices)
#define     FIVE_MINUTES    (5 * 1000 * 60)


#define MAX_LIST_SIZE   1024

#define PI_LITELOAD     0x00000004      // Lite load of the profile (for system use only)

//
// Data declarations/definitions
//


#pragma data_seg(DATASEG_READONLY)

_TCHAR vszKernel32[] = _TEXT("KERNEL32.DLL");
_TCHAR vszOpenVxDHandle[]=_TEXT("OpenVxDHandle");

static const _TCHAR szWkssvcToAgentStartEvent[] = _T("WkssvcToAgentStartEvent");
static const _TCHAR szWkssvcToAgentStopEvent[] = _T("WkssvcToAgentStopEvent");
static const _TCHAR szAgentToWkssvcEvent[] = _T("AgentToWkssvcEvent");
static const _TCHAR szAgentExistsEvent[] = _T("AgentExistsEvent");

static const _TCHAR vtzCSCUI[] = _TEXT("cscui.dll");
static const char vszCSCUIInitialize[] = "CSCUIInitialize";
static const char vszCSCUISetState[] = "CSCUISetState";
static const _TCHAR vtzDefaultExclusionList[] = L" *.SLM *.MDB *.LDB *.MDW *.MDE *.PST *.DB?";

DWORD vdwManualFileDetectionCount = 0;

#pragma data_seg()

#pragma data_seg(DATASEG_PERINSTANCE)

static _TCHAR vrgchBuff[1024], vrwBuff[4096], vrgchSrcName[350], vrgchDstName[300];
static HMENU g_MainMenu;
char    vszDBDir[MAX_PATH]={0};
DWORD   vdwDBCapacity = 0, vdwClusterSize = 0;
DWORD   vdwRedirStartTime = 0;
AssertData;
AssertError;

#pragma  data_seg()

HWND    vhwndMain = NULL;            // main window

BOOL vfAgentEnabledCSC=FALSE;   // this is used to detect whether the remoteboot enabled CSC
BOOL vfCSCEnabled=FALSE;        // csc is enabled
BOOL vfOKToEnableCSC = FALSE;
HANDLE vhProfile = NULL;
#pragma data_seg()

BOOL    vfFormatDatabase = FALSE;   // set at init time

#ifdef DEBUG
ULONG ReintKdPrintVector = REINT_KDP_GOOD_DEFAULT;
ULONG ReintKdPrintVectorDef = REINT_KDP_GOOD_DEFAULT;
#endif

unsigned ulFreePercent=30;       // Amount of % cache freeing to be attempted
                                 // if the cache is full

UINT vcntNetDevices = 0;        // count of net devices
BOOL g_bShowMergeIcon;          // menu icon
BOOL vfAgentRegistered = FALSE;
BOOL vfClassRegistered = TRUE;
BOOL vfMerging = FALSE;

BOOL    vfAgentQuiet = FALSE;
DWORD   vdwAgentThreadId = 0;
DWORD   vdwAgentSessionId = 0xffff;
GLOBALSTATUS vsGS;
BOOL    allowAttempt;                    // set if we want to allow AttemptCacheFill now

//
// event handles of named events shared between usermode and kernel mode
//
HANDLE      heventPerSess = NULL;
HANDLE      heventSharedFill = NULL;
HANDLE      vhMutex = NULL;
DWORD       dwVxDEvent = 0;    // handle for VxD event obtained from heventShared
HANDLE      vhShadowDBForEvent = INVALID_HANDLE_VALUE;

extern     LPCONNECTINFO  vlpLogonConnectList;
extern     _TCHAR * vrgchCRLF;
HWND     vhdlgShdLogon=NULL;

// net start-stop vars
HANDLE  heventWkssvcToAgentStart = NULL;// event set by Workstation service on redir start
HANDLE  heventWkssvcToAgentStop = NULL; // event set by Workstation service on redir stop
HANDLE  heventAgentToWkssvc = NULL;     // event used by agent to respond to wkssvc to tell it that
                                        // it is OK to stop the redir
HANDLE  heventShutDownAgent = NULL;
HANDLE  heventShutDownThread = NULL;
HANDLE  hCopyChunkThread = NULL;
DWORD   vdwCopyChunkThreadId = 0;
BOOL    vfRedirStarted  = -1;

BOOL    vfStartRecieved = FALSE;
BOOL    vfStopRecieved = FALSE;

BOOL    fAgentShutDownRequested = FALSE;
BOOL    fAgentShutDown = FALSE;


// CSCUI related

HANDLE  vhlibCSCUI = NULL;
CSCUIINITIALIZE vlpfnCSCUIInitialize = NULL;
CSCUISETSTATE   vlpfnCSCUISetState = NULL;
BOOL    vfShowingOfflineDlg = FALSE;
ULONG   uOldDatabaseErrorFlags = 0;


//
// Function Prototypes
//




LRESULT
CALLBACK
ReInt_WndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

DWORD ReInt_AttemptCacheFill(
    LPVOID  lpContext
    );

BOOL
ReInt_RefreshTray(
    BOOL bHide
    );

BOOL
ReInt_AnythingToMerge(
    VOID
    );

int InitMaint(
    VOID
    );  // Initialize the maintenance subsystem

BOOL
CheckCSCDatabaseVersion(
    BOOL    *lpfWasDirty
);

BOOL
UpgradeCSCDatabase(
    LPSTR   lpszDir
);

BOOL
IsNetConnected(
    VOID
    );

int
ExtractSpaceStats(
    IN GLOBALSTATUS     *lpsGS,
    OUT unsigned long   *lpulMaxSpace,
    OUT unsigned long   *lpulCurSpace,
    OUT unsigned long   *lpulFreeSpace
    );

int
InitCacheSize(
    VOID
    );

int
SetDefaultSpace(
    LPSTR lpShadowDir
    );

BOOL
NEAR
PASCAL
ReInt_InitApp(
    HANDLE hInstance
    );

BOOL
NEAR
PASCAL
ReInt_InitInstance(
    HANDLE hInstance,
    HANDLE hPrevInstance,
    int cmdShow);

BOOL
NEAR
PASCAL
ReInt_TermInstance(
    VOID
    );

int
DoEventProcessing(
    VOID
);

BOOL
FindCreateDBDir(
    BOOL    *lpfCreated,
    BOOL    fCleanup    // empty the directory if found
    );

BOOL
CreatePerSessSyncObjects(
    VOID
    );

BOOL
CreateSharedFillSyncObjects(
    VOID
    );

BOOL
EnableCSC(
    VOID
    );
BOOL
DisableCSC(
    VOID
    );
BOOL
IsCSCOn(
    VOID
    );

VOID
ProcessStartStopAgent(
    VOID
    );

BOOL
FStartAgent(
    VOID
    );

int
StartStopCheck(
    VOID
    );

BOOL
Reint_RegisterAgent(
    VOID
    );

VOID
Reint_UnregisterAgent(
    VOID
    );

BOOL
QueryEnableCSC(
    VOID
    );

VOID
QueryMiscRegistryValues(
    VOID
    );


BOOL
CreateStartStopEvents(
    VOID
    );

VOID
DestroyStartStopEvents(
    VOID
    );


BOOL
ProcessNetArrivalMessage(
    VOID
    );

BOOL
ProcessNetDepartureMessage(
    BOOL    fInvokeAutoDial
    );

BOOL
WINAPI
CheckCSC(
    LPSTR,
    BOOL
    );

BOOL
ReportShareNetArrivalDeparture(
    BOOL    fOneServer,
    HSHARE hShare,
    BOOL    fInvokeAutoDial,
    BOOL    fArrival
    );

LRESULT
ReportEventsToSystray(
    DWORD   dwMessage,
    WPARAM  dwWParam,
    LPARAM  dwLParam
    );

BOOL
CheckServerOnline(
    VOID
    );

VOID
SetAgentShutDown(
    VOID
    );


BOOL
IsAgentShutDownRequested(
    VOID
    );

BOOL
LaunchSystrayForLoggedonUser(
    VOID
    );

BOOL
ImpersonateALoggedOnUser(
    VOID
    );

VOID
ReportCreateDelete(
    HSHADOW hDir,
    HSHADOW hShadow,
    BOOL    fCreated
    );

BOOL
GetNameOfServerGoingOfflineEx(
    HANDLE  hShadowDB,
    _TCHAR  **lplptzServerName,
    DWORD   *lpdwSize,
    BOOL    *lpfAllocated
    );

BOOL
AreAnyServersOffline(
    VOID);

BOOL
IsPersonal(
    VOID);

BOOL
IsMultipleUsersEnabled(
    void);

//
// Functions
//

int
PASCAL
ReInt_WinMain(
    HANDLE hInstance,
    HANDLE hPrevInstance,
    LPSTR lpszCommandLine,
    int cmdShow)
/*++
Routine Description:
    This is the mainloop for the agent processing. It "schedules" different agent activities
    based on either an event set by the rdr or by predefined time intervals for these
    activities. The activities include

    a) Filling partially filled files
    b) checking for stale files
    c) maintaining space within limits
    d) reducing reference priority of all files for every FILE_OPEN_THRESHOLD fileopens
--*/
{
    MSG     msg;
    DWORD   result;                   // result from Wait...
    BOOL    done = FALSE;             // to detect a quit message.
    BOOL    staleInited = FALSE;      // ensure that Staleness code runs
    DWORD   timeToWait;
    DWORD   nextGlobalStatusTime;
    DWORD   newTick;
    DWORD   nextSkipPurgeTime;        // to figure out if we should perform an action.
    HANDLE  hT[4];

    if (hPrevInstance) {
        return FALSE;
    }


    vdwAgentThreadId = GetCurrentThreadId();

    ReintKdPrint(MAINLOOP, ("Agent(1):----------ReInt_WinMain----------\n"));

    if (ReInt_InitApp(hInstance) && ReInt_InitInstance(hInstance, hPrevInstance, cmdShow)) {
        if (!AnyActiveNets(NULL))
            vcntNetDevices = 1;
        newTick = GetTickCount();
        nextGlobalStatusTime = newTick + WAIT_INTERVAL_GLOBALSTATUS_MS;
        nextSkipPurgeTime = newTick + WAIT_INTERVAL_SKIP_MS;
        hT[0] = heventPerSess;
        hT[1] = heventWkssvcToAgentStart;
        hT[2] = heventWkssvcToAgentStop;
        hT[3] = heventShutDownAgent;
        StartStopCheck();
        ProcessStartStopAgent();
        while (!done) {
            timeToWait = INFINITE;
            ReintKdPrint(MAINLOOP, ("Agent(1): Wait INFINITE\n"));
            result = WaitForMultipleObjects(4, hT, FALSE, timeToWait);
            newTick=GetTickCount();
            if ((result == WAIT_OBJECT_0) || (result == (WAIT_OBJECT_0+4))) {
                ReintKdPrint(MAINLOOP, ("Agent(1):Event %d was fired or ReadGlobalStatus set\n",
                                            result));
                DoEventProcessing();
                // During event processing, we also do globalstatus check and
                // any other maintenance tasks. So let us restart the timer for
                // globalstatus
                nextGlobalStatusTime = newTick + WAIT_INTERVAL_GLOBALSTATUS_MS;
            } else if ((result == (WAIT_OBJECT_0+1)) || (result  == (WAIT_OBJECT_0+2))) {
                ReintKdPrint(MAINLOOP, ("Agent(1): Received startstop \r\n"));
                vfStartRecieved = (result == (WAIT_OBJECT_0+1));
                vfStopRecieved = (result  == (WAIT_OBJECT_0+2));
                ProcessStartStopAgent();
                continue;
            } else if (result == (WAIT_OBJECT_0+3)) {
                ReintKdPrint(MAINLOOP, ("Agent(1):Agent ShutdownRequested, terminating agent\r\n"));
                SetAgentShutDown();
                goto AllDone;
            }
            // do work only if CSC enabled
            if (vfCSCEnabled && AGENT_ALIVE_AND_ACTIVE) {
                // reset the staleness check time interval
                if(((int)(newTick - nextSkipPurgeTime)) >= 0) {
                    // Unmark failures for servers that are known to be
                    // disconnected and connection has not been attempted on them
                    // for the last WAIT_INTERVAL_SKIP_MS milliseconds
                    PurgeSkipQueue(FALSE, 0, 0, 0);
                    vhcursor = NULL;
                    nextSkipPurgeTime = newTick + WAIT_INTERVAL_SKIP_MS;
                    ReintKdPrint(MAINLOOP, ("Agent(1):nextSkipPurgeTime = %d\n", nextSkipPurgeTime));
                }
                if(((int)(newTick - nextGlobalStatusTime)) >= 0) {
                    nextGlobalStatusTime = newTick + WAIT_INTERVAL_GLOBALSTATUS_MS;
                    ReintKdPrint(MAINLOOP,("Agent(1):nextGlobalStatusTime = %d\n", nextGlobalStatusTime));
                    // We haven't gotten an event for sometime now from the
                    // rdr, so let us go look what is up with him
                    DoEventProcessing();
                    // reset the globalstatus time interval
                    nextGlobalStatusTime = newTick + WAIT_INTERVAL_GLOBALSTATUS_MS;
                }
            }
        }
    }
AllDone:
    // do termination processing
    ReintKdPrint(MAINLOOP, ("Agent(1):Exiting mainloop \r\n"));
    ReInt_TermInstance();
    return 0;
}

BOOL
NEAR
PASCAL
ReInt_InitApp(
    HANDLE hInstance
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

--*/
{
    if (
        CreateSharedFillSyncObjects()
            &&
        CreatePerSessSyncObjects()
    ) {
        if (!CreateStartStopEvents()) {
            ReintKdPrint(BADERRORS, ("Agent:Failed to create Sync events \r\n"));
            return FALSE;
        }
        if (!(hCopyChunkThread = CreateThread(
                                    NULL,
                                    8192,
                                    ReInt_AttemptCacheFill,
                                    NULL,
                                    0,
                                    &vdwCopyChunkThreadId))
        ) {
            ReintKdPrint(BADERRORS, ("Agent:Failed to create copychunk thread\r\n"));
            return FALSE;
        }
        return TRUE;
    } else {
        ReintKdPrint(BADERRORS, ("Failed to Create shared events\n"));
        return FALSE;
    }
}

BOOL
NEAR
PASCAL
ReInt_InitInstance(
    HANDLE hInstance,
    HANDLE hPrevInstance,
    int cmdShow)
/*++

Routine Description:

Parameters:

Return Value:

Notes:

--*/
{
    BOOL    fRet;

    fRet = InitValues(vszDBDir, sizeof(vszDBDir), &vdwDBCapacity, &vdwClusterSize);

    Assert(fRet);

    fAgentShutDown = FALSE;
    fAgentShutDownRequested = FALSE;

    if (!(vfOKToEnableCSC = QueryEnableCSC()))
    {
        ReintKdPrint(INIT, ("cscdll: Registry says disable CSC, not enabling\r\n"));
    }

    vfFormatDatabase = QueryFormatDatabase();

    ReintKdPrint(INIT, ("Format=%d\n", vfFormatDatabase));

    return (TRUE);
}

/*--------------------------------------------------------------------------*/
BOOL
NEAR
PASCAL
ReInt_TermInstance(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

--*/
{

    DisableCSC();

    if (heventPerSess) {
        CloseHandle(heventPerSess);
        heventPerSess = NULL;
    }

    if (heventSharedFill) {
        CloseHandle(heventSharedFill);
        heventSharedFill = NULL;
    }

    PurgeSkipQueue(TRUE, 0, 0, 0);

    if (vhMutex) {
        ReleaseMutex(vhMutex);
        vhMutex = NULL;
    }

    // tell the workstation service that the agent is
    // going away
    if (heventAgentToWkssvc) {
        SetEvent(heventAgentToWkssvc);
    }

    if (heventShutDownThread) {
        DWORD   dwRet;

        Assert(hCopyChunkThread);
        SetEvent(heventShutDownThread);
        dwRet = WaitForSingleObject(hCopyChunkThread, WAIT_INTERVAL_ATTEMPT_MS);
        ReintKdPrint(MAINLOOP, ("wait on thread handle %d \r\n", dwRet));
        CloseHandle(hCopyChunkThread);
    }

    DestroyStartStopEvents();

    if (vfClassRegistered) {
        UnregisterClass(vszReintClass, vhinstCur);
        vfClassRegistered = FALSE;

    }
    return TRUE;
}


DWORD
ReInt_AttemptCacheFill(
    LPVOID  lpParams
    )
/*++
Routine Description:

    A wrapper for AttemptCacheFill. On NT many agent threads can do copychunk
    simultaneously, so there is no need to do mutual exclusion.
--*/
{
    DWORD nextCheckServerOnlineTime;
    DWORD dwWaitResult;
    DWORD dwWaitResult2;
    DWORD dwWaitTime;
    DWORD newTick;
    ULONG nFiles = 0;
    ULONG nYoungFiles = 0;
    HANDLE hT[2];
    DWORD dwManualFileDetectionCount = 0xffff;

    // on NT we run as a winlogon thread which has a very high process priority
    // so we have to get to the lowest
    if(!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_LOWEST)) {
        ReintKdPrint(BADERRORS, ("RE: SetTheadPriority failed, reason: 0x%08x\n", GetLastError()));
    }

    ReintKdPrint(MAINLOOP, ("Agent(2): Launched.\n"));

    hT[0] = heventShutDownThread;
    hT[1] = heventSharedFill;

    nextCheckServerOnlineTime = GetTickCount() +
                                WAIT_INTERVAL_CHECK_SERVER_ONLINE_MS +
                                WAIT_INTERVAL_FILL_THROTTLE_MS;
    for (;;) {
        ReintKdPrint(MAINLOOP, ("Agent(2): nYoungFiles=%d\n", nYoungFiles));
        if (nYoungFiles > 0 || AreAnyServersOffline() == TRUE) {
            dwWaitTime = WAIT_INTERVAL_CHECK_SERVER_ONLINE_MS;
            ReintKdPrint(MAINLOOP, ("Agent(2): Wait 8 min\n"));
        } else {
            dwWaitTime = INFINITE;
            ReintKdPrint(MAINLOOP, ("Agent(2): Wait INFINITE\n"));
        }
        dwWaitResult = WaitForMultipleObjects(2, hT, FALSE, dwWaitTime);
        if (dwWaitResult == (WAIT_OBJECT_0+0)) {  // shutdown event
            ReintKdPrint(MAINLOOP, ("Agent(2): Termination event...\n"));
            if (AGENT_ALIVE && vdwAgentSessionId == 0)
                CSCPurgeUnpinnedFiles(100, &nFiles, &nYoungFiles);
            goto AllDone;
        }
        ReintKdPrint(MAINLOOP, ("Agent(2): Wait 2 min\n"));
        dwWaitResult2 = WaitForSingleObject(heventShutDownThread, WAIT_INTERVAL_FILL_THROTTLE_MS);
        if (dwWaitResult2 == (WAIT_OBJECT_0+0)) {  // shutdown event
            ReintKdPrint(MAINLOOP, ("Agent(2): Termination event...\n"));
            if (AGENT_ALIVE && vdwAgentSessionId == 0)
                CSCPurgeUnpinnedFiles(100, &nFiles, &nYoungFiles);
            goto AllDone;
        }
        if (dwWaitResult == WAIT_TIMEOUT) {  // timeout
            if (AGENT_ALIVE) {
                ReintKdPrint(MAINLOOP, ("Agent(2): Timeout...\n"));
                AttemptCacheFill(0, DO_ONE_OBJECT, FALSE, CSC_INVALID_PRINCIPAL_ID, NULL, 0);
                if (vdwAgentSessionId == 0) {
                    GetManualFileDetectionCounter(INVALID_HANDLE_VALUE,&dwManualFileDetectionCount);
                    vdwManualFileDetectionCount = dwManualFileDetectionCount;
                    CSCPurgeUnpinnedFiles(100, &nFiles, &nYoungFiles);
                }
            }
        } else if (dwWaitResult == (WAIT_OBJECT_0+1)) { // kernel told us to run
            if (AGENT_ALIVE) {
                ReintKdPrint(MAINLOOP, ("Agent(2): Shared Event signal...\n"));
                AttemptCacheFill(0, DO_ONE_OBJECT, FALSE, CSC_INVALID_PRINCIPAL_ID, NULL, 0);
                GetManualFileDetectionCounter(INVALID_HANDLE_VALUE,&dwManualFileDetectionCount);
                if (dwManualFileDetectionCount != vdwManualFileDetectionCount) {
                    vdwManualFileDetectionCount = dwManualFileDetectionCount;
                    CSCPurgeUnpinnedFiles(100, &nFiles, &nYoungFiles);
                }
            }
        }
        newTick = GetTickCount();
        if(((int)(newTick - nextCheckServerOnlineTime)) >= 0) {
            if (AGENT_ALIVE) {
                // check whether one or more shares that are presently in
                // disconnected state have come online.
                // If they are, report them to the UI
                CheckServerOnline();
                nextCheckServerOnlineTime = newTick +
                                            WAIT_INTERVAL_CHECK_SERVER_ONLINE_MS +
                                            WAIT_INTERVAL_FILL_THROTTLE_MS;
            }
        }
    }
AllDone:
    ReintKdPrint(MAINLOOP, ("Agent(2):Thread exit\n"));
    return 0;
}

VOID
ReInt_DoFreeShadowSpace(
    GLOBALSTATUS    *lpsGS,
    int fForce
    )
/*++

Routine Description:
         The function is called from the main
         loop every "n" minutes to see if we are running out of space.
         If so, it tries to free up some percentage of the shadow cache.

Parameters:
   fForce:  0 => do it only if we don't have space and we are
                 on the net
            1 => do it if we are on the net

            2 => just do it


Return Value:

Notes:

--*/
{
    ULONG ulMax;
    ULONG ulCur;
    ULONG ulFree;
    WIN32_FIND_DATA sFind32;
    LPCOPYPARAMS lpCP = NULL;

    if (!lpsGS) {
        lpsGS = &vsGS;
    }

    ReintKdPrint(MERGE, ("ReInt_DoFreeShadowSpace(1)\r\n"));

    // Get space stats
    if (ExtractSpaceStats(lpsGS, &ulMax, &ulCur, &ulFree) >= 0){
        ReintKdPrint(MERGE, ("ReInt_DoFreeShadowSpace(2)\r\n"));
        // do we have space and are not forced to free up?
        if ((fForce < 1) && (ulFree > 0)){
             ReintKdPrint(MERGE, ("ReInt_DoFreeShadowSpace(3)\r\n"));
             return;
        }
        //
        // We are forced or there is no space
        //
        // NB!!!! We check for a net device and if it exists we assume that
        // it is OK to freespace on all shares.
        if ((fForce < 2) && !vcntNetDevices){
            ReintKdPrint(MERGE, ("ReInt_DoFreeShadowSpace: No net, aborting \r\n"));
            return;
        }

        // Maximum force, or all conditions for freeing are being met
        // ie. there is no space and we are on the net
        memset(&sFind32, 0, sizeof(sFind32));

        // NB the math below is done to avoid overflow.
        // The consequence is that the resulting value is less than
        // the percentage of cache space to be freed.
        ulFree = (ulMax/100) * ulFreePercent;

        // if the cached data is more than the earmarked space
        // then add the extra too.
        if (ulCur > ulMax) {
            ulFree += (ulCur - ulMax);
        }
        DosToWin32FileSize(ulFree, &sFind32.nFileSizeHigh, &sFind32.nFileSizeLow);
        ReintKdPrint(MERGE, ("ReInt_DoFreeShadowSpace(): freeing %d\n", ulFree));
        ReintKdPrint(MERGE, ("                nFileSizeLow=%d\n", sFind32.nFileSizeLow));
        FreeShadowSpace(INVALID_HANDLE_VALUE,
                        sFind32.nFileSizeHigh,
                        sFind32.nFileSizeLow,
                        FALSE);  // don't clear all
        ReintKdPrint(MERGE, ("ReInt_DoFreeShadowSpace(): ending.\n"));
    }
}

/*********************** Merging related routines **************************/

//
// DoubleClick/Menu handler.
//
VOID
ReInt_DoNetProp(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

--*/
{
    HINSTANCE hLib=LoadLibrary(_TEXT("shhndl.dll"));
    ReintKdPrint(BADERRORS, ("LoadLibrary of shhndl returned %d\n",hLib));
    if(hLib)
    {
        FARPROC lpFn=GetProcAddress(hLib,"NetProp_Create");
        ReintKdPrint(BADERRORS, ("NetProp_Create is 0x%x\n",lpFn));
        if(lpFn)
            lpFn();
        FreeLibrary(hLib);
    }

}

//
//  Command Handler
//
BOOL
NEAR
PASCAL
ReInt_CommandHandler(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

--*/
{
    unsigned long ulSwitch, ulSav;
    switch (wParam)
    {
        case IDM_PROPERTIES:
            ReInt_DoNetProp();
        break;

        case IDM_SHADOW_LOG:
        {
            if(ShadowSwitches(INVALID_HANDLE_VALUE, &ulSwitch, SHADOW_SWITCH_GET_STATE))
            {
                ulSav = (ulSwitch & SHADOW_SWITCH_LOGGING);
                ulSwitch = SHADOW_SWITCH_LOGGING;
                if (ShadowSwitches(INVALID_HANDLE_VALUE, &ulSwitch, (ulSav)?SHADOW_SWITCH_OFF:SHADOW_SWITCH_ON))
                    CheckMenuItem(GetMenu(hwnd), IDM_SHADOW_LOG , MF_BYCOMMAND|((ulSav)?MF_UNCHECKED:MF_CHECKED));
            }
        }
        break;

        case IDM_LOG_COPYING:
        {
#ifdef TEST
            HKEY hKey=0;
            _TCHAR szDoCopy[MAX_NAME_LEN];



            vfLogCopying = vfLogCopying?0:1;
            CheckMenuItem(GetMenu(hwnd), IDM_LOG_COPYING , MF_BYCOMMAND|((vfLogCopying)?MF_UNCHECKED:MF_CHECKED));

            if(RegOpenKey(HKEY_LOCAL_MACHINE, REG_KEY_CSC_SETTINGS, &hKey) !=  ERROR_SUCCESS)
            {
                ReintKdPrint(BADERRORS, ("IDM_LOG_COPYING: RegOpenKey failed\n"));
                goto done;
            }

            if(vfLogCopying)
                strcpy(szDoCopy, SZ_TRUE);
            else
                strcpy(szDoCopy, SZ_FALSE);

            if(RegSetValueEx(hKey, vszDoLogCopy, (DWORD) 0, REG_SZ, szDoCopy, strlen(szDoCopy)+1) != ERROR_SUCCESS)
            {
                ReintKdPrint(BADERRORS, ("IDM_LOG_COPYING: RegSetValueEx failed\n"));
            }
            done:
            if(hKey)
                RegCloseKey(hKey);
#endif //TEST
        }
        break;

        case IDM_SHADOWING:
        break;

        case IDM_SPEED_OPT:
        break;

        case IDM_TRAY_FILL_SHADOW:
        break;


        case IDM_TRAY_MERGE:
        break;

        case IDM_TRAY_FREE_SPACE:
        break;

        case IDM_TRAY_FORCE_LOG:
        break;

        case IDM_REFRESH_CONNECTIONS:
        break;

        case IDM_BREAK_CONNECTIONS:
        break;

        case IDM_LOGON:
            if (lParam)
            {
                vfStartRecieved = TRUE;
                // logon is done, try enabling CSC
                // if CSC is already enabled, the routine will do the right thing
                //
                EnableCSC();

            }
            break;
        case IDM_LOGOFF:
            // no need to trap this, we get WM_QUERYENDSESSION and WM_ENDSESSION
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

LRESULT
CALLBACK
ReInt_WndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

--*/
{
    LPARAM lRet = 0L;

    switch (message)
    {
        case RWM_UPDATE:
            ReintKdPrint(BADERRORS, ("Update hShare:%0x hWnd=%0x\n",wParam, lParam));
            PurgeSkipQueue(TRUE, (HSHARE)wParam, 0, 0);
//            return ReintOneShare((HSHARE)wParam,(HWND)lParam);
            break;

        case RWM_UPDATEALL:
            break;

        case WM_TIMER:
        break;

        case TRAY_NOTIFY:
        break;

        case WM_DEVICECHANGE:
        {
            switch (wParam)
            {
                case DBT_DEVICEARRIVAL:
                    if (((DEV_BROADCAST_NET *)lParam)->dbcn_devicetype == DBT_DEVTYP_NET)
                    {
//                        ProcessNetArrivalMessage();

                    }
                    break;
                case DBT_DEVICEREMOVECOMPLETE:
                    if (((DEV_BROADCAST_NET *)lParam)->dbcn_devicetype == DBT_DEVTYP_NET)
                    {
//                        ProcessNetDepartureMessage(FALSE);

                    }
                    break;
            }
            break;
        }

        case WM_INITMENU:
            return TRUE;
        break;

        case WM_INITMENUPOPUP:
        break;

        case WM_COMMAND:
            if(lRet = ReInt_CommandHandler(hwnd, wParam, lParam))
                return lRet;
            break;

        case WM_CLOSE:
            ReintKdPrint(BADERRORS, ("WM_CLOSE hit.\n"));
            break;

        case WM_DESTROY:
            ReintKdPrint(BADERRORS, ("WM_DESTROY hit.\n"));
            PostQuitMessage((int)wParam);
            return 1L;

        case WM_SETCURSOR:
        break;
        case WM_QUERYENDSESSION:
            return TRUE;
        case WM_ENDSESSION:
            ReintKdPrint(BADERRORS, ("Turning off shadowing on WM_ENDSESSION\r\n"));
           DisableCSC();
           break;
        case WM_FILE_OPENS:
            break;

        case WM_SHADOW_ADDED:
        case WM_SHADOW_DELETED:
            ReintKdPrint(BADERRORS, ("allowAttempt = TRUE\n"));
            allowAttempt = TRUE;
            break;

        case WM_SHARE_DISCONNECTED:
            ReintKdPrint(BADERRORS, ("REINT: VxD notification(0x%08x)\n",message));
            break;

        default:
            break;
    }

    return DefWindowProc(hwnd, message, wParam, lParam);
}

BOOL ReInt_AnythingToMerge(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

--*/
{
    return (CheckDirtyShares() != 0);
}

//
//
BOOL
ReInt_RefreshTray(
    BOOL bHide
    )
/*++

Routine Description:
    Called to update the tray ICON to reflect the merge status.

Parameters:

    bHide   = TRUE means hide it
            = FALSE means work it out.

Return Value:

Notes:

--*/
{
    return TRUE;
}

// See if shadfowing is ON
// Returns: TRUE=> ON, FALSE=> OFF, -1 => soem error happened
BOOL
IsCSCOn(
    VOID
    )
{

    if (vfCSCEnabled)
    {
#ifdef DEBUG
        unsigned ulSwitch = SHADOW_SWITCH_SHADOWING;
        if(ShadowSwitches(INVALID_HANDLE_VALUE, &ulSwitch, SHADOW_SWITCH_GET_STATE))
        {
            Assert((ulSwitch & SHADOW_SWITCH_SHADOWING)!=0);
        }
#endif
        return (TRUE);
    }
    return (FALSE);
}

// Disable Shadowing
// Returns: 1 => done, -1 => some error happened
int
DisableCSC()
{
    unsigned ulSwitch = SHADOW_SWITCH_SHADOWING;

    if (vfCSCEnabled && vfAgentEnabledCSC) {

        if(ShadowSwitches(INVALID_HANDLE_VALUE, &ulSwitch, SHADOW_SWITCH_OFF))
        {
            vfCSCEnabled = FALSE;
            if (vhShadowDBForEvent != INVALID_HANDLE_VALUE)
            {
                CloseHandle(vhShadowDBForEvent);
                vhShadowDBForEvent = INVALID_HANDLE_VALUE;
            }

            Reint_UnregisterAgent();
//            SetDisabledReg();
            return (1);
        }
    }
    return (-1);
}

BOOL
EnableCSC(
    VOID
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    char szBuff[MAX_PATH];
    DWORD   dwBuffSize;
    BOOL fDirCreated=FALSE, fRedirCSCEnabled=TRUE, fWasDirty = FALSE;
    unsigned uShadowSwitches;

    ReintKdPrint(INIT, ("CSC Enabled %d \r\n", vfCSCEnabled));
    if (vfCSCEnabled==FALSE)
    {

        dwBuffSize = sizeof(szBuff);
        if(!GetUserNameA(szBuff, &dwBuffSize))
        {
            // not logged on yet
            return FALSE;
        }

        if(ShadowSwitches(INVALID_HANDLE_VALUE, &uShadowSwitches, SHADOW_SWITCH_GET_STATE))
        {
            if (uShadowSwitches & SHADOW_SWITCH_SHADOWING)
            {
                ReintKdPrint(INIT, ("cscdll: CSC already started\r\n"));
            }
            else
            {
                ReintKdPrint(INIT, ("cscdll: redir is not doing CSC yet, OK\r\n"));
                fRedirCSCEnabled = FALSE;

                if (!vfOKToEnableCSC)
                {
                    return FALSE;
                }

                vfAgentEnabledCSC = TRUE;

            }
        }
        else
        {
            ReintKdPrint(BADERRORS, ("cscdll: couldn't get the CSC state from the redir\r\n"));
        }

        if (Reint_RegisterAgent())
        {

            SetFileAttributesA(vszDBDir, FILE_ATTRIBUTE_SYSTEM|FILE_ATTRIBUTE_HIDDEN);

            ReintKdPrint(INIT,
                 ("cscdll: enabling CSC at %s for %s with capacity %d and clustersize %d\r\n",
                 vszDBDir, szBuff, vdwDBCapacity, vdwClusterSize));
            if (EnableShadowing(
                    INVALID_HANDLE_VALUE,
                    vszDBDir,
                    szBuff,
                    0,
                    vdwDBCapacity,
                    vdwClusterSize,
                    vfFormatDatabase))
            {
                vfCSCEnabled = TRUE;
                if (vhShadowDBForEvent == INVALID_HANDLE_VALUE)
                {
                    vhShadowDBForEvent = OpenShadowDatabaseIO();
                }
            }
            else
            {
                ReintKdPrint(BADERRORS, ("cscdll: EnableShadowing failed, CSC not enabled!!!!\r\n"));
            }

            if (vfCSCEnabled==FALSE)
            {
                Reint_UnregisterAgent();
            }
        }
        else
        {
            ReintKdPrint(BADERRORS, ("cscdll: EnableCSC.Agent registration failed, CSC not enabled!!!!\r\n"));
        }
    }
    if (!vfCSCEnabled)
    {
        // NTRAID-455253-1/31/2000-shishirp need to add it to the event log with the right error
        ReintKdPrint(BADERRORS, ("cscdll: CSC not enabled \r\n"));
    }

    return (vfCSCEnabled);
}

BOOL
IsNetConnected(
VOID
)
/*++

Routine Description:
        The function checks to see whether at this moment
        we are connected to any resources on the real net.

Parameters:

Return Value:

Notes:
        This is used to decide whether to start purging stuff from the
        cache. If we are in a completely disconnected state then we
        may not want to purge data that is potentially useful.

--*/
{
    CSC_ENUMCOOKIE  ulEnumCookie=NULL;
    WIN32_FIND_DATA sFind32;
    BOOL fConnected = FALSE;
    SHADOWINFO sSI;
    HANDLE hShadowDB;

    memset(&sFind32, 0, sizeof(sFind32));
    lstrcpy(sFind32.cFileName, _TEXT("*.*"));

    if ((hShadowDB = OpenShadowDatabaseIO()) == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    if(FindOpenShadow(hShadowDB, 0, FINDOPEN_SHADOWINFO_ALL, &sFind32, &sSI))
    {
        ulEnumCookie = sSI.uEnumCookie;

        do
        {
            if (sSI.uStatus & SHARE_CONNECTED) {
                if (!(sSI.uStatus & SHARE_DISCONNECTED_OP)) {
                    fConnected = TRUE;
                    break;
                }
             }
        } while(FindNextShadow(hShadowDB, ulEnumCookie, &sFind32, &sSI));

        FindCloseShadow(hShadowDB, ulEnumCookie);
    }

    CloseShadowDatabaseIO(hShadowDB);

    return fConnected;
}


int
ExtractSpaceStats(
    GLOBALSTATUS    *lpsGS,
    unsigned long     *lpulMaxSpace,
    unsigned long     *lpulCurSpace,
    unsigned long     *lpulFreeSpace
    )
/*++

Routine Description:
         The function returns the max, current and free
         space as known by the shadow cache.

Parameters:

Return Value:
    1 if there is any free space
    0 if there is no free space
    -1 if there is some error

Notes:

--*/
{
    int iRet = 1;

    if (!lpsGS)
    {
        lpsGS = &vsGS;
    }

    if (lpulMaxSpace){
        *lpulMaxSpace = lpsGS->sST.sMax.ulSize;
    }

    if (lpulCurSpace){
        *lpulCurSpace = lpsGS->sST.sCur.ulSize;
    }

    if (lpulFreeSpace){
        *lpulFreeSpace = 0;
    }

    // do we have any space?
    if (lpsGS->sST.sMax.ulSize > lpsGS->sST.sCur.ulSize){
        if (lpulFreeSpace){
            *lpulFreeSpace =  (lpsGS->sST.sMax.ulSize - lpsGS->sST.sCur.ulSize);
        }
        iRet = 1;
    }
    else{
        iRet = 0;
    }

    return iRet;
}


int
InitCacheSize(
    VOID
    )
/*++

Routine Description:
         The function returns the max, current and free
         space as known by the shadow cache.

Parameters:

Return Value:
    1 if there is any free space
    0 if there is no free space
    -1 if there is some error

Notes:

--*/
{
    unsigned ulMaxStore;
    int iRet = 0;

    if(!GetGlobalStatus(INVALID_HANDLE_VALUE, &vsGS))
    {
        return -1;
    }

    if (ExtractSpaceStats(&vsGS, &ulMaxStore, NULL, NULL)>=0){

        if (ulMaxStore==0xffffffff){

            ReintKdPrint(BADERRORS, ("Agent: Found newly created cache, setting cache size \r\n"));

            Assert(vszDBDir[0]);

            iRet = SetDefaultSpace(vszDBDir);
        }
    }
    return iRet;
}

int
SetDefaultSpace(
    LPSTR lpShadowDir
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

--*/
{
    DWORD dwSPC, dwBPS, dwFreeC, dwTotalC, dwCapacity;
    _TCHAR szDrive[4];
    int iRet = 0;

    Assert(lpShadowDir[1]==':');
    memset(szDrive, 0, sizeof(szDrive));
    memcpy(szDrive, lpShadowDir, 3);
    if(GetDiskFreeSpace(szDrive, &dwSPC, &dwBPS, &dwFreeC, &dwTotalC )){
        dwCapacity = ((dwSPC * dwBPS * 10)/100)*dwTotalC;
        SetMaxShadowSpace(INVALID_HANDLE_VALUE, 0, dwCapacity);
        iRet = 1;
    }
    return (iRet);
}

int
DoEventProcessing(
    VOID
)
/*++

Routine Description:

    When the named event is triggered by the kernel mode component, this routine
    looks to see what needs to be taken care of and does the job.

Parameters:

Return Value:

Notes:

    This routine is called from various places in the mailoop and other loops such as
    AttemptCacheFill. It may end up showing up dialog boxes and such, so care has to be taken
    while invoking it.

--*/
{
    int iRet;
    GLOBALSTATUS sGS;

    ReintKdPrint(
        INIT,
        ("CSC Agent: CSC Enabled=%d vhShadowDBForEvent \n",
        vfCSCEnabled,
        vhShadowDBForEvent));

    ReintKdPrint(MAINLOOP, ("Agent(1):DoEventProcessing()\n"));

    if (iRet = GetGlobalStatus(vhShadowDBForEvent, &sGS)) {
        ReintKdPrint(MAINLOOP, (
                        "Agent(1):uFlagsEvents:0x%x\n"
                        "         uDatabaseErrorFlags:0x%x\n"
                        "         hShadowAdded:0x%x\n"
                        "         hDirAdded:0x%x\n"
                        "         hShadowDeleted:0x%x\n"
                        "         hDirDeleted:0x%x\n"
                        "         cntFileOpen:%d\n"
                        "         hShareDisconnected:0x%x\n",
                            sGS.uFlagsEvents,
                            sGS.uDatabaseErrorFlags,
                            sGS.hShadowAdded,
                            sGS.hDirAdded,
                            sGS.hShadowDeleted,
                            sGS.hDirDeleted,
                            sGS.cntFileOpen,
                            sGS.hShareDisconnected,
                            sGS.uFlagsEvents));
        if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_START)
            ReintKdPrint(MAINLOOP, ("Agent(1):FLAG_GLOBALSTATUS_START received\r\n"));
        if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_STOP)
            ReintKdPrint(MAINLOOP, ("Agent(1):FLAG_GLOBALSTATUS_STOP received\r\n"));
        if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_NO_NET)
            ReintKdPrint(MAINLOOP, ("Agent(1):FLAG_GLOBALSTATUS_NO_NET received\r\n"));
        if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_GOT_NET)
            ReintKdPrint(MAINLOOP, ("Agent(1):FLAG_GLOBALSTATUS_GOT_NET received\r\n"));
        if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_INVOKE_FREESPACE)
            ReintKdPrint(MAINLOOP, ("Agent(1):FLAG_GLOBALSTATUS_INVOKE_FREESPACE received\r\n"));
        if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_SHARE_DISCONNECTED)
            ReintKdPrint(
                    MAINLOOP,
                    ("Agent(1):FLAG_GLOBALSTATUS_SHARE_DISCONNECTED (share=%d) received\r\n",
                    sGS.hShareDisconnected));
        if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_START) {
            vfCSCEnabled = TRUE;
            if (vhShadowDBForEvent == INVALID_HANDLE_VALUE) {
                vhShadowDBForEvent = OpenShadowDatabaseIO();
            }
            Reint_RegisterAgent();
        } else if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_STOP) {
            vfCSCEnabled = FALSE;
            if (vhShadowDBForEvent != INVALID_HANDLE_VALUE) {
                CloseHandle(vhShadowDBForEvent);
                vhShadowDBForEvent = INVALID_HANDLE_VALUE;
            }
            Reint_UnregisterAgent();
        }
        if (AGENT_ALIVE) {
            if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_GOT_NET) {
                ProcessNetArrivalMessage();
            } else if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_NO_NET) {
                ProcessNetDepartureMessage(
                            ((sGS.uFlagsEvents & FLAG_GLOBALSTATUS_INVOKE_AUTODIAL)!=0));
            }
            if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_SHARE_DISCONNECTED) {
                ReportShareNetArrivalDeparture(
                    1,
                    sGS.hShareDisconnected,
                    ((sGS.uFlagsEvents & FLAG_GLOBALSTATUS_INVOKE_AUTODIAL)!=0),
                    FALSE); // departed
            }
            if (uOldDatabaseErrorFlags != sGS.uDatabaseErrorFlags) {
                ReportEventsToSystray(STWM_CACHE_CORRUPTED, 0, 0);
                uOldDatabaseErrorFlags = sGS.uDatabaseErrorFlags;
            }
            // see if space needs freeing
            if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_INVOKE_FREESPACE) {
                ReintKdPrint(MAINLOOP, ("Agent(1): Calling DoFreeShadowSpace(1)\r\n"));
                ReInt_DoFreeShadowSpace(&sGS, 0);
            } else {
                ReintKdPrint(MAINLOOP, ("Agent(1): Calling DoFreeShadowSpace(2)\r\n"));
                ReInt_DoFreeShadowSpace(&sGS, 0);
            }
        } else {
            if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_SHARE_DISCONNECTED) {
                ReintKdPrint(MAINLOOP, ("Agent(1): Calling ReportShareNetArrivalDeparture\r\n"));
                ReportShareNetArrivalDeparture(
                    1,
                    0,
                    ((sGS.uFlagsEvents & FLAG_GLOBALSTATUS_INVOKE_AUTODIAL)!=0),
                    FALSE); // departed
            }
        }
        vsGS = sGS;
        vsGS.uFlagsEvents = 0; // clear all event indicators
    }
    return iRet;
}

BOOL
CreatePerSessSyncObjects(
    VOID
    )
{
    NTSTATUS Status;
    UNICODE_STRING EventName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR SessEventName[100];

    // DbgPrint("CreatePerSessSyncObjects:vdwAgentSessionId = %d\n", vdwAgentSessionId);

    Assert(heventPerSess == NULL);

    wsprintf(SessEventName, L"%ws_%d", SESSION_EVENT_NAME_NT, vdwAgentSessionId);

   //  DbgPrint("CreatePerSessSyncObjects:SessEventName = [%ws]\n", SessEventName);

    RtlInitUnicodeString(&EventName, SessEventName);

    InitializeObjectAttributes( &ObjectAttributes,
                                &EventName,
                                OBJ_OPENIF,  //got this const from base\client\support.c
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    Status = NtCreateEvent(
                &heventPerSess,
                EVENT_ALL_ACCESS,
                &ObjectAttributes,
                SynchronizationEvent,
                FALSE
                );

    if (!NT_SUCCESS(Status)) {
        DbgPrint("CreatePerSessSyncObjects:NtCreateEvent returned %08lx\n",Status);
    }


    return (heventPerSess==0)?FALSE:TRUE;

}

BOOL
CreateSharedFillSyncObjects(
    VOID
    )
{
    NTSTATUS Status;
    UNICODE_STRING EventName;
    OBJECT_ATTRIBUTES ObjectAttributes;

    Assert(heventSharedFill == NULL);

    RtlInitUnicodeString(&EventName,SHARED_FILL_EVENT_NAME_NT);

    InitializeObjectAttributes( &ObjectAttributes,
                                &EventName,
                                OBJ_OPENIF,  //got this const from base\client\support.c
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    Status = NtCreateEvent(
                &heventSharedFill,
                EVENT_ALL_ACCESS,
                &ObjectAttributes,
                SynchronizationEvent,
                FALSE
                );

    if (!NT_SUCCESS(Status)) {
        DbgPrint("ntcreateeventstatus=%08lx\n",Status);
    }


    return (heventSharedFill==0)?FALSE:TRUE;

}


VOID
ProcessStartStopAgent(
    VOID
    )
{
    if (vfStartRecieved)
    {
        
        ReintKdPrint(MAINLOOP, ("Agent(1): start received, enabling CSC\r\n"));


        if (EnableCSC() == FALSE)
        {
            ReintKdPrint(ALWAYS, ("Ageint(1):Couldn't turn CSC ON!!!!!!!!! \n"));
        }
        else
        {
            UpdateExclusionList();
            UpdateBandwidthConservationList();
        }


        // set the event to indicate to wkssvc that we are alive
        if (heventAgentToWkssvc)
        {
            SetEvent(heventAgentToWkssvc);
        }

        vfStartRecieved = FALSE;
        vfRedirStarted = TRUE;
    }
    else if (vfStopRecieved)
    {
        ReintKdPrint(MAINLOOP, ("Agent(1):Stop recieved \r\n"));

        DisableCSC();

        if(heventAgentToWkssvc)
        {
            SetEvent(heventAgentToWkssvc);
        }

        vcntNetDevices = 0;
        vfStopRecieved = FALSE;
        vfRedirStarted = FALSE;
    }
}

BOOL
FStopAgent(
    VOID
    )
{

    if (StartStopCheck() && vfStopRecieved)
    {
        return TRUE;
    }

    return FALSE;
}

BOOL
StartStopCheck(
    VOID
    )
{
    DWORD    dwError;
    BOOL fRet = FALSE;
    HANDLE hT[2];
    unsigned ulSwitch=0;

    // the way we are finding out about the start makes the start event
    // redundant, but we will leave it, because it is generically the right thing to have a
    // start event and a stop event.

    if ((vfRedirStarted == -1) &&   // if newly launched agent
        (ShadowSwitches(INVALID_HANDLE_VALUE, &ulSwitch, SHADOW_SWITCH_GET_STATE)))
    {
            ReintKdPrint(INIT, ("Agent: redir already started\r\n"));
            vfStartRecieved = TRUE;
    }
    else if (heventWkssvcToAgentStart)
    {
        // we know that when it comes to events it is all or nothing
        Assert(heventWkssvcToAgentStop);

        hT[0] = heventWkssvcToAgentStart;
        hT[1] = heventWkssvcToAgentStop;

        dwError = MsgWaitForMultipleObjects(2, hT, FALSE, 0, QS_ALLINPUT);

        if (vfRedirStarted == TRUE)
        {
            vfStopRecieved = (dwError == WAIT_OBJECT_0+1);
            if (vfStopRecieved)
            {
                ReintKdPrint(INIT, ("Agent: stop recieved\r\n"));
            }
        }
        else
        {
            vfStartRecieved = (dwError == WAIT_OBJECT_0);

            if (vfStartRecieved)
            {
                ReintKdPrint(INIT, ("Agent: start recieved\r\n"));
            }
        }
    }

    return fRet;
}

BOOL
Reint_RegisterAgent(
    VOID
    )
{

    if (!vfAgentRegistered)
    {
        if (!RegisterAgent(INVALID_HANDLE_VALUE, vhwndMain, LongToHandle(dwVxDEvent)))
        {
            ReintKdPrint(BADERRORS, ("Agent registration failed \n"));
            return FALSE;
        }

        else
        {
            vfAgentRegistered = TRUE;
        }
    }
    return vfAgentRegistered;
}

VOID
Reint_UnregisterAgent(
    VOID
    )
{
    if (vfAgentRegistered)
    {
        // don't do any checking
        UnregisterAgent(INVALID_HANDLE_VALUE, vhwndMain);
        vfAgentRegistered = FALSE;
    }

}

BOOL
QueryEnableCSC(
    VOID
    )
{

    DWORD dwDisposition, dwSize, dwEnabled=0;
    HKEY hKey = NULL;
    BOOL fRet = TRUE;
    int i;
    _TCHAR  *lpKey;
    NT_PRODUCT_TYPE productType;

    if( !RtlGetNtProductType( &productType ) ) {
       productType = NtProductWinNt;
    }

    switch ( productType ) {
    case NtProductWinNt:
       /* WORKSTATION */
        ReintKdPrint(INIT, ("Agent:CSC running workstation\r\n"));
      break;
    default:
        ReintKdPrint(INIT, ("Agent:CSC NOT running workstation\r\n"));
        fRet = FALSE;   // default is fail
    }

    if (IsPersonal() == TRUE || IsMultipleUsersEnabled() == TRUE)
        return FALSE;

    for (i=0; i<2; ++i)
    {
        if (i==0)
        {
            lpKey = REG_STRING_POLICY_NETCACHE_KEY;
        }
        else
        {
            lpKey = REG_STRING_NETCACHE_KEY;
        }

        if (RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        lpKey,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hKey
                        ) == ERROR_SUCCESS)
        {
            dwSize = sizeof(dwEnabled);

            if (RegQueryValueEx(hKey, REG_VALUE_ENABLED, NULL, NULL, (void *)&dwEnabled, &dwSize) == ERROR_SUCCESS)
            {
                fRet = (dwEnabled != 0);
                break;
            }


            RegCloseKey(hKey);
            hKey = NULL;
        }
        else
        {
            hKey = NULL;
        }
    }

    if(hKey)
    {
        RegCloseKey(hKey);
    }

    return (fRet);
}




BOOL
CreateStartStopEvents(
    VOID
    )
{
    BOOL fOK = FALSE;

    // ensure that there are thre named autoreset events
    if (!heventWkssvcToAgentStart)
    {
        heventWkssvcToAgentStart = CreateEvent(NULL, FALSE, FALSE, szWkssvcToAgentStartEvent);

        if (!heventWkssvcToAgentStart)
        {
            ReintKdPrint(BADERRORS, ("CSC.Agent: Failed to create heventWkssvcToAgentStart, error = %d\n", GetLastError()));
            goto bailout;
        }

        Assert(!heventAgentToWkssvc);

        heventWkssvcToAgentStop = CreateEvent(NULL, FALSE, FALSE, szWkssvcToAgentStopEvent);

        if (!heventWkssvcToAgentStop)
        {
            ReintKdPrint(BADERRORS, ("CSC.Agent: Failed to create heventWkssvcToAgentStop, error = %d\n", GetLastError()));
            goto bailout;
        }

        heventAgentToWkssvc = CreateEvent(NULL, FALSE, FALSE, szAgentToWkssvcEvent);

        if (!heventAgentToWkssvc)
        {
            ReintKdPrint(BADERRORS, ("CSC.Agent: Failed to create heventAgentToWkssvc, error = %d\n", GetLastError()));
            goto bailout;
        }

        // event to detect whether the agent is alive (used by wkssvc) and
        // to signal termination (used by winlogon)
        heventShutDownAgent = CreateEvent(NULL, FALSE, FALSE, szAgentExistsEvent);

        if (!heventShutDownAgent)
        {
            ReintKdPrint(BADERRORS, ("CSC.Agent: Failed to create heventShutDownAgent, error = %d\n", GetLastError()));
            goto bailout;
        }

        heventShutDownThread = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (!heventShutDownThread)
        {
            ReintKdPrint(BADERRORS, ("CSC.Agent: Failed to create heventShutDownThread, error = %d\n", GetLastError()));
            goto bailout;
        }
    }

    fOK = TRUE;

bailout:

    if (!fOK)
    {
        DestroyStartStopEvents();
    }
    return fOK;
}

VOID
DestroyStartStopEvents(
    VOID
    )
{

    if (heventWkssvcToAgentStart)
    {
        CloseHandle(heventWkssvcToAgentStart);
        heventWkssvcToAgentStart = NULL;
    }

    if (heventWkssvcToAgentStop)
    {
        CloseHandle(heventWkssvcToAgentStop);
        heventWkssvcToAgentStop = NULL;
    }

    if (heventAgentToWkssvc)
    {
        CloseHandle(heventAgentToWkssvc);
        heventAgentToWkssvc = NULL;
    }

    if (heventShutDownAgent)
    {
        CloseHandle(heventShutDownAgent);
        heventShutDownAgent = NULL;
    }
    if (heventShutDownThread)
    {
        CloseHandle(heventShutDownThread);
        heventShutDownThread = NULL;
    }
}

BOOL
UpdateExclusionList(
    VOID
    )
/*++

Routine Description:

    Tell the kernel mode code about the exclusion list. If there is none set in the registry
    then we set the default one

Parameters:

Return Value:

Notes:


--*/
{
    LPWSTR  lpwExclusionList = NULL;
    DWORD   cbSize = 0;
    char    buff[MAX_LIST_SIZE]; // max exclusion list
    BOOL    fRet = FALSE;

    if (!vfCSCEnabled)
    {

        ReintKdPrint(INIT, ("CSC not enabled \r\n"));
        return FALSE;

    }

    ReintKdPrint(INIT, ("Getting ExclusionList \r\n"));

    // get the exclusion list from the policy key.
    // if that doesn't work then try the one from the netcache key

    if (GetWideStringFromRegistryString(REG_STRING_POLICY_NETCACHE_KEY_A,
                                        REG_STRING_EXCLUSION_LIST_A,
                                        &lpwExclusionList,
                                        &cbSize) ||
        GetWideStringFromRegistryString(REG_STRING_NETCACHE_KEY_A,
                                        REG_STRING_EXCLUSION_LIST_A,
                                        &lpwExclusionList,
                                        &cbSize)
        )
    {
        ReintKdPrint(INIT, ("Got ExclusionList \r\n"));

        if (cbSize < sizeof(buff))
        {
            memcpy(buff, lpwExclusionList, cbSize);

            ReintKdPrint(INIT, ("Setting User defined exclusion list %ls size=%d\r\n", buff, cbSize));
            if (SetExclusionList(INVALID_HANDLE_VALUE, (USHORT *)buff, cbSize))
            {
                fRet = TRUE;
            }
        }

    }
    else
    {
        // set the default
        // take the string and it's terminating null char
        cbSize = sizeof(vtzDefaultExclusionList);
        Assert(cbSize < MAX_LIST_SIZE);
        memcpy(buff, vtzDefaultExclusionList, cbSize);
        ReintKdPrint(INIT, ("Setting default exclusion list %ls size=%d\r\n", buff, cbSize));

        if (SetExclusionList(INVALID_HANDLE_VALUE, (USHORT *)buff, cbSize))
        {
            fRet = TRUE;
        }
    }

    if (lpwExclusionList)
    {
        LocalFree(lpwExclusionList);
    }
    return fRet;
}


BOOL
UpdateBandwidthConservationList(
    VOID
    )
/*++

Routine Description:

    Update the list of extensions on which bitcopy should be turned ON. We do not set any default

Parameters:

Return Value:

Notes:


--*/
{
    LPWSTR  lpwBandwidthConservationList = NULL;
    DWORD   cbSize = 0;
    char    buff[MAX_LIST_SIZE]; // max exclusion list
    BOOL    fRet = FALSE;

    if (!vfCSCEnabled)
    {

        ReintKdPrint(INIT, ("CSC not enabled \r\n"));
        return FALSE;

    }

    ReintKdPrint(INIT, ("Getting BandwidthConservationList \r\n"));

    // get the exclusion list from the policy key.
    // if that doesn't work then try the one from the netcache key

    if (GetWideStringFromRegistryString(REG_STRING_POLICY_NETCACHE_KEY_A,
                                        REG_STRING_BANDWIDTH_CONSERVATION_LIST_A,
                                        &lpwBandwidthConservationList,
                                        &cbSize) ||
        GetWideStringFromRegistryString(REG_STRING_NETCACHE_KEY_A,
                                        REG_STRING_BANDWIDTH_CONSERVATION_LIST_A,
                                        &lpwBandwidthConservationList,
                                        &cbSize)
        )
    {
        ReintKdPrint(INIT, ("Got BandwidthConservationList \r\n"));

        if (cbSize < sizeof(buff))
        {
            memcpy(buff, lpwBandwidthConservationList, cbSize);

            ReintKdPrint(INIT, ("Setting User defined bandwidth conservation list %ls size=%d\r\n", buff, cbSize));
            if (SetBandwidthConservationList(INVALID_HANDLE_VALUE, (USHORT *)buff, cbSize))
            {
                fRet = TRUE;
            }
        }

    }
    else
    {
        fRet = FALSE;
#if 0
        // set the default
        // take the string and it's terminating null char
        cbSize = sizeof(vtzDefaultBandwidthConservationList);
        Assert(cbSize < MAX_LIST_SIZE);
        memcpy(buff, vtzDefaultBandwidthConservationList, cbSize);
        ReintKdPrint(INIT, ("Setting default exclusion list %ls size=%d\r\n", buff, cbSize));

        if (SetBandwidthConservationList(INVALID_HANDLE_VALUE, (USHORT *)buff, cbSize))
        {
            fRet = TRUE;
        }
#endif
    }

    if (lpwBandwidthConservationList)
    {
        LocalFree(lpwBandwidthConservationList);
    }
    return fRet;
}



BOOL
ProcessNetArrivalMessage(
    VOID
    )
/*++

Routine Description:


Parameters:

Return Value:

Notes:

--*/
{

    vcntNetDevices = 1;
    ReportShareNetArrivalDeparture( 0,      // all shares
                                    0,
                                    FALSE,  // don't invoke autodial
                                    TRUE    // arrived
                                  );

    ReintKdPrint(INIT, ("WM_DEVICECHANGE:Net arrived, %d nets so far\r\n", vcntNetDevices));

    return (TRUE);
}

BOOL
ProcessNetDepartureMessage(
    BOOL    fInvokeAutodial
    )
/*++

Routine Description:


Parameters:

Return Value:

Notes:

--*/
{
    ReintKdPrint(MAINLOOP, ("WM_DEVICECHANGE:Net removed, %d nets so far\r\n", vcntNetDevices));

    vcntNetDevices = 0;

    ReportShareNetArrivalDeparture( 0,  // all shares
                                    0,
                                    fInvokeAutodial, // invoke auto dial
                                    FALSE // departed
                                    );

    return TRUE;
}

BOOL
ReportShareNetArrivalDeparture(
    BOOL    fOneServer,
    HSHARE hShare,
    BOOL    fInvokeAutoDial,
    BOOL    fArrival
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:

--*/
{
    SHAREINFO  sSR;
    _TCHAR  *lptzServerName;
    unsigned    ulStatus;
    DWORD dwSize;
    BOOL fGotName = FALSE;
    BOOL fAllocated = FALSE;
    BOOL fRet = FALSE;
    LRESULT lResult = LRESULT_CSCFAIL;
    LPTSTR lp = NULL;
    DWORD dwMessage = 0;
    WPARAM dwWParam = (WPARAM) 0;
    LPARAM dwLParam = (LPARAM) 0;

    lptzServerName = sSR.rgSharePath;

    if (fOneServer) {
        if (fArrival) {
            if(GetShareInfo(vhShadowDBForEvent, hShare, &sSR, &ulStatus)<= 0) {
                PrintFn("ReportShareNetArrivalDeparture: couldn't get status for server 0x%x\r\n",
                            hShare);
                ReintKdPrint(
                    BADERRORS,
                    ("ReportShareNetArrivalDeparture: couldn't get status for server 0x%x\r\n",
                    hShare));
                return FALSE;
            }
            lp = MyStrChr(sSR.rgSharePath+2, _T('\\'));
            if (!lp) {
                ReintKdPrint(
                    BADERRORS,
                    ("ReportShareNetArrivalDeparture: Invalid server name %ls\r\n",
                    sSR.rgSharePath));
                Assert(FALSE);
                return FALSE;
            }
            *lp = 0;
        } else { // A share departure
            int i;
            
            dwSize = sizeof(sSR.rgSharePath);
            fGotName = GetNameOfServerGoingOfflineEx(
                            vhShadowDBForEvent,
                            &lptzServerName,
                            &dwSize,
                            &fAllocated);
            if(!fGotName) {
                TransitionShareToOffline(vhShadowDBForEvent, fOneServer, 0xffffffff);
                goto bailout;
            }
        }
    }

    fRet = TRUE;

    ReintKdPrint(
        INIT,
        ("ReportShareNetArrivalDeparture: reporting %s to the systray\r\n",
        (fArrival) ? "arrival" : "departure"));

    dwMessage = (fArrival) ? STWM_CSCNETUP : STWM_CSCQUERYNETDOWN;
    dwWParam = (fInvokeAutoDial)
                    ? ((hShare != 0)
                        ? CSCUI_AUTODIAL_FOR_CACHED_SHARE
                        : CSCUI_AUTODIAL_FOR_UNCACHED_SHARE)
                    : CSCUI_NO_AUTODIAL;
    dwLParam = (fOneServer) ? (DWORD_PTR)(lptzServerName) : 0;

    lResult = ReportEventsToSystray(dwMessage, dwWParam, dwLParam);

    // if the redir is stuck waiting to be told whether to go offline on a share
    // tell him yes or no
    if (!fArrival) {
        if (fOneServer) {
            TransitionShareToOffline(
                vhShadowDBForEvent,
                fOneServer,
                (lResult == LRESULT_CSCWORKOFFLINE)
                    ? 1
                    : ((lResult == LRESULT_CSCRETRY)
                        ? 0
                        : 0xffffffff)
                );

            if (lResult == LRESULT_CSCWORKOFFLINE) {
                dwMessage = STWM_CSCNETDOWN;
                dwWParam = fInvokeAutoDial;
                dwLParam = (fOneServer)
                                ? ((hShare != 0)
                                    ? (DWORD_PTR)(lptzServerName)
                                    : 0xffffffff)
                                : 0;
                ReportEventsToSystray(dwMessage, dwWParam, dwLParam);
                ReportTransitionToDfs(lptzServerName, TRUE, 0xffffffff);
            }
        }
    }

bailout:
    if (fAllocated) {
        LocalFree(lptzServerName);
    }
    return (fRet);
}


BOOL
CheckServerOnline(
    VOID
    )
/*++

Routine Description:


Parameters:

Return Value:

Notes:

--*/
{
    unsigned long ulStatus;
    WIN32_FIND_DATA sFind32;
    int cntReconnected=0;
    SHADOWINFO sSI;
    HANDLE  hShadowDB;
    _TCHAR  tzDriveMap[4];
    CSC_ENUMCOOKIE  ulEnumCookie=NULL;
    DWORD   dwError;

    if (!ImpersonateALoggedOnUser())
    {
        return 0;
    }

    if ((hShadowDB = OpenShadowDatabaseIO()) ==INVALID_HANDLE_VALUE)
    {
        ResetAgentThreadImpersonation();
        return 0;
    }

    memset(&sFind32, 0, sizeof(sFind32));
    lstrcpy(sFind32.cFileName, _TEXT("*"));

    if(FindOpenShadow(  hShadowDB, 0, FINDOPEN_SHADOWINFO_ALL,
                        &sFind32, &sSI))
    {
        ulEnumCookie = sSI.uEnumCookie;

        do {
            if(GetShareStatus(hShadowDB, sSI.hShare, &ulStatus)) {

                if(ulStatus & SHARE_DISCONNECTED_OP){

                    dwError = DWConnectNet(sFind32.cFileName, tzDriveMap, NULL, NULL, NULL, 0, NULL);

                    if ((dwError == NO_ERROR)||(dwError == ERROR_ACCESS_DENIED)||(dwError==WN_CONNECTED_OTHER_PASSWORD_DEFAULT))
                    {
                        if (sSI.ulHintFlags & FLAG_CSC_HINT_PIN_SYSTEM)
                        {
                            TransitionShareToOnline(INVALID_HANDLE_VALUE, 0);
                        }
                        else
                        {
                            ReportShareNetArrivalDeparture( TRUE,
                                                            sSI.hShare, // this share
                                                            FALSE,      // don't autodial
                                                            TRUE); // Arrived
                        }

                        ++cntReconnected;
                        if (dwError == NO_ERROR || dwError == WN_CONNECTED_OTHER_PASSWORD_DEFAULT)
                        {
                            DWDisconnectDriveMappedNet(tzDriveMap, TRUE); // force disconnect
                        }
                    }
                }
            }

            Sleep(200);

        } while(FindNextShadow(hShadowDB, ulEnumCookie, &sFind32, &sSI));

        FindCloseShadow(hShadowDB, ulEnumCookie);
    }


    CloseShadowDatabaseIO(hShadowDB);

    ResetAgentThreadImpersonation();

    return (cntReconnected?TRUE:FALSE);

}

BOOL
AreAnyServersOffline(
    VOID)
{
    ULONG ulStatus;
    WIN32_FIND_DATA sFind32 = {0};
    SHADOWINFO sSI;
    HANDLE  hShadowDB;
    CSC_ENUMCOOKIE  ulEnumCookie = NULL;
    BOOL bFoundOne = FALSE;

    if ((hShadowDB = OpenShadowDatabaseIO()) ==INVALID_HANDLE_VALUE)
        return FALSE;

    wcscpy(sFind32.cFileName, L"*");
    if (FindOpenShadow(hShadowDB, 0, FINDOPEN_SHADOWINFO_ALL, &sFind32, &sSI)) {
        ulEnumCookie = sSI.uEnumCookie;
        do {
            if (GetShareStatus(hShadowDB, sSI.hShare, &ulStatus)) {
                if ((ulStatus & SHARE_DISCONNECTED_OP) != 0) {
                    bFoundOne = TRUE;
                    break;
                }
            }
        } while(FindNextShadow(hShadowDB, ulEnumCookie, &sFind32, &sSI));
        FindCloseShadow(hShadowDB, ulEnumCookie);
    }
    CloseShadowDatabaseIO(hShadowDB);
    return bFoundOne;
}

BOOL
FAbortOperation(
    VOID
    )
{

    if (!vdwAgentThreadId)
    {
        return FALSE;
    }

    if (IsAgentShutDownRequested() || HasAgentShutDown())
    {
        ReintKdPrint(MAINLOOP, ("CSC.FAbortOperation: Agentshutdown detected aborting \r\n"));
        return TRUE;
    }
    return (FStopAgent());
}

VOID
SetAgentShutDownRequest(
    VOID
    )
{
    fAgentShutDownRequested = TRUE;
    SetEvent(heventShutDownAgent);
}

BOOL
IsAgentShutDownRequested(
    VOID
    )
{
    return (fAgentShutDownRequested == TRUE);
}

VOID
SetAgentShutDown(
    VOID
    )
{
    fAgentShutDown = TRUE;
}

BOOL
HasAgentShutDown(
    VOID
    )
{
    return (fAgentShutDown == TRUE );

}


//            HWND CSCUIInitialize(HANDLE hToken, DWORD dwFlags)
BOOL
InitCSCUI(
    HANDLE  hToken
    )
{

    ReintKdPrint(INIT, (" Initializing cscui\r\n"));

    EnterAgentCrit();
    if (!vhlibCSCUI)
    {
        vhlibCSCUI = LoadLibrary(vtzCSCUI);

        if (vhlibCSCUI)
        {
            if (vlpfnCSCUIInitialize = (CSCUIINITIALIZE)GetProcAddress(vhlibCSCUI, (const char *)vszCSCUIInitialize))
            {
                if(!(vlpfnCSCUISetState = (CSCUISETSTATE)GetProcAddress(vhlibCSCUI, (const char *)vszCSCUISetState)))
                {
                    ReintKdPrint(BADERRORS, ("Failed to get proc addres for %s, Error = %d \r\n", vszCSCUISetState, GetLastError()));
                }
                else
                {
                    (*vlpfnCSCUIInitialize)(hToken, CI_INITIALIZE);
                }
            }
            else
            {
                ReintKdPrint(BADERRORS, ("Failed to get proc addres for %s, Error = %d \r\n", vszCSCUIInitialize, GetLastError()));
            }
        }
        else
        {
            ReintKdPrint(BADERRORS, ("Failed to load %ls, Error = %d \r\n", vtzCSCUI, GetLastError()));
        }
    }
    LeaveAgentCrit();

    return (vlpfnCSCUISetState != NULL);
}



VOID
TerminateCSCUI(
    VOID
    )
{

    BOOL    fShowing;

    // snapshot the state of the showing dialog
    // if we are about to show an offline dialog, ReportEventsToSystray
    // will also do the action below but will try to set the vfShowingOfflineDlg
    // variable to 1
    // If fShowing was not set to 1, then we know that we are not showing UI
    // and we set vfShowingOfflineDlg to 0xffffffff. This will make ReportEventsToSystray
    // to not show the offline popup, so we will be free to do FreeLibrary

    fShowing = (BOOL)InterlockedExchange((PLONG)&vfShowingOfflineDlg, 0xffffffff);

    if (fShowing==1)
    {
        Assert(vhlibCSCUI && vlpfnCSCUISetState);

        (vlpfnCSCUISetState)(STWM_CSCCLOSEDIALOGS, 0, 0);

        while (vfShowingOfflineDlg != 0xfffffffe)
        {
            Sleep(10);
        }
    }

    if (vhlibCSCUI)
    {
        (*vlpfnCSCUIInitialize)(0, CI_TERMINATE);
        vlpfnCSCUIInitialize = NULL;
        vlpfnCSCUISetState = NULL;
        FreeLibrary(vhlibCSCUI);
        vhlibCSCUI = NULL;
    }

    vfShowingOfflineDlg = 0;

}

LRESULT
ReportEventsToSystray(
    DWORD   dwMessage,
    WPARAM  dwWParam,
    LPARAM  dwLParam
    )
/*++

Routine Description:


Parameters:

Return Value:

Notes:

--*/
{
    LRESULT lResult = LRESULT_CSCFAIL;
    BOOL    fOk;

    HWND hwnd;
    extern HDESK hdesktopUser, hdesktopCur;

    EnterAgentCrit();

    // is there a currently logged on user?
    if (!hdesktopUser)
    {
        LeaveAgentCrit();

        ReintKdPrint(INIT, ("ReportEventsToSystray: no-user logged, not-reporting\r\n"));
        return lResult;
    }
    else
    {
        if(!SetThreadDesktop(hdesktopUser))
        {
            LeaveAgentCrit();
            PrintFn("ReportEventsToSystray: failed to set desktop for agent thread error=%d\r\n", GetLastError());
            ReintKdPrint(BADERRORS, ("ReportEventsToSystray: failed to set desktop for agent thread error=%d\r\n", GetLastError()));
            return lResult;
        }

        // set our desktop to be that of the loggedon users desktop
        hdesktopCur = hdesktopUser;

    }


    LeaveAgentCrit();

    ReintKdPrint(INIT, ("ReportEventsToSystray: reporting message dwMessage=0x%x to the systray\r\n", dwMessage));

    // snapshot the state of the showing dialog
    // if we are about to terminate, the the terminateCSCUI will have
    // will also do the action below but will try to set the vfShowingOfflineDlg
    // variable to 0xffffffff
    // If fOk was not set to 0xffffffff, then we know that we are not terminating
    // and we set vfShowingOfflineDlg to 1. This will block the terminating guy
    // and he will not free the library till thei variable gets set to FALSE;

    fOk = (BOOL)InterlockedExchange((PLONG)&vfShowingOfflineDlg, 1);

    if (fOk == 0)
    {
        if (vlpfnCSCUISetState)
        {

            lResult = (vlpfnCSCUISetState)(dwMessage, dwWParam, dwLParam);

            // change the value of vfShowingOfflineDlg to 0 only if it is 1 right now
            // it can be something other than 1 if we are about to terminate

            if((DWORD)InterlockedCompareExchange(&vfShowingOfflineDlg, 0, 1) == 0xffffffff)
            {
                // if we came here then we are terminating, set a termination value
                // so that the logoff thread will stop doing a sleep loop
                // and if we came here again fOk will never be 0
                vfShowingOfflineDlg = 0xfffffffe;
            }

        }
        else
        {
            // Not showing any dialog, restore the variable back to what it should be
            vfShowingOfflineDlg = 0;
            PrintFn("ReportEventsToSystray: CSCUI not initalized\r\n");
        }
    }

    return lResult;
}

BOOL
GetNameOfServerGoingOfflineEx(
    HANDLE  hShadowDB,
    _TCHAR  **lplptzServerName,
    DWORD   *lpdwSize,
    BOOL    *lpfAllocated
    )
/*++

Routine Description:

    This routine is called in winlogon thread to findout which server is about to go offline
    The routine may allocate memory, which must be freed by the caller
    
Parameters:

Return Value:

Notes:

--*/
{
    DWORD   dwSize, i;
    BOOL    fRet = FALSE;

    dwSize = *lpdwSize;
    *lpfAllocated = FALSE;

    for (i=0;i<2;++i)
    {

        if(!GetNameOfServerGoingOffline(
                    hShadowDB,
                    (LPBYTE)(*lplptzServerName), &dwSize))
        {
            // if we need a bigger buffer go get one
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                // we shouldn't be trying to get a bigger buffer twice
                // it should have been sufficient the first time around

                if (i==1)
                {
                    Assert(FALSE);                    
                    break;
                }

                ReintKdPrint(MAINLOOP, ("GetNameOfServerGoingOfflineEx: Need %d sized Buffer \n", dwSize));
                *lplptzServerName = LocalAlloc(LPTR, dwSize);

                if (!*lplptzServerName)
                {
                    return FALSE;                
                }

                *lpfAllocated = TRUE;
                *lpdwSize = dwSize;

                continue;                
            }
            else
            {
                break;
            }
        }
        else
        {
            // ReintKdPrint(MAINLOOP,("GetNameOfServerGoingOfflineEx:name=%ws\n", *lplptzServerName));
            fRet = TRUE;
            break;
        }
    }

    // cleanup on error
    if (!fRet && *lpfAllocated)
    {
        LocalFree(*lplptzServerName);
        *lpfAllocated = FALSE;
    }

    return fRet;
}

BOOL
IsWinlogonRegValueSet(HKEY hKey, LPSTR pszKeyName, LPSTR pszPolicyKeyName, LPSTR pszValueName)
{
    BOOL bRet = FALSE;
    DWORD dwType;
    DWORD dwSize;
    HKEY hkey;

    //
    //  first check the per-machine location.
    //
    if (RegOpenKeyExA(hKey, pszKeyName, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(bRet);
        if (RegQueryValueExA(hkey, pszValueName, NULL, &dwType, (LPBYTE)&bRet, &dwSize) == ERROR_SUCCESS)
        {
            if (dwType != REG_DWORD)
            {
                bRet = FALSE;
            }
        }
        RegCloseKey(hkey);
    }
    //
    //  then let the policy value override
    //
    if (RegOpenKeyExA(hKey, pszPolicyKeyName, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(bRet);
        if (RegQueryValueExA(hkey, pszValueName, NULL, &dwType, (LPBYTE)&bRet, &dwSize) == ERROR_SUCCESS)
        {
            if (dwType != REG_DWORD)
            {
                bRet = FALSE;
            }
        }
        RegCloseKey(hkey);
    }

    return bRet;
}



BOOL
CheckIsSafeModeType(DWORD dwSafeModeType)
{

    BOOL bResult = FALSE;
    HKEY hkey;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      TEXT("SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Option"),
                                      0,
                                      KEY_QUERY_VALUE,
                                      &hkey))
    {
     DWORD dwType;
        DWORD dwValue;
        DWORD cbValue = sizeof(dwValue);

        if (ERROR_SUCCESS == RegQueryValueEx(hkey,
                                             TEXT("OptionValue"),
                                             NULL,
                                             &dwType,
                                             (LPBYTE)&dwValue,
                                             &cbValue))
        {
            bResult = (dwValue == dwSafeModeType);
        }
        RegCloseKey(hkey);
    }
    return bResult;
}




BOOL
AllowMultipleTsSessions(void)
{
    return IsWinlogonRegValueSet(HKEY_LOCAL_MACHINE,
                                "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                                "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system",
                                "AllowMultipleTSSessions");
}



BOOL
IsSafeMode(void)
{
    return CheckIsSafeModeType(SAFEBOOT_MINIMAL) ||
           CheckIsSafeModeType(SAFEBOOT_NETWORK);
}



BOOL
IsTerminalServicesEnabled(void)

{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask;

    dwlConditionMask = 0;
    ZeroMemory(&osVersionInfo, sizeof(osVersionInfo));
    osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS;
    VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);
    return(VerifyVersionInfo(&osVersionInfo, VER_SUITENAME, dwlConditionMask) != FALSE);
}



BOOL
IsMultipleUsersEnabled(void)
{
    return IsTerminalServicesEnabled() &&
           !IsSafeMode() &&
           AllowMultipleTsSessions();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\util\cscgetinfo\cscgetinfo.c ===
#define UNICODE
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winioctl.h>
#include <shdcom.h>

#include <smbdebug.h>

CHAR *ProgName = "cscgetinfo";

PBYTE InBuf[0x50];
PBYTE OutBuf = NULL;

#define STATUS_SUCCESS                   ((ULONG)0x00000000L)
#define STATUS_BUFFER_TOO_SMALL          ((ULONG)0xC0000023L)


_cdecl
main(LONG argc, CHAR *argv[])
{
    BOOL bResult;
    HANDLE  hShadow=NULL;
    ULONG junk;
    PULONG pl = NULL;
    PIOCTL_GET_DEBUG_INFO_ARG pInfoArg = NULL;
    ULONG i;
    ULONG j;
    ULONG BufSize = 0x1000;
    ULONG Cmd = DEBUG_INFO_SERVERLIST;
    // ULONG Cmd = DEBUG_INFO_CSCFCBSLIST;

TryAgain:

    OutBuf = malloc(BufSize);

    if (OutBuf == NULL) {
        printf("Couldn't alloc memory\n");
        return 0;
    }

    hShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hShadow == INVALID_HANDLE_VALUE) {
        printf("Failed open of shadow device\n");
        return 0;
    }

    memset(InBuf, 0, sizeof(InBuf));
    pl = (PULONG)InBuf;
    *pl = Cmd;

    bResult = DeviceIoControl(
                hShadow,                        // device 
                IOCTL_GET_DEBUG_INFO,           // control code
                (LPVOID)InBuf,                  // in buffer
                sizeof(InBuf),                  // inbuffer size
                (LPVOID)OutBuf,                 // out buffer
                BufSize,                        // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    CloseHandle(hShadow);

    pInfoArg = (PIOCTL_GET_DEBUG_INFO_ARG) OutBuf;
    if (bResult && pInfoArg->Status == STATUS_SUCCESS) {
        if (Cmd == DEBUG_INFO_SERVERLIST) {
            for (i = 0; i < pInfoArg->EntryCount; i++) {
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].Name, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].DomainName, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].DfsRootName, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].DnsName, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].pNetRoots, OutBuf);
                for (j = 0; j < pInfoArg->ServerEntryObject[i].NetRootEntryCount; j++)
                    OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].pNetRoots[j].Name, OutBuf);
            }
            printf("Status:        0x%x\n"
                   "Version:       %d\n"
                   "Entries:       %d\n",
                       pInfoArg->Status,
                       pInfoArg->Version,
                       pInfoArg->EntryCount);
            for (i = 0; i < pInfoArg->EntryCount; i++) {
                printf("=================================================\n");
                printf("Name:                       %ws\n"
                       "DomainName:                 %ws\n"
                       "ServerStatus:               0x%x\n"
                       "DfsRootName:                %ws\n"
                       "DnsName:                    %ws\n"
                       "SecuritySignaturesEnabled:  0x%x\n"
                       "NetRootEntryCount:          0x%x\n"
                       "=================================================\n",
                            pInfoArg->ServerEntryObject[i].Name,
                            pInfoArg->ServerEntryObject[i].DomainName,
                            pInfoArg->ServerEntryObject[i].ServerStatus,
                            pInfoArg->ServerEntryObject[i].DfsRootName,
                            pInfoArg->ServerEntryObject[i].DnsName,
                            pInfoArg->ServerEntryObject[i].SecuritySignaturesEnabled,
                            pInfoArg->ServerEntryObject[i].NetRootEntryCount);
                for (j = 0; j < pInfoArg->ServerEntryObject[i].NetRootEntryCount; j++) {
                    printf("    Name:                       %ws\n"
                           "    MaximalAccessRights:        0x%x\n"
                           "    GuestMaximalAccessRights:   0x%x\n"
                           "    DfsAware:                   0x%x\n"
                           "    hShare:                     0x%x\n"
                           "    hRootDir:                   0x%x\n"
                           "    ShareStatus:                0x%x\n"
                           "    CscEnabled:                 0x%x\n"
                           "    CscShadowable:              0x%x\n"
                           "    Disconnected:               0x%x\n",
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].Name,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].MaximalAccessRights,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].GuestMaximalAccessRights,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].DfsAware,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].hRootDir,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].ShareStatus,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].CscEnabled,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].CscShadowable,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].Disconnected);
                    if (j < pInfoArg->ServerEntryObject[i].NetRootEntryCount-1)
                        printf("    --------------------------------------------\n");
                }
            }
            printf("=================================================\n");
        } else if (Cmd == DEBUG_INFO_CSCFCBSLIST) {
            for (i = 0; i < pInfoArg->EntryCount; i++) {
                OFFSET_TO_POINTER(pInfoArg->FcbEntryObject[i].DfsPrefix, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->FcbEntryObject[i].ActualPrefix, OutBuf);
            }
            printf("Status:        0x%x\n"
                   "Version:       %d\n"
                   "Entries:       %d\n",
                       pInfoArg->Status,
                       pInfoArg->Version,
                       pInfoArg->EntryCount);
            for (i = 0; i < pInfoArg->EntryCount; i++) {
                printf("=================================================\n");
                printf("MFlags:                     0x%x\n"
                       "Tid:                        0x%x\n"
                       "ShadowIsCorrupt:            0x%x\n"
                       "hShadow:                    0x%x\n"
                       "hParentDir:                 0x%x\n"
                       "hShadowRenamed:             0x%x\n"
                       "hParentDirRenamed:          0x%x\n"
                       "ShadowStatus:               0x%x\n"
                       "LocalFlags:                 0x%x\n"
                       "LastComponentOffset:        0x%x\n"
                       "LastComponentLength:        0x%x\n"
                       "hShare:                     0x%x\n"
                       "hRootDir:                   0x%x\n"
                       "ShareStatus:                0x%x\n"
                       "Flags:                      0x%x\n"
                       "DfsPrefix:                  %s\n"
                       "ActualPrefix:               %s\n",
                            pInfoArg->FcbEntryObject[i].MFlags,
                            pInfoArg->FcbEntryObject[i].Tid,
                            pInfoArg->FcbEntryObject[i].ShadowIsCorrupt,
                            pInfoArg->FcbEntryObject[i].hShadow,
                            pInfoArg->FcbEntryObject[i].hParentDir,
                            pInfoArg->FcbEntryObject[i].hShadowRenamed,
                            pInfoArg->FcbEntryObject[i].hParentDirRenamed,
                            pInfoArg->FcbEntryObject[i].ShadowStatus,
                            pInfoArg->FcbEntryObject[i].LocalFlags,
                            pInfoArg->FcbEntryObject[i].LastComponentOffset,
                            pInfoArg->FcbEntryObject[i].LastComponentLength,
                            pInfoArg->FcbEntryObject[i].hShare,
                            pInfoArg->FcbEntryObject[i].hRootDir,
                            pInfoArg->FcbEntryObject[i].ShareStatus,
                            pInfoArg->FcbEntryObject[i].Flags,
                            pInfoArg->FcbEntryObject[i].DfsPrefix,
                            pInfoArg->FcbEntryObject[i].ActualPrefix);
            }
        }
    } else if (bResult && pInfoArg->Status == STATUS_BUFFER_TOO_SMALL) {
        // printf("Success but status = 0x%x\n", pInfoArg->Status);
        free(OutBuf);
        OutBuf = NULL;
        BufSize *= 2;
        goto TryAgain;
    }

    if (OutBuf != NULL)
        free(OutBuf);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\test\apitst.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    apitest.c

Abstract:

    Program to test CSC apis.

Author:

    Shishir Pardikar (shishirp) 4-24-97

Environment:

    User Mode - Win32

Revision History:

--*/
#ifdef CSC_ON_NT
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#else
typedef const char *    LPCSTR;
#endif
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <cscapi.h>
#include "lmcons.h"
#include "lmuse.h"
//#include <timelog.h>

//=================================================================================
#define MAX_COMMAND_ARGS    32
#define DEFAULT_BUFFER_SIZE 1024    // 1k
//=================================================================================

// The order of these must match the order in GlobalCommandInfo[]
typedef enum _COMMAND_CODE {
    CmdCSCPinFile,
    CmdCSCUnPinFile,
    CmdCSCQueryFileStatus,
    CmdCSCEnum,
    CmdCSCDelete,
    CmdCSCFill,
    CmdCSCMerge,
    CmdCSCCopyReplica,
    CmdTimeLog,
    CmdCheckCSC,
    CmdDbCheckCSC,
    CmdCSCEnumForStats,
    CmdCSCDoLocalRename,
    CmdCSCDoEnableDisable,
    CmdShowTime,
    CmdEncryptDecrypt,
    CmdDoRandomWrites,
    CmdHelp,
    CmdQuit,
    UnknownCommand
} COMMAND_CODE, *LPCOMMAND_CODE;

typedef struct _COMMAND_INFO {
    LPSTR CommandName;
    LPSTR CommandParams;
    COMMAND_CODE CommandCode;
} COMMAND_INFO, *LPCOMMAND_INFO;

typedef VOID (*PRINTPROC)(LPSTR);
#ifndef CSC_ON_NT
typedef BOOL (*CHECKCSCEX)(LPSTR, LPCSCPROCA, DWORD, DWORD);
#else
typedef BOOL (*CHECKCSCEX)(LPSTR, LPCSCPROCW, DWORD, DWORD);
#endif
// If Count is not already aligned, then
// round Count up to an even multiple of "Pow2".  "Pow2" must be a power of 2.
//
// DWORD
// ROUND_UP_COUNT(
//     IN DWORD Count,
//     IN DWORD Pow2
//     );

#define ROUND_UP_COUNT(Count,Pow2) \
        ( ((Count)+(Pow2)-1) & (~((Pow2)-1)) )

#define ALIGN_WCHAR             sizeof(WCHAR)

//=================================================================================
FILE *UncList = NULL;
LPSTR g_lpWriteFileBuf = NULL;
FILE *DumpUncList = NULL;
DWORD cCommands = 0;
DWORD cFails = 0;
DWORD g_dwNumIterations = 1;
DWORD g_dwIteration = 0;
DWORD g_dwNumCmdIterations = 1;
DWORD g_dwCmdIteration = 0;
DWORD g_dwFileSize = 0;
DWORD g_dwDiskCache = 0;
BOOL g_bWriteFile = FALSE;
BOOL g_bQuietMode = FALSE;
BOOL g_bPerfMode = FALSE;
BOOL g_bUseFile = FALSE;
char szDefaultTimeLogFile[] = "c:\\debug\\kd.log";
char vszFile[] = "C:\\WINNT\\private\\ntos\\rdr2\\csc\\usermode\\reint\\foo";
WCHAR vwzFileName[] = L"\\\\shishir1\\public\\foo.txt";

COMMAND_INFO GlobalCommandInfo[] = {
    {"pin",         "UNCName",                          CmdCSCPinFile},
    {"unpin",       "UNCName",                          CmdCSCUnPinFile},
    {"query",       "UNCName",                          CmdCSCQueryFileStatus},
    {"Enum",        "UNCName or nothing",               CmdCSCEnum},
    {"Del",         "UNCName",                          CmdCSCDelete},
    {"Fill",        "UNCName",                          CmdCSCFill},
    {"Merge",       "\\\\Server\\Share",                CmdCSCMerge},
    {"Move",        "UNCNAME",                          CmdCSCCopyReplica},
    {"tlog",        "logfile",                          CmdTimeLog},
    {"check",       "\\\\Server\\Share",                CmdCheckCSC},
    {"dbcheck",     "dbdir <0 (verify) or 1 (fix)>",    CmdDbCheckCSC},
    {"stats",       ""              ,                   CmdCSCEnumForStats},
    {"Ren",         "ren src containing_dst_dir [1:-replace files]", CmdCSCDoLocalRename},
    {"EnDis",       "0 (disable) or 1 enable",              CmdCSCDoEnableDisable},
    {"ShowTime",    "HHHHHHHH LLLLLLLL (Hex HighDateTime and LowDateTime)", CmdShowTime},
    {"EncDec",      "U (decrypt) anything else=> encrypt", CmdEncryptDecrypt},
    {"RandW",        "Randw filename",                  CmdDoRandomWrites},
    {"Help",        "",                                 CmdHelp},
    {"Quit",         "",                                CmdQuit}
};

LPSTR   rgszNameArray[] =
{
"EditRecordEx",
"AddFileRecordFR",
"DeleteFileRecFromInode",
"FindFileRecord",
"UpdateFileRecordFR",
"AddPriQRecord",
"DeletePriQRecord",
"FindPriQRecordInternal",
"SetPriorityForInode",
"CreateShadowInternal",
"GetShadow",
"GetShadowInfo",
"SetShadowInfoInternal",
"ChangePriEntryStatusHSHADOW",
"MRxSmbCscCreateShadowFromPath",
"MRxSmbGetFileInfoFromServer",
"EditRecordEx_OpenFileLocal",
"EditRecordEx_Lookup",
"KeAttachProcess_R0Open",
"IoCreateFile_R0Open",
"KeDetachProcess_R0Open",
"KeAttachProcess_R0Read",
"R0ReadWrite",
"KeDetachProcess_R0Read",
"FindQRecordInsertionPoint_Addq",
"LinkQRecord_Addq",
"UnlinkQRecord_Addq",
"FindQRecordInsertionPoint_Addq_dir",
"EditRecordEx_Validate",
"EditRecordEx_dat"
};

typedef struct tagCSCSTATS{
    DWORD   dwTotal;
    DWORD   dwTotalFiles;
    DWORD   dwTotalDirs;
    DWORD   dwSparseFiles;
    DWORD   dwDirtyFiles;
    DWORD   dwPinned;
    DWORD   dwPinnedAndSparse;
    DWORD   dwMismatched;
} CSCSTATS, *LPCSCSTATS;

DWORD WINAPIV Format_String(LPSTR *plpsz, LPSTR lpszFmt, ...);
DWORD WINAPI Format_Error(DWORD dwErr, LPSTR *plpsz);
DWORD WINAPI Format_StringV(LPSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs);
DWORD WINAPI Format_MessageV(DWORD dwFlags, DWORD dwErr, LPSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs);
VOID PrintBuffer(
    LPSTR   lpszBuff
    );


BOOL WINAPI CheckCSC(LPSTR lpszDataBaseLocation, BOOL fFix);
BOOL
DoPinningA(
    LPSTR   lpszName,
    DWORD   dwHintFlags,
    BOOL    fRecurse
    );
BOOL
DoPinningW(
    LPWSTR   lpwzName,
    DWORD   dwHintFlags,
    BOOL    fRecurse
    );

DWORD
ProcessShowTime (
    DWORD argc,
    LPSTR *argv
    );

DWORD
ProcessEncryptDecrypt(
    DWORD   argc,
    LPSTR   *argv
);


//=================================================================================
DWORD
ProcessCommandCode (
    DWORD CommandCode,
    DWORD CommandArgc,
    LPSTR *CommandArgv
    );


DWORD
GetLeafLenFromPath(
    LPSTR   lpszPath
    );

BOOL
GetStreamInformation(
    LPCSTR  lpExistingFileName,
    LPVOID  *lpStreamInformation
    );

//=================================================================================
#if DBG

#define TestDbgAssert(Predicate) \
    { \
        if (!(Predicate)) \
            TestDbgAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }

VOID
TestDbgAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    )
/*++

Routine Description:

    Assertion failed.

Arguments:

    FailedAssertion :

    FileName :

    LineNumber :

    Message :

Return Value:

    none.

--*/
{

    printf("Assert @ %s \n", FailedAssertion );
    printf("Assert Filename, %s \n", FileName );
    printf("Line Num. = %ld.\n", LineNumber );
    printf("Message is %s\n", Message );

    DebugBreak();
}
#else

#define TestDbgAssert(_x_)

#endif // DBG

//=================================================================================
VOID
ParseArguments(
    LPSTR InBuffer,
    LPSTR *CArgv,
    LPDWORD CArgc
    )
{
    LPSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr == ' ' ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != '\0') &&
                (*CurrentPtr != '\n') ) {
            if( *CurrentPtr == '"' ) {      // Deal with simple quoted args
                if( Cnt == 0 )
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                else
                    *CurrentPtr = '\0';     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == ' ') ||   // If we hit a space and no quotes yet we are done with this arg
                (*CurrentPtr == '\0') )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        *CurrentPtr++ = '\0';
    }

    *CArgc = i;
    return;
}

#ifdef MAYBE
//=================================================================================
LPSTR
GetUncFromFile ()
{
    if (!UncList)
    {
        UncList = fopen ("Unclist", "r");
        if (UncList == NULL)
            return NULL;
    }
    if (fgets( UncBuffer, DEFAULT_BUFFER_SIZE, UncList))
    {
        UncBuffer[strlen(UncBuffer) -1] = '\0';  //kill line feed for no param cmds
        return UncBuffer;
    }
    else
    {
        fclose (UncList);
        UncList = NULL;
        return GetUncFromFile();
    }
}

#endif
//=================================================================================
COMMAND_CODE
DecodeCommand(
    LPSTR CommandName
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalCommandInfo) / sizeof(COMMAND_INFO);
    TestDbgAssert( NumCommands <= UnknownCommand );
    for( i = 0; i < NumCommands; i++) {
        if(( lstrcmpi( CommandName, GlobalCommandInfo[i].CommandName ) == 0 )){
            return( GlobalCommandInfo[i].CommandCode );
        }
    }
    return( UnknownCommand );
}

//=================================================================================
VOID
PrintCommands(
    VOID
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalCommandInfo) / sizeof(COMMAND_INFO);
    TestDbgAssert( NumCommands <= UnknownCommand );
    for( i = 0; i < NumCommands; i++) {
        fprintf(stderr, "    %s (%s)\n",
            GlobalCommandInfo[i].CommandName,
            GlobalCommandInfo[i].CommandParams );
    }
}

//=================================================================================
VOID
DisplayUsage(
    VOID
    )
{
    fprintf(stderr, "Usage: command <command parameters>\n" );

    fprintf(stderr, "Commands : \n");
    PrintCommands();

    return;
}

//=================================================================================
FILETIME
GetGmtTime(
    VOID
    )
{
    SYSTEMTIME SystemTime;
    FILETIME Time;

    GetSystemTime( &SystemTime );
    SystemTimeToFileTime( &SystemTime, &Time );

    return( Time );
}

//=================================================================================
LPSTR
ConvertGmtTimeToString(
    FILETIME Time,
    LPSTR OutputBuffer
    )
{
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    static FILETIME ftNone = {0, 0};

    if (!memcmp (&Time, &ftNone, sizeof(FILETIME)))
        sprintf (OutputBuffer, "<none>");
    else
    {
        FileTimeToLocalFileTime( &Time , &LocalTime );
        FileTimeToSystemTime( &LocalTime, &SystemTime );

        sprintf( OutputBuffer,
                    "%02u/%02u/%04u %02u:%02u:%02u ",
                    SystemTime.wMonth,
                    SystemTime.wDay,
                    SystemTime.wYear,
                    SystemTime.wHour,
                    SystemTime.wMinute,
                    SystemTime.wSecond );
    }

    return( OutputBuffer );
}


void
PrintCSCEntryInfo(
    WIN32_FIND_DATA *lpFind32,
    DWORD           dwStatus,
    DWORD           dwPinCount,
    DWORD           dwHintFlags,
    FILETIME        *lpftOrgTime
)
{
    char buff[128];
    fprintf(stderr, "\n");


    if (lpFind32)
    {
        fprintf(stderr, "LFN: %s\n", lpFind32->cFileName);
        fprintf(stderr, "SFN: %s\n", lpFind32->cAlternateFileName);
        fprintf(stderr, "Attr: %x\n", lpFind32->dwFileAttributes);
        fprintf(stderr, "Size: %d %d\n", lpFind32->nFileSizeHigh, lpFind32->nFileSizeLow);

        ConvertGmtTimeToString(lpFind32->ftLastWriteTime, buff);
        fprintf(stderr, "LastWriteTime: %s\n", buff);
    }

    if (lpftOrgTime)
    {
        ConvertGmtTimeToString(*lpftOrgTime, buff);
        fprintf(stderr, "ORGTime: %s\n", buff);
    }

    fprintf(stderr, "Status: %x\n", dwStatus);

    fprintf(stderr, "PinCount: %x\n", dwPinCount);

    fprintf(stderr, "PinFlags: %x\n", dwHintFlags);

    fprintf(stderr, "\n");

}

void
PrintCSCEntryInfoW(
    WIN32_FIND_DATAW *lpFind32,
    DWORD           dwStatus,
    DWORD           dwPinCount,
    DWORD           dwHintFlags,
    FILETIME        *lpftOrgTime
)
{

    WIN32_FIND_DATA *lpFind32P = NULL;

    fprintf(stderr, "\n");
    if (lpFind32)
    {
        WIN32_FIND_DATA sFind32;

        lpFind32P = &sFind32;
        memset(&sFind32, 0, sizeof(WIN32_FIND_DATAA));
        memcpy(&sFind32, lpFind32, sizeof(WIN32_FIND_DATAA)-sizeof(sFind32.cFileName)-sizeof(sFind32.cAlternateFileName));

        WideCharToMultiByte(CP_ACP, 0, lpFind32->cFileName, wcslen(lpFind32->cFileName), sFind32.cFileName, sizeof(sFind32.cFileName), NULL, NULL);
        WideCharToMultiByte(CP_OEMCP, 0, lpFind32->cAlternateFileName, wcslen(lpFind32->cAlternateFileName), sFind32.cAlternateFileName, sizeof(sFind32.cAlternateFileName), NULL, NULL);
    }

    PrintCSCEntryInfo(  lpFind32P,
                        dwStatus,
                        dwPinCount,
                        dwHintFlags,
                        lpftOrgTime
                    );
}

DWORD
MyCSCProc(
    const char          *lpszFullPath,
    DWORD               dwStatus,
    DWORD               dwHintFlags,
    DWORD               dwPinCount,
    WIN32_FIND_DATAA    *lpFind32,
    DWORD               dwReason,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwContext
    )
{
    if (dwReason==CSCPROC_REASON_BEGIN)
    {
        printf("CSCPROC:Name=%s Status=0x%x HintFlags=0x%x PinCount=%d Reason=%d Param1=%d Param2=%d\r\n",
                    (lpszFullPath)?lpszFullPath:"None",
                    dwStatus,
                    dwHintFlags,
                    dwPinCount,
                    dwReason,
                    dwParam1,
                    dwParam2
        );
    }
    else if (dwReason==CSCPROC_REASON_MORE_DATA)
    {
        printf(".");
    }
    else
    {
        printf("\r\n");
        if (dwParam2==ERROR_SUCCESS)
        {
            printf("Succeeded\r\n");
        }
        else
        {
            printf("Error=%d \r\n", dwParam2);
        }
    }
    return (CSCPROC_RETURN_CONTINUE);
}

DWORD
MyCSCProcW(
    const unsigned short  *lpszFullPath,
    DWORD           dwStatus,
    DWORD           dwHintFlags,
    DWORD           dwPinCount,
    WIN32_FIND_DATAW *lpFind32,
    DWORD           dwReason,
    DWORD           dwParam1,
    DWORD           dwParam2,
    DWORD           dwContext
    )
{
    if (dwReason==CSCPROC_REASON_BEGIN)
    {
        printf("CSCPROC:Name=%ls Status=0x%x HintFlags=0x%x PinCount=%d Reason=%d Param1=%d Param2=%d\r\n",
                    (lpszFullPath)?lpszFullPath:L"None",
                    dwStatus,
                    dwHintFlags,
                    dwPinCount,
                    dwReason,
                    dwParam1,
                    dwParam2
        );
    }
    else if (dwReason==CSCPROC_REASON_MORE_DATA)
    {
        printf(".");
    }
    else
    {
        printf("\r\n");
        if (dwParam2==ERROR_SUCCESS)
        {
            printf("Succeeded\r\n");
        }
        else
        {
            printf("Error=%d \r\n", dwParam2);
        }
    }
    return (CSCPROC_RETURN_CONTINUE);
}

DWORD
MyCSCEnumForStatsProc(
    const char          *lpszFullPath,
    DWORD               dwStatus,
    DWORD               dwHintFlags,
    DWORD               dwPinCount,
    WIN32_FIND_DATAA    *lpFind32,
    DWORD               dwReason,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwContext
    )
{
    LPCSCSTATS lpStats = (LPCSCSTATS)dwContext;

    lpStats->dwTotal++;
    if(dwParam1)
    {
        lpStats->dwTotalFiles++;
        if (dwStatus & FLAG_CSC_COPY_STATUS_SPARSE)
        {
            lpStats->dwSparseFiles++;
        }
        if (dwStatus & FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED)
        {
            lpStats->dwDirtyFiles++;
        }
        if ((dwHintFlags & (FLAG_CSC_HINT_PIN_USER|FLAG_CSC_HINT_PIN_SYSTEM))||dwPinCount)
        {
            lpStats->dwPinned++;
            if (dwStatus & FLAG_CSC_COPY_STATUS_SPARSE)
            {
                lpStats->dwPinnedAndSparse++;
            }

        }
    }
    else
    {
        lpStats->dwTotalDirs++;
    }

    return (CSCPROC_RETURN_CONTINUE);
}

DWORD
MyCSCEnumForStatsProcW(
    const unsigned short  *lpszFullPath,
    DWORD           dwStatus,
    DWORD           dwHintFlags,
    DWORD           dwPinCount,
    WIN32_FIND_DATAW *lpFind32,
    DWORD           dwReason,
    DWORD           dwParam1,
    DWORD           dwParam2,
    DWORD           dwContext
    )
{
    LPCSCSTATS lpStats = (LPCSCSTATS)dwContext;

    lpStats->dwTotal++;
    if(dwParam1)
    {
        lpStats->dwTotalFiles++;
        if (dwStatus & FLAG_CSC_COPY_STATUS_SPARSE)
        {
            lpStats->dwSparseFiles++;
        }
        if (dwStatus & FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED)
        {
            lpStats->dwDirtyFiles++;
        }
        if ((dwHintFlags & (FLAG_CSC_HINT_PIN_USER|FLAG_CSC_HINT_PIN_SYSTEM))||dwPinCount)
        {
            lpStats->dwPinned++;
            if (dwStatus & FLAG_CSC_COPY_STATUS_SPARSE)
            {
                lpStats->dwPinnedAndSparse++;
            }
        }
    }
    else
    {
        lpStats->dwTotalDirs++;
    }

    return (CSCPROC_RETURN_CONTINUE);
}

DWORD
MyCSCCheckExProc(
    const char          *lpszFullPath,
    DWORD               dwStatus,
    DWORD               dwHintFlags,
    DWORD               dwPinCount,
    WIN32_FIND_DATAA    *lpFind32,
    DWORD               dwReason,
    DWORD               dwParam1,
    DWORD               dwParam2,
    DWORD               dwContext
    )
{
    LPCSCSTATS lpStats = (LPCSCSTATS)dwContext;

    if (dwReason == CSCPROC_REASON_BEGIN)
    {
        if (lpFind32)
        {
            printf("%s size=%d\r\n", lpszFullPath, lpFind32->nFileSizeLow);
            lpStats->dwTotal++;
            lpStats->dwTotalFiles++;
        }
        else
        {
            printf("%s\r\n", lpszFullPath);
        }

    }
    else if (dwReason == CSCPROC_REASON_END)
    {
        if (dwParam2 != NO_ERROR)
        {
            if (dwParam2 == ERROR_INVALID_DATA)
            {
                printf("Mismatched, press any key to continue...\r\n", dwParam2);
            }
            else
            {
                printf("Error in comparing Errcode=%d, press any key to continue...\r\n", dwParam2);
            }
            getchar();
            lpStats->dwMismatched++;
        }
    }

    return (CSCPROC_RETURN_CONTINUE);
}

DWORD
MyCSCCheckExProcW(
    const unsigned short  *lpszFullPath,
    DWORD           dwStatus,
    DWORD           dwHintFlags,
    DWORD           dwPinCount,
    WIN32_FIND_DATAW *lpFind32,
    DWORD           dwReason,
    DWORD           dwParam1,
    DWORD           dwParam2,
    DWORD           dwContext
    )
{
    LPCSCSTATS lpStats = (LPCSCSTATS)dwContext;

    if (dwReason == CSCPROC_REASON_BEGIN)
    {
        if (lpFind32)
        {
            printf("%ls size=%d\r\n", lpszFullPath, lpFind32->nFileSizeLow);
            lpStats->dwTotal++;
            lpStats->dwTotalFiles++;
        }
        else
        {
            printf("%s\r\n", lpszFullPath);
        }
    }
    else if (dwReason == CSCPROC_REASON_END)
    {
        if (dwParam2 != NO_ERROR)
        {
            if (dwParam2 == ERROR_INVALID_DATA)
            {
                printf("Mismatched, press any key to continue...\r\n", dwParam2);
            }
            else
            {
                printf("Error in comparing Errcode=%d, press any key to continue...\r\n", dwParam2);
            }
            getchar();
            lpStats->dwMismatched++;
        }
    }
    return (CSCPROC_RETURN_CONTINUE);
}

DWORD
ProcessCSCPinFile(
    DWORD   argc,
    LPSTR   *argv
)
{
    DWORD   dwError=ERROR_SUCCESS, dwHintFlags=0;
    BOOL    fRecurse = FALSE, fRet=FALSE;
#ifdef CSC_ON_NT
    unsigned short uBuff[MAX_PATH];
#endif
    if (argc < 1)
    {
        printf("CSCPinFile: must provide a UNC path \r\n");
    }
    else
    {
        if (argc > 1)
        {
            if ((*argv[1] == 'u')||(*argv[1] == 'U'))
            {
                dwHintFlags |= FLAG_CSC_HINT_PIN_USER;
            }
            else if ((*argv[1] == 's')||(*argv[1] == 'S'))
            {
                dwHintFlags |= FLAG_CSC_HINT_PIN_SYSTEM;
            }
            else if (*argv[1] == 'i')
            {
                dwHintFlags |= FLAG_CSC_HINT_PIN_INHERIT_USER;
            }
            else if (*argv[1] == 'I')
            {
                dwHintFlags |= FLAG_CSC_HINT_PIN_INHERIT_SYSTEM;
            }
            else if (*argv[1] == 'T')
            {
                fRecurse = TRUE;
            }

        }
#ifndef CSC_ON_NT
        fRet = DoPinningA(argv[0], dwHintFlags, fRecurse);
#else
        memset(uBuff, 0, sizeof(uBuff));
        MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));
        fRet = DoPinningW(uBuff, dwHintFlags, fRecurse);
#endif

    }

    if (!fRet)
    {
        dwError = GetLastError();
    }

    return (dwError);
}

DWORD
ProcessCSCUnPinFile(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwStatus, dwError=ERROR_SUCCESS, dwPinCount, dwHintFlags=0;
#ifdef CSC_ON_NT
    unsigned short uBuff[MAX_PATH];
#endif

    if (argc < 1)
    {
        printf("CSCUnPinFile: must provide a UNC path \r\n");
    }
    else
    {
        if (argc > 1)
        {
            if ((*argv[1] == 'u')||(*argv[1] == 'U'))
            {
                dwHintFlags |= FLAG_CSC_HINT_PIN_USER;
            }
            else if ((*argv[1] == 's')||(*argv[1] == 'S'))
            {
                dwHintFlags |= FLAG_CSC_HINT_PIN_SYSTEM;
            }
            else if (*argv[1] == 'i')
            {
                dwHintFlags |= FLAG_CSC_HINT_PIN_INHERIT_USER;
            }
            else if (*argv[1] == 'I')
            {
                dwHintFlags |= FLAG_CSC_HINT_PIN_INHERIT_SYSTEM;
            }
        }

#ifndef CSC_ON_NT
        if (!CSCUnpinFileA(argv[0], dwHintFlags, &dwStatus, &dwPinCount, &dwHintFlags))
        {
            dwError = GetLastError();   
        }
        else
        {
            PrintCSCEntryInfo(NULL, dwStatus, dwPinCount, dwHintFlags, NULL);

        }
#else
        memset(uBuff, 0, sizeof(uBuff));
        MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));

        if (!CSCUnpinFileW(uBuff, dwHintFlags, &dwStatus, &dwPinCount, &dwHintFlags))
        {
            dwError = GetLastError();   
        }
        else
        {
            PrintCSCEntryInfo(NULL, dwStatus, dwPinCount, dwHintFlags, NULL);

        }
#endif
    }
    return (dwError);
}

DWORD
ProcessCSCQueryFileStatus(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwStatus, dwError=ERROR_SUCCESS, dwPinCount, dwHintFlags;
#ifdef CSC_ON_NT
    unsigned short uBuff[MAX_PATH];
#endif

    if (argc < 1)
    {
        printf("CSCQueryFileStatusA: must provide a UNC path \r\n");
    }
    else
    {
#ifndef CSC_ON_NT
        if (!CSCQueryFileStatusA(argv[0], &dwStatus, &dwPinCount, &dwHintFlags))
        {
            dwError = GetLastError();   
        }
        else
        {
            PrintCSCEntryInfo(NULL, dwStatus, dwPinCount, dwHintFlags, NULL);

        }
#else

        memset(uBuff, 0, sizeof(uBuff));
        MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));
        if (!CSCQueryFileStatusW(uBuff, &dwStatus, &dwPinCount, &dwHintFlags))
        {
            dwError = GetLastError();   
        }
        else
        {
            PrintCSCEntryInfo(NULL, dwStatus, dwPinCount, dwHintFlags, NULL);

        }

#endif
    }
    return (dwError);
}

DWORD
ProcessCSCEnum(
    DWORD   argc,
    LPSTR   *argv
)
{
    HANDLE hFind;
    DWORD dwError = ERROR_SUCCESS, dwStatus, dwPinCount, dwHintFlags;
    FILETIME ftOrgTime;
#ifndef CSC_ON_NT
    WIN32_FIND_DATAA    sFind32;
#else
    WIN32_FIND_DATAW    sFind32;
    unsigned short uBuff[MAX_PATH];
#endif

#ifndef CSC_ON_NT
    hFind = CSCFindFirstFileA((argc<1)?NULL:argv[0], &sFind32, &dwStatus, &dwPinCount, &dwHintFlags, &ftOrgTime);

    if (hFind != INVALID_HANDLE_VALUE)
    {
        PrintCSCEntryInfo(&sFind32, dwStatus, dwPinCount, dwHintFlags, &ftOrgTime);

        while (CSCFindNextFileA(hFind, &sFind32, &dwStatus, &dwPinCount, &dwHintFlags, &ftOrgTime))
        {
            PrintCSCEntryInfo(&sFind32, dwStatus, dwPinCount, dwHintFlags, &ftOrgTime);
        }

        CSCFindClose(hFind);
    }
    else
    {
        dwError = GetLastError();
    }
#else
    memset(uBuff, 0, sizeof(uBuff));
    MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));
    hFind = CSCFindFirstFileW(uBuff, &sFind32, &dwStatus, &dwPinCount, &dwHintFlags, &ftOrgTime);

    if (hFind != INVALID_HANDLE_VALUE)
    {
        PrintCSCEntryInfoW(&sFind32, dwStatus, dwPinCount, dwHintFlags, &ftOrgTime);

        while (CSCFindNextFileW(hFind, &sFind32, &dwStatus, &dwPinCount, &dwHintFlags, &ftOrgTime))
        {
            PrintCSCEntryInfoW(&sFind32, dwStatus, dwPinCount, dwHintFlags, &ftOrgTime);
        }

        CSCFindClose(hFind);
    }
    else
    {
        dwError = GetLastError();
    }
#endif
    return (dwError);
}

DWORD
ProcessCSCDelete(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwError=ERROR_SUCCESS;
#ifdef CSC_ON_NT
    unsigned short uBuff[MAX_PATH];
#endif
    if (argc < 1)
    {
        printf("CSCQueryFileStatusA: must provide a UNC path \r\n");
    }
    else
    {
#ifndef CSC_ON_NT
        if (!CSCDeleteA(argv[0]))
        {
            dwError = GetLastError();   
        }
#else
        memset(uBuff, 0, sizeof(uBuff));
        MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));
        if (!CSCDeleteW(uBuff))
        {
            dwError = GetLastError();   
        }
#endif
    }
    return (dwError);
}

DWORD
ProcessTimeLog(
    DWORD   argc,
    LPSTR   *argv
)
{
    DWORD dwError=ERROR_SUCCESS;
    LPSTR   lpszLogFile;
    FILE *fp= (FILE *)NULL;
    char buff[256];
    int indx = 0;
    LONGLONG llTime = 0;
    DWORD   dwMin, dwSec, dwMSec;
    if (argc < 1)
    {
        printf("No file specified assuming %s\r\n", szDefaultTimeLogFile);
        lpszLogFile = szDefaultTimeLogFile;
    }
    else
    {
        lpszLogFile = argv[0];
    }

    if (fp = fopen(lpszLogFile, "rb")){
        printf("Total time spent by routine \r\n");

         while(fgets(buff, sizeof(buff), fp) != NULL)
         {

            if (sscanf(buff, "%x %x", (DWORD *)&llTime, (DWORD *)(((BYTE *)&llTime)+sizeof(DWORD)))==2)
            {
                dwMin = (DWORD)((llTime/10000000)/60);
                dwSec = (DWORD)((llTime/10000000)%60);

                if (!dwMin && !dwSec)
                {
                    dwMSec = (DWORD)(llTime/10000);
                    printf("%d msecs:   %s\r\n", dwMSec, rgszNameArray[indx]);
                }
                else
                {
                    printf("%d min %d sec:   %s \r\n",
                        dwMin,
                        dwSec,
                        rgszNameArray[indx]);

                }
            }

            ++indx;
         }

         fclose(fp);
    }

    return (dwError);

}

DWORD
ProcessCheckCSC(
    DWORD   argc,
    LPSTR   *argv
    )
{
    CHECKCSCEX  lpCheckCscEx;
    HANDLE  hLib;
    CSCSTATS    sCscStats;
    DWORD dwError=ERROR_SUCCESS;
    BOOL fRet = TRUE;

    if (hLib = LoadLibraryA("cscdll.dll"))
    {
        if (lpCheckCscEx = (CHECKCSCEX)GetProcAddress(hLib, "CheckCSCEx"))
        {
            memset(&sCscStats, 0, sizeof(sCscStats));
#ifndef CSC_ON_NT
            fRet = lpCheckCscEx(argv[0], MyCSCCheckExProc, (DWORD)&sCscStats, 0);    // verify
#else
            fRet = lpCheckCscEx(argv[0], MyCSCCheckExProcW, (DWORD)&sCscStats, 0);    // verify
#endif
        }
        else
        {
            printf("Older version of cscdll \r\n");
            fRet = FALSE;

        }

        FreeLibrary(hLib);
    }

    if (!fRet)
    {
        dwError = GetLastError();
    }
    return dwError;
}

DWORD
ProcessDbCheckCSC(
    DWORD   argc,
    LPSTR   *argv
)
{
    DWORD dwError=ERROR_SUCCESS;
    DWORD   dwLevel=0;
    BOOL fRet = TRUE;
    PRINTPROC lpfnPrintProc = NULL;
#if 0
    PFILE_STREAM_INFORMATION pStream = NULL, pstreamT;
    char buff[1024];

    if (GetStreamInformation((LPCSTR)vszFile, (LPVOID *)&pStream))
    {
        pstreamT = pStream;

        do
        {
            memset(buff, 0, sizeof(buff));

            wcstombs(buff, pstreamT->StreamName, pstreamT->StreamNameLength);

            printf("%s\r\n", buff);

            if (!pstreamT->NextEntryOffset)
            {
                break;
            }

            pstreamT = (PFILE_STREAM_INFORMATION)((LPBYTE)pstreamT + pstreamT->NextEntryOffset);
        }
        while (TRUE);

        LocalFree(pStream);
    }

#endif

    if (argc < 1)
    {
        printf("Usage: check cscdir level{0 for verify, 1 for rebuild}\r\n");
        return (ERROR_INVALID_PARAMETER);
    }
    else if (argc>1)
    {
        dwLevel = *argv[1] - '0';
    }

    if (dwLevel > 1)
    {
        printf("Usage: check cscdir level{0 for verify, 1 for rebuild}\r\n");
        return (ERROR_INVALID_PARAMETER);
    }

    printf("Calling CheckCSC with cscdir=%s level=%d \r\n", argv[0], dwLevel);

    switch (dwLevel)
    {
        case 0:
            fRet = CheckCSC(argv[0], FALSE); // don't fix
            break;
        case 1:
            fRet = CheckCSC(argv[0], TRUE);  // fix
            break;
        default:
            break;
    }
    if (!fRet)
    {
        dwError = GetLastError();
    }
    return dwError;
}

DWORD
ProcessCSCFill(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwError=ERROR_FILE_NOT_FOUND;
#ifdef CSC_ON_NT
    unsigned short uBuff[MAX_PATH];
#endif

    if (argc>=1)
    {
#ifndef CSC_ON_NT
        if (!CSCFillSparseFilesA((const char *)argv[0], FALSE, MyCSCProc, 0))
        {
            dwError = GetLastError();
        }
        else
        {
            dwError = ERROR_SUCCESS;
        }
#else
        memset(uBuff, 0, sizeof(uBuff));
        MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));

        if (!CSCFillSparseFilesW((const unsigned short *)uBuff, FALSE, MyCSCProcW, 0))
        {
            dwError = GetLastError();
        }
        else
        {
            dwError = ERROR_SUCCESS;
        }
#endif
    }
    return dwError;
}

DWORD
ProcessCSCMerge(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwError=ERROR_FILE_NOT_FOUND;
#ifdef CSC_ON_NT
    unsigned short uBuff[MAX_PATH];
#endif

    if (argc>=1)
    {
#ifndef CSC_ON_NT
        if (!CSCMergeShareA((const char *)(argv[0]), MyCSCProc, 0))
        {
            dwError = GetLastError();
        }
        else
        {
            dwError = ERROR_SUCCESS;
        }
#else
        memset(uBuff, 0, sizeof(uBuff));
        MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));
        if (!CSCMergeShareW((const unsigned short *)uBuff, MyCSCProcW, 0))
        {
            dwError = GetLastError();
        }
        else
        {
            dwError = ERROR_SUCCESS;
        }
        CSCTransitionServerOnlineW((const unsigned short *)uBuff);
#endif

    }
    return dwError;
}

DWORD
ProcessCSCCopyReplica(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwError=ERROR_FILE_NOT_FOUND;
#ifdef CSC_ON_NT
    LPWSTR  lpszTempName = NULL;
    unsigned short uBuff[MAX_PATH];
#else
    LPSTR  lpszTempName = NULL;
#endif

    if (argc>=1)
    {
#ifndef CSC_ON_NT
        if (!CSCCopyReplicaA((const char *)argv[0], &lpszTempName))
        {
            dwError = GetLastError();
        }
        else
        {
            dwError = ERROR_SUCCESS;
        }
#else
        memset(uBuff, 0, sizeof(uBuff));
        MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));

        if (!CSCCopyReplicaW((const unsigned short *)uBuff, &lpszTempName))
        {
            dwError = GetLastError();
        }
        else
        {
            dwError = ERROR_SUCCESS;
        }
#endif
    }

    if (dwError == ERROR_SUCCESS)
    {

#ifdef CSC_ON_NT
        OutputDebugStringW(lpszTempName);
        OutputDebugStringW(L"\r\n");
#else
        OutputDebugStringA(lpszTempName);
        OutputDebugStringA("\r\n");
#endif
    }

    return dwError;
}



DWORD
ProcessCSCEnumForStats(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwError=ERROR_FILE_NOT_FOUND;
    CSCSTATS   sStats;
#ifdef CSC_ON_NT
    unsigned short uBuff[MAX_PATH];
#endif

    memset(&sStats, 0, sizeof(sStats));
#ifndef CSC_ON_NT
        if (!CSCEnumForStatsA((argc >=1)?(const char *)(argv[0]):NULL, MyCSCEnumForStatsProc, (DWORD)&sStats))
        {
            dwError = GetLastError();
        }
        else
        {
            dwError = ERROR_SUCCESS;
        }
#else
        if (argc >= 1)
        {
            memset(uBuff, 0, sizeof(uBuff));
            MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));
        }
        if (!CSCEnumForStatsW((argc>=1)?(const unsigned short *)uBuff:NULL, MyCSCEnumForStatsProcW, (DWORD)&sStats))
        {
            dwError = GetLastError();
        }
        else
        {
            dwError = ERROR_SUCCESS;
        }
#if 0
        if (argc < 1)
        {
            DWORD   dwMaxSpaceHigh, dwMaxSpaceLow, dwCurrentSpaceHigh, dwCurrentSpaceLow, cntTotalFiles, cntTotalDirs;

            if(CSCGetSpaceUsageW(uBuff, sizeof(uBuff),
                                &dwMaxSpaceHigh, &dwMaxSpaceLow,
                                &dwCurrentSpaceHigh, &dwCurrentSpaceLow,
                                &cntTotalFiles, &cntTotalDirs))
            {
                printf("\r\n Space Stats \r\n");
                printf("CSC directory location: %ls \r\n", uBuff);
                printf("MaxSpace=%d, CurrentSpaceUsed=%d, Fnles=%d Dirs=%d \r\n", dwMaxSpaceLow, dwCurrentSpaceLow, cntTotalFiles, cntTotalDirs);
            }
            else
            {
                printf("Error=%d in CSCGetSpaceUsage\r\n", GetLastError());
            }
        }
#endif
#endif
    if (dwError == ERROR_SUCCESS)
    {
        printf("Stats\n");
        printf("Total = %d, files=%d dirs=%d sparse=%d dirty=%d pinned=%d pinnedAndSparse=%d\r\n",
            sStats.dwTotal,
            sStats.dwTotalFiles,
            sStats.dwTotalDirs,
            sStats.dwSparseFiles,
            sStats.dwDirtyFiles,
            sStats.dwPinned,
            sStats.dwPinnedAndSparse

        );
    }
    return dwError;
}


DWORD
ProcessCSCDoLocalRename(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwError=ERROR_FILE_NOT_FOUND;
#ifdef CSC_ON_NT
    unsigned short uBuffSrc[MAX_PATH], uBuffDst[MAX_PATH];
#endif


    if (argc<2)
    {
        printf("Usage: ren source_name dest_dir [optional character to indicate replace]\r\n");
        return ERROR_INVALID_PARAMETER;
    }

#ifndef CSC_ON_NT
    dwError = ERROR_CALL_NOT_IMPLEMENTED;
#else
    memset(uBuffSrc, 0, sizeof(uBuffSrc));
    MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuffSrc, MAX_PATH*sizeof(unsigned short));

    memset(uBuffDst, 0, sizeof(uBuffDst));
    MultiByteToWideChar(CP_ACP, 0, argv[1], strlen(argv[1]), uBuffDst, MAX_PATH*sizeof(unsigned short));

    if (!CSCDoLocalRenameW(uBuffSrc, uBuffDst, (argc > 2)))
    {
        dwError = GetLastError();
    }
    else
    {
        dwError = ERROR_SUCCESS;
    }
#endif
    return dwError;
}

DWORD
ProcessCSCDoEnableDisable(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwError=ERROR_FILE_NOT_FOUND;

    if (argc<1)
    {
        printf("Usage: endis fEnable\r\n");
        return ERROR_INVALID_PARAMETER;
    }

#ifndef CSC_ON_NT
    dwError = ERROR_CALL_NOT_IMPLEMENTED;
#else

    if (!CSCDoEnableDisable(*argv[0]!='0'))
    {
        dwError = GetLastError();
    }
    else
    {
        dwError = ERROR_SUCCESS;
    }
#endif
    return dwError;
}


DWORD
ProcessDoRandomWrites(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwError=ERROR_SUCCESS, dwFileSize, dwOffset, dwOffsetHigh;
    unsigned short uBuff[MAX_PATH];
    unsigned char   uchData;
    
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    int i, count;
        
    if (argc>=1)
    {
        memset(uBuff, 0, sizeof(uBuff));
        MultiByteToWideChar(CP_ACP, 0, argv[0], strlen(argv[0]), uBuff, MAX_PATH*sizeof(unsigned short));
        hFile = CreateFileW(
                        uBuff,                              // name
                        GENERIC_READ|GENERIC_WRITE,         // access mode
                        FILE_SHARE_READ|FILE_SHARE_WRITE,   // share mode
                        NULL,                               // security descriptor
                        OPEN_EXISTING,                      // create disposition
                        0,                                  // file statributes if created
                        NULL);                              // template handle
#if LARGE_FILE
        hFile = CreateFileW(
                        uBuff,                              // name
                        GENERIC_READ|GENERIC_WRITE,         // access mode
                        FILE_SHARE_READ|FILE_SHARE_WRITE,   // share mode
                        NULL,                               // security descriptor
                        OPEN_ALWAYS,                      // create disposition
                        0,                                  // file statributes if created
                        NULL);                              // template handle
#endif

        if (hFile != INVALID_HANDLE_VALUE)
        {
            dwFileSize = GetFileSize(hFile, NULL);
            if (dwFileSize == -1)
            {
                dwError = GetLastError();
                goto bailout;
            }
            if (dwFileSize == 0)
            {
                printf("0 sized file \n");
                goto bailout;
            }
            
            srand( (unsigned)time( NULL ) );
            
//            count = rand() % 100;
            count = 2;

            printf("writing %d times \n", count);
                        
            for (i=0; i< count; ++i)
            {
                DWORD   dwReturn;
                
                dwOffset = rand() % dwFileSize;
                uchData = (unsigned char)rand();

                if (SetFilePointer(hFile, dwOffset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
                {
                    dwError = GetLastError();
                    printf("Failed SetFilePointer %d \n", dwError);
                    goto bailout;
                }

                printf("writing %c at %d \n", uchData, dwOffset);
                
                if (!WriteFile(hFile, &uchData, 1, &dwReturn, NULL))
                {
                    dwError = GetLastError();
                    printf("Failed write with error %d \n", dwError);
                    goto bailout;
                }
            }
        }
#if LARGE_FILE
                dwOffsetHigh = 1;
                if (SetFilePointer(hFile, 0x400000, &dwOffsetHigh, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
                {
                    dwError = GetLastError();
                    printf("Failed SetFilePointer %d \n", dwError);
                    goto bailout;
                }
                
                if (!SetEndOfFile(hFile))
                {
                    dwError = GetLastError();
                    printf("Failed SetEof %d \n", dwError);
                    goto bailout;
                }
#endif
    }
    
bailout:
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }
    return dwError;
}




VOID
PrintBuffer(
    LPSTR   lpszBuff
    )
{
    printf(lpszBuff);
}

//=================================================================================
DWORD
ProcessCommandCode (
    DWORD CommandCode,
    DWORD CommandArgc,
    LPSTR *CommandArgv
    )
{
    DWORD Error = ERROR_SUCCESS;

        switch( CommandCode ) {
            case CmdCSCPinFile:
                Error = ProcessCSCPinFile(CommandArgc, CommandArgv);
            break;

            case CmdCSCUnPinFile:
                Error = ProcessCSCUnPinFile(CommandArgc, CommandArgv);
            break;
            case CmdCSCQueryFileStatus:
                Error = ProcessCSCQueryFileStatus(CommandArgc, CommandArgv);
            break;
            case CmdCSCEnum:
                Error = ProcessCSCEnum(CommandArgc, CommandArgv);
            break;
            case CmdCSCDelete:
                Error = ProcessCSCDelete(CommandArgc, CommandArgv);
            break;
            case CmdHelp:
                DisplayUsage();
            break;
            case CmdTimeLog:
                Error = ProcessTimeLog(CommandArgc, CommandArgv);
            break;
            case CmdCheckCSC:
                Error = ProcessCheckCSC(CommandArgc, CommandArgv);
            break;
            case CmdDbCheckCSC:
                Error = ProcessDbCheckCSC(CommandArgc, CommandArgv);
            break;
            case CmdCSCFill:
                Error = ProcessCSCFill(CommandArgc, CommandArgv);
            break;
            case CmdCSCMerge:
                Error = ProcessCSCMerge(CommandArgc, CommandArgv);
            break;
            case CmdCSCCopyReplica:
                Error = ProcessCSCCopyReplica(CommandArgc, CommandArgv);
            break;
            case CmdCSCEnumForStats:
                Error = ProcessCSCEnumForStats(CommandArgc, CommandArgv);
            break;
            case CmdCSCDoLocalRename:
                Error = ProcessCSCDoLocalRename(CommandArgc, CommandArgv);
                break;
            case CmdCSCDoEnableDisable:
                Error = ProcessCSCDoEnableDisable(CommandArgc, CommandArgv);
                break;
            case CmdShowTime:
                Error = ProcessShowTime( CommandArgc, CommandArgv );
                break;
            case CmdEncryptDecrypt:
                Error = ProcessEncryptDecrypt(CommandArgc, CommandArgv );
                break;
            case CmdDoRandomWrites:
                Error = ProcessDoRandomWrites(CommandArgc, CommandArgv );
                break;
            case CmdQuit :
                exit (0);

        default:
            TestDbgAssert( FALSE );
            fprintf(stderr, "Unknown Command Specified.\n");
            DisplayUsage();
            break;
        }
        cCommands++;

        if( Error != ERROR_SUCCESS ) {
            LPSTR lpstr;

            cFails++;
            Format_Error(Error, &lpstr);
            printf("FAILED (%s), %ld-%s.\n",
                GlobalCommandInfo[CommandCode].CommandName, Error, lpstr );
            LocalFree(lpstr);
        }
        else {
            if(!g_bQuietMode)
                printf("Command (%s) successfully completed.\n", GlobalCommandInfo[CommandCode].CommandName );
        }
        return Error;
}


//=================================================================================
VOID
__cdecl
main(
    int argc,
    char *argv[]
    )
{

    DWORD Error;
    COMMAND_CODE CommandCode;
    CHAR InBuffer[DEFAULT_BUFFER_SIZE];
    DWORD CArgc;
    LPSTR CArgv[MAX_COMMAND_ARGS];
    unsigned u1 = 1, u2 = 0xffffffff;

    DWORD CommandArgc;
    LPSTR *CommandArgv;

    printf("u1=0x%x u2=0x%x, (int)(u1-u2)=%d, (u1-u2)=0x%x \r\n", u1, u2, (int)(u1-u2), (u1-u2));

    /* must check for batch mode.  if there are command line parms, assume batch mode */
    if (argc > 1)
    {
        //this means that the arguments translate directly into CommandArgc....
        CommandCode = DecodeCommand( argv[1] );
        if( CommandCode == UnknownCommand ) {
            printf("Unknown Command Specified.\n");
            return;
        }

        CommandArgc = argc - 2;
        CommandArgv = &argv[2];

        Error = ProcessCommandCode (CommandCode,CommandArgc,CommandArgv);

        if (DumpUncList)
            fclose(DumpUncList);
        if (UncList)
            fclose(UncList);

        return;
    }

    DisplayUsage();

    for(;;) {

        fprintf(stderr,  "Command : " );

        gets( InBuffer );

        CArgc = 0;
        ParseArguments( InBuffer, CArgv, &CArgc );

        if( CArgc < 1 ) {
            continue;
        }

        //
        // decode command.
        //

        CommandCode = DecodeCommand( CArgv[0] );
        if( CommandCode == UnknownCommand ) {
            fprintf(stderr, "Unknown Command Specified.\n");
            continue;
        }

        CommandArgc = CArgc - 1;
        CommandArgv = &CArgv[1];

        Error = ProcessCommandCode (CommandCode,CommandArgc,CommandArgv);

    }

    return;
}

//=================================================================================
DWORD
GetLeafLenFromPath(
    LPSTR   lpszPath
    )
{
    DWORD len;
    LPSTR   lpT;

    if(!lpszPath)
        return(0);

    len = lstrlen(lpszPath);

    if (len == 0) {

        return (len);

    }

    lpT = lpszPath+len-1;
    if (*lpT =='\\') {
        --lpT;
    }
    for (; lpT >= lpszPath; --lpT) {
        if (*lpT == '\\') {
            break;
        }
    }
    return (lstrlen(lpT));
}

//=================================================================================
DWORD WINAPIV Format_String(LPSTR *plpsz, LPSTR lpszFmt, ...)
{
    const char c_Func_Name[] = "[Format_String] ";
    DWORD dwRet;
    va_list vArgs;

    va_start (vArgs, lpszFmt);
    dwRet = Format_StringV(plpsz, lpszFmt, &vArgs);
    va_end (vArgs);

    return(dwRet);
}

//=================================================================================
DWORD WINAPI Format_Error(DWORD dwErr, LPSTR *plpsz)
{
    DWORD dwRet;

    if(dwErr != ERROR_SUCCESS)
    {
        dwRet = Format_MessageV(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            dwErr, plpsz, NULL, NULL);
    }
    else
    {
        const char szMsg[] = "No Error";
        Format_String(plpsz, (LPSTR)szMsg);
        dwRet = lstrlen(szMsg);
    }

    return(dwRet);
}

//=================================================================================
DWORD WINAPI Format_StringV(LPSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs)
{
    return(Format_MessageV(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        0, plpsz, lpszFmt, vArgs));
}

// ***************************************************************************
DWORD WINAPI Format_MessageV(DWORD dwFlags, DWORD dwErr, LPSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs)
{
    const char c_Func_Name[] = "[Format_MessageV]";

    DWORD dwRet;
    DWORD dwGLE;

    *plpsz = NULL;
    dwRet = FormatMessage(dwFlags, lpszFmt, dwErr, 0, (LPSTR) plpsz, 0, vArgs);

    if (!dwRet || !*plpsz)
    {
        dwGLE = GetLastError();
        printf("%s FormatMessage Failed: %s. dwRet: %#lx!. *plpsz:%#lx! GLE:%d\r\n", c_Func_Name, lpszFmt, dwRet, *plpsz, dwGLE);

        if (*plpsz)
            LocalFree ((HLOCAL) *plpsz);
        *plpsz = NULL;
        return 0;
    }

    return(dwRet);
}

#if 0
BOOL
GetStreamInformation(
    LPCSTR  lpExistingFileName,
    LPVOID  *lpStreamInformation
    )
{
    HANDLE SourceFile = INVALID_HANDLE_VALUE;
    PFILE_STREAM_INFORMATION StreamInfoBase = NULL;
    ULONG StreamInfoSize;
    IO_STATUS_BLOCK IoStatus;
    BOOL    fRet = FALSE;
    DWORD   Status;

    *lpStreamInformation = NULL;
    SourceFile = CreateFile(
                    lpExistingFileName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );
    if (SourceFile == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }
    //
    //  Obtain the full set of streams we have to copy.  Since the Io subsystem does
    //  not provide us a way to find out how much space this information will take,
    //  we must iterate the call, doubling the buffer size upon each failure.
    //
    //  If the underlying file system does not support stream enumeration, we end up
    //  with a NULL buffer.  This is acceptable since we have at least a default
    //  data stream,
    //

    StreamInfoSize = 4096;
    do {
        StreamInfoBase = LocalAlloc(LPTR, StreamInfoSize );

        if ( !StreamInfoBase ) {
            SetLastError( STATUS_NO_MEMORY );
            goto bailout;
        }

        Status = NtQueryInformationFile(
                    SourceFile,
                    &IoStatus,
                    (PVOID) StreamInfoBase,
                    StreamInfoSize,
                    FileStreamInformation
                    );

        if (Status != STATUS_SUCCESS) {
            //
            //  We failed the call.  Free up the previous buffer and set up
            //  for another pass with a buffer twice as large
            //

            LocalFree(StreamInfoBase);
            StreamInfoBase = NULL;
            StreamInfoSize *= 2;
        }

    } while ( Status == STATUS_BUFFER_OVERFLOW || Status == STATUS_BUFFER_TOO_SMALL );

    if (Status == STATUS_SUCCESS)
    {
        fRet = TRUE;
    }

bailout:

    if (SourceFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(SourceFile);
    }

    *lpStreamInformation = StreamInfoBase;

    return fRet;
}
#endif


#ifdef CSC_ON_NT
BOOL
DoPinningW(
    LPWSTR   lpwzName,
    DWORD   dwHintFlags,
    BOOL    fRecurse
    )
{
    unsigned short uBuff[MAX_PATH];
    WIN32_FIND_DATAW sFind32W;
    HANDLE  hFind = NULL;
    BOOL    fRet = TRUE;
    DWORD   lenName, dwStatus, dwPinCount, dwError;

    lenName = lstrlenW(lpwzName);

    if (lenName < 5)
    {
        return FALSE;
    }

    lstrcpyW(uBuff, lpwzName);

    if (uBuff[lenName-1] == (USHORT)'\\')
    {
        uBuff[lenName-1] = 0;

        --lenName;

        if (lenName < 5)
        {
            return FALSE;
        }
    }

    hFind = FindFirstFileW(uBuff, &sFind32W);
    if (hFind==INVALID_HANDLE_VALUE)
    {
        lstrcatW(uBuff, L"\\*");

        hFind = FindFirstFileW(uBuff, &sFind32W);

        uBuff[lenName] = 0;

        if (hFind==INVALID_HANDLE_VALUE)
        {
            return FALSE;
        }

    }
    else if (sFind32W.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        FindClose(hFind);

        lstrcatW(uBuff, L"\\*");
        hFind = FindFirstFileW(uBuff, &sFind32W);
        uBuff[lenName] = 0;

        if (hFind==INVALID_HANDLE_VALUE)
        {
            return FALSE;
        }
    }

    do
    {
        if (!CSCPinFileW(uBuff, dwHintFlags, &dwStatus, &dwPinCount, &dwHintFlags))
        {
            dwError = GetLastError();   
        }
        else
        {
            PrintCSCEntryInfo(NULL, dwStatus, dwPinCount, dwHintFlags, NULL);
        }

        if (fRecurse)
        {
            do
            {
                if(!FindNextFileW(hFind, &sFind32W))
                {
                    goto bailout;
                }

                if ((!lstrcmpW(sFind32W.cFileName, L"."))||(!lstrcmpW(sFind32W.cFileName, L"..")))
                {
                    continue;
                }

                uBuff[lenName] = (USHORT)'\\';
                uBuff[lenName+1] = 0;
                lstrcatW(uBuff, sFind32W.cFileName);

                if (sFind32W.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    DoPinningW(uBuff, dwHintFlags, fRecurse);
                }

                break;
            }
            while (TRUE);
        }
        else
        {
            break;
        }
    }
    while (TRUE);

bailout:
    if (hFind)
    {
        FindClose(hFind);
    }
    return fRet;
}

#else

BOOL
DoPinningA(
    LPSTR   lpszName,
    DWORD   dwHintFlags,
    BOOL    fRecurse
    )
{
    char chBuff[MAX_PATH];
    WIN32_FIND_DATAA sFind32A;
    HANDLE  hFind = NULL;
    BOOL    fRet = TRUE;
    DWORD   lenName, dwStatus, dwPinCount, dwError;


    lenName = lstrlen(lpszName);

    if (lenName < 5)
    {
        return FALSE;
    }

    lstrcpy(chBuff, lpszName);

    if (chBuff[lenName-1] == (USHORT)'\\')
    {
        chBuff[lenName-1] = 0;
        --lenName;
        if (lenName < 5)
        {
            return FALSE;
        }
    }

    hFind = FindFirstFileA(chBuff, &sFind32A);

    if (hFind==INVALID_HANDLE_VALUE)
    {
        lstrcatA(chBuff, "\\*");
        hFind = FindFirstFileA(chBuff, &sFind32A);
        if (hFind==INVALID_HANDLE_VALUE)
        {
            return FALSE;
        }
        chBuff[lenName] = 0;
    }

    if (sFind32A.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        FindClose(hFind);

        lstrcatA(chBuff, "\\*");
        hFind = FindFirstFileA(chBuff, &sFind32A);

        if (hFind==INVALID_HANDLE_VALUE)
        {
            return FALSE;
        }
        chBuff[lenName] = 0;
    }

    do
    {
        if (!CSCPinFileA(chBuff, dwHintFlags, &dwStatus, &dwPinCount, &dwHintFlags))
        {
            dwError = GetLastError();   
        }
        else
        {
            PrintCSCEntryInfo(NULL, dwStatus, dwPinCount, dwHintFlags, NULL);
        }

        if (fRecurse)
        {
            if(!FindNextFile(hFind, &sFind32A))
            {
                goto bailout;
            }

            chBuff[lenName] = '\\';
            lstrcat(chBuff, sFind32A.cFileName);

            if (sFind32A.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                DoPinningA(chBuff, dwHintFlags, fRecurse);
            }
        }
        else
        {
            break;
        }
    }
    while (TRUE);

bailout:
    if (hFind)
    {
        FindClose(hFind);
    }
    return fRet;
}

#endif


//=================================================================================
DWORD
ProcessShowTime (
    DWORD argc,
    LPSTR *argv
    )
{
    DWORD Error, dwSize;
    FILETIME ftTemp;
    SYSTEMTIME SystemTime;

    if(argc != 2)
        return 0xffffffff;

    sscanf(argv[0], "%x", &(ftTemp.dwHighDateTime));
    sscanf(argv[1], "%x", &(ftTemp.dwLowDateTime));

    if(FileTimeToSystemTime( &ftTemp, &SystemTime )) {
        printf("%02u/%02u/%04u %02u:%02u:%02u\n ",
                    SystemTime.wMonth,
                    SystemTime.wDay,
                    SystemTime.wYear,
                    SystemTime.wHour,
                    SystemTime.wMinute,
                    SystemTime.wSecond );

    }
    else {
        printf("Wrong Times \n");
    }

    return ERROR_SUCCESS;
}

DWORD
ProcessEncryptDecrypt(
    DWORD   argc,
    LPSTR   *argv
)
{

    DWORD dwStatus, dwError=ERROR_SUCCESS;
    BOOL    fEncrypt = FALSE;
#ifdef CSC_ON_NT
    unsigned short uBuff[MAX_PATH];
#endif

    if (argc != 1)
    {
        printf("CSCUnPinFile: must provide a UNC path \r\n");
    }
    else
    {
        fEncrypt = !((*argv[0] == 'u')||(*argv[0] == 'U'));            
        if (argc == 1)
        {
            if(!CSCEncryptDecryptDatabase(fEncrypt, NULL, 0))
            {
                dwError = GetLastError();   
            }
        }
        else
        {
#if 0
            memset(uBuff, 0, sizeof(uBuff));
            MultiByteToWideChar(CP_ACP, 0, argv[1], strlen(argv[1]), uBuff, MAX_PATH*sizeof(unsigned short));

            if (!CSCEncryptDecryptFileW(uBuff, fEncrypt))
            {
                dwError = GetLastError();   
            }
#endif
        }
    }
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\util\cscgetloc\cscgetloc.c ===
#define UNICODE
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winioctl.h>
#include <shdcom.h>

#include <smbdebug.h>

CHAR *ProgName = "cscgetinfo";

PBYTE InBuf[0x50];
PBYTE OutBuf = NULL;

#define STATUS_SUCCESS                   ((ULONG)0x00000000L)
#define STATUS_BUFFER_TOO_SMALL          ((ULONG)0xC0000023L)


_cdecl
main(LONG argc, CHAR *argv[])
{
    BOOL bResult;
    HANDLE  hShadow=NULL;
    ULONG junk;
    SHADOWINFO sSI;
    WIN32_FIND_DATAW Find32W;

    printf("Starting....\n");

    hShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hShadow == INVALID_HANDLE_VALUE) {
        printf("Failed open of shadow device\n");
        return 0;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uStatus = SHADOW_SWITCH_SHADOWING;
    sSI.uOp = SHADOW_SWITCH_GET_STATE;
    sSI.lpFind32 = &Find32W;

    bResult = DeviceIoControl(
                hShadow,                        // device 
                IOCTL_SWITCHES,                 // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // in buffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    CloseHandle(hShadow);

    printf("cFileName:%ws\n", Find32W.cFileName);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\usermode\reint\utils.h ===
#include "shdcom.h"
#include "oslayeru.h"

LPTSTR PUBLIC LpGetServerPart(LPTSTR, LPTSTR, int);
LPTSTR PUBLIC LpGetNextPathElement(LPTSTR, LPTSTR, int);
LPTSTR PUBLIC GetLeafPtr(LPTSTR);

#if 0
BOOL PUBLIC FMatchFile(LPTSTR lpFileName, LPBYTE lpList);
BOOL PUBLIC ExtnMatch(LPTSTR, LPTSTR);
BOOL PUBLIC PrefixMatch(LPTSTR, LPTSTR);
#endif

void DebugPrint(char *szFmt, ...);

LPTSTR
LpBreakPath(
	LPTSTR lpszNextPath,
	BOOL fFirstTime,
	BOOL *lpfDone
	);

void
RestorePath(
	LPTSTR	lpszPtr
);

BOOL
FindCreateShadowFromPath(
	LPCTSTR	lpszFile,
	BOOL	fCreate,	// create if necessary
	LPWIN32_FIND_DATA lpsFind32,
	LPSHADOWINFO lpSI,
	BOOL	*lpfCreated
);

BOOL
IsShareReallyConnected(
    LPCTSTR  lpszShareName
);

BOOL
AnyActiveNets(
    BOOL *lpfSlowLink
    );

BOOL
GetWideStringFromRegistryString(
    IN  LPSTR   lpszKeyName,    // registry key
    IN  LPSTR   lpszParameter,  // registry value name
    OUT LPWSTR  *lplpwzList,    // wide character string
    OUT LPDWORD lpdwLength      // length in bytes
    );

LPTSTR
GetTempFileForCSC(
    LPTSTR  lpszBuff
    );

BOOL
SetRegValueDWORDA(
    IN  HKEY    hKey,
    IN  LPCSTR  lpSubKey,
    IN  LPCSTR  lpValueName,
    IN  DWORD   dwValue
    );

BOOL
QueryRegValueDWORDA(
    IN  HKEY    hKey,
    IN  LPCSTR  lpSubKey,
    IN  LPCSTR  lpValueName,
    OUT LPDWORD lpdwValue
    );

BOOL
DeleteRegValueA(
    IN  HKEY    hKey,
    IN  LPCSTR  lpSubKey,
    IN  LPCSTR  lpValueName
    );
BOOL
GetDiskSizeFromPercentage(
    LPSTR       lpszDir,
    unsigned    uPercent,
    DWORD       *lpdwSize,
    DWORD       *lpdwClusterSize
    );


BOOL
InitValues(
    LPSTR   lpszDBDir,
    DWORD   cbDBDirSize,
    LPDWORD lpdwDBCapacity,
    LPDWORD lpdwClusterSize
    );

BOOL
QueryFormatDatabase(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\util\cscqueryinfo\cscqueryinfo.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <cscapi.h>
#include "lmcons.h"
#include "lmuse.h"

VOID __cdecl
main(
    int argc,
    char *argv[])
{
    // PWCHAR pFileName = L"\\\\jharperdc1\\vdo\\xx\\yy.txt";
    PWCHAR pFileName = L"\\\\jharperdc1\\jim\\jim.txt";
    DWORD Status = 0;
    DWORD PinCount = 0;
    DWORD HintFlags = 0;
    DWORD UserPerms = 0;
    DWORD OtherPerms = 0;
    DWORD QueryStatus = 0;

    QueryStatus = CSCQueryFileStatusExW(
                            pFileName,
                            &Status,
                            &PinCount,
                            &HintFlags,
                            &UserPerms,
                            &OtherPerms);
    printf("CSCQueryFileStatus(%ws) returned %d(0x%x)\n", pFileName, QueryStatus, QueryStatus);

    if (QueryStatus > 0) {
        printf(
            "Status:  0x%x\n"
            "PinCount:  0x%x\n"
            "HintFlags:  0x%x\n"
            "UserPerms:  0x%x\n"
            "OtherPerms:  0x%x\n",
                    Status,
                    PinCount,
                    HintFlags,
                    UserPerms,
                    OtherPerms);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\util\cscutil\cscutil.c ===
#define UNICODE
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winioctl.h>
#include <shdcom.h>
#include <shellapi.h>
#include <smbdebug.h>
#include <time.h>

#include "struct.h"
#include "messages.h"
#include "cscapi.h"

CHAR *ProgName = "cscutil";

#define CSC_MERGE_KEEP_LOCAL   1
#define CSC_MERGE_KEEP_NETWORK 2
#define CSC_MERGE_KEEP_BOTH    3

//
// Arguments (ie '/arg:')
//
MAKEARG(Pin);
MAKEARG(UnPin);
MAKEARG(Delete);
MAKEARG(DeleteShadow);
MAKEARG(GetShadow);
MAKEARG(GetShadowInfo);
MAKEARG(ShareId);
MAKEARG(Fill);
MAKEARG(Db);
MAKEARG(SetShareStatus);
MAKEARG(Purge);
MAKEARG(IsServerOffline);
MAKEARG(EnumForStats);
MAKEARG(SetSpace);
MAKEARG(Merge);
MAKEARG(QueryFile);
MAKEARG(QueryFileEx);
MAKEARG(QueryShare);
MAKEARG(Check);
MAKEARG(ExclusionList);
MAKEARG(BWConservationList);
MAKEARG(Disconnect);
MAKEARG(Reconnect);
MAKEARG(Enum);
MAKEARG(Move);
MAKEARG(Bitcopy);
MAKEARG(RandW);
MAKEARG(Offset);

//
// Switches (ie '/arg')
//
SWITCH(Info);
SWITCH(Fcblist);
SWITCH(DBStatus);
SWITCH(PQEnum);
SWITCH(User);
SWITCH(System);
SWITCH(Inherit);
SWITCH(Recurse);
SWITCH(Abort);
SWITCH(Skip);
SWITCH(Ask);
SWITCH(Eof);
SWITCH(Retry);
SWITCH(Touch);
SWITCH(Enable);
SWITCH(Disable);
SWITCH(Ioctl);
SWITCH(Flags);
SWITCH(GetSpace);
SWITCH(Encrypt);
SWITCH(Decrypt);
SWITCH(Db);
SWITCH(Set);
SWITCH(Clear);
SWITCH(Purge);
SWITCH(Detector);
SWITCH(Switches);

SWITCH(Debug);
SWITCH(Help);
SWITCH(HelpHelp);
SWITCH(Enum);
SWITCH(Resid);
SWITCH(Full);

//
// The macro can not make these
//

WCHAR SwQ[] = L"/?";
BOOLEAN fSwQ;
WCHAR SwQQ[] = L"/??";
BOOLEAN fSwQQ;

//
// Globals
//
LPWSTR pwszDisconnectArg = NULL;
LPWSTR pwszExclusionListArg = NULL;
LPWSTR pwszBWConservationListArg = NULL;
LPWSTR pwszSetShareStatusArg = NULL;
LPWSTR pwszIsServerOfflineArg = NULL;
LPWSTR pwszPurgeArg = NULL;
LPWSTR pwszPinUnPinArg = NULL;
LPWSTR pwszDeleteArg = NULL;
LPWSTR pwszDeleteShadowArg = NULL;
LPWSTR pwszGetShadowArg = NULL;
LPWSTR pwszGetShadowInfoArg = NULL;
LPWSTR pwszShareIdArg = NULL;
LPWSTR pwszReconnectArg = NULL;
LPWSTR pwszQueryFileArg = NULL;
LPWSTR pwszQueryFileExArg = NULL;
LPWSTR pwszDbArg = NULL;
LPWSTR pwszSetSpaceArg = NULL;
LPWSTR pwszQueryShareArg = NULL;
LPWSTR pwszMoveArg = NULL;
LPWSTR pwszMergeArg = NULL;
LPWSTR pwszFillArg = NULL;
LPWSTR pwszEnumArg = NULL;
LPWSTR pwszRandWArg = NULL;
LPWSTR pwszBitcopyArg = NULL;
LPWSTR pwszOffsetArg = NULL;
LPWSTR pwszEnumForStatsArg = NULL;
LPWSTR pwszCheckArg = NULL;

DWORD
Usage(
    BOOLEAN fHelpHelp);

BOOLEAN
CmdProcessArg(
    LPWSTR Arg);

DWORD
CmdInfo(
    ULONG Cmd);

DWORD
CmdDBStatus(
    VOID);

DWORD
CmdPurge(
    PWSTR PurgeArg);

DWORD
CmdDetector(
    VOID);

DWORD
CmdPQEnum(
    VOID);

DWORD
CmdGetSpace(
    VOID);

DWORD
CmdSwitches(
    VOID);

DWORD
CmdDisconnect(
    PWSTR DisconnectArg);

DWORD
CmdExclusionList(
    PWSTR ExclusionListArg);

DWORD
CmdBWConservationList(
    PWSTR BWConservationListArg);

DWORD
CmdSetShareStatus(
    PWSTR SetShareStatusArg);

DWORD
CmdIsServerOffline(
    PWSTR IsServerOfflineArg);

DWORD
CmdReconnect(
    PWSTR ReconnectArg);

DWORD
CmdQueryFile(
    PWSTR QueryFileArg);

DWORD
CmdQueryFileEx(
    PWSTR QueryFileExArg);

DWORD
CmdDb(
    PWSTR DbArg);

DWORD
CmdSetSpace(
    PWSTR SetSpaceArg);

DWORD
CmdQueryShare(
    PWSTR QueryShareArg);

DWORD
CmdMove(
    PWSTR MoveArg);

DWORD
CmdMerge(
    PWSTR MergeArg);

DWORD
CmdEncryptDecrypt(
    BOOL fEncrypt);

DWORD
CmdFill(
    PWSTR FillArg);

DWORD
CmdCheck(
    PWSTR CheckArg);

DWORD
CmdEnum(
    PWSTR CmdEnumArg);

DWORD
CmdRandW(
    PWSTR CmdRandWArg);

DWORD
CmdBitcopy(
    PWSTR CmdBitcopyArg);

DWORD
CmdEnumForStats(
    PWSTR EnumForStatsArg);

DWORD
CmdDelete(
    PWSTR DeleteArg);

DWORD
CmdGetShadow(
    PWSTR GetShadowArg);

DWORD
CmdGetShadowInfo(
    PWSTR GetShadowInfoArg);

DWORD
CmdShareId(
    PWSTR ShareIdArg);

DWORD
CmdDeleteShadow(
    PWSTR DeleteArg);

DWORD
CmdPinUnPin(
    BOOL fPin,
    PWSTR PinArg);

DWORD
CscMergeFillAsk(
    LPCWSTR lpszFullPath);

DWORD
MyCscMergeProcW(
     LPCWSTR         lpszFullPath,
     DWORD           dwStatus,
     DWORD           dwHintFlags,
     DWORD           dwPinCount,
     WIN32_FIND_DATAW *lpFind32,
     DWORD           dwReason,
     DWORD           dwParam1,
     DWORD           dwParam2,
     DWORD_PTR       dwContext);

DWORD
MyCscFillProcW(
     LPCWSTR         lpszFullPath,
     DWORD           dwStatus,
     DWORD           dwHintFlags,
     DWORD           dwPinCount,
     WIN32_FIND_DATAW *lpFind32,
     DWORD           dwReason,
     DWORD           dwParam1,
     DWORD           dwParam2,
     DWORD_PTR       dwContext);

DWORD
MyEncryptDecryptProcW(
     LPCWSTR         lpszFullPath,
     DWORD           dwStatus,
     DWORD           dwHintFlags,
     DWORD           dwPinCount,
     WIN32_FIND_DATAW *lpFind32,
     DWORD           dwReason,
     DWORD           dwParam1,
     DWORD           dwParam2,
     DWORD_PTR       dwContext);

DWORD
MyEnumForStatsProcW(
     LPCWSTR         lpszFullPath,
     DWORD           dwStatus,
     DWORD           dwHintFlags,
     DWORD           dwPinCount,
     WIN32_FIND_DATAW *lpFind32,
     DWORD           dwReason,
     DWORD           dwParam1,
     DWORD           dwParam2,
     DWORD_PTR       dwContext);

DWORD
FileStatusToEnglish(
    DWORD Status,
    LPWSTR OutputBuffer);

DWORD
HintsToEnglish(
    DWORD Hint,
    LPWSTR OutputBuffer);

DWORD
ShareStatusToEnglish(
    DWORD Status,
    LPWSTR OutputBuffer);

BOOLEAN
LooksToBeAShare(LPWSTR Name);

LONG
CountOffsetArgs(
    PWSTR OffsetArg,
    ULONG OffsetArray[]);

DWORD
DumpBitMap(
    LPWSTR lpszTempName);

VOID
ErrorMessage(
    IN HRESULT hr,
    ...);

WCHAR NameBuf[MAX_PATH + 25];

WCHAR vtzDefaultExclusionList[] = L" *.SLM *.MDB *.LDB *.MDW *.MDE *.PST *.DB?"; // from ui.c

//
// These functions were added for Windows XP, and so we do a loadlibrary on them, so that
// this utility will work on both Windows 2000 and Windows XP
//
typedef BOOL (*CSCQUERYFILESTATUSEXW)(LPCWSTR, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD);
typedef BOOL (*CSCQUERYSHARESTATUSW)(LPCWSTR, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD);
typedef BOOL (*CSCPURGEUNPINNEDFILES)(ULONG, PULONG, PULONG);
typedef BOOL (*CSCENCRYPTDECRYPTDATABASE)(BOOL, LPCSCPROCW, DWORD_PTR);
typedef BOOL (*CSCSHAREIDTOSHARENAME)(ULONG, PBYTE, PULONG);

_cdecl
main(int argc, char *argv[])
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR CommandLine;
    LPWSTR *argvw;
    int argx;
    int argcw;

    // fSwDebug = TRUE;

    //
    // Get the command line in Unicode
    //

    CommandLine = GetCommandLine();

    argvw = CommandLineToArgvW(CommandLine, &argcw);

    if ( argvw == NULL ) {
        MyPrintf(L"cscutil:Can't convert command line to Unicode: %d\r\n", GetLastError() );
        return 1;
    }

    //
    // Get the arguments
    //
    if (argcw <= 1) {
        Usage(FALSE);
        dwErr = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // Process arguments
    //

    for (argx = 1; argx < argcw; argx++) {
        if (CmdProcessArg(argvw[argx]) != TRUE) {
            dwErr = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    if (fSwDebug == TRUE) {
        MyPrintf(L"Do special debug stuff here\r\n");
    }

    //
    // Do the work
    //
    if (fSwHelp == TRUE || fSwQ == TRUE) {
        dwErr = Usage(FALSE);
    } else if (fSwHelpHelp == TRUE || fSwQQ == TRUE) {
        dwErr = Usage(TRUE);
    } else if (fSwInfo == TRUE) {
        dwErr = CmdInfo(DEBUG_INFO_SERVERLIST);
    } else if (fSwFcblist == TRUE) {
        dwErr = CmdInfo(DEBUG_INFO_CSCFCBSLIST);
    } else if (fSwGetSpace == TRUE) {
        dwErr = CmdGetSpace();
    } else if (fSwDBStatus == TRUE) {
        dwErr = CmdDBStatus();
    } else if (fArgPurge == TRUE) {
        dwErr = CmdPurge(pwszPurgeArg);
    } else if (fSwPurge == TRUE) {
        dwErr = CmdPurge(NULL);
    } else if (fSwDetector == TRUE) {
        dwErr = CmdDetector();
    } else if (fSwPQEnum == TRUE) {
        dwErr = CmdPQEnum();
    } else if (fSwFlags == TRUE) {
        ErrorMessage(MSG_FLAGS);
        dwErr = ERROR_SUCCESS;
    } else if (fSwEnable == TRUE) {
        dwErr = (CSCDoEnableDisable(TRUE) == TRUE) ? ERROR_SUCCESS : GetLastError();
    } else if (fSwDisable == TRUE) {
        dwErr = (CSCDoEnableDisable(FALSE) == TRUE) ? ERROR_SUCCESS : GetLastError();
    } else if (fSwSwitches == TRUE) {
        dwErr = CmdSwitches();
    } else if (fArgDisconnect == TRUE) {
        dwErr = CmdDisconnect(pwszDisconnectArg);
    } else if (fArgExclusionList == TRUE) {
        dwErr = CmdExclusionList(pwszExclusionListArg);
    } else if (fArgBWConservationList == TRUE) {
        dwErr = CmdBWConservationList(pwszBWConservationListArg);
    } else if (fArgSetShareStatus == TRUE) {
        dwErr = CmdSetShareStatus(pwszSetShareStatusArg);
    } else if (fArgIsServerOffline == TRUE) {
        dwErr = CmdIsServerOffline(pwszIsServerOfflineArg);
    } else if (fArgReconnect == TRUE) {
        dwErr = CmdReconnect(pwszReconnectArg);
    } else if (fArgQueryFile == TRUE) {
        dwErr = CmdQueryFile(pwszQueryFileArg);
    } else if (fArgQueryFileEx == TRUE) {
        dwErr = CmdQueryFileEx(pwszQueryFileExArg);
#if defined(CSCUTIL_INTERNAL)
    } else if (fArgDb == TRUE) {
        dwErr = CmdDb(pwszDbArg);
    } else if (fSwDb == TRUE) {
        dwErr = CmdDb(NULL);
    } else if (fArgBitcopy == TRUE) {
        dwErr = CmdBitcopy(pwszBitcopyArg);
#endif // CSCUTIL_INTERNAL
    } else if (fArgSetSpace == TRUE) {
        dwErr = CmdSetSpace(pwszSetSpaceArg);
    } else if (fArgQueryShare == TRUE) {
        dwErr = CmdQueryShare(pwszQueryShareArg);
    } else if (fArgMerge == TRUE) {
        dwErr = CmdMerge(pwszMergeArg);
    } else if (fArgMove == TRUE) {
        dwErr = CmdMove(pwszMoveArg);
    } else if (fSwEncrypt == TRUE) {
        dwErr = CmdEncryptDecrypt(TRUE);
    } else if (fSwDecrypt == TRUE) {
        dwErr = CmdEncryptDecrypt(FALSE);
    } else if (fArgFill == TRUE) {
        dwErr = CmdFill(pwszFillArg);
    } else if (fArgCheck == TRUE) {
        dwErr = CmdCheck(pwszCheckArg);
    } else if (fArgEnum == TRUE) {
        dwErr = CmdEnum(pwszEnumArg);
    } else if (fSwEnum == TRUE) {
        dwErr = CmdEnum(NULL);
    } else if (fArgRandW == TRUE) {
        dwErr = CmdRandW(pwszRandWArg);
    } else if (fArgEnumForStats == TRUE) {
        dwErr = CmdEnumForStats(pwszEnumForStatsArg);
    } else if (fArgGetShadow == TRUE) {
        dwErr = CmdGetShadow(pwszGetShadowArg);
    } else if (fArgGetShadowInfo == TRUE) {
        dwErr = CmdGetShadowInfo(pwszGetShadowInfoArg);
    } else if (fArgShareId == TRUE) {
        dwErr = CmdShareId(pwszShareIdArg);
    } else if (fArgDelete == TRUE) {
        dwErr = CmdDelete(pwszDeleteArg);
    } else if (fArgDeleteShadow == TRUE) {
        dwErr = CmdDeleteShadow(pwszDeleteShadowArg);
    } else if (fArgPin == TRUE || fArgUnPin == TRUE) {
        dwErr = CmdPinUnPin(fArgPin, pwszPinUnPinArg);
    } else {
        dwErr = Usage(FALSE);
    }

Cleanup:

    if (dwErr == ERROR_SUCCESS) {
        ErrorMessage(MSG_SUCCESSFUL);
    } else {
        LPWSTR MessageBuffer;
        DWORD dwBufferLength;

        dwBufferLength = FormatMessage(
                            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            dwErr,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (LPWSTR) &MessageBuffer,
                            0,
                            NULL);

        ErrorMessage(MSG_ERROR, dwErr);
        if (dwBufferLength > 0) {
            MyPrintf(L"%ws\r\n", MessageBuffer);
            LocalFree(MessageBuffer);
        }
    }

    return dwErr;
}

BOOLEAN
CmdProcessArg(LPWSTR Arg)
{
    LONG ArgLen;
    BOOLEAN dwErr = FALSE;
    BOOLEAN FoundAnArg = FALSE;

    if (fSwDebug == TRUE)
        MyPrintf(L"ProcessArg(%ws)\r\n", Arg);

    if ( Arg != NULL && wcslen(Arg) > 1) {

        dwErr = TRUE;
        ArgLen = wcslen(Arg);

        //
        // Commands with args
        //
        if (_wcsnicmp(Arg, ArgDisconnect, ArgLenDisconnect) == 0) {
            FoundAnArg = fArgDisconnect = TRUE;
            if (ArgLen > ArgLenDisconnect)
                pwszDisconnectArg = &Arg[ArgLenDisconnect];
        } else if (_wcsnicmp(Arg, ArgEnum, ArgLenEnum) == 0) {
            FoundAnArg = fArgEnum = TRUE;
            if (ArgLen > ArgLenEnum)
                pwszEnumArg = &Arg[ArgLenEnum];
#if defined(CSCUTIL_INTERNAL)
        } else if (_wcsnicmp(Arg, ArgReconnect, ArgLenReconnect) == 0) {
            FoundAnArg = fArgReconnect = TRUE;
            if (ArgLen > ArgLenReconnect)
                pwszReconnectArg = &Arg[ArgLenReconnect];
        } else if (_wcsnicmp(Arg, ArgPin, ArgLenPin) == 0) {
            FoundAnArg = fArgPin = TRUE;
            if (ArgLen > ArgLenPin)
                pwszPinUnPinArg = &Arg[ArgLenPin];
        } else if (_wcsnicmp(Arg, ArgUnPin, ArgLenUnPin) == 0) {
            FoundAnArg = fArgUnPin = TRUE;
            if (ArgLen > ArgLenUnPin)
                pwszPinUnPinArg = &Arg[ArgLenUnPin];
        } else if (_wcsnicmp(Arg, ArgDelete, ArgLenDelete) == 0) {
            FoundAnArg = fArgDelete = TRUE;
            if (ArgLen > ArgLenDelete)
                pwszDeleteArg = &Arg[ArgLenDelete];
        } else if (_wcsnicmp(Arg, ArgExclusionList, ArgLenExclusionList) == 0) {
            FoundAnArg = fArgExclusionList = TRUE;
            if (ArgLen > ArgLenExclusionList)
                pwszExclusionListArg = &Arg[ArgLenExclusionList];
        } else if (_wcsnicmp(Arg, ArgBWConservationList, ArgLenBWConservationList) == 0) {
            FoundAnArg = fArgBWConservationList = TRUE;
            if (ArgLen > ArgLenBWConservationList)
                pwszBWConservationListArg = &Arg[ArgLenBWConservationList];
        } else if (_wcsnicmp(Arg, ArgSetShareStatus, ArgLenSetShareStatus) == 0) {
            FoundAnArg = fArgSetShareStatus = TRUE;
            if (ArgLen > ArgLenSetShareStatus)
                pwszSetShareStatusArg = &Arg[ArgLenSetShareStatus];
        } else if (_wcsnicmp(Arg, ArgIsServerOffline, ArgLenIsServerOffline) == 0) {
            FoundAnArg = fArgIsServerOffline = TRUE;
            if (ArgLen > ArgLenIsServerOffline)
                pwszIsServerOfflineArg = &Arg[ArgLenIsServerOffline];
        } else if (_wcsnicmp(Arg, ArgPurge, ArgLenPurge) == 0) {
            FoundAnArg = fArgPurge = TRUE;
            if (ArgLen > ArgLenPurge)
                pwszPurgeArg = &Arg[ArgLenPurge];
        } else if (_wcsnicmp(Arg, ArgRandW, ArgLenRandW) == 0) {
            FoundAnArg = fArgRandW = TRUE;
            if (ArgLen > ArgLenRandW)
                pwszRandWArg = &Arg[ArgLenRandW];
        } else if (_wcsnicmp(Arg, ArgBitcopy, ArgLenBitcopy) == 0) {
            FoundAnArg = fArgBitcopy = TRUE;
            if (ArgLen > ArgLenBitcopy)
                pwszBitcopyArg = &Arg[ArgLenBitcopy];
        } else if (_wcsnicmp(Arg, ArgOffset, ArgLenOffset) == 0) {
            FoundAnArg = fArgOffset = TRUE;
            if (ArgLen > ArgLenOffset)
                pwszOffsetArg = &Arg[ArgLenOffset];
        } else if (_wcsnicmp(Arg, ArgDeleteShadow, ArgLenDeleteShadow) == 0) {
            FoundAnArg = fArgDeleteShadow = TRUE;
            if (ArgLen > ArgLenDeleteShadow)
                pwszDeleteShadowArg = &Arg[ArgLenDeleteShadow];
        } else if (_wcsnicmp(Arg, ArgQueryFile, ArgLenQueryFile) == 0) {
            FoundAnArg = fArgQueryFile = TRUE;
            if (ArgLen > ArgLenQueryFile)
                pwszQueryFileArg = &Arg[ArgLenQueryFile];
        } else if (_wcsnicmp(Arg, ArgQueryFileEx, ArgLenQueryFileEx) == 0) {
            FoundAnArg = fArgQueryFileEx = TRUE;
            if (ArgLen > ArgLenQueryFileEx)
                pwszQueryFileExArg = &Arg[ArgLenQueryFileEx];
        } else if (_wcsnicmp(Arg, ArgDb, ArgLenDb) == 0) {
            FoundAnArg = fArgDb = TRUE;
            if (ArgLen > ArgLenDb)
                pwszDbArg = &Arg[ArgLenDb];
        } else if (_wcsnicmp(Arg, ArgSetSpace, ArgLenSetSpace) == 0) {
            FoundAnArg = fArgSetSpace = TRUE;
            if (ArgLen > ArgLenSetSpace)
                pwszSetSpaceArg = &Arg[ArgLenSetSpace];
        } else if (_wcsnicmp(Arg, ArgGetShadow, ArgLenGetShadow) == 0) {
            FoundAnArg = fArgGetShadow = TRUE;
            if (ArgLen > ArgLenGetShadow)
                pwszGetShadowArg = &Arg[ArgLenGetShadow];
        } else if (_wcsnicmp(Arg, ArgGetShadowInfo, ArgLenGetShadowInfo) == 0) {
            FoundAnArg = fArgGetShadowInfo = TRUE;
            if (ArgLen > ArgLenGetShadowInfo)
                pwszGetShadowInfoArg = &Arg[ArgLenGetShadowInfo];
        } else if (_wcsnicmp(Arg, ArgShareId, ArgLenShareId) == 0) {
            FoundAnArg = fArgShareId = TRUE;
            if (ArgLen > ArgLenShareId)
                pwszShareIdArg = &Arg[ArgLenShareId];
        } else if (_wcsnicmp(Arg, ArgQueryShare, ArgLenQueryShare) == 0) {
            FoundAnArg = fArgQueryShare = TRUE;
            if (ArgLen > ArgLenQueryShare)
                pwszQueryShareArg = &Arg[ArgLenQueryShare];
        } else if (_wcsnicmp(Arg, ArgMove, ArgLenMove) == 0) {
            FoundAnArg = fArgMove = TRUE;
            if (ArgLen > ArgLenMove)
                pwszMoveArg = &Arg[ArgLenMove];
        } else if (_wcsnicmp(Arg, ArgMerge, ArgLenMerge) == 0) {
            FoundAnArg = fArgMerge = TRUE;
            if (ArgLen > ArgLenMerge)
                pwszMergeArg = &Arg[ArgLenMerge];
        } else if (_wcsnicmp(Arg, ArgFill, ArgLenFill) == 0) {
            FoundAnArg = fArgFill = TRUE;
            if (ArgLen > ArgLenFill)
                pwszFillArg = &Arg[ArgLenFill];
        } else if (_wcsnicmp(Arg, ArgCheck, ArgLenCheck) == 0) {
            FoundAnArg = fArgCheck = TRUE;
            if (ArgLen > ArgLenCheck)
                pwszCheckArg = &Arg[ArgLenCheck];
        } else if (_wcsnicmp(Arg, ArgEnumForStats, ArgLenEnumForStats) == 0) {
            FoundAnArg = fArgEnumForStats = TRUE;
            if (ArgLen > ArgLenEnumForStats)
                pwszEnumForStatsArg = &Arg[ArgLenEnumForStats];
#endif // CSCUTIL_INTERNAL
        }

        // Switches go at the end!!
        
        if (_wcsicmp(Arg, SwDebug) == 0) {
            FoundAnArg = fSwDebug = TRUE;
        } else if (_wcsicmp(Arg, SwHelpHelp) == 0) {
            FoundAnArg = fSwHelpHelp = TRUE;
        } else if (_wcsicmp(Arg, SwHelp) == 0) {
            FoundAnArg = fSwHelp = TRUE;
        } else if (_wcsicmp(Arg, SwResid) == 0) {
            FoundAnArg = fSwTouch = fSwEnum = fSwRecurse = TRUE;
        } else if (_wcsicmp(Arg, SwFull) == 0) {
            FoundAnArg = fSwFull = TRUE;
        } else if (_wcsicmp(Arg, SwTouch) == 0) {
            FoundAnArg = fSwTouch = TRUE;
        } else if (_wcsicmp(Arg, SwEnum) == 0) {
            FoundAnArg = fSwEnum = TRUE;
        } else if (_wcsicmp(Arg, SwQQ) == 0) {
            FoundAnArg = fSwQQ = TRUE;
        } else if (_wcsicmp(Arg, SwQ) == 0) {
            FoundAnArg = fSwQ = TRUE;
#if defined(CSCUTIL_INTERNAL)
        } else if (_wcsicmp(Arg, SwPQEnum) == 0) {
            FoundAnArg = fSwPQEnum = TRUE;
        } else if (_wcsicmp(Arg, SwInfo) == 0) {
            FoundAnArg = fSwInfo = TRUE;
        } else if (_wcsicmp(Arg, SwDBStatus) == 0) {
            FoundAnArg = fSwDBStatus = TRUE;
        } else if (_wcsicmp(Arg, SwPurge) == 0) {
            FoundAnArg = fSwPurge = TRUE;
        } else if (_wcsicmp(Arg, SwDetector) == 0) {
            FoundAnArg = fSwDetector = TRUE;
        } else if (_wcsicmp(Arg, SwGetSpace) == 0) {
            FoundAnArg = fSwGetSpace = TRUE;
        } else if (_wcsicmp(Arg, SwDb) == 0) {
            FoundAnArg = fSwDb = TRUE;
        } else if (_wcsicmp(Arg, SwFcblist) == 0) {
            FoundAnArg = fSwFcblist = TRUE;
        } else if (_wcsicmp(Arg, SwEnable) == 0) {
            FoundAnArg = fSwEnable = TRUE;
        } else if (_wcsicmp(Arg, SwDisable) == 0) {
            FoundAnArg = fSwDisable = TRUE;
        } else if (_wcsicmp(Arg, SwSwitches) == 0) {
            FoundAnArg = fSwSwitches = TRUE;
        } else if (_wcsicmp(Arg, SwUser) == 0) {
            FoundAnArg = fSwUser = TRUE;
        } else if (_wcsicmp(Arg, SwSystem) == 0) {
            FoundAnArg = fSwSystem = TRUE;
        } else if (_wcsicmp(Arg, SwInherit) == 0) {
            FoundAnArg = fSwInherit = TRUE;
        } else if (_wcsicmp(Arg, SwRecurse) == 0) {
            FoundAnArg = fSwRecurse = TRUE;
        } else if (_wcsicmp(Arg, SwAbort) == 0) {
            FoundAnArg = fSwAbort = TRUE;
        } else if (_wcsicmp(Arg, SwSkip) == 0) {
            FoundAnArg = fSwSkip = TRUE;
        } else if (_wcsicmp(Arg, SwAsk) == 0) {
            FoundAnArg = fSwAsk = TRUE;
        } else if (_wcsicmp(Arg, SwEof) == 0) {
            FoundAnArg = fSwEof = TRUE;
        } else if (_wcsicmp(Arg, SwRetry) == 0) {
            FoundAnArg = fSwRetry = TRUE;
        } else if (_wcsicmp(Arg, SwSet) == 0) {
            FoundAnArg = fSwSet = TRUE;
        } else if (_wcsicmp(Arg, SwClear) == 0) {
            FoundAnArg = fSwClear = TRUE;
        } else if (_wcsicmp(Arg, SwFlags) == 0) {
            FoundAnArg = fSwFlags = TRUE;
        } else if (_wcsicmp(Arg, SwIoctl) == 0) {
            FoundAnArg = fSwIoctl = TRUE;
        } else if (_wcsicmp(Arg, SwEncrypt) == 0) {
            FoundAnArg = fSwEncrypt = TRUE;
        } else if (_wcsicmp(Arg, SwDecrypt) == 0) {
            FoundAnArg = fSwDecrypt = TRUE;
#endif // CSCUTIL_INTERNAL
        }

        if (FoundAnArg == FALSE) {
            ErrorMessage(MSG_UNRECOGNIZED_OPTION, &Arg[1]);
            dwErr = FALSE;
            goto AllDone;
        }

    }

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"ProcessArg exit %d\r\n", dwErr);

    return dwErr;
}

DWORD
Usage(
    BOOLEAN fHelpHelp)
{
#if defined(CSCUTIL_INTERNAL)
    ErrorMessage(MSG_USAGE);
    if (fHelpHelp == TRUE)
        ErrorMessage(MSG_USAGE_EX);
#else
    ErrorMessage(MSG_USAGE2);
    if (fHelpHelp == TRUE)
        ErrorMessage(MSG_USAGE_EX2);
#endif // CSCUTIL_INTERNAL
    return ERROR_SUCCESS;
}

DWORD
CmdReconnect(
    PWSTR ReconnectArg)
{
    DWORD Error = ERROR_SUCCESS;
    BOOL fRet;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdReconnect(%ws)\r\n", ReconnectArg);

    fRet = CSCTransitionServerOnlineW(ReconnectArg);
    if (fRet == FALSE)
       Error = GetLastError();

    return Error;
}

DWORD
CmdQueryFile(
    PWSTR QueryFileArg)
{
    DWORD HintFlags = 0;
    DWORD PinCount = 0;
    DWORD Status = 0;
    DWORD Error = ERROR_SUCCESS;
    BOOL fRet;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdQueryFile(%ws)\r\n", QueryFileArg);

    fRet = CSCQueryFileStatusW(
                QueryFileArg,
                &Status,
                &PinCount,
                &HintFlags);

    if (fRet == FALSE) {
       Error = GetLastError();
       goto AllDone;
    }

    if (fSwFull != TRUE) {
        MyPrintf(
            L"QueryFile of %ws:\r\n"
            L"Status:                0x%x\r\n"
            L"PinCount:              %d\r\n"
            L"HintFlags:             0x%x\r\n",
                QueryFileArg,
                Status,
                PinCount,
                HintFlags);
    } else {
        WCHAR StatusBuffer[0x100];
        WCHAR HintBuffer[0x100];
   
        if (LooksToBeAShare(QueryFileArg) == TRUE)
            ShareStatusToEnglish(Status, StatusBuffer);
        else
            FileStatusToEnglish(Status, StatusBuffer);
        HintsToEnglish(HintFlags, HintBuffer);
        MyPrintf(
            L"QueryFile of %ws:\r\n"
            L"Status:    0x%x %ws\r\n"
            L"PinCount:  %d\r\n"
            L"HintFlags: 0x%x %ws\r\n",
                QueryFileArg,
                Status,
                StatusBuffer,
                PinCount,
                HintFlags,
                HintBuffer);
    }

AllDone:
    return Error;
}

DWORD
CmdQueryFileEx(
    PWSTR QueryFileExArg)
{
    DWORD HintFlags = 0;
    DWORD PinCount = 0;
    DWORD Status = 0;
    DWORD UserPerms = 0;
    DWORD OtherPerms = 0;
    DWORD Error = ERROR_SUCCESS;
    BOOL fRet;
    HMODULE hmodCscDll = LoadLibrary(TEXT("cscdll.dll"));
    CSCQUERYFILESTATUSEXW pCSCQueryFileStatusExW = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdQueryFileEx(%ws)\r\n", QueryFileExArg);

    if (hmodCscDll == NULL) {
        Error = GetLastError();
        goto AllDone;
    }

    pCSCQueryFileStatusExW = (CSCQUERYFILESTATUSEXW) GetProcAddress(
                                                        hmodCscDll,
                                                        "CSCQueryFileStatusExW");
    if (pCSCQueryFileStatusExW == NULL) {
        Error = GetLastError();
        goto AllDone;
    }

    fRet = (pCSCQueryFileStatusExW)(
                QueryFileExArg,
                &Status,
                &PinCount,
                &HintFlags,
                &UserPerms,
                &OtherPerms);

    if (fRet == FALSE) {
       Error = GetLastError();
       goto AllDone;
    }

    if (fSwFull != TRUE) {
        MyPrintf(
            L"Query of %ws:\r\n"
            L"Status:                0x%x\r\n"
            L"PinCount:              %d\r\n"
            L"HintFlags:             0x%x\r\n"
            L"UserPerms:             0x%x\r\n"
            L"OtherPerms:            0x%x\r\n",
                QueryFileExArg,
                Status,
                PinCount,
                HintFlags,
                UserPerms,
                OtherPerms);
    } else {
        WCHAR StatusBuffer[0x100] = {0};
        WCHAR HintBuffer[0x100] = {0};
   
        if (LooksToBeAShare(QueryFileExArg) == TRUE)
            ShareStatusToEnglish(Status, StatusBuffer);
        else
            FileStatusToEnglish(Status, StatusBuffer);
        HintsToEnglish(HintFlags, HintBuffer);
        MyPrintf(
            L"Query of %ws:\r\n"
            L"Status:     0x%x %ws\r\n"
            L"PinCount:   %d\r\n"
            L"HintFlags:  0x%x %ws\r\n"
            L"UserPerms:  0x%x\r\n"
            L"OtherPerms: 0x%x\r\n",
                QueryFileExArg,
                Status,
                StatusBuffer,
                PinCount,
                HintFlags,
                HintBuffer,
                UserPerms,
                OtherPerms);
    }

AllDone:
    if (hmodCscDll != NULL)
        FreeLibrary(hmodCscDll);
    return Error;
}

DWORD
CmdSetSpace(
    PWSTR SetSpaceArg)
{
    DWORD Error = ERROR_SUCCESS;
    DWORD MaxSpaceHigh = 0;
    DWORD MaxSpaceLow;
    BOOL fRet;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSetSpace(%ws)\r\n", SetSpaceArg);

    swscanf(SetSpaceArg, L"%d", &MaxSpaceLow);

    fRet = CSCSetMaxSpace(
                MaxSpaceHigh,
                MaxSpaceLow);

    if (fRet == FALSE) {
       Error = GetLastError();
       goto AllDone;
    }

    CmdGetSpace();

AllDone:
    return Error;
}

DWORD
CmdQueryShare(
    PWSTR QueryShareArg)
{
    DWORD HintFlags = 0;
    DWORD PinCount = 0;
    DWORD Status = 0;
    DWORD UserPerms = 0;
    DWORD OtherPerms = 0;
    DWORD Error = ERROR_SUCCESS;
    BOOL fRet;
    HMODULE hmodCscDll = LoadLibrary(TEXT("cscdll.dll"));
    CSCQUERYSHARESTATUSW pCSCQueryShareStatusW = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdQueryShare(%ws)\r\n", QueryShareArg);

    if (hmodCscDll == NULL) {
        Error = GetLastError();
        goto AllDone;
    }

    pCSCQueryShareStatusW = (CSCQUERYSHARESTATUSW) GetProcAddress(
                                                        hmodCscDll,
                                                        "CSCQueryShareStatusW");
    if (pCSCQueryShareStatusW == NULL) {
        Error = GetLastError();
        goto AllDone;
    }

    fRet = (pCSCQueryShareStatusW)(
                QueryShareArg,
                &Status,
                &PinCount,
                &HintFlags,
                &UserPerms,
                &OtherPerms);

    if (fRet == FALSE) {
       Error = GetLastError();
       goto AllDone;
    }

    if (fSwFull != TRUE) {
        MyPrintf(
            L"Query of %ws:\r\n"
            L"Status:                0x%x\r\n"
            L"PinCount:              %d\r\n"
            L"HintFlags:             0x%x\r\n"
            L"UserPerms:             0x%x\r\n"
            L"OtherPerms:            0x%x\r\n",
                QueryShareArg,
                Status,
                PinCount,
                HintFlags,
                UserPerms,
                OtherPerms);
    } else {
        WCHAR StatusBuffer[0x100] = {0};
        WCHAR HintBuffer[0x100] = {0};
   
        ShareStatusToEnglish(Status, StatusBuffer);
        HintsToEnglish(HintFlags, HintBuffer);
        MyPrintf(
            L"Query of %ws:\r\n"
            L"Status:     0x%x %ws\r\n"
            L"PinCount:   %d\r\n"
            L"HintFlags:  0x%x %ws\r\n"
            L"UserPerms:  0x%x\r\n"
            L"OtherPerms: 0x%x\r\n",
                QueryShareArg,
                Status,
                StatusBuffer,
                PinCount,
                HintFlags,
                HintBuffer,
                UserPerms,
                OtherPerms);
    }
AllDone:
    if (hmodCscDll != NULL)
        FreeLibrary(hmodCscDll);
    return Error;
}

DWORD
CmdMerge(
    PWSTR MergeArg)
{
    DWORD Error = ERROR_SUCCESS;
    DWORD HowToRespond = CSCPROC_RETURN_CONTINUE; // JMH
    BOOL fRet;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdMerge(%ws)\r\n", MergeArg);

    fRet = CSCMergeShareW(MergeArg, MyCscMergeProcW, HowToRespond);
    if (fRet == FALSE) {
        Error = GetLastError();
        goto AllDone;
    }

    fRet = CSCTransitionServerOnlineW(MergeArg);
    if (fRet == FALSE)
       Error = GetLastError();

AllDone:
    return Error;
}

DWORD
CmdMove(
    PWSTR MoveArg)
{

	DWORD Error = ERROR_FILE_NOT_FOUND;
	LPWSTR  lpszTempName = NULL;

    if (!CSCCopyReplicaW(MoveArg, &lpszTempName)) {
        Error = GetLastError();
    } else {
        Error = ERROR_SUCCESS;
    }

	if (Error == ERROR_SUCCESS)
        MyPrintf(L"Copy is %ws\r\n", lpszTempName);

	return Error;
}


DWORD
CmdEncryptDecrypt(
    BOOL fEncrypt)
{
    DWORD Error = ERROR_SUCCESS;
    DWORD EncryptDecryptType = 0;
    BOOL fRet;
    HMODULE hmodCscDll = LoadLibrary(TEXT("cscdll.dll"));
    CSCENCRYPTDECRYPTDATABASE pCSCEncryptDecryptDatabase = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdEncryptDecrypt(%ws)\r\n", fEncrypt == TRUE ? L"Encrypt" : L"Decrypt");

    if (hmodCscDll == NULL) {
        Error = GetLastError();
        goto AllDone;
    }

    pCSCEncryptDecryptDatabase = (CSCENCRYPTDECRYPTDATABASE) GetProcAddress(
                                                                hmodCscDll,
                                                                "CSCEncryptDecryptDatabase");
    if (pCSCEncryptDecryptDatabase == NULL) {
        Error = GetLastError();
        goto AllDone;
    }

    fRet = (pCSCEncryptDecryptDatabase)(fEncrypt, MyEncryptDecryptProcW, EncryptDecryptType);
    if (fRet == FALSE) {
        Error = GetLastError();
        goto AllDone;
    }

AllDone:

    if (hmodCscDll != NULL)
        FreeLibrary(hmodCscDll);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdEncryptDecrypt exit %d\r\n", Error);

    return Error;
}

DWORD
CmdFill(
    PWSTR FillArg)
{
    DWORD Error = ERROR_SUCCESS;
    DWORD HowToRespond = CSCPROC_RETURN_CONTINUE;
    BOOL fRet;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdFill(%ws, %d)\r\n", FillArg, fSwFull);

    fRet = CSCFillSparseFilesW(FillArg, fSwFull, MyCscFillProcW, HowToRespond);
    if (fRet == FALSE) {
        Error = GetLastError();
    }

    return Error;
}

DWORD
CmdCheck(
    PWSTR CheckArg)
{
    DWORD Error = ERROR_SUCCESS;
    DWORD Speed = 0;
    BOOL fOnline = FALSE;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdCheck(%ws)\r\n", CheckArg);

    fOnline = CSCCheckShareOnlineExW(CheckArg, &Speed);

    MyPrintf(
        L"%ws is %s\r\n",
            CheckArg,
            (fOnline == FALSE) ? L"Offline" : L"Online");

    return Error;
}

DWORD
CmdDBStatus(
    VOID)
{
    GLOBALSTATUS sGS = {0};
    ULONG DBStatus = 0;
    ULONG DBErrorFlags = 0;
    BOOL bResult;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    ULONG junk;
    ULONG Status = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDBStatus()\r\n");

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdDBStatus:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_GETGLOBALSTATUS,          // control code
                (LPVOID)&sGS,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    if (!bResult) {
        MyPrintf(L"CmdDBStatus:DeviceIoControl IOCTL_GETGLOBALSTATUS failed\n");
        Status = GetLastError();
        goto AllDone;
    }

    DBStatus = sGS.sST.uFlags;
    DBErrorFlags = sGS.uDatabaseErrorFlags;

    if (DBStatus & FLAG_DATABASESTATUS_DIRTY)
        MyPrintf(L"FLAG_DATABASESTATUS_DIRTY\r\n");
    if (DBStatus & FLAG_DATABASESTATUS_UNENCRYPTED)
        MyPrintf(L"FLAG_DATABASESTATUS_UNENCRYPTED\r\n");
    if (DBStatus & FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED)
        MyPrintf(L"FLAG_DATABASESTATUS_PARTIALLY_UNENCRYPTED\r\n");
    if (DBStatus & FLAG_DATABASESTATUS_ENCRYPTED)
        MyPrintf(L"FLAG_DATABASESTATUS_ENCRYPTED\r\n");
    if (DBStatus & FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED)
        MyPrintf(L"FLAG_DATABASESTATUS_PARTIALLY_ENCRYPTED\r\n");

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDBStatus exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return Status;
}

DWORD
CmdPurge(
    PWSTR PurgeArg)
{
    ULONG nFiles = 0;
    ULONG nYoungFiles = 0;
    ULONG Status = ERROR_SUCCESS;
    ULONG Timeout = 120;
    BOOL fRet = FALSE;
    HMODULE hmodCscDll = LoadLibrary(TEXT("cscdll.dll"));
    CSCPURGEUNPINNEDFILES pCSCPurgeUnpinnedFiles = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdPurge(%ws)\r\n", PurgeArg);

    if (hmodCscDll == NULL) {
        Status = GetLastError();
        goto AllDone;
    }

    pCSCPurgeUnpinnedFiles = (CSCPURGEUNPINNEDFILES) GetProcAddress(
                                                        hmodCscDll,
                                                        "CSCPurgeUnpinnedFiles");
    if (pCSCPurgeUnpinnedFiles == NULL) {
        Status = GetLastError();
        goto AllDone;
    }

    if (PurgeArg != NULL)
        swscanf(PurgeArg, L"%d", &Timeout);

    if (fSwDebug == TRUE)
        MyPrintf(L"Timeout=%d seconds\r\n", Timeout);

    fRet = (pCSCPurgeUnpinnedFiles)(Timeout, &nFiles, &nYoungFiles);
    if (fRet == FALSE) {
        Status = GetLastError();
        goto AllDone;
    }
    MyPrintf(L"nFiles = %d nYoungFiles=%d\n", nFiles, nYoungFiles);

AllDone:
    if (hmodCscDll != NULL)
        FreeLibrary(hmodCscDll);
    if (fSwDebug == TRUE)
        MyPrintf(L"CmdPurge exit %d\r\n", Status);

    return Status;
}

DWORD
CmdPQEnum(
    VOID)
{
    PQPARAMS PQP = {0};
    BOOL bResult;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    ULONG junk;
    ULONG Status = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdPQEnum()\r\n");

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdPQEnum:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    MyPrintf(L"  POS SHARE      DIR   SHADOW   STATUS REFPRI   HPRI HINTFLG HINTPRI  VER\r\n");

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_SHADOW_BEGIN_PQ_ENUM,     // control code
                (LPVOID)&PQP,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    if (!bResult) {
        MyPrintf(L"CmdPQEnum:DeviceIoControl IOCTL_SHADOW_BEGIN_PQ_ENUM failed\n");
        Status = GetLastError();
        goto AllDone;
    }

    do {
        bResult = DeviceIoControl(
                    hDBShadow,                      // device 
                    IOCTL_SHADOW_NEXT_PRI_SHADOW,   // control code
                    (LPVOID)&PQP,                   // in buffer
                    0,                              // inbuffer size
                    NULL,                           // out buffer
                    0,                              // out buffer size
                    &junk,                          // bytes returned
                    NULL);                          // overlapped
        if (bResult) {
           MyPrintf(L"%5d %5x %8x %8x %8x %6d %6x %7d %7d %4d\r\n",
                PQP.uPos,
                PQP.hShare,
                PQP.hDir,
                PQP.hShadow,
                PQP.ulStatus,
                PQP.ulRefPri,
                PQP.ulIHPri,
                PQP.ulHintFlags,
                PQP.ulHintPri,
                PQP.dwPQVersion);
        }
    } while (bResult && PQP.uPos != 0);

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_SHADOW_END_PQ_ENUM,       // control code
                (LPVOID)&PQP,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdPQEnum exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return Status;
}

LPWSTR
ConvertGmtTimeToString(
    FILETIME Time,
    LPWSTR OutputBuffer)
{
    FILETIME LocalTime;
    SYSTEMTIME SystemTime;

    static FILETIME ftNone = {0, 0};

    if (memcmp(&Time, &ftNone, sizeof(FILETIME)) == 0) {
        wsprintf (OutputBuffer, L"<none>");
    } else {
        FileTimeToLocalFileTime( &Time , &LocalTime );
        FileTimeToSystemTime( &LocalTime, &SystemTime );
        wsprintf(
            OutputBuffer,
            L"%02u/%02u/%04u %02u:%02u:%02u ",
                    SystemTime.wMonth,
                    SystemTime.wDay,
                    SystemTime.wYear,
                    SystemTime.wHour,
                    SystemTime.wMinute,
                    SystemTime.wSecond );
    }
    return( OutputBuffer );
}

VOID
DumpCscEntryInfo(
    LPWSTR Path,
    PWIN32_FIND_DATA Find32,
    DWORD Status,
    DWORD PinCount,
    DWORD HintFlags,
    PFILETIME OrgTime)
{
    WCHAR TimeBuf1[40];
    WCHAR TimeBuf2[40];
    FILE *fp = NULL;

    if (fSwTouch == TRUE) {
        if (Path == NULL) {
            wsprintf(NameBuf, L"%ws", Find32->cFileName);
        } else {
            wsprintf(NameBuf, L"%ws\\%ws", Path, Find32->cFileName);
        }
        MyPrintf(L"%ws\r\n", NameBuf);
        if ((Find32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
            fp = _wfopen(NameBuf, L"rb");
            if (fp != NULL)
                fclose(fp);
        }
    } else if (fSwFull == TRUE) {
        WCHAR StatusBuffer[0x100];
        WCHAR HintBuffer[0x100];

        if (Path != NULL)
            MyPrintf(L"Directory %ws\r\n", Path);
        ConvertGmtTimeToString(Find32->ftLastWriteTime, TimeBuf1);
        MyPrintf(
            L"LFN:           %s\r\n"
            L"SFN:           %s\r\n"
            L"Attr:          0x%x\r\n"
            L"Size:          0x%x:0x%x\r\n"
            L"LastWriteTime: %ws\r\n",
                Find32->cFileName,
                Find32->cAlternateFileName,
                Find32->dwFileAttributes,
                Find32->nFileSizeHigh, Find32->nFileSizeLow,
                TimeBuf1);

        if (OrgTime) {
            ConvertGmtTimeToString(*OrgTime, TimeBuf1);
            MyPrintf(L"ORGTime:       %ws\r\n", TimeBuf1);
        }
        StatusBuffer[0] = L'\0';
        HintBuffer[0] = L'\0';
        if (Path == NULL) {
            ShareStatusToEnglish(Status, StatusBuffer);
            HintsToEnglish(HintFlags, HintBuffer);
        } else {
            if (LooksToBeAShare(Path) == TRUE)
                ShareStatusToEnglish(Status, StatusBuffer);
            else
                FileStatusToEnglish(Status, StatusBuffer);
            HintsToEnglish(HintFlags, HintBuffer);
        }
        MyPrintf(
            L"Status:        0x%x %ws\r\n"
            L"PinCount:      %d\r\n"
            L"HintFlags:     0x%x %ws\r\n\r\n",
                Status,
                StatusBuffer,
                PinCount,
                HintFlags,
                HintBuffer);
    } else {
        if (Path == NULL) {
            MyPrintf(L"%ws\r\n", Find32->cFileName);
        } else {
            MyPrintf(L"%ws\\%ws\r\n", Path, Find32->cFileName);
        }
        MyPrintf(L"  Attr=0x%x Size=0x%x:0x%x Status=0x%x PinCount=%d HintFlags=0x%x\r\n",
                Find32->dwFileAttributes,
                Find32->nFileSizeHigh, Find32->nFileSizeLow,
                Status,
                PinCount,
                HintFlags);
        ConvertGmtTimeToString(Find32->ftLastWriteTime, TimeBuf1);
        if (OrgTime)
            ConvertGmtTimeToString(*OrgTime, TimeBuf2);
        else
            wcscpy(TimeBuf2, L"<none>");
        MyPrintf(L"  LastWriteTime: %ws OrgTime: %ws\r\n",
                        TimeBuf1,
                        TimeBuf2);
        MyPrintf(L"\r\n");
    }
}

DWORD
CmdEnum(
    PWSTR EnumArg)
{
	HANDLE hFind;
	DWORD Error = ERROR_SUCCESS;
    DWORD Status = 0;
    DWORD PinCount = 0;
    DWORD HintFlags = 0;
	FILETIME ftOrgTime = {0};
	WIN32_FIND_DATAW sFind32 = {0};
    WCHAR FullPath[MAX_PATH];

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdEnum(%ws)\r\n", EnumArg);

    hFind = CSCFindFirstFileW(EnumArg, &sFind32, &Status, &PinCount, &HintFlags, &ftOrgTime);
    if (hFind == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
        goto AllDone;
    }
    DumpCscEntryInfo(EnumArg, &sFind32, Status, PinCount, HintFlags, &ftOrgTime);
    if (fSwRecurse == TRUE && (sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        if (EnumArg != NULL) {
            wcscpy(FullPath, EnumArg);
            wcscat(FullPath, L"\\");
        } else {
            wcscpy(FullPath, L"");
        }
        wcscat(FullPath, sFind32.cFileName);
        CmdEnum(FullPath);
    }
    while (CSCFindNextFileW(hFind, &sFind32, &Status, &PinCount, &HintFlags, &ftOrgTime)) {
        DumpCscEntryInfo(EnumArg, &sFind32, Status, PinCount, HintFlags, &ftOrgTime);
        if (fSwRecurse == TRUE && (sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            if (EnumArg != NULL) {
                wcscpy(FullPath, EnumArg);
                wcscat(FullPath, L"\\");
            } else {
                wcscpy(FullPath, L"");
            }
            wcscat(FullPath, sFind32.cFileName);
            CmdEnum(FullPath);
        }
    }
    CSCFindClose(hFind);

AllDone:
	return (Error);
}

DWORD
CmdEnumForStats(
    PWSTR EnumForStatsArg)
{
    DWORD Error = ERROR_SUCCESS;
    DWORD EnumForStatsType = 0;
    BOOL fRet;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdEnumForStats()\r\n");

    fRet = CSCEnumForStatsW(EnumForStatsArg, MyEnumForStatsProcW, EnumForStatsType);
    if (fRet == FALSE) {
        Error = GetLastError();
        goto AllDone;
    }

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdEnumForStats exit %d\r\n", Error);

    return Error;
}

DWORD
CmdDelete(
    PWSTR DeleteArg)
{
	DWORD Error = ERROR_SUCCESS;
    DWORD Status = 0;
    DWORD PinCount = 0;
    DWORD HintFlags = 0;
	FILETIME ftOrgTime = {0};
    BOOL fResult;
	HANDLE hFind;
	WIN32_FIND_DATAW sFind32 = {0};
    WCHAR FullPath[MAX_PATH];


    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDelete(%ws)\r\n", DeleteArg);

    //
    // Non-recursive delete
    //
    if (fSwRecurse == FALSE) {
        fResult = CSCDeleteW(DeleteArg);
        if (fResult == FALSE)
            Error = GetLastError();
        goto AllDone;
    }
    //
    // Delete recursively, using eumeration
    //
    hFind = CSCFindFirstFileW(DeleteArg, &sFind32, &Status, &PinCount, &HintFlags, &ftOrgTime);
    if (hFind == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
        goto AllDone;
    }
    if (DeleteArg != NULL) {
        wcscpy(FullPath, DeleteArg);
        wcscat(FullPath, L"\\");
    } else {
        wcscpy(FullPath, L"");
    }
    wcscat(FullPath, sFind32.cFileName);
    if (sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        CmdDelete(FullPath);
    MyPrintf(L"CSCDeleteW(%ws) -> %d\r\n", FullPath, CSCDeleteW(FullPath));
    while (CSCFindNextFileW(hFind, &sFind32, &Status, &PinCount, &HintFlags, &ftOrgTime)) {
        if (DeleteArg != NULL) {
            wcscpy(FullPath, DeleteArg);
            wcscat(FullPath, L"\\");
        } else {
            wcscpy(FullPath, L"");
        }
        wcscat(FullPath, sFind32.cFileName);
        if (sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            CmdDelete(FullPath);
        MyPrintf(L"CSCDeleteW(%ws) -> %d\r\n", FullPath, CSCDeleteW(FullPath));
    }
    CSCFindClose(hFind);

AllDone:
	return (Error);
}

DWORD
CmdDeleteShadow(
    PWSTR DeleteShadowArg)
{
    HSHADOW hDir;
    HSHADOW hShadow;
    SHADOWINFO sSI;
    BOOL bResult;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    ULONG junk;
    ULONG Status = 0;
    ULONG hShare;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDeleteShadow(%ws)\r\n", DeleteShadowArg);

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdDeleteShadow:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    swscanf(DeleteShadowArg, L"0x%x:0x%x", &hDir, &hShadow);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDeleteShadow: hDir:0x%x hShadow:0x%x\r\n", hDir, hShadow);

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hDir = hDir;
    sSI.hShadow = hShadow;

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_SHADOW_DELETE,            // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    if (!bResult) {
        MyPrintf(
                L"CmdDeleteShadow:DeviceIoControl IOCTL_SHADOW_DELETE failed 0x%x\n",
                sSI.dwError);
        Status = sSI.dwError;
        goto AllDone;
    }

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDeleteShadow exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return Status;
}

DWORD
CmdPinUnPin(
    BOOL fPin,
    PWSTR PinArg)
{
    BOOL fRet;
	HANDLE hFind;
	DWORD Error = ERROR_SUCCESS;
    DWORD Status = 0;
    DWORD PinCount = 0;
    DWORD HintFlags = 0;
	FILETIME ftOrgTime = {0};
	WIN32_FIND_DATAW sFind32 = {0};
    WCHAR FullPath[MAX_PATH];

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdPinUnPin(%d,%ws)\r\n", fPin, PinArg);

    if (fSwUser == TRUE && fSwSystem == TRUE) {
        MyPrintf(L"Can not use both /SYSTEM and /USER\r\n");
        goto AllDone;
    }

    if (fSwUser == TRUE) {
        if (fSwInherit == TRUE)
            HintFlags |= FLAG_CSC_HINT_PIN_INHERIT_USER;
        else
            HintFlags |= FLAG_CSC_HINT_PIN_USER;
    }
    if (fSwSystem == TRUE) {
        if (fSwInherit == TRUE)
            HintFlags |= FLAG_CSC_HINT_PIN_INHERIT_SYSTEM;
        else
            HintFlags |= FLAG_CSC_HINT_PIN_SYSTEM;
    }

    if (fSwRecurse == TRUE && fPin == TRUE) {
        MyPrintf(L"Can not pin recursively.\r\n");
        goto AllDone;
    }
    //
    // Pin/Unpin one file
    //
    if (fSwRecurse == FALSE) {
        if (fPin == TRUE) {
            fRet = CSCPinFileW(PinArg, HintFlags, &Status, &PinCount, &HintFlags);
        } else {
            fRet = CSCUnpinFileW(PinArg, HintFlags, &Status, &PinCount, &HintFlags);
        }

        if (fRet == FALSE) {
            Error = GetLastError();
            goto AllDone;
        }

        MyPrintf(
            L"%ws of %ws:\r\n"
            L"Status:                0x%x\r\n"
            L"PinCount:              %d\r\n"
            L"HintFlags:             0x%x\r\n",
                fPin ? L"Pin" : L"Unpin",
                PinArg,
                Status,
                PinCount,
                HintFlags);

        goto AllDone;
    }
    //
    // Unpin recursively, using eumeration
    //
    hFind = CSCFindFirstFileW(PinArg, &sFind32, &Status, &PinCount, &HintFlags, &ftOrgTime);
    if (hFind == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
        goto AllDone;
    }
    if (PinArg != NULL) {
        wcscpy(FullPath, PinArg);
        wcscat(FullPath, L"\\");
    } else {
        wcscpy(FullPath, L"");
    }
    wcscat(FullPath, sFind32.cFileName);
    if (sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        CmdPinUnPin(fPin, FullPath);
    fRet = CSCUnpinFileW(FullPath, HintFlags, &Status, &PinCount, &HintFlags);
    MyPrintf(L"CSCUnpinFile(%ws) -> %d\r\n", FullPath, fRet);
    while (CSCFindNextFileW(hFind, &sFind32, &Status, &PinCount, &HintFlags, &ftOrgTime)) {
        if (PinArg != NULL) {
            wcscpy(FullPath, PinArg);
            wcscat(FullPath, L"\\");
        } else {
            wcscpy(FullPath, L"");
        }
        wcscat(FullPath, sFind32.cFileName);
        if (sFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            CmdPinUnPin(fPin, FullPath);
        fRet = CSCUnpinFileW(FullPath, HintFlags, &Status, &PinCount, &HintFlags);
        MyPrintf(L"CSCUnpinFile(%ws) -> %d\r\n", FullPath, fRet);
    }
    CSCFindClose(hFind);
                
AllDone:

    return Error;
}

DWORD
MyCscMergeProcW(
     LPCWSTR         lpszFullPath,
     DWORD           dwStatus,
     DWORD           dwHintFlags,
     DWORD           dwPinCount,
     WIN32_FIND_DATAW *lpFind32,
     DWORD           dwReason,
     DWORD           dwParam1,
     DWORD           dwParam2,
     DWORD_PTR       dwContext)
{
	if (dwReason == CSCPROC_REASON_BEGIN || dwReason == CSCPROC_REASON_MORE_DATA) {
        if (dwReason == CSCPROC_REASON_BEGIN) {
            MyPrintf( L"BEGIN[%ws][%d/%d]",
                (lpszFullPath) ? lpszFullPath : L"None",
                dwParam1,
                dwParam2);
        } else if (dwReason == CSCPROC_REASON_MORE_DATA) {
            MyPrintf( L"MORE_DATA[%ws][%d/%d]",
                (lpszFullPath) ? lpszFullPath : L"None",
                dwParam1,
                dwParam2);
        }
        if (fSwAbort) {
            MyPrintf(L":Abort\r\n");
            return CSCPROC_RETURN_ABORT;
        } else if (fSwSkip) {
            MyPrintf(L":Skip\r\n");
            return CSCPROC_RETURN_SKIP;
        } else if (fSwRetry) {
            MyPrintf(L"Retry\r\n");
            return CSCPROC_RETURN_RETRY;
        } else if (fSwAsk) {
            MyPrintf(L" - (R)etry/(A)bort/(S)kip/(C)ontinue:");
            return CscMergeFillAsk(lpszFullPath);
        } else {
            MyPrintf(L"Continue\r\n");
            return (DWORD)dwContext;
        }
    }

    MyPrintf( L"END[%ws]:", (lpszFullPath) ? lpszFullPath : L"None");
    if (dwParam2 == ERROR_SUCCESS) {
        MyPrintf(L"SUCCEEDED\r\n");
    } else {
        MyPrintf(L"ERROR=%d \r\n", dwParam2);
    }
    return (DWORD)dwContext;
}

DWORD
MyCscFillProcW(
     LPCWSTR         lpszFullPath,
     DWORD           dwStatus,
     DWORD           dwHintFlags,
     DWORD           dwPinCount,
     WIN32_FIND_DATAW *lpFind32,
     DWORD           dwReason,
     DWORD           dwParam1,
     DWORD           dwParam2,
     DWORD_PTR       dwContext)
{
	if (dwReason == CSCPROC_REASON_BEGIN || dwReason == CSCPROC_REASON_MORE_DATA) {
        if (dwReason == CSCPROC_REASON_BEGIN) {
            MyPrintf( L"BEGIN[%ws][%d/%d]",
                (lpszFullPath) ? lpszFullPath : L"None",
                dwParam1,
                dwParam2);
        } else if (dwReason == CSCPROC_REASON_MORE_DATA) {
            MyPrintf( L"MORE_DATA[%ws][%d/%d]",
                (lpszFullPath) ? lpszFullPath : L"None",
                dwParam1,
                dwParam2);
        }
        if (fSwAbort) {
            MyPrintf(L":Abort\r\n");
            return CSCPROC_RETURN_ABORT;
        } else if (fSwSkip) {
            MyPrintf(L":Skip\r\n");
            return CSCPROC_RETURN_SKIP;
        } else if (fSwRetry) {
            MyPrintf(L"Retry\r\n");
            return CSCPROC_RETURN_RETRY;
        } else if (fSwAsk) {
            MyPrintf(L" - (R)etry/(A)bort/(S)kip/(C)ontinue:");
            return CscMergeFillAsk(lpszFullPath);
        } else {
            MyPrintf(L"Continue\r\n");
            return (DWORD)dwContext;
        }
    }

    MyPrintf( L"END[%ws]:", (lpszFullPath) ? lpszFullPath : L"None");
    if (dwParam2 == ERROR_SUCCESS) {
        MyPrintf(L"SUCCEEDED\r\n");
    } else {
        MyPrintf(L"ERROR=%d \r\n", dwParam2);
    }
    return (DWORD)dwContext;
}

DWORD
CscMergeFillAsk(LPCWSTR lpszFullPath)
{
    WCHAR wch;
    ULONG ulid;
    LONG cnt;
    WCHAR rgwch[256];
    PWCHAR lpBuff = NULL;

    do {
        lpBuff = rgwch;
        memset(rgwch, 0, sizeof(rgwch));
        if (!fgetws(rgwch, sizeof(rgwch)/sizeof(WCHAR), stdin))
           break;
        // Chop leading blanks
        if (lpBuff != NULL)
            while (*lpBuff != L'\0' && *lpBuff == L' ')
                lpBuff++;

        cnt = swscanf(lpBuff, L"%c", &wch);

        if (!cnt)
            continue;

        switch (wch) {
            case L's': case L'S':
                return CSCPROC_RETURN_SKIP;
            case L'c': case L'C':
                return CSCPROC_RETURN_CONTINUE;
            case L'a': case L'A':
                return CSCPROC_RETURN_ABORT;
            case L'r': case L'R':
                return CSCPROC_RETURN_RETRY;
        }
    } while (1);

    return CSCPROC_RETURN_CONTINUE;
}

DWORD
MyEncryptDecryptProcW(
     LPCWSTR         lpszFullPath,
     DWORD           dwStatus,
     DWORD           dwHintFlags,
     DWORD           dwPinCount,
     WIN32_FIND_DATAW *lpFind32,
     DWORD           dwReason,
     DWORD           dwParam1,
     DWORD           dwParam2,
     DWORD_PTR       dwContext)
{
	if (dwReason == CSCPROC_REASON_BEGIN) {
        return CSCPROC_RETURN_CONTINUE;
	} else if (dwReason == CSCPROC_REASON_MORE_DATA) {
		MyPrintf(L"%ws\r\n", (lpszFullPath != NULL) ? lpszFullPath : L"None");
        return CSCPROC_RETURN_CONTINUE;
    }
    //
    // CSC_PROC_END
    //
    if (dwParam2 == ERROR_SUCCESS) {
        MyPrintf(L"Succeeded\r\n");
    } else {
        MyPrintf(L"Error=%d \r\n", dwParam2);
    }
	return CSCPROC_RETURN_CONTINUE;
}

DWORD
MyEnumForStatsProcW(
     LPCWSTR         lpszFullPath,
     DWORD           dwStatus,
     DWORD           dwHintFlags,
     DWORD           dwPinCount,
     WIN32_FIND_DATAW *lpFind32,
     DWORD           dwReason,
     DWORD           dwParam1,
     DWORD           dwParam2,
     DWORD_PTR       dwContext)
{
	if (dwReason == CSCPROC_REASON_BEGIN) {
		MyPrintf(L"(1)%ws ", (lpszFullPath != NULL) ? lpszFullPath : L"None");
        if (lpFind32 != NULL)
            MyPrintf(L"[%ws]\r\n", lpFind32->cFileName);
        MyPrintf(L" Status=0x%02x HintFlags=0x%02x "
                 L"Pincount=%3d Reason=0x%x Param1=0x%x Param2=0x%x\r\n",
                        dwStatus,
                        dwHintFlags,
                        dwPinCount,
                        dwReason,
                        dwParam1,
                        dwParam2);
        return CSCPROC_RETURN_CONTINUE;
	} else if (dwReason == CSCPROC_REASON_MORE_DATA) {
		MyPrintf(L"(2)%ws ", (lpszFullPath != NULL) ? lpszFullPath : L"None");
        if (lpFind32 != NULL)
            MyPrintf(L" %ws\r\n", lpFind32->cFileName);
        MyPrintf(L" Status=0x%02x HintFlags=0x%02x "
                 L"Pincount=%3d Reason=0x%x Param1=0x%x Param2=0x%x\r\n",
                        dwStatus,
                        dwHintFlags,
                        dwPinCount,
                        dwReason,
                        dwParam1,
                        dwParam2);
        return CSCPROC_RETURN_CONTINUE;
    }
    //
    // CSC_PROC_END
    //
    MyPrintf(L"(3)%ws\r\n", (lpszFullPath != NULL) ? lpszFullPath : L"None");
    if (dwParam2 == ERROR_SUCCESS) {
        MyPrintf(L"Succeeded\r\n");
    } else {
        MyPrintf(L"Error=%d \r\n", dwParam2);
    }
	return CSCPROC_RETURN_CONTINUE;
}

struct {
    DWORD ShareStatus;
    LPWSTR ShareStatusName;
} ShareStatusStuff[] = {
    { FLAG_CSC_SHARE_STATUS_MODIFIED_OFFLINE, L"MODIFIED_OFFLINE " },
    { FLAG_CSC_SHARE_STATUS_CONNECTED, L"CONNECTED " },
    { FLAG_CSC_SHARE_STATUS_FILES_OPEN, L"FILES_OPEN " },
    { FLAG_CSC_SHARE_STATUS_FINDS_IN_PROGRESS, L"FINDS_IN_PROGRESS " },
    { FLAG_CSC_SHARE_STATUS_DISCONNECTED_OP, L"DISCONNECTED_OP " },
    { FLAG_CSC_SHARE_MERGING, L"MERGING " },
    { 0, NULL }
};

DWORD
ShareStatusToEnglish(
    DWORD Status,
    LPWSTR OutputBuffer)
{
    ULONG i;

    OutputBuffer[0] = L'\0';
    for (i = 0; ShareStatusStuff[i].ShareStatusName; i++) {
        if (Status & ShareStatusStuff[i].ShareStatus)
            wcscat(OutputBuffer, ShareStatusStuff[i].ShareStatusName);
    }
    if ((Status & FLAG_CSC_SHARE_STATUS_CACHING_MASK) == FLAG_CSC_SHARE_STATUS_MANUAL_REINT)
        wcscat(OutputBuffer, L"MANUAL_REINT ");
    else if ((Status & FLAG_CSC_SHARE_STATUS_CACHING_MASK) == FLAG_CSC_SHARE_STATUS_AUTO_REINT)
        wcscat(OutputBuffer, L"AUTO_REINT ");
    else if ((Status & FLAG_CSC_SHARE_STATUS_CACHING_MASK) == FLAG_CSC_SHARE_STATUS_VDO)
        wcscat(OutputBuffer, L"VDO ");
    else if ((Status & FLAG_CSC_SHARE_STATUS_CACHING_MASK) == FLAG_CSC_SHARE_STATUS_NO_CACHING)
        wcscat(OutputBuffer, L"NO_CACHING ");
    return 0;
}

struct {
    DWORD FileStatus;
    LPWSTR FileStatusName;
} FileStatusStuff[] = {
    { FLAG_CSC_COPY_STATUS_DATA_LOCALLY_MODIFIED, L"DATA_LOCALLY_MODIFIED " },
    { FLAG_CSC_COPY_STATUS_ATTRIB_LOCALLY_MODIFIED, L"ATTRIB_LOCALLY_MODIFIED " },
    { FLAG_CSC_COPY_STATUS_TIME_LOCALLY_MODIFIED, L"TIME_LOCALLY_MODIFIED " },
    { FLAG_CSC_COPY_STATUS_STALE, L"STALE " },
    { FLAG_CSC_COPY_STATUS_LOCALLY_DELETED, L"LOCALLY_DELETED " },
    { FLAG_CSC_COPY_STATUS_SPARSE, L"SPARSE " },
    { FLAG_CSC_COPY_STATUS_ORPHAN, L"ORPHAN " },
    { FLAG_CSC_COPY_STATUS_SUSPECT, L"SUSPECT " },
    { FLAG_CSC_COPY_STATUS_LOCALLY_CREATED, L"LOCALLY_CREATED " },
    { 0x00010000, L"USER_READ " },
    { 0x00020000, L"USER_WRITE " },
    { 0x00040000, L"GUEST_READ " },
    { 0x00080000, L"GUEST_WRITE " },
    { 0x00100000, L"OTHER_READ " },
    { 0x00200000, L"OTHER_WRITE " },
    { FLAG_CSC_COPY_STATUS_IS_FILE, L"IS_FILE " },
    { FLAG_CSC_COPY_STATUS_FILE_IN_USE, L"FILE_IN_USE " },
    { 0, NULL }
};

DWORD
FileStatusToEnglish(
    DWORD Status,
    LPWSTR OutputBuffer)
{
    ULONG i;

    OutputBuffer[0] = L'\0';
    for (i = 0; FileStatusStuff[i].FileStatusName; i++) {
        if (Status & FileStatusStuff[i].FileStatus)
            wcscat(OutputBuffer, FileStatusStuff[i].FileStatusName);
    }
    return 0;
}

struct {
    DWORD HintFlag;
    LPWSTR HintName;
} HintStuff[] = {
    { FLAG_CSC_HINT_PIN_USER, L"PIN_USER " },
    { FLAG_CSC_HINT_PIN_INHERIT_USER, L"PIN_INHERIT_USER " },
    { FLAG_CSC_HINT_PIN_INHERIT_SYSTEM, L"PIN_INHERIT_SYSTEM " },
    { FLAG_CSC_HINT_CONSERVE_BANDWIDTH, L"CONSERVE_BANDWIDTH " },
    { FLAG_CSC_HINT_PIN_SYSTEM, L"PIN_SYSTEM " },
    { 0, NULL }
};

DWORD
HintsToEnglish(
    DWORD Hint,
    LPWSTR OutputBuffer)
{
    ULONG i;

    OutputBuffer[0] = L'\0';
    for (i = 0; HintStuff[i].HintName; i++) {
        if (Hint & HintStuff[i].HintFlag)
            wcscat(OutputBuffer, HintStuff[i].HintName);
    }
    return 0;
}

BOOLEAN
LooksToBeAShare(LPWSTR Name)
{
    //
    // See if we have \\server\share or \\server\share\<something>
    // Assume a valid name passed in...
    //

    ULONG Len = wcslen(Name);
    ULONG i;
    ULONG SlashCount = 0;

    // Remove any trailing '\'s
    while (Len >= 1) {
        if (Name[Len-1] == L'\\') {
            Name[Len-1] = L'\0';
            Len--;
        } else {
            break;
        }
    }
    for (i = 0; Name[i]; i++) {
        if (Name[i] == L'\\')
            SlashCount++;
    }
    if (SlashCount > 3)
        return FALSE;

    return TRUE;
}

DWORD
CmdDisconnect(
    PWSTR DisconnectArg)
{
    HSHADOW hDir;
    SHADOWINFO sSI;
    BOOL bResult;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    ULONG junk;
    ULONG Status = 0;
    ULONG hShare;
    PWCHAR wCp;
    ULONG SlashCount = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDisconnect(%ws)\r\n", DisconnectArg);

    GetFileAttributes(DisconnectArg);

    Status = GetLastError();
    if (Status != NO_ERROR)
        goto AllDone;

    SlashCount = 0;
    for (wCp = DisconnectArg; *wCp; wCp++) {
        if (*wCp == L'\\')
            SlashCount++;
        if (SlashCount == 3) {
            *wCp = L'\0';
            break;
        }
    }

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    FILE_EXECUTE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdDisconnect:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.cbBufferSize = (wcslen(DisconnectArg)+1) * sizeof(WCHAR);
    sSI.lpBuffer = DisconnectArg;

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_TAKE_SERVER_OFFLINE,      // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    if (!bResult) {
        MyPrintf(L"CmdDisconnect:DeviceIoControl IOCTL_TAKE_SERVER_OFFLINE failed\n");
        Status = GetLastError();
        goto AllDone;
    }

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDisconnect exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return Status;
}

DWORD
CmdGetShadow(
    PWSTR GetShadowArg)
{
    DWORD Status = 0;
    DWORD dwErr = ERROR_SUCCESS;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    HSHADOW hShadow = 0;
    HSHADOW hDir = 0;
    WIN32_FIND_DATAW sFind32 = {0};
    SHADOWINFO sSI = {0};
    PWCHAR wCp = NULL;
    BOOL bResult = FALSE;
    DWORD junk;
    WCHAR TimeBuf1[40];
    WCHAR TimeBuf2[40];
    WCHAR TimeBuf3[40];

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdGetShadow(%ws)\r\n", GetShadowArg);

    if (GetShadowArg == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

    swscanf(GetShadowArg, L"%x:", &hDir);
    for (wCp = GetShadowArg; *wCp && *wCp != L':'; wCp++)
        ;
    if (*wCp != L':') {
        dwErr = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }
    wCp++;
    if (wcslen(wCp) >= MAX_PATH) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }
    wcscpy(sFind32.cFileName, wCp);

    if (fSwDebug == TRUE)
        MyPrintf(L"hDir=0x%x cFileName=[%ws]\r\n", hDir, sFind32.cFileName);

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdGetShadow:Failed open of shadow device\r\n");
        dwErr = GetLastError();
        goto AllDone;
    }

    sSI.hDir = hDir;
    sSI.lpFind32 = &sFind32;

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_GETSHADOW,                // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    if (!bResult) {
        MyPrintf(L"CmdGetShadow:DeviceIoControl IOCTL_GETSHADOW failed\n");
        dwErr = GetLastError();
        goto AllDone;
    }

    ConvertGmtTimeToString(sFind32.ftCreationTime, TimeBuf1);
    ConvertGmtTimeToString(sFind32.ftLastAccessTime, TimeBuf2);
    ConvertGmtTimeToString(sFind32.ftLastWriteTime, TimeBuf3);

    MyPrintf(L"\r\n");
    MyPrintf(L"%ws:\r\n"
             L"   Size=0x%x:0x%x Attr=0x%x\r\n"
             L"   CreationTime:   %ws\r\n"
             L"   LastAccessTime: %ws\r\n"
             L"   LastWriteTime:  %ws\r\n",
                sFind32.cFileName,
                sFind32.nFileSizeHigh,
                sFind32.nFileSizeLow,
                sFind32.dwFileAttributes,
                TimeBuf1,
                TimeBuf2,
                TimeBuf3);
    MyPrintf(L"   hShare=0x%x hDir=0x%x hShadow=0x%x Status=0x%x HintFlags=0x%x\r\n",
                    sSI.hShare,
                    sSI.hDir,
                    sSI.hShadow,
                    sSI.uStatus,
                    sSI.ulHintFlags);
    MyPrintf(L"\r\n");

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdGetShadowArg exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return dwErr;
}

DWORD
CmdGetShadowInfo(
    PWSTR GetShadowInfoArg)
{
    DWORD Status = 0;
    DWORD dwErr = ERROR_SUCCESS;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    HSHADOW hShadow = 0;
    HSHADOW hDir = 0;
    WIN32_FIND_DATAW sFind32 = {0};
    SHADOWINFO sSI = {0};
    BOOL bResult = FALSE;
    DWORD junk;
    WCHAR TimeBuf1[40];
    WCHAR TimeBuf2[40];
    WCHAR TimeBuf3[40];

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdGetShadowInfo(%ws)\r\n", GetShadowInfoArg);

    if (GetShadowInfoArg == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

    swscanf(GetShadowInfoArg, L"%x:%x", &hDir, &hShadow);

    if (fSwDebug == TRUE)
        MyPrintf(L"hDir=0x%x hShadow=0x%x\r\n", hDir, hShadow);

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdGetShadowInfo:Failed open of shadow device\r\n");
        dwErr = GetLastError();
        goto AllDone;
    }

    sSI.hDir = hDir;
    sSI.hShadow = hShadow;
    sSI.lpFind32 = &sFind32;

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_SHADOW_GET_SHADOW_INFO,   // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    if (!bResult) {
        MyPrintf(L"CmdGetShadowInfo:DeviceIoControl IOCTL_SHADOW_GET_SHADOW_INFO failed\n");
        dwErr = GetLastError();
        goto AllDone;
    }

    ConvertGmtTimeToString(sFind32.ftCreationTime, TimeBuf1);
    ConvertGmtTimeToString(sFind32.ftLastAccessTime, TimeBuf2);
    ConvertGmtTimeToString(sFind32.ftLastWriteTime, TimeBuf3);

    MyPrintf(L"\r\n");
    MyPrintf(L"%ws:\r\n"
             L"   Size=0x%x:0x%x Attr=0x%x\r\n"
             L"   CreationTime:   %ws\r\n"
             L"   LastAccessTime: %ws\r\n"
             L"   LastWriteTime:  %ws\r\n",
                sFind32.cFileName,
                sFind32.nFileSizeHigh,
                sFind32.nFileSizeLow,
                sFind32.dwFileAttributes,
                TimeBuf1,
                TimeBuf2,
                TimeBuf3);
    MyPrintf(L"\r\n");

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdGetShadowInfoArg exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return dwErr;
}

DWORD
CmdShareId(
    PWSTR ShareIdArg)
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG ShareId = 0;
    BOOL fRet;
    WCHAR Buffer[100];
    ULONG BufSize = sizeof(Buffer);
    HMODULE hmodCscDll = LoadLibrary(TEXT("cscdll.dll"));
    CSCSHAREIDTOSHARENAME pCSCShareIdToShareName = NULL;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdShareId(%ws)\r\n", ShareIdArg);

    if (ShareIdArg == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

    swscanf(ShareIdArg, L"%x", &ShareId);

    if (fSwDebug == TRUE)
        MyPrintf(L"ShareId=0x%x\r\n", ShareId);

    if (hmodCscDll == NULL) {
        dwErr = GetLastError();
        goto AllDone;
    }

    pCSCShareIdToShareName = (CSCSHAREIDTOSHARENAME) GetProcAddress(
                                                        hmodCscDll,
                                                        "CSCShareIdToShareName");
    if (pCSCShareIdToShareName == NULL) {
        dwErr = GetLastError();
        goto AllDone;
    }

    fRet = (pCSCShareIdToShareName)(ShareId, (PBYTE)Buffer, &BufSize);
    if (fRet == FALSE) {
        dwErr = GetLastError();
        goto AllDone;
    }

    MyPrintf(L"ShareId 0x%x  = %ws\r\n", ShareId, Buffer);

AllDone:

    if (hmodCscDll != NULL)
        FreeLibrary(hmodCscDll);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdShareIdToShareName exit %d\r\n", dwErr);

    return dwErr;
}

DWORD
CmdExclusionList(
    PWSTR ExclusionListArg)
{
    HSHADOW hDir;
    SHADOWINFO sSI;
    BOOL bResult;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    ULONG junk;
    ULONG Status = 0;
    ULONG hShare;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdExclusionList(%ws)\r\n", ExclusionListArg);

    if (ExclusionListArg == NULL) {
        ExclusionListArg = vtzDefaultExclusionList;
    }
    MyPrintf(L"Setting exclusion list to \"%ws\"\r\n", ExclusionListArg);

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdExclusionList:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_SET_EXCLUSION_LIST;
    sSI.lpBuffer = ExclusionListArg;
    sSI.cbBufferSize = (wcslen(ExclusionListArg)+1) * sizeof(WCHAR);

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_DO_SHADOW_MAINTENANCE,    // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdExclusionList exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return Status;
}

DWORD
CmdBWConservationList(
    PWSTR BWConservationListArg)
{
    HSHADOW hDir;
    SHADOWINFO sSI;
    BOOL bResult;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    ULONG junk;
    ULONG Status = 0;
    ULONG hShare;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdBWConservationList(%ws)\r\n", BWConservationListArg);

    if (BWConservationListArg == NULL) {
        BWConservationListArg = L" ";
    }

    MyPrintf(L"Setting BWConservation list to \"%ws\"\r\n", BWConservationListArg);

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdBWConservationList:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_SET_BW_CONSERVE_LIST;
    sSI.lpBuffer = BWConservationListArg;
    sSI.cbBufferSize = (wcslen(BWConservationListArg)+1) * sizeof(WCHAR);

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_DO_SHADOW_MAINTENANCE,    // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdBWConservationList exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return Status;
}

DWORD
CmdDetector(
    VOID)
{
    HSHADOW hDir;
    SHADOWINFO sSI;
    BOOL bResult;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    ULONG junk;
    ULONG Status = ERROR_SUCCESS;
    ULONG hShare;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDetector()\r\n");

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdDetector:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uSubOperation = SHADOW_SPARSE_STALE_DETECTION_COUNTER;

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_DO_SHADOW_MAINTENANCE,    // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    if (bResult)
        MyPrintf(L"%d\r\n", sSI.dwError);
    else
        Status = sSI.dwError;

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdDetector exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return Status;
}

DWORD
CmdSwitches(
    VOID)
{
    HSHADOW hDir;
    SHADOWINFO sSI;
    BOOL bResult;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    ULONG junk;
    ULONG Status = ERROR_SUCCESS;
    ULONG hShare;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSwitches()\r\n");

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdSwitches:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.uOp = SHADOW_SWITCH_GET_STATE;

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_SWITCHES,                 // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    if (bResult) {
        MyPrintf(L"0x%08x", sSI.uStatus);
        if (sSI.uStatus != 0) {
            MyPrintf(L" (");
            if (sSI.uStatus & SHADOW_SWITCH_SHADOWING)
                MyPrintf(L"SHADOW_SWITCH_SHADOWING ");
            if (sSI.uStatus & SHADOW_SWITCH_LOGGING)
                MyPrintf(L"SHADOW_SWITCH_LOGGING ");
            if (sSI.uStatus & SHADOW_SWITCH_SPEAD_OPTIMIZE)
                MyPrintf(L"SHADOW_SWITCH_SPEAD_OPTIMIZE ");
            MyPrintf(L")");
        }
        if ((sSI.uStatus & SHADOW_SWITCH_SHADOWING) == 0)
            MyPrintf(L" ... csc is disabled");
        else
            MyPrintf(L" ... csc is enabled");
        MyPrintf(L"\r\n");
    } else {
        Status = sSI.dwError;
    }

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSwitches exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return Status;
}

DWORD
CmdGetSpace(
    VOID)
{
    DWORD Error = ERROR_SUCCESS;
    WCHAR szVolume[MAX_PATH];
    LARGE_INTEGER MaxSpace;
    LARGE_INTEGER CurrentSpace;
    DWORD TotalFiles;
    DWORD TotalDirs;
    BOOL fRet;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdGetSpace()\r\n");

    fRet = CSCGetSpaceUsageW(
            szVolume,
            sizeof(szVolume)/sizeof(WCHAR),
            &MaxSpace.HighPart,
            &MaxSpace.LowPart,
            &CurrentSpace.HighPart,
            &CurrentSpace.LowPart,
            &TotalFiles,
            &TotalDirs);

    if (fRet == FALSE) {
        Error = GetLastError();
        goto AllDone;
    }

    MyPrintf(
        L"Volume:         %ws\r\n"
        L"MaxSpace:       0x%x:0x%x (%d)\r\n"
        L"CurrentSpace:   0x%x:0x%x (%d)\r\n"
        L"TotalFiles:     %d\r\n"
        L"TotalDirs:      %d\r\n",
            szVolume,
            MaxSpace.HighPart,
            MaxSpace.LowPart,
            MaxSpace.LowPart,
            CurrentSpace.HighPart,
            CurrentSpace.LowPart,
            CurrentSpace.LowPart,
            TotalFiles,
            TotalDirs);

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdGetSpace exit %d\r\n", Error);

    return Error;
}

DWORD
CmdIsServerOffline(
    PWSTR IsServerOfflineArg)
{
    DWORD Error = ERROR_SUCCESS;
    BOOL fRet;
    BOOL fOffline = FALSE;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdIsServerOffline(%ws)\r\n", IsServerOfflineArg);

    fRet = CSCIsServerOfflineW(
            IsServerOfflineArg,
            &fOffline);

    if (fRet == FALSE) {
        Error = GetLastError();
        goto AllDone;
    }

    if (fOffline == TRUE)
        MyPrintf(L"Offline\r\n");
    else
        MyPrintf(L"Online\r\n");

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdIsServerOffline exit %d\r\n", Error);

    return Error;
}

DWORD
CmdSetShareStatus(
    PWSTR SetShareStatusArg)
{
    HSHADOW hDir;
    SHADOWINFO sSI;
    BOOL bResult;
    HANDLE hDBShadow = INVALID_HANDLE_VALUE;
    ULONG junk;
    ULONG Status = 0;
    ULONG StatusToSet = 0;
    ULONG hShare = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSetShareStatus(%ws)\r\n", SetShareStatusArg);

    if (fSwSet == TRUE && fSwClear == TRUE) {
        MyPrintf(L"Can't have both SET and CLEAR\r\n");
        Status = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

    hDBShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hDBShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdSetShareStatus:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    swscanf(SetShareStatusArg, L"%x:%x", &hShare, &StatusToSet);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSetShareStatus hShare=0x%x StatusToSet=0x%x\r\n", hShare, StatusToSet);

    memset(&sSI, 0, sizeof(SHADOWINFO));
    sSI.hShare = hShare;
    if (fSwSet == TRUE) {
        sSI.uStatus = StatusToSet;
        sSI.uOp = SHADOW_FLAGS_OR;
    } else if (fSwClear == TRUE) {
        sSI.uStatus = ~StatusToSet;
        sSI.uOp = SHADOW_FLAGS_AND;
    } else {
        MyPrintf(L"Missing /SET or /CLEAR\r\n");
        Status = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

    bResult = DeviceIoControl(
                hDBShadow,                      // device 
                IOCTL_SET_SHARE_STATUS,         // control code
                (LPVOID)&sSI,                   // in buffer
                0,                              // inbuffer size
                NULL,                           // out buffer
                0,                              // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    if (!bResult) {
        MyPrintf(L"CmdSetShareStatus:DeviceIoControl IOCTL_SET_SHARE_STATUS failed\n");
        Status = GetLastError();
        goto AllDone;
    }

AllDone:

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdSetShareStatus exit %d\r\n", Status);

    if (hDBShadow != INVALID_HANDLE_VALUE)
        CloseHandle(hDBShadow);

    return Status;
}

#define MAX_OFFSETS 256
#define PAGESIZE 4096
ULONG OffsetArgs[MAX_OFFSETS];

DWORD
CmdRandW(
    PWSTR CmdRandWArg)
{

    DWORD dwError = ERROR_SUCCESS;
    DWORD dwFileSize;
    DWORD dwOffset;
    DWORD dwOffsetHigh;
    UCHAR uchData;
    
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    ULONG i;
    LONG WriteCount = 0;
    LONG PageCount = 0;
    PBYTE wArray = NULL;

    if (fSwDebug == TRUE) {
        MyPrintf(L"CmdRandW(%ws)\r\n", CmdRandWArg);
        if (fArgOffset == TRUE)
            MyPrintf(L"  OFFSET [%ws]\r\n", pwszOffsetArg);
    }

    srand( (unsigned)time( NULL ) );

    hFile = CreateFileW(
                    CmdRandWArg,                         // name
                    GENERIC_READ|GENERIC_WRITE,         // access mode
                    FILE_SHARE_READ|FILE_SHARE_WRITE,   // share mode
                    NULL,                               // security descriptor
                    OPEN_EXISTING,                      // create disposition
                    0,                                  // file statributes if created
                    NULL);                              // template handle
    if (hFile == INVALID_HANDLE_VALUE) {
        dwError = GetLastError();
        goto AllDone;
    }
    dwFileSize = GetFileSize(hFile, NULL);
    MyPrintf(L"File size = %d bytes\r\n", dwFileSize);

    if (fArgOffset == TRUE) {
        WriteCount = CountOffsetArgs(pwszOffsetArg, OffsetArgs);
        if (WriteCount == 0) {
            MyPrintf(L"No offsets specified, or  - nothing to do.\r\n");
            goto AllDone;
        } else if (WriteCount < 0) {
            MyPrintf(L"Error in offset list.  Exiting.\r\n");
            dwError = ERROR_INVALID_PARAMETER;
            goto AllDone;
        }
    } else {
        PageCount =  (dwFileSize / PAGESIZE);
        WriteCount = rand() % PageCount;
    }
    if (fSwDebug == TRUE) {
        wArray = calloc(1, PageCount * sizeof(BYTE));
        MyPrintf(L"There are %d pages in the file\r\n", PageCount);
    }
            
    if (dwFileSize == -1) {
        dwError = GetLastError();
        if (fSwDebug == TRUE)
            MyPrintf(L"GetFileSize() failed %d\r\n", dwError);
        goto AllDone;
    }
    if (dwFileSize == 0) {
        MyPrintf(L"0 sized file - nothing to do.\r\n");
        goto AllDone;
    }
    MyPrintf(L"Writing %d times\r\n", WriteCount);
    for (i = 0; i < (ULONG)WriteCount; ++i) {
        DWORD   dwReturn;
        
        if (fArgOffset == TRUE)
            dwOffset = OffsetArgs[i];
        else
            dwOffset = ((rand() % PageCount) * PAGESIZE) + (rand() % PAGESIZE);
        uchData = (UCHAR)rand();
        if (SetFilePointer(hFile, dwOffset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
            dwError = GetLastError();
            if (fSwDebug == TRUE)
                MyPrintf(L"SetFilePointer() failed %d\r\n", dwError);
            goto AllDone;
        }
        MyPrintf(L"writing 0x02%x Page %d offset %d (offset %d(0x%x))\r\n", uchData,
                        dwOffset / PAGESIZE,
                        dwOffset % PAGESIZE,
                        dwOffset,
                        dwOffset);
        if (wArray)
            wArray[dwOffset/PAGESIZE]++;
        if (!WriteFile(hFile, &uchData, 1, &dwReturn, NULL)) {
            dwError = GetLastError();
            if (fSwDebug == TRUE)
                MyPrintf(L"WriteFile() failed %d\r\n", dwError);
            goto AllDone;
        }
    }

    if (wArray) {
        for (i = 0; i < (ULONG)PageCount; i++) {
            MyPrintf(L"%d", wArray[i]);
            if ((i % 50) == 0)
                MyPrintf(L"\r\n");
        }
        MyPrintf(L"\r\n");
    }

    // If EOF is specified, truncate the file to a random length
    if (fSwEof == TRUE) {
        ULONG xx = rand() % 5;
        ULONG NewLen = (rand() * rand()) % (dwFileSize * 2);
        if (xx == 0 || xx == 1) {
            MyPrintf(L"New EOF = %d\r\n", NewLen);
            SetFilePointer(hFile, NewLen, 0, FILE_BEGIN);
            SetEndOfFile(hFile);
        } else {
            MyPrintf(L"No EOF change.\r\n");
        }
    }

AllDone:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (wArray)
        free(wArray);
    if (fSwDebug == TRUE)
        MyPrintf(L"CmdRandW exit %d\r\n", dwError);
    return dwError;
}

LONG
CountOffsetArgs(
    PWSTR OffsetArg,
    ULONG OffsetArray[])
{
    // Expect a string of the form "N,N,N,N" where each N can be hex OR decimal.
    // Store results in OffsetArray[]
    // Limit is MAX_OFFSETS offsets, to make things easy.

    ULONG i;
    PWCHAR wCp = OffsetArg;
    PWCHAR wNum = NULL;
    ULONG iRet;

    for (i = 0; i < MAX_OFFSETS; i++) {
        if (*wCp == L'\0')
            break;
        wNum = wCp;
        while (*wCp != L',' && *wCp != L'\0')
            wCp++;
        if (*wCp == L',')
            *wCp++ = L'\0';
        iRet = swscanf(wNum, L"%Li", &OffsetArray[i]);
        if (iRet <= 0)
            return -1;
    }
    if (fSwDebug == TRUE) {
        ULONG j;
        for (j = 0; j < i; j++)
            MyPrintf(L"[%d]-0x%x(%d)\r\n", j, OffsetArray[j], OffsetArray[j]);
        MyPrintf(L"CountOffsetArgs returning %d\r\n", i);
    }
    return i;
}

#if defined(CSCUTIL_INTERNAL)
DWORD
CmdBitcopy(
    PWSTR BitcopyArg)
{
	DWORD Error = ERROR_FILE_NOT_FOUND;
	LPWSTR  lpszTempName = NULL;

    if (!CSCCopyReplicaW(BitcopyArg, &lpszTempName)) {
        Error = GetLastError();
    } else {
        Error = ERROR_SUCCESS;
    }

	if (Error == ERROR_SUCCESS) {
        Error = DumpBitMap(lpszTempName);
        DeleteFile(lpszTempName);
    }

	return Error;
}
#endif // CSCUTIL_INTERNAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\util\cscutil\struct.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       struct.h
//
//-----------------------------------------------------------------------------

#ifndef _STRUCT_H
#define _STRUCT_H

//
// Globals
//

//
// Undocumented
//
extern BOOLEAN fSwDebug;

VOID
MyPrintf(
    PWCHAR format,
    ...);

VOID
MyFPrintf(
    HANDLE hHandle,
    PWCHAR format,
    ...);

//
// How we make args & switches
//

#define MAKEARG(x) \
    WCHAR Arg##x[] = L"/" L#x L":"; \
    LONG ArgLen##x = (sizeof(Arg##x) / sizeof(WCHAR)) - 1; \
    BOOLEAN fArg##x;

#define SWITCH(x) \
    WCHAR Sw##x[] = L"/" L#x ; \
    BOOLEAN fSw##x;

#endif _STRUCT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\util\cscutil\sources.inc ===
SOURCES=    \
            cscutil.c \
            cscutil.rc \
            messages.mc \
            misc.c \
            getinfo.c \
            db.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\util\cscutil\misc.c ===
//--------------------------------------------------------------------------
//
//  Copyright (C) 2000, Microsoft Corporation
//
//  File:       misc.c
//
//--------------------------------------------------------------------------

#define UNICODE 1

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <winldap.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <lm.h>
#include <rpc.h>

#include "struct.h"
#include "messages.h"

#define MAX_BUF_SIZE	10000

WCHAR MsgBuf[MAX_BUF_SIZE];
CHAR  AnsiBuf[MAX_BUF_SIZE*3];

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

VOID
MyFormatMessageText(
    HRESULT   dwMsgId,
    PWSTR     pszBuffer,
    DWORD     dwBufferSize,
    va_list   *parglist)
{
    DWORD dwReturn = 0;

    dwReturn = FormatMessage(
                            (dwMsgId >= MSG_FIRST_MESSAGE)
                                    ? FORMAT_MESSAGE_FROM_HMODULE
                                    : FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             dwMsgId,
                             LANG_USER_DEFAULT,
                             pszBuffer,
                             dwBufferSize,
                             parglist);

    if (dwReturn == 0)
        MyPrintf(L"Formatmessage failed %d\r\n", GetLastError());
}

VOID
ErrorMessage(
    IN HRESULT hr,
    ...)
{
    ULONG cch;
    va_list arglist;

    va_start(arglist, hr);
    MyFormatMessageText(hr, MsgBuf, ARRAYLEN(MsgBuf), &arglist);
    cch = WideCharToMultiByte(CP_OEMCP, 0,
                MsgBuf, wcslen(MsgBuf),
                AnsiBuf, MAX_BUF_SIZE*3,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), AnsiBuf, cch, &cch, NULL);
    va_end(arglist);
}

VOID
MyPrintf(
    PWCHAR format,
    ...)
{
    ULONG cch;
    va_list va;

    va_start(va, format);
    wvsprintf(MsgBuf, format, va);
    cch = WideCharToMultiByte(CP_OEMCP, 0,
                MsgBuf, wcslen(MsgBuf),
                AnsiBuf, MAX_BUF_SIZE*3,
                NULL, NULL);
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), AnsiBuf, cch, &cch, NULL);
    va_end(va);
    return;
}

VOID
MyFPrintf(
    HANDLE hHandle,
    PWCHAR format,
    ...)
{
    ULONG cch;
    va_list va;

    va_start(va, format);
    wvsprintf(MsgBuf, format, va);
    cch = WideCharToMultiByte(CP_OEMCP, 0,
                MsgBuf, wcslen(MsgBuf),
                AnsiBuf, MAX_BUF_SIZE*3,
                NULL, NULL);
    WriteFile(hHandle, AnsiBuf, cch, &cch, NULL);
    va_end(va);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\util\rovdo\rovdo.c ===
#define UNICODE
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winioctl.h>
#include <shdcom.h>

CHAR *ProgName = "cscgetinfo";

CHAR buf[10000];

_cdecl
main(LONG argc, CHAR *argv[])
{
    FILE *fh1;
    FILE *fh2;

    fh1 = fopen("\\\\jharperdc1\\vdo\\foo.txt", "r");
    if (fh1 == NULL) {
        printf("Open #1 failed %d\n", GetLastError());
        goto AllDone;
    }
    printf("ok1\n");
    while (fread(buf, sizeof(buf), 1, fh1) != 0)
        printf(".");
    printf("\n");
    fh2 = fopen("\\\\jharperdc1\\vdo\\foo.txt", "r+");
    if (fh2 == NULL) {
        printf("Open #2 failed %d\n", GetLastError());
        goto AllDone;
    }
    printf("ok2\n");
AllDone:
    gets(buf);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\util\cscutil\db.c ===
#define UNICODE
#define PUBLIC
#define PRIVATE
#include <stdlib.h>
#include <stdio.h>
#include <memory.h>
#include <string.h>
#include <windows.h>
#include <conio.h>
#include <share.h>
#include <dos.h>
#include <sddl.h>
#include "cscapi.h"
#include "csc_bmpc.h"
#pragma pack (1)

#include "struct.h"


#define  MAX_PQ_PER_PAGE   10
#define  MAX_SHARES_PER_PAGE  6
#define  MAX_FILE_PER_PAGE   4
#define  MAX_INODES_PER_PAGE   15

#define _wtoupper(x)     ( ( ((x)>='a')&&((x)<='z') ) ? ((x)-'a'+'A'):(x))

typedef PVOID   CSCHFILE;

#include "shdcom.h"
#include "cscsec.h"

#define  ESC       0x1b

#include "record.h"

#define InodeFromRec(ulRec, fFile)  ((ulRec+ULID_FIRST_USER_DIR-1) | ((fFile)?0x80000000:0))
#define RecFromInode(hShadow)       ((hShadow & 0x7fffffff) - (ULID_FIRST_USER_DIR-1))

WCHAR rgwch[256];
WCHAR rgPrint[1024];
WCHAR rgwchPar[256];

WCHAR Shadow[] = L"\\WINDOWS\\CSC";
WCHAR Backslash[] = L"\\";
WCHAR DbDir[256];    // shadow database
WCHAR Name[MAX_PATH];     // working buffer

extern BOOLEAN fSwDebug;

// The _DB is used to distinguish this from the kernel mode CSC_BITMAP
// or the usermode _U

typedef struct _CSC_BITMAP_DB {
    DWORD bitmapsize;  // size in bits. How many bits effective in the bitmap
    DWORD numDWORD;    // how many DWORDs to accomodate the bitmap */
    LPDWORD bitmap;    // The bitmap itself
} CSC_BITMAP_DB, *LPCSC_BITMAP_DB, *PCSC_BITMAP_DB;

// append this to inode file name to get the stream name
PWCHAR CscBmpAltStrmName = L":cscbmp";

LONG DispFunc(PWSTR);
LONG EditFileFunc(PWSTR, FILEREC *);
LONG EditShareFunc(PWSTR, SHAREREC *);
VOID DisplayShares(PWSTR);
VOID DisplayInodes(VOID);
VOID DisplayPriorityQ(VOID);
VOID DisplaySids(VOID);
VOID DisplayFile(ULONG ulid, PWSTR, BOOL fForce);
VOID EditFile(ULONG ulid);
VOID EditShare(ULONG ulid);
LONG HexToA(ULONG, PWSTR, LONG);

// From recordse.c
#define CSC_NUMBER_OF_SIDS_OFFSET (0x0)
#define CSC_SID_SIZES_OFFSET      (CSC_NUMBER_OF_SIDS_OFFSET + sizeof(ULONG))

VOID
FormNameStringDB(
   PWSTR lpdbID,
   ULONG ulidFile,
   PWSTR lpName);

BOOL
FindAncestor(
    ULONG ulid,
    ULONG *lpulidDir);

LONG
RoughCompareWideStringWithAnsiString(
    PWSTR   lpSrcString,
    USHORT  *lpwDstString,
    LONG     cntMax);

PWSTR
ConvertGmtTimeToString(
    FILETIME Time,
    PWSTR OutputBuffer);

int
DBCSC_BitmapIsMarked(
    LPCSC_BITMAP_DB lpbitmap,
    DWORD bitoffset);

int
DBCSC_BitmapAppendStreamName(
    PWCHAR fname,
    DWORD bufsize);

int
DBCSC_BitmapRead(
    LPCSC_BITMAP_DB *lplpbitmap,
    LPCTSTR filename);

VOID
DBCSC_BitmapOutput(
    FILE *outStrm,
    LPCSC_BITMAP_DB lpbitmap);

#if defined(CSCUTIL_INTERNAL)
CmdDb(PWSTR DbArg)
{
   BOOL fRet;
   DWORD junk;
   unsigned uAttr;
   int iRet = -1;
   if (DbArg == NULL) {
       fRet = CSCGetSpaceUsageW(
                    DbDir,
                    sizeof(DbDir)/sizeof(WCHAR),
                    &junk,
                    &junk,
                    &junk,
                    &junk,
                    &junk,
                    &junk);
       if (fRet == FALSE)
          wcscpy(DbDir, Shadow);
    } else {
       wcscpy(DbDir, DbArg);
    }
    if((uAttr = GetFileAttributesW(DbDir)) == 0xffffffff) {
       MyPrintf(L"Error accessing directory %ws \r\n", DbDir);
    } else if (!(uAttr & _A_SUBDIR)) {
       MyPrintf(L"%ws is not a directory\r\n", DbDir);
    } else {
       do {
           memset(rgwch, 0, sizeof(rgwch));
           MyPrintf(
               L"\r\n"
               L"(S)hares [name], "
               L"Pri(Q), "
               L"(O)wner, "
               L"(F)ile inode# [name], "
               L"(E)dit inode#, "
               L"e(D)it share#, "
               L"e(X)it "
               L":");
           if (!fgetws(rgwch, sizeof(rgwch)/sizeof(WCHAR), stdin))
               break;
           MyPrintf(L"\r\n");
           if (DispFunc(rgwch) == 0)
               break;
        } while (1);
       iRet = 0;
    }
   return (iRet);
}

LONG
DispFunc(PWSTR lpBuff)
{
    WCHAR wch;
    ULONG ulid;
    LONG cnt;

    // Chop leading blanks
    if (lpBuff != NULL)
        while (*lpBuff != L'\0' && *lpBuff == L' ')
            lpBuff++;

    cnt = swscanf(lpBuff, L"%c", &wch);

    if (!cnt)
        return 0;

    switch (wch) {
        // Display shares database
        case L's':
        case L'S':
            cnt = swscanf(lpBuff, L"%c%ws", &wch, rgwchPar);
            DisplayShares((cnt==2) ? rgwchPar : NULL);
            break;
        // display priority Q database
        case L'q':
        case L'Q':
            DisplayPriorityQ();
            break;
        case L'o':
        case L'O':
            DisplaySids();
            break;
        case L'f':
        case L'F':
            cnt = swscanf(lpBuff, L"%c%x%ws", &wch, &ulid, rgwchPar);
            if (cnt==2) {
                // display Inode file
                DisplayFile(ulid, NULL, (wch == 'F') ? TRUE : FALSE);
            } else if (cnt==3) {
                MyPrintf(L"Looking for %ws in 0x%x \r\n", rgwchPar, ulid);
                // display Inode file
                DisplayFile(ulid, rgwchPar, (wch == 'F') ? TRUE : FALSE);
            }
            break;
        case L'e':
        case L'E':
            cnt = swscanf(lpBuff, L"%c%x%ws", &wch, &ulid, rgwchPar);
            if (cnt==2) {
                // display Inode file
                EditFile(ulid);
            }
            break;
        case L'd':
        case L'D':
            cnt = swscanf(lpBuff, L"%c%x%ws", &wch, &ulid, rgwchPar);
            if (cnt==2) {
                // display Inode file
                EditShare(ulid);
            }
            break;
        case L'x':
        case L'X':
            return 0;
    }
    return 1;
}

VOID
DisplaySecurityContext2(
    PWSTR pSecurityDescriptor,
    LPRECORDMANAGER_SECURITY_CONTEXT   pSecurityContext)
{
    PCACHED_SECURITY_INFORMATION pCachedSecurityInformation;
    BOOL fGotOne = FALSE;
    ULONG i;

    pCachedSecurityInformation = (PCACHED_SECURITY_INFORMATION)pSecurityContext;

    for (i = 0; i < MAXIMUM_NUMBER_OF_USERS; i++) {
        CSC_SID_INDEX SidIndex;

        SidIndex = pCachedSecurityInformation->AccessRights[i].SidIndex;
        if (SidIndex != CSC_INVALID_SID_INDEX) {
            fGotOne = TRUE;
            break;
        }
    }

    if (fGotOne == FALSE)
        return;

    MyPrintf(L"%ws Security: ", pSecurityDescriptor);
    for (i = 0; i < MAXIMUM_NUMBER_OF_USERS; i++) {
        CSC_SID_INDEX SidIndex;

        SidIndex = pCachedSecurityInformation->AccessRights[i].SidIndex;
        if (SidIndex == CSC_INVALID_SID_INDEX) {
            continue;
        }else if (SidIndex == CSC_GUEST_SID_INDEX) {
            MyPrintf(L"(G:0x%x)",
                pCachedSecurityInformation->AccessRights[i].MaximalRights);
        } else {
            MyPrintf(L"(0x%x:0x%x)",
                SidIndex,
                pCachedSecurityInformation->AccessRights[i].MaximalRights);
        }
    }
    MyPrintf(L"\r\n");
}

VOID
DisplayShares(PWSTR ShareName)
{
    FILE *fp= NULL;
    SHAREHEADER sSH;
    SHAREREC sSR;
    ULONG ulrec = 0;
    LONG count = 0;
    WCHAR TimeBuf1[30];
    WCHAR TimeBuf2[30];

    FormNameStringDB(DbDir, ULID_SHARE, Name);
    if (fp = _wfopen(Name, L"rb")) {
        if (fread(&sSH, sizeof(SHAREHEADER), 1, fp) != 1) {
            MyPrintf(L"Error reading server header \r\n");
            goto bailout;
        }

        MyPrintf(L"Header: Flags=%x Version=%lx Records=%ld Size=%d \r\n",
                sSH.uFlags, sSH.ulVersion, sSH.ulRecords, sSH.uRecSize);

        MyPrintf(L"Store(Max): Size=%d Dirs=%d Files=%d\r\n",
                         sSH.sMax.ulSize,
                         sSH.sMax.ucntDirs,
                         sSH.sMax.ucntFiles);
        MyPrintf(L"Store(Cur): Size=%d Dirs=%d Files=%d\r\n",
                         sSH.sCur.ulSize,
                         sSH.sCur.ucntDirs,
                         sSH.sCur.ucntFiles);
        MyPrintf(L"\r\n");

        for (ulrec = 1; fread(&sSR, sizeof(SHAREREC), 1, fp) == 1; ulrec++) {
            if (sSR.uchType == (UCHAR)REC_DATA) {
                if (ShareName != NULL) {
                    if (RoughCompareWideStringWithAnsiString(
                            ShareName,
                            sSR.rgPath,
                            sizeof(sSR.rgPath)/sizeof(WCHAR)-1)
                    ) {
                        continue;
                    }
                }

                MyPrintf(L"%ws (0x%x) Root=0x%x\r\n",
                                sSR.rgPath,
                                ulrec,
                                sSR.ulidShadow);
                MyPrintf(L"  Status=0x%x RootStatus=0x%x "
                         L"HntFlgs=0x%x HntPri=0x%x Attr=0x%x\r\n",
                            sSR.uStatus,
                            (unsigned)(sSR.usRootStatus),
                            (unsigned)(sSR.uchHintFlags),
                            (unsigned)(sSR.uchHintPri),
                            sSR.dwFileAttrib);

                ConvertGmtTimeToString(sSR.ftLastWriteTime, TimeBuf1);
                ConvertGmtTimeToString(sSR.ftOrgTime, TimeBuf2);
                MyPrintf(L"  LastWriteTime: %ws Orgtime: %ws\r\n", TimeBuf1, TimeBuf2);

                DisplaySecurityContext2(L"  ShareLevel",&sSR.sShareSecurity);
                DisplaySecurityContext2(L"  Root ",&sSR.sRootSecurity);
                MyPrintf(L"\r\n");
            }
        }
    }
bailout:
    if (fp)
        fclose(fp);
}

VOID
DisplayPriorityQ(VOID)
{
   FILE *fp= NULL;
   QHEADER sQH;
   QREC sQR;
   ULONG ulRec = 1;
   LONG count = 0;

   FormNameStringDB(DbDir, ULID_PQ, Name);
   if (fp = _wfopen(Name, L"rb")) {
       if (fread(&sQH, sizeof(QHEADER), 1, fp) != 1) {
           MyPrintf(L"Error reading PQ header \r\n");
           goto bailout;
        }
       MyPrintf(L"Header: Flags=%x Version=%lx Records=%ld Size=%d head=%ld tail=%ld\r\n",
                    sQH.uchFlags,
                    sQH.ulVersion,
                    sQH.ulRecords,
                    sQH.uRecSize,
                    sQH.ulrecHead,
                    sQH.ulrecTail);
       MyPrintf(L"\r\n");
       MyPrintf(
       L"  REC SHARE      DIR   SHADOW   STATUS  PRI HINTFLGS HINTPRI  PREV  NEXT DIRENT\r\n");
       for (ulRec = sQH.ulrecHead; ulRec;) {
           fseek(fp, ((ulRec-1) * sizeof(QREC))+sizeof(QHEADER), SEEK_SET);
           if (fread(&sQR, sizeof(QREC), 1, fp)!=1)
               break;
           MyPrintf(L"%5d %5x %8x %8x %8x %4d %8x %7d %5d %5d %6d\r\n",
                        ulRec,
                        sQR.ulidShare,
                        sQR.ulidDir,
                        sQR.ulidShadow,
                        sQR.usStatus,
                        (unsigned)(sQR.uchRefPri),
                        (unsigned)(sQR.uchHintFlags),
                        (unsigned)(sQR.uchHintPri),
                        sQR.ulrecPrev,
                        sQR.ulrecNext,
                        sQR.ulrecDirEntry);
            ++count;
           ulRec = sQR.ulrecNext;
        }
    }
bailout:
   if (fp)
       fclose(fp);
}

VOID
DisplaySids(VOID)
{
   DWORD Status = ERROR_SUCCESS;
   ULONG SidOffset = 0;
   ULONG NumberOfSids;
   ULONG BytesRead;
   ULONG i;
   PCSC_SIDS pCscSids = NULL;
   FILE *fp = NULL;
   LPWSTR StringSid = NULL;
   SID_NAME_USE SidUse;
   BOOL bRet = FALSE;
   DWORD cbAcctName;
   DWORD cbDomainName;
   WCHAR AcctName[MAX_PATH];
   WCHAR DomainName[MAX_PATH];

   FormNameStringDB(DbDir, ULID_SID_MAPPINGS, Name);
   fp = _wfopen(Name, L"rb");
   if (fp == NULL) {
        MyPrintf(L"Error opening SID file\r\n");
        goto bailout;
    }
   fseek(fp, CSC_NUMBER_OF_SIDS_OFFSET, SEEK_SET);
   if (fread(&NumberOfSids, sizeof(NumberOfSids), 1, fp) != 1) {
        MyPrintf(L"Error reading # SIDS\r\n");
        goto bailout;
    }

    pCscSids = (PCSC_SIDS)malloc(sizeof(CSC_SIDS) + sizeof(CSC_SID) * NumberOfSids);

    if (pCscSids == NULL) {
        MyPrintf(L"Error allocating memory of SID array\n");
        goto bailout;
    }

    pCscSids->MaximumNumberOfSids = NumberOfSids;
    pCscSids->NumberOfSids = NumberOfSids;

    for (i = 0; i < NumberOfSids; i++)
        pCscSids->Sids[i].pSid = NULL;

    fseek(fp, CSC_SID_SIZES_OFFSET, SEEK_SET);
    if (fread(&pCscSids->Sids, sizeof(CSC_SID) * NumberOfSids, 1, fp) != 1) {
        MyPrintf(L"Error reading SIDS\r\n");
        goto bailout;
    }

    // The array structure has been initialized correctly. Each of the
    // individual sids needs to be initialized.
    SidOffset = CSC_SID_SIZES_OFFSET + sizeof(CSC_SID) * NumberOfSids;

    for (i = 0; i < NumberOfSids; i++) {
        pCscSids->Sids[i].pSid = malloc(pCscSids->Sids[i].SidLength);
        if (pCscSids->Sids[i].pSid == NULL) {
            MyPrintf(L"Error allocating memory of SID array\n");
            goto bailout;
        }
        fseek(fp, SidOffset, SEEK_SET);
        if (fread(pCscSids->Sids[i].pSid, pCscSids->Sids[i].SidLength, 1, fp) != 1) {
            MyPrintf(L"Error reading SIDS\r\n");
            goto bailout;
        }
        SidOffset += pCscSids->Sids[i].SidLength;
    }

    MyPrintf(L"MaximumNumberOfSids: %d\r\n"
             L"NumberOfSids: %d\r\n",
             pCscSids->MaximumNumberOfSids,
             pCscSids->NumberOfSids);
    for (i = 0; i < NumberOfSids; i++) {
        StringSid = NULL;
        if (ConvertSidToStringSid(pCscSids->Sids[i].pSid, &StringSid)) {
            MyPrintf(L"---0x%x (%d)---\r\n"
                     L"  SidLength: %d\r\n"
                     L"  Sid: %ws\r\n",
                     i+1, i+1,
                     pCscSids->Sids[i].SidLength,
                     StringSid);
            LocalFree(StringSid);
            StringSid = NULL;
            DomainName[0] = L'0';
            AcctName[0] = L'0';
            cbAcctName = sizeof(AcctName) / sizeof(WCHAR);
            cbDomainName = sizeof(DomainName) / sizeof(WCHAR);
            bRet = LookupAccountSid(
                        NULL,
                        pCscSids->Sids[i].pSid,
                        AcctName,
                        &cbAcctName,
                        DomainName,
                        &cbDomainName,
                        &SidUse);
            if (bRet) {
                MyPrintf(L"  Name: %ws%ws%ws\r\n",
                         DomainName,
                         DomainName[0] ? L"\\" : L"",
                         AcctName);
            } else {
                MyPrintf(L"  Name: <unknown>\r\n");
            }
        } else {
            MyPrintf(L"ConvertSidToStringSid returned %d\r\n", GetLastError());
        }
    }
bailout:
   if (fp)
       fclose(fp);
}

VOID
DisplayFile(
    ULONG ulid,
    PWSTR lpwszName,
    BOOL fForce)
{
    FILE *fp= NULL;
    FILEHEADER sFH;
    FILEREC sFR;
    LONG fLfn=0;
    ULONG ulidDir=ulid;
    LONG fPrintOvf = 0, count=0;
    WCHAR strmPath[MAX_PATH];
    LPCSC_BITMAP_DB lpbitmap = NULL;
    WCHAR TimeBuf1[30];
    WCHAR TimeBuf2[30];

    if (IsLeaf(ulid)) {
        if (!FindAncestor(ulid, &ulidDir))
            return;
    }

    FormNameStringDB(DbDir, ulidDir, Name);

    if (fp = _wfopen(Name, L"rb")) {
        if (fread(&sFH, sizeof(FILEHEADER), 1, fp) != 1) {
            MyPrintf(L"Error reading file header \r\n");
            goto bailout;
        }


        if (ulid == ulidDir) {
            MyPrintf(L"Header: Flags=%x Version=%lx Records=%ld Size=%d\r\n",
                        sFH.uchFlags, sFH.ulVersion, sFH.ulRecords, sFH.uRecSize);
            MyPrintf(L"Header: bytes=%ld entries=%d Share=%ld Dir=%lx\r\n",
                        sFH.ulsizeShadow, sFH.ucShadows, sFH.ulidShare, sFH.ulidDir);
            printf ("\r\n");
            fPrintOvf = 1;
        }

        while (fread(&sFR, sizeof(FILEREC), 1, fp)==1) {
            if (sFR.uchType != (unsigned char)REC_OVERFLOW) {
                if (fLfn) {
                    if (ulidDir != ulid)
                        break;
                }
                fLfn = 0;
            }
            if (sFR.uchType==(unsigned char)REC_DATA) {
                if (ulidDir != ulid) {
                    if (ulid != sFR.ulidShadow)
                        continue;
                }
                if (lpwszName) {
                    if (RoughCompareWideStringWithAnsiString(
                            lpwszName,
                            sFR.rgwName,
                            sizeof(sFR.rgw83Name)/sizeof(WCHAR)-1)
                    ) {
                        continue;
                    }
                }

                fPrintOvf = 1;
                MyPrintf(L"%ws (0x%x)\r\n", sFR.rgw83Name, sFR.ulidShadow);
                if (fForce == TRUE) {
                    MyPrintf(L"  Type=%c Flags=0x%x status=0x%x size=%ld attrib=0x%lx\r\n",
                                sFR.uchType,
                                (unsigned)sFR.uchFlags,
                                sFR.uStatus,
                                sFR.ulFileSize,
                                sFR.dwFileAttrib);
                    MyPrintf(L"  PinFlags=0x%x PinCount=%d RefPri=%d OriginalInode=0x%0x\r\n",
                                 (unsigned)(sFR.uchHintFlags),
                                 (int)(sFR.uchHintPri),
                                 (int)(sFR.uchRefPri),
                                 sFR.ulidShadowOrg);
                    ConvertGmtTimeToString(sFR.ftLastWriteTime, TimeBuf1);
                    ConvertGmtTimeToString(sFR.ftOrgTime, TimeBuf2);
                    MyPrintf(L"  LastWriteTime: %ws Orgtime: %ws\r\n", TimeBuf1, TimeBuf2);
                    if (sFR.rgwName[0]) {
                        MyPrintf(L"  LFN:%ws", sFR.rgwName);
                        fLfn = 1;
                    }

                    MyPrintf(L"\r\n");
                    DisplaySecurityContext2(L" ",&sFR.Security);

                    if (ulidDir != ulid) {
                        MyPrintf(L"  DirInode = 0x%x\r\n", ulidDir);
                        FormNameStringDB(DbDir, sFR.ulidShadow, strmPath);
                        DBCSC_BitmapAppendStreamName(strmPath, MAX_PATH);
                        // read bitmap
                        switch(DBCSC_BitmapRead(&lpbitmap, strmPath)) {
                            case 1:
                                // Print the bitmap associated if any
                                MyPrintf(L"\r\n");
                                DBCSC_BitmapOutput(stdout, lpbitmap);
                                MyPrintf(L"\r\n");
                                // if bitmap opened delete bitmap
                                // DBCSC_BitmapDelete(&lpbitmap);
                                break;
                            case -1:
                                MyPrintf(L"Error reading bitmap file %ws or bitmap invalid\r\n",
                                                strmPath);
                                break;
                            case -2:
                                MyPrintf(L"No CSCBitmap\n");
                                break;
                            case 0:
                            default:
                                MyPrintf(L"Something strange going on with bitmap printing...\r\n");
                                break;
                        }
                        break;
                    }
                    MyPrintf(L"\r\n");
                } else if (fPrintOvf && (sFR.uchType == (unsigned char)REC_OVERFLOW)) {
                    MyPrintf(L"(overflow) ");
                    MyPrintf(L"%ws\r\n\r\n", sFR.rgwOvf);
                }
            }

            // do counting only when we are scanning the whole directory
            if (!lpwszName &&  (ulid == ulidDir)) {
                ++count;
            }
        }
        MyPrintf(L"\r\n");
    }
bailout:
    if (fp)
        fclose(fp);
}

VOID
EditFile(
    ULONG ulid)
{
    FILE *fp= NULL;
    FILEHEADER sFH;
    FILEREC sFR;
    ULONG ulidDir=ulid;
    WCHAR TimeBuf1[30];
    WCHAR TimeBuf2[30];
    LONG iRes;

    if (!IsLeaf(ulid)) {
        MyPrintf(L"0x%x is a directory.\r\n", ulid);
        return;
    }

    if (!FindAncestor(ulid, &ulidDir))
        return;

    FormNameStringDB(DbDir, ulidDir, Name);

    if (fp = _wfopen(Name, L"rb+")) {
        if (fread(&sFH, sizeof(FILEHEADER), 1, fp) != 1) {
            MyPrintf(L"Error reading file header \r\n");
            goto bailout;
        }

        while (fread(&sFR, sizeof(FILEREC), 1, fp)==1) {
            if (sFR.uchType == (unsigned char)REC_OVERFLOW) {
                continue;
            }
            if (sFR.uchType==(unsigned char)REC_DATA) {
                if (ulid != sFR.ulidShadow)
                    continue;
                do {
                    MyPrintf(L"---------------------------------------------\r\n");
                    MyPrintf(L"%ws (0x%x)\r\n", sFR.rgw83Name, sFR.ulidShadow);

                    MyPrintf(L"  Type=%c Flags=0x%x status=0x%x size=%ld attrib=0x%lx\r\n",
                                sFR.uchType,
                                (unsigned)sFR.uchFlags,
                                sFR.uStatus,
                                sFR.ulFileSize,
                                sFR.dwFileAttrib);
                    MyPrintf(L"  PinFlags=0x%x PinCount=%d RefPri=%d OriginalInode=0x%0x\r\n",
                                 (unsigned)(sFR.uchHintFlags),
                                 (int)(sFR.uchHintPri),
                                 (int)(sFR.uchRefPri),
                                 sFR.ulidShadowOrg);
                    ConvertGmtTimeToString(sFR.ftLastWriteTime, TimeBuf1);
                    ConvertGmtTimeToString(sFR.ftOrgTime, TimeBuf2);
                    MyPrintf(L"  LastWriteTime: %ws Orgtime: %ws\r\n", TimeBuf1, TimeBuf2);
                    MyPrintf(L"  DirInode = 0x%x\r\n", ulidDir);

                    memset(rgwch, 0, sizeof(rgwch));
                    MyPrintf(
                            L"\r\n"
                            L"(F)lags, "
                            L"(S)tatus, "
                            L"si(Z)e , "
                            L"(A)ttrib, "
                            L"e(X)it "
                            L":");
                    if (!fgetws(rgwch, sizeof(rgwch)/sizeof(WCHAR), stdin))
                        break;
                    MyPrintf(L"\r\n");
                        iRes = EditFileFunc(rgwch, &sFR);
                        if (iRes == 0) {
                           break;
                        } else if (iRes == 1) {
                            fseek(fp, ftell(fp) - sizeof(FILEREC), SEEK_SET);
                            fwrite(&sFR, sizeof(FILEREC), 1, fp);
                        }
                } while (1);
            }
        }
        MyPrintf(L"\r\n");
    }
bailout:
    if (fp)
        fclose(fp);
}

LONG
EditFileFunc(
    PWSTR lpBuff,
    FILEREC *sFR)
{
    WCHAR wch;
    ULONG NewFlags;
    ULONG NewStatus;
    ULONG NewSize;
    ULONG NewAttrib;
    LONG cnt;

    // Tristate return:
    // 0 -> exit
    // 1 -> write updated sFR
    // 2 -> don't write updated sFR

    // Chop leading blanks
    if (lpBuff != NULL)
        while (*lpBuff != L'\0' && *lpBuff == L' ')
            lpBuff++;

    cnt = swscanf(lpBuff, L"%c", &wch);

    if (!cnt)
        return 0;

    switch (wch) {
        // Edit flags
        case L'f':
        case L'F':
            cnt = swscanf(lpBuff, L"%c%x", &wch, &NewFlags);
            if (cnt != 2)
                return 2;
            MyPrintf(L"Flags 0x%x -> 0x%x\r\n", (unsigned)sFR->uchFlags, NewFlags);
            sFR->uchFlags = (char)NewFlags;
            break;
        // Edit status
        case L's':
        case L'S':
            cnt = swscanf(lpBuff, L"%c%x", &wch, &NewStatus);
            if (cnt != 2)
                return 2;
            MyPrintf(L"Status 0x%x -> 0x%x\r\n", sFR->uStatus, NewStatus);
            sFR->uStatus = (USHORT)NewStatus;
            break;
        // Edit size
        case L'z':
        case L'Z':
            cnt = swscanf(lpBuff, L"%c%x", &wch, &NewSize);
            if (cnt != 2)
                return 2;
            MyPrintf(L"Size 0x%x -> 0x%x\r\n", sFR->ulFileSize, NewSize);
            sFR->ulFileSize = NewSize;
            break;
        // Edit attrib
        case L'a':
        case L'A':
            cnt = swscanf(lpBuff, L"%c%x", &wch, &NewAttrib);
            if (cnt != 2)
                return 2;
            MyPrintf(L"Attrib 0x%x -> 0x%x\r\n", sFR->dwFileAttrib, NewAttrib);
            sFR->dwFileAttrib = NewAttrib;
            break;
        // Exit
        case L'x':
        case L'X':
            return 0;
    }
    return 1;
}

VOID
EditShare(
    ULONG ulid)
{
    FILE *fp= NULL;
    SHAREHEADER sSH;
    SHAREREC sSR;
    WCHAR TimeBuf1[30];
    WCHAR TimeBuf2[30];
    LONG iRes;
    ULONG ulrec = 0;

    FormNameStringDB(DbDir, ULID_SHARE, Name);

    if (fp = _wfopen(Name, L"rb+")) {
        if (fread(&sSH, sizeof(SHAREHEADER), 1, fp) != 1) {
            MyPrintf(L"Error reading server header \r\n");
            goto bailout;
        }

        for (ulrec = 1; fread(&sSR, sizeof(SHAREREC), 1, fp) == 1; ulrec++) {
            if (sSR.uchType == (UCHAR)REC_DATA) {
                if (ulid != ulrec)
                    continue;
                do {
                    MyPrintf(L"---------------------------------------------\r\n");

                    MyPrintf(L"%ws (0x%x) Root=0x%x\r\n",
                                sSR.rgPath,
                                ulrec,
                                sSR.ulidShadow);
                    MyPrintf(L"  Status=0x%x RootStatus=0x%x "
                             L"HntFlgs=0x%x HntPri=0x%x Attr=0x%x\r\n",
                                sSR.uStatus,
                                (unsigned)(sSR.usRootStatus),
                                (unsigned)(sSR.uchHintFlags),
                                (unsigned)(sSR.uchHintPri),
                                sSR.dwFileAttrib);

                    memset(rgwch, 0, sizeof(rgwch));
                    MyPrintf(
                            L"\r\n"
                            L"(S)tatus, "
                            L"(R)ootStatus, "
                            L"Hnt(F)lgs , "
                            L"Hnt(P)ri, "
                            L"(A)ttr , "
                            L"e(X)it "
                            L":");
                    if (!fgetws(rgwch, sizeof(rgwch)/sizeof(WCHAR), stdin))
                        break;
                    MyPrintf(L"\r\n");
                        iRes = EditShareFunc(rgwch, &sSR);
                        if (iRes == 0) {
                           break;
                        } else if (iRes == 1) {
                            fseek(fp, ftell(fp) - sizeof(SHAREREC), SEEK_SET);
                            fwrite(&sSR, sizeof(SHAREREC), 1, fp);
                        }
                } while (1);
            }
        }
        MyPrintf(L"\r\n");
    }
bailout:
    if (fp)
        fclose(fp);
}

LONG
EditShareFunc(
    PWSTR lpBuff,
    SHAREREC *sSR)
{
    WCHAR wch;
    ULONG NewStatus;
    ULONG NewRootStatus;
    ULONG NewHntFlgs;
    ULONG NewHntPri;
    ULONG NewAttr;
    LONG cnt;

    // Tristate return:
    // 0 -> exit
    // 1 -> write updated sSR
    // 2 -> don't write updated sSR

    // Chop leading blanks
    if (lpBuff != NULL)
        while (*lpBuff != L'\0' && *lpBuff == L' ')
            lpBuff++;

    cnt = swscanf(lpBuff, L"%c", &wch);

    if (!cnt)
        return 0;

    switch (wch) {
        // Edit status
        case L's':
        case L'S':
            cnt = swscanf(lpBuff, L"%c%x", &wch, &NewStatus);
            if (cnt != 2)
                return 2;
            MyPrintf(L"Status 0x%x -> 0x%x\r\n", (ULONG)sSR->uStatus, NewStatus);
            sSR->uStatus = (USHORT)NewStatus;
            break;
        // Edit RootStatus
        case L'r':
        case L'R':
            cnt = swscanf(lpBuff, L"%c%x", &wch, &NewRootStatus);
            if (cnt != 2)
                return 2;
            MyPrintf(L"RootStatus 0x%x -> 0x%x\r\n", (ULONG)sSR->usRootStatus, NewRootStatus);
            sSR->usRootStatus = (USHORT)NewRootStatus;
            break;
        // Edit HntFlgs
        case L'f':
        case L'F':
            cnt = swscanf(lpBuff, L"%c%x", &wch, &NewHntFlgs);
            if (cnt != 2)
                return 2;
            MyPrintf(L"HntFlgs 0x%x -> 0x%x\r\n", (ULONG)sSR->uchHintFlags, NewHntFlgs);
            sSR->uchHintFlags = (char)NewHntFlgs;
            break;
        // Edit HntPri
        case L'p':
        case L'P':
            cnt = swscanf(lpBuff, L"%c%x", &wch, &NewHntPri);
            if (cnt != 2)
                return 2;
            MyPrintf(L"HntPri 0x%x -> 0x%x\r\n", (ULONG)sSR->uchHintPri, NewHntPri);
            sSR->uchHintPri = (char)NewHntPri;
            break;
        // Edit attrib
        case L'a':
        case L'A':
            cnt = swscanf(lpBuff, L"%c%x", &wch, &NewAttr);
            if (cnt != 2)
                return 2;
            MyPrintf(L"Attrib 0x%x -> 0x%x\r\n", sSR->dwFileAttrib, NewAttr);
            sSR->dwFileAttrib = NewAttr;
            break;
        // Exit
        case L'x':
        case L'X':
            return 0;
    }
    return 1;
}

VOID
FormNameStringDB(
   PWSTR lpdbID,
   ULONG ulidFile,
   PWSTR lpName)
{
   PWSTR lp;
   WCHAR wchSubdir;

    // Prepend the local path
   wcscpy(lpName, lpdbID);
   wcscat(lpName, Backslash);

    // Bump the pointer appropriately
   lp = lpName + wcslen(lpName);

   wchSubdir = CSCDbSubdirSecondChar(ulidFile);

   // sprinkle the user files in one of the subdirectories
   if (wchSubdir) {
       // now append the subdirectory
       *lp++ = CSCDbSubdirFirstChar();
       *lp++ = wchSubdir;
       *lp++ = L'\\';
   }


   HexToA(ulidFile, lp, 8);

   lp += 8;
    *lp = 0;
}

LONG
HexToA(
   ULONG ulHex,
   PWSTR lpName,
   LONG count)
{
   int i;
   PWSTR lp = lpName + count - 1;
   WCHAR wch;

   for (i = 0; i < count; ++i) {
       wch = (WCHAR)(ulHex & 0xf) + L'0';
       if (wch > '9')
           wch += 7;    // A becomes '0' + A + 7 which is 'A'
        *lp = wch;
        --lp;
       ulHex >>= 4;
    }
    *(lpName+count) = '\0';
   return 0;
}

BOOL
FindAncestor(
    ULONG ulid,
    ULONG *lpulidDir)
{
    ULONG ulRec = RecFromInode(ulid);
    FILE *fp= (FILE *)NULL;
    QHEADER sQH;
    QREC sQR;
    BOOL fRet = FALSE;

    *lpulidDir = 0;

    FormNameStringDB(DbDir, ULID_PQ, Name);
    if (fp = _wfopen(Name, L"rb")) {
        if (fread(&sQH, sizeof(QHEADER), 1, fp) != 1) {
            MyPrintf(L"Error reading PQ header \r\n");
            goto bailout;
         }

         fseek(fp, ((ulRec-1) * sizeof(QREC))+sizeof(QHEADER), SEEK_SET);

         if (fread(&sQR, sizeof(QREC), 1, fp)!=1)
            goto bailout;
         *lpulidDir = sQR.ulidDir;
         fRet = TRUE;
     }
 bailout:
    if (fp)
        fclose(fp);
    return fRet;
}

LONG
RoughCompareWideStringWithAnsiString(
    PWSTR   lpSrcString,
    USHORT  *lpwDstString,
    LONG     cntMax)
{
    WCHAR wch;
    USHORT  uch;
    LONG i;

    for (i = 0; i < cntMax; ++i) {
        wch = *lpSrcString++;
        uch = *lpwDstString++;
        wch = _wtoupper(wch);
        uch = _wtoupper(uch);

        if (!wch) {
            return 0;
        }

        if (wch != uch) {
            return (uch - wch);
        }
    }
    if (i == cntMax) {
        return 0;
    }

    return 1;   // this should never occur
}

/*++

    DBCSC_BitmapIsMarked()

Routine Description:


Arguments:


Returns:

    -1 if lpbitmap is NULL or bitoffset is larger than the bitmap
    TRUE if the bit is marked
    FALSE if the bit is unmarked

Notes:

--*/
int
DBCSC_BitmapIsMarked(
    LPCSC_BITMAP_DB lpbitmap,
    DWORD bitoffset)
{
    DWORD DWORDnum;
    DWORD bitpos;

    if (lpbitmap == NULL)
        return -1;
    if (bitoffset >= lpbitmap->bitmapsize)
        return -1;

    DWORDnum = bitoffset/(8*sizeof(DWORD));
    bitpos = 1 << bitoffset%(8*sizeof(DWORD));

    if (lpbitmap->bitmap[DWORDnum] & bitpos)
        return TRUE;

    return FALSE;
}

/*++

    DBCSC_BitmapAppendStreamName()

Routine Description:

    Appends the CSC stream name to the existing path/file name fname.

Arguments:

    fname is the sting buffer containing the path/file.
    bufsize is the buffer size.

Returns:

    TRUE if append successful.
    FALSE if buffer is too small or other errors.

Notes:

    Unicode strings only.

--*/
int
DBCSC_BitmapAppendStreamName(
    PWCHAR fname,
    DWORD bufsize)
{
    if ((wcslen(fname) + wcslen(CscBmpAltStrmName) + 1) > bufsize)
        return FALSE;
    wcscat(fname, CscBmpAltStrmName);
    return TRUE;
}

/*++

    DBCSC_BitmapRead()

Routine Description:

    Reads the on-disk bitmap file, and if it exists, is not in use and valid,
    store it in *lplpbitmap. If *lplpbitmap is NULL allocate a new
    bitmap data structure. Otherwise, if *lplpbitmap is not NULL, the
    existing bitmap will be deleted and assigned the on-disk bitmap
    file.

Arguments:

    filename is the file that contains the bitmap. If read from a
    stream, append the stream name before passing the filename in. The
    filename is used as is and no checking of validity of the name is
    performed. For default stream name, append the global LPSTR
    CscBmpAltStrmName.

Returns:

    1 if read successful
    0 if lplpbitmap is NULL
    -1 if error in disk operation (open/read), memory allocating error,
          or invalid bitmap file format.
    -2 if bitmap not exist

Notes:

    CODE.IMPROVEMENT design a better error message propagation mechanism.
    Bitmap open for exclusive access.

--*/
int
DBCSC_BitmapRead(
    LPCSC_BITMAP_DB *lplpbitmap,
    LPCTSTR filename)
{
    CscBmpFileHdr hdr;
    HANDLE bitmapFile;
    DWORD bytesRead;
    DWORD bitmapByteSize;
    DWORD * bitmapBuf = NULL;
    DWORD errCode;
    int ret = 1;

    if (fSwDebug)
        MyPrintf(L"BitmapRead(%ws)\r\n", filename);

    if (lplpbitmap == NULL)
        return 0;

    bitmapFile = CreateFile(
                    filename,
                    GENERIC_READ,
                    0, // No sharing; exclusive
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
    if (bitmapFile == INVALID_HANDLE_VALUE) {
        errCode = GetLastError();
        if (fSwDebug)
            MyPrintf(L"BitmapRead!Createfile error %d\r\n", errCode);
        if (errCode == ERROR_FILE_NOT_FOUND) {
            // File does not exist
            return -2;
        }
        return -1;
    }

    if (!ReadFile(
            bitmapFile,
            &hdr, 
            sizeof(CscBmpFileHdr),
            &bytesRead,
            NULL)
    ) {
        if (fSwDebug)
            MyPrintf(L"BitmapRead!ReadFile of header error %d\r\n", GetLastError());
        ret = -1;
        goto CLOSEFILE;
    }

    MyPrintf(
        L"---Header---\r\n"
        L"MagicNum: 0x%x\r\n"
        L"inuse: 0x%x\r\n"
        L"valid: 0x%x\r\n"
        L"sizeinbits:0x%x\r\n"
        L"numDWORDS:0x%x\r\n",
            hdr.magicnum,
            hdr.inuse,
            hdr.valid,
            hdr.sizeinbits,
            hdr.numDWORDs);

    if (bytesRead != sizeof(CscBmpFileHdr)) {
        if (fSwDebug)
            MyPrintf(L"BitmapRead!ReadFile bytesRead != sizeof(CscBmpFileHdr).\r\n");
        ret = -1;
        goto CLOSEFILE;
    }
    if (hdr.magicnum != MAGICNUM) {
        if (fSwDebug)
            MyPrintf(L"BitmapRead!ReadFile hdr.magicnum != MAGICNUM.\r\n");
        ret = -1;
        goto CLOSEFILE;
    }
    if (!hdr.valid) {
        if (fSwDebug)
            MyPrintf(L"BitmapRead!ReadFile !hdr.valid.\r\n");
        ret = -1;
        goto CLOSEFILE;
    }
    if (hdr.inuse) {
        if (fSwDebug)
            MyPrintf(L"BitmapRead!ReadFile hdr.inuse.\r\n");
        ret = -1;
        goto CLOSEFILE;
    }

    if (hdr.sizeinbits > 0) {
        bitmapByteSize = hdr.numDWORDs*sizeof(DWORD);
        bitmapBuf = (DWORD *)malloc(bitmapByteSize);
        if (!bitmapBuf) {
            if (fSwDebug)
                MyPrintf(L"BitmapRead!malloc failed\r\n");
            ret = -1;
            goto CLOSEFILE;
        }

        if (!ReadFile(
                bitmapFile,
                bitmapBuf,
                bitmapByteSize,
                &bytesRead,
                NULL)
        ) {
            if (fSwDebug)
                MyPrintf(L"BitmapRead!ReadFile of bitmap error %d\r\n", GetLastError());
            ret = -1;
            goto CLOSEFILE;
        }

        if (bytesRead != bitmapByteSize) {
            if (fSwDebug)
                MyPrintf(
                    L"BitmapRead!ReadFile wrong size (%d vs %d).\r\n",
                        bytesRead,
                        bitmapByteSize);
            ret = -1;
            goto CLOSEFILE;
        }
    }

    if (*lplpbitmap) {
        // bitmap exist, dump old and create new
        if ((*lplpbitmap)->bitmap)
            free((*lplpbitmap)->bitmap);
        (*lplpbitmap)->bitmap = bitmapBuf;
        (*lplpbitmap)->numDWORD = hdr.numDWORDs;
        (*lplpbitmap)->bitmapsize = hdr.sizeinbits;
    } else {
        // bitmap not exist, create brand new
        *lplpbitmap = (LPCSC_BITMAP_DB)malloc(sizeof(CSC_BITMAP_DB));
        if (!(*lplpbitmap)) {
            // Error in memory allocation
            ret = -1;
            goto CLOSEFILE;
        }
        (*lplpbitmap)->bitmap = bitmapBuf;
        (*lplpbitmap)->numDWORD = hdr.numDWORDs;
        (*lplpbitmap)->bitmapsize = hdr.sizeinbits;
    }

CLOSEFILE:
    CloseHandle(bitmapFile);

    return ret;
}

/*++

    DBCSC_BitmapOutput()

Routine Description:

    Outputs the passed in bitmap to the ouput file stream outStrm

Arguments:


Returns:


Notes:


--*/
void
DBCSC_BitmapOutput(
    FILE * outStrm,
    LPCSC_BITMAP_DB lpbitmap)
{
    DWORD i;

    if (lpbitmap == NULL) {
        MyPrintf(L"lpbitmap is NULL\r\n");
        return;
    }

    MyPrintf(L"lpbitmap 0x%08x, bitmapsize 0x%x numDWORD 0x%x\r\n",
                (ULONG_PTR)lpbitmap, lpbitmap->bitmapsize, lpbitmap->numDWORD);

    MyPrintf(L"bitmap  |0/5        |1/6        |2/7        |3/8        |4/9\r\n");
    MyPrintf(L"number  |01234|56789|01234|56789|01234|56789|01234|56789|01234|56789");
    for (i = 0; i < lpbitmap->bitmapsize; i++) {
        if ((i % 50) == 0)
            MyPrintf(L"\r\n%08d", i);
        if ((i % 5) == 0)
            MyPrintf(L"|");
        MyPrintf(L"%1d", DBCSC_BitmapIsMarked(lpbitmap, i));
    }
    MyPrintf(L"\r\n");
}

DWORD
DumpBitMap(
    LPWSTR lpszTempName)
{
    WCHAR  lpszBitMapName[MAX_PATH];
    LPCSC_BITMAP_DB lpbitmap = NULL;
    DWORD dwError = ERROR_SUCCESS;

    wcscpy(lpszBitMapName,lpszTempName);
    DBCSC_BitmapAppendStreamName(lpszBitMapName, MAX_PATH);
    // read bitmap
    switch(DBCSC_BitmapRead(&lpbitmap, lpszBitMapName)) {
        case 1:
            // Print the bitmap associated if any
            MyPrintf(L"\r\n");
            DBCSC_BitmapOutput(stdout, lpbitmap);
            MyPrintf(L"\r\n");
            // if bitmap opened delete bitmap
            // DBCSC_BitmapDelete(&lpbitmap);
            break;
        case -1:
            MyPrintf(L"Error reading bitmap file %ws or bitmap invalid\r\n", lpszBitMapName);
            dwError = ERROR_FILE_NOT_FOUND;
            break;
        case -2:
            MyPrintf(L"No CSCBitmap\n");
            dwError = ERROR_FILE_NOT_FOUND;
            break;
        case 0:
        default:
            MyPrintf(L"Something strange going on with bitmap printing...\r\n");
            dwError = ERROR_FILE_NOT_FOUND;
            break;
    }
    return dwError;
}

#endif // CSCUTIL_INTERNAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\csc\util\cscutil\getinfo.c ===
#define UNICODE
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winioctl.h>
#include <shdcom.h>

#include <smbdebug.h>

#include "struct.h"

PBYTE InBuf[0x50];
PBYTE OutBuf = NULL;

#define STATUS_SUCCESS                   ((ULONG)0x00000000L)
#define STATUS_BUFFER_TOO_SMALL          ((ULONG)0xC0000023L)

PWCHAR CscStateArray[] = {
    L"Shadowing",
    L"Disconnected",
    L"TransitioningToShadowing",
    L"TransitioningtoDisconnected"
};


DWORD
CmdInfo(ULONG Cmd)
{
    BOOL bResult;
    HANDLE  hShadow=NULL;
    ULONG junk;
    PULONG pl = NULL;
    PIOCTL_GET_DEBUG_INFO_ARG pInfoArg = NULL;
    ULONG i;
    ULONG j;
    ULONG BufSize = 0x1000;
    ULONG Status = 0;

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdInfo(0x%x)\r\n", Cmd);

TryAgain:

    OutBuf = malloc(BufSize);

    if (OutBuf == NULL) {
        MyPrintf(L"CmdInfo:Couldn't alloc memory\r\n");
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto AllDone;
    }

    hShadow = CreateFile(
                    L"\\\\.\\shadow",
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL);

    if (hShadow == INVALID_HANDLE_VALUE) {
        MyPrintf(L"CmdInfo:Failed open of shadow device\r\n");
        Status = GetLastError();
        goto AllDone;
    }

    memset(InBuf, 0, sizeof(InBuf));
    pl = (PULONG)InBuf;
    *pl = Cmd;

    bResult = DeviceIoControl(
                hShadow,                        // device 
                IOCTL_GET_DEBUG_INFO,           // control code
                (LPVOID)InBuf,                  // in buffer
                sizeof(InBuf),                  // inbuffer size
                (LPVOID)OutBuf,                 // out buffer
                BufSize,                        // out buffer size
                &junk,                          // bytes returned
                NULL);                          // overlapped

    CloseHandle(hShadow);

    if (!bResult) {
        MyPrintf(L"CmdInfo:DeviceIoControl failed\n");
        Status = GetLastError();
        goto AllDone;
    }

    pInfoArg = (PIOCTL_GET_DEBUG_INFO_ARG) OutBuf;
    if (bResult && pInfoArg->Status == STATUS_SUCCESS) {
        if (Cmd == DEBUG_INFO_SERVERLIST) {
            if (pInfoArg->Version != 2 && pInfoArg->Version != 3 && pInfoArg->Version != 4) {
                MyPrintf(L"Incorrect version.\r\n");
                goto AllDone;
            }
            for (i = 0; i < pInfoArg->EntryCount; i++) {
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].Name, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].DomainName, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].DfsRootName, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].DnsName, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].pNetRoots, OutBuf);
                for (j = 0; j < pInfoArg->ServerEntryObject[i].NetRootEntryCount; j++)
                    OFFSET_TO_POINTER(pInfoArg->ServerEntryObject[i].pNetRoots[j].Name, OutBuf);
            }
            MyPrintf(L"Status:        0x%x\r\n"
                     L"Version:       %d\r\n"
                     L"Entries:       %d\r\n",
                       pInfoArg->Status,
                       pInfoArg->Version,
                       pInfoArg->EntryCount);
            for (i = 0; i < pInfoArg->EntryCount; i++) {
                PWCHAR FlagDesc = NULL;
                MyPrintf(L"=================================================\r\n");
                MyPrintf(L"Name:                                    %ws\r\n"
                         L"DomainName:                              %ws\r\n"
                         L"ServerStatus:                            0x%x\r\n"
                         L"DfsRootName:                             %ws\r\n"
                         L"DnsName:                                 %ws\r\n"
                         L"SecuritySignaturesEnabled:               0x%x\r\n"
                         L"Server.CscState:                         0x%x (%ws)\r\n"
                         L"Sever.IsFakeDfsServerForOfflineUse:      0x%x\r\n"
                         L"Sever.IsPinnedOffline:                   0x%x\r\n"
                         L"NetRootEntryCount:                       0x%x\r\n"
                         L"=================================================\n",
                            pInfoArg->ServerEntryObject[i].Name,
                            pInfoArg->ServerEntryObject[i].DomainName,
                            pInfoArg->ServerEntryObject[i].ServerStatus,
                            pInfoArg->ServerEntryObject[i].DfsRootName,
                            pInfoArg->ServerEntryObject[i].DnsName,
                            pInfoArg->ServerEntryObject[i].SecuritySignaturesEnabled,
                            pInfoArg->ServerEntryObject[i].CscState,
                            CscStateArray[pInfoArg->ServerEntryObject[i].CscState],
                            pInfoArg->ServerEntryObject[i].IsFakeDfsServerForOfflineUse,
                            pInfoArg->ServerEntryObject[i].IsPinnedOffline,
                            pInfoArg->ServerEntryObject[i].NetRootEntryCount);
                for (j = 0; j < pInfoArg->ServerEntryObject[i].NetRootEntryCount; j++) {
                    switch (pInfoArg->ServerEntryObject[i].pNetRoots[j].CscFlags) {
                    case 0x0: FlagDesc = L"SMB_CSC_CACHE_MANUAL_REINT"; break;
                    case 0x4: FlagDesc = L"SMB_CSC_CACHE_AUTO_REINT"; break;
                    case 0x8: FlagDesc = L"SMB_CSC_CACHE_VDO"; break;
                    case 0xc: FlagDesc = L"SMB_CSC_NO_CACHING"; break;
                    default:  FlagDesc = L"<unknown>"; break;
                    }
                    MyPrintf(L"    Name:                       %ws\r\n"
                             L"    MaximalAccessRights:        0x%x\r\n"
                             L"    GuestMaximalAccessRights:   0x%x\r\n"
                             L"    DfsAware:                   0x%x\r\n"
                             L"    hShare:                     0x%x\r\n"
                             L"    hRootDir:                   0x%x\r\n"
                             L"    ShareStatus:                0x%x\r\n"
                             L"    CscFlags:                   0x%x (%ws)\r\n"
                             L"    CscEnabled:                 0x%x\r\n"
                             L"    CscShadowable:              0x%x\r\n"
                             L"    Disconnected:               0x%x\r\n",
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].Name,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].MaximalAccessRights,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].GuestMaximalAccessRights,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].DfsAware,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].hShare,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].hRootDir,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].ShareStatus,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].CscFlags,
                                FlagDesc,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].CscEnabled,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].CscShadowable,
                                pInfoArg->ServerEntryObject[i].pNetRoots[j].Disconnected);
                    if (j < pInfoArg->ServerEntryObject[i].NetRootEntryCount-1)
                        MyPrintf(L"    --------------------------------------------\r\n");
                }
                if (pInfoArg->ServerEntryObject[i].NetRootEntryCount == 0)
                    MyPrintf(L"     no entries\r\n");
            }
            MyPrintf(L"=================================================\r\n");
        } else if (Cmd == DEBUG_INFO_CSCFCBSLIST) {
            for (i = 0; i < pInfoArg->EntryCount; i++) {
                OFFSET_TO_POINTER(pInfoArg->FcbEntryObject[i].DfsPrefix, OutBuf);
                OFFSET_TO_POINTER(pInfoArg->FcbEntryObject[i].ActualPrefix, OutBuf);
            }
            MyPrintf(L"Status:        0x%x\r\n"
                   L"Version:       %d\r\n"
                   L"Entries:       %d\r\n",
                       pInfoArg->Status,
                       pInfoArg->Version,
                       pInfoArg->EntryCount);
            for (i = 0; i < pInfoArg->EntryCount; i++) {
                MyPrintf(L"=================================================\r\n");
                MyPrintf(L"MFlags:                     0x%x\r\n"
                         L"Tid:                        0x%x\r\n"
                         L"ShadowIsCorrupt:            0x%x\r\n"
                         L"hShadow:                    0x%x\r\n"
                         L"hParentDir:                 0x%x\r\n"
                         L"hShadowRenamed:             0x%x\r\n"
                         L"hParentDirRenamed:          0x%x\r\n"
                         L"ShadowStatus:               0x%x\r\n"
                         L"LocalFlags:                 0x%x\r\n"
                         L"LastComponentOffset:        0x%x\r\n"
                         L"LastComponentLength:        0x%x\r\n"
                         L"hShare:                     0x%x\r\n"
                         L"hRootDir:                   0x%x\r\n"
                         L"ShareStatus:                0x%x\r\n"
                         L"Flags:                      0x%x\r\n"
                         L"DfsPrefix:                  %s\r\n"
                         L"ActualPrefix:               %s\r\n",
                            pInfoArg->FcbEntryObject[i].MFlags,
                            pInfoArg->FcbEntryObject[i].Tid,
                            pInfoArg->FcbEntryObject[i].ShadowIsCorrupt,
                            pInfoArg->FcbEntryObject[i].hShadow,
                            pInfoArg->FcbEntryObject[i].hParentDir,
                            pInfoArg->FcbEntryObject[i].hShadowRenamed,
                            pInfoArg->FcbEntryObject[i].hParentDirRenamed,
                            pInfoArg->FcbEntryObject[i].ShadowStatus,
                            pInfoArg->FcbEntryObject[i].LocalFlags,
                            pInfoArg->FcbEntryObject[i].LastComponentOffset,
                            pInfoArg->FcbEntryObject[i].LastComponentLength,
                            pInfoArg->FcbEntryObject[i].hShare,
                            pInfoArg->FcbEntryObject[i].hRootDir,
                            pInfoArg->FcbEntryObject[i].ShareStatus,
                            pInfoArg->FcbEntryObject[i].Flags,
                            pInfoArg->FcbEntryObject[i].DfsPrefix,
                            pInfoArg->FcbEntryObject[i].ActualPrefix);
            }
        }
    } else if (bResult && pInfoArg->Status == STATUS_BUFFER_TOO_SMALL) {
        free(OutBuf);
        OutBuf = NULL;
        BufSize *= 2;
        goto TryAgain;
    }

AllDone:

    if (OutBuf != NULL)
        free(OutBuf);

    if (fSwDebug == TRUE)
        MyPrintf(L"CmdInfo exit %d\r\n", Status);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\drt\daytona\rxconfig.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    Rxconfig.h

Abstract:

    Private header file for redirector configuration for DRT

Author:

    Balan Sethu Raman -- created from the workstation service code

Revision History:

--*/


#ifndef _RXCONFIG_INCLUDED_
#define _RXCONFIG_INCLUDED_


typedef enum _DATATYPE {
    BooleanType,
    DWordType
} DATATYPE, *PDATATYPE;

typedef struct _RX_REDIR_FIELDS {
    LPWSTR Keyword;
    LPDWORD FieldPtr;
    DWORD Default;
    DWORD Minimum;
    DWORD Maximum;
    DATATYPE DataType;
    DWORD Parmnum;
} RX_REDIR_FIELDS, *PRX_REDIR_FIELDS;


#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\drt\daytona\rxdrt.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    Rxmain.c

Abstract:

    This is the main routine for the NT LAN Manager Workstation service.

Author:

--*/

#include "rxdrt.h"            // Service related global definitions
#include "rxdevice.h"          // Device init & shutdown

DWORD RxDrtTrace = 0;

#define RDBSS    L"Rdbss"
#define MRXLOCAL L"MrxLocal"
#define MRXSMB   L"MrxSmb"

int __cdecl
main( int argc , char** argv)
{
   NTSTATUS Status;

   // Set up the appropriate debug tracing.
   RxDrtTrace = RXDRT_DEBUG_ALL;

   DbgPrint("[RxDrt] START\n");

   Status = RxLoadDriver(RDBSS);
   if (!NT_SUCCESS(Status)) {
      DbgPrint("[RxDrt] RxLoadDriver(%ws) returned %lx\n",RDBSS,Status);
   }

   Status = RxLoadDriver(MRXLOCAL);
   if (!NT_SUCCESS(Status)) {
      DbgPrint("[RxDrt] RxLoadDriver(%ws) returned %lx\n",MRXLOCAL,Status);
   }

   Status = RxLoadDriver(MRXSMB);
   if (!NT_SUCCESS(Status)) {
      DbgPrint("[RxDrt] RxLoadDriver(%ws) returned %lx\n",MRXSMB,Status);
   }

   Status = RxOpenRedirector();
   if (!NT_SUCCESS(Status)) {
      DbgPrint("[RxDrt] RxOpenRedirector() returned %lx\n",Status);
   }

   Status = RxOpenDgReceiver();
   if (!NT_SUCCESS(Status)) {
      DbgPrint("[RxDrt] RxOpenDgReceiver() returned %lx\n",Status);
   }

   Status = RxStartRedirector();
   if (!NT_SUCCESS(Status)) {
      DbgPrint("[RxDrt] RxStartRedirector() returned %lx\n",Status);
   }

   Status = RxBindToTransports();
   if (!NT_SUCCESS(Status)) {
      DbgPrint("[RxDrt] RxBindToTransports() returned %lx\n",Status);
   }

   Status = RxStopRedirector();
   if (!NT_SUCCESS(Status)) {
      DbgPrint("[RxDrt] RxShutdownRedirector() returned %lx\n",Status);
   }

   Status = RxUnloadDriver(MRXSMB);
   if (!NT_SUCCESS(Status)) {
      DbgPrint("[RxDrt] RxUnloadDriver(%ws) returned %lx\n",MRXSMB,Status);
   }

   Status = RxUnloadDriver(MRXLOCAL);
   if (!NT_SUCCESS(Status)) {
      DbgPrint("[RxDrt] RxUnloadDriver(%ws) returned %lx\n",MRXLOCAL,Status);
   }

   Status = RxUnloadDriver(RDBSS);
   if (!NT_SUCCESS(Status)) {
      DbgPrint("[RxDrt] RxUnloadDriver(%ws) returned %lx\n",RDBSS,Status);
   }

   DbgPrint("[RxDrt] END\n");
   return 0;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\drt\daytona\rxconfig.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    Rxconfig.c

Abstract:

    Redirector configuration routines for DRT

Author:

    Balan Sethu Raman -- Created from the workstation service code

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>

#include <windows.h>
#include "rxdrt.h"
#include "rxdevice.h"
#include "rxconfig.h"
#include "malloc.h"

#define PRIVILEGE_BUF_SIZE  512
#define WS_LINKAGE_REGISTRY_PATH  L"LanmanWorkstation\\Linkage"
#define WS_BIND_VALUE_NAME        L"Bind"

extern NTSTATUS
RxBindATransport(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

//
// For specifying the importance of a transport when binding to it.
// The higher the number means that the transport will be searched
// first.
//
STATIC DWORD QualityOfService = 65536;

NTSTATUS
RxGetDomainName(
    IN  PULONG   pBufferLengthInBytes,
    IN  PWCHAR   Buffer, // alloc and set ptr (free with NetApiBufferFree)
    OUT PBOOLEAN IsWorkgroupName
    )

/*++

Routine Description:

    Returns the name of the domain or workgroup this machine belongs to.

Arguments:

    DomainNamePtr - The name of the domain or workgroup

    IsWorkgroupName - Returns TRUE if the name is a workgroup name.
        Returns FALSE if the name is a domain name.

Return Value:

   NERR_Success - Success.
   NERR_CfgCompNotFound - There was an error determining the domain name

--*/
{
    NTSTATUS ntstatus;
    LSA_HANDLE PolicyHandle;
    PPOLICY_ACCOUNT_DOMAIN_INFO PrimaryDomainInfo;
    OBJECT_ATTRIBUTES ObjAttributes;

    //
    // Open a handle to the local security policy.  Initialize the
    // objects attributes structure first.
    //
    InitializeObjectAttributes(
        &ObjAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    ntstatus = LsaOpenPolicy(
                   NULL,
                   &ObjAttributes,
                   POLICY_VIEW_LOCAL_INFORMATION,
                   &PolicyHandle
                   );

    if (! NT_SUCCESS(ntstatus)) {
        return ntstatus;
    }

    //
    // Get the name of the primary domain from LSA
    //
    ntstatus = LsaQueryInformationPolicy(
                   PolicyHandle,
                   PolicyPrimaryDomainInformation,
                   (PVOID *) &PrimaryDomainInfo
                   );

    if (! NT_SUCCESS(ntstatus)) {
        (void) LsaClose(PolicyHandle);
        return ntstatus;
    }

    (void) LsaClose(PolicyHandle);

    if (PrimaryDomainInfo->DomainName.Length + sizeof(WCHAR) > *pBufferLengthInBytes) {
       ntstatus = STATUS_BUFFER_OVERFLOW;
    } else {
       *pBufferLengthInBytes = PrimaryDomainInfo->DomainName.Length;
       RtlZeroMemory(
           Buffer,
           PrimaryDomainInfo->DomainName.Length + sizeof(WCHAR)
           );

       memcpy(
           Buffer,
           PrimaryDomainInfo->DomainName.Buffer,
           PrimaryDomainInfo->DomainName.Length
           );
    }

    *IsWorkgroupName = (PrimaryDomainInfo->DomainSid == NULL);
    (void) LsaFreeMemory((PVOID) PrimaryDomainInfo);

    return STATUS_SUCCESS;
}

NTSTATUS
RxStartRedirector(
    VOID
    )
{
    NTSTATUS status;
    WCHAR NameBuffer[MAX_PATH];
    ULONG Length;
    WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    ULONG ComputerNameLengthInBytes;
    WCHAR DomainName[DNLEN + 1];
    ULONG DomainNameLengthInBytes;
    DWORD version;
    WKSTA_INFO_502 WkstaInfo;
    UNICODE_STRING InputString;
    UNICODE_STRING OutputString;
    BOOLEAN        IsWorkGroup;

    BYTE Buffer[max(sizeof(LMR_REQUEST_PACKET) + (CNLEN + 1) * sizeof(WCHAR) +
                                                 (DNLEN + 1) * sizeof(WCHAR),
                    sizeof(LMDR_REQUEST_PACKET))];

    PLMR_REQUEST_PACKET Rrp = (PLMR_REQUEST_PACKET) Buffer;
    PLMDR_REQUEST_PACKET Drrp = (PLMDR_REQUEST_PACKET) Buffer;

    // Obtain the computer name.
    Length = MAX_PATH;
    status = GetComputerName(NameBuffer,&Length);

    ASSERT(Length <= MAX_COMPUTERNAME_LENGTH);

    // Canonicalize the name. ( Upcase conversion )
    InputString.Length = InputString.MaximumLength = (USHORT)((Length + 1) * sizeof(WCHAR));
    InputString.Buffer = NameBuffer;

    OutputString.Length = OutputString.MaximumLength = (USHORT)((Length + 1) * sizeof(WCHAR));
    OutputString.Buffer = ComputerName;

    ComputerNameLengthInBytes = Length * sizeof(WCHAR);

    RtlUpcaseUnicodeString(&OutputString,&InputString,FALSE);

    // Get the primary domain name from the configuration file
    DomainNameLengthInBytes = sizeof(WCHAR) * (DNLEN + 1);
    status = RxGetDomainName(&DomainNameLengthInBytes,DomainName,&IsWorkGroup);
    if (NT_SUCCESS(status)) {
       // Initialize redirector configuration
       Rrp->Type = ConfigInformation;
       Rrp->Version = REQUEST_PACKET_VERSION;

       wcscpy(Rrp->Parameters.Start.RedirectorName,
              ComputerName);
       Rrp->Parameters.Start.RedirectorNameLength = ComputerNameLengthInBytes;

       Rrp->Parameters.Start.DomainNameLength = DomainNameLengthInBytes;
       wcscpy((Rrp->Parameters.Start.RedirectorName+ComputerNameLengthInBytes),
              DomainName);

       status = RxRedirFsControl(
                         RxRedirDeviceHandle,
                         FSCTL_LMR_START,
                         Rrp,
                         sizeof(LMR_REQUEST_PACKET) +
                             Rrp->Parameters.Start.RedirectorNameLength+
                             Rrp->Parameters.Start.DomainNameLength,
                         (LPBYTE) &WkstaInfo,
                         sizeof(WKSTA_INFO_502),
                         NULL
                         );
    }

    return status;
}


NTSTATUS
RxBindToTransports(
    VOID
    )
/*++

Routine Description:

    This function binds the transports specified in the registry to the
    redirector.  The order of priority for the transports follows the order
    they are listed by the "Bind=" valuename.

Arguments:

    None.

Return Value:

    NTSTATUS - Success or reason for failure.

--*/
{
    NTSTATUS              status;
    NTSTATUS              tempStatus;
    NTSTATUS                    ntstatus;
    DWORD                       transportsBound;
    PRTL_QUERY_REGISTRY_TABLE   queryTable;
    LIST_ENTRY                  header;
    PLIST_ENTRY                 pListEntry;
    PRX_BIND                    pBind;


    //
    // Ask the RTL to call us back for each subvalue in the MULTI_SZ
    // value \LanmanWorkstation\Linkage\Bind.
    //
    queryTable = (PVOID)malloc(sizeof(RTL_QUERY_REGISTRY_TABLE) * 2);

    if (queryTable == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    InitializeListHead( &header);

    queryTable[0].QueryRoutine = RxBindATransport;
    queryTable[0].Flags = 0;
    queryTable[0].Name = WS_BIND_VALUE_NAME;
    queryTable[0].EntryContext = NULL;
    queryTable[0].DefaultType = REG_NONE;
    queryTable[0].DefaultData = NULL;
    queryTable[0].DefaultLength = 0;

    queryTable[1].QueryRoutine = NULL;
    queryTable[1].Flags = 0;
    queryTable[1].Name = NULL;

    ntstatus = RtlQueryRegistryValues(
                   RTL_REGISTRY_SERVICES,       // path relative to ...
                   WS_LINKAGE_REGISTRY_PATH,
                   queryTable,
                   (PVOID) &header,             // context
                   NULL
                   );

    //
    //  First process all the data, then clean up.
    //

    for ( pListEntry = header.Flink;
                pListEntry != &header;
                    pListEntry = pListEntry->Flink) {

        pBind = CONTAINING_RECORD(
            pListEntry,
            RX_BIND,
            ListEntry
            );

        tempStatus = NO_ERROR;

        if ( pBind->Redir->EventHandle != INVALID_HANDLE_VALUE) {
            WaitForSingleObject(
                pBind->Redir->EventHandle,
                INFINITE
                );
            pBind->Redir->Bound = (tempStatus == NO_ERROR);
            if (tempStatus == ERROR_DUP_NAME) {
                status = tempStatus;
            }
        }

        if ( pBind->Dgrec->EventHandle != INVALID_HANDLE_VALUE) {
            WaitForSingleObject(
                pBind->Dgrec->EventHandle,
                INFINITE
                );
            pBind->Dgrec->Bound = (tempStatus == NO_ERROR);
            if (tempStatus == ERROR_DUP_NAME) {
                status = tempStatus;
            }
        }

        //
        //  If one is installed but the other is not, clean up the other.
        //

        if ( pBind->Dgrec->Bound != pBind->Redir->Bound) {
            RxUnbindTransport2( pBind);
        }
    }


    if (NT_SUCCESS(ntstatus)) {
        for ( pListEntry = header.Flink;
                    pListEntry != &header;
                        pListEntry = pListEntry->Flink) {

            pBind = CONTAINING_RECORD(
                pListEntry,
                RX_BIND,
                ListEntry
                );

            RxUnbindTransport2( pBind);
        }
    }

    for ( transportsBound = 0;
                IsListEmpty( &header) == FALSE;
                        LocalFree((HLOCAL) pBind)) {

        pListEntry = RemoveHeadList( &header);

        pBind = CONTAINING_RECORD(
            pListEntry,
            RX_BIND,
            ListEntry
            );

        if ( pBind->Redir->EventHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( pBind->Redir->EventHandle);
        }

        if ( pBind->Redir->Bound == TRUE) {
            transportsBound++;
        }

        if ( pBind->Dgrec->EventHandle != INVALID_HANDLE_VALUE) {
            CloseHandle( pBind->Dgrec->EventHandle);
        }

    }

    (void) free((HLOCAL) queryTable);

    if ( RxRedirAsyncDeviceHandle != NULL) {
        (VOID)NtClose( RxRedirAsyncDeviceHandle);
        RxRedirAsyncDeviceHandle = NULL;
    }

    if ( RxDgrecAsyncDeviceHandle != NULL) {
        (VOID)NtClose( RxDgrecAsyncDeviceHandle);
        RxDgrecAsyncDeviceHandle = NULL;
    }

    return ntstatus;
}

NTSTATUS
RxBindATransport(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++
    This routine always returns SUCCESS because we want all transports
    to be processed fully.
--*/
{
    NTSTATUS  status;

    DBG_UNREFERENCED_PARAMETER( ValueName);
    DBG_UNREFERENCED_PARAMETER( ValueLength);
    DBG_UNREFERENCED_PARAMETER( EntryContext);

    //
    // Bind transport
    //

    status = RxAsyncBindTransport(
                      ValueData,                  // name of transport device object
                      --QualityOfService,
                      (PLIST_ENTRY)Context);

    return STATUS_SUCCESS;
}

DWORD
RxGetPrivilege(
    IN  DWORD       numPrivileges,
    IN  PULONG      pulPrivileges
    )
/*++

Routine Description:

    This function alters the privilege level for the current thread.

    It does this by duplicating the token for the current thread, and then
    applying the new privileges to that new token, then the current thread
    impersonates with that new token.

    Privileges can be relinquished by calling NetpReleasePrivilege().

Arguments:

    numPrivileges - This is a count of the number of privileges in the
        array of privileges.

    pulPrivileges - This is a pointer to the array of privileges that are
        desired.  This is an array of ULONGs.

Return Value:

    NO_ERROR - If the operation was completely successful.

    Otherwise, it returns mapped return codes from the various NT
    functions that are called.

--*/
{
    DWORD                       status;
    NTSTATUS                    ntStatus;
    HANDLE                      ourToken;
    HANDLE                      newToken;
    OBJECT_ATTRIBUTES           Obja;
    SECURITY_QUALITY_OF_SERVICE SecurityQofS;
    ULONG                       bufLen;
    ULONG                       returnLen;
    PTOKEN_PRIVILEGES           pPreviousState;
    PTOKEN_PRIVILEGES           pTokenPrivilege = NULL;
    DWORD                       i;

    //
    // Initialize the Privileges Structure
    //
    pTokenPrivilege = LocalAlloc(LMEM_FIXED, sizeof(TOKEN_PRIVILEGES) +
                        (sizeof(LUID_AND_ATTRIBUTES) * numPrivileges));

    if (pTokenPrivilege == NULL) {
        status = GetLastError();
        return(status);
    }
    pTokenPrivilege->PrivilegeCount  = numPrivileges;
    for (i=0; i<numPrivileges ;i++ ) {
        pTokenPrivilege->Privileges[i].Luid = RtlConvertLongToLargeInteger(
                                                pulPrivileges[i]);
        pTokenPrivilege->Privileges[i].Attributes = SE_PRIVILEGE_ENABLED;

    }

    //
    // Initialize Object Attribute Structure.
    //
    InitializeObjectAttributes(&Obja,NULL,0L,NULL,NULL);

    //
    // Initialize Security Quality Of Service Structure
    //
    SecurityQofS.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQofS.ImpersonationLevel = SecurityImpersonation;
    SecurityQofS.ContextTrackingMode = FALSE;     // Snapshot client context
    SecurityQofS.EffectiveOnly = FALSE;

    Obja.SecurityQualityOfService = &SecurityQofS;

    //
    // Allocate storage for the structure that will hold the Previous State
    // information.
    //
    pPreviousState = LocalAlloc(LMEM_FIXED, PRIVILEGE_BUF_SIZE);
    if (pPreviousState == NULL) {

        status = GetLastError();

        LocalFree(pTokenPrivilege);
        return(status);
    }

    //
    // Open our own Token
    //
    ntStatus = NtOpenProcessToken(
                NtCurrentProcess(),
                TOKEN_DUPLICATE,
                &ourToken);

    if (!NT_SUCCESS(ntStatus)) {
        LocalFree(pPreviousState);
        LocalFree(pTokenPrivilege);
        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // Duplicate that Token
    //
    ntStatus = NtDuplicateToken(
                ourToken,
                TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                &Obja,
                FALSE,                  // Duplicate the entire token
                TokenImpersonation,     // TokenType
                &newToken);             // Duplicate token

    if (!NT_SUCCESS(ntStatus)) {
        LocalFree(pPreviousState);
        LocalFree(pTokenPrivilege);
        NtClose(ourToken);
        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // Add new privileges
    //
    bufLen = PRIVILEGE_BUF_SIZE;
    ntStatus = NtAdjustPrivilegesToken(
                newToken,                   // TokenHandle
                FALSE,                      // DisableAllPrivileges
                pTokenPrivilege,            // NewState
                bufLen,                     // bufferSize for previous state
                pPreviousState,             // pointer to previous state info
                &returnLen);                // numBytes required for buffer.

    if (ntStatus == STATUS_BUFFER_TOO_SMALL) {

        LocalFree(pPreviousState);

        bufLen = returnLen;

        pPreviousState = LocalAlloc(LMEM_FIXED, bufLen);


        ntStatus = NtAdjustPrivilegesToken(
                    newToken,               // TokenHandle
                    FALSE,                  // DisableAllPrivileges
                    pTokenPrivilege,        // NewState
                    bufLen,                 // bufferSize for previous state
                    pPreviousState,         // pointer to previous state info
                    &returnLen);            // numBytes required for buffer.

    }
    if (!NT_SUCCESS(ntStatus)) {
        LocalFree(pPreviousState);
        LocalFree(pTokenPrivilege);
        NtClose(ourToken);
        NtClose(newToken);
        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // Begin impersonating with the new token
    //
    ntStatus = NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID)&newToken,
                (ULONG)sizeof(HANDLE));

    if (!NT_SUCCESS(ntStatus)) {
        LocalFree(pPreviousState);
        LocalFree(pTokenPrivilege);
        NtClose(ourToken);
        NtClose(newToken);
        return(RtlNtStatusToDosError(ntStatus));
    }

    LocalFree(pPreviousState);
    LocalFree(pTokenPrivilege);
    NtClose(ourToken);
    NtClose(newToken);

    return(NO_ERROR);
}

DWORD
RxReleasePrivilege(
    VOID
    )
/*++

Routine Description:

    This function relinquishes privileges obtained by calling NetpGetPrivilege().

Arguments:

    none

Return Value:

    NO_ERROR - If the operation was completely successful.

    Otherwise, it returns mapped return codes from the various NT
    functions that are called.


--*/
{
    NTSTATUS    ntStatus;
    HANDLE      NewToken;


    //
    // Revert To Self.
    //
    NewToken = NULL;

    ntStatus = NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID)&NewToken,
                (ULONG)sizeof(HANDLE));

    if ( !NT_SUCCESS(ntStatus) ) {
        return(RtlNtStatusToDosError(ntStatus));
    }


    return(NO_ERROR);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\drt\daytona\rxdevice.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    Rxdevice.h

Abstract:

    Private header file for the Rx DRT ( Redirector FSCTL calls )

Author:

    Balan Sethu Raman -- Created from the workstation service code

Revision History:

--*/

#ifndef _RXDEVICE_INCLUDED_
#define _RXDEVICE_INCLUDED_

#include <ntddnfs2.h>                // Rdr2 include file
#include <ntddbrow.h>                // Datagram receiver include file



typedef struct _RX_BIND_REDIR {
    HANDLE              EventHandle;
    BOOL                Bound;
    IO_STATUS_BLOCK     IoStatusBlock;
    LMR_REQUEST_PACKET  Packet;
} RX_BIND_REDIR, *PRX_BIND_REDIR;

typedef struct _RX_BIND_DGREC {
    HANDLE              EventHandle;
    BOOL                Bound;
    IO_STATUS_BLOCK     IoStatusBlock;
    LMDR_REQUEST_PACKET  Packet;
} RX_BIND_DGREC, *PRX_BIND_DGREC;

typedef struct _RX_BIND {
    LIST_ENTRY          ListEntry;
    PRX_BIND_REDIR      Redir;
    PRX_BIND_DGREC      Dgrec;
    ULONG               TransportNameLength;  // not including terminator
    WCHAR               TransportName[1];     // Name of transport provider
} RX_BIND, *PRX_BIND;

typedef enum _DDTYPE {
    Redirector,
    DatagramReceiver
} DDTYPE, *PDDTYPE;

//
// Binding/Unbinding related functions
//
extern NTSTATUS
RxBindTransport(
    IN  LPTSTR TransportName,
    IN  DWORD QualityOfService,
    OUT LPDWORD ErrorParameter OPTIONAL
    );


extern NTSTATUS
RxBindToTransports(
    VOID
    );

extern NTSTATUS
RxUnbindTransport(
    IN LPTSTR TransportName,
    IN DWORD ForceLevel
    );


extern NTSTATUS
RxAsyncBindTransport(
    IN  LPTSTR          transportName,
    IN  DWORD           qualityOfService,
    IN  PLIST_ENTRY     pHeader
    );

extern VOID
RxUnbindTransport2(
    IN  PRX_BIND        pBind
    );

//
// Loading and unloading drivers
//
NTSTATUS
RxUnloadDriver(
    IN LPTSTR DriverNameString
    );

NTSTATUS
RxLoadDriver(
    IN LPWSTR DriverNameString
    );

//
// FSCTL issued to the drivers.
//

extern NTSTATUS
RxDeviceControlGetInfo(
    IN  DDTYPE DeviceDriverType,
    IN  HANDLE FileHandle,
    IN  ULONG DeviceControlCode,
    IN  PVOID RequestPacket,
    IN  ULONG RequestPacketLength,
    OUT PVOID *OutputBuffer,
    IN  ULONG PreferedMaximumLength,
    IN  ULONG BufferHintSize,
    OUT PULONG Information
    );

extern NTSTATUS
RxRedirFsControl (
    IN  HANDLE FileHandle,
    IN  ULONG RedirControlCode,
    IN  PLMR_REQUEST_PACKET Rrp,
    IN  ULONG RrpLength,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    );

extern NTSTATUS
RxDgReceiverIoControl(
    IN  HANDLE FileHandle,
    IN  ULONG DgReceiverControlCode,
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  ULONG DrpLength,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    );


//
// Start/Stop control for redirectors.
//

extern NTSTATUS
RxOpenRedirector(
    VOID
    );

extern NTSTATUS
RxOpenDgReceiver (
    VOID
    );

extern NTSTATUS
RxStartRedirector(VOID);

extern NTSTATUS
RxStopRedirector(
    VOID
    );


//
// Miscellanous functions fro the DRT.
//
extern NTSTATUS
RxDeleteDomainName(
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  DWORD DrpLength,
    IN  LPTSTR DomainName,
    IN  DWORD DomainNameSize
    );

NTSTATUS
RxAddDomainName(
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  DWORD DrpLength,
    IN  LPTSTR DomainName,
    IN  DWORD DomainNameSize
    );

extern DWORD
RxGetPrivilege(
    IN  DWORD       numPrivileges,
    IN  PULONG      pulPrivileges
    );


extern DWORD
RxReleasePrivilege(
    VOID
    );

//                                    //
// Handles to the Redirector FSD, Datgram receiver FSd
//

extern HANDLE   RxRedirDeviceHandle;
extern HANDLE   RxDgReceiverDeviceHandle;
extern HANDLE   RxRedirAsyncDeviceHandle;   // redirector
extern HANDLE   RxDgrecAsyncDeviceHandle;   // datagram receiver or "bowser"


#endif   // ifndef _RXDEVICE_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\drt\daytona\rxdevice.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    rxdevice.c

Abstract:

    This module contains the support routines for the APIs that call
    into the redirector or the datagram receiver.

Author:

    Balan Sethu Raman -- Created from the workstation service code

Revision History:

--*/

#include "align.h"
#include "rxdrt.h"
#include "rxdevice.h"
#include "rxconfig.h"
#include "malloc.h"

#define SERVICE_REGISTRY_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"

//
// Buffer allocation size for enumeration output buffer.
//
#define INITIAL_ALLOCATION_SIZE  4096  // First attempt size
#define FUDGE_FACTOR_SIZE        1024  // Second try TotalBytesNeeded
                                       //     plus this amount

//
// Handle to the Redirector FSD
//
HANDLE RxRedirDeviceHandle = NULL;
HANDLE RxRedirAsyncDeviceHandle = NULL;

BOOLEAN LoadedRdbssInsteadOfRdr = FALSE;

//
// Handle to the Datagram Receiver DD
//
HANDLE RxDgReceiverDeviceHandle = NULL;
HANDLE RxDgrecAsyncDeviceHandle = NULL;


NTSTATUS
RxDeviceControlGetInfo(
    IN  DDTYPE DeviceDriverType,
    IN  HANDLE FileHandle,
    IN  ULONG DeviceControlCode,
    IN  PVOID RequestPacket,
    IN  ULONG RequestPacketLength,
    OUT PVOID *OutputBuffer,
    IN  ULONG PreferedMaximumLength,
    IN  ULONG BufferHintSize,
    OUT PULONG Information
    )
/*++

Routine Description:

    This function allocates the buffer and fill it with the information
    that is retrieved from the redirector or datagram receiver.

Arguments:

    DeviceDriverType - Supplies the value which indicates whether to call
        the redirector or the datagram receiver.

    FileHandle - Supplies a handle to the file or device of which to get
        information about.

    DeviceControlCode - Supplies the NtFsControlFile or NtIoDeviceControlFile
        function control code.

    RequestPacket - Supplies a pointer to the device request packet.

    RrequestPacketLength - Supplies the length of the device request packet.

    OutputBuffer - Returns a pointer to the buffer allocated by this routine
        which contains the use information requested.  This pointer is set to
         NULL if return code is not Success.

    PreferedMaximumLength - Supplies the number of bytes of information to
        return in the buffer.  If this value is MAXULONG, we will try to
        return all available information if there is enough memory resource.

    BufferHintSize - Supplies the hint size of the output buffer so that the
        memory allocated for the initial buffer will most likely be large
        enough to hold all requested data.

    Information - Returns the information code from the NtFsControlFile or
        NtIoDeviceControlFile call.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS status;
    DWORD OutputBufferLength;
    DWORD TotalBytesNeeded = 1;
    ULONG OriginalResumeKey;


    //
    // If PreferedMaximumLength is MAXULONG, then we are supposed to get all
    // the information, regardless of size.  Allocate the output buffer of a
    // reasonable size and try to use it.  If this fails, the Redirector FSD
    // will say how much we need to allocate.
    //
    if (PreferedMaximumLength == MAXULONG) {
        OutputBufferLength = (BufferHintSize) ?
                             BufferHintSize :
                             INITIAL_ALLOCATION_SIZE;
    }
    else {
        OutputBufferLength = PreferedMaximumLength;
    }

    OutputBufferLength = ROUND_UP_COUNT(OutputBufferLength, ALIGN_WCHAR);

    if ((*OutputBuffer = malloc(OutputBufferLength)) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RtlZeroMemory((PVOID) *OutputBuffer, OutputBufferLength);

    if (DeviceDriverType == Redirector) {
        PLMR_REQUEST_PACKET Rrp = (PLMR_REQUEST_PACKET) RequestPacket;

        OriginalResumeKey = Rrp->Parameters.Get.ResumeHandle;

        //
        // Make the request of the Redirector
        //

        status = RxRedirFsControl(
                     FileHandle,
                     DeviceControlCode,
                     Rrp,
                     RequestPacketLength,
                     *OutputBuffer,
                     OutputBufferLength,
                     Information
                     );

        if (status == ERROR_MORE_DATA) {
            TotalBytesNeeded = Rrp->Parameters.Get.TotalBytesNeeded;

        }

    }
    else {
        PLMDR_REQUEST_PACKET Drrp = (PLMDR_REQUEST_PACKET) RequestPacket;

        OriginalResumeKey = Drrp->Parameters.EnumerateNames.ResumeHandle;

        //
        // Make the request of the Datagram Receiver
        //
        status = RxDgReceiverIoControl(
                     FileHandle,
                     DeviceControlCode,
                     Drrp,
                     RequestPacketLength,
                     *OutputBuffer,
                     OutputBufferLength,
                     NULL
                     );

        if (status == ERROR_MORE_DATA) {
            TotalBytesNeeded = Drrp->Parameters.EnumerateNames.TotalBytesNeeded;
        }
    }

    if ((TotalBytesNeeded > OutputBufferLength) &&
        (PreferedMaximumLength == MAXULONG)) {

        //
        // Initial output buffer allocated was too small and we need to return
        // all data.  First free the output buffer before allocating the
        // required size plus a fudge factor just in case the amount of data
        // grew.
        //

        free(*OutputBuffer);

        OutputBufferLength =
            ROUND_UP_COUNT((TotalBytesNeeded + FUDGE_FACTOR_SIZE),
                           ALIGN_WCHAR);

        if ((*OutputBuffer = malloc(OutputBufferLength)) == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        RtlZeroMemory((PVOID) *OutputBuffer, OutputBufferLength);

        //
        // Try again to get the information from the redirector or datagram
        // receiver
        //
        if (DeviceDriverType == Redirector) {
            PLMR_REQUEST_PACKET Rrp = (PLMR_REQUEST_PACKET) RequestPacket;

            Rrp->Parameters.Get.ResumeHandle = OriginalResumeKey;

            //
            // Make the request of the Redirector
            //
            status = RxRedirFsControl(
                         FileHandle,
                         DeviceControlCode,
                         Rrp,
                         RequestPacketLength,
                         *OutputBuffer,
                         OutputBufferLength,
                         Information
                         );
        }
        else {
            PLMDR_REQUEST_PACKET Drrp = (PLMDR_REQUEST_PACKET) RequestPacket;

            Drrp->Parameters.EnumerateNames.ResumeHandle = OriginalResumeKey;

            //
            // Make the request of the Datagram Receiver
            //

            status = RxDgReceiverIoControl(
                         FileHandle,
                         DeviceControlCode,
                         Drrp,
                         RequestPacketLength,
                         *OutputBuffer,
                         OutputBufferLength,
                         NULL
                         );
        }
    }


    //
    // If not successful in getting any data, or if the caller asked for
    // all available data with PreferedMaximumLength == MAXULONG and
    // our buffer overflowed, free the output buffer and set its pointer
    // to NULL.
    //
    if ((status != STATUS_SUCCESS && status != ERROR_MORE_DATA) ||
        (TotalBytesNeeded == 0) ||
        (PreferedMaximumLength == MAXULONG && status == ERROR_MORE_DATA)) {

        free(*OutputBuffer);
        *OutputBuffer = NULL;

        //
        // PreferedMaximumLength == MAXULONG and buffer overflowed means
        // we do not have enough memory to satisfy the request.
        //
        if (status == ERROR_MORE_DATA) {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return status;
}


NTSTATUS
RxOpenRedirector(
    VOID
    )
/*++

Routine Description:

    This routine opens the NT LAN Man redirector FSD.

Arguments:

    None.

Return Value:

    NTSTATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS            ntstatus;
    UNICODE_STRING      DeviceName;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;

    //
    // Open the redirector device.
    //
    RtlInitUnicodeString(&DeviceName,
                         DD_NFS2_DEVICE_NAME_U);


    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    ntstatus = NtOpenFile(
                   &RxRedirDeviceHandle,
                   SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (! NT_SUCCESS(ntstatus)) {
        RxRedirDeviceHandle = NULL;
        return ntstatus;
    }

    ntstatus = NtOpenFile(
                   &RxRedirAsyncDeviceHandle,
                   FILE_READ_DATA | FILE_WRITE_DATA,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   0L
                   );

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (! NT_SUCCESS(ntstatus)) {
        RxRedirAsyncDeviceHandle = NULL;
    }

    return ntstatus;
}

NTSTATUS
RxOpenDgReceiver(
    VOID
    )
/*++

Routine Description:

    This routine opens the NT LAN Man Datagram Receiver driver.

Arguments:

    None.

Return Value:

    NTSTATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS            ntstatus;
    UNICODE_STRING      DeviceName;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;

    //
    // Open the redirector device.
    //

    RtlInitUnicodeString( &DeviceName, DD_BROWSER_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    ntstatus = NtOpenFile(
                   &RxDgReceiverDeviceHandle,
                   SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (! NT_SUCCESS(ntstatus)) {
        RxDgReceiverDeviceHandle = NULL;
        return ntstatus;
    }

    ntstatus = NtOpenFile(
                   &RxDgrecAsyncDeviceHandle,
                   FILE_READ_DATA | FILE_WRITE_DATA,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_VALID_FLAGS,
                   0L
                   );

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (! NT_SUCCESS(ntstatus)) {
        RxDgrecAsyncDeviceHandle = NULL;
    }

    return ntstatus;
}


NTSTATUS
RxUnloadDriver(
    IN LPWSTR DriverNameString
    )
{
    ULONG Privileges[1];
    LPWSTR DriverRegistryName;
    UNICODE_STRING DriverRegistryString;
    NTSTATUS Status;
    NTSTATUS ntstatus;


    DriverRegistryName = (LPWSTR) malloc(
                                      (UINT) (sizeof(SERVICE_REGISTRY_KEY) +
                                              (wcslen(DriverNameString) *
                                               sizeof(WCHAR)))
                                      );

    if (DriverRegistryName == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    Privileges[0] = SE_LOAD_DRIVER_PRIVILEGE;

    Status = RxGetPrivilege(1, Privileges);

    if (Status != STATUS_SUCCESS) {
        free(DriverRegistryName);
        return Status;
    }

    wcscpy(DriverRegistryName, SERVICE_REGISTRY_KEY);
    wcscat(DriverRegistryName, DriverNameString);

    RtlInitUnicodeString(&DriverRegistryString, DriverRegistryName);

    ntstatus = NtUnloadDriver(&DriverRegistryString);

    free(DriverRegistryName);

    RxReleasePrivilege();

    return ntstatus;
}


NTSTATUS
RxLoadDriver(
    IN LPWSTR DriverNameString
    )
{
    ULONG Privileges[1];
    LPWSTR DriverRegistryName;
    UNICODE_STRING DriverRegistryString;
    NTSTATUS Status;
    NTSTATUS ntstatus;



    DriverRegistryName = (LPWSTR) malloc(
                                      (UINT) (sizeof(SERVICE_REGISTRY_KEY) +
                                              (wcslen(DriverNameString) *
                                               sizeof(WCHAR)))
                                      );

    if (DriverRegistryName == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Privileges[0] = SE_LOAD_DRIVER_PRIVILEGE;

    Status = RxGetPrivilege(1, Privileges);

    if (Status != STATUS_SUCCESS) {
        free(DriverRegistryName);
        return Status;
    }

    wcscpy(DriverRegistryName, SERVICE_REGISTRY_KEY);
    wcscat(DriverRegistryName, DriverNameString);

    RtlInitUnicodeString(&DriverRegistryString, DriverRegistryName);

    ntstatus = NtLoadDriver(&DriverRegistryString);

    RxReleasePrivilege();

    free(DriverRegistryName);

    if (ntstatus != STATUS_SUCCESS && ntstatus != STATUS_IMAGE_ALREADY_LOADED) {

        LPWSTR  subString[1];


        subString[0] = DriverNameString;
    }

    return ntstatus;
}

NTSTATUS
RxStopRedirector(
    VOID
    )
/*++

Routine Description:

    This routine close the LAN Man Redirector device.

Arguments:

    None.

Return Value:



--*/
{
    LMR_REQUEST_PACKET Rrp;
    LMDR_REQUEST_PACKET Drp;
    NTSTATUS Status;

    Rrp.Version = REQUEST_PACKET_VERSION;

    Status = RxRedirFsControl(
                 RxRedirDeviceHandle,
                 FSCTL_LMR_STOP,
                 &Rrp,
                 sizeof(LMR_REQUEST_PACKET),
                 NULL,
                 0,
                 NULL);

    return Status;
}

NTSTATUS
RxStopDgReceiver(
    VOID
    )
/*++

Routine Description:

    This routine stops the datagram receiver.

Arguments:

    None.

Return Value:



--*/
{

    NTSTATUS Status;
    if (RxDgReceiverDeviceHandle != NULL) {
       LMDR_REQUEST_PACKET Drp;

        Drp.Version = LMDR_REQUEST_PACKET_VERSION;

        (void) RxDgReceiverIoControl(
                   RxDgReceiverDeviceHandle,
                   IOCTL_LMDR_STOP,
                   &Drp,
                   sizeof(LMDR_REQUEST_PACKET),
                   NULL,
                   0,
                   NULL
                   );
    } else {
       DbgPrint("[RxDevice] Invalid datagram receiver handle\n");
       Status = STATUS_INVALID_HANDLE;
    }

    return Status;
}


NTSTATUS
RxRedirFsControl(
    IN  HANDLE FileHandle,
    IN  ULONG RedirControlCode,
    IN  PLMR_REQUEST_PACKET Rrp,
    IN  ULONG RrpLength,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    )
/*++

Routine Description:

Arguments:

    FileHandle - Supplies a handle to the file or device on which the service
        is being performed.

    RedirControlCode - Supplies the NtFsControlFile function code given to
        the redirector.

    Rrp - Supplies the redirector request packet.

    RrpLength - Supplies the length of the redirector request packet.

    SecondBuffer - Supplies the second buffer in call to NtFsControlFile.

    SecondBufferLength - Supplies the length of the second buffer.

    Information - Returns the information field of the I/O status block.

Return Value:

    NTSTATUS - NERR_Success or reason for failure.

--*/

{
    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Send the request to the Redirector FSD.
    //
    ntstatus = NtFsControlFile(
                   FileHandle,
                   NULL,
                   NULL,
                   NULL,
                   &IoStatusBlock,
                   RedirControlCode,
                   Rrp,
                   RrpLength,
                   SecondBuffer,
                   SecondBufferLength
                   );

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (ARGUMENT_PRESENT(Information)) {
        *Information = IoStatusBlock.Information;
    }

    return ntstatus;
}



NTSTATUS
RxDgReceiverIoControl(
    IN  HANDLE FileHandle,
    IN  ULONG DgReceiverControlCode,
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  ULONG DrpSize,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    )
/*++

Routine Description:

Arguments:

    FileHandle - Supplies a handle to the file or device on which the service
        is being performed.

    DgReceiverControlCode - Supplies the NtDeviceIoControlFile function code
        given to the datagram receiver.

    Drp - Supplies the datagram receiver request packet.

    DrpSize - Supplies the length of the datagram receiver request packet.

    SecondBuffer - Supplies the second buffer in call to NtDeviceIoControlFile.

    SecondBufferLength - Supplies the length of the second buffer.

    Information - Returns the information field of the I/O status block.

Return Value:

    NTSTATUS - NERR_Success or reason for failure.

--*/

{
    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;


    if (FileHandle == NULL) {
        return STATUS_INVALID_HANDLE;
    }

    Drp->TransportName.Length = 0;

    //
    // Send the request to the Datagram Receiver DD.
    //
    ntstatus = NtDeviceIoControlFile(
                   FileHandle,
                   NULL,
                   NULL,
                   NULL,
                   &IoStatusBlock,
                   DgReceiverControlCode,
                   Drp,
                   DrpSize,
                   SecondBuffer,
                   SecondBufferLength
                   );

    if (NT_SUCCESS(ntstatus)) {
        ntstatus = IoStatusBlock.Status;
    }

    if (ARGUMENT_PRESENT(Information)) {
        *Information = IoStatusBlock.Information;
    }

    return ntstatus;
}



NTSTATUS
RxAsyncBindTransport(
    IN  LPWSTR          transportName,
    IN  DWORD           qualityOfService,
    IN  PLIST_ENTRY     pHeader
    )
/*++

Routine Description:

    This function async binds the specified transport to the redirector
    and the datagram receiver.

    NOTE: The transport name length pass to the redirector and
          datagram receiver is the number of bytes.

Arguments:

    transportName - Supplies the name of the transport to bind to.

    qualityOfService - Supplies a value which specifies the search
        order of the transport with respect to other transports.  The
        highest value is searched first.

Return Value:

    NO_ERROR

--*/
{
    NTSTATUS          ntstatus;
    NTSTATUS          status;
    DWORD                   size;
    DWORD                   redirSize;
    DWORD                   dgrecSize;
    DWORD                   nameLength;
    PRX_BIND                pBind;
    PRX_BIND_REDIR          pBindRedir;
    PRX_BIND_DGREC          pBindDgrec;

    nameLength = wcslen( transportName);

    //
    //  Make sure *Size-s are DWORD aligned.
    //

    dgrecSize = redirSize = size = (nameLength & 1) ? sizeof( WCHAR) : 0;

    //
    //  Then add the fixed part to *Size-s.
    //

    size += sizeof( RX_BIND) + nameLength * sizeof( WCHAR);
    redirSize += sizeof( RX_BIND_REDIR) + nameLength * sizeof( WCHAR);
    dgrecSize += sizeof( RX_BIND_DGREC) +
                 nameLength * sizeof( WCHAR)
                 ;


    pBind = (PVOID) malloc(
                        (UINT) (size + redirSize + dgrecSize)
                        );

    if ( pBind == NULL) {
        return GetLastError();
    }

    pBind->TransportNameLength = nameLength * sizeof( WCHAR);
    wcscpy( pBind->TransportName, transportName);
    pBind->Redir = pBindRedir = (PRX_BIND_REDIR)( (PCHAR)pBind + size);
    pBind->Dgrec = pBindDgrec = (PRX_BIND_DGREC)( (PCHAR)pBindRedir + redirSize);

    pBindRedir->EventHandle = INVALID_HANDLE_VALUE;
    pBindRedir->Bound = FALSE;
    pBindRedir->Packet.Version = REQUEST_PACKET_VERSION;
    pBindRedir->Packet.Parameters.Bind.QualityOfService = qualityOfService;
    pBindRedir->Packet.Parameters.Bind.TransportNameLength =
            nameLength * sizeof( WCHAR);
    wcscpy( pBindRedir->Packet.Parameters.Bind.TransportName, transportName);

    pBindDgrec->EventHandle = INVALID_HANDLE_VALUE;
    pBindDgrec->Bound = FALSE;
    pBindDgrec->Packet.Version = LMDR_REQUEST_PACKET_VERSION;
    pBindDgrec->Packet.Level = 0; // Indicate computername doesn't follow transport name
    pBindDgrec->Packet.Parameters.Bind.TransportNameLength =
            nameLength * sizeof( WCHAR);
    wcscpy( pBindDgrec->Packet.Parameters.Bind.TransportName, transportName);

    pBindRedir->EventHandle = CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL
            );

    if ( pBindRedir->EventHandle == INVALID_HANDLE_VALUE) {
        status = GetLastError();
        goto tail_exit;
    }

    ntstatus = NtFsControlFile(
            RxRedirAsyncDeviceHandle,
            pBindRedir->EventHandle,
            NULL,                               // apc routine
            NULL,                               // apc context
            &pBindRedir->IoStatusBlock,
            FSCTL_LMR_BIND_TO_TRANSPORT,        // control code
            &pBindRedir->Packet,
            sizeof( LMR_REQUEST_PACKET) +
                pBindRedir->Packet.Parameters.Bind.TransportNameLength,
            NULL,
            0
            );

    if ( ntstatus != STATUS_PENDING) {
        CloseHandle( pBindRedir->EventHandle);
        pBindRedir->EventHandle = INVALID_HANDLE_VALUE;
    }


    pBindDgrec->EventHandle = CreateEvent(
            NULL,
            TRUE,
            FALSE,
            NULL
            );

    if ( pBindDgrec->EventHandle == INVALID_HANDLE_VALUE) {
        status = GetLastError();
        goto tail_exit;
    }

    ntstatus = NtDeviceIoControlFile(
            RxDgrecAsyncDeviceHandle,
            pBindDgrec->EventHandle,
            NULL,
            NULL,
            &pBindDgrec->IoStatusBlock,
            IOCTL_LMDR_BIND_TO_TRANSPORT,
            &pBindDgrec->Packet,
            dgrecSize,
            NULL,
            0
            );

    if ( ntstatus != STATUS_PENDING) {
        CloseHandle( pBindDgrec->EventHandle);
        pBindDgrec->EventHandle = INVALID_HANDLE_VALUE;
    }

tail_exit:
    InsertTailList( pHeader, &pBind->ListEntry);
    return NO_ERROR;
}



NTSTATUS
RxBindTransport(
    IN  LPTSTR TransportName,
    IN  DWORD QualityOfService,
    OUT LPDWORD ErrorParameter OPTIONAL
    )
/*++

Routine Description:

    This function binds the specified transport to the redirector
    and the datagram receiver.

    NOTE: The transport name length pass to the redirector and
          datagram receiver is the number of bytes.

Arguments:

    TransportName - Supplies the name of the transport to bind to.

    QualityOfService - Supplies a value which specifies the search
        order of the transport with respect to other transports.  The
        highest value is searched first.

    ErrorParameter - Returns the identifier to the invalid parameter if
        this function returns ERROR_INVALID_PARAMETER.

Return Value:

    NTSTATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS status;
    DWORD RequestPacketSize;
    DWORD TransportNameSize = wcslen(TransportName) * sizeof(TCHAR);

    PLMR_REQUEST_PACKET Rrp;
    PLMDR_REQUEST_PACKET Drrp;

    //
    // Size of request packet buffer
    //
    RequestPacketSize = wcslen(TransportName) * sizeof(WCHAR) +
                        max(sizeof(LMR_REQUEST_PACKET),
                            sizeof(LMDR_REQUEST_PACKET));

    //
    // Allocate memory for redirector/datagram receiver request packet
    //
    if ((Rrp = (PVOID) malloc((UINT) RequestPacketSize)) == NULL) {
        return GetLastError();
    }

    //
    // Get redirector to bind to transport
    //
    Rrp->Version = REQUEST_PACKET_VERSION;
    Rrp->Parameters.Bind.QualityOfService = QualityOfService;

    Rrp->Parameters.Bind.TransportNameLength = TransportNameSize;
    wcscpy(Rrp->Parameters.Bind.TransportName, TransportName);

    if ((status = RxRedirFsControl(
                      RxRedirDeviceHandle,
                      FSCTL_LMR_BIND_TO_TRANSPORT,
                      Rrp,
                      sizeof(LMR_REQUEST_PACKET) +
                          Rrp->Parameters.Bind.TransportNameLength,
                      //Rrp,                  BUGBUG: rdr bugchecks!
                      //RequestPacketSize,            specify NULL for now
                      NULL,
                      0,
                      NULL
                      )) != STATUS_SUCCESS) {

        if (status == ERROR_INVALID_PARAMETER &&
            ARGUMENT_PRESENT(ErrorParameter)) {

            *ErrorParameter = Rrp->Parameters.Bind.WkstaParameter;
        }

        (void) free(Rrp);
        return status;
    }


    //
    // Get dgrec to bind to transport
    //

    //
    // Make use of the same request packet buffer as FSCtl to
    // redirector.
    //
    Drrp = (PLMDR_REQUEST_PACKET) Rrp;

    Drrp->Version = LMDR_REQUEST_PACKET_VERSION;

    Drrp->Parameters.Bind.TransportNameLength = TransportNameSize;
    wcscpy(Drrp->Parameters.Bind.TransportName, TransportName);

    status = RxDgReceiverIoControl(
                 RxDgReceiverDeviceHandle,
                 IOCTL_LMDR_BIND_TO_TRANSPORT,
                 Drrp,
                 RequestPacketSize,
                 NULL,
                 0,
                 NULL
                 );

    (void) free(Rrp);
    return status;
}


VOID
RxUnbindTransport2(
    IN PRX_BIND     pBind
    )
/*++

Routine Description:

    This function unbinds the specified transport from the redirector
    and the datagram receiver.

Arguments:

    pBind - structure constructed via RxAsyncBindTransport()

Return Value:

    None.

--*/
{
//    NTSTATUS          status;
    PRX_BIND_REDIR          pBindRedir = pBind->Redir;
    PRX_BIND_DGREC          pBindDgrec = pBind->Dgrec;


    //
    // Get redirector to unbind from transport
    //

    if ( pBindRedir->Bound == TRUE) {
        pBindRedir->Packet.Parameters.Unbind.TransportNameLength
                = pBind->TransportNameLength;
        memcpy(
            pBindRedir->Packet.Parameters.Unbind.TransportName,
            pBind->TransportName,
            pBind->TransportNameLength
            );

        (VOID)NtFsControlFile(
                RxRedirDeviceHandle,
                NULL,
                NULL,                               // apc routine
                NULL,                               // apc context
                &pBindRedir->IoStatusBlock,
                FSCTL_LMR_UNBIND_FROM_TRANSPORT,    // control code
                &pBindRedir->Packet,
                sizeof( LMR_REQUEST_PACKET) +
                    pBindRedir->Packet.Parameters.Unbind.TransportNameLength,
                NULL,
                0
                );
        pBindRedir->Bound = FALSE;
    }

    //
    // Get datagram receiver to unbind from transport
    //

    if ( pBindDgrec->Bound == TRUE) {

        pBindDgrec->Packet.Parameters.Unbind.TransportNameLength
                = pBind->TransportNameLength;
        memcpy(
            pBindDgrec->Packet.Parameters.Unbind.TransportName,
            pBind->TransportName,
            pBind->TransportNameLength
            );

        (VOID)NtDeviceIoControlFile(
                RxDgReceiverDeviceHandle,
                NULL,
                NULL,                               // apc routine
                NULL,                               // apc context
                &pBindDgrec->IoStatusBlock,
                FSCTL_LMR_UNBIND_FROM_TRANSPORT,    // control code
                &pBindDgrec->Packet,
                sizeof( LMR_REQUEST_PACKET) +
                    pBindDgrec->Packet.Parameters.Unbind.TransportNameLength,
                NULL,
                0
                );
         pBindDgrec->Bound = FALSE;
    }
}


NTSTATUS
RxUnbindTransport(
    IN LPTSTR TransportName,
    IN DWORD ForceLevel
    )
/*++

Routine Description:

    This function unbinds the specified transport from the redirector
    and the datagram receiver.

    NOTE: The transport name length pass to the redirector and
          datagram receiver is the number of bytes.

Arguments:

    TransportName - Supplies the name of the transport to bind to.

    ForceLevel - Supplies the force level to delete active connections
        on the specified transport.

Return Value:

    NTSTATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS status;
    DWORD RequestPacketSize;
    DWORD TransportNameSize = wcslen(TransportName) * sizeof(TCHAR);

    PLMR_REQUEST_PACKET Rrp;
    PLMDR_REQUEST_PACKET Drrp;

    //
    // Size of request packet buffer
    //
    RequestPacketSize = wcslen(TransportName) * sizeof(WCHAR) +
                       max(sizeof(LMR_REQUEST_PACKET),
                            sizeof(LMDR_REQUEST_PACKET));

    //
    // Allocate memory for redirector/datagram receiver request packet
    //
    if ((Rrp = (PVOID) malloc((UINT) RequestPacketSize)) == NULL) {
        return GetLastError();
    }


    //
    // Get redirector to unbind from transport
    //
    Rrp->Version = REQUEST_PACKET_VERSION;
    Rrp->Level = ForceLevel;

    Rrp->Parameters.Unbind.TransportNameLength = TransportNameSize;
    wcscpy(Rrp->Parameters.Unbind.TransportName, TransportName);

    if ((status = RxRedirFsControl(
                      RxRedirDeviceHandle,
                      FSCTL_LMR_UNBIND_FROM_TRANSPORT,
                      Rrp,
                      sizeof(LMR_REQUEST_PACKET) +
                          Rrp->Parameters.Unbind.TransportNameLength,
                      NULL,
                      0,
                      NULL
                      )) != STATUS_SUCCESS) {
        (void) free(Rrp);
        return status;
    }

    //
    // Get datagram receiver to unbind from transport
    //

    //
    // Make use of the same request packet buffer as FSCtl to
    // redirector.
    //
    Drrp = (PLMDR_REQUEST_PACKET) Rrp;

    Drrp->Version = LMDR_REQUEST_PACKET_VERSION;
    Drrp->Level = ForceLevel;

    Drrp->Parameters.Unbind.TransportNameLength = TransportNameSize;
    wcscpy(Drrp->Parameters.Unbind.TransportName, TransportName);

    if ((status = RxDgReceiverIoControl(
                  RxDgReceiverDeviceHandle,
                  IOCTL_LMDR_UNBIND_FROM_TRANSPORT,
                  Drrp,
                  RequestPacketSize,
                  NULL,
                  0,
                  NULL
                  )) != STATUS_SUCCESS) {

// BUGBUG:  This is a hack until the bowser supports XNS and LOOP.

        if (status == STATUS_NOT_FOUND) {
            status = STATUS_SUCCESS;
        }
    }

    (void) free(Rrp);
    return status;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\drt\daytona\rxdrt.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    rxdrt.h

Abstract:

    Private header file which defines the global data for the Rx DRT

Author:

    Balan Sethu Raman -- Created from the workstation service code

--*/

#ifndef _RXDRT_INCLUDED_
#define _RXDRT_INCLUDED_


#include <nt.h>                   // NT definitions
#include <ntrtl.h>                // NT runtime library definitions
#include <nturtl.h>


#include <windef.h>               // Win32 type definitions
#include <winbase.h>              // Win32 base API prototypes
#include <winsvc.h>               // Win32 service control APIs


//
// Debug trace level bits for turning on/off trace statements in the
// Workstation service
//

//
// All debug flags on
//

#define RXDRT_DEBUG_ALL          0xFFFFFFFF


#if DBG

#define STATIC

extern DWORD RxDrtTrace;

#define DEBUG if (TRUE)

#define IF_DEBUG(Function) if (RxDrtTrace & WKSTA_DEBUG_ ## Function)

#else

#define STATIC static

#define DEBUG if (FALSE)

#define IF_DEBUG(Function) if (FALSE)

#endif // DBG

//
// Time for the sender of a start or stop request to the Workstation
// service to wait (in milliseconds) before checking on the
// Workstation service again to see if it is done.
//
#define WS_WAIT_HINT_TIME                    60000  // 60 seconds

extern DWORD RxDrtTrace;

#endif // ifndef _RXDRT_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\backpack.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    backpack.h

Abstract:

    This module contains the package for pseudo polling. When a caller
    requests the same operation and gets the same error return the rdr
    must prevent flooding the network by backing off requests. Examples
    of when this is desirable are receiving 0 bytes on consequtive reads
    and consequtive fails on a file lock.

    If the caller is flooding the network, the rdr will return the 0 bytes
    or lock fail to the user until NextTime. When NextTime is reached
    the network will be used.

Author:

    Colin Watson (colinw) 02-Jan-1991


Revision History:

    ColinWatson   [ColinW]       02-Jan-1991   Created
    Joe Linn      [JoeLinn]      10-Oct-1996   Lifted from rdr1 and massaged for rdr2


--*/

#ifndef _BACKPACK_
#define _BACKPACK_

typedef struct _THROTTLING_STATE {
    LARGE_INTEGER NextTime;          //  Do not access the network until
                            //   CurrentTime >= NextTime
    ULONG CurrentIncrement;  //  Number of Increments applied to calculate NextTime
    ULONG MaximumDelay;      //  Specifies slowest rate that we will back off to
                            //  NextTime <= CurrentTime + (Interval * MaximumDelay)
    LARGE_INTEGER Increment;//  {0,10000000} == 1 second
    ULONG NumberOfQueries;
}   THROTTLING_STATE, *PTHROTTLING_STATE;

//++
//
// VOID
// RxInitializeThrottlingState(
//     IN PTHROTTLING_STATE pBP,
//     IN ULONG Increment,
//     IN ULONG MaximumDelay
//     );
//
// Routine Description:
//
//     This routine is called to initialize the back off structure (usually in
//     an Icb).
//
// Arguments:
//
//     pBP         -   Supplies back pack data for this request.
//     Increment   -   Supplies the increase in delay in milliseconds, each time a request
//                     to the network fails.
//     MaximumDelay-   Supplies the longest delay the backoff package can introduce
//                     in milliseconds.
//
// Return Value:
//
//     None.
//
//--

#define RxInitializeThrottlingState( _pBP, _Increment, _MaximumDelay ) {  \
    if ((_Increment)>0) {                                               \
        (_pBP)->Increment.QuadPart = (_Increment) * 10000;              \
        (_pBP)->MaximumDelay = (_MaximumDelay) / (_Increment);          \
        (_pBP)->CurrentIncrement = 0;                                   \
    }}

//++
//
// VOID
// RxUninitializeBackPack(
//     IN PTHROTTLING_STATE pBP
//     )
//
// Routine Description:
//
//  Resets the Back Pack specified. Currently no work needed.
//
// Arguments:
//
//     pBP   -  Supplies back pack address.
//
// Return Value:
//
//     None.
//
//--

#define RxUninitializeBackPack( pBP ) ()

//  RxShouldRequestBeThrottled indicates when the request should not go to the network.

BOOLEAN
RxShouldRequestBeThrottled(
    IN PTHROTTLING_STATE pBP
    );

//  Register the last request as failed.

VOID
RxInitiateOrContinueThrottling (
    IN PTHROTTLING_STATE pBP
    );

//  Register the last request as worked.

//++
//
// VOID
// RxTerminateThrottling(
//     IN PTHROTTLING_STATE pBP
//     )
//
// Routine Description:
//
//  Sets the Delay to zero. This routine is called each time that
//  a network request succeeds to avoid the next request backing off.
//
// Arguments:
//
//     pBP   -  Supplies back pack address.
//
// Return Value:
//
//     None.
//
//--

#define RxTerminateThrottling( pBP ) ( (pBP)->CurrentIncrement = 0 )

//++
//
// VOID
// RxInitializeBackoffPackage (
//     VOID
//     )
//
// Routine Description:
//
//     This routine initializes the redirector back off package.
//
// Arguments:
//
//     None
//
// Return Value:
//
//    None.
//
//--

#define RxInitializeBackoffPackage( )

//++
//
// VOID
// RxUninitializeBackoffPackage (
//     VOID
//     )
//
// Routine Description:
//
//     This routine uninitializes the redirector back off package.
//
// Arguments:
//
//     None
//
// Return Value:
//
//    None.
//
//--

#define RxUninitializeBackoffPackage( )

#endif /* _BACKPACK_ */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\cifs.h ===
/*++

Copyright (c) 1989 - 1999  Microsoft Corporation

Module Name:

    cifs.h

Abstract:

    This module defines structures and constants for the Common Internet File System
	commands, request and response protocol.


--*/

#ifndef _CIFS_
#define _CIFS_


//
// The server has 16 bits available to it in each 32-bit status code.
// See \nt\sdk\inc\ntstatus.h for a description of the use of the
// high 16 bits of the status.
//
// The layout of the bits is:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------+-----------------------+
//  |Sev|C|   Facility--Server      | Class |        Code           |
//  +---+-+-------------------------+-------+-----------------------+
//
// Class values:
//     0 - a server-specific error code, not put directly on the wire.
//     1 - SMB error class DOS.  This includes those OS/2 errors
//             that share code values and meanings with the SMB protocol.
//     2 - SMB error class SERVER.
//     3 - SMB error class HARDWARE.
//     4 - other SMB error classes
//     5-E - undefined
//     F - an OS/2-specific error.  If the client is OS/2, then the
//              SMB error class is set to DOS and the code is set to
//              the actual OS/2 error code contained in the Code field.
//
// The meaning of the Code field depends on the Class value.  If the
// class is 00, then the code value is arbitrary.  For other classes,
// the code is the actual code of the error in the SMB or OS/2
// protocols.
//

#define SRV_STATUS_FACILITY_CODE 0x00980000L
#define SRV_SRV_STATUS                (0xC0000000L | SRV_STATUS_FACILITY_CODE)
#define SRV_DOS_STATUS                (0xC0001000L | SRV_STATUS_FACILITY_CODE)
#define SRV_SERVER_STATUS             (0xC0002000L | SRV_STATUS_FACILITY_CODE)
#define SRV_HARDWARE_STATUS           (0xC0003000L | SRV_STATUS_FACILITY_CODE)
#define SRV_WIN32_STATUS              (0xC000E000L | SRV_STATUS_FACILITY_CODE)
#define SRV_OS2_STATUS                (0xC000F000L | SRV_STATUS_FACILITY_CODE)

//++
//
// BOOLEAN
// SmbIsSrvStatus (
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     Macro to determine whether a status code is one defined by the
//     server (has the server facility code).
//
// Arguments:
//
//     Status - the status code to check.
//
// Return Value:
//
//     BOOLEAN - TRUE if the facility code is the servers, FALSE
//         otherwise.
//
//--

#define SrvIsSrvStatus(Status) \
    ( ((Status) & 0x1FFF0000) == SRV_STATUS_FACILITY_CODE ? TRUE : FALSE )

//++
//
// UCHAR
// SmbErrorClass (
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     This macro extracts the error class field from a server status
//     code.
//
// Arguments:
//
//     Status - the status code from which to get the error class.
//
// Return Value:
//
//     UCHAR - the server error class of the status code.
//
//--

#define SrvErrorClass(Status) ((UCHAR)( ((Status) & 0x0000F000) >> 12 ))

//++
//
// UCHAR
// SmbErrorCode (
//     IN NTSTATUS Status
//     )
//
// Routine Description:
//
//     This macro extracts the error code field from a server status
//     code.
//
// Arguments:
//
//     Status - the status code from which to get the error code.
//
// Return Value:
//
//     UCHAR - the server error code of the status code.
//
//--

#define SrvErrorCode(Status) ((USHORT)( (Status) & 0xFFF) )

//
// Status codes unique to the server.  These error codes are used
// internally only.
//

#define STATUS_ENDPOINT_CLOSED              (SRV_SRV_STATUS | 0x01)
#define STATUS_DISCONNECTED                 (SRV_SRV_STATUS | 0x02)
#define STATUS_SERVER_ALREADY_STARTED       (SRV_SRV_STATUS | 0x04)
#define STATUS_SERVER_NOT_STARTED           (SRV_SRV_STATUS | 0x05)
#define STATUS_OPLOCK_BREAK_UNDERWAY        (SRV_SRV_STATUS | 0x06)
#define STATUS_NONEXISTENT_NET_NAME         (SRV_SRV_STATUS | 0x08)

//
// Error codes that exist in both the SMB protocol and OS/2 but not NT.
// Note that all SMB DOS-class error codes are defined in OS/2.
//

#define STATUS_OS2_INVALID_FUNCTION   (SRV_DOS_STATUS | ERROR_INVALID_FUNCTION)
#define STATUS_OS2_TOO_MANY_OPEN_FILES \
                                   (SRV_DOS_STATUS | ERROR_TOO_MANY_OPEN_FILES)
#define STATUS_OS2_INVALID_ACCESS     (SRV_DOS_STATUS | ERROR_INVALID_ACCESS)

//
// SMB SERVER-class error codes that lack an NT or OS/2 equivalent.
//

#define STATUS_INVALID_SMB            (SRV_SERVER_STATUS | SMB_ERR_ERROR)
#define STATUS_SMB_BAD_NET_NAME       (SRV_SERVER_STATUS | SMB_ERR_BAD_NET_NAME)
#define STATUS_SMB_BAD_TID            (SRV_SERVER_STATUS | SMB_ERR_BAD_TID)
#define STATUS_SMB_BAD_UID            (SRV_SERVER_STATUS | SMB_ERR_BAD_UID)
#define STATUS_SMB_TOO_MANY_UIDS      (SRV_SERVER_STATUS | SMB_ERR_TOO_MANY_UIDS)
#define STATUS_SMB_USE_MPX            (SRV_SERVER_STATUS | SMB_ERR_USE_MPX)
#define STATUS_SMB_USE_STANDARD       (SRV_SERVER_STATUS | SMB_ERR_USE_STANDARD)
#define STATUS_SMB_CONTINUE_MPX       (SRV_SERVER_STATUS | SMB_ERR_CONTINUE_MPX)
#define STATUS_SMB_BAD_COMMAND        (SRV_SERVER_STATUS | SMB_ERR_BAD_COMMAND)
#define STATUS_SMB_NO_SUPPORT         (SRV_SERVER_STATUS | SMB_ERR_NO_SUPPORT_INTERNAL)

// *** because SMB_ERR_NO_SUPPORT uses 16 bits, but we have only 12 bits
//     available for error codes, it must be special-cased in the code.

//
// SMB HARDWARE-class error codes that lack an NT or OS/2 equivalent.
//

#define STATUS_SMB_DATA               (SRV_HARDWARE_STATUS | SMB_ERR_DATA)

//
// OS/2 error codes that lack an NT or SMB equivalent.
//

#include <winerror.h>

#define STATUS_OS2_INVALID_LEVEL \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_INVALID_LEVEL)

#define STATUS_OS2_EA_LIST_INCONSISTENT \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_EA_LIST_INCONSISTENT)

#define STATUS_OS2_NEGATIVE_SEEK \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_NEGATIVE_SEEK)

#define STATUS_OS2_NO_MORE_SIDS \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_NO_MORE_SEARCH_HANDLES)

#define STATUS_OS2_EAS_DIDNT_FIT \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_EAS_DIDNT_FIT)

#define STATUS_OS2_EA_ACCESS_DENIED \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_EA_ACCESS_DENIED)

#define STATUS_OS2_CANCEL_VIOLATION \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_CANCEL_VIOLATION)

#define STATUS_OS2_ATOMIC_LOCKS_NOT_SUPPORTED \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_ATOMIC_LOCKS_NOT_SUPPORTED)

#define STATUS_OS2_CANNOT_COPY \
        (NTSTATUS)(SRV_OS2_STATUS | ERROR_CANNOT_COPY)


//
// SMBDBG determines whether the get/put macros are instead defined as
// function calls.  (This is used to more reliablyfind char/short/long
// mismatches).
//

#ifndef SMBDBG
#define SMBDBG 0
#endif

//
// SMBDBG1 determines whether the names of short and long fields in SMB
// structures have an extra character appended.  This is used to ensure
// that these fields are only accessed via the get/put macros.  SMBDBG1
// must be disabled when SMBDBG is enabled.
//

#ifndef SMBDBG1
#define SMBDBG1 0
#endif

#if SMBDBG && SMBDBG1
#undef SMBDBG1
#define SMBDBG1 0
#endif

//
// If __unaligned support is available, or if we're compiling for a
// machine that handles unaligned accesses in hardware, then define
// SMB_USE_UNALIGNED as 1 (TRUE).  Otherwise, define it as 0 (FALSE).
// If SMB_USE_UNALIGNED is FALSE, then the macros below use byte
// accesses to build up word and longword accesses to unaligned fields.
//
// Currently, the machines we build for all have SMB_USE_UNALIGNED as
// TRUE.  x86 supports unaligned accesses in hardware, while the MIPS
// compiler supports the __unaligned keyword.
//
// Note that if SMB_USE_UNALIGNED is predefined, we use that definition.
// Also, if SMB_NO_UNALIGNED is defined as TRUE, it forces
// SMB_USE_ALIGNED off.  This allows us to force, for testing purposes,
// use of byte accesses in the macros.
//

#ifndef SMB_NO_UNALIGNED
#define SMB_NO_UNALIGNED 0
#endif

#ifndef SMB_USE_UNALIGNED
#if SMB_NO_UNALIGNED
#define SMB_USE_UNALIGNED 0
#else
#define SMB_USE_UNALIGNED 1
#endif
#endif

//
// ntdef.h defines UNALIGNED as "__unaligned" or "", depending on
// whether we're building for MIPS or x86, respectively.  Because we
// want to be able to disable use of __unaligned, we define
// SMB_UNALIGNED as "UNALIGNED" or "", depending on whether
// SMB_USE_UNALIGNED is TRUE or FALSE, respectively.
//

#if SMB_USE_UNALIGNED
#define SMB_UNALIGNED UNALIGNED
#else
#define SMB_UNALIGNED
#endif

//
// For ease of use, we define types for unaligned pointers to shorts
// and longs in SMBs.  Note that "PUSHORT UNALIGNED" doesn't work.
//

typedef unsigned short SMB_UNALIGNED *PSMB_USHORT;
typedef unsigned long SMB_UNALIGNED *PSMB_ULONG;

//
// Macros for renaming short and long SMB fields.
//

#if SMBDBG1

#define _USHORT( field ) USHORT field ## S
#define _ULONG( field ) ULONG field ## L

#else

#define _USHORT( field ) USHORT field
#define _ULONG( field ) ULONG field

#endif

//
// Force misalignment of the following structures
//

#ifndef NO_PACKING
#include <packon.h>
#endif // ndef NO_PACKING


//
// The SMB_DIALECT type corresponds to the different SMB dialects
// that the server can speak.  Associated with it is the DialectStrings[]
// array that holds information about the ASCIIZ strings that are passed
// in the Negotiate SMB.s
//
// These are listed in order from highest preference to lowest preference.
// The assigned numbers correspond to the array SrvClientTypes[] in the
// server module srvdata.c.
//

typedef enum _SMB_DIALECT {


    SmbDialectNtLanMan,             // NT LAN Man
    SmbDialectLanMan21,             // OS/2 Lanman 2.1
    SmbDialectDosLanMan21,          // DOS Lanman 2.1
    SmbDialectLanMan20,             // OS/2 1.2 LanMan 2.0
    SmbDialectDosLanMan20,          // DOS LanMan 2.0
    SmbDialectLanMan10,             // 1st version of full LanMan extensions
    SmbDialectMsNet30,              // Larger subset of LanMan extensions
    SmbDialectMsNet103,             // Limited subset of LanMan extensions
    SmbDialectPcLan10,              // Alternate original protocol
    SmbDialectPcNet10,              // Original protocol
    SmbDialectIllegal,

} SMB_DIALECT, *PSMB_DIALECT;

#define FIRST_DIALECT SmbDialectNtLanMan

#define FIRST_DIALECT_EMULATED  SmbDialectNtLanMan

#define LAST_DIALECT SmbDialectIllegal
#define IS_DOS_DIALECT(dialect)                                        \
    ( (BOOLEAN)( (dialect) == SmbDialectDosLanMan21 ||                 \
                 (dialect) == SmbDialectDosLanMan20 ||                 \
                 (dialect) > SmbDialectLanMan10 ) )
#define IS_OS2_DIALECT(dialect) ( (BOOLEAN)!IS_DOS_DIALECT(dialect) )

#define IS_NT_DIALECT(dialect)  (dialect) == SmbDialectNtLanMan

#define DIALECT_HONORS_UID(dialect)     \
    ( (BOOLEAN)(dialect <= SmbDialectDosLanMan20 ) )


//
// Date and time structures that conform to MS-DOS standard used in
// some SMBs.
//
// !!! These structures are not portable--they depend on a little-endian
//     machine (TwoSeconds in lowest bits, etc.)
//

typedef union _SMB_DATE {
    USHORT Ushort;
    struct {
        USHORT Day : 5;
        USHORT Month : 4;
        USHORT Year : 7;
    } Struct;
} SMB_DATE;
typedef SMB_DATE SMB_UNALIGNED *PSMB_DATE;

typedef union _SMB_TIME {
    USHORT Ushort;
    struct {
        USHORT TwoSeconds : 5;
        USHORT Minutes : 6;
        USHORT Hours : 5;
    } Struct;
} SMB_TIME;
typedef SMB_TIME SMB_UNALIGNED *PSMB_TIME;


//
// The SMB_FIND_BUFFER and SMB_FIND_BUFFER2 structures are used in the
// Transaction2 Find protocols to return files matching the requested
// specifications.  They are identical except for the EaSize field
// in SMB_FIND_BUFFER2.
//

typedef struct _SMB_FIND_BUFFER {
    SMB_DATE CreationDate;
    SMB_TIME CreationTime;
    SMB_DATE LastAccessDate;
    SMB_TIME LastAccessTime;
    SMB_DATE LastWriteDate;
    SMB_TIME LastWriteTime;
    _ULONG( DataSize );
    _ULONG( AllocationSize );
    _USHORT( Attributes );
    UCHAR FileNameLength;
    CHAR FileName[1];
} SMB_FIND_BUFFER;
typedef SMB_FIND_BUFFER SMB_UNALIGNED *PSMB_FIND_BUFFER;

typedef struct _SMB_FIND_BUFFER2 {
    SMB_DATE CreationDate;
    SMB_TIME CreationTime;
    SMB_DATE LastAccessDate;
    SMB_TIME LastAccessTime;
    SMB_DATE LastWriteDate;
    SMB_TIME LastWriteTime;
    _ULONG( DataSize );
    _ULONG( AllocationSize );
    _USHORT( Attributes );
    _ULONG( EaSize );               // this field intentionally misaligned!
    UCHAR FileNameLength;
    CHAR FileName[1];
} SMB_FIND_BUFFER2;
typedef SMB_FIND_BUFFER2 SMB_UNALIGNED *PSMB_FIND_BUFFER2;


//
// The following structures are used in OS/2 1.2 for extended attributes
// (EAs).  OS/2 2.0 uses the same structures as NT.  See the OS/2
// Programmer's Reference, Volume 4, Chapter 4 for more information.
//
// The FEA structure holds a single EA's name and value and is the
// equivalent ofthe NT structure FILE_FULL_EA_INFORMATION.
//

typedef struct _FEA {
    UCHAR fEA;
    UCHAR cbName;
    _USHORT( cbValue );
} FEA;
typedef FEA SMB_UNALIGNED *PFEA;

//
// The only legal bit in fEA is FEA_NEEDEA.
//

#define FEA_NEEDEA 0x80

//
// The FEALIST structure holds the names and values of multiple EAs
// NT has no direct equivalent but rather strings together
// FILE_FULL_EA_INFORMATION structures.
//

typedef struct _FEALIST {
    _ULONG( cbList );
    FEA list[1];
} FEALIST;
typedef FEALIST SMB_UNALIGNED *PFEALIST;

//
// The GEA structure holds the name of a single EA.  It is used to
// request the value of that EA in OS/2 API functions.  The NT
// equivalent is FILE_GET_EA_INFORMATION.
//

typedef struct _GEA {
    UCHAR cbName;
    CHAR szName[1];
} GEA;
typedef GEA SMB_UNALIGNED *PGEA;

//
// The GEALIST structure holds the names of multiple EAs.  NT has no
// direct equivalent but rather strings together FILE_GET_EA_INFORMATION
// structures.
//

typedef struct _GEALIST {
    _ULONG( cbList );
    GEA list[1];
} GEALIST;
typedef GEALIST SMB_UNALIGNED *PGEALIST;

//
// The EAOP structure holds EA information needed by API calls.  It has
// no NT equivalent.
//

typedef struct _EAOP {
    PGEALIST fpGEAList;
    PFEALIST fpFEAList;
    ULONG oError;
} EAOP;
typedef EAOP SMB_UNALIGNED *PEAOP;

//
// FSALLOCATE contains information about a disk returned by
// SrvSmbQueryFsInfo.
//

typedef struct _FSALLOCATE {
    _ULONG( idFileSystem );
    _ULONG( cSectorUnit );
    _ULONG( cUnit );
    _ULONG( cUnitAvail );
    _USHORT( cbSector );
} FSALLOCATE, *PFSALLOCATE;     // *** NOT SMB_UNALIGNED!

//
// VOLUMELABEL contains information about a volume label returned by
// SrvSmbQueryFsInformation.
//

typedef struct _VOLUMELABEL {
    UCHAR cch;
    CHAR szVolLabel[12];
} VOLUMELABEL, *PVOLUMELABEL;   // *** NOT SMB_UNALIGNED!

//
// FSINFO holds information about a volume returned by
// SrvSmbQueryFsInformation.
//

typedef struct _FSINFO {
    _ULONG( ulVsn );
    VOLUMELABEL vol;
} FSINFO, *PFSINFO;             // *** NOT SMB_UNALIGNED!

//
// File types (returned by OpenAndX and Transact2_Open)
// FileTypeIPC is a private definition for the NT redirector and
// is not in the smb protocol.
//

typedef enum _FILE_TYPE {
    FileTypeDisk = 0,
    FileTypeByteModePipe = 1,
    FileTypeMessageModePipe = 2,
    FileTypePrinter = 3,
    FileTypeCommDevice = 4,
    FileTypeIPC = 0xFFFE,
    FileTypeUnknown = 0xFFFF
} FILE_TYPE;

//
// Turn structure packing back off
//

#ifndef NO_PACKING
#include <packoff.h>
#endif // ndef NO_PACKING


//
// PVOID
// ALIGN_SMB_WSTR(
//     IN PVOID Pointer
//     )
//
// Routine description:
//
//     This macro aligns the input pointer to the next 2-byte boundary.
//     Used to align Unicode strings in SMBs.
//
// Arguments:
//
//     Pointer - A pointer
//
// Return Value:
//
//     PVOID - Pointer aligned to next 2-byte boundary.
//

#define ALIGN_SMB_WSTR( Pointer ) \
        (PVOID)( ((ULONG_PTR)Pointer + 1) & ~1 )

//
// Macro to find the size of an SMB parameter block.  This macro takes
// as input the type of a parameter block and a byte count.  It finds
// the offset of the Buffer field, which appears at the end of all
// parameter blocks, and adds the byte count to find the total size.
// The type of the returned offset is USHORT.
//
// Note that this macro does NOT pad to a word or longword boundary.
//

#define SIZEOF_SMB_PARAMS(type,byteCount)   \
            (USHORT)( (ULONG_PTR)&((type *)0)->Buffer[0] + (byteCount) )

//
// Macro to find the next location after an SMB parameter block.  This
// macro takes as input the address of the current parameter block, its
// type, and a byte count.  It finds the address of the Buffer field,
// which appears at the end of all parameter blocks, and adds the byte
// count to find the next available location.  The type of the returned
// pointer is PVOID.
//
// The byte count is passed in even though it is available through
// base->ByteCount.  The reason for this is that this number will be a
// compile-time constant in most cases, so the resulting code will be
// simpler and faster.
//
// !!! This macro does not round to a longword boundary when packing
//     is turned off.  Pre-LM 2.0 DOS redirectors cannot handle having
//     too much data sent to them; the exact amount must be sent.
//     We may want to make this macro such that the first location
//     AFTER the returned value (WordCount field of the SMB) is aligned,
//     since most of the fields are misaligned USHORTs.  This would
//     result in a minor performance win on the 386 and other CISC
//     machines.
//

#ifndef NO_PACKING

#define NEXT_LOCATION(base,type,byteCount)  \
        (PVOID)( (ULONG_PTR)( (PUCHAR)( &((type *)(base))->Buffer[0] ) ) + \
        (byteCount) )

#else

#define NEXT_LOCATION(base,type,byteCount)  \
        (PVOID)(( (ULONG_PTR)( (PUCHAR)( &((type *)(base))->Buffer[0] ) ) + \
        (byteCount) + 3) & ~3)

#endif

//
// Macro to find the offset of a followon command to an and X command.
// This offset is the number of bytes from the start of the SMB header
// to where the followon command's parameters should start.
//

#define GET_ANDX_OFFSET(header,params,type,byteCount) \
        (USHORT)( (PCHAR)(params) - (PCHAR)(header) + \
          SIZEOF_SMB_PARAMS( type,(byteCount) ) )

//
// The following are macros to assist in converting OS/2 1.2 EAs to
// NT style and vice-versa.
//

//++
//
// ULONG
// SmbGetNtSizeOfFea (
//     IN PFEA Fea
//     )
//
// Routine Description:
//
//     This macro gets the size that would be required to hold the FEA
//     in NT format.  The length is padded to account for the fact that
//     each FILE_FULL_EA_INFORMATION structure must start on a
//     longword boundary.
//
// Arguments:
//
//     Fea - a pointer to the OS/2 1.2 FEA structure to evaluate.
//
// Return Value:
//
//     ULONG - number of bytes the FEA would require in NT format.
//
//--

//
// The +1 is for the zero terminator on the name, the +3 is for padding.
//

#define SmbGetNtSizeOfFea( Fea )                                            \
            (ULONG)(( FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +   \
                      (Fea)->cbName + 1 + SmbGetUshort( &(Fea)->cbValue ) + \
                      3 ) & ~3 )

//++
//
// ULONG
// SmbGetNtSizeOfGea (
//     IN PFEA Gea
//     )
//
// Routine Description:
//
//     This macro gets the size that would be required to hold the GEA
//     in NT format.  The length is padded to account for the fact that
//     each FILE_FULL_EA_INFORMATION structure must start on a
//     longword boundary.
//
// Arguments:
//
//     Gea - a pointer to the OS/2 1.2 GEA structure to evaluate.
//
// Return Value:
//
//     ULONG - number of bytes the GEA would require in NT format.
//
//--

//
// The +1 is for the zero terminator on the name, the +3 is for padding.
//

#define SmbGetNtSizeOfGea( Gea )                                            \
            (ULONG)(( FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +   \
                      (Gea)->cbName + 1 + 3 ) & ~3 )

//++
//
// ULONG
// SmbGetOs2SizeOfNtFullEa (
//     IN PFILE_FULL_EA_INFORMATION NtFullEa;
//     )
//
// Routine Description:
//
//     This macro gets the size a FILE_FULL_EA_INFORMATION structure would
//     require to be represented in a OS/2 1.2 style FEA.
//
// Arguments:
//
//     NtFullEa - a pointer to the NT FILE_FULL_EA_INFORMATION structure
//         to evaluate.
//
// Return Value:
//
//     ULONG - number of bytes requires for the FEA.
//
//--

#define SmbGetOs2SizeOfNtFullEa( NtFullEa )                                        \
            (ULONG)( sizeof(FEA) + (NtFullEa)->EaNameLength + 1 +               \
                     (NtFullEa)->EaValueLength )

//++
//
// ULONG
// SmbGetOs2SizeOfNtGetEa (
//     IN PFILE_GET_EA_INFORMATION NtGetEa;
//     )
//
// Routine Description:
//
//     This macro gets the size a FILE_GET_EA_INFORMATION structure would
//     require to be represented in a OS/2 1.2 style GEA.
//
// Arguments:
//
//     NtGetEa - a pointer to the NT FILE_GET_EA_INFORMATION structure
//         to evaluate.
//
// Return Value:
//
//     ULONG - number of bytes requires for the GEA.
//
//--

//
// The zero terminator on the name is accounted for by the szName[0]
// field in the GEA definition.
//

#define SmbGetOs2SizeOfNtGetEa( NtGetEa )                                        \
            (ULONG)( sizeof(GEA) + (NtGetEa)->EaNameLength )


/*

Inclusion of SMB request/response structures in this file is
conditionalized in the following way:

    If INCLUDE_SMB_ALL is defined, all of the structures are defined.

    Otherwise, the following names, if defined, cause inclusion of the
    corresponding SMB categories:

        INCLUDE_SMB_ADMIN           Administrative requests:
                                        PROCESS_EXIT
                                        NEGOTIATE
                                        SESSION_SETUP_ANDX
                                        LOGOFF_ANDX

        INCLUDE_SMB_TREE            Tree connect requests:
                                        TREE_CONNECT
                                        TREE_DISCONNECT
                                        TREE_CONNECT_ANDX

        INCLUDE_SMB_DIRECTORY       Directory-related requests:
                                        CREATE_DIRECTORY
                                        DELETE_DIRECTORY
                                        CHECK_DIRECTORY

        INCLUDE_SMB_OPEN_CLOSE      File open and close requests:
                                        OPEN
                                        CREATE
                                        CLOSE
                                        CREATE_TEMPORARY
                                        CREATE_NEW
                                        OPEN_ANDX
                                        CLOSE_AND_TREE_DISC

        INCLUDE_SMB_READ_WRITE      Read and write requests:
                                        READ
                                        WRITE
                                        SEEK
                                        LOCK_AND_READ
                                        WRITE_AND_UNLOCK
                                        WRITE_AND_CLOSE
                                        READ_ANDX
                                        WRITE_ANDX


        INCLUDE_SMB_FILE_CONTROL    File control requests:
                                        FLUSH
                                        DELETE
                                        RENAME
                                        COPY
                                        MOVE

        INCLUDE_SMB_QUERY_SET       File query/set requests:
                                        QUERY_INFORMATION
                                        SET_INFORMATION
                                        QUERY_INFORMATION2
                                        SET_INFORMATION2
                                        QUERY_PATH_INFORMATION
                                        SET_PATH_INFORMATION
                                        QUERY_FILE_INFORMATION
                                        SET_FILE_INFORMATION

        INCLUDE_SMB_LOCK            Lock requests (not LOCK_AND_READ)
                                        LOCK_BYTE_RANGE
                                        UNLOCK_BYTE_RANGE
                                        LOCKING_ANDX

        INCLUDE_SMB_RAW             Raw read/write requests:
                                        READ_RAW
                                        WRITE_RAW

        INCLUDE_SMB_MPX             Multiplexed requests:
                                        READ_MPX
                                        WRITE_MPX

        INCLUDE_SMB_SEARCH          Search requests:
                                        FIND_CLOSE2
                                        FIND_NOTIFY_CLOSE
                                        SEARCH
                                        FIND
                                        FIND_UNIQUE
                                        FIND_CLOSE

        INCLUDE_SMB_TRANSACTION     Transaction and IOCTL requests:
                                        TRANSACTION
                                        IOCTL
                                        TRANSACTION2
                                        NTTRANSACTION

        INCLUDE_SMB_PRINT           Printer requests:
                                        OPEN_PRINT_FILE
                                        WRITE_PRINT_FILE
                                        CLOSE_PRINT_FILE
                                        GET_PRINT_QUEUE

        INCLUDE_SMB_MESSAGE         Message requests:
                                        SEND_MESSAGE
                                        SEND_BROADCAST_MESSAGE
                                        FORWARD_USER_NAME
                                        CANCEL_FORWARD
                                        GET_MACHINE_NAME
                                        SEND_START_MB_MESSAGE
                                        SEND_END_MB_MESSAGE
                                        SEND_TEXT_MB_MESSAGE

        INCLUDE_SMB_MISC            Miscellaneous requests:
                                        QUERY_INFORMATION_SRV
                                        ECHO
                                        QUERY_INFORMATION_DISK
*/

#ifdef INCLUDE_SMB_ALL

#define INCLUDE_SMB_ADMIN
#define INCLUDE_SMB_TREE
#define INCLUDE_SMB_DIRECTORY
#define INCLUDE_SMB_OPEN_CLOSE
#define INCLUDE_SMB_FILE_CONTROL
#define INCLUDE_SMB_READ_WRITE
#define INCLUDE_SMB_LOCK
#define INCLUDE_SMB_RAW
#define INCLUDE_SMB_MPX
#define INCLUDE_SMB_QUERY_SET
#define INCLUDE_SMB_SEARCH
#define INCLUDE_SMB_TRANSACTION
#define INCLUDE_SMB_PRINT
#define INCLUDE_SMB_MESSAGE
#define INCLUDE_SMB_MISC

#endif // def INCLUDE_SMB_ALL


//
// Force misalignment of the following structures
//

#ifndef NO_PACKING
#include <packon.h>
#endif // ndef NO_PACKING

//
// SMB servers listen on two NETBIOS addresses to facilitate connections. The
// first one is a name formulated from the computer name by padding it with
// a number of blanks ( upto NETBIOS_NAME_LEN ). This name is registered and
// resolved using the NETBIOS name registration/resolution mechanism. They also
// register under a second name *SMBSERVER which is not a valuid netbios name
// but provides a name which can be used in NETBT session setup. This eliminates
// the need for querying the remote adapter status to obtain the name.
//

#define SMBSERVER_LOCAL_ENDPOINT_NAME "*SMBSERVER      "

//
// SMB Command code definitions:
//

// *** Start of SMB commands
#define SMB_COM_CREATE_DIRECTORY         (UCHAR)0x00
#define SMB_COM_DELETE_DIRECTORY         (UCHAR)0x01
#define SMB_COM_OPEN                     (UCHAR)0x02
#define SMB_COM_CREATE                   (UCHAR)0x03
#define SMB_COM_CLOSE                    (UCHAR)0x04
#define SMB_COM_FLUSH                    (UCHAR)0x05
#define SMB_COM_DELETE                   (UCHAR)0x06
#define SMB_COM_RENAME                   (UCHAR)0x07
#define SMB_COM_QUERY_INFORMATION        (UCHAR)0x08
#define SMB_COM_SET_INFORMATION          (UCHAR)0x09
#define SMB_COM_READ                     (UCHAR)0x0A
#define SMB_COM_WRITE                    (UCHAR)0x0B
#define SMB_COM_LOCK_BYTE_RANGE          (UCHAR)0x0C
#define SMB_COM_UNLOCK_BYTE_RANGE        (UCHAR)0x0D
#define SMB_COM_CREATE_TEMPORARY         (UCHAR)0x0E
#define SMB_COM_CREATE_NEW               (UCHAR)0x0F
#define SMB_COM_CHECK_DIRECTORY          (UCHAR)0x10
#define SMB_COM_PROCESS_EXIT             (UCHAR)0x11
#define SMB_COM_SEEK                     (UCHAR)0x12
#define SMB_COM_LOCK_AND_READ            (UCHAR)0x13
#define SMB_COM_WRITE_AND_UNLOCK         (UCHAR)0x14
#define SMB_COM_READ_RAW                 (UCHAR)0x1A
#define SMB_COM_READ_MPX                 (UCHAR)0x1B
#define SMB_COM_READ_MPX_SECONDARY       (UCHAR)0x1C    // server to redir only
#define SMB_COM_WRITE_RAW                (UCHAR)0x1D
#define SMB_COM_WRITE_MPX                (UCHAR)0x1E
#define SMB_COM_WRITE_MPX_SECONDARY      (UCHAR)0x1F
#define SMB_COM_WRITE_COMPLETE           (UCHAR)0x20    // server to redir only
#define SMB_COM_QUERY_INFORMATION_SRV    (UCHAR)0x21
#define SMB_COM_SET_INFORMATION2         (UCHAR)0x22
#define SMB_COM_QUERY_INFORMATION2       (UCHAR)0x23
#define SMB_COM_LOCKING_ANDX             (UCHAR)0x24
#define SMB_COM_TRANSACTION              (UCHAR)0x25
#define SMB_COM_TRANSACTION_SECONDARY    (UCHAR)0x26
#define SMB_COM_IOCTL                    (UCHAR)0x27
#define SMB_COM_IOCTL_SECONDARY          (UCHAR)0x28
#define SMB_COM_COPY                     (UCHAR)0x29
#define SMB_COM_MOVE                     (UCHAR)0x2A
#define SMB_COM_ECHO                     (UCHAR)0x2B
#define SMB_COM_WRITE_AND_CLOSE          (UCHAR)0x2C
#define SMB_COM_OPEN_ANDX                (UCHAR)0x2D
#define SMB_COM_READ_ANDX                (UCHAR)0x2E
#define SMB_COM_WRITE_ANDX               (UCHAR)0x2F
#define SMB_COM_CLOSE_AND_TREE_DISC      (UCHAR)0x31
#define SMB_COM_TRANSACTION2             (UCHAR)0x32
#define SMB_COM_TRANSACTION2_SECONDARY   (UCHAR)0x33
#define SMB_COM_FIND_CLOSE2              (UCHAR)0x34
#define SMB_COM_FIND_NOTIFY_CLOSE        (UCHAR)0x35
#define SMB_COM_TREE_CONNECT             (UCHAR)0x70
#define SMB_COM_TREE_DISCONNECT          (UCHAR)0x71
#define SMB_COM_NEGOTIATE                (UCHAR)0x72
#define SMB_COM_SESSION_SETUP_ANDX       (UCHAR)0x73
#define SMB_COM_LOGOFF_ANDX              (UCHAR)0x74
#define SMB_COM_TREE_CONNECT_ANDX        (UCHAR)0x75
#define SMB_COM_QUERY_INFORMATION_DISK   (UCHAR)0x80
#define SMB_COM_SEARCH                   (UCHAR)0x81
#define SMB_COM_FIND                     (UCHAR)0x82
#define SMB_COM_FIND_UNIQUE              (UCHAR)0x83
#define SMB_COM_FIND_CLOSE               (UCHAR)0x84
#define SMB_COM_NT_TRANSACT              (UCHAR)0xA0
#define SMB_COM_NT_TRANSACT_SECONDARY    (UCHAR)0xA1
#define SMB_COM_NT_CREATE_ANDX           (UCHAR)0xA2
#define SMB_COM_NT_CANCEL                (UCHAR)0xA4
#define SMB_COM_NT_RENAME                (UCHAR)0xA5
#define SMB_COM_OPEN_PRINT_FILE          (UCHAR)0xC0
#define SMB_COM_WRITE_PRINT_FILE         (UCHAR)0xC1
#define SMB_COM_CLOSE_PRINT_FILE         (UCHAR)0xC2
#define SMB_COM_GET_PRINT_QUEUE          (UCHAR)0xC3
#define SMB_COM_SEND_MESSAGE             (UCHAR)0xD0
#define SMB_COM_SEND_BROADCAST_MESSAGE   (UCHAR)0xD1
#define SMB_COM_FORWARD_USER_NAME        (UCHAR)0xD2
#define SMB_COM_CANCEL_FORWARD           (UCHAR)0xD3
#define SMB_COM_GET_MACHINE_NAME         (UCHAR)0xD4
#define SMB_COM_SEND_START_MB_MESSAGE    (UCHAR)0xD5
#define SMB_COM_SEND_END_MB_MESSAGE      (UCHAR)0xD6
#define SMB_COM_SEND_TEXT_MB_MESSAGE     (UCHAR)0xD7
// *** End of SMB commands

#define SMB_COM_NO_ANDX_COMMAND          (UCHAR)0xFF


//
// Header for SMBs, see #4 page 10
//
// *** Note that we do NOT define PSMB_HEADER as SMB_UNALIGNED!  This is
//     done on the assumption that the SMB header, at least, will always
//     be properly aligned.  If you need to access an unaligned header,
//     declare the pointer as SMB_UNALIGNED *SMB_HEADER.
//

#define SMB_SECURITY_SIGNATURE_LENGTH  8

typedef struct _SMB_HEADER {
    UCHAR Protocol[4];                  // Contains 0xFF,'SMB'
    UCHAR Command;                      // Command code
    UCHAR ErrorClass;                   // Error class
    UCHAR Reserved;                     // Reserved for future use
    _USHORT( Error );                   // Error code
    UCHAR Flags;                        // Flags
    _USHORT( Flags2 );                  // More flags
    union {
        _USHORT( Reserved2 )[6];        // Reserved for future use
        struct {
            _USHORT( PidHigh );         // High part of PID (NT Create And X)
            union {
                struct {
                    _ULONG( Key );              // Encryption key (IPX)
                    _USHORT( Sid );             // Session ID (IPX)
                    _USHORT( SequenceNumber );  // Sequence number (IPX)
                    _USHORT( Gid );             // Group ID (unused?)
                };
                UCHAR SecuritySignature[SMB_SECURITY_SIGNATURE_LENGTH];
                                         // Client must send the correct Signature
                                         // for this SMB to be accepted.
            };
        };
    };
    _USHORT( Tid );                     // Authenticated user/group
    _USHORT( Pid );                     // Caller's process id
    _USHORT( Uid );                     // Unauthenticated user id
    _USHORT( Mid );                     // multiplex id
#ifdef NO_PACKING                       // ***
    _USHORT( Kludge );                  // *** make sure parameter structs
#endif                                  // *** are longword aligned
} SMB_HEADER;
typedef SMB_HEADER *PSMB_HEADER;

typedef struct _NT_SMB_HEADER {
    UCHAR Protocol[4];                  // Contains 0xFF,'SMB'
    UCHAR Command;                      // Command code
    union {
        struct {
            UCHAR ErrorClass;           // Error class
            UCHAR Reserved;             // Reserved for future use
            _USHORT( Error );           // Error code
        } DosError;
        ULONG NtStatus;                 // NT-style 32-bit error code
    } Status;
    UCHAR Flags;                        // Flags
    _USHORT( Flags2 );                  // More flags
    union {
        _USHORT( Reserved2 )[6];        // Reserved for future use
        struct {
            _USHORT( PidHigh );         // High part of PID (NT Create And X)
            union {
                struct {
                    _ULONG( Key );              // Encryption key (IPX)
                    _USHORT( Sid );             // Session ID (IPX)
                    _USHORT( SequenceNumber );  // Sequence number (IPX)
                    _USHORT( Gid );             // Group ID (unused?)
                };
                UCHAR SecuritySignature[SMB_SECURITY_SIGNATURE_LENGTH];
                                         // Client must send the correct Signature
                                         // for this SMB to be accepted.
            };
        };
    };
    _USHORT( Tid );                     // Authenticated user/group
    _USHORT( Pid );                     // Caller's process id
    _USHORT( Uid );                     // Unauthenticated user id
    _USHORT( Mid );                     // multiplex id
#ifdef NO_PACKING                       // ***
    _USHORT( Kludge );                  // *** make sure parameter structs
#endif                                  // *** are longword aligned
} NT_SMB_HEADER;
typedef NT_SMB_HEADER *PNT_SMB_HEADER;

//
// The SMB header, protocol field, as a long.
//

#define SMB_HEADER_PROTOCOL   (0xFF + ('S' << 8) + ('M' << 16) + ('B' << 24))

//
// Minimum parameter structure that can be returned.  Used in returning
// error SMBs.
//
// *** Note that this structure does NOT have a Buffer field!
//

typedef struct _SMB_PARAMS {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of bytes that follow; min = 0
} SMB_PARAMS;
typedef SMB_PARAMS SMB_UNALIGNED *PSMB_PARAMS;

//
// Generic header for AndX commands.
//

typedef struct _GENERIC_ANDX {
    UCHAR WordCount;                    // Count of parameter words
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved
    _USHORT( AndXOffset );              // Offset (from SMB header start)
} GENERIC_ANDX;
typedef GENERIC_ANDX SMB_UNALIGNED *PGENERIC_ANDX;


#ifdef INCLUDE_SMB_MESSAGE

//
// Cancel Forward SMB, see #1 page 35
// Function is SrvSmbCancelForward()
// SMB_COM_CANCEL_FORWARD 0xD3
//

typedef struct _REQ_CANCEL_FORWARD {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR ForwardedName[];            //  Forwarded name
} REQ_CANCEL_FORWARD;
typedef REQ_CANCEL_FORWARD SMB_UNALIGNED *PREQ_CANCEL_FORWARD;

typedef struct _RESP_CANCEL_FORWARD {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CANCEL_FORWARD;
typedef RESP_CANCEL_FORWARD SMB_UNALIGNED *PRESP_CANCEL_FORWARD;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_DIRECTORY

//
// Check Directory SMB, see #1 page 23
// Function is SrvSmbCheckDirectory()
// SMB_COM_CHECK_DIRECTORY 0x10
//

typedef struct _REQ_CHECK_DIRECTORY {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR DirectoryPath[];            //  Directory path
} REQ_CHECK_DIRECTORY;
typedef REQ_CHECK_DIRECTORY SMB_UNALIGNED *PREQ_CHECK_DIRECTORY;

typedef struct _RESP_CHECK_DIRECTORY {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CHECK_DIRECTORY;
typedef RESP_CHECK_DIRECTORY SMB_UNALIGNED *PRESP_CHECK_DIRECTORY;

#endif // def INCLUDE_SMB_DIRECTORY

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Close SMB, see #1 page 10
// Function is SrvSmbClose()
// SMB_COM_CLOSE 0x04
//

typedef struct _REQ_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 3
    _USHORT( Fid );                     // File handle
    _ULONG( LastWriteTimeInSeconds );   // Time of last write, low and high
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_CLOSE;
typedef REQ_CLOSE SMB_UNALIGNED *PREQ_CLOSE;

typedef struct _RESP_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CLOSE;
typedef RESP_CLOSE SMB_UNALIGNED *PRESP_CLOSE;

#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Close and Tree Disconnect SMB, see #? page ??
// Function is SrvSmbCloseAndTreeDisc
// SMB_COM_CLOSE_AND_TREE_DISC 0x31
//

typedef struct _REQ_CLOSE_AND_TREE_DISC {
    UCHAR WordCount;                    // Count of parameter words
    _USHORT( Fid );                     // File handle
    _ULONG( LastWriteTimeInSeconds );
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_CLOSE_AND_TREE_DISC;
typedef REQ_CLOSE_AND_TREE_DISC SMB_UNALIGNED *PREQ_CLOSE_AND_TREE_DISC;

typedef struct _RESP_CLOSE_AND_TREE_DISC {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CLOSE_AND_TREE_DISC;
typedef RESP_CLOSE_AND_TREE_DISC SMB_UNALIGNED *PRESP_CLOSE_AND_TREE_DISC;

#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_PRINT

//
// Close Print Spool File SMB, see #1 page 29
// Function is SrvSmbClosePrintSpoolFile()
// SMB_COM_CLOSE_PRINT_FILE 0xC2
//

typedef struct _REQ_CLOSE_PRINT_FILE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_CLOSE_PRINT_FILE;
typedef REQ_CLOSE_PRINT_FILE SMB_UNALIGNED *PREQ_CLOSE_PRINT_FILE;

typedef struct _RESP_CLOSE_PRINT_FILE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CLOSE_PRINT_FILE;
typedef RESP_CLOSE_PRINT_FILE SMB_UNALIGNED *PRESP_CLOSE_PRINT_FILE;

#endif // def INCLUDE_SMB_PRINT

#ifdef INCLUDE_SMB_FILE_CONTROL

//
// Copy SMB, see #2 page 23
// Function is SrvSmbCopy()
// SMB_COM_COPY 0x29
//

typedef struct _REQ_COPY {
    UCHAR WordCount;                    // Count of parameter words = 3
    _USHORT( Tid2 );                    // Second (target) path TID
    _USHORT( OpenFunction );            // What to do if target file exists
    _USHORT( Flags );                   // Flags to control copy operation:
                                        //  bit 0 - target must be a file
                                        //  bit 1 - target must ba a dir.
                                        //  bit 2 - copy target mode:
                                        //          0 = binary, 1 = ASCII
                                        //  bit 3 - copy source mode:
                                        //          0 = binary, 1 = ASCII
                                        //  bit 4 - verify all writes
                                        //  bit 5 - tree copy
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR SourceFileName[];           //  pathname of source file
    //UCHAR TargetFileName[];           //  pathname of target file
} REQ_COPY;
typedef REQ_COPY SMB_UNALIGNED *PREQ_COPY;

typedef struct _RESP_COPY {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Number of files copied
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // ASCIIZ pathname of file with error
} RESP_COPY;
typedef RESP_COPY SMB_UNALIGNED *PRESP_COPY;

#endif // def INCLUDE_SMB_FILE_CONTROL

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Create SMB, see #1 page 9
// Create New SMB, see #1 page 23
// Function is SrvSmbCreate()
// SMB_COM_CREATE 0x03
// SMB_COM_CREATE_NEW 0x0F
//

typedef struct _REQ_CREATE {
    UCHAR WordCount;                    // Count of parameter words = 3
    _USHORT( FileAttributes );          // New file attributes
    _ULONG( CreationTimeInSeconds );        // Creation time
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name
} REQ_CREATE;
typedef REQ_CREATE SMB_UNALIGNED *PREQ_CREATE;

typedef struct _RESP_CREATE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CREATE;
typedef RESP_CREATE SMB_UNALIGNED *PRESP_CREATE;

#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_DIRECTORY

//
// Create Directory SMB, see #1 page 14
// Function is SrvSmbCreateDirectory
// SMB_COM_CREATE_DIRECTORY 0x00
//

typedef struct _REQ_CREATE_DIRECTORY {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR DirectoryName[];            //  Directory name
} REQ_CREATE_DIRECTORY;
typedef REQ_CREATE_DIRECTORY SMB_UNALIGNED *PREQ_CREATE_DIRECTORY;

typedef struct _RESP_CREATE_DIRECTORY {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_CREATE_DIRECTORY;
typedef RESP_CREATE_DIRECTORY SMB_UNALIGNED *PRESP_CREATE_DIRECTORY;

#endif // def INCLUDE_SMB_DIRECTORY

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Create Temporary SMB, see #1 page 21
// Function is SrvSmbCreateTemporary()
// SMB_COM_CREATE_TEMPORARY 0x0E
//

typedef struct _REQ_CREATE_TEMPORARY {
    UCHAR WordCount;                    // Count of parameter words = 3
    _USHORT( FileAttributes );
    _ULONG( CreationTimeInSeconds );
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR DirectoryName[];            //  Directory name
} REQ_CREATE_TEMPORARY;
typedef REQ_CREATE_TEMPORARY SMB_UNALIGNED *PREQ_CREATE_TEMPORARY;

typedef struct _RESP_CREATE_TEMPORARY {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name
} RESP_CREATE_TEMPORARY;
typedef RESP_CREATE_TEMPORARY SMB_UNALIGNED *PRESP_CREATE_TEMPORARY;

#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_FILE_CONTROL

//
// Delete SMB, see #1 page 16
// Function is SrvSmbDelete()
// SMB_COM_DELETE 0x06
//

typedef struct _REQ_DELETE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( SearchAttributes );
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name
} REQ_DELETE;
typedef REQ_DELETE SMB_UNALIGNED *PREQ_DELETE;

typedef struct _RESP_DELETE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_DELETE;
typedef RESP_DELETE SMB_UNALIGNED *PRESP_DELETE;

#endif // def INCLUDE_SMB_FILE_CONTROL

#ifdef INCLUDE_SMB_DIRECTORY

//
// Delete Directory SMB, see #1 page 15
// Function is SrvSmbDeleteDirectory()
// SMB_COM_DELETE_DIRECTORY 0x01
//

typedef struct _REQ_DELETE_DIRECTORY {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR DirectoryName[];            //  Directory name
} REQ_DELETE_DIRECTORY;
typedef REQ_DELETE_DIRECTORY SMB_UNALIGNED *PREQ_DELETE_DIRECTORY;

typedef struct _RESP_DELETE_DIRECTORY {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_DELETE_DIRECTORY;
typedef RESP_DELETE_DIRECTORY SMB_UNALIGNED *PRESP_DELETE_DIRECTORY;

#endif // def INCLUDE_SMB_DIRECTORY

#ifdef INCLUDE_SMB_MISC

//
// Echo SMB, see #2 page 25
// Function is SrvSmbEcho()
// SMB_COM_ECHO 0x2B
//

typedef struct _REQ_ECHO {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( EchoCount );               // Number of times to echo data back
    _USHORT( ByteCount );               // Count of data bytes; min = 4
    UCHAR Buffer[1];                    // Data to echo
} REQ_ECHO;
typedef REQ_ECHO SMB_UNALIGNED *PREQ_ECHO;

typedef struct _RESP_ECHO {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( SequenceNumber );          // Sequence number of this echo
    _USHORT( ByteCount );               // Count of data bytes; min = 4
    UCHAR Buffer[1];                    // Echoed data
} RESP_ECHO;
typedef RESP_ECHO SMB_UNALIGNED *PRESP_ECHO;

#endif // def INCLUDE_SMB_MISC

#ifdef INCLUDE_SMB_SEARCH

//
// Find Close2 SMB, see #3 page 54
// Function is SrvFindClose2()
// SMB_COM_FIND_CLOSE2 0x34
//

typedef struct _REQ_FIND_CLOSE2 {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Sid );                     // Find handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_FIND_CLOSE2;
typedef REQ_FIND_CLOSE2 SMB_UNALIGNED *PREQ_FIND_CLOSE2;

typedef struct _RESP_FIND_CLOSE2 {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_FIND_CLOSE2;
typedef RESP_FIND_CLOSE2 SMB_UNALIGNED *PRESP_FIND_CLOSE2;

#endif // def INCLUDE_SMB_SEARCH

#ifdef INCLUDE_SMB_SEARCH

//
// Find Notify Close SMB, see #3 page 53
// Function is SrvSmbFindNotifyClose()
// SMB_COM_FIND_NOTIFY_CLOSE 0x35
//

typedef struct _REQ_FIND_NOTIFY_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Handle );                  // Find notify handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_FIND_NOTIFY_CLOSE;
typedef REQ_FIND_NOTIFY_CLOSE SMB_UNALIGNED *PREQ_FIND_NOTIFY_CLOSE;

typedef struct _RESP_FIND_NOTIFY_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_FIND_NOTIFY_CLOSE;
typedef RESP_FIND_NOTIFY_CLOSE SMB_UNALIGNED *PRESP_FIND_NOTIFY_CLOSE;

#endif // def INCLUDE_SMB_SEARCH

#ifdef INCLUDE_SMB_FILE_CONTROL

//
// Flush SMB, see #1 page 11
// Function is SrvSmbFlush()
// SMB_COM_FLUSH 0x05
//

typedef struct _REQ_FLUSH {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_FLUSH;
typedef REQ_FLUSH SMB_UNALIGNED *PREQ_FLUSH;

typedef struct _RESP_FLUSH {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_FLUSH;
typedef RESP_FLUSH SMB_UNALIGNED *PRESP_FLUSH;

#endif // def INCLUDE_SMB_FILE_CONTROL

#ifdef INCLUDE_SMB_MESSAGE

//
// Forward User Name SMB, see #1 page 34
// Function is SrvSmbForwardUserName()
// SMB_COM_FORWARD_USER_NAME 0xD2
//

typedef struct _REQ_FORWARD_USER_NAME {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR ForwardedName[];            //  Forwarded name
} REQ_FORWARD_USER_NAME;
typedef REQ_FORWARD_USER_NAME SMB_UNALIGNED *PREQ_FORWARD_USER_NAME;

typedef struct _RESP_FORWARD_USER_NAME {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_FORWARD_USER_NAME;
typedef RESP_FORWARD_USER_NAME SMB_UNALIGNED *PRESP_FORWARD_USER_NAME;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_MESSAGE

//
// Get Machine Name SMB, see #1 page 35
// Function is SrvSmbGetMachineName()
// SMB_COM_GET_MACHINE_NAME 0xD4
//

typedef struct _REQ_GET_MACHINE_NAME {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_GET_MACHINE_NAME;
typedef REQ_GET_MACHINE_NAME SMB_UNALIGNED *PREQ_GET_MACHINE_NAME;

typedef struct _RESP_GET_MACHINE_NAME {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR MachineName[];              //  Machine name
} RESP_GET_MACHINE_NAME;
typedef RESP_GET_MACHINE_NAME SMB_UNALIGNED *PRESP_GET_MACHINE_NAME;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_PRINT

//
// Get Print Queue SMB, see #1 page 29
// Function is SrvSmbGetPrintQueue()
// SMB_COM_GET_PRINT_QUEUE 0xC3
//

typedef struct _REQ_GET_PRINT_QUEUE {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( MaxCount );                // Max number of entries to return
    _USHORT( StartIndex );              // First queue entry to return
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_GET_PRINT_QUEUE;
typedef REQ_GET_PRINT_QUEUE SMB_UNALIGNED *PREQ_GET_PRINT_QUEUE;

typedef struct _RESP_GET_PRINT_QUEUE {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( Count );                   // Number of entries returned
    _USHORT( RestartIndex );            // Index of entry after last returned
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x01 -- Data block
    //USHORT DataLength;                //  Length of data
    //UCHAR Data[];                     //  Queue elements
} RESP_GET_PRINT_QUEUE;
typedef RESP_GET_PRINT_QUEUE SMB_UNALIGNED *PRESP_GET_PRINT_QUEUE;

#endif // def INCLUDE_SMB_PRINT

#ifdef INCLUDE_SMB_TRANSACTION

//
// Ioctl SMB, see #2 page 39
// Function is SrvSmbIoctl()
// SMB_COM_IOCTL 0x27
// SMB_COM_IOCTL_SECONDARY 0x28
//

typedef struct _REQ_IOCTL {
    UCHAR WordCount;                    // Count of parameter words = 14
    _USHORT( Fid );                     // File handle
    _USHORT( Category );                // Device category
    _USHORT( Function );                // Device function
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( MaxParameterCount );       // Max parameter bytes to return
    _USHORT( MaxDataCount );            // Max data bytes to return
    _ULONG( Timeout );
    _USHORT( Reserved );
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[];                     //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} REQ_IOCTL;
typedef REQ_IOCTL SMB_UNALIGNED *PREQ_IOCTL;

typedef struct _RESP_IOCTL_INTERIM {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_IOCTL_INTERIM;
typedef RESP_IOCTL_INTERIM SMB_UNALIGNED *PRESP_IOCTL_INTERIM;

typedef struct _REQ_IOCTL_SECONDARY {
    UCHAR WordCount;                    // Count of parameter words = 8
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( ParameterDisplacement );   // Displacement of these param bytes
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( DataDisplacement );        // Displacement of these data bytes
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[];                     //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} REQ_IOCTL_SECONDARY;
typedef REQ_IOCTL_SECONDARY SMB_UNALIGNED *PREQ_IOCTL_SECONDARY;

typedef struct _RESP_IOCTL {
    UCHAR WordCount;                    // Count of parameter words = 8
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( ParameterDisplacement );   // Displacement of these param bytes
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( DataDisplacement );        // Displacement of these data bytes
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[];                     //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} RESP_IOCTL;
typedef RESP_IOCTL SMB_UNALIGNED *PRESP_IOCTL;

#endif // def INCLUDE_SMB_TRANSACTION

#ifdef INCLUDE_SMB_LOCK

//
// Lock Byte Range SMB, see #1 page 20
// Function is SrvSmbLockByteRange()
// SMB_COM_LOCK_BYTE_RANGE 0x0C
//

typedef struct _REQ_LOCK_BYTE_RANGE {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( Fid );                     // File handle
    _ULONG( Count );                    // Count of bytes to lock
    _ULONG( Offset );                   // Offset from start of file
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_LOCK_BYTE_RANGE;
typedef REQ_LOCK_BYTE_RANGE SMB_UNALIGNED *PREQ_LOCK_BYTE_RANGE;

typedef struct _RESP_LOCK_BYTE_RANGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_LOCK_BYTE_RANGE;
typedef RESP_LOCK_BYTE_RANGE SMB_UNALIGNED *PRESP_LOCK_BYTE_RANGE;

#endif // def INCLUDE_SMB_LOCK

#ifdef INCLUDE_SMB_LOCK

//
// Locking and X SMB, see #2 page 46
// Function is SrvLockingAndX()
// SMB_COM_LOCKING_ANDX 0x24
//

typedef struct _REQ_LOCKING_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 8
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle

    //
    // When NT protocol is not negotiated the OplockLevel field is
    // omitted, and LockType field is a full word.  Since the upper
    // bits of LockType are never used, this definition works for
    // all protocols.
    //

    UCHAR( LockType );                  // Locking mode:
                                        //  bit 0: 0 = lock out all access
                                        //         1 = read OK while locked
                                        //  bit 1: 1 = 1 user total file unlock
    UCHAR( OplockLevel );               // The new oplock level
    _ULONG( Timeout );
    _USHORT( NumberOfUnlocks );         // Num. unlock range structs following
    _USHORT( NumberOfLocks );           // Num. lock range structs following
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //LOCKING_ANDX_RANGE Unlocks[];     //  Unlock ranges
    //LOCKING_ANDX_RANGE Locks[];       //  Lock ranges
} REQ_LOCKING_ANDX;
typedef REQ_LOCKING_ANDX SMB_UNALIGNED *PREQ_LOCKING_ANDX;

#define LOCKING_ANDX_SHARED_LOCK     0x01
#define LOCKING_ANDX_OPLOCK_RELEASE  0x02
#define LOCKING_ANDX_CHANGE_LOCKTYPE 0x04
#define LOCKING_ANDX_CANCEL_LOCK     0x08
#define LOCKING_ANDX_LARGE_FILES     0x10

#define OPLOCK_BROKEN_TO_NONE        0
#define OPLOCK_BROKEN_TO_II          1

typedef struct _LOCKING_ANDX_RANGE {
    _USHORT( Pid );                     // PID of process "owning" lock
    _ULONG( Offset );                   // Ofset to bytes to [un]lock
    _ULONG( Length );                   // Number of bytes to [un]lock
} LOCKING_ANDX_RANGE;
typedef LOCKING_ANDX_RANGE SMB_UNALIGNED *PLOCKING_ANDX_RANGE;

typedef struct _NT_LOCKING_ANDX_RANGE {
    _USHORT( Pid );                     // PID of process "owning" lock
    _USHORT( Pad );                     // Pad to DWORD align (mbz)
    _ULONG( OffsetHigh );               // Ofset to bytes to [un]lock (high)
    _ULONG( OffsetLow );                // Ofset to bytes to [un]lock (low)
    _ULONG( LengthHigh );               // Number of bytes to [un]lock (high)
    _ULONG( LengthLow );                // Number of bytes to [un]lock (low)
} NTLOCKING_ANDX_RANGE;
typedef NTLOCKING_ANDX_RANGE SMB_UNALIGNED *PNTLOCKING_ANDX_RANGE;
                                        //
typedef struct _RESP_LOCKING_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 2
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_LOCKING_ANDX;
typedef RESP_LOCKING_ANDX SMB_UNALIGNED *PRESP_LOCKING_ANDX;

#define LOCK_BROKEN_SIZE 51             // # of bytes in lock broken notify

#endif // def INCLUDE_SMB_LOCK

#ifdef INCLUDE_SMB_ADMIN

//
// Logoff and X SMB, see #3, page 55
// SMB_COM_LOGOFF_ANDX 0x74
//

typedef struct _REQ_LOGOFF_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 2
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_LOGOFF_ANDX;
typedef REQ_LOGOFF_ANDX SMB_UNALIGNED *PREQ_LOGOFF_ANDX;

typedef struct _RESP_LOGOFF_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 2
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_LOGOFF_ANDX;
typedef RESP_LOGOFF_ANDX SMB_UNALIGNED *PRESP_LOGOFF_ANDX;

#endif // def INCLUDE_SMB_ADMIN

#ifdef INCLUDE_SMB_FILE_CONTROL

//
// Move SMB, see #2 page 49
// Funcion is SrvSmbMove()
// SMB_COM_MOVE 0x2A
//

typedef struct _REQ_MOVE {
    UCHAR WordCount;                    // Count of parameter words = 3
    _USHORT( Tid2 );                    // Second (target) file id
    _USHORT( OpenFunction );            // what to do if target file exists
    _USHORT( Flags );                   // Flags to control move operations:
                                        //  0 - target must be a file
                                        //  1 - target must be a directory
                                        //  2 - reserved (must be 0)
                                        //  3 - reserved (must be 0)
                                        //  4 - verify all writes
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR OldFileName[];              //  Old file name
    //UCHAR NewFileName[];              //  New file name
} REQ_MOVE;
typedef REQ_MOVE SMB_UNALIGNED *PREQ_MOVE;

typedef struct _RESP_MOVE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Number of files moved
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Pathname of file where error occurred
} RESP_MOVE;
typedef RESP_MOVE SMB_UNALIGNED *PRESP_MOVE;

#endif // def INCLUDE_SMB_FILE_CONTROL

#ifdef INCLUDE_SMB_ADMIN

//
// Negotiate SMB's for Net 1 and Net 3, see #1 page 25 and #2 page 20
// Function is SrvSmbNegotiate()
// SMB_COM_NEGOTIATE 0x72
//

typedef struct _REQ_NEGOTIATE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //struct {
    //  UCHAR BufferFormat;             //  0x02 -- Dialect
    //  UCHAR DialectName[];            //  ASCIIZ
    //} Dialects[];
} REQ_NEGOTIATE;
typedef REQ_NEGOTIATE *PREQ_NEGOTIATE;  // *** NOT SMB_UNALIGNED!

typedef struct _RESP_NEGOTIATE {
    UCHAR WordCount;                    // Count of parameter words = 13
    _USHORT( DialectIndex );            // Index of selected dialect
    _USHORT( SecurityMode );            // Security mode:
                                        //  bit 0: 0 = share, 1 = user
                                        //  bit 1: 1 = encrypt passwords
                                        //  bit 2: 1 = SMB security signatures enabled
                                        //  bit 3: 1 = SMB security signatures required
    _USHORT( MaxBufferSize );           // Max transmit buffer size
    _USHORT( MaxMpxCount );             // Max pending multiplexed requests
    _USHORT( MaxNumberVcs );            // Max VCs between client and server
    _USHORT( RawMode );                 // Raw modes supported:
                                        //  bit 0: 1 = Read Raw supported
                                        //  bit 1: 1 = Write Raw supported
    _ULONG( SessionKey );
    SMB_TIME ServerTime;                // Current time at server
    SMB_DATE ServerDate;                // Current date at server
    _USHORT( ServerTimeZone );          // Current time zone at server
    _USHORT( EncryptionKeyLength );     // MBZ if this is not LM2.1
    _USHORT( Reserved );                // MBZ
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Password encryption key
    //UCHAR EncryptionKey[];            // The challenge encryption key
    //UCHAR PrimaryDomain[];            // The server's primary domain (2.1 only)
} RESP_NEGOTIATE;
typedef RESP_NEGOTIATE *PRESP_NEGOTIATE;    // *** NOT SMB_UNALIGNED!

// Macros for SecurityMode field, above
#define NEGOTIATE_USER_SECURITY                     0x01
#define NEGOTIATE_ENCRYPT_PASSWORDS                 0x02
#define NEGOTIATE_SECURITY_SIGNATURES_ENABLED       0x04
#define NEGOTIATE_SECURITY_SIGNATURES_REQUIRED      0x08

// Macros for RawMode field, above
#define NEGOTIATE_READ_RAW_SUPPORTED    1
#define NEGOTIATE_WRITE_RAW_SUPPORTED   2

typedef struct _RESP_OLD_NEGOTIATE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( DialectIndex );            // Index of selected dialect
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_OLD_NEGOTIATE;
typedef RESP_OLD_NEGOTIATE *PRESP_OLD_NEGOTIATE;    // *** NOT SMB_UNALIGNED!

typedef struct _RESP_NT_NEGOTIATE {
    UCHAR WordCount;                    // Count of parameter words = 17
    _USHORT( DialectIndex );            // Index of selected dialect
    UCHAR( SecurityMode );              // Security mode:
                                        //  bit 0: 0 = share, 1 = user
                                        //  bit 1: 1 = encrypt passwords
                                        //  bit 2: 1 = SMB sequence numbers enabled
                                        //  bit 3: 1 = SMB sequence numbers required
    _USHORT( MaxMpxCount );             // Max pending multiplexed requests
    _USHORT( MaxNumberVcs );            // Max VCs between client and server
    _ULONG( MaxBufferSize );            // Max transmit buffer size
    _ULONG( MaxRawSize );               // Maximum raw buffer size
    _ULONG( SessionKey );
    _ULONG( Capabilities );             // Server capabilities
    _ULONG( SystemTimeLow );            // System (UTC) time of the server (low).
    _ULONG( SystemTimeHigh );           // System (UTC) time of the server (high).
    _USHORT( ServerTimeZone );          // Time zone of server (min from UTC)
    UCHAR( EncryptionKeyLength );       // Length of encryption key.
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Password encryption key
    //UCHAR EncryptionKey[];            // The challenge encryption key
    //UCHAR OemDomainName[];            // The name of the domain (in OEM chars)
} RESP_NT_NEGOTIATE;
typedef RESP_NT_NEGOTIATE *PRESP_NT_NEGOTIATE;  // *** NOT SMB_UNALIGNED!

#endif // def INCLUDE_SMB_ADMIN

//
// Server / workstation capabilities
// N.B. Most messages use a ULONG for this, so there are many more
// bits available.
//

#define CAP_RAW_MODE            0x0001
#define CAP_MPX_MODE            0x0002
#define CAP_UNICODE             0x0004
#define CAP_LARGE_FILES         0x0008
#define CAP_NT_SMBS             0x0010
#define CAP_RPC_REMOTE_APIS     0x0020
#define CAP_NT_STATUS           0x0040
#define CAP_LEVEL_II_OPLOCKS    0x0080
#define CAP_LOCK_AND_READ       0x0100
#define CAP_NT_FIND             0x0200
#define CAP_DFS                 0x1000       // This server is DFS aware
#define CAP_INFOLEVEL_PASSTHRU  0x2000       // NT information level requests can pass through
#define CAP_LARGE_READX         0x4000       // Server supports oversized READ&X on files
#define CAP_LARGE_WRITEX        0x8000

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Open SMB, see #1, page 7
// Function is SrvSmbOpen()
// SMB_COM_OPEN 0x02
//

typedef struct _REQ_OPEN {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( DesiredAccess );           // Mode - read/write/share
    _USHORT( SearchAttributes );
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name
} REQ_OPEN;
typedef REQ_OPEN SMB_UNALIGNED *PREQ_OPEN;

typedef struct _RESP_OPEN {
    UCHAR WordCount;                    // Count of parameter words = 7
    _USHORT( Fid );                     // File handle
    _USHORT( FileAttributes );
    _ULONG( LastWriteTimeInSeconds );
    _ULONG( DataSize );                 // File size
    _USHORT( GrantedAccess );           // Access allowed
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_OPEN;
typedef RESP_OPEN SMB_UNALIGNED *PRESP_OPEN;

#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Open and X SMB, see #2 page 51
// Function is SrvOpenAndX()
// SMB_COM_OPEN_ANDX 0x2D
//

typedef struct _REQ_OPEN_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 15
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Flags );                   // Additional information: bit set-
                                        //  0 - return additional info
                                        //  1 - set single user total file lock
                                        //  2 - server notifies consumer of
                                        //      actions which may change file
                                        //  4 - return extended response
    _USHORT( DesiredAccess );           // File open mode
    _USHORT( SearchAttributes );
    _USHORT( FileAttributes );
    _ULONG( CreationTimeInSeconds );
    _USHORT( OpenFunction );
    _ULONG( AllocationSize );           // Bytes to reserve on create or truncate
    _ULONG( Timeout );                  // Max milliseconds to wait for resource
    _ULONG( Reserved );                 // Reserved (must be 0)
    _USHORT( ByteCount );               // Count of data bytes; min = 1
    UCHAR Buffer[1];                    // File name
} REQ_OPEN_ANDX;
typedef REQ_OPEN_ANDX SMB_UNALIGNED *PREQ_OPEN_ANDX;

typedef struct _RESP_OPEN_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 15
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle
    _USHORT( FileAttributes );
    _ULONG( LastWriteTimeInSeconds );
    _ULONG( DataSize );                 // Current file size
    _USHORT( GrantedAccess );           // Access permissions actually allowed
    _USHORT( FileType );
    _USHORT( DeviceState );             // state of IPC device (e.g. pipe)
    _USHORT( Action );                  // Action taken
    _ULONG( ServerFid );                // Server unique file id
    _USHORT( Reserved );                // Reserved (must be 0)
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_OPEN_ANDX;
typedef RESP_OPEN_ANDX SMB_UNALIGNED *PRESP_OPEN_ANDX;

typedef struct _REQ_NT_CREATE_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 24
    UCHAR AndXCommand;                  // Secondary command; 0xFF = None
    UCHAR AndXReserved;                 // MBZ
    _USHORT( AndXOffset );              // Offset to next command wordcount
    UCHAR Reserved;                     // MBZ
    _USHORT( NameLength );              // Length of Name[] in bytes
    _ULONG( Flags );                    // Create flags
    _ULONG( RootDirectoryFid );         // If non-zero, open is relative to this directory
    ACCESS_MASK DesiredAccess;          // NT access desired
    LARGE_INTEGER AllocationSize;       // Initial allocation size
    _ULONG( FileAttributes );           // File attributes for creation
    _ULONG( ShareAccess );              // Type of share access
    _ULONG( CreateDisposition );        // Action to take if file exists or not
    _ULONG( CreateOptions );            // Options to use if creating a file
    _ULONG( ImpersonationLevel );       // Security QOS information
    UCHAR SecurityFlags;                // Security QOS information
    _USHORT( ByteCount );               // Length of byte parameters
    UCHAR Buffer[1];
    //UCHAR Name[];                       // File to open or create
} REQ_NT_CREATE_ANDX;
typedef REQ_NT_CREATE_ANDX SMB_UNALIGNED *PREQ_NT_CREATE_ANDX;

// Flag bit for Security flags

#define SMB_SECURITY_DYNAMIC_TRACKING   0x01
#define SMB_SECURITY_EFFECTIVE_ONLY     0x02

typedef struct _RESP_NT_CREATE_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 26
    UCHAR AndXCommand;                  // Secondary command; 0xFF = None
    UCHAR AndXReserved;                 // MBZ
    _USHORT( AndXOffset );              // Offset to next command wordcount
    UCHAR OplockLevel;                  // The oplock level granted
    _USHORT( Fid );                     // The file ID
    _ULONG( CreateAction );             // The action taken
    TIME CreationTime;                  // The time the file was created
    TIME LastAccessTime;                // The time the file was accessed
    TIME LastWriteTime;                 // The time the file was last written
    TIME ChangeTime;                    // The time the file was last changed
    _ULONG( FileAttributes );           // The file attributes
    LARGE_INTEGER AllocationSize;       // The number of byes allocated
    LARGE_INTEGER EndOfFile;            // The end of file offset
    _USHORT( FileType );
    union {
        _USHORT( DeviceState );         // state of IPC device (e.g. pipe)
        _USHORT( FileStatusFlags );     // if a file or directory.  See below.
    };
    BOOLEAN Directory;                  // TRUE if this is a directory
    _USHORT( ByteCount );               // = 0
    UCHAR Buffer[1];
} RESP_NT_CREATE_ANDX;
typedef RESP_NT_CREATE_ANDX SMB_UNALIGNED *PRESP_NT_CREATE_ANDX;

//
// Values for FileStatusFlags, if the opened resource is a file or directory
//
#define SMB_FSF_NO_EAS          0x0001   // file/dir has no extended attributes
#define SMB_FSF_NO_SUBSTREAMS   0x0002   // file/dir has no substreams
#define SMB_FSF_NO_REPARSETAG   0x0004   // file/dir is not a reparse point


#define SMB_OPLOCK_LEVEL_NONE       0
#define SMB_OPLOCK_LEVEL_EXCLUSIVE  1
#define SMB_OPLOCK_LEVEL_BATCH      2
#define SMB_OPLOCK_LEVEL_II         3

#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_PRINT

//
// Open Print File SMB, see #1 page 27
// Function is SrvSmbOpenPrintFile()
// SMB_COM_OPEN_PRINT_FILE 0xC0
//

typedef struct _REQ_OPEN_PRINT_FILE {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( SetupLength );             // Length of printer setup data
    _USHORT( Mode );                    // 0 = Text mode (DOS expands TABs)
                                        // 1 = Graphics mode
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR IdentifierString[];         //  Identifier string
} REQ_OPEN_PRINT_FILE;
typedef REQ_OPEN_PRINT_FILE SMB_UNALIGNED *PREQ_OPEN_PRINT_FILE;

typedef struct _RESP_OPEN_PRINT_FILE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_OPEN_PRINT_FILE;
typedef RESP_OPEN_PRINT_FILE SMB_UNALIGNED *PRESP_OPEN_PRINT_FILE;

#endif // def INCLUDE_SMB_PRINT

#ifdef INCLUDE_SMB_ADMIN

//
// Process Exit SMB, see #1 page 22
// Function is SrvSmbProcessExit()
// SMB_COM_PROCESS_EXIT 0x11
//

typedef struct _REQ_PROCESS_EXIT {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_PROCESS_EXIT;
typedef REQ_PROCESS_EXIT SMB_UNALIGNED *PREQ_PROCESS_EXIT;

typedef struct _RESP_PROCESS_EXIT {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_PROCESS_EXIT;
typedef RESP_PROCESS_EXIT SMB_UNALIGNED *PRESP_PROCESS_EXIT;

#endif // def INCLUDE_SMB_ADMIN

#ifdef INCLUDE_SMB_QUERY_SET

//
// Query Information SMB, see #1 page 18
// Function is SrvSmbQueryInformation()
// SMB_COM_QUERY_INFORMATION 0x08
//

typedef struct _REQ_QUERY_INFORMATION {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name
} REQ_QUERY_INFORMATION;
typedef REQ_QUERY_INFORMATION SMB_UNALIGNED *PREQ_QUERY_INFORMATION;

typedef struct _RESP_QUERY_INFORMATION {
    UCHAR WordCount;                    // Count of parameter words = 10
    _USHORT( FileAttributes );
    _ULONG( LastWriteTimeInSeconds );
    _ULONG( FileSize );                 // File size
    _USHORT( Reserved )[5];             // Reserved (must be 0)
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_QUERY_INFORMATION;
typedef RESP_QUERY_INFORMATION SMB_UNALIGNED *PRESP_QUERY_INFORMATION;

#endif // def INCLUDE_SMB_QUERY_SET

#ifdef INCLUDE_SMB_QUERY_SET

//
// Query Information2 SMB, see #2 page 37
// Function is SrvSmbQueryInformation2()
// SMB_COM_QUERY_INFORMATION2 0x23
//

typedef struct _REQ_QUERY_INFORMATION2 {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_QUERY_INFORMATION2;
typedef REQ_QUERY_INFORMATION2 SMB_UNALIGNED *PREQ_QUERY_INFORMATION2;

typedef struct _RESP_QUERY_INFORMATION2 {
    UCHAR WordCount;                    // Count of parameter words = 11
    SMB_DATE CreationDate;
    SMB_TIME CreationTime;
    SMB_DATE LastAccessDate;
    SMB_TIME LastAccessTime;
    SMB_DATE LastWriteDate;
    SMB_TIME LastWriteTime;
    _ULONG( FileDataSize );             // File end of data
    _ULONG( FileAllocationSize );       // File allocation size
    _USHORT( FileAttributes );
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Reserved buffer
} RESP_QUERY_INFORMATION2;
typedef RESP_QUERY_INFORMATION2 SMB_UNALIGNED *PRESP_QUERY_INFORMATION2;

#endif // def INCLUDE_SMB_QUERY_SET

#ifdef INCLUDE_SMB_MISC

//
// Query Information Disk SMB, see #1 page 24
// Function is SrvSmbQueryInformationDisk()
// SMB_COM_QUERY_INFORMATION_DISK 0x80
//

typedef struct _REQ_QUERY_INFORMATION_DISK {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_QUERY_INFORMATION_DISK;
typedef REQ_QUERY_INFORMATION_DISK SMB_UNALIGNED *PREQ_QUERY_INFORMATION_DISK;

typedef struct _RESP_QUERY_INFORMATION_DISK {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( TotalUnits );              // Total allocation units per server
    _USHORT( BlocksPerUnit );           // Blocks per allocation unit
    _USHORT( BlockSize );               // Block size (in bytes)
    _USHORT( FreeUnits );               // Number of free units
    _USHORT( Reserved );                // Reserved (media identification code)
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_QUERY_INFORMATION_DISK;
typedef RESP_QUERY_INFORMATION_DISK SMB_UNALIGNED *PRESP_QUERY_INFORMATION_DISK;

#endif // def INCLUDE_SMB_MISC

#ifdef INCLUDE_SMB_MISC

//
// Query Server Information SMB, see #? page ??
// Function is SrvSmbQueryInformationServer
// SMB_COM_QUERY_INFORMATION_SRV 0x21
//

typedef struct _REQ_QUERY_INFORMATION_SRV {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Mode );
    _USHORT( ByteCount );               // Count of data bytes; min =
    UCHAR Buffer[1];                    //
} REQ_QUERY_INFORMATION_SRV;
typedef REQ_QUERY_INFORMATION_SRV SMB_UNALIGNED *PREQ_QUERY_INFORMATION_SRV;

typedef struct _RESP_QUERY_INFORMATION_SRV {
    UCHAR WordCount;                    // Count of parameter words = 20
    _ULONG( smb_fsid );
    _ULONG( BlocksPerUnit );
    _ULONG( smb_aunits );
    _ULONG( smb_fau );
    _USHORT( BlockSize );
    SMB_DATE smb_vldate;
    SMB_TIME smb_vltime;
    UCHAR smb_vllen;
    UCHAR Reserved;                     // Reserved (must be 0)
    _USHORT( SecurityMode );
    _USHORT( BlockMode );
    _ULONG( Services );
    _USHORT( MaxTransmitSize );
    _USHORT( MaxMpxCount );
    _USHORT( MaxNumberVcs );
    SMB_TIME ServerTime;
    SMB_DATE ServerDate;
    _USHORT( ServerTimeZone );
    _ULONG( Reserved2 );
    _USHORT( ByteCount );               // Count of data bytes; min =
    UCHAR Buffer[1];                    //
} RESP_QUERY_INFORMATION_SRV;
typedef RESP_QUERY_INFORMATION_SRV SMB_UNALIGNED *PRESP_QUERY_INFORMATION_SRV;

#endif // def INCLUDE_SMB_MISC

#ifdef INCLUDE_SMB_READ_WRITE

//
// Read SMB, see #1 page 12
// Lock and Read SMB, see #2 page 44
// SMB_COM_READ 0x0A, Function is SrvSmbRead
// SMB_COM_LOCK_AND_READ 0x13, Function is SrvSmbLockAndRead
//

typedef struct _REQ_READ {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Count of bytes being requested
    _ULONG( Offset );                   // Offset in file of first byte to read
    _USHORT( Remaining );               // Estimate of bytes to read if nonzero
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_READ;
typedef REQ_READ SMB_UNALIGNED *PREQ_READ;

//
// *** Warning: the following structure is defined the way it is to
//     ensure longword alignment of the data buffer.  (This only matters
//     when packing is disabled; when packing is turned on, the right
//     thing happens no matter what.)
//

typedef struct _RESP_READ {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( Count );                   // Count of bytes actually returned
    _USHORT( Reserved )[4];             // Reserved (must be 0)
    _USHORT( ByteCount );               // Count of data bytes
    //UCHAR Buffer[1];                  // Buffer containing:
      UCHAR BufferFormat;               //  0x01 -- Data block
      _USHORT( DataLength );            //  Length of data
      ULONG Buffer[1];                  //  Data
} RESP_READ;
typedef RESP_READ SMB_UNALIGNED *PRESP_READ;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_READ_WRITE

//
// Read and X SMB, see #2 page 56
// Function is SrvSmbReadAndX()
// SMB_COM_READ_ANDX 0x2E
//

typedef struct _REQ_READ_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 10
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin read
    _USHORT( MaxCount );                // Max number of bytes to return
    _USHORT( MinCount );                // Min number of bytes to return
    _ULONG( Timeout );
    _USHORT( Remaining );               // Bytes remaining to satisfy request
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_READ_ANDX;
typedef REQ_READ_ANDX SMB_UNALIGNED *PREQ_READ_ANDX;

typedef struct _REQ_NT_READ_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 12
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin read
    _USHORT( MaxCount );                // Max number of bytes to return
    _USHORT( MinCount );                // Min number of bytes to return
    union {
        _ULONG( Timeout );
        _USHORT( MaxCountHigh );        // upper 16 bits of MaxCount if NT request
    };
    _USHORT( Remaining );               // Bytes remaining to satisfy request
    _ULONG( OffsetHigh );               // Used for NT Protocol only
                                        // Upper 32 bits of offset
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_NT_READ_ANDX;
typedef REQ_NT_READ_ANDX SMB_UNALIGNED *PREQ_NT_READ_ANDX;

typedef struct _RESP_READ_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 12
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Remaining );               // Bytes remaining to be read
    _USHORT( DataCompactionMode );
    _USHORT( Reserved );                // Reserved (must be 0)
    _USHORT( DataLength );              // Number of data bytes (min = 0)
    _USHORT( DataOffset );              // Offset (from header start) to data
    union {
        _USHORT( Reserved2 );           // Reserved (must be 0)
        _USHORT( DataLengthHigh );      // upper 16 bits of DataLength if NT request
    };
    _ULONG( Reserved3 )[2];             // Reserved (must be 0)
    _USHORT( ByteCount );               // Count of data bytes.  Inaccurate if we
                                        //   are doing large Read&X's!
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (size = DataLength)
} RESP_READ_ANDX;
typedef RESP_READ_ANDX SMB_UNALIGNED *PRESP_READ_ANDX;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_MPX

//
// Read Block Multiplexed SMB, see #2 page 58
// Function is SrvSmbReadMpx()
// SMB_COM_READ_MPX 0x1B
// SMB_COM_READ_MPX_SECONDARY 0x1C
//

typedef struct _REQ_READ_MPX {
    UCHAR WordCount;                    // Count of parameter words = 8
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin read
    _USHORT( MaxCount );                // Max bytes to return (max 65535)
    _USHORT( MinCount );                // Min bytes to return (normally 0)
    _ULONG( Timeout );
    _USHORT( Reserved );
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_READ_MPX;
typedef REQ_READ_MPX SMB_UNALIGNED *PREQ_READ_MPX;

typedef struct _RESP_READ_MPX {
    UCHAR WordCount;                    // Count of parameter words = 8
    _ULONG( Offset );                   // Offset in file where data read
    _USHORT( Count );                   // Total bytes being returned
    _USHORT( Remaining );               // Bytes remaining to be read (pipe/dev)
    _USHORT( DataCompactionMode );
    _USHORT( Reserved );
    _USHORT( DataLength );              // Number of data bytes this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (size = DataLength)
} RESP_READ_MPX;
typedef RESP_READ_MPX SMB_UNALIGNED *PRESP_READ_MPX;

#endif // def INCLUDE_SMB_MPX

#ifdef INCLUDE_SMB_RAW

//
// Read Block Raw SMB, see #2 page 61
// Function is SrvSmbReadRaw()
// SMB_COM_READ_RAW 0x1A
//

typedef struct _REQ_READ_RAW {
    UCHAR WordCount;                    // Count of parameter words = 8
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin read
    _USHORT( MaxCount );                // Max bytes to return (max 65535)
    _USHORT( MinCount );                // Min bytes to return (normally 0)
    _ULONG( Timeout );
    _USHORT( Reserved );
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_READ_RAW;
typedef REQ_READ_RAW SMB_UNALIGNED *PREQ_READ_RAW;

typedef struct _REQ_NT_READ_RAW {
    UCHAR WordCount;                    // Count of parameter words = 10
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin read
    _USHORT( MaxCount );                // Max bytes to return (max 65535)
    _USHORT( MinCount );                // Min bytes to return (normally 0)
    _ULONG( Timeout );
    _USHORT( Reserved );
    _ULONG( OffsetHigh );               // Used for NT Protocol only
                                        // Upper 32 bits of offset
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_NT_READ_RAW;
typedef REQ_NT_READ_RAW SMB_UNALIGNED *PREQ_NT_READ_RAW;

// No response params for raw read--the response is the raw data.

#endif // def INCLUDE_SMB_RAW

#ifdef INCLUDE_SMB_FILE_CONTROL

//
// Rename SMB, see #1 page 17
// Function is SrvSmbRename()
// SMB_COM_RENAME 0x07
//

typedef struct _REQ_RENAME {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( SearchAttributes );
    _USHORT( ByteCount );               // Count of data bytes; min = 4
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR OldFileName[];              //  Old file name
    //UCHAR BufferFormat2;              //  0x04 -- ASCII
    //UCHAR NewFileName[];              //  New file name
} REQ_RENAME;
typedef REQ_RENAME SMB_UNALIGNED *PREQ_RENAME;


//
// Extended NT rename SMB
// Function is SrvSmbRename()
// SMB_COM_NT_RENAME 0xA5
//

typedef struct _REQ_NTRENAME {
    UCHAR WordCount;                    // Count of parameter words = 4
    _USHORT( SearchAttributes );
    _USHORT( InformationLevel );
    _ULONG( ClusterCount );
    _USHORT( ByteCount );               // Count of data bytes; min = 4
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR OldFileName[];              //  Old file name
    //UCHAR BufferFormat2;              //  0x04 -- ASCII
    //UCHAR NewFileName[];              //  New file name
} REQ_NTRENAME;
typedef REQ_NTRENAME SMB_UNALIGNED *PREQ_NTRENAME;

typedef struct _RESP_RENAME {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_RENAME;
typedef RESP_RENAME SMB_UNALIGNED *PRESP_RENAME;

#endif // def INCLUDE_SMB_FILE_CONTROL

#ifdef INCLUDE_SMB_SEARCH

//
// Search SMBs.  One structure is common for both the core Search and the
// LAN Manager 1.0 Find First/Next/Close.
//
// Function is SrvSmbSearch()
//
// Search, see #1 page 26
//      SMB_COM_SEARCH 0x81
// FindFirst and FindNext, see #2 page 27
//      SMB_COM_FIND 0x82
// FindUnique, see #2 page 33
//      SMB_COM_FIND_UNIQUE 0x83
// FindClose, see #2 page 31
//      SMB_COM_FIND_CLOSE 0x84
//

typedef struct _REQ_SEARCH {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( MaxCount );                // Number of dir. entries to return
    _USHORT( SearchAttributes );
    _USHORT( ByteCount );               // Count of data bytes; min = 5
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name, may be null
    //UCHAR BufferFormat2;              //  0x05 -- Variable block
    //USHORT ResumeKeyLength;           //  Length of resume key, may be 0
    //UCHAR SearchStatus[];             //  Resume key
} REQ_SEARCH;
typedef REQ_SEARCH SMB_UNALIGNED *PREQ_SEARCH;

typedef struct _RESP_SEARCH {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Number of entries returned
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x05 -- Variable block
    //USHORT DataLength;                //  Length of data
    //UCHAR Data[];                     //  Data
} RESP_SEARCH;
typedef RESP_SEARCH SMB_UNALIGNED *PRESP_SEARCH;

//
// These two structures are use to return information in the Search SMBs.
// SMB_DIRECTORY_INFORMATION is used to return information about a file
// that was found.  In addition to the usual information about the file,
// each of these structures contains an SMB_RESUME_KEY, which is used to
// continue or rewind a search.
//
// These structures must be packed, so turn on packing if it isn't
// already on.
//

#ifdef NO_PACKING
#include <packon.h>
#endif // def NO_PACKING

typedef struct _SMB_RESUME_KEY {
    UCHAR Reserved;                     // bit 7 - comsumer use
                                        // bits 5,6 - system use (must preserve)
                                        // bits 0-4 - server use (must preserve)
    UCHAR FileName[11];
    UCHAR Sid;                          // Uniquely identifies Find through Close
    _ULONG( FileIndex );                // Reserved for server use
    UCHAR Consumer[4];                  // Reserved for comsumer use
} SMB_RESUME_KEY;
typedef SMB_RESUME_KEY SMB_UNALIGNED *PSMB_RESUME_KEY;

typedef struct _SMB_DIRECTORY_INFORMATION {
    SMB_RESUME_KEY ResumeKey;
    UCHAR FileAttributes;
    SMB_TIME LastWriteTime;
    SMB_DATE LastWriteDate;
    _ULONG( FileSize );
    UCHAR FileName[13];                 // ASCII, space-filled null terminated
} SMB_DIRECTORY_INFORMATION;
typedef SMB_DIRECTORY_INFORMATION SMB_UNALIGNED *PSMB_DIRECTORY_INFORMATION;

#ifdef NO_PACKING
#include <packoff.h>
#endif // def NO_PACKING

#endif // def INCLUDE_SMB_SEARCH

#ifdef INCLUDE_SMB_READ_WRITE

//
// Seek SMB, see #1 page 14
// Function is SrvSmbSeek
// SMB_COM_SEEK 0x12
//

typedef struct _REQ_SEEK {
    UCHAR WordCount;                    // Count of parameter words = 4
    _USHORT( Fid );                     // File handle
    _USHORT( Mode );                    // Seek mode:
                                        //  0 = from start of file
                                        //  1 = from current position
                                        //  2 = from end of file
    _ULONG( Offset );                   // Relative offset
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_SEEK;
typedef REQ_SEEK SMB_UNALIGNED *PREQ_SEEK;

typedef struct _RESP_SEEK {
    UCHAR WordCount;                    // Count of parameter words = 2
    _ULONG( Offset );                   // Offset from start of file
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SEEK;
typedef RESP_SEEK SMB_UNALIGNED *PRESP_SEEK;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_MESSAGE

//
// Send Broadcast Message SMB, see #1 page 32
// Function is SrvSmbSendBroadcastMessage()
// SMB_COM_SEND_BROADCAST_MESSAGE 0xD1
//

typedef struct _REQ_SEND_BROADCAST_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 8
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR OriginatorName[];           //  Originator name (max = 15)
    //UCHAR BufferFormat2;              //  0x04 -- ASCII
    //UCHAR DestinationName[];          //  "*"
    //UCHAR BufferFormat3;              //  0x01 -- Data block
    //USHORT DataLength;                //  Length of message; max = 128
    //UCHAR Data[];                     //  Message
} REQ_SEND_BROADCAST_MESSAGE;
typedef REQ_SEND_BROADCAST_MESSAGE SMB_UNALIGNED *PREQ_SEND_BROADCAST_MESSAGE;

// No response for Send Broadcast Message

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_MESSAGE

//
// Send End of Multi-block Message SMB, see #1 page 33
// Function is SrvSmbSendEndMbMessage()
// SMB_COM_SEND_END_MB_MESSAGE 0xD6
//

typedef struct _REQ_SEND_END_MB_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( MessageGroupId );
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_SEND_END_MB_MESSAGE;
typedef REQ_SEND_END_MB_MESSAGE SMB_UNALIGNED *PREQ_SEND_END_MB_MESSAGE;

typedef struct _RESP_SEND_END_MB_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SEND_END_MB_MESSAGE;
typedef RESP_SEND_END_MB_MESSAGE SMB_UNALIGNED *PRESP_SEND_END_MB_MESSAGE;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_MESSAGE

//
// Send Single Block Message SMB, see #1 page 31
// Function is SrvSmbSendMessage()
// SMB_COM_SEND_MESSAGE 0xD0
//

typedef struct _REQ_SEND_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 7
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR OriginatorName[];           //  Originator name (max = 15)
    //UCHAR BufferFormat2;              //  0x04 -- ASCII
    //UCHAR DestinationName[];          //  Destination name (max = 15)
    //UCHAR BufferFormat3;              //  0x01 -- Data block
    //USHORT DataLength;                //  Length of message; max = 128
    //UCHAR Data[];                     //  Message
} REQ_SEND_MESSAGE;
typedef REQ_SEND_MESSAGE SMB_UNALIGNED *PREQ_SEND_MESSAGE;

typedef struct _RESP_SEND_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SEND_MESSAGE;
typedef RESP_SEND_MESSAGE SMB_UNALIGNED *PRESP_SEND_MESSAGE;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_MESSAGE

//
// Send Start of Multi-block Message SMB, see #1 page 32
// Function is SrvSmbSendStartMbMessage()
// SMB_COM_SEND_START_MB_MESSAGE 0xD5
//

typedef struct _REQ_SEND_START_MB_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR OriginatorName[];           //  Originator name (max = 15)
    //UCHAR BufferFormat2;              //  0x04 -- ASCII
    //UCHAR DestinationName[];          //  Destination name (max = 15)
} REQ_SEND_START_MB_MESSAGE;
typedef REQ_SEND_START_MB_MESSAGE SMB_UNALIGNED *PREQ_SEND_START_MB_MESSAGE;

typedef struct _RESP_SEND_START_MB_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( MessageGroupId );
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SEND_START_MB_MESSAGE;
typedef RESP_SEND_START_MB_MESSAGE SMB_UNALIGNED *PSEND_START_MB_MESSAGE;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_MESSAGE

//
// Send Text of Multi-block Message SMB, see #1 page 33
// Function is SrvSmbSendTextMbMessage()
// SMB_COM_SEND_TEXT_MB_MESSAGE 0xD7
//

typedef struct _REQ_SEND_TEXT_MB_MESSAGE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( MessageGroupId );
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x01 -- Data block
    //USHORT DataLength;                //  Length of message; max = 128
    //UCHAR Data[];                     //  Message
} REQ_SEND_TEXT_MB_MESSAGE;
typedef REQ_SEND_TEXT_MB_MESSAGE SMB_UNALIGNED *PREQ_SEND_TEXT_MB_MESSAGE;

typedef struct _RESP_SEND_TEXT_MB_MESSAGE {
    UCHAR WordCount;                    // Count of aprameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SEND_TEXT_MB_MESSAGE;
typedef RESP_SEND_TEXT_MB_MESSAGE SMB_UNALIGNED *PRESP_SEND_TEXT_MB_MESSAGE;

#endif // def INCLUDE_SMB_MESSAGE

#ifdef INCLUDE_SMB_ADMIN

//
// Session Setup and X SMB, see #2 page 63 and #3 page 10
// Function is SrvSmbSessionSetupAndX()
// SMB_COM_SESSION_SETUP_ANDX 0x73
//

typedef struct _REQ_SESSION_SETUP_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 10
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( MaxBufferSize );           // Consumer's maximum buffer size
    _USHORT( MaxMpxCount );             // Actual maximum multiplexed pending requests
    _USHORT( VcNumber );                // 0 = first (only), nonzero=additional VC number
    _ULONG( SessionKey );               // Session key (valid iff VcNumber != 0)
    _USHORT( PasswordLength );          // Account password size
    _ULONG( Reserved );
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR AccountPassword[];          //  Account Password
    //UCHAR AccountName[];              //  Account Name
    //UCHAR PrimaryDomain[];            //  Client's primary domain
    //UCHAR NativeOS[];                 //  Client's native operating system
    //UCHAR NativeLanMan[];             //  Client's native LAN Manager type
} REQ_SESSION_SETUP_ANDX;
typedef REQ_SESSION_SETUP_ANDX SMB_UNALIGNED *PREQ_SESSION_SETUP_ANDX;

typedef struct _REQ_NT_SESSION_SETUP_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 13
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( MaxBufferSize );           // Consumer's maximum buffer size
    _USHORT( MaxMpxCount );             // Actual maximum multiplexed pending requests
    _USHORT( VcNumber );                // 0 = first (only), nonzero=additional VC number
    _ULONG( SessionKey );               // Session key (valid iff VcNumber != 0)
    _USHORT( CaseInsensitivePasswordLength );      // Account password size, ANSI
    _USHORT( CaseSensitivePasswordLength );        // Account password size, Unicode
    _ULONG( Reserved);
    _ULONG( Capabilities );             // Client capabilities
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR CaseInsensitivePassword[];  //  Account Password, ANSI
    //UCHAR CaseSensitivePassword[];    //  Account Password, Unicode
    //UCHAR AccountName[];              //  Account Name
    //UCHAR PrimaryDomain[];            //  Client's primary domain
    //UCHAR NativeOS[];                 //  Client's native operating system
    //UCHAR NativeLanMan[];             //  Client's native LAN Manager type
} REQ_NT_SESSION_SETUP_ANDX;
typedef REQ_NT_SESSION_SETUP_ANDX SMB_UNALIGNED *PREQ_NT_SESSION_SETUP_ANDX;

//
// Action flags in the response
//
#define SMB_SETUP_GUEST          0x0001          // Session setup as a guest
#define SMB_SETUP_USE_LANMAN_KEY 0x0002          // Use the Lan Manager setup key.

typedef struct _RESP_SESSION_SETUP_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 3
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Action );                  // Request mode:
                                        //    bit0 = logged in as GUEST
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR NativeOS[];                 //  Server's native operating system
    //UCHAR NativeLanMan[];             //  Server's native LAN Manager type
    //UCHAR PrimaryDomain[];            //  Server's primary domain
} RESP_SESSION_SETUP_ANDX;
typedef RESP_SESSION_SETUP_ANDX SMB_UNALIGNED *PRESP_SESSION_SETUP_ANDX;

#endif // def INCLUDE_SMB_ADMIN

#ifdef INCLUDE_SMB_QUERY_SET

//
// Set Information SMB, see #1 page 19
// Function is SrvSmbSetInformation()
// SMB_COM_SET_INFORMATION 0x09
//

typedef struct _REQ_SET_INFORMATION {
    UCHAR WordCount;                    // Count of parameter words = 8
    _USHORT( FileAttributes );
    _ULONG( LastWriteTimeInSeconds );
    _USHORT( Reserved )[5];             // Reserved (must be 0)
    _USHORT( ByteCount );               // Count of data bytes; min = 2
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x04 -- ASCII
    //UCHAR FileName[];                 //  File name
} REQ_SET_INFORMATION;
typedef REQ_SET_INFORMATION SMB_UNALIGNED *PREQ_SET_INFORMATION;

typedef struct _RESP_SET_INFORMATION {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SET_INFORMATION;
typedef RESP_SET_INFORMATION SMB_UNALIGNED *PRESP_SET_INFORMATION;

#endif // def INCLUDE_SMB_QUERY_SET

#ifdef INCLUDE_SMB_QUERY_SET

//
// Set Information2 SMB, see #2 page 66
// Function is SrvSmbSetInformation2
// SMB_COM_SET_INFORMATION2 0x22
//

typedef struct _REQ_SET_INFORMATION2 {
    UCHAR WordCount;                    // Count of parameter words = 7
    _USHORT( Fid );                     // File handle
    SMB_DATE CreationDate;
    SMB_TIME CreationTime;
    SMB_DATE LastAccessDate;
    SMB_TIME LastAccessTime;
    SMB_DATE LastWriteDate;
    SMB_TIME LastWriteTime;
    _USHORT( ByteCount );               // Count of data bytes; min = 0
    UCHAR Buffer[1];                    // Reserved buffer
} REQ_SET_INFORMATION2;
typedef REQ_SET_INFORMATION2 SMB_UNALIGNED *PREQ_SET_INFORMATION2;

typedef struct _RESP_SET_INFORMATION2 {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_SET_INFORMATION2;
typedef RESP_SET_INFORMATION2 SMB_UNALIGNED *PRESP_SET_INFORMATION2;

#endif // def INCLUDE_SMB_QUERY_SET

#ifdef INCLUDE_SMB_TRANSACTION

//
// Transaction and Transaction2 SMBs, see #2 page 68 and #3 page 13
// Function is SrvSmbTransaction()
// SMB_COM_TRANSACTION 0x25
// SMB_COM_TRANSACTION_SECONDARY 0x26
// SMB_COM_TRANSACTION2 0x32
// SMB_COM_TRANSACTION2_SECONDARY 0x33
//
// Structures for specific transaction types are defined in smbtrans.h.
//
// *** The Transaction2 secondary request format includes a USHORT Fid
//     field that we ignore.  We can do this because the Fid field
//     occurs at the end of the word parameters part of the request, and
//     because the rest of the request (parameter and data bytes) is
//     pointed by offset fields occurring prior to the Fid field.  (The
//     Fid field was added to speed up dispatching in the OS/2 server,
//     in which different worker processes handle each Fid.  The NT
//     server has only one process.)
//

typedef struct _REQ_TRANSACTION {
    UCHAR WordCount;                    // Count of parameter words; value = (14 + SetupCount)
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( MaxParameterCount );       // Max parameter bytes to return
    _USHORT( MaxDataCount );            // Max data bytes to return
    UCHAR MaxSetupCount;                // Max setup words to return
    UCHAR Reserved;
    _USHORT( Flags );                   // Additional information:
                                        //  bit 0 - also disconnect TID in Tid
                                        //  bit 1 - one-way transacion (no resp)
    _ULONG( Timeout );
    _USHORT( Reserved2 );
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    UCHAR SetupCount;                   // Count of setup words
    UCHAR Reserved3;                    // Reserved (pad above to word)
    UCHAR Buffer[1];                    // Buffer containing:
    //USHORT Setup[];                   //  Setup words (# = SetupWordCount)
    //USHORT ByteCount;                 //  Count of data bytes
    //UCHAR Name[];                     //  Name of transaction (NULL if Transact2)
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[];                     //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} REQ_TRANSACTION;
typedef REQ_TRANSACTION SMB_UNALIGNED *PREQ_TRANSACTION;

#define SMB_TRANSACTION_DISCONNECT 1
#define SMB_TRANSACTION_NO_RESPONSE 2
#define SMB_TRANSACTION_RECONNECTING 4
#define SMB_TRANSACTION_DFSFILE 8

typedef struct _RESP_TRANSACTION_INTERIM {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_TRANSACTION_INTERIM;
typedef RESP_TRANSACTION_INTERIM SMB_UNALIGNED *PRESP_TRANSACTION_INTERIM;

typedef struct _REQ_TRANSACTION_SECONDARY {
    UCHAR WordCount;                    // Count of parameter words = 8
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( ParameterDisplacement );   // Displacement of these param bytes
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( DataDisplacement );        // Displacement of these data bytes
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[];                     //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} REQ_TRANSACTION_SECONDARY;
typedef REQ_TRANSACTION_SECONDARY SMB_UNALIGNED *PREQ_TRANSACTION_SECONDARY;

typedef struct _RESP_TRANSACTION {
    UCHAR WordCount;                    // Count of data bytes; value = 10 + SetupCount
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( Reserved );
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( ParameterDisplacement );   // Displacement of these param bytes
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( DataDisplacement );        // Displacement of these data bytes
    UCHAR SetupCount;                   // Count of setup words
    UCHAR Reserved2;                    // Reserved (pad above to word)
    UCHAR Buffer[1];                    // Buffer containing:
    //USHORT Setup[];                   //  Setup words (# = SetupWordCount)
    //USHORT ByteCount;                 //  Count of data bytes
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Parameters[];               //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[];                     //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} RESP_TRANSACTION;
typedef RESP_TRANSACTION SMB_UNALIGNED *PRESP_TRANSACTION;

typedef struct _REQ_NT_TRANSACTION {
    UCHAR WordCount;                    // Count of parameter words; value = (19 + SetupCount)
    UCHAR MaxSetupCount;                // Max setup words to return
    _USHORT( Flags );                   // Currently unused
    _ULONG( TotalParameterCount );      // Total parameter bytes being sent
    _ULONG( TotalDataCount );           // Total data bytes being sent
    _ULONG( MaxParameterCount );        // Max parameter bytes to return
    _ULONG( MaxDataCount );             // Max data bytes to return
    _ULONG( ParameterCount );           // Parameter bytes sent this buffer
    _ULONG( ParameterOffset );          // Offset (from header start) to params
    _ULONG( DataCount );                // Data bytes sent this buffer
    _ULONG( DataOffset );               // Offset (from header start) to data
    UCHAR SetupCount;                   // Count of setup words
    _USHORT( Function );                            // The transaction function code
    UCHAR Buffer[1];
    //USHORT Setup[];                   // Setup words (# = SetupWordCount)
    //USHORT ByteCount;                 // Count of data bytes
    //UCHAR Pad1[];                     // Pad to LONG
    //UCHAR Parameters[];               // Parameter bytes (# = ParameterCount)
    //UCHAR Pad2[];                     // Pad to LONG
    //UCHAR Data[];                     // Data bytes (# = DataCount)
} REQ_NT_TRANSACTION;
typedef REQ_NT_TRANSACTION SMB_UNALIGNED *PREQ_NT_TRANSACTION;

#define SMB_TRANSACTION_DISCONNECT 1
#define SMB_TRANSACTION_NO_RESPONSE 2

typedef struct _RESP_NT_TRANSACTION_INTERIM {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];
} RESP_NT_TRANSACTION_INTERIM;
typedef RESP_NT_TRANSACTION_INTERIM SMB_UNALIGNED *PRESP_NT_TRANSACTION_INTERIM;

typedef struct _REQ_NT_TRANSACTION_SECONDARY {
    UCHAR WordCount;                    // Count of parameter words = 18
    UCHAR Reserved1;                    // MBZ
    _USHORT( Reserved2 );               // MBZ
    _ULONG( TotalParameterCount );      // Total parameter bytes being sent
    _ULONG( TotalDataCount );           // Total data bytes being sent
    _ULONG( ParameterCount );           // Parameter bytes sent this buffer
    _ULONG( ParameterOffset );          // Offset (from header start) to params
    _ULONG( ParameterDisplacement );    // Displacement of these param bytes
    _ULONG( DataCount );                // Data bytes sent this buffer
    _ULONG( DataOffset );               // Offset (from header start) to data
    _ULONG( DataDisplacement );         // Displacement of these data bytes
    UCHAR Reserved3;
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];
    //UCHAR Pad1[];                     // Pad to LONG
    //UCHAR Parameters[];               // Parameter bytes (# = ParameterCount)
    //UCHAR Pad2[];                     // Pad to LONG
    //UCHAR Data[];                     // Data bytes (# = DataCount)
} REQ_NT_TRANSACTION_SECONDARY;
typedef REQ_NT_TRANSACTION_SECONDARY SMB_UNALIGNED *PREQ_NT_TRANSACTION_SECONDARY;

typedef struct _RESP_NT_TRANSACTION {
    UCHAR WordCount;                    // Count of data bytes; value = 18 + SetupCount
    UCHAR Reserved1;
    _USHORT( Reserved2 );
    _ULONG( TotalParameterCount );     // Total parameter bytes being sent
    _ULONG( TotalDataCount );          // Total data bytes being sent
    _ULONG( ParameterCount );          // Parameter bytes sent this buffer
    _ULONG( ParameterOffset );         // Offset (from header start) to params
    _ULONG( ParameterDisplacement );   // Displacement of these param bytes
    _ULONG( DataCount );               // Data bytes sent this buffer
    _ULONG( DataOffset );              // Offset (from header start) to data
    _ULONG( DataDisplacement );        // Displacement of these data bytes
    UCHAR SetupCount;                  // Count of setup words
    UCHAR Buffer[1];
    //USHORT Setup[];                  // Setup words (# = SetupWordCount)
    //USHORT ByteCount;                // Count of data bytes
    //UCHAR Pad1[];                    // Pad to LONG
    //UCHAR Parameters[];              // Parameter bytes (# = ParameterCount)
    //UCHAR Pad2[];                    // Pad to SHORT or LONG
    //UCHAR Data[];                    // Data bytes (# = DataCount)
} RESP_NT_TRANSACTION;
typedef RESP_NT_TRANSACTION SMB_UNALIGNED *PRESP_NT_TRANSACTION;

#endif // def INCLUDE_SMB_TRANSACTION

#ifdef INCLUDE_SMB_TREE

//
// Tree Connect SMB, see #1, page 6
// Function is SrvSmbTreeConnect()
// SMB_COM_TREE_CONNECT 0x70
//

typedef struct _REQ_TREE_CONNECT {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes; min = 4
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat1;              //  0x04 -- ASCII
    //UCHAR Path[];                     //  Server name and share name
    //UCHAR BufferFormat2;              //  0x04 -- ASCII
    //UCHAR Password[];                 //  Password
    //UCHAR BufferFormat3;              //  0x04 -- ASCII
    //UCHAR Service[];                  //  Service name
} REQ_TREE_CONNECT;
typedef REQ_TREE_CONNECT SMB_UNALIGNED *PREQ_TREE_CONNECT;

typedef struct _RESP_TREE_CONNECT {
    UCHAR WordCount;                    // Count of parameter words = 2
    _USHORT( MaxBufferSize );           // Max size message the server handles
    _USHORT( Tid );                     // Tree ID
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_TREE_CONNECT;
typedef RESP_TREE_CONNECT SMB_UNALIGNED *PRESP_TREE_CONNECT;

#endif // def INCLUDE_SMB_TREE

#ifdef INCLUDE_SMB_TREE

//
// Tree Connect and X SMB, see #2, page 88
// Function is SrvSmbTreeConnectAndX()
// SMB_COM_TREE_CONNECT_ANDX 0x75
//
// TREE_CONNECT_ANDX flags

#define TREE_CONNECT_ANDX_DISCONNECT_TID    (0x1)
// #define TREE_CONNECT_ANDX_W95            (0x2)  -- W95 sets this flag.  Don't know why.

typedef struct _REQ_TREE_CONNECT_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 4
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Flags );                   // Additional information
                                        //  bit 0 set = disconnect Tid
                                        //  bit 7 set = extended response
    _USHORT( PasswordLength );          // Length of Password[]
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Password[];                 //  Password
    //UCHAR Path[];                     //  Server name and share name
    //UCHAR Service[];                  //  Service name
} REQ_TREE_CONNECT_ANDX;
typedef REQ_TREE_CONNECT_ANDX SMB_UNALIGNED *PREQ_TREE_CONNECT_ANDX;

typedef struct _RESP_TREE_CONNECT_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 2
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Service type connected to
} RESP_TREE_CONNECT_ANDX;
typedef RESP_TREE_CONNECT_ANDX SMB_UNALIGNED *PRESP_TREE_CONNECT_ANDX;

//
// The response for clients that are LAN Manager 2.1 or better.
//

typedef struct _RESP_21_TREE_CONNECT_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 3
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( OptionalSupport );         // Optional support bits
    _USHORT( ByteCount );               // Count of data bytes; min = 3
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Service[];                  //   Service type connected to
    //UCHAR NativeFileSystem[];         //   Native file system for this tree
} RESP_21_TREE_CONNECT_ANDX;
typedef RESP_21_TREE_CONNECT_ANDX SMB_UNALIGNED *PRESP_21_TREE_CONNECT_ANDX;

//
// Optional Support bit definitions
//
#define SMB_SUPPORT_SEARCH_BITS         0x0001
#define SMB_SHARE_IS_IN_DFS             0x0002

#endif // def INCLUDE_SMB_TREE

#ifdef INCLUDE_SMB_TREE

//
// Tree Disconnect SMB, see #1 page 7
// Function is SrvSmbTreeDisconnect()
// SMB_COM_TREE_DISCONNECT 0x71
//

typedef struct _REQ_TREE_DISCONNECT {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_TREE_DISCONNECT;
typedef REQ_TREE_DISCONNECT SMB_UNALIGNED *PREQ_TREE_DISCONNECT;

typedef struct _RESP_TREE_DISCONNECT {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_TREE_DISCONNECT;
typedef RESP_TREE_DISCONNECT SMB_UNALIGNED *PRESP_TREE_DISCONNECT;

#endif // def INCLUDE_SMB_TREE

#ifdef INCLUDE_SMB_LOCK

//
// Unlock Byte Range SMB, see #1 page 20
// Function is SrvSmbUnlockByteRange()
// SMB_COM_UNLOCK_BYTE_RANGE 0x0D
//

typedef struct _REQ_UNLOCK_BYTE_RANGE {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( Fid );                     // File handle
    _ULONG( Count );                    // Count of bytes to unlock
    _ULONG( Offset );                   // Offset from start of file
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} REQ_UNLOCK_BYTE_RANGE;
typedef REQ_UNLOCK_BYTE_RANGE SMB_UNALIGNED *PREQ_UNLOCK_BYTE_RANGE;

typedef struct _RESP_UNLOCK_BYTE_RANGE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_UNLOCK_BYTE_RANGE;
typedef RESP_UNLOCK_BYTE_RANGE SMB_UNALIGNED *PRESP_UNLOCK_BYTE_RANGE;

#endif // def INCLUDE_SMB_LOCK

#ifdef INCLUDE_SMB_READ_WRITE

//
// Write SMB, see #1 page 12
// Write and Unlock SMB, see #2 page 92
// Function is SrvSmbWrite()
// SMB_COM_WRITE 0x0B
// SMB_COM_WRITE_AND_UNLOCK 0x14
//

//
// *** Warning: the following structure is defined the way it is to
//     ensure longword alignment of the data buffer.  (This only matters
//     when packing is disabled; when packing is turned on, the right
//     thing happens no matter what.)
//

typedef struct _REQ_WRITE {
    UCHAR WordCount;                    // Count of parameter words = 5
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Number of bytes to be written
    _ULONG( Offset );                   // Offset in file to begin write
    _USHORT( Remaining );               // Bytes remaining to satisfy request
    _USHORT( ByteCount );               // Count of data bytes
    //UCHAR Buffer[1];                  // Buffer containing:
      UCHAR BufferFormat;               //  0x01 -- Data block
      _USHORT( DataLength );            //  Length of data
      ULONG Buffer[1];                  //  Data
} REQ_WRITE;
typedef REQ_WRITE SMB_UNALIGNED *PREQ_WRITE;

typedef struct _RESP_WRITE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Count of bytes actually written
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE;
typedef RESP_WRITE SMB_UNALIGNED *PRESP_WRITE;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_READ_WRITE

//
// Write and Close SMB, see #2 page 90
// Function is SrvSmbWriteAndClose()
// SMB_COM_WRITE_AND_CLOSE 0x2C
//

//
// The Write and Close parameters can be 6 words long or 12 words long,
// depending on whether it's supposed to look like a Write SMB or a
// Write and X SMB.  So we define two different structures here.
//
// *** Warning: the following structures are defined the way they are to
//     ensure longword alignment of the data buffer.  (This only matters
//     when packing is disabled; when packing is turned on, the right
//     thing happens no matter what.)
//

typedef struct _REQ_WRITE_AND_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 6
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Number of bytes to write
    _ULONG( Offset );                   // Offset in file of first byte to write
    _ULONG( LastWriteTimeInSeconds );   // Time of last write
    _USHORT( ByteCount );               // 1 (for pad) + value of Count
    UCHAR Pad;                          // To force to doubleword boundary
    ULONG Buffer[1];                    // Data
} REQ_WRITE_AND_CLOSE;
typedef REQ_WRITE_AND_CLOSE SMB_UNALIGNED *PREQ_WRITE_AND_CLOSE;

typedef struct _REQ_WRITE_AND_CLOSE_LONG {
    UCHAR WordCount;                    // Count of parameter words = 12
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Number of bytes to write
    _ULONG( Offset );                   // Offset in file of first byte to write
    _ULONG( LastWriteTimeInSeconds );   // Time of last write
    _ULONG( Reserved )[3];              // Reserved, must be 0
    _USHORT( ByteCount );               // 1 (for pad) + value of Count
    UCHAR Pad;                          // To force to doubleword boundary
    ULONG Buffer[1];                    // Data
} REQ_WRITE_AND_CLOSE_LONG;
typedef REQ_WRITE_AND_CLOSE_LONG SMB_UNALIGNED *PREQ_WRITE_AND_CLOSE_LONG;

typedef struct _RESP_WRITE_AND_CLOSE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Count of bytes actually written
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_AND_CLOSE;
typedef RESP_WRITE_AND_CLOSE SMB_UNALIGNED *PRESP_WRITE_AND_CLOSE;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_READ_WRITE

//
// Write and X SMB, see #2 page 94
// Function is SrvSmbWriteAndX()
// SMB_COM_WRITE_ANDX 0x2F
//

typedef struct _REQ_WRITE_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 12
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin write
    _ULONG( Timeout );
    _USHORT( WriteMode );               // Write mode:
                                        //  0 - write through
                                        //  1 - return Remaining
                                        //  2 - use WriteRawNamedPipe (n. pipes)
                                        //  3 - "this is the start of the msg"
    _USHORT( Remaining );               // Bytes remaining to satisfy request
    _USHORT( Reserved );
    _USHORT( DataLength );              // Number of data bytes in buffer (>=0)
    _USHORT( DataOffset );              // Offset to data bytes
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (# = DataLength)
} REQ_WRITE_ANDX;
typedef REQ_WRITE_ANDX SMB_UNALIGNED *PREQ_WRITE_ANDX;

typedef struct _REQ_NT_WRITE_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 14
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Fid );                     // File handle
    _ULONG( Offset );                   // Offset in file to begin write
    _ULONG( Timeout );
    _USHORT( WriteMode );               // Write mode:
                                        //  0 - write through
                                        //  1 - return Remaining
                                        //  2 - use WriteRawNamedPipe (n. pipes)
                                        //  3 - "this is the start of the msg"
    _USHORT( Remaining );               // Bytes remaining to satisfy request
    _USHORT( DataLengthHigh );
    _USHORT( DataLength );              // Number of data bytes in buffer (>=0)
    _USHORT( DataOffset );              // Offset to data bytes
    _ULONG( OffsetHigh );               // Used for NT Protocol only
                                        // Upper 32 bits of offset
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (# = DataLength)
} REQ_NT_WRITE_ANDX;
typedef REQ_NT_WRITE_ANDX SMB_UNALIGNED *PREQ_NT_WRITE_ANDX;

typedef struct _RESP_WRITE_ANDX {
    UCHAR WordCount;                    // Count of parameter words = 6
    UCHAR AndXCommand;                  // Secondary (X) command; 0xFF = none
    UCHAR AndXReserved;                 // Reserved (must be 0)
    _USHORT( AndXOffset );              // Offset to next command WordCount
    _USHORT( Count );                   // Number of bytes written
    _USHORT( Remaining );               // Bytes remaining to be read (pipe/dev)
    union {
        _ULONG( Reserved );
        _USHORT( CountHigh );           // if large write&x
    };
    _USHORT( ByteCount );               // Count of data bytes. Inaccurate if
                                        //    large writes
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_ANDX;
typedef RESP_WRITE_ANDX SMB_UNALIGNED *PRESP_WRITE_ANDX;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_MPX

//
// Write Block Multiplexed SMB, see #2 page 97
// Function is SrvSmbWriteMpx()
// SMB_COM_WRITE_MPX 0x1E
// SMB_COM_WRITE_MPX_SECONDARY 0x1F
// SMB_COM_WRITE_MPX_COMPLETE 0x20
//

typedef struct _REQ_WRITE_MPX {
    UCHAR WordCount;                    // Count of parameter words = 12
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Total bytes, including this buffer
    _USHORT( Reserved );
    _ULONG( Offset );                   // Offset in file to begin write
    _ULONG( Timeout );
    _USHORT( WriteMode );               // Write mode:
                                        //  bit 0 - complete write to disk and
                                        //          send final result response
                                        //  bit 1 - return Remaining (pipe/dev)
                                        //  bit 7 - IPX datagram mode
    union {
        struct {
            _USHORT( DataCompactionMode );
            _USHORT( Reserved2 );
        } ;
        _ULONG( Mask );                 // IPX datagram mode mask
    } ;
    _USHORT( DataLength );              // Number of data bytes this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (# = DataLength)
} REQ_WRITE_MPX;
typedef REQ_WRITE_MPX SMB_UNALIGNED *PREQ_WRITE_MPX;

typedef struct _RESP_WRITE_MPX_INTERIM {    // First response
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Remaining );               // Bytes ramaining to be read (pipe/dev)
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_MPX_INTERIM;
typedef RESP_WRITE_MPX_INTERIM SMB_UNALIGNED *PRESP_WRITE_MPX_INTERIM;

typedef struct _RESP_WRITE_MPX_DATAGRAM {    // Response to sequenced request
    UCHAR WordCount;                    // Count of parameter words = 2
    _ULONG( Mask );                     // OR of all masks received
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_MPX_DATAGRAM;
typedef RESP_WRITE_MPX_DATAGRAM SMB_UNALIGNED *PRESP_WRITE_MPX_DATAGRAM;

// Secondary request format, 0 to N of these.

typedef struct _REQ_WRITE_MPX_SECONDARY {
    UCHAR WordCount;                    // Count of parameter words  = 8
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Total bytes to be sent
    _ULONG( Offset );                   // Offset in file to begin write
    _ULONG( Reserved );
    _USHORT( DataLength );              // Number of data bytes this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (# = DataLength)
} REQ_WRITE_MPX_SECONDARY;
typedef REQ_WRITE_MPX_SECONDARY SMB_UNALIGNED *PREQ_WRITE_MPX_SECONDARY;

#endif // def INCLUDE_SMB_MPX

#ifndef INCLUDE_SMB_WRITE_COMPLETE
#ifdef INCLUDE_SMB_MPX
#define INCLUDE_SMB_WRITE_COMPLETE
#else
#ifdef INCLUDE_SMB_RAW
#define INCLUDE_SMB_WRITE_COMPLETE
#endif
#endif
#endif

#ifdef INCLUDE_SMB_WRITE_COMPLETE

//
// The following structure is used as the final response to both Write
// Block Multiplexed and Write Block Raw.
//

typedef struct _RESP_WRITE_COMPLETE {   // Final response; command is
                                        //  SMB_COM_WRITE_COMPLETE
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Total number of bytes written
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_COMPLETE;
typedef RESP_WRITE_COMPLETE SMB_UNALIGNED *PRESP_WRITE_COMPLETE;

#endif // def INCLUDE_SMB_WRITE_COMPLETE

#ifdef INCLUDE_SMB_READ_WRITE

//
// Write Print File SMB, see #1 page 29
// Function is SrvSmbWritePrintFile()
// SMB_COM_WRITE_PRINT_FILE 0xC1
//

typedef struct _REQ_WRITE_PRINT_FILE {
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Fid );                     // File handle
    _USHORT( ByteCount );               // Count of data bytes; min = 4
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR BufferFormat;               //  0x01 -- Data block
    //USHORT DataLength;                //  Length of data
    //UCHAR Data[];                     //  Data
} REQ_WRITE_PRINT_FILE;
typedef REQ_WRITE_PRINT_FILE SMB_UNALIGNED *PREQ_WRITE_PRINT_FILE;

typedef struct _RESP_WRITE_PRINT_FILE {
    UCHAR WordCount;                    // Count of parameter words = 0
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_PRINT_FILE;
typedef RESP_WRITE_PRINT_FILE SMB_UNALIGNED *PRESP_WRITE_PRINT_FILE;

#endif // def INCLUDE_SMB_READ_WRITE

#ifdef INCLUDE_SMB_RAW

//
// Write Block Raw SMB, see #2 page 100
// Function is SrvSmbWriteRaw()
// SMB_COM_WRITE_RAW 0x1D
//

typedef struct _REQ_WRITE_RAW {
    UCHAR WordCount;                    // Count of parameter words = 12
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Total bytes, including this buffer
    _USHORT( Reserved );
    _ULONG( Offset );                   // Offset in file to begin write
    _ULONG( Timeout );
    _USHORT( WriteMode );               // Write mode:
                                        //  bit 0 - complete write to disk and
                                        //          send final result response
                                        //  bit 1 - return Remaining (pipe/dev)
                                        //  (see WriteAndX for #defines)
    _ULONG( Reserved2 );
    _USHORT( DataLength );              // Number of data bytes this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (# = DataLength)
} REQ_WRITE_RAW;
typedef REQ_WRITE_RAW SMB_UNALIGNED *PREQ_WRITE_RAW;

typedef struct _REQ_NT_WRITE_RAW {
    UCHAR WordCount;                    // Count of parameter words = 14
    _USHORT( Fid );                     // File handle
    _USHORT( Count );                   // Total bytes, including this buffer
    _USHORT( Reserved );
    _ULONG( Offset );                   // Offset in file to begin write
    _ULONG( Timeout );
    _USHORT( WriteMode );               // Write mode:
                                        //  bit 0 - complete write to disk and
                                        //          send final result response
                                        //  bit 1 - return Remaining (pipe/dev)
                                        //  (see WriteAndX for #defines)
    _ULONG( Reserved2 );
    _USHORT( DataLength );              // Number of data bytes this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    _ULONG( OffsetHigh );               // Used for NT Protocol only
                                        // Upper 32 bits of offset
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR Pad[];                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data (# = DataLength)
} REQ_NT_WRITE_RAW;
typedef REQ_NT_WRITE_RAW SMB_UNALIGNED *PREQ_NT_WRITE_RAW;

typedef struct _RESP_WRITE_RAW_INTERIM {    // First response
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Remaining );               // Bytes remaining to be read (pipe/dev)
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_RAW_INTERIM;
typedef RESP_WRITE_RAW_INTERIM SMB_UNALIGNED *PRESP_WRITE_RAW_INTERIM;

typedef struct _RESP_WRITE_RAW_SECONDARY {  // Second (final) response
    UCHAR WordCount;                    // Count of parameter words = 1
    _USHORT( Count );                   // Total number of bytes written
    _USHORT( ByteCount );               // Count of data bytes = 0
    UCHAR Buffer[1];                    // empty
} RESP_WRITE_RAW_SECONDARY;
typedef RESP_WRITE_RAW_SECONDARY SMB_UNALIGNED *PRESP_WRITE_RAW_SECONDARY;

typedef struct _REQ_103_WRITE_RAW {
    UCHAR WordCount;                    // Count of parameter words
    _USHORT( Fid );                     // File handle
    _USHORT( Count );
    _USHORT( Reserved );
    _ULONG( Offset );
    _ULONG( Timeout );
    _USHORT( WriteMode );
    _ULONG( Reserved2 );
    _USHORT( ByteCount );               // Count of data bytes; min =
    UCHAR Buffer[1];                    //
} REQ_103_WRITE_RAW;
typedef REQ_103_WRITE_RAW SMB_UNALIGNED *PREQ_103_WRITE_RAW;

typedef struct _RESP_103_WRITE_RAW {
    UCHAR WordCount;                    // Count of parameter words
    _USHORT( ByteCount );               // Count of data bytes; min =
    UCHAR Buffer[1];                    //
} RESP_103_WRITE_RAW;
typedef RESP_103_WRITE_RAW SMB_UNALIGNED *PRESP_103_WRITE_RAW;

#endif // def INCLUDE_SMB_RAW

typedef struct _REQ_NT_CANCEL {
    UCHAR WordCount;                    // = 0
    _USHORT( ByteCount );               // = 0
    UCHAR Buffer[1];
} REQ_NT_CANCEL;
typedef REQ_NT_CANCEL SMB_UNALIGNED *PREQ_NT_CANCEL;

typedef struct _RESP_NT_CANCEL {
    UCHAR WordCount;                    // = 0
    _USHORT( ByteCount );               // = 0
    UCHAR Buffer[1];
} RESP_NT_CANCEL;
typedef RESP_NT_CANCEL SMB_UNALIGNED *PRESP_NT_CANCEL;

//
// File open modes
//

#define SMB_ACCESS_READ_ONLY 0
#define SMB_ACCESS_WRITE_ONLY 1
#define SMB_ACCESS_READ_WRITE 2
#define SMB_ACCESS_EXECUTE 3

//
// Open flags
//

#define SMB_OPEN_QUERY_INFORMATION  0x01
#define SMB_OPEN_OPLOCK             0x02
#define SMB_OPEN_OPBATCH            0x04
#define SMB_OPEN_QUERY_EA_LENGTH    0x08
#define SMB_OPEN_EXTENDED_RESPONSE  0x10

//
// NT open manifests
//

#define NT_CREATE_REQUEST_OPLOCK    0x02
#define NT_CREATE_REQUEST_OPBATCH   0x04
#define NT_CREATE_OPEN_TARGET_DIR   0x08


#define Added              0
#define Removed            1
#define Modified           2
#define RenamedOldName     3
#define RenamedNewName     4

//
// Lockrange for use with OS/2 DosFileLocks call
//

// *** Where is this used?

//typedef struct lockrange {
//    ULONG offset;
//    ULONG range;
//    };

//#define LOCK 0x1
//#define UNLOCK 0x2

//
// Data buffer format codes, from the core protocol.
//

#define SMB_FORMAT_DATA         1
#define SMB_FORMAT_DIALECT      2
#define SMB_FORMAT_PATHNAME     3
#define SMB_FORMAT_ASCII        4
#define SMB_FORMAT_VARIABLE     5

//
// WriteMode flags
//

#define SMB_WMODE_WRITE_THROUGH        0x0001   // complete write before responding
#define SMB_WMODE_SET_REMAINING        0x0002   // returning amt remaining in pipe
#define SMB_WMODE_WRITE_RAW_NAMED_PIPE 0x0004   // write named pipe in raw mode
#define SMB_WMODE_START_OF_MESSAGE     0x0008   // start of pipe message
#define SMB_WMODE_DATAGRAM             0x0080   // start of pipe message

//
// Various SMB flags:
//

//
// If the server supports LockAndRead and WriteAndUnlock, it sets this
// bit the Negotiate response.
//

#define SMB_FLAGS_LOCK_AND_READ_OK 0x01

//
// When on, the consumer guarantees that there is a receive buffer posted
// such that a "Send.No.Ack" can be used by the server to respond to
// the consumer's request.
//

#define SMB_FLAGS_SEND_NO_ACK 0x2

//
// This is part of the Flags field of every SMB header.  If this bit
// is set, then all pathnames in the SMB should be treated as case-
// insensitive.
//

#define SMB_FLAGS_CASE_INSENSITIVE 0x8

//
// When on in session setup, this bit indicates that all paths sent to
// the server are already in OS/2 canonicalized format.
//

#define SMB_FLAGS_CANONICALIZED_PATHS 0x10

//
// When on in a open file request SMBs (open, create, openX, etc.) this
// bit indicates a request for an oplock on the file.  When on in the
// response, this bit indicates that the oplock was granted.
//

#define SMB_FLAGS_OPLOCK 0x20

//
// When on, this bit indicates that the server should notify the client
// on any request that could cause the file to be changed.  If not set,
// the server only notifies the client on other open requests on the
// file.
//

#define SMB_FLAGS_OPLOCK_NOTIFY_ANY 0x40

//
// This bit indicates that the SMB is being sent from server to redir.
//

#define SMB_FLAGS_SERVER_TO_REDIR 0x80

//
// Valid bits for Flags on an incoming SMB
//

#define INCOMING_SMB_FLAGS      \
            (SMB_FLAGS_LOCK_AND_READ_OK    | \
             SMB_FLAGS_SEND_NO_ACK         | \
             SMB_FLAGS_CASE_INSENSITIVE    | \
             SMB_FLAGS_CANONICALIZED_PATHS | \
             SMB_FLAGS_OPLOCK_NOTIFY_ANY   | \
             SMB_FLAGS_OPLOCK)

//
// Names for bits in Flags2 field of SMB header that indicate what the
// client app is aware of.
//

#define SMB_FLAGS2_KNOWS_LONG_NAMES      0x0001
#define SMB_FLAGS2_KNOWS_EAS             0x0002
#define SMB_FLAGS2_SMB_SECURITY_SIGNATURE 0x0004
#define SMB_FLAGS2_IS_LONG_NAME          0x0040
#define SMB_FLAGS2_DFS                   0x1000
#define SMB_FLAGS2_PAGING_IO             0x2000
#define SMB_FLAGS2_NT_STATUS             0x4000
#define SMB_FLAGS2_UNICODE               0x8000

//
// Valid bits for Flags2 on an incoming SMB
//

#define INCOMING_SMB_FLAGS2     \
            (SMB_FLAGS2_KNOWS_LONG_NAMES | \
             SMB_FLAGS2_KNOWS_EAS        | \
             SMB_FLAGS2_DFS              | \
             SMB_FLAGS2_PAGING_IO        | \
             SMB_FLAGS2_IS_LONG_NAME     | \
             SMB_FLAGS2_NT_STATUS        | \
             SMB_FLAGS2_UNICODE )

//
// The SMB open function determines what action should be taken depending
// on the existence or lack thereof of files used in the operation.  It
// has the following mapping:
//
//    1111 1
//    5432 1098 7654 3210
//    rrrr rrrr rrrC rrOO
//
// where:
//
//    O - Open (action to be taken if the target file exists)
//        0 - Fail
//        1 - Open or Append file
//        2 - Truncate file
//
//    C - Create (action to be taken if the target file does not exist)
//        0 - Fail
//        1 - Create file
//

#define SMB_OFUN_OPEN_MASK 0x3
#define SMB_OFUN_CREATE_MASK 0x10

#define SMB_OFUN_OPEN_FAIL 0
#define SMB_OFUN_OPEN_APPEND 1
#define SMB_OFUN_OPEN_OPEN 1
#define SMB_OFUN_OPEN_TRUNCATE 2

#define SMB_OFUN_CREATE_FAIL 0x00
#define SMB_OFUN_CREATE_CREATE 0x10

//++
//
// BOOLEAN
// SmbOfunCreate(
//     IN USHORT SmbOpenFunction
//     )
//
//--

#define SmbOfunCreate(SmbOpenFunction) \
    (BOOLEAN)((SmbOpenFunction & SMB_OFUN_CREATE_MASK) == SMB_OFUN_CREATE_CREATE)

//++
//
// BOOLEAN
// SmbOfunAppend(
//     IN USHORT SmbOpenFunction
//     )
//
//--

#define SmbOfunAppend(SmbOpenFunction) \
    (BOOLEAN)((SmbOpenFunction & SMB_OFUN_OPEN_MASK) == SMB_OFUN_OPEN_APPEND)

//++
//
// BOOLEAN
// SmbOfunTruncate(
//     IN USHORT SmbOpenFunction
//     )
//
//--

#define SmbOfunTruncate(SmbOpenFunction) \
    (BOOLEAN)((SmbOpenFunction & SMB_OFUN_OPEN_MASK) == SMB_OFUN_OPEN_TRUNCATE)

//
// The desired access mode passed in Open and Open and X has the following
// mapping:
//
//    1111 11
//    5432 1098 7654 3210
//    rWrC rLLL rSSS rAAA
//
// where:
//
//    W - Write through mode.  No read ahead or write behind allowed on
//        this file or device.  When protocol is returned, data is expected
//        to be on the disk or device.
//
//    S - Sharing mode:
//        0 - Compatibility mode (as in core open)
//        1 - Deny read/write/execute (exclusive)
//        2 - Deny write
//        3 - Deny read/execute
//        4 - Deny none
//
//    A - Access mode
//        0 - Open for reading
//        1 - Open for writing
//        2 - Open for reading and writing
//        3 - Open for execute
//
//    rSSSrAAA = 11111111 (hex FF) indicates FCB open (as in core protocol)
//
//    C - Cache mode
//        0 - Normal file
//        1 - Do not cache this file
//
//    L - Locality of reference
//        0 - Locality of reference is unknown
//        1 - Mainly sequential access
//        2 - Mainly random access
//        3 - Random access with some locality
//        4 to 7 - Currently undefined
//


#define SMB_DA_SHARE_MASK           0x70
#define SMB_DA_ACCESS_MASK          0x07
#define SMB_DA_FCB_MASK             (UCHAR)0xFF

#define SMB_DA_ACCESS_READ          0x00
#define SMB_DA_ACCESS_WRITE         0x01
#define SMB_DA_ACCESS_READ_WRITE    0x02
#define SMB_DA_ACCESS_EXECUTE       0x03

#define SMB_DA_SHARE_COMPATIBILITY  0x00
#define SMB_DA_SHARE_EXCLUSIVE      0x10
#define SMB_DA_SHARE_DENY_WRITE     0x20
#define SMB_DA_SHARE_DENY_READ      0x30
#define SMB_DA_SHARE_DENY_NONE      0x40

#define SMB_DA_FCB                  (UCHAR)0xFF

#define SMB_CACHE_NORMAL            0x0000
#define SMB_DO_NOT_CACHE            0x1000

#define SMB_LR_UNKNOWN              0x0000
#define SMB_LR_SEQUENTIAL           0x0100
#define SMB_LR_RANDOM               0x0200
#define SMB_LR_RANDOM_WITH_LOCALITY 0x0300
#define SMB_LR_MASK                 0x0F00

#define SMB_DA_WRITE_THROUGH        0x4000

//
// The Action field of OpenAndX has the following format:
//
//    1111 11
//    5432 1098 7654 3210
//    Lrrr rrrr rrrr rrOO
//
// where:
//
//    L - Opportunistic lock.  1 if lock granted, else 0.
//
//    O - Open action:
//        1 - The file existed and was opened
//        2 - The file did not exist but was created
//        3 - The file existed and was truncated
//

#define SMB_OACT_OPENED     0x01
#define SMB_OACT_CREATED    0x02
#define SMB_OACT_TRUNCATED  0x03

#define SMB_OACT_OPLOCK     0x8000

//
// These flags are passed in the Flags field of the copy and extended rename
// SMBs.
//

//
// If set, the target must be a file or directory.
//

#define SMB_TARGET_IS_FILE         0x1
#define SMB_TARGET_IS_DIRECTORY    0x2

//
// The copy mode--if set, ASCII copying should be done, otherwise binary.
//

#define SMB_COPY_TARGET_ASCII       0x4
#define SMB_COPY_SOURCE_ASCII       0x8

#define SMB_COPY_TREE               0x20

//
// If set, verify all writes.
//

#define SMB_VERIFY_WRITES

//
// Define file attribute bits as used in the SMB protocol.  The specific
// bit positions are, for the most part, identical to those used in NT.
// However, NT does not define Volume and Directory bits.  It also has
// an explicit Normal bit; this bit is implied in SMB attributes by
// Hidden, System, and Directory being off.
//

#define SMB_FILE_ATTRIBUTE_READONLY     0x01
#define SMB_FILE_ATTRIBUTE_HIDDEN       0x02
#define SMB_FILE_ATTRIBUTE_SYSTEM       0x04
#define SMB_FILE_ATTRIBUTE_VOLUME       0x08
#define SMB_FILE_ATTRIBUTE_DIRECTORY    0x10
#define SMB_FILE_ATTRIBUTE_ARCHIVE      0x20

//
// Share type strings are passed in SMBs to indicate what type of shared
// resource is being or has been connected to.
//

#define SHARE_TYPE_NAME_DISK "A:"
#define SHARE_TYPE_NAME_PIPE "IPC"
#define SHARE_TYPE_NAME_COMM "COMM"
#define SHARE_TYPE_NAME_PRINT "LPT1:"
#define SHARE_TYPE_NAME_WILD "?????"

//
// SMB Error codes:
//

//
// Success Class:
//

#define SMB_ERR_SUCCESS (UCHAR)0x00

//
// DOS Error Class:
//

#define SMB_ERR_CLASS_DOS (UCHAR)0x01

#define SMB_ERR_BAD_FUNCTION        1   // Invalid function
#define SMB_ERR_BAD_FILE            2   // File not found
#define SMB_ERR_BAD_PATH            3   // Invalid directory
#define SMB_ERR_NO_FIDS             4   // Too many open files
#define SMB_ERR_ACCESS_DENIED       5   // Access not allowed for req. func.
#define SMB_ERR_BAD_FID             6   // Invalid file handle
#define SMB_ERR_BAD_MCB             7   // Memory control blocks destroyed
#define SMB_ERR_INSUFFICIENT_MEMORY 8   // For the desired function
#define SMB_ERR_BAD_MEMORY          9   // Invalid memory block address
#define SMB_ERR_BAD_ENVIRONMENT     10  // Invalid environment
#define SMB_ERR_BAD_FORMAT          11  // Invalid format
#define SMB_ERR_BAD_ACCESS          12  // Invalid open mode
#define SMB_ERR_BAD_DATA            13  // Invalid data (only from IOCTL)
#define SMB_ERR_RESERVED            14
#define SMB_ERR_BAD_DRIVE           15  // Invalid drive specified
#define SMB_ERR_CURRENT_DIRECTORY   16  // Attempted to remove currect directory
#define SMB_ERR_DIFFERENT_DEVICE    17  // Not the same device
#define SMB_ERR_NO_FILES            18  // File search can't find more files
#define SMB_ERR_BAD_SHARE           32  // An open conflicts with FIDs on file
#define SMB_ERR_LOCK                33  // Conflict with existing lock
#define SMB_ERR_FILE_EXISTS         80  // Tried to overwrite existing file
#define SMB_ERR_BAD_PIPE            230 // Invalie pipe
#define SMB_ERR_PIPE_BUSY           231 // All instances of the pipe are busy
#define SMB_ERR_PIPE_CLOSING        232 // Pipe close in progress
#define SMB_ERR_PIPE_NOT_CONNECTED  233 // No process on other end of pipe
#define SMB_ERR_MORE_DATA           234 // There is more data to return

//
// SERVER Error Class:
//

#define SMB_ERR_CLASS_SERVER (UCHAR)0x02

#define SMB_ERR_ERROR               1   // Non-specific error code
#define SMB_ERR_BAD_PASSWORD        2   // Bad name/password pair
#define SMB_ERR_BAD_TYPE            3   // Reserved
#define SMB_ERR_ACCESS              4   // Requester lacks necessary access
#define SMB_ERR_BAD_TID             5   // Invalid TID
#define SMB_ERR_BAD_NET_NAME        6   // Invalid network name in tree connect
#define SMB_ERR_BAD_DEVICE          7   // Invalid device request
#define SMB_ERR_QUEUE_FULL          49  // Print queue full--returned print file
#define SMB_ERR_QUEUE_TOO_BIG       50  // Print queue full--no space
#define SMB_ERR_QUEUE_EOF           51  // EOF on print queue dump
#define SMB_ERR_BAD_PRINT_FID       52  // Invalid print file FID
#define SMB_ERR_BAD_SMB_COMMAND     64  // SMB command not recognized
#define SMB_ERR_SERVER_ERROR        65  // Internal server error
#define SMB_ERR_FILE_SPECS          67  // FID and pathname were incompatible
#define SMB_ERR_RESERVED2           68
#define SMB_ERR_BAD_PERMITS         69  // Access permissions invalid
#define SMB_ERR_RESERVED3           70
#define SMB_ERR_BAD_ATTRIBUTE_MODE  71  // Invalid attribute mode specified
#define SMB_ERR_SERVER_PAUSED       81  // Server is paused
#define SMB_ERR_MESSAGE_OFF         82  // Server not receiving messages
#define SMB_ERR_NO_ROOM             83  // No room for buffer message
#define SMB_ERR_TOO_MANY_NAMES      87  // Too many remote user names
#define SMB_ERR_TIMEOUT             88  // Operation was timed out
#define SMB_ERR_NO_RESOURCE         89  // No resources available for request
#define SMB_ERR_TOO_MANY_UIDS       90  // Too many UIDs active in session
#define SMB_ERR_BAD_UID             91  // UID not known as a valid UID
#define SMB_ERR_INVALID_NAME        123 // Invalid name returned from FAT.
#define SMB_ERR_INVALID_NAME_RANGE  206 // Non 8.3 name passed to FAT (or non 255 name to HPFS)
#define SMB_ERR_USE_MPX             250 // Can't support Raw; use MPX
#define SMB_ERR_USE_STANDARD        251 // Can't support Raw, use standard r/w
#define SMB_ERR_CONTINUE_MPX        252 // Reserved
#define SMB_ERR_RESERVED4           253
#define SMB_ERR_RESERVED5           254
#define SMB_ERR_NO_SUPPORT_INTERNAL 255 // Internal code for NO_SUPPORT--
                                        // allows codes to be stored in a byte
#define SMB_ERR_NO_SUPPORT          (USHORT)0xFFFF  // Function not supported

//
// HARDWARE Error Class:
//

#define SMB_ERR_CLASS_HARDWARE (UCHAR)0x03

#define SMB_ERR_NO_WRITE            19  // Write attempted to write-prot. disk
#define SMB_ERR_BAD_UNIT            20  // Unknown unit
#define SMB_ERR_DRIVE_NOT_READY     21  // Disk drive not ready
#define SMB_ERR_BAD_COMMAND         22  // Unknown command
#define SMB_ERR_DATA                23  // Data error (CRC)
#define SMB_ERR_BAD_REQUEST         24  // Bad request structure length
#define SMB_ERR_SEEK                25  // Seek error
#define SMB_ERR_BAD_MEDIA           26  // Unknown media type
#define SMB_ERR_BAD_SECTOR          27  // Sector not found
#define SMB_ERR_NO_PAPER            28  // Printer out of paper
#define SMB_ERR_WRITE_FAULT         29  // Write fault
#define SMB_ERR_READ_FAULT          30  // Read fault
#define SMB_ERR_GENERAL             31  // General failure
#define SMB_ERR_LOCK_CONFLICT       33  // Lock conflicts with existing lock
#define SMB_ERR_WRONG_DISK          34  // Wrong disk was found in a drive
#define SMB_ERR_FCB_UNAVAILABLE     35  // No FCBs available to process request
#define SMB_ERR_SHARE_BUFFER_EXCEEDED 36
#define SMB_ERR_DISK_FULL           39  // !!! Undocumented, but in LM2.0

//
// Other Error Classes:
//

#define SMB_ERR_CLASS_XOS        (UCHAR)0x04    // Reserved for XENIX
#define SMB_ERR_CLASS_RMX1       (UCHAR)0xE1    // Reserved for iRMX
#define SMB_ERR_CLASS_RMX2       (UCHAR)0xE2    // Reserved for iRMX
#define SMB_ERR_CLASS_RMX3       (UCHAR)0xE3    // Reserved for iRMX
#define SMB_ERR_CLASS_COMMAND    (UCHAR)0xFF    // Command was not in the SMB format


//
// Turn structure packing back off
//

#ifndef NO_PACKING
#include <packoff.h>
#endif // ndef NO_PACKING

//   Old (LanMan 1.2) and new (NT) field names:
//   (Undocumented fields have corresponding structure in parenthesis)
// smb_access            Access
// smb_action            Action
// smb_adate             AccessDate
// smb_allocsize         AllocationSize
// smb_aname             AccountName
// smb_apasslen          PasswordSize
// smb_apasswd           AccountPassword
// smb_atime             AccessTime
// smb_attr              Attribute
// smb_attribute         Attribute
// smb_aunits            (RESP_QUERY_INFORMATION_SERVER)
// smb_bcc               BufferSize
// smb_blkmode           BlockMode
// smb_blksize           BlockSize
// smb_blksperunit       BlocksPerUnit
// smb_bpu               BlocksPerUnit
// smb_bs                BlockSize
// smb_bufsize           MaxBufferSize
// smb_buf[1]            Buffer[1]
// smb_bytes[*]          Bytes[*]
// smb_cat               Category
// smb_cct               FilesCopied
// smb_cdate             CreateDate
// smb_cert              CertificateOffset
// smb_com               Command
// smb_com2              AndXCommand
// smb_count             Count
// smb_count_left        Remaining
// smb_cryptkey[*]       CryptKey
// smb_ctime             CreateTime
// smb_datablock         DataBlock
// smb_datalen           DataSize
// smb_datasize          DataSize
// smb_data[*]           Data[*]
// smb_dcmode            DataCompactMode
// smb_dev               DeviceName
// smb_doff              DataOffset
// smb_drcnt             DataCount
// smb_drdisp            DataDisplacement
// smb_droff             DataOffset
// smb_dscnt             DataCount
// smb_dsdisp            DataDisplacement
// smb_dsize             DataSize
// smb_dsoff             DataOffset
// smb_encrypt           EncryptKey
// smb_encryptlen        EncryptKeySize
// smb_encryptoff        EncryptKeyOffset
// smb_eos               EndOfSearch
// smb_err               Error
// smb_errmsg[1]         ErrorMessage[1]
// smb_fau               (RESP_QUERY_INFORMATION_SERVER)
// smb_fid               Fid
// smb_fileid            ServerFid
// smb_flag              Flag
// smb_flag2             Flag2
// smb_flags             Flag
// smb_flg               Flag
// smb_freeunits         FreeUnits
// smb_fsid              (RESP_QUERY_INFORMATION_SERVER)
// smb_fsize             FileSize
// smb_fun               Function
// smb_gid               Gid
// smb_handle            Handle
// smb_ident1            Identifier
// smb_idf[4]            Protocol[4]
// smb_index             Index
// smb_info              Info
// smb_left              Remaining
// smb_len               SetupLength
// smb_locknum           NumberOfLocks
// smb_lockrng[*]        LockRange
// smb_locktype          LockType
// smb_lpid              OwnerPid
// smb_maxbytes          MaxBytes
// smb_maxcnt            MaxCount
// smb_maxcount          MaxCount
// smb_maxmux            (RESP_NEGOTIATE)
// smb_maxvcs            MaxNumberVcs
// smb_maxxmitsz         MaxTransmitSize
// smb_maxxmt            MaxTransmitSize
// smb_mdate             ModificationDate
// smb_mdrcnt            MaxDataCount
// smb_mid               Mid
// smb_mincnt            MinCount
// smb_mode              Mode
// smb_mprcnt            MaxParameterCount
// smb_mpxmax            MaxMpxCount
// smb_msrcnt            MaxSetupCount
// smb_mtime             ModificationTime
// smb_name[*]           Name[*]
// smb_off2              AndXOffset
// smb_offset            Offset
// smb_ofun              OpenFunction
// smb_pad               Pad
// smb_pad1[]            Pad1
// smb_pad[]             Pad[]
// smb_param[*]          Parameter[*]
// smb_path              ServerName
// smb_pathname          PathName
// smb_pid               Pid
// smb_prcnt             ParameterCount
// smb_prdisp            ParameterDisplacement
// smb_proff             ParameterCount
// smb_pscnt             ParameterCount
// smb_psdisp            ParameterDisplacement
// smb_psoff             ParameterOffset
// smb_range             LockLength or UnlockLength
// smb_rcls              ErrorClass
// smb_reh               ReservedH
// smb_reh2              ReservedH2
// smb_remaining         Remaining
// smb_remcnt            Remaining
// smb_res1              Reserved
// smb_res2              Reserved2
// smb_res3              Reserved3
// smb_res4              Reserved4
// smb_res5              Reserved5
// smb_reserved          Reserved
// smb_restart           Restart
// smb_resumekey         ResumeKey
// smb_res[5]            Reserved[]
// smb_reverb            ReverbCount
// smb_rsvd              Reserved
// smb_rsvd1             Reserved
// smb_rsvd2             Reserved2
// smb_rsvd3             Reserved3
// smb_rsvd4             Reserved4
// smb_sattr             SearchAttribute
// smb_secmode           SecurityMode
// smb_seq               SequenceNumber
// smb_services          Services
// smb_sesskey           SessionKey
// smb_setup[*]          Setup[*]
// smb_size              Size
// smb_spasslen          ServerPasswordSize
// smb_spasswd           ServerPassword
// smb_srv_date          ServerDate
// smb_srv_time          ServerTime
// smb_srv_tzone         ServerTimeZone
// smb_start             StartIndex
// smb_state             DeviceState
// smb_suwcnt            SetupWordCount
// smb_su_class          SetupClass
// smb_su_com            SetupCommand
// smb_su_handle         SetupFid
// smb_su_opcode         SetupOpcode
// smb_su_priority       SetupPriority
// smb_tcount            Count
// smb_tdis              TreeDisconnect
// smb_tdrcnt            TotalDataCount
// smb_tdscnt            TotalDataCount
// smb_tid               Tid
// smb_tid2              Tid2
// smb_time              Time
// smb_timeout           Timeout
// smb_totalunits        TotalUnits
// smb_tprcnt            TotalParameterCount
// smb_tpscnt            TotalParameterCount
// smb_type              FileType
// smb_uid               Uid
// smb_unlkrng[*]        UnlockRange
// smb_unlocknum         NumberOfUnlocks
// smb_vblen             DataLength
// smb_vcnum             VcNumber
// smb_vldate            (RESP_QUERY_INFORMATION_SERVER)
// smb_vllen             (RESP_QUERY_INFORMATION_SERVER)
// smb_vltime            (RESP_QUERY_INFORMATION_SERVER)
// smb_vwv[1]            Param
// smb_wct               WordCount
// smb_wmode             WriteMode
// smb_xchain            EncryptChainOffset


//
// Force misalignment of the following structures
//

#ifndef NO_PACKING
#include <packon.h>
#endif // ndef NO_PACKING


//
// Named pipe function codes
//

#define TRANS_SET_NMPIPE_STATE      0x01
#define TRANS_RAW_READ_NMPIPE       0x11
#define TRANS_QUERY_NMPIPE_STATE    0x21
#define TRANS_QUERY_NMPIPE_INFO     0x22
#define TRANS_PEEK_NMPIPE           0x23
#define TRANS_TRANSACT_NMPIPE       0x26
#define TRANS_RAW_WRITE_NMPIPE      0x31
#define TRANS_READ_NMPIPE           0x36
#define TRANS_WRITE_NMPIPE          0x37
#define TRANS_WAIT_NMPIPE           0x53
#define TRANS_CALL_NMPIPE           0x54

//
// Mailslot function code
//

#define TRANS_MAILSLOT_WRITE        0x01

//
// Transaction2 function codes
//

#define TRANS2_OPEN2                    0x00
#define TRANS2_FIND_FIRST2              0x01
#define TRANS2_FIND_NEXT2               0x02
#define TRANS2_QUERY_FS_INFORMATION     0x03
#define TRANS2_SET_FS_INFORMATION       0x04
#define TRANS2_QUERY_PATH_INFORMATION   0x05
#define TRANS2_SET_PATH_INFORMATION     0x06
#define TRANS2_QUERY_FILE_INFORMATION   0x07
#define TRANS2_SET_FILE_INFORMATION     0x08
#define TRANS2_FSCTL                    0x09
#define TRANS2_IOCTL2                   0x0A
#define TRANS2_FIND_NOTIFY_FIRST        0x0B
#define TRANS2_FIND_NOTIFY_NEXT         0x0C
#define TRANS2_CREATE_DIRECTORY         0x0D
#define TRANS2_SESSION_SETUP            0x0E
#define TRANS2_QUERY_FS_INFORMATION_FID 0x0F
#define TRANS2_GET_DFS_REFERRAL         0x10
#define TRANS2_REPORT_DFS_INCONSISTENCY 0x11

#define TRANS2_MAX_FUNCTION             0x11

//
// Nt Transaction function codes
//

#define NT_TRANSACT_MIN_FUNCTION        1

#define NT_TRANSACT_CREATE              1
#define NT_TRANSACT_IOCTL               2
#define NT_TRANSACT_SET_SECURITY_DESC   3
#define NT_TRANSACT_NOTIFY_CHANGE       4
#define NT_TRANSACT_RENAME              5
#define NT_TRANSACT_QUERY_SECURITY_DESC 6
#define NT_TRANSACT_QUERY_QUOTA         7
#define NT_TRANSACT_SET_QUOTA           8

#define NT_TRANSACT_MAX_FUNCTION        8

//
// File information levels
//

#define SMB_INFO_STANDARD               1
#define SMB_INFO_QUERY_EA_SIZE          2
#define SMB_INFO_SET_EAS                2
#define SMB_INFO_QUERY_EAS_FROM_LIST    3
#define SMB_INFO_QUERY_ALL_EAS          4       // undocumented but supported
#define SMB_INFO_QUERY_FULL_NAME        5       // never sent by redir
#define SMB_INFO_IS_NAME_VALID          6
#define SMB_INFO_PASSTHROUGH            1000    // any info above here is a simple pass-through

//
// NT extension to file info levels
//

#define SMB_QUERY_FILE_BASIC_INFO          0x101
#define SMB_QUERY_FILE_STANDARD_INFO       0x102
#define SMB_QUERY_FILE_EA_INFO             0x103
#define SMB_QUERY_FILE_NAME_INFO           0x104
#define SMB_QUERY_FILE_ALLOCATION_INFO     0x105
#define SMB_QUERY_FILE_END_OF_FILEINFO     0x106
#define SMB_QUERY_FILE_ALL_INFO            0x107
#define SMB_QUERY_FILE_ALT_NAME_INFO       0x108
#define SMB_QUERY_FILE_STREAM_INFO         0x109
#define SMB_QUERY_FILE_COMPRESSION_INFO    0x10B

#define SMB_SET_FILE_BASIC_INFO                 0x101
#define SMB_SET_FILE_DISPOSITION_INFO           0x102
#define SMB_SET_FILE_ALLOCATION_INFO            0x103
#define SMB_SET_FILE_END_OF_FILE_INFO           0x104

#define SMB_QUERY_FS_LABEL_INFO            0x101
#define SMB_QUERY_FS_VOLUME_INFO           0x102
#define SMB_QUERY_FS_SIZE_INFO             0x103
#define SMB_QUERY_FS_DEVICE_INFO           0x104
#define SMB_QUERY_FS_ATTRIBUTE_INFO        0x105
#define SMB_QUERY_FS_QUOTA_INFO            0x106        // unused?
#define SMB_QUERY_FS_CONTROL_INFO          0x107

//
// Volume information levels.
//

#define SMB_INFO_ALLOCATION             1
#define SMB_INFO_VOLUME                 2

//
// Rename2 information levels.
//

#define SMB_NT_RENAME_MOVE_CLUSTER_INFO   0x102
#define SMB_NT_RENAME_SET_LINK_INFO       0x103
#define SMB_NT_RENAME_RENAME_FILE         0x104 // Server internal
#define SMB_NT_RENAME_MOVE_FILE           0x105 // Server internal

//
// Protocol for NtQueryQuotaInformationFile
//
typedef struct {
    _USHORT( Fid );                 // FID of target
    UCHAR ReturnSingleEntry;        // Indicates that only a single entry should be returned
                                    //   rather than filling the buffer with as
                                    //   many entries as possible.
    UCHAR RestartScan;              // Indicates whether the scan of the quota information
                                    //   is to be restarted from the beginning.
    _ULONG ( SidListLength );       // Supplies the length of the SID list if present
    _ULONG ( StartSidLength );      // Supplies an optional SID that indicates that the returned
                                    //   information is to start with an entry other
                                    //   than the first.  This parameter is ignored if a
                                    //   SidList is given
    _ULONG( StartSidOffset);        // Supplies the offset of Start Sid in the buffer
} REQ_NT_QUERY_FS_QUOTA_INFO, *PREQ_NT_QUERY_FS_QUOTA_INFO;
//
// Desciptor response
//
// Data Bytes:  The Quota Information
//
typedef struct {
    _ULONG ( Length );
} RESP_NT_QUERY_FS_QUOTA_INFO, *PRESP_NT_QUERY_FS_QUOTA_INFO;

//
// Protocol for NtSetQuotaInformationFile
//
typedef struct {
    _USHORT( Fid );                 // FID of target
} REQ_NT_SET_FS_QUOTA_INFO, *PREQ_NT_SET_FS_QUOTA_INFO;
//
// Response:
//
// Setup words:  None.
// Parameter Bytes:  None.
// Data Bytes:  None.
//


//
// Dfs Transactions
//

//
// Request for Referral.
//
typedef struct {
    USHORT MaxReferralLevel;            // Latest version of referral understood
    UCHAR RequestFileName[1];           // Dfs name for which referral is sought
} REQ_GET_DFS_REFERRAL;
typedef REQ_GET_DFS_REFERRAL SMB_UNALIGNED *PREQ_GET_DFS_REFERRAL;

//
// The format of an individual referral contains version and length information
//  allowing the client to skip referrals it does not understand.
//
// !! All referral elements must have VersionNumber and Size as the first 2 elements !!
//

typedef struct {
    USHORT  VersionNumber;              // == 1
    USHORT  Size;                       // Size of this whole element
    USHORT  ServerType;                 // Type of server: 0 == Don't know, 1 == SMB, 2 == Netware
    struct {
        USHORT StripPath : 1;           // Strip off PathConsumed characters from front of
                                        // DfsPathName prior to submitting name to UncShareName
    };
    WCHAR   ShareName[1];               // The server+share name go right here.  NULL terminated.
} DFS_REFERRAL_V1;
typedef DFS_REFERRAL_V1 SMB_UNALIGNED *PDFS_REFERRAL_V1;

typedef struct {
    USHORT  VersionNumber;              // == 2
    USHORT  Size;                       // Size of this whole element
    USHORT  ServerType;                 // Type of server: 0 == Don't know, 1 == SMB, 2 == Netware
    struct {
        USHORT StripPath : 1;           // Strip off PathConsumed characters from front of
                                        // DfsPathName prior to submitting name to UncShareName
    };
    ULONG   Proximity;                  // Hint of transport cost
    ULONG   TimeToLive;                 // In number of seconds
    USHORT  DfsPathOffset;              // Offset from beginning of this element to Path to access
    USHORT  DfsAlternatePathOffset;     // Offset from beginning of this element to 8.3 path
    USHORT  NetworkAddressOffset;       // Offset from beginning of this element to Network path
} DFS_REFERRAL_V2;
typedef DFS_REFERRAL_V2 SMB_UNALIGNED *PDFS_REFERRAL_V2;

typedef struct {
    USHORT  VersionNumber;              // == 3
    USHORT  Size;                       // Size of this whole element
    USHORT  ServerType;                 // Type of server: 0 == Don't know, 1 == SMB, 2 == Netware
    struct {
        USHORT StripPath : 1;           // Strip off PathConsumed characters from front of
                                        // DfsPathName prior to submitting name to UncShareName
        USHORT NameListReferral : 1;    // This referral contains an expanded name list
    };
    ULONG   TimeToLive;                 // In number of seconds
    union {
      struct {
        USHORT DfsPathOffset;           // Offset from beginning of this element to Path to access
        USHORT DfsAlternatePathOffset;  // Offset from beginning of this element to 8.3 path
        USHORT NetworkAddressOffset;    // Offset from beginning of this element to Network path
        GUID   ServiceSiteGuid;         // The guid for the site
      };
      struct {
        USHORT SpecialNameOffset;       // Offset from this element to the special name string
        USHORT NumberOfExpandedNames;   // Number of expanded names
        USHORT ExpandedNameOffset;      // Offset from this element to the expanded name list
      };
    };
} DFS_REFERRAL_V3;
typedef DFS_REFERRAL_V3 SMB_UNALIGNED *PDFS_REFERRAL_V3;

typedef struct {
    USHORT  PathConsumed;               // Number of WCHARs consumed in DfsPathName
    USHORT  NumberOfReferrals;          // Number of referrals contained here
    struct {
            ULONG ReferralServers : 1;  // Elements in Referrals[] are referral servers
            ULONG StorageServers : 1;   // Elements in Referrals[] are storage servers
    };
    union {                             // The vector of referrals
        DFS_REFERRAL_V1 v1;
        DFS_REFERRAL_V2 v2;
        DFS_REFERRAL_V3 v3;
    } Referrals[1];                     // [ NumberOfReferrals ]

    //
    // WCHAR StringBuffer[];            // Used by DFS_REFERRAL_V2
    //

} RESP_GET_DFS_REFERRAL;
typedef RESP_GET_DFS_REFERRAL SMB_UNALIGNED *PRESP_GET_DFS_REFERRAL;

//
// During Dfs operations, a client may discover a knowledge inconsistency in the Dfs.
// The parameter portion of the TRANS2_REPORT_DFS_INCONSISTENCY SMB is
// encoded in this way
//

typedef struct {
    UCHAR RequestFileName[1];           // Dfs name for which inconsistency is being reported
    union {
        DFS_REFERRAL_V1 v1;             // The single referral thought to be in error
    } Referral;
} REQ_REPORT_DFS_INCONSISTENCY;
typedef REQ_REPORT_DFS_INCONSISTENCY SMB_UNALIGNED *PREQ_REPORT_DFS_INCONSISTENCY;

typedef struct _REQ_QUERY_FS_INFORMATION_FID {
    _USHORT( InformationLevel );
    _USHORT( Fid );
} REQ_QUERY_FS_INFORMATION_FID;
typedef REQ_QUERY_FS_INFORMATION_FID SMB_UNALIGNED *PREQ_QUERY_FS_INFORMATION_FID;

//
// The client also needs to send to this server the referral which it believes to be
//  in error.  The data part of this transaction contains the errant referral(s), encoded
//  as above in the DFS_REFERRAL_* structures.
//

//
// Find First, information levels
//

#define SMB_FIND_FILE_DIRECTORY_INFO       0x101
#define SMB_FIND_FILE_FULL_DIRECTORY_INFO  0x102
#define SMB_FIND_FILE_NAMES_INFO           0x103
#define SMB_FIND_FILE_BOTH_DIRECTORY_INFO  0x104

#ifdef INCLUDE_SMB_DIRECTORY

//
// CreateDirectory2 function code os Transaction2 SMB, see #3 page 51
// Function is SrvSmbCreateDirectory2()
// TRANS2_CREATE_DIRECTORY 0x0D
//

typedef struct _REQ_CREATE_DIRECTORY2 {
    _ULONG( Reserved );                 // Reserved--must be zero
    UCHAR Buffer[1];                    // Directory name to create
} REQ_CREATE_DIRECTORY2;
typedef REQ_CREATE_DIRECTORY2 SMB_UNALIGNED *PREQ_CREATE_DIRECTORY2;

// Data bytes for CreateDirectory2 request are the extended attributes for the
// created file.

typedef struct _RESP_CREATE_DIRECTORY2 {
    _USHORT( EaErrorOffset );           // Offset into FEAList of first error
                                        // which occurred while setting EAs
} RESP_CREATE_DIRECTORY2;
typedef RESP_CREATE_DIRECTORY2 SMB_UNALIGNED *PRESP_CREATE_DIRECTORY2;

#endif // def INCLUDE_SMB_DIRECTORY

#ifdef INCLUDE_SMB_SEARCH

//
// FindFirst2 function code of Transaction2 SMB, see #3 page 22
// Function is SrvSmbFindFirst2()
// TRANS2_FIND_FIRST2 0x01
//

typedef struct _REQ_FIND_FIRST2 {
    _USHORT( SearchAttributes );
    _USHORT( SearchCount );             // Maximum number of entries to return
    _USHORT( Flags );                   // Additional information: bit set-
                                        //  0 - close search after this request
                                        //  1 - close search if end reached
                                        //  2 - return resume keys
    _USHORT( InformationLevel );
    _ULONG(SearchStorageType);
    UCHAR Buffer[1];                    // File name
} REQ_FIND_FIRST2;
typedef REQ_FIND_FIRST2 SMB_UNALIGNED *PREQ_FIND_FIRST2;

// Data bytes for Find First2 request are a list of extended attributes
// to retrieve (a GEAList), if InformationLevel is QUERY_EAS_FROM_LIST.

typedef struct _RESP_FIND_FIRST2 {
    _USHORT( Sid );                     // Search handle
    _USHORT( SearchCount );             // Number of entries returned
    _USHORT( EndOfSearch );             // Was last entry returned?
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
    _USHORT( LastNameOffset );          // Offset into data to file name of
                                        //  last entry, if server needs it
                                        //  to resume search; else 0
} RESP_FIND_FIRST2;
typedef RESP_FIND_FIRST2 SMB_UNALIGNED *PRESP_FIND_FIRST2;

// Data bytes for Find First2 response are level-dependent information
// about the matching files.  If bit 2 in the request parameters was
// set, each entry is preceded by a four-byte resume key.

//
// FindNext2 function code of Transaction2 SMB, see #3 page 26
// Function is SrvSmbFindNext2()
// TRANS2_FIND_NEXT2 0x02
//

typedef struct _REQ_FIND_NEXT2 {
    _USHORT( Sid );                     // Search handle
    _USHORT( SearchCount );             // Maximum number of entries to return
    _USHORT( InformationLevel );
    _ULONG( ResumeKey );                // Value returned by previous find
    _USHORT( Flags );                   // Additional information: bit set-
                                        //  0 - close search after this request
                                        //  1 - close search if end reached
                                        //  2 - return resume keys
                                        //  3 - resume/continue, NOT rewind
    UCHAR Buffer[1];                    // Resume file name
} REQ_FIND_NEXT2;
typedef REQ_FIND_NEXT2 SMB_UNALIGNED *PREQ_FIND_NEXT2;

// Data bytes for Find Next2 request are a list of extended attributes
// to retrieve, if InformationLevel is QUERY_EAS_FROM_LIST.

typedef struct _RESP_FIND_NEXT2 {
    _USHORT( SearchCount );             // Number of entries returned
    _USHORT( EndOfSearch );             // Was last entry returned?
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
    _USHORT( LastNameOffset );          // Offset into data to file name of
                                        //  last entry, if server needs it
                                        //  to resume search; else 0
} RESP_FIND_NEXT2;
typedef RESP_FIND_NEXT2 SMB_UNALIGNED *PRESP_FIND_NEXT2;

// Data bytes for Find Next2 response are level-dependent information
// about the matching files.  If bit 2 in the request parameters was
// set, each entry is preceded by a four-byte resume key.

//
// Flags for REQ_FIND_FIRST2.Flags
//

#define SMB_FIND_CLOSE_AFTER_REQUEST    0x01
#define SMB_FIND_CLOSE_AT_EOS           0x02
#define SMB_FIND_RETURN_RESUME_KEYS     0x04
#define SMB_FIND_CONTINUE_FROM_LAST     0x08
#define SMB_FIND_WITH_BACKUP_INTENT     0x10

#endif // def INCLUDE_SMB_SEARCH

#ifdef INCLUDE_SMB_OPEN_CLOSE

//
// Open2 function code of Transaction2 SMB, see #3 page 19
// Function is SrvSmbOpen2()
// TRANS2_OPEN2 0x00
//
// *** Note that the REQ_OPEN2 and RESP_OPEN2 structures closely
//     resemble the REQ_OPEN_ANDX and RESP_OPEN_ANDX structures.
//

typedef struct _REQ_OPEN2 {
    _USHORT( Flags );                   // Additional information: bit set-
                                        //  0 - return additional info
                                        //  1 - set single user total file lock
                                        //  2 - server notifies consumer of
                                        //      actions which may change file
                                        //  3 - return total length of EAs
    _USHORT( DesiredAccess );           // File open mode
    _USHORT( SearchAttributes );        // *** ignored
    _USHORT( FileAttributes );
    _ULONG( CreationTimeInSeconds );
    _USHORT( OpenFunction );
    _ULONG( AllocationSize );           // Bytes to reserve on create or truncate
    _USHORT( Reserved )[5];             // Pad through OpenAndX's Timeout,
                                        //  Reserved, and ByteCount
    UCHAR Buffer[1];                    // File name
} REQ_OPEN2;
typedef REQ_OPEN2 SMB_UNALIGNED *PREQ_OPEN2;

// Data bytes for Open2 request are the extended attributes for the
// created file.

typedef struct _RESP_OPEN2 {
    _USHORT( Fid );                     // File handle
    _USHORT( FileAttributes );
    _ULONG( CreationTimeInSeconds );
    _ULONG( DataSize );                 // Current file size
    _USHORT( GrantedAccess );           // Access permissions actually allowed
    _USHORT( FileType );
    _USHORT( DeviceState );             // state of IPC device (e.g. pipe)
    _USHORT( Action );                  // Action taken
    _ULONG( ServerFid );                // Server unique file id
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
    _ULONG( EaLength );                 // Total EA length for opened file
} RESP_OPEN2;
typedef RESP_OPEN2 SMB_UNALIGNED *PRESP_OPEN2;

// The Open2 response has no data bytes.


#endif // def INCLUDE_SMB_OPEN_CLOSE

#ifdef INCLUDE_SMB_MISC

//
// QueryFsInformation function code of Transaction2 SMB, see #3 page 30
// Function is SrvSmbQueryFsInformation()
// TRANS2_QUERY_FS_INFORMATION 0x03
//

typedef struct _REQ_QUERY_FS_INFORMATION {
    _USHORT( InformationLevel );
} REQ_QUERY_FS_INFORMATION;
typedef REQ_QUERY_FS_INFORMATION SMB_UNALIGNED *PREQ_QUERY_FS_INFORMATION;

// No data bytes for Query FS Information request.

//typedef struct _RESP_QUERY_FS_INFORMATION {
//} RESP_QUERY_FS_INFORMATION;
//typedef RESP_QUERY_FS_INFORMATION SMB_UNALIGNED *PRESP_QUERY_FS_INFORMATION;

// Data bytes for Query FS Information response are level-dependent
// information about the specified volume.

//
// SetFSInformation function code of Transaction2 SMB, see #3 page 31
// Function is SrvSmbSetFSInformation()
// TRANS2_SET_PATH_INFORMATION 0x04
//

typedef struct _REQ_SET_FS_INFORMATION {
    _USHORT( Fid );
    _USHORT( InformationLevel );
} REQ_SET_FS_INFORMATION;
typedef REQ_SET_FS_INFORMATION SMB_UNALIGNED *PREQ_SET_FS_INFORMATION;

// Data bytes for Set FS Information request are level-dependant
// information about the specified volume.

//typedef struct _RESP_SET_FS_INFORMATION {
//} RESP_SET_FS_INFORMATION;
//typedef RESP_SET_FS_INFORMATION SMB_UNALIGNED *PRESP_SET_FS_INFORMATION;

// The Set FS Information response has no data bytes.

#endif // def INCLUDE_SMB_MISC

#ifdef INCLUDE_SMB_QUERY_SET

//
// QueryPathInformation function code of Transaction2 SMB, see #3 page 33
// Function is SrvSmbQueryPathInformation()
// TRANS2_QUERY_PATH_INFORMATION 0x05
//

typedef struct _REQ_QUERY_PATH_INFORMATION {
    _USHORT( InformationLevel );
    _ULONG( Reserved );                 // Must be zero
    UCHAR Buffer[1];                    // File name
} REQ_QUERY_PATH_INFORMATION;
typedef REQ_QUERY_PATH_INFORMATION SMB_UNALIGNED *PREQ_QUERY_PATH_INFORMATION;

// Data bytes for Query Path Information request are a list of extended
// attributes to retrieve, if InformationLevel is QUERY_EAS_FROM_LIST.

typedef struct _RESP_QUERY_PATH_INFORMATION {
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
} RESP_QUERY_PATH_INFORMATION;
typedef RESP_QUERY_PATH_INFORMATION SMB_UNALIGNED *PRESP_QUERY_PATH_INFORMATION;

// Data bytes for Query Path Information response are level-dependent
// information about the specified path/file.

//
// SetPathInformation function code of Transaction2 SMB, see #3 page 35
// Function is SrvSmbSetPathInformation()
// TRANS2_SET_PATH_INFORMATION 0x06
//

typedef struct _REQ_SET_PATH_INFORMATION {
    _USHORT( InformationLevel );
    _ULONG( Reserved );                 // Must be zero
    UCHAR Buffer[1];                    // File name
} REQ_SET_PATH_INFORMATION;
typedef REQ_SET_PATH_INFORMATION SMB_UNALIGNED *PREQ_SET_PATH_INFORMATION;

// Data bytes for Set Path Information request are either file information
// and attributes or a list of extended attributes for the file.

typedef struct _RESP_SET_PATH_INFORMATION {
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
} RESP_SET_PATH_INFORMATION;
typedef RESP_SET_PATH_INFORMATION SMB_UNALIGNED *PRESP_SET_PATH_INFORMATION;

// The Set Path Information response has no data bytes.

//
// QueryFileInformation function code of Transaction2 SMB, see #3 page 37
// Function is SrvSmbQueryFileInformation()
// TRANS2_QUERY_FILE_INFORMATION 0x07
//

typedef struct _REQ_QUERY_FILE_INFORMATION {
    _USHORT( Fid );                     // File handle
    _USHORT( InformationLevel );
} REQ_QUERY_FILE_INFORMATION;
typedef REQ_QUERY_FILE_INFORMATION SMB_UNALIGNED *PREQ_QUERY_FILE_INFORMATION;

// Data bytes for Query File Information request are a list of extended
// attributes to retrieve, if InformationLevel is QUERY_EAS_FROM_LIST.

typedef struct _RESP_QUERY_FILE_INFORMATION {
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
} RESP_QUERY_FILE_INFORMATION;
typedef RESP_QUERY_FILE_INFORMATION SMB_UNALIGNED *PRESP_QUERY_FILE_INFORMATION;

// Data bytes for Query File Information response are level-dependent
// information about the specified path/file.

//
// SetFileInformation function code of Transaction2 SMB, see #3 page 39
// Function is SrvSmbSetFileInformation()
// TRANS2_SET_FILE_INFORMATION 0x08
//

typedef struct _REQ_SET_FILE_INFORMATION {
    _USHORT( Fid );                     // File handle
    _USHORT( InformationLevel );
    _USHORT( Flags );                   // File I/O control flags: bit set-
                                        //  4 - write through
                                        //  5 - no cache
} REQ_SET_FILE_INFORMATION;
typedef REQ_SET_FILE_INFORMATION SMB_UNALIGNED *PREQ_SET_FILE_INFORMATION;

// Data bytes for Set File Information request are either file information
// and attributes or a list of extended attributes for the file.

typedef struct _RESP_SET_FILE_INFORMATION {
    _USHORT( EaErrorOffset );           // Offset into EA list if EA error
} RESP_SET_FILE_INFORMATION;
typedef RESP_SET_FILE_INFORMATION SMB_UNALIGNED *PRESP_SET_FILE_INFORMATION;

// The Set File Information response has no data bytes.

#endif // def INCLUDE_SMB_QUERY_SET

//
//  Opcodes for Mailslot transactions.  Not all filled in at present.
//    WARNING ... the info here on mailslots (opcode and smb struct)
//                is duplicated in net/h/mslotsmb.h
//

#define MS_WRITE_OPCODE 1

typedef struct _SMB_TRANSACT_MAILSLOT {
    UCHAR WordCount;                    // Count of data bytes; value = 17
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( MaxParameterCount );       // Max parameter bytes to return
    _USHORT( MaxDataCount );            // Max data bytes to return
    UCHAR MaxSetupCount;                // Max setup words to return
    UCHAR Reserved;
    _USHORT( Flags );                   // Additional information:
                                        //  bit 0 - unused
                                        //  bit 1 - one-way transacion (no resp)
    _ULONG( Timeout );
    _USHORT( Reserved1 );
    _USHORT( ParameterCount );          // Parameter bytes sent this buffer
    _USHORT( ParameterOffset );         // Offset (from header start) to params
    _USHORT( DataCount );               // Data bytes sent this buffer
    _USHORT( DataOffset );              // Offset (from header start) to data
    UCHAR SetupWordCount;               // = 3
    UCHAR Reserved2;                    // Reserved (pad above to word)
    _USHORT( Opcode );                  // 1 -- Write Mailslot
    _USHORT( Priority );                // Priority of transaction
    _USHORT( Class );                   // Class: 1 = reliable, 2 = unreliable
    _USHORT( ByteCount );               // Count of data bytes
    UCHAR Buffer[1];                    // Buffer containing:
    //UCHAR MailslotName[];             //  "\MAILSLOT\<name>0"
    //UCHAR Pad[]                       //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data to write to mailslot
} SMB_TRANSACT_MAILSLOT;
typedef SMB_TRANSACT_MAILSLOT SMB_UNALIGNED *PSMB_TRANSACT_MAILSLOT;

typedef struct _SMB_TRANSACT_NAMED_PIPE {
    UCHAR WordCount;                    // Count of data bytes; value = 16
    _USHORT( TotalParameterCount );     // Total parameter bytes being sent
    _USHORT( TotalDataCount );          // Total data bytes being sent
    _USHORT( MaxParameterCount );       // Max parameter bytes to return
    _USHORT( MaxDataCount );            // Max data bytes to return
    UCHAR MaxSetupCount;                // Max setup words to return
    UCHAR Reserved;
    _USHORT( Flags );                   // Additional information:
                                        //  bit 0 - also disconnect TID in Tid
                                        //  bit 1 - one-way transacion (no resp)
    _ULONG( Timeout );
    _USHORT( Reserved1 );
    _USHORT( ParameterCount );
                                        // Buffer containing:
    //UCHAR PipeName[];                 //  "\PIPE\<name>0"
    //UCHAR Pad[]                       //  Pad to SHORT or LONG
    //UCHAR Param[];                    //  Parameter bytes (# = ParameterCount)
    //UCHAR Pad1[]                      //  Pad to SHORT or LONG
    //UCHAR Data[];                     //  Data bytes (# = DataCount)
} SMB_TRANSACT_NAMED_PIPE;
typedef SMB_TRANSACT_NAMED_PIPE SMB_UNALIGNED *PSMB_TRANSACT_NAMED_PIPE;


//
// Transaction - QueryInformationNamedPipe, Level 1, output data format
//

typedef struct _NAMED_PIPE_INFORMATION_1 {
    _USHORT( OutputBufferSize );
    _USHORT( InputBufferSize );
    UCHAR MaximumInstances;
    UCHAR CurrentInstances;
    UCHAR PipeNameLength;
    UCHAR PipeName[1];
} NAMED_PIPE_INFORMATION_1;
typedef NAMED_PIPE_INFORMATION_1 SMB_UNALIGNED *PNAMED_PIPE_INFORMATION_1;

//
// Transaction - PeekNamedPipe, output format
//

typedef struct _RESP_PEEK_NMPIPE {
    _USHORT( ReadDataAvailable );
    _USHORT( MessageLength );
    _USHORT( NamedPipeState );
    //UCHAR Pad[];
    //UCHAR Data[];
} RESP_PEEK_NMPIPE;
typedef RESP_PEEK_NMPIPE SMB_UNALIGNED *PRESP_PEEK_NMPIPE;

//
// Define SMB pipe handle state bits used by Query/SetNamedPipeHandleState
//
// These number are the bit location of the fields in the handle state.
//

#define PIPE_COMPLETION_MODE_BITS   15
#define PIPE_PIPE_END_BITS          14
#define PIPE_PIPE_TYPE_BITS         10
#define PIPE_READ_MODE_BITS          8
#define PIPE_MAXIMUM_INSTANCES_BITS  0

/* DosPeekNmPipe() pipe states */

#define PIPE_STATE_DISCONNECTED 0x0001
#define PIPE_STATE_LISTENING    0x0002
#define PIPE_STATE_CONNECTED    0x0003
#define PIPE_STATE_CLOSING      0x0004

/* DosCreateNPipe and DosQueryNPHState state */

#define SMB_PIPE_READMODE_BYTE        0x0000
#define SMB_PIPE_READMODE_MESSAGE     0x0100
#define SMB_PIPE_TYPE_BYTE            0x0000
#define SMB_PIPE_TYPE_MESSAGE         0x0400
#define SMB_PIPE_END_CLIENT           0x0000
#define SMB_PIPE_END_SERVER           0x4000
#define SMB_PIPE_WAIT                 0x0000
#define SMB_PIPE_NOWAIT               0x8000
#define SMB_PIPE_UNLIMITED_INSTANCES  0x00FF


//
// Pipe name string for conversion between SMB and NT formats.
//

#define SMB_PIPE_PREFIX  "\\PIPE"
#define UNICODE_SMB_PIPE_PREFIX L"\\PIPE"
#define CANONICAL_PIPE_PREFIX "PIPE\\"
#define NT_PIPE_PREFIX   L"\\Device\\NamedPipe"

#define SMB_PIPE_PREFIX_LENGTH  (sizeof(SMB_PIPE_PREFIX) - 1)
#define UNICODE_SMB_PIPE_PREFIX_LENGTH \
                    (sizeof(UNICODE_SMB_PIPE_PREFIX) - sizeof(WCHAR))
#define CANONICAL_PIPE_PREFIX_LENGTH (sizeof(CANONICAL_PIPE_PREFIX) - 1)
#define NT_PIPE_PREFIX_LENGTH   (sizeof(NT_PIPE_PREFIX) - sizeof(WCHAR))

//
// Mailslot name strings.
//

#define SMB_MAILSLOT_PREFIX "\\MAILSLOT"
#define UNICODE_SMB_MAILSLOT_PREFIX L"\\MAILSLOT"

#define SMB_MAILSLOT_PREFIX_LENGTH (sizeof(SMB_MAILSLOT_PREFIX) - 1)
#define UNICODE_SMB_MAILSLOT_PREFIX_LENGTH \
                    (sizeof(UNICODE_SMB_MAILSLOT_PREFIX) - sizeof(WCHAR))

//
// NT Transaction subfunctions
//

#ifdef INCLUDE_SMB_OPEN_CLOSE

typedef struct _REQ_CREATE_WITH_SD_OR_EA {
    _ULONG( Flags );                   // Creation flags
    _ULONG( RootDirectoryFid );        // Optional directory for relative open
    ACCESS_MASK DesiredAccess;         // Desired access (NT format)
    LARGE_INTEGER AllocationSize;      // The initial allocation size in bytes
    _ULONG( FileAttributes );          // The file attributes
    _ULONG( ShareAccess );             // The share access
    _ULONG( CreateDisposition );       // Action to take if file exists or not
    _ULONG( CreateOptions );           // Options for creating a new file
    _ULONG( SecurityDescriptorLength );// Length of SD in bytes
    _ULONG( EaLength );                // Length of EA in bytes
    _ULONG( NameLength );              // Length of name in characters
    _ULONG( ImpersonationLevel );      // Security QOS information
    UCHAR SecurityFlags;               // Security QOS information
    UCHAR Buffer[1];
    //UCHAR Name[];                     // The name of the file (not NUL terminated)
} REQ_CREATE_WITH_SD_OR_EA;
typedef REQ_CREATE_WITH_SD_OR_EA SMB_UNALIGNED *PREQ_CREATE_WITH_SD_OR_EA;

//
// Data format:
//   UCHAR SecurityDesciptor[];
//   UCHAR Pad1[];        // Pad to LONG
//   UCHAR EaList[];
//

typedef struct _RESP_CREATE_WITH_SD_OR_EA {
    UCHAR OplockLevel;                  // The oplock level granted
    UCHAR Reserved;
    _USHORT( Fid );                     // The file ID
    _ULONG( CreateAction );             // The action taken
    _ULONG( EaErrorOffset );            // Offset of the EA error
    TIME CreationTime;                  // The time the file was created
    TIME LastAccessTime;                // The time the file was accessed
    TIME LastWriteTime;                 // The time the file was last written
    TIME ChangeTime;                    // The time the file was last changed
    _ULONG( FileAttributes );           // The file attributes
    LARGE_INTEGER AllocationSize;       // The number of byes allocated
    LARGE_INTEGER EndOfFile;            // The end of file offset
    _USHORT( FileType );
    _USHORT( DeviceState );             // state of IPC device (e.g. pipe)
    BOOLEAN Directory;                  // TRUE if this is a directory
} RESP_CREATE_WITH_SD_OR_EA;
typedef RESP_CREATE_WITH_SD_OR_EA SMB_UNALIGNED *PRESP_CREATE_WITH_SD_OR_EA;

// No data bytes for the response


#endif //  INCLUDE_SMB_OPEN_CLOSE

//
// Setup words for NT I/O control request
//

typedef struct _REQ_NT_IO_CONTROL {
    _ULONG( FunctionCode );
    _USHORT( Fid );
    BOOLEAN IsFsctl;
    UCHAR   IsFlags;
} REQ_NT_IO_CONTROL;
typedef REQ_NT_IO_CONTROL SMB_UNALIGNED *PREQ_NT_IO_CONTROL;

//
// Request parameter bytes - The first buffer
// Request data bytes - The second buffer
//

//
// NT I/O Control response:
//
// Setup Words:  None.
// Parameter Bytes:  First buffer.
// Data Bytes: Second buffer.
//

//
// NT Notify directory change
//

// Request Setup Words

typedef struct _REQ_NOTIFY_CHANGE {
    _ULONG( CompletionFilter );              // Specifies operation to monitor
    _USHORT( Fid );                          // Fid of directory to monitor
    BOOLEAN WatchTree;                       // TRUE = watch all subdirectories too
    UCHAR Reserved;                          // MBZ
} REQ_NOTIFY_CHANGE;
typedef REQ_NOTIFY_CHANGE SMB_UNALIGNED *PREQ_NOTIFY_CHANGE;

//
// Request parameter bytes:  None
// Request data bytes:  None
//

//
// NT Notify directory change response
//
// Setup words:  None.
// Parameter bytes:  The change data buffer.
// Data bytes:  None.
//

//
// NT Set Security Descriptor request
//
// Setup words:  REQ_SET_SECURITY_DESCIPTOR.
// Parameter Bytes:  None.
// Data Bytes:  The Security Descriptor data.
//

typedef struct _REQ_SET_SECURITY_DESCRIPTOR {
    _USHORT( Fid );                    // FID of target
    _USHORT( Reserved );               // MBZ
    _ULONG( SecurityInformation );     // Fields of SD that to set
} REQ_SET_SECURITY_DESCRIPTOR;
typedef REQ_SET_SECURITY_DESCRIPTOR SMB_UNALIGNED *PREQ_SET_SECURITY_DESCRIPTOR;

//
// NT Set Security Desciptor response
//
// Setup words:  None.
// Parameter Bytes:  None.
// Data Bytes:  None.
//

//
// NT Query Security Descriptor request
//
// Setup words:  None.
// Parameter Bytes:  REQ_QUERY_SECURITY_DESCRIPTOR.
// Data Bytes:  None.
//

typedef struct _REQ_QUERY_SECURITY_DESCRIPTOR {
    _USHORT( Fid );                    // FID of target
    _USHORT( Reserved );               // MBZ
    _ULONG( SecurityInformation );     // Fields of SD that to query
} REQ_QUERY_SECURITY_DESCRIPTOR;
typedef REQ_QUERY_SECURITY_DESCRIPTOR SMB_UNALIGNED *PREQ_QUERY_SECURITY_DESCRIPTOR;

//
// NT Query Security Desciptor response
//
// Parameter bytes:  RESP_QUERY_SECURITY_DESCRIPTOR
// Data Bytes:  The Security Descriptor data.
//

typedef struct _RESP_QUERY_SECURITY_DESCRIPTOR {
    _ULONG( LengthNeeded );           // Size of data buffer required for SD
} RESP_QUERY_SECURITY_DESCRIPTOR;
typedef RESP_QUERY_SECURITY_DESCRIPTOR SMB_UNALIGNED *PRESP_QUERY_SECURITY_DESCRIPTOR;

//
// NT Rename file
//
// Setup words: None
// Parameters bytes:  REQ_NT_RENAME
// Data bytes: None
//

typedef struct _REQ_NT_RENAME {
    _USHORT( Fid );                    // FID of file to rename
    _USHORT( RenameFlags );            // defined below
    UCHAR NewName[];                   // New file name.
} REQ_NT_RENAME;
typedef REQ_NT_RENAME SMB_UNALIGNED *PREQ_NT_RENAME;

//
// Rename flags defined
//

#define SMB_RENAME_REPLACE_IF_EXISTS   1

//
// Turn structure packing back off
//

#ifndef NO_PACKING
#include <packoff.h>
#endif // ndef NO_PACKING

//
// The following macros store and retrieve USHORTS and ULONGS from
// potentially unaligned addresses, avoiding alignment faults.  They
// would best be written as inline assembly code.
//
// The macros are designed to be used for accessing SMB fields.  Such
// fields are always stored in little-endian byte order, so these macros
// do byte swapping when compiled for a big-endian machine.
//
// !!! Not yet.
//

#if !SMBDBG

#define BYTE_0_MASK 0xFF

#define BYTE_0(Value) (UCHAR)(  (Value)        & BYTE_0_MASK)
#define BYTE_1(Value) (UCHAR)( ((Value) >>  8) & BYTE_0_MASK)
#define BYTE_2(Value) (UCHAR)( ((Value) >> 16) & BYTE_0_MASK)
#define BYTE_3(Value) (UCHAR)( ((Value) >> 24) & BYTE_0_MASK)

#endif

//++
//
// USHORT
// SmbGetUshort (
//     IN PSMB_USHORT SrcAddress
//     )
//
// Routine Description:
//
//     This macro retrieves a USHORT value from the possibly misaligned
//     source address, avoiding alignment faults.
//
// Arguments:
//
//     SrcAddress - where to retrieve USHORT value from
//
// Return Value:
//
//     USHORT - the value retrieved.  The target must be aligned.
//
//--

#if !SMBDBG

#if !SMBDBG1
#if SMB_USE_UNALIGNED
#define SmbGetUshort(SrcAddress) *(PSMB_USHORT)(SrcAddress)
#else
#define SmbGetUshort(SrcAddress) (USHORT)(          \
            ( ( (PUCHAR)(SrcAddress) )[0]       ) | \
            ( ( (PUCHAR)(SrcAddress) )[1] <<  8 )   \
            )
#endif
#else
#define SmbGetUshort(SrcAddress) (USHORT)(                  \
            ( ( (PUCHAR)(SrcAddress ## S) )[0]       ) |    \
            ( ( (PUCHAR)(SrcAddress ## S) )[1] <<  8 )      \
            )
#endif

#else

USHORT
SmbGetUshort (
    IN PSMB_USHORT SrcAddress
    );

#endif

//++
//
// USHORT
// SmbGetAlignedUshort (
//     IN PUSHORT SrcAddress
//     )
//
// Routine Description:
//
//     This macro retrieves a USHORT value from the source address,
//     correcting for the endian characteristics of the server if
//     necessary.
//
// Arguments:
//
//     SrcAddress - where to retrieve USHORT value from; must be aligned.
//
// Return Value:
//
//     USHORT - the value retrieved.  The target must be aligned.
//
//--

#if !SMBDBG

#if !SMBDBG1
#define SmbGetAlignedUshort(SrcAddress) *(SrcAddress)
#else
#define SmbGetAlignedUshort(SrcAddress) *(SrcAddress ## S)
#endif

#else

USHORT
SmbGetAlignedUshort (
    IN PUSHORT SrcAddress
    );

#endif

//++
//
// VOID
// SmbPutUshort (
//     OUT PSMB_USHORT DestAddress,
//     IN USHORT Value
//     )
//
// Routine Description:
//
//     This macro stores a USHORT value at the possibly misaligned
//     destination address, avoiding alignment faults.
//
// Arguments:
//
//     DestAddress - where to store USHORT value.  Address may be
//         misaligned.
//
//     Value - USHORT to store.  Value must be a constant or an aligned
//         field.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if !SMBDBG1
#if SMB_USE_UNALIGNED
#define SmbPutUshort(SrcAddress, Value) \
                            *(PSMB_USHORT)(SrcAddress) = (Value)
#else
#define SmbPutUshort(DestAddress,Value) {                   \
            ( (PUCHAR)(DestAddress) )[0] = BYTE_0(Value);   \
            ( (PUCHAR)(DestAddress) )[1] = BYTE_1(Value);   \
        }
#endif
#else
#define SmbPutUshort(DestAddress,Value) {                       \
            ( (PUCHAR)(DestAddress ## S) )[0] = BYTE_0(Value);  \
            ( (PUCHAR)(DestAddress ## S) )[1] = BYTE_1(Value);  \
        }
#endif

#else

VOID
SmbPutUshort (
    OUT PSMB_USHORT DestAddress,
    IN USHORT Value
    );

#endif

//++
//
// VOID
// SmbPutAlignedUshort (
//     OUT PUSHORT DestAddres,
//     IN USHORT Value
//     )
//
// Routine Description:
//
//     This macro stores a USHORT value from the source address,
//     correcting for the endian characteristics of the server if
//     necessary.
//
// Arguments:
//
//     DestAddress - where to store USHORT value.  Address may not be
//         misaligned.
//
//     Value - USHORT to store.  Value must be a constant or an aligned
//         field.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if !SMBDBG1
#define SmbPutAlignedUshort(DestAddress,Value) *(DestAddress) = (Value)
#else
#define SmbPutAlignedUshort(DestAddress,Value) *(DestAddress ## S) = (Value)
#endif

#else

VOID
SmbPutAlignedUshort (
    OUT PUSHORT DestAddress,
    IN USHORT Value
    );

#endif

//++
//
// VOID
// SmbMoveUshort (
//     OUT PSMB_USHORT DestAddress
//     IN PSMB_USHORT SrcAddress
//     )
//
// Routine Description:
//
//     This macro moves a USHORT value from the possibly misaligned
//     source address to the possibly misaligned destination address,
//     avoiding alignment faults.
//
// Arguments:
//
//     DestAddress - where to store USHORT value
//
//     SrcAddress - where to retrieve USHORT value from
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if !SMBDBG1
#if SMB_USE_UNALIGNED
#define SmbMoveUshort(DestAddress, SrcAddress) \
        *(PSMB_USHORT)(DestAddress) = *(PSMB_USHORT)(SrcAddress)
#else
#define SmbMoveUshort(DestAddress,SrcAddress) {                         \
            ( (PUCHAR)(DestAddress) )[0] = ( (PUCHAR)(SrcAddress) )[0]; \
            ( (PUCHAR)(DestAddress) )[1] = ( (PUCHAR)(SrcAddress) )[1]; \
        }
#endif
#else
#define SmbMoveUshort(DestAddress,SrcAddress) {                                     \
            ( (PUCHAR)(DestAddress ## S) )[0] = ( (PUCHAR)(SrcAddress ## S) )[0];   \
            ( (PUCHAR)(DestAddress ## S) )[1] = ( (PUCHAR)(SrcAddress ## S) )[1];   \
        }
#endif

#else

VOID
SmbMoveUshort (
    OUT PSMB_USHORT DestAddress,
    IN PSMB_USHORT SrcAddress
    );

#endif

//++
//
// ULONG
// SmbGetUlong (
//     IN PSMB_ULONG SrcAddress
//     )
//
// Routine Description:
//
//     This macro retrieves a ULONG value from the possibly misaligned
//     source address, avoiding alignment faults.
//
// Arguments:
//
//     SrcAddress - where to retrieve ULONG value from
//
// Return Value:
//
//     ULONG - the value retrieved.  The target must be aligned.
//
//--

#if !SMBDBG

#if !SMBDBG1
#if SMB_USE_UNALIGNED
#define SmbGetUlong(SrcAddress) *(PSMB_ULONG)(SrcAddress)
#else
#define SmbGetUlong(SrcAddress) (ULONG)(                \
            ( ( (PUCHAR)(SrcAddress) )[0]       ) |     \
            ( ( (PUCHAR)(SrcAddress) )[1] <<  8 ) |     \
            ( ( (PUCHAR)(SrcAddress) )[2] << 16 ) |     \
            ( ( (PUCHAR)(SrcAddress) )[3] << 24 )       \
            )
#endif
#else
#define SmbGetUlong(SrcAddress) (ULONG)(                    \
            ( ( (PUCHAR)(SrcAddress ## L) )[0]       ) |    \
            ( ( (PUCHAR)(SrcAddress ## L) )[1] <<  8 ) |    \
            ( ( (PUCHAR)(SrcAddress ## L) )[2] << 16 ) |    \
            ( ( (PUCHAR)(SrcAddress ## L) )[3] << 24 )      \
            )
#endif

#else

ULONG
SmbGetUlong (
    IN PSMB_ULONG SrcAddress
    );

#endif

//++
//
// USHORT
// SmbGetAlignedUlong (
//     IN PULONG SrcAddress
//     )
//
// Routine Description:
//
//     This macro retrieves a ULONG value from the source address,
//     correcting for the endian characteristics of the server if
//     necessary.
//
// Arguments:
//
//     SrcAddress - where to retrieve ULONG value from; must be aligned.
//
// Return Value:
//
//     ULONG - the value retrieved.  The target must be aligned.
//
//--

#if !SMBDBG

#if !SMBDBG1
#define SmbGetAlignedUlong(SrcAddress) *(SrcAddress)
#else
#define SmbGetAlignedUlong(SrcAddress) *(SrcAddress ## L)
#endif

#else

ULONG
SmbGetAlignedUlong (
    IN PULONG SrcAddress
    );

#endif

//++
//
// VOID
// SmbPutUlong (
//     OUT PSMB_ULONG DestAddress,
//     IN ULONG Value
//     )
//
// Routine Description:
//
//     This macro stores a ULONG value at the possibly misaligned
//     destination address, avoiding alignment faults.
//
// Arguments:
//
//     DestAddress - where to store ULONG value
//
//     Value - ULONG to store.  Value must be a constant or an aligned
//         field.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if !SMBDBG1
#if SMB_USE_UNALIGNED
#define SmbPutUlong(SrcAddress, Value) *(PSMB_ULONG)(SrcAddress) = Value
#else
#define SmbPutUlong(DestAddress,Value) {                    \
            ( (PUCHAR)(DestAddress) )[0] = BYTE_0(Value);   \
            ( (PUCHAR)(DestAddress) )[1] = BYTE_1(Value);   \
            ( (PUCHAR)(DestAddress) )[2] = BYTE_2(Value);   \
            ( (PUCHAR)(DestAddress) )[3] = BYTE_3(Value);   \
        }
#endif
#else
#define SmbPutUlong(DestAddress,Value) {                        \
            ( (PUCHAR)(DestAddress ## L) )[0] = BYTE_0(Value);  \
            ( (PUCHAR)(DestAddress ## L) )[1] = BYTE_1(Value);  \
            ( (PUCHAR)(DestAddress ## L) )[2] = BYTE_2(Value);  \
            ( (PUCHAR)(DestAddress ## L) )[3] = BYTE_3(Value);  \
        }
#endif

#else

VOID
SmbPutUlong (
    OUT PSMB_ULONG DestAddress,
    IN ULONG Value
    );

#endif

//++
//
// VOID
// SmbPutAlignedUlong (
//     OUT PULONG DestAddres,
//     IN ULONG Value
//     )
//
// Routine Description:
//
//     This macro stores a ULONG value from the source address,
//     correcting for the endian characteristics of the server if
//     necessary.
//
// Arguments:
//
//     DestAddress - where to store ULONG value.  Address may not be
//         misaligned.
//
//     Value - ULONG to store.  Value must be a constant or an aligned
//         field.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if !SMBDBG1
#define SmbPutAlignedUlong(DestAddress,Value) *(DestAddress) = (Value)
#else
#define SmbPutAlignedUlong(DestAddress,Value) *(DestAddress ## L) = (Value)
#endif

#else

VOID
SmbPutAlignedUlong (
    OUT PULONG DestAddress,
    IN ULONG Value
    );

#endif

//++
//
// VOID
// SmbMoveUlong (
//     OUT PSMB_ULONG DestAddress,
//     IN PSMB_ULONG SrcAddress
//     )
//
// Routine Description:
//
//     This macro moves a ULONG value from the possibly misaligned
//     source address to the possible misaligned destination address,
//     avoiding alignment faults.
//
// Arguments:
//
//     DestAddress - where to store ULONG value
//
//     SrcAddress - where to retrieve ULONG value from
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if !SMBDBG1
#if SMB_USE_UNALIGNED
#define SmbMoveUlong(DestAddress,SrcAddress) \
        *(PSMB_ULONG)(DestAddress) = *(PSMB_ULONG)(SrcAddress)
#else
#define SmbMoveUlong(DestAddress,SrcAddress) {                          \
            ( (PUCHAR)(DestAddress) )[0] = ( (PUCHAR)(SrcAddress) )[0]; \
            ( (PUCHAR)(DestAddress) )[1] = ( (PUCHAR)(SrcAddress) )[1]; \
            ( (PUCHAR)(DestAddress) )[2] = ( (PUCHAR)(SrcAddress) )[2]; \
            ( (PUCHAR)(DestAddress) )[3] = ( (PUCHAR)(SrcAddress) )[3]; \
        }
#endif
#else
#define SmbMoveUlong(DestAddress,SrcAddress) {                                      \
            ( (PUCHAR)(DestAddress ## L) )[0] = ( (PUCHAR)(SrcAddress ## L) )[0];   \
            ( (PUCHAR)(DestAddress ## L) )[1] = ( (PUCHAR)(SrcAddress ## L) )[1];   \
            ( (PUCHAR)(DestAddress ## L) )[2] = ( (PUCHAR)(SrcAddress ## L) )[2];   \
            ( (PUCHAR)(DestAddress ## L) )[3] = ( (PUCHAR)(SrcAddress ## L) )[3];   \
        }
#endif

#else

VOID
SmbMoveUlong (
    OUT PSMB_ULONG DestAddress,
    IN PSMB_ULONG SrcAddress
    );

#endif

//++
//
// VOID
// SmbPutDate (
//     OUT PSMB_DATE DestAddress,
//     IN SMB_DATE Value
//     )
//
// Routine Description:
//
//     This macro stores an SMB_DATE value at the possibly misaligned
//     destination address, avoiding alignment faults.  This macro
//     is different from SmbPutUshort in order to be able to handle
//     funny bitfield / big-endian interactions.
//
// Arguments:
//
//     DestAddress - where to store SMB_DATE value
//
//     Value - SMB_DATE to store.  Value must be a constant or an
//         aligned field.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if SMB_USE_UNALIGNED
#define SmbPutDate(DestAddress,Value) (DestAddress)->Ushort = (Value).Ushort
#else
#define SmbPutDate(DestAddress,Value) {                                     \
            ( (PUCHAR)&(DestAddress)->Ushort )[0] = BYTE_0((Value).Ushort); \
            ( (PUCHAR)&(DestAddress)->Ushort )[1] = BYTE_1((Value).Ushort); \
        }
#endif

#else

VOID
SmbPutDate (
    OUT PSMB_DATE DestAddress,
    IN SMB_DATE Value
    );

#endif

//++
//
// VOID
// SmbMoveDate (
//     OUT PSMB_DATE DestAddress,
//     IN PSMB_DATE SrcAddress
//     )
//
// Routine Description:
//
//     This macro copies an SMB_DATE value from the possibly misaligned
//     source address, avoiding alignment faults.  This macro is
//     different from SmbGetUshort in order to be able to handle funny
//     bitfield / big-endian interactions.
//
//     Note that there is no SmbGetDate because of the way SMB_DATE is
//     defined.  It is a union containing a USHORT and a bitfield
//     struct.  The caller of an SmbGetDate macro would have to
//     explicitly use one part of the union.
//
// Arguments:
//
//     DestAddress - where to store SMB_DATE value.  MUST BE ALIGNED!
//
//     SrcAddress - where to retrieve SMB_DATE value from
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if SMB_USE_UNALIGNED
#define SmbMoveDate(DestAddress,SrcAddress)     \
            (DestAddress)->Ushort = (SrcAddress)->Ushort
#else
#define SmbMoveDate(DestAddress,SrcAddress)                         \
            (DestAddress)->Ushort =                                 \
                ( ( (PUCHAR)&(SrcAddress)->Ushort )[0]       ) |    \
                ( ( (PUCHAR)&(SrcAddress)->Ushort )[1] <<  8 )
#endif

#else

VOID
SmbMoveDate (
    OUT PSMB_DATE DestAddress,
    IN PSMB_DATE SrcAddress
    );

#endif

//++
//
// VOID
// SmbZeroDate (
//     IN PSMB_DATE Date
//     )
//
// Routine Description:
//
//     This macro zeroes a possibly misaligned SMB_DATE field.
//
// Arguments:
//
//     Date - Pointer to SMB_DATE field to zero.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if SMB_USE_UNALIGNED
#define SmbZeroDate(Date) (Date)->Ushort = 0
#else
#define SmbZeroDate(Date) {                     \
            ( (PUCHAR)&(Date)->Ushort )[0] = 0; \
            ( (PUCHAR)&(Date)->Ushort )[1] = 0; \
        }
#endif

#else

VOID
SmbZeroDate (
    IN PSMB_DATE Date
    );

#endif

//++
//
// BOOLEAN
// SmbIsDateZero (
//     IN PSMB_DATE Date
//     )
//
// Routine Description:
//
//     This macro returns TRUE if the supplied SMB_DATE value is zero.
//
// Arguments:
//
//     Date - Pointer to SMB_DATE value to check.  MUST BE ALIGNED!
//
// Return Value:
//
//     BOOLEAN - TRUE if Date is zero, else FALSE.
//
//--

#if !SMBDBG

#define SmbIsDateZero(Date) ( (Date)->Ushort == 0 )

#else

BOOLEAN
SmbIsDateZero (
    IN PSMB_DATE Date
    );

#endif

//++
//
// VOID
// SmbPutTime (
//     OUT PSMB_TIME DestAddress,
//     IN SMB_TIME Value
//     )
//
// Routine Description:
//
//     This macro stores an SMB_TIME value at the possibly misaligned
//     destination address, avoiding alignment faults.  This macro
//     is different from SmbPutUshort in order to be able to handle
//     funny bitfield / big-endian interactions.
//
// Arguments:
//
//     DestAddress - where to store SMB_TIME value
//
//     Value - SMB_TIME to store.  Value must be a constant or an
//         aligned field.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if SMB_USE_UNALIGNED
#define SmbPutTime(DestAddress,Value) (DestAddress)->Ushort = (Value).Ushort
#else
#define SmbPutTime(DestAddress,Value) {                                     \
            ( (PUCHAR)&(DestAddress)->Ushort )[0] = BYTE_0((Value).Ushort); \
            ( (PUCHAR)&(DestAddress)->Ushort )[1] = BYTE_1((Value).Ushort); \
        }
#endif

#else

VOID
SmbPutTime (
    OUT PSMB_TIME DestAddress,
    IN SMB_TIME Value
    );

#endif

//++
//
// VOID
// SmbMoveTime (
//     OUT PSMB_TIME DestAddress,
//     IN PSMB_TIME SrcAddress
//     )
//
// Routine Description:
//
//     This macro copies an SMB_TIME value from the possibly
//     misaligned source address, avoiding alignment faults.  This macro
//     is different from SmbGetUshort in order to be able to handle
//     funny bitfield / big-endian interactions.
//
//     Note that there is no SmbGetTime because of the way SMB_TIME is
//     defined.  It is a union containing a USHORT and a bitfield
//     struct.  The caller of an SmbGetTime macro would have to
//     explicitly use one part of the union.
//
// Arguments:
//
//     DestAddress - where to store SMB_TIME value.  MUST BE ALIGNED!
//
//     SrcAddress - where to retrieve SMB_TIME value from
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if SMB_USE_UNALIGNED
#define SmbMoveTime(DestAddress,SrcAddress) \
                (DestAddress)->Ushort = (SrcAddress)->Ushort
#else
#define SmbMoveTime(DestAddress,SrcAddress)                         \
            (DestAddress)->Ushort =                                 \
                ( ( (PUCHAR)&(SrcAddress)->Ushort )[0]       ) |    \
                ( ( (PUCHAR)&(SrcAddress)->Ushort )[1] <<  8 )
#endif

#else

VOID
SmbMoveTime (
    OUT PSMB_TIME DestAddress,
    IN PSMB_TIME SrcAddress
    );

#endif

//++
//
// VOID
// SmbZeroTime (
//     IN PSMB_TIME Time
//     )
//
// Routine Description:
//
//     This macro zeroes a possibly misaligned SMB_TIME field.
//
// Arguments:
//
//     Time - Pointer to SMB_TIME field to zero.
//
// Return Value:
//
//     None.
//
//--

#if !SMBDBG

#if SMB_USE_UNALIGNED
#define SmbZeroTime(Time) (Time)->Ushort = 0
#else
#define SmbZeroTime(Time) {                     \
            ( (PUCHAR)&(Time)->Ushort )[0] = 0; \
            ( (PUCHAR)&(Time)->Ushort )[1] = 0; \
        }
#endif

#else

VOID
SmbZeroTime (
    IN PSMB_TIME Time
    );

#endif

//++
//
// BOOLEAN
// SmbIsTimeZero (
//     IN PSMB_TIME Time
//     )
//
// Routine Description:
//
//     This macro returns TRUE if the supplied SMB_TIME value is zero.
//
// Arguments:
//
//     Time - Pointer to SMB_TIME value to check.  Must be aligned and
//         in native format!
//
// Return Value:
//
//     BOOLEAN - TRUE if Time is zero, else FALSE.
//
//--

#if !SMBDBG

#define SmbIsTimeZero(Time) ( (Time)->Ushort == 0 )

#else

BOOLEAN
SmbIsTimeZero (
    IN PSMB_TIME Time
    );

#endif


//
//
//      Define protocol names
//
//


//
//      PCNET1 is the original SMB protocol (CORE).
//

#define PCNET1          "PC NETWORK PROGRAM 1.0"

//
//      Some versions of the original MSNET defined this as an alternate
//      to the core protocol name
//

#define PCLAN1          "PCLAN1.0"

//
//      This is used for the MS-NET 1.03 product.  It defines Lock&Read,
//      Write&Unlock, and a special version of raw read and raw write.
//
#define MSNET103        "MICROSOFT NETWORKS 1.03"

//
//      This is the  DOS Lanman 1.0 specific protocol.  It is equivilant
//      to the LANMAN 1.0 protocol, except the server is required to
//      map errors from the OS/2 error to an appropriate DOS error.
//
#define MSNET30         "MICROSOFT NETWORKS 3.0"

//
//      This is the first version of the full LANMAN 1.0 protocol, defined in
//      the SMB FILE SHARING PROTOCOL EXTENSIONS VERSION 2.0 document.
//

#define LANMAN10        "LANMAN1.0"

//
//      This is the first version of the full LANMAN 2.0 protocol, defined in
//      the SMB FILE SHARING PROTOCOL EXTENSIONS VERSION 3.0 document.  Note
//      that the name is an interim protocol definition.  This is for
//      interoperability with IBM LAN SERVER 1.2
//

#define LANMAN12        "LM1.2X002"

//
//      This is the dos equivilant of the LANMAN12 protocol.  It is identical
//      to the LANMAN12 protocol, but the server will perform error mapping
//      to appropriate DOS errors.
//
#define DOSLANMAN12     "DOS LM1.2X002" /* DOS equivalant of above.  Final
                                         * string will be "DOS LANMAN2.0" */

//
//      Strings for LANMAN 2.1.
//
#define LANMAN21 "LANMAN2.1"
#define DOSLANMAN21 "DOS LANMAN2.1"

//
//       !!! Do not set to final protcol string until the spec
//           is cast in stone.
//
//       The SMB protocol designed for NT.  This has special SMBs
//       which duplicate the NT semantics.
//
#define NTLANMAN "NT LM 0.12"


//
//      The XENIXCORE dialect is a bit special.  It is identical to core,
//      except user passwords are not to be uppercased before being shipped
//      to the server
//
#define XENIXCORE       "XENIX CORE"


//
//      Windows for Workgroups V1.0
//
#define WFW10           "Windows for Workgroups 3.1a"


#define PCNET1_SZ       22
#define PCLAN1_SZ        8

#define MSNET103_SZ     23
#define MSNET30_SZ      22

#define LANMAN10_SZ      9
#define LANMAN12_SZ      9

#define DOSLANMAN12_SZ  13



/*
 * Defines and data for Negotiate Protocol
 */
#define PC1             0
#define PC2             1
#define LM1             2
#define MS30            3
#define MS103           4
#define LM12            5
#define DOSLM12         6


/*  Protocol indexes definition.  */
#define PCLAN           1               /* PC Lan 1.0 & MS Lan 1.03 */
#define MSNT30          2               /* MS Net 3.0 redirector    */
#define DOSLM20         3               /* Dos LAN Manager 2.0      */
#define LANMAN          4               /* Lanman redirector        */
#define LANMAN20        5               /* Lan Manager 2.0          */

//
//  Protocol specific path constraints.
//

#define MAXIMUM_PATHLEN_LANMAN12        260
#define MAXIMUM_PATHLEN_CORE            128

#define MAXIMUM_COMPONENT_LANMAN12      254
#define MAXIMUM_COMPONENT_CORE          8+1+3 // 8.3 filenames.



#endif // _CIFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\buffring.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    buffring.h

Abstract:

    This module defines the change buffering state requests related data structures in RDBSS.

Author:

    Balan Sethu Raman (SethuR) 11-Nov-95    Created

Notes:

    The buffering manager implementation consists of two primary data structures
    (1) CHANGE_BUFFERING_STATE_REQUEST and (2) BUFFERING_MANAGER.

    The BUFFERING_MANAGER tracks and initiates actions on all change buffering state
    requests generated by the various mini redirectors as well as the RDBSS.

    There are three lists associated with the buffering manager, i.e., the registration
    list, the dispatcher list and the handler list.

    The registration list contains all the requests initiated for which no processing
    has been done. All DPC level indications merely register the indication in this
    list. The access to this list is protected by a spin lock(RxStrucsupSpinLock).

    The dispatcher list contains all the requests for which the lookup has not been
    completed. This list is organized as a two tier list. The top level is based on
    the NetRootKey. Each entry for a NetRootKey in this list has an associated cluster
    of requests corresponding to the various SrvOpenKey's. This is the reason for
    ghaving two LIST_ENTRY's in the request data structure as well. The
    NetRootListEntry field is used for inter cluster threading and the listEntry
    field is used for intra cluster threading.

    The handler list consists of all the requests for which the lookup has been completed
    and are awaiting processing.

    The dispatcher list and the handler list access is protected by the buffering manager
    mutex.

    The three routines of interest to mini rdr writers are ...

    1) RxIndicateChangeOfBufferingState -- for registering the request.

    2) RxAssociateSrvOpenKey -- for associating a SRV_OPEN instance with the key.


    Note that the key associations are irreverisble and will last the lifetime of the
    associated SRV_OPEN.

    Also note that 0 and 0xffffffff are not valid keys for SRV_OPEN. It has special
    significance for the buffering manager.

--*/

#ifndef __BUFFRING_H__
#define __BUFFRING_H__

#define RX_REQUEST_PREPARED_FOR_HANDLING  (0x10000000)

typedef struct _CHANGE_BUFFERING_STATE_REQUEST_ {
   LIST_ENTRY     ListEntry;

   ULONG          Flags;

   PSRV_CALL      pSrvCall;
   PSRV_OPEN      pSrvOpen;

   PVOID          SrvOpenKey;
   PVOID          pMRxContext;
} CHANGE_BUFFERING_STATE_REQUEST, *PCHANGE_BUFFERING_STATE_REQUEST;

typedef struct _RX_BUFFERING_MANAGER_ {

   BOOLEAN            fDispatcherActive;
   BOOLEAN            fNoWaitHandlerActive;
   BOOLEAN            fLastChanceHandlerActive;
   UCHAR              Pad;

   KSPIN_LOCK         SpinLock;

   // This count is always incremented and never reset. This provides us with
   // a quick mechanism to establish if a buffering state change request has
   // been received for a given srvcall since a point in time.
   LONG               CumulativeNumberOfBufferingChangeRequests;

   LONG               NumberOfUnhandledRequests;
   LONG               NumberOfUndispatchedRequests;
   LONG               NumberOfOutstandingOpens;

   LIST_ENTRY         DispatcherList;
   LIST_ENTRY         HandlerList;
   LIST_ENTRY         LastChanceHandlerList;

   RX_WORK_QUEUE_ITEM DispatcherWorkItem;
   RX_WORK_QUEUE_ITEM HandlerWorkItem;
   RX_WORK_QUEUE_ITEM LastChanceHandlerWorkItem;

   FAST_MUTEX         Mutex;
   LIST_ENTRY         SrvOpenLists[1];
} RX_BUFFERING_MANAGER, *PRX_BUFFERING_MANAGER;

#define RxAcquireBufferingManagerMutex(pBufferingManager)               \
        {                                                               \
           if (!ExTryToAcquireFastMutex(&(pBufferingManager)->Mutex)) {   \
              ExAcquireFastMutex(&(pBufferingManager)->Mutex);            \
           }                                                            \
        }

#define RxReleaseBufferingManagerMutex(pBufferingManager)               \
        ExReleaseFastMutex(&(pBufferingManager)->Mutex)

extern VOID
RxpProcessChangeBufferingStateRequests(
      PSRV_CALL  pSrvCall,
      BOOLEAN    UpdateHandlerState);

extern VOID
RxProcessChangeBufferingStateRequests(
      PSRV_CALL  pSrvCall);

extern VOID
RxProcessFcbChangeBufferingStateRequest(
      PFCB  pFcb);

extern VOID
RxPurgeChangeBufferingStateRequestsForSrvOpen(
      PSRV_OPEN   pSrvOpen);

extern VOID
RxCompleteSrvOpenKeyAssociation(
    IN OUT PSRV_OPEN    pSrvOpen);

extern VOID
RxInitiateSrvOpenKeyAssociation(
   IN OUT PSRV_OPEN pSrvOpen);

extern NTSTATUS
RxInitializeBufferingManager(
   PSRV_CALL pSrvCall);

extern NTSTATUS
RxTearDownBufferingManager(
   PSRV_CALL pSrvCall);

NTSTATUS
RxFlushFcbInSystemCache(
    IN PFCB     Fcb,
    IN BOOLEAN  SynchronizeWithLazyWriter
    );

NTSTATUS
RxPurgeFcbInSystemCache(
    IN PFCB             Fcb,
    IN PLARGE_INTEGER   FileOffset OPTIONAL,
    IN ULONG            Length,
    IN BOOLEAN          UninitializeCacheMaps,
    IN BOOLEAN          FlushFile );


#endif __BUFFRING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\fcbtable.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    fcbtable.h

Abstract:

    This module defines the data structures that facilitate management of the
    collection of FCB's associated with a NET_ROOT

Author:

    Balan Sethu Raman (SethuR)    10/17/96

Revision History:

    This was derived from the original implementation of prefix tables done
    by Joe Linn.

--*/


#ifndef _RXFCBTABLE_
#define _RXFCBTABLE_

typedef struct _RX_FCB_TABLE_ENTRY {

    // Normal Header for Refcounted Structure
    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    // the computed hash value
    ULONG      HashValue;

    // the path associated with the FCB
    UNICODE_STRING Path;

    // the threaded list of all entries in a bucket.
    LIST_ENTRY HashLinks;

    // Statistics for amortising lookup costs
    LONG       Lookups;
} RX_FCB_TABLE_ENTRY, *PRX_FCB_TABLE_ENTRY;


#define RX_FCB_TABLE_NUMBER_OF_HASH_BUCKETS 32

typedef struct _RX_FCB_TABLE {

    // Normal Header for refcounted data structures
    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    // version stamp changes on each insertion/removal
    ULONG Version;

    BOOLEAN CaseInsensitiveMatch;
    USHORT  NumberOfBuckets;

    // Statistics for table maintenance
    LONG    Lookups;
    LONG    FailedLookups;
    LONG    Compares;

    // Resource used to control table access
    ERESOURCE TableLock;

    // TableEntry for the Null string
    PRX_FCB_TABLE_ENTRY pTableEntryForNull;

    // the hash buckets
    LIST_ENTRY HashBuckets[RX_FCB_TABLE_NUMBER_OF_HASH_BUCKETS];
} RX_FCB_TABLE, *PRX_FCB_TABLE;

extern VOID
RxInitializeFcbTable(
    IN OUT PRX_FCB_TABLE pFcbTable,
    IN     BOOLEAN       CaseInsensitiveMatch);

extern VOID
RxFinalizeFcbTable(
    IN OUT PRX_FCB_TABLE pFcbTable);

extern PFCB
RxFcbTableLookupFcb(
    IN  PRX_FCB_TABLE    pFcbTable,
    IN  PUNICODE_STRING  pPath);

extern NTSTATUS
RxFcbTableInsertFcb (
    IN OUT PRX_FCB_TABLE pFcbTable,
    IN OUT PFCB          pFcb);

extern NTSTATUS
RxFcbTableRemoveFcb (
    IN OUT PRX_FCB_TABLE pFcbTable,
    IN OUT PFCB          pFcb);

#define RxAcquireFcbTableLockShared(pFcbTable,Wait) \
        ExAcquireResourceSharedLite(&(pFcbTable)->TableLock,Wait)

#define RxAcquireFcbTableLockExclusive(pFcbTable,Wait) \
        ExAcquireResourceExclusiveLite(&(pFcbTable)->TableLock,Wait)

#define RxReleaseFcbTableLock(pFcbTable)  \
        ExReleaseResourceLite(&(pFcbTable)->TableLock)

#define RxIsFcbTableLockExclusive(PTABLE) ExIsResourceAcquiredExclusiveLite(&(PTABLE)->TableLock)

#define RxIsFcbTableLockAcquired(PTABLE) ( ExIsResourceAcquiredSharedLite(&(PTABLE)->TableLock) || \
                                              ExIsResourceAcquiredExclusiveLite(&(PTABLE)->TableLock) )


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\fsctlbuf.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FsCtlBuf.h

Abstract:

    This module defines routines that get the buffers for the various types of ioctl/fsctls. It is essntially
    just the reverse of the IopXXXControlFile routine in io\internal.c, the appropriate parts of which are
    reproduced here.

Author:

    Joe Linn     [JoeLinn]    4-aug-1994

Revision History:

--*/

#ifndef _fsctlbuf_
#define _fsctlbuf_

// the presentation here is in three pieces: the macros for METHODBUFFERED, METHODDIRECT, AND METHODNEITHER.
// it's set up this way so that you can find out what you've got just by reading this and not looking thru
// IO system....

/*  here is the code for case 0
    case 0:

        //
        // For this case, allocate a buffer that is large enough to contain
        // both the input and the output buffers.  Copy the input buffer to
        // the allocated buffer and set the appropriate IRP fields.
        //

        try {

            if (InputBufferLength || OutputBufferLength) {
                irp->AssociatedIrp.SystemBuffer =
                    RxAllocatePool( poolType,
                                    (InputBufferLength > OutputBufferLength) ? InputBufferLength : OutputBufferLength );

                if (ARGUMENT_PRESENT( InputBuffer )) {
                    RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                                   InputBuffer,
                                   InputBufferLength );
                }
                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
                irp->UserBuffer = OutputBuffer;
                if (ARGUMENT_PRESENT( OutputBuffer )) {
                    irp->Flags |= IRP_INPUT_OPERATION;
                }
            } else {
                irp->Flags = 0;
                irp->UserBuffer = (PVOID) NULL;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
              <<<elided>>>
        }

        break;

So, the bottom line is that irp->AssociatedIrp.SystemBuffer is a buffer of length (I-length+O-length) and
is preloaded with the input. Even though the original outputbuffer is passed thru in irp->UserBuffer, it is not to be used
in the FS; rather the FS writes its answer into the same buffer.  we get the
following macros:

*/
#define METHODBUFFERED_SharedBuffer(IRP)     (IRP)->AssociatedIrp.SystemBuffer


/* for 1 and 2

    case 1:
    case 2:

        //
        // For these two cases, allocate a buffer that is large enough to
        // contain the input buffer, if any, and copy the information to
        // the allocated buffer.  Then build an MDL for either read or write
        // access, depending on the method, for the output buffer.  Note
        // that the buffer length parameters have been jammed to zero for
        // users if the buffer parameter was not passed.  (Kernel callers
        // should be calling the service correctly in the first place.)
        //
        // Note also that it doesn't make a whole lot of sense to specify
        // either method #1 or #2 if the IOCTL does not require the caller
        // to specify an output buffer.
        //

        try {

            if (InputBufferLength && ARGUMENT_PRESENT( InputBuffer )) {
                irp->AssociatedIrp.SystemBuffer =
                    RxAllocatePool( poolType, InputBufferLength );
                RtlCopyMemory( irp->AssociatedIrp.SystemBuffer,
                               InputBuffer,
                               InputBufferLength );
                irp->Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;
            } else {
                irp->Flags = 0;
            }

            if (OutputBufferLength != 0) {
                irp->MdlAddress = IoAllocateMdl( OutputBuffer,
                                                 OutputBufferLength,
                                                 FALSE,
                                                 TRUE,
                                                 irp  );
                if (irp->MdlAddress == NULL) {
                    ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                }
                MmProbeAndLockPages( irp->MdlAddress,
                                     requestorMode,
                                     (LOCK_OPERATION) ((method == 1) ? IoReadAccess : IoWriteAccess) );
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            <<<ELIDED>>>
        }

        break;

So the deal is that the input buffer has been copied in as in case 0 but what we have is an MDL for
the output buffer. this leads to the following
*/


#define METHODDIRECT_BufferedInputBuffer(IRP)   ((IRP)->AssociatedIrp.SystemBuffer)
#define METHODDIRECT_DirectBuffer(IRP)  (((IRP)->MdlAddress) \
                                                 ? MmGetSystemAddressForMdlSafe((IRP)->MdlAddress,NormalPagePriority):NULL)

/* and finally
    case 3:

        //
        // For this case, do nothing.  Everything is up to the driver.
        // Simply give the driver a copy of the caller's parameters and
        // let the driver do everything itself.
        //

        irp->UserBuffer = OutputBuffer;
        irpSp->Parameters.DeviceIoControl.Type3InputBuffer = InputBuffer;
    }

So we can get 'em.....but we don't really know how they're gonna be used. Nevertheless.......
*/

#define METHODNEITHER_OriginalInputBuffer(IRPSP)   ((IRPSP)->Parameters.DeviceIoControl.Type3InputBuffer)
#define METHODNEITHER_OriginalOutputBuffer(IRP)    ((IRP)->UserBuffer)


#endif    // _fsctlbuf_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\fcb.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Fcb.h

Abstract:

    This module defines File Control Block data structures, by which we mean:

       1) File Control Blocks     (FCB)
       2) File Object Extensions  (FOXB)
       3) Net Roots               (NET_ROOT)
       4) ServerSide Open Context (SRV_OPEN)
       5) Server Call Context     (SRV_CALL)
       6) View of Net Roots       (V_NET_ROOT)

    The more complete description follows the prototypes.

Author:

    Joe Linn          [JoeLinn]   19-aug-1994

Revision History:

    Balan Sethu Raman [SethuR]   1-Aug-96

--*/

#ifndef _FCB_STRUCTS_DEFINED_
#define _FCB_STRUCTS_DEFINED_

#include "fcbtable.h"
#include "buffring.h"

typedef NODE_TYPE_CODE TYPE_OF_OPEN;

struct _FCB_INIT_PACKET;
typedef struct _FCB_INIT_PACKET *PFCB_INIT_PACKET;


/* -----------------------------------------------------------
       There are six important data structures in the wrapper that are shared with the
       various mini redirectors. These data structures come in two flavours -- the
       mini redirector flavour which contains only those fields that can be manipulated
       by the mini redirector and the RDBSS flavour defined here. The mini redirector
       flavour carries the prefix MRX_.

       The six data structures are SRV_CALL,NET_ROOT,V_NET_ROOT,FCB,SRV_OPEN and FOBX
       respectively.

       The global view of these structures is the following (information on each of the
       data structures follows the locking description )

       L O C K I N G  <-------

       There are two levels of lookup tables used: a global table for srvcalls
       and netroots and a table-per-netroot for fcbs.  This allows directory
       operations on different netroots to be almost completely noninterfering
       (once the connections are established).  Directory operations on the
       same netroot do intefere slightly.  The following table describes what
       locks you need:

       OPERATION         DATATYPE              LOCK REQUIRED

       create/finalize   srvcall/(v)netroot    exclusive on netnametablelock
       ref/deref/lookup  srvcall/(v)netroot    shared on netnametablelock (at least)

       create/finalize   fcb/srvopen/fobx      exclusive on netroot->fcbtablelock
       ref/deref/lookup  fcb/srvopen/fobx      shared on netroot->fcbtablelock

       Note that manipulations on srvopens and fobxs require the same lock as
       fcbs....this is simply a memory saving idea.  It would be
       straightforward to add another resource at the fcb level to remove this;
       a set of sharted resources could be used to decrease the probability of
       collision to an acceptably low level.

       R E F   C O U N T S  <---------------

       Each of the structures is reference counted. The counts are the
       following:

       refcount(srvcall) = number of netroots pointing to srvcall + DYNAMIC
       refcount(netroot) = number of fcbs pointing to netroot + DYNAMIC
       refcount(fcb)     = number of fcbs pointing to netroot + DYNAMIC
       refcount(srvopen) = number of fcbs pointing to netroot + DYNAMIC
       refcount(fobx)    = DYNAMIC

       In each case, dynamic refers to the number of callers that have
       referenced the structure without dereferencing it. The static part of
       the refcount is maintained by the routines themselves; for example,
       CreateNetRoot increments the refcount for the associated srvcall.
       Reference and Successful Lookups increment the reference counts;
       dereference decrements the count. Creates set the reference counts to 1,

       If you require both locks (like FinalizeNetFcb), you take the fcblock
       first AND THEN the global table lock. obviously, you release in the
       opposite order.

----------------------------------*/

//
// SRV_CALL
//
// A global list of the SRV_CALL structures is maintained in the global
// data.  Each SrvCall structure has stuff that is unique to a srv_call.
// Now, the rx doesn't know what this stuff is except for
//
//     0) signature and refcount
//     a) a name and associated table stuff
//     b) a list of associated NET_ROOTs
//     c) a set of timing parameters that control how often the subrx wants
//        to be called by the rx in different circumstances (i.e. idle timouts)
//     d) the minirdr id
//     .
//     .
//     z) whatever additional storage is request by the minirdr (or creator of the block).
//
// In fact, the Unicode name of the structure is carried in the structure itself
// at the end.  The extra space begins at the end of the known stuff so that a
// mini redirector can just refer to his extra space using the context fields

// These flags are not visible to the mini redirectors.

#define SRVCALL_FLAG_NO_CONNECTION_ALLOWED (0x10000)
#define SRVCALL_FLAG_NO_WRITES_ALLOWED     (0x20000)
#define SRVCALL_FLAG_NO_DELETES_ALLOWED    (0x40000)

#ifdef __cplusplus
typedef struct _SRV_CALL : public MRX_SRV_CALL {
#else //  !__cplusplus
typedef struct _SRV_CALL {

    //
    //  The portion of SRV_CALL visible to mini redirectors.
    //

    union {
        MRX_SRV_CALL;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
        };
    };
#endif // __cplusplus

    //
    //  The finalization of a SRV_CALL instance consists of two parts,
    //  destroying the association with all NET_ROOTS etc and freeing the
    //  memory. There can be a delay between these two and this field
    //  prevents thefirst step from being duplicated.
    //

    BOOLEAN UpperFinalizationDone;

    //  
    //  Name and Prefixtable entry for name lookups
    //

    RX_PREFIX_ENTRY PrefixEntry;

    //
    //  Current condition of the SRV_CALL, i.e., good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    ULONG SerialNumberForEnum;

    //
    //  Number of delayed close files
    //

    LONG NumberOfCloseDelayedFiles;

    //
    //  List of Contexts which are waiting for the SRV_CALL transitioning
    //  to be completed before resumption of processing. This typically
    //  happens when concurrent requests are directed at a server. One of
    //  these requests initiates the construction while the other requests
    //  are queued.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Entry to thread together all the SRV_CALL instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  Synchronization context for coordinating the purge operations on the
    //  files opened at this server.
    //

    PURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext;

    //
    //  The Buffering manager for coordinating/processing the buffering state
    //  change requests of the files opened at the server.
    //

    RX_BUFFERING_MANAGER BufferingManager;
} SRV_CALL, *PSRV_CALL;

//
//  A NET_ROOT contains
//      0) signature and refcount
//      a) a name and associated table stuff
//      b) backpointer to the SRV_CALL structure
//      c) size information for the various substructures
//      d) a lookuptable of FCB structures
//      .
//      .
//      z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  A NET_ROOT is what the rx wants to deal with.....not a server.
//  Accordingly, the rx calls down to open a netroot and the subrx is
//  responsible for opening a server and calling up to put the right
//  structures.
//

#define NETROOT_FLAG_ENCLOSED_ALLOCATED       ( 0x00010000 )
#define NETROOT_FLAG_DEVICE_NETROOT           ( 0x00020000 )
#define NETROOT_FLAG_FINALIZATION_IN_PROGRESS ( 0x00040000 )
#define NETROOT_FLAG_NAME_ALREADY_REMOVED     ( 0x00080000 )

#define NETROOT_INIT_KEY (0)

#ifdef __cplusplus
typedef struct _NET_ROOT : public MRX_NET_ROOT {
#else // !__cplusplus
typedef struct _NET_ROOT {

    //
    //  The porion of NET_ROOT instance visible to mini redirectors.
    //

    union {
        MRX_NET_ROOT;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PSRV_CALL SrvCall;
        };
    };
#endif //  __cplusplus

    //
    //  The finalization of a NET_ROOT instance consists of two parts,
    //  destroying the association with all V_NET_ROOTS etc and freeing the
    //  memory. There can be a delay between these two and this field
    //  prevents thefirst step from being duplicated.
    //

    BOOLEAN UpperFinalizationDone;

    //
    //  Current condition of the NET_ROOT, i.e., good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  List of Contexts which are waiting for the NET_ROOT transitioning
    //  to be completed before resumption of processing. This typically
    //  happens when concurrent requests are directed at a server. One of
    //  these requests initiates the construction while the other requests
    //  are queued.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Entry to thread together all the NET_ROOT instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  Synchronization context for coordinating the purge operations on the
    //  files opened for this NET_ROOt
    //

    PURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext;

    //
    //  The default V_NET_ROOT instance to be used on this NET_ROOT
    //

    PV_NET_ROOT DefaultVNetRoot;

    //
    //  list of V_NET_ROOTs associated with the NET_ROOT
    //

    LIST_ENTRY VirtualNetRoots;

    //
    //  the count of V_NET_ROOT instances associated with the NET_ROOT
    //

    ULONG NumberOfVirtualNetRoots;

    ULONG  SerialNumberForEnum;

    //
    //  NET_ROOT name and prefix table entry
    //

    RX_PREFIX_ENTRY PrefixEntry;

    //
    //  the FCB's associated with this NET_ROOT
    //

    RX_FCB_TABLE FcbTable;
} NET_ROOT, *PNET_ROOT;

//
//  A V_NETROOT contains
//     0) signature and refcount
//     a) ptr to netroot and links.
//     b) name info for table lookup (prefix)
//     c) name for a prefix to be added to whatever name you see. this is for simulating a netroot
//     mapped not at the root of the actual netroot.
//

#ifdef __cplusplus
typedef struct _V_NET_ROOT : public MRX_V_NET_ROOT {
#else //  !__cplusplus
typedef struct _V_NET_ROOT {

    //
    //  the portion of V_NET_ROOT visible to mini redirectors
    //

    union {
        MRX_V_NET_ROOT;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PNET_ROOT NetRoot;
        };
    };
#endif //  __cplusplus

    //
    //  The finalization of a V_NET_ROOT instance consists of two parts,
    //  destroying the association with all FCBs etc and freeing the
    //  memory. There can be a delay between these two and this field
    //  prevents thefirst step from being duplicated.
    //

    BOOLEAN UpperFinalizationDone;

    BOOLEAN ConnectionFinalizationDone;

    //
    //  Current condition of the V_NET_ROOT, i.e., good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  Additional reference for the Delete FSCTL. This field is long as
    //  opposed to a BOOLEAN eventhough it can have only one of two values
    //  0 or 1. This enables the usage of interlocked instructions
    //

    LONG AdditionalReferenceForDeleteFsctlTaken;

    //
    //  Prefix table entry and V_NET_ROOT name ( prefix table entry is inserted
    //  in the RxNetNameTable)
    //

    RX_PREFIX_ENTRY PrefixEntry;

    //
    //  this name is prepended to all fcbs (not currently used)
    //

    UNICODE_STRING NamePrefix;

    //
    //  amount of bytes required to get past the netroot
    //

    ULONG PrefixOffsetInBytes;

    //
    //  List entry to wire the V_NET_ROOT instance into a list of V_NET_ROOTS
    //  maintained in the NET_ROOT
    //

    LIST_ENTRY NetRootListEntry;

    ULONG SerialNumberForEnum;

    //
    //  List of Contexts which are waiting for the NET_ROOT transitioning
    //  to be completed before resumption of processing. This typically
    //  happens when concurrent requests are directed at a server. One of
    //  these requests initiates the construction while the other requests
    //  are queued.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Entry to thread together all the V_NET_ROOT instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;
} V_NET_ROOT, *PV_NET_ROOT;

#define FILESIZE_LOCK_DISABLED(x)

//
//  An FCB contains
//      0) FSRTL_COMMON_HEADER
//      1) a reference count
//      a) a name and associated table stuff
//      b) backpointer to the NET_ROOT structure
//      c) a list of SRV_OPEN structures
//      d) device object
//      e) dispatch table (not yet)
//      .
//      .
//      z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  The FCB is pointed to by the FsContext Field in the file object.  The
//  rule is that all the guys sharing an FCB are talking about the same
//  file.  (unfortuantely, SMB servers are implemented today in such a way
//  that names are aliased so that two different names could be the same
//  actual file.....sigh!) The Fcb is the focal point of file
//  operations...since operations on the same FCB are actually on the same
//  file, synchronization is based on the Fcb rather than some higher level
//  (the levels described so far are lower, i.e.  farther from the user).
//  Again, we will provide for colocation of FCB/SRV_OPEN/FOBX to improve
//  paging behaviour.  We don't colocate the FCB and NET_ROOT because the
//  NET_ROOTs are not paged but FCBs usually are (i.e.  unless they are
//  paging files).
//
//  The Fcb record corresponds to every open file and directory and is is split up into
//  two portions a non paged part, i.e., an instance allocated in non paged pool and
//  a paged part. The former is the NON_PAGED_FCB and the later is referred to as FCB.
//  The FCB conatins a pointer to the corresponding NON_PAGED_FCB part. A backpointer
//  is maintained from the NON_PAGED_FCB to the FCB for debugging purposes in debug builds
//

typedef struct _NON_PAGED_FCB {

    //
    //  Struct type and size for debugging/tracking
    //

    NODE_TYPE_CODE     NodeTypeCode;
    NODE_BYTE_SIZE     NodeByteSize;

    //
    //  The following field contains a record of special pointers used by
    //  MM and Cache to manipluate section objects.  Note that the values
    //  are set outside of the file system.  However the file system on an
    //  open/create will set the file object's SectionObject field to point
    //  to this field
    //

    SECTION_OBJECT_POINTERS SectionObjectPointers;

    //
    //  This resource is used in the common fsrtl routines....allocated here for
    //  space locality.
    //

    ERESOURCE HeaderResource;

    //
    //  This resource is also used in the common fsrtl routines....allocated here for
    //  space locality.
    //

    ERESOURCE PagingIoResource;

#ifdef USE_FILESIZE_LOCK

    //
    //  This mutex protect the filesize during read/write
    //

    FAST_MUTEX FileSizeLock;

#endif

    //
    //  The list of contexts whose processing has been suspended pending the state
    //  transition of the FCB.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  This context is non-zero only if the file currently has asynchronous
    //  non-cached valid data length extending writes.  It allows
    //  synchronization between pending writes and other operations.
    //

    ULONG OutstandingAsyncWrites;

    //
    //  This event is set when OutstandingAsyncWrites transitions to zero.
    //

    PKEVENT OutstandingAsyncEvent;

    KEVENT TheActualEvent;

    //
    //  The mechanism for the mini redirectors to store additional information
    //

    PVOID MiniRdrContext[2];

    //
    //  This is the mutex that is inserted into the FCB_ADVANCED_HEADER
    //  FastMutex field
    //

    FAST_MUTEX AdvancedFcbHeaderMutex;

#if DBG
    PFCB FcbBackPointer;
#endif

} NON_PAGED_FCB, *PNON_PAGED_FCB;

typedef enum _FCB_CONDITION {
    FcbGood = 1,
    FcbBad,
    FcbNeedsToBeVerified
} FCB_CONDITION;

//
//  A enumerated type distinguishing the varios contexts under which the FCB resource
//  is accquired.
//

typedef enum _RX_FCBTRACKER_CASES {
    RX_FCBTRACKER_CASE_NORMAL,
    RX_FCBTRACKER_CASE_NULLCONTEXT,
    RX_FCBTRACKER_CASE_CBS_CONTEXT,
    RX_FCBTRACKER_CASE_CBS_WAIT_CONTEXT,
    RX_FCBTRACKER_CASE_MAXIMUM
} RX_FCBTRACKER_CASES;

#ifdef __cplusplus
typedef struct _FCB : public MRX_FCB {
#else //  !__cplusplus
typedef struct _FCB {
    
    //
    //  Entries are reference counted. ordinarily this would be at the beginning but
    //  in the case of FCB's it will follows the common header and fixed part
    //

    union {
        MRX_FCB;
        struct {
           FSRTL_ADVANCED_FCB_HEADER spacer;
           PNET_ROOT NetRoot;
        };
    };
#endif //  !__cplusplus

    //
    //  VNetroot for this FCB, if any
    //

    PV_NET_ROOT VNetRoot;  

    //
    //  Structure for fields that must be in non-paged pool.
    //

    PNON_PAGED_FCB NonPaged;

    //
    //  List Entry to thread together all the FCB instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  The resource accquisition mechanism gives preference to buffering state change
    //  processing over other requests. Therefor when a buffering state change is
    //  indicated all subsequent requests are shunted off to wait on a buffering state
    //  change completion event. This enables the actual buffering state change processing
    //  to complete in a timely fashion.
    //

    PKEVENT pBufferingStateChangeCompletedEvent;

    //
    //  Number of contexts awaiting buffering state change processing completion
    //

    LONG NumberOfBufferingStateChangeWaiters;

    //
    //  the name in the table is always a suffix of the name as viewed by the mini
    //  redirector. the string in the prefix entry is the name in the table....
    //  the "alreadyprefixedname: points to the whole name.
    //

    RX_FCB_TABLE_ENTRY FcbTableEntry;

    //
    //  the name alongwith the MRX_NET_ROOT prefix, i.e. fully qualified name
    //

    UNICODE_STRING PrivateAlreadyPrefixedName;

    //
    //  Indicates that the V_NET_ROOT related processing on finalization is complete
    //

    BOOLEAN UpperFinalizationDone;

    //
    //  the present state of the FCB, good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  Pointer to the private dispatch table, if any.
    //

    PRX_FSD_DISPATCH_VECTOR PrivateDispatchVector;

    //
    //  the device object that owns this fcb
    //

    PRDBSS_DEVICE_OBJECT RxDeviceObject;

    PMINIRDR_DISPATCH MRxDispatch;

    //
    //	private fast dispatch table, if any. This allows lwio to add it's own hooks
    //

    PFAST_IO_DISPATCH MRxFastIoDispatch;

    //
    //  Whenever a  FCB instance is created a correpsonding SRV_OPEN and FOBX instance
    //  is also created. More than one SRV_OPEN can be associated with a given FCB and
    //  more than one FOBX is associated with a given SRV_OPEN. In a majority of the
    //  cases the number of SRV_OPENs associated with an FCB is one and the number of
    //  FOBX associated with a given SRV_OPEN is 1. In order to improve the spatial
    //  locality and the paging behaviour in such cases the allocation for the
    //  FCB also involves an allocation for the SRV_OPEN and FOBX.
    //

    //
    //  set initially to the internally allocated srv_open
    //

    PSRV_OPEN InternalSrvOpen;

    //
    //  set to internal fobx until allocated
    //

    PFOBX InternalFobx;

    //
    //  the shared access for each time this file/directory is opened.
    //

    SHARE_ACCESS ShareAccess;
    SHARE_ACCESS ShareAccessPerSrvOpens;

    //
    //  this information is returned when the file is opened. ..might as well
    //  cache it so that so that tandard info query can be handled on the client
    //  side
    //

    ULONG NumberOfLinks;

    //
    //  Cache these entries..... speeds up RxFastQueryBasicInfo().
    //

    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER LastChangeTime;

    //
    //  this thread is one who has acquired the FCB for CreateSection. it is used
    //  to deduce whether certain operations (notably queryfileinfo) have preacquired
    //  the resources and will, therefore, run without blocking.
    //

    PETHREAD CreateSectionThread;

    //
    //  used to check by mini redirs in order to decide whether to update the FCB
    //

    ULONG ulFileSizeVersion;

    //
    //  The following union is cased off of the node type code for the fcb.
    //  There is a seperate case for the directory versus file fcbs.
    //

    union {

        //
        //  A File Control Block (Fcb)
        //

        struct {
            
            //
            //  The following field will be used by the oplock module
            //  to maintain current oplock information. BUT we dont do it
            //  yet
            //

            //  OPLOCK Oplock;

            //
            //  The following field is used by the filelock module
            //  to maintain current byte range locking information.
            //

            FILE_LOCK FileLock;

            //
            //  This pointer is used to detect writes that eminated in the
            //  cache manager's lazywriter.  It prevents lazy writer threads,
            //  who already have the Fcb shared, from trying to acquire it
            //  exclusive, and thus causing a deadlock.
            //

            PVOID LazyWriteThread;

            //
            //  do this wierdly so that I can call stuff be the inner or outer names
            //

            union {
#ifndef __cplusplus
                LOWIO_PER_FCB_INFO;
#endif // __cplusplus
                LOWIO_PER_FCB_INFO LowIoPerFcbInfo;
            };

#ifdef USE_FILESIZE_LOCK
            PFAST_MUTEX FileSizeLock;
#endif

        } Fcb;

    } Specific;

    //
    //  The following field is used to verify that the Ea's for a file
    //  have not changed between calls to query for Ea's.  It is compared
    //  with a similar field in a Fobx.
    //
    //  IMPORTANT!! **** DO NOT MOVE THIS FIELD ****
    //
    //              The slack space in the union above is computed from
    //              the field offset of the EaModificationCount.
    //

    ULONG EaModificationCount;

#if DBG
    PNON_PAGED_FCB CopyOfNonPaged;     //  copy of NonPaged so we can zap the real pointer and still find it
#endif
#ifdef RDBSS_TRACKER
    ULONG FcbAcquires[RX_FCBTRACKER_CASE_MAXIMUM]; //  there are four types
    ULONG FcbReleases[RX_FCBTRACKER_CASE_MAXIMUM];
#else
#error tracker must be defined
#endif

    PCHAR PagingIoResourceFile;
    ULONG PagingIoResourceLine;

} FCB, *PFCB;

//
//  Here are the Fcb state fields.
//

#define FCB_STATE_SRVOPEN_USED                   ( 0x80000000 )
#define FCB_STATE_FOBX_USED                      ( 0x40000000 )
#define FCB_STATE_ADDEDBACKSLASH                 ( 0x20000000 )
#define FCB_STATE_NAME_ALREADY_REMOVED           ( 0x10000000 )
#define FCB_STATE_WRITECACHEING_ENABLED          ( 0x08000000 )
#define FCB_STATE_WRITEBUFFERING_ENABLED         ( 0x04000000 )
#define FCB_STATE_READCACHEING_ENABLED           ( 0x02000000 )
#define FCB_STATE_READBUFFERING_ENABLED          ( 0x01000000 )
#define FCB_STATE_OPENSHARING_ENABLED            ( 0x00800000 )
#define FCB_STATE_COLLAPSING_ENABLED             ( 0x00400000 )
#define FCB_STATE_LOCK_BUFFERING_ENABLED         ( 0x00200000 )
#define FCB_STATE_FILESIZECACHEING_ENABLED       ( 0x00100000 )
#define FCB_STATE_FILETIMECACHEING_ENABLED       ( 0x00080000 )
#define FCB_STATE_TIME_AND_SIZE_ALREADY_SET      ( 0x00040000 )
#define FCB_STATE_SPECIAL_PATH                   ( 0x00020000 )
#define FCB_STATE_FILE_IS_SHADOWED               ( 0x00010000 )
#define FCB_STATE_FILE_IS_DISK_COMPRESSED        ( 0x00008000 )
#define FCB_STATE_FILE_IS_BUF_COMPRESSED         ( 0x00004000 )
#define FCB_STATE_BUFFERSTATE_CHANGING           ( 0x00002000 )
#define FCB_STATE_FAKEFCB                        ( 0x00001000 )
#define FCB_STATE_DELAY_CLOSE                    ( 0x00000800 )
#define FCB_STATE_READAHEAD_DEFERRED             ( 0x00000100 )
#define FCB_STATE_ORPHANED                       ( 0x00000080 )
#define FCB_STATE_BUFFERING_STATE_CHANGE_PENDING ( 0x00000040 )
#define FCB_STATE_TEMPORARY                      ( 0x00000020 )
#define FCB_STATE_DISABLE_LOCAL_BUFFERING        ( 0x00000010 )
#define FCB_STATE_LWIO_ENABLED                   ( 0x00000008 )
#define FCB_STATE_PAGING_FILE                    ( 0x00000004 )
#define FCB_STATE_TRUNCATE_ON_CLOSE              ( 0x00000002 )
#define FCB_STATE_DELETE_ON_CLOSE                ( 0x00000001 )

#define FCB_STATE_BUFFERING_STATE_MASK    \
                    (( FCB_STATE_WRITECACHEING_ENABLED          \
                          | FCB_STATE_WRITEBUFFERING_ENABLED    \
                          | FCB_STATE_READCACHEING_ENABLED      \
                          | FCB_STATE_READBUFFERING_ENABLED     \
                          | FCB_STATE_OPENSHARING_ENABLED       \
                          | FCB_STATE_COLLAPSING_ENABLED        \
                          | FCB_STATE_LOCK_BUFFERING_ENABLED    \
                          | FCB_STATE_FILESIZECACHEING_ENABLED  \
                          | FCB_STATE_FILETIMECACHEING_ENABLED  ))
//
//  This is the MAX recursive resource limit.
//

#define MAX_FCB_ASYNC_ACQUIRE            (0xf000)

typedef struct _FCB_INIT_PACKET {
    PULONG pAttributes;             //  in the fcb this is DirentRxFlags;
    PULONG pNumLinks;               //  in the fcb this is NumberOfLinks;
    PLARGE_INTEGER pCreationTime;   //  these fields are the same as for the Fcb
    PLARGE_INTEGER pLastAccessTime;
    PLARGE_INTEGER pLastWriteTime;
    PLARGE_INTEGER pLastChangeTime;
    PLARGE_INTEGER pAllocationSize; //  common header fields
    PLARGE_INTEGER pFileSize;
    PLARGE_INTEGER pValidDataLength;
} FCB_INIT_PACKET;

//
//  A SRV_OPEN contains
//      0) signature and refcount
//      a) backpointer to the FCB
//      b) backpointer to the NET_ROOT   //maybe
//      c) a list of FOXB structures
//      d) access rights and collapsability status
//      .
//      .
//      z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  The SRV_OPEN points to a structure describing a spevific open on the
//  server; multiple file objects and fileobject extensions (FOBXs) can
//  share the same srvopen if the access rights are correct.  For example,
//  this would be where the FID is stored for SMBs.  A list of these hangs
//  from the FCB.  Similarly, all fileobject extensionss that share the same
//  serverside open are listed together here.  Also here is information
//  about whether a new open of this FCB can share this serverside open
//  context; obviously the guys that pass the test on the list.
//

//
//  The SRVOPEN flags are split into two groups, i.e., visible to mini rdrs and invisible to mini rdrs.
//  The visible ones are defined above and the definitions for the invisible ones can be found
//  in fcb.h. The convention that has been adopted is that the lower 16 flags will be visible
//  to the mini rdr and the upper 16 flags will be reserved for the wrapper. This needs to be
//  enforced in defining new flags.
//

#define SRVOPEN_FLAG_ENCLOSED_ALLOCATED  (0x10000)
#define SRVOPEN_FLAG_FOBX_USED           (0x20000)
#define SRVOPEN_FLAG_SHAREACCESS_UPDATED (0x40000)

#ifdef __cplusplus
typedef struct _SRV_OPEN : public MRX_SRV_OPEN {
#else //  !__cplusplus
typedef struct _SRV_OPEN {

    //
    //  the portion of SRV_OPEN visible to all the mini redirectors.
    //

    union {
        MRX_SRV_OPEN;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PFCB Fcb;       //  the Fcb for this srv_open
        };
    };
#endif //  !__cplusplus

    BOOLEAN UpperFinalizationDone;

    //
    //  the current condition of the SRV_OPEN, good/bad/in transition
    //

    RX_BLOCK_CONDITION Condition;

    //
    //  Buffering state manager token
    //

    LONG BufferingToken;

    //
    //  List Entry to thread together all the FCB instances marked
    //  for garbage collection/scavenging.
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  The list of contexts whose processing has been suspended pending the state
    //  transition of the SRV_OPEN.
    //

    LIST_ENTRY TransitionWaitList;

    //
    //  List Head for the list of FOBXs associated with this SRV_OPEN
    //

    LIST_ENTRY FobxList;

    //
    //  The colocated instance of FOBX that is allocated whenever a SRV_OPEN
    //  instance is allocated.
    //

    PFOBX InternalFobx;

    //
    //  the data structure for maintaining the mapping between the key
    //  associated with the SRV_OPEN instance by the mini redirector and
    //  the SRV_OPEN instance
    //

    union {
       LIST_ENTRY SrvOpenKeyList;
       ULONG SequenceNumber;
    };
    NTSTATUS OpenStatus;
} SRV_OPEN, *PSRV_OPEN;

#define RxWriteCacheingAllowed(Fcb,SrvOpen) \
      (FlagOn( (Fcb)->FcbState, FCB_STATE_WRITECACHEING_ENABLED ) && \
       !FlagOn( (SrvOpen)->Flags, SRVOPEN_FLAG_DONTUSE_WRITE_CACHEING ))


#define SRVOPEN_INIT_KEY (0)

//
//  A FOBX contains
//     0) signature and refcount
//     a) backpointer to the FCB
//     b) backpointer to the SRV_OPEN
//     c) context information about this open
//     ...
//     z) whatever additional storage is request by the minirdr (or creator of the block).
//
//  The FOBX points to the "fileobject extension", i.e.  all the stuff that
//  is per fileobject is not stored there because the IO system provides
//  fixed size filesystem objects (not a dig BTW, that's just the decision).
//  The FOBX for any file object is referenced by the FsContext2 field in
//  the fileobject.  Even tho the FOBX is ordinarily a terminus in the
//  structure, it is currently refcounted anyway.

//  The FOBX flags are split into two groups, i.e., visible to mini rdrs and invisible to mini rdrs.
//  The visible ones are defined above and the definitions for the invisible ones can be found
//  in fcb.h. The convention that has been adopted is that the lower 16 flags will be visible
//  to the mini rdr and the upper 16 flags will be reserved for the wrapper. This needs to be
//  enforced in defining new flags.
//

#define FOBX_FLAG_MATCH_ALL               (0x10000)

//
//  This tells us whether we allocated buffers to hold search templates.
//

#define FOBX_FLAG_FREE_UNICODE            (0x20000)

//
//  These flags prevents cleanup from updating the modify time, etc.
//

#define FOBX_FLAG_USER_SET_LAST_WRITE     (0x40000)
#define FOBX_FLAG_USER_SET_LAST_ACCESS    (0x80000)
#define FOBX_FLAG_USER_SET_CREATION       (0x100000)
#define FOBX_FLAG_USER_SET_LAST_CHANGE    (0x200000)

//
//  This bit says the file object associated with this Fobx was opened for
//  read only access.
//

#define FOBX_FLAG_READ_ONLY               (0x400000)

//
//  the delete on close flag is used to track a file object that was opened with delete-on-close;
//  when this object is closed, we copy the bit to the fcb and make it global
//

#define FOBX_FLAG_DELETE_ON_CLOSE         (0x800000)

//
//  this bits is used by minirdrs that do not have NT semantics. for example, the smbmini has
//  to close a file before it can try a rename or delete. after the operation, we prevent people from
//  getting back in.
//

#define FOBX_FLAG_SRVOPEN_CLOSED          (0x1000000)

//
//  this bit is used to tell whether the original name was a UNC name so that
//  we can return the name the same way
//

#define FOBX_FLAG_UNC_NAME                (0x2000000)

//
//  this flag tells if this fobx is allocated as part of a larger structure
//

#define FOBX_FLAG_ENCLOSED_ALLOCATED      (0x4000000)

//
//  this flag specfies if the FOBX was included in the count of dormant
//  files against the server.
//

#define FOBX_FLAG_MARKED_AS_DORMANT       (0x8000000)

//
//  this flag notes down the fact that some writes have been issued on this FOBX
//  this is used to issue flushes on close
//

#define FOBX_FLAG_WRITES_ISSUED           (0x10000000)

#ifdef __cplusplus
typedef struct _FOBX : public MRX_FOBX {
#else //  !__cplusplus
typedef struct _FOBX {
    //
    //  the portion of FOBX visible to the mini redirectors
    //

    union {
        MRX_FOBX;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
           PSRV_OPEN SrvOpen;
        };
    };
#endif //  __cplusplus

    //
    //  a serial number....it wraps but not often
    //

    ULONG FobxSerialNumber;

    //
    //  list entry to wire the FOBX to the list of FOBXs maintained in
    //  the associated SRV_OPEN
    //

    LIST_ENTRY FobxQLinks;

    //
    //  list entry to gather all the FOBX instance marked for garbage collection
    //  scavenging
    //

    LIST_ENTRY ScavengerFinalizationList;

    //
    //  list entry to thread together all the FOBXs which have a pending close
    //  operation.
    //

    LIST_ENTRY ClosePendingList;

    BOOLEAN UpperFinalizationDone;
    BOOLEAN ContainsWildCards;
    BOOLEAN fOpenCountDecremented;

    //
    //  Parameters depending on the type of file opened, pipe/file etc.
    //

    union {

        struct {

            union {
#ifndef __cplusplus
                MRX_PIPE_HANDLE_INFORMATION;
#endif //  __cplusplus
                MRX_PIPE_HANDLE_INFORMATION PipeHandleInformation;
            };

            LARGE_INTEGER CollectDataTime;
            ULONG CollectDataSize;
            THROTTLING_STATE ThrottlingState;   //  for peek and read om msgmodepipes

            //
            //  these serialization Qs must be together
            //  and read must be the first
            //

            LIST_ENTRY ReadSerializationQueue;
            LIST_ENTRY WriteSerializationQueue;
        } NamedPipe;

        struct {
            RXVBO PredictedReadOffset;
            RXVBO PredictedWriteOffset;
            THROTTLING_STATE LockThrottlingState;   //  for locks
            LARGE_INTEGER LastLockOffset;
            LARGE_INTEGER LastLockRange;
        } DiskFile;
    } Specific;
} FOBX, *PFOBX;


#define FOBX_NUMBER_OF_SERIALIZATION_QUEUES 2

//
//  The RDBSS wrapper relies upon ref. counting to mark the instances of
//  various data structures. The following macros implement a debugging
//  mechanism to track/log the reference counts associated with various
//  data structures. A fine grained control to monitor each data structure
//  separately is provided. Each of these can be further controlled to either
//  print the tracking info or log it.
//

#define RDBSS_REF_TRACK_SRVCALL  (0x00000001)
#define RDBSS_REF_TRACK_NETROOT  (0x00000002)
#define RDBSS_REF_TRACK_VNETROOT (0x00000004)
#define RDBSS_REF_TRACK_NETFOBX  (0x00000008)
#define RDBSS_REF_TRACK_NETFCB   (0x00000010)
#define RDBSS_REF_TRACK_SRVOPEN  (0x00000020)

#define RX_LOG_REF_TRACKING      (0x80000000)
#define RX_PRINT_REF_TRACKING    (0x40000000)

//
//  The reference count tracking mechanism is activated by setting the following
//  variable to the appropriate value defined above.
//

extern ULONG RdbssReferenceTracingValue;

//
//  Macros for tracking the line number and the file of each reference and
//  derefernce on the data structure. on Non DBG builds they are defined as
//  NOTHING. For each data structure the appropriate reference/dereference
//  macro is defined, These should be used instead of raw manipulation of
//  the reference counts.
//

#ifdef DBG
VOID
RxpTrackReference (
    ULONG TraceType,
    PCHAR FileName,
    ULONG Line,
    PVOID Instance
    );

BOOLEAN
RxpTrackDereference (
    ULONG TraceType,
    PCHAR FileName,
    ULONG Line,
    PVOID Instance
    );

#else
#define RxpTrackReference(Type,File,Line,Instance)    NOTHING
#define RxpTrackDereference(Type,File,Line,Instance)  NOTHING
#endif

#define REF_TRACING_ON(TraceMask)  (TraceMask & RdbssReferenceTracingValue)
#define PRINT_REF_COUNT(TYPE,Count)                                 \
        if (REF_TRACING_ON( RDBSS_REF_TRACK_ ## TYPE ) &&           \
            (RdbssReferenceTracingValue & RX_PRINT_REF_TRACKING)) { \
           DbgPrint("%ld\n",Count);                                 \
        }

#define RxReferenceSrvCallAtDpc(SrvCall)                                      \
   RxpTrackReference( RDBSS_REF_TRACK_SRVCALL, __FILE__, __LINE__, SrvCall ); \
   ASSERT( SrvCall->NodeReferenceCount > 1 );                                 \
   InterlockedIncrement( &SrvCall->NodeReferenceCount )

#define RxReferenceSrvCall(SrvCall)                                           \
   RxpTrackReference( RDBSS_REF_TRACK_SRVCALL, __FILE__, __LINE__, SrvCall ); \
   RxReference( SrvCall )

#define RxDereferenceSrvCall(SrvCall,LockHoldingState)                          \
   RxpTrackDereference( RDBSS_REF_TRACK_SRVCALL, __FILE__, __LINE__, SrvCall ); \
   RxDereference(SrvCall, LockHoldingState )

#define RxReferenceNetRoot(NetRoot)                                           \
   RxpTrackReference( RDBSS_REF_TRACK_NETROOT, __FILE__, __LINE__, NetRoot ); \
   RxReference( NetRoot )

#define RxDereferenceNetRoot( NetRoot, LockHoldingState )                      \
   RxpTrackDereference( RDBSS_REF_TRACK_NETROOT, __FILE__, __LINE__, NetRoot );\
   RxDereference( NetRoot, LockHoldingState )

#define RxReferenceVNetRoot(VNetRoot)                                        \
   RxpTrackReference( RDBSS_REF_TRACK_VNETROOT, __FILE__, __LINE__, VNetRoot );\
   RxReference( VNetRoot )

#define RxDereferenceVNetRoot( VNetRoot, LockHoldingState )                       \
   RxpTrackDereference( RDBSS_REF_TRACK_VNETROOT, __FILE__, __LINE__, VNetRoot ); \
   RxDereference( VNetRoot, LockHoldingState )

#define RxReferenceNetFobx(Fobx)                                          \
   RxpTrackReference( RDBSS_REF_TRACK_NETFOBX, __FILE__, __LINE__, Fobx );      \
   RxReference( Fobx )

#define RxDereferenceNetFobx(Fobx,LockHoldingState)                       \
   RxpTrackDereference( RDBSS_REF_TRACK_NETFOBX, __FILE__, __LINE__, Fobx );    \
   RxDereference( Fobx, LockHoldingState )

#define RxReferenceSrvOpen(SrvOpen)                                           \
   RxpTrackReference( RDBSS_REF_TRACK_SRVOPEN, __FILE__, __LINE__, SrvOpen ); \
   RxReference( SrvOpen )

#define RxDereferenceSrvOpen( SrvOpen, LockHoldingState )                      \
   RxpTrackDereference( RDBSS_REF_TRACK_SRVOPEN, __FILE__, __LINE__, SrvOpen); \
   RxDereference( SrvOpen, LockHoldingState )

#define RxReferenceNetFcb(Fcb)                                            \
   RxpTrackReference( RDBSS_REF_TRACK_NETFCB, __FILE__, __LINE__, Fcb );  \
   RxpReferenceNetFcb( Fcb )

//
//  the following macros manipulate the reference count and also return the
//  status of the final derefence or finalize call. This results in the usage
//  of the , operator.
//           

#define RxDereferenceNetFcb(Fcb)  ( \
   ((LONG)RxpTrackDereference( RDBSS_REF_TRACK_NETFCB, __FILE__, __LINE__, Fcb )), \
   RxpDereferenceNetFcb( Fcb ))

#define RxDereferenceAndFinalizeNetFcb(Fcb,RxContext,RecursiveFinalize,ForceFinalize) ( \
   RxpTrackDereference( RDBSS_REF_TRACK_NETFCB, __FILE__, __LINE__, Fcb ),              \
   RxpDereferenceAndFinalizeNetFcb( Fcb, RxContext, RecursiveFinalize, ForceFinalize )) \

//
//  Check for structure alignment errors
//            

VOID
RxCheckFcbStructuresForAlignment(
    VOID
    );


//
//  SRV_CALL related routines.
//

PSRV_CALL
RxCreateSrvCall (
    IN PRX_CONTEXT RxContext,
    IN PUNICODE_STRING Name,
    IN PUNICODE_STRING InnerNamePrefix OPTIONAL,
    IN PRX_CONNECTION_ID RxConnectionId
    );


#define RxWaitForStableSrvCall(SRVCALL,RXCONTEXT) {                                  \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableSrvCall -- %lx\n",(SRVCALL)) );    \
    RxWaitForStableCondition( &(SRVCALL)->Condition, &(SRVCALL)->TransitionWaitList, (RXCONTEXT), NULL); \
    }

#define RxWaitForStableSrvCall_Async(SRVCALL,RXCONTEXT,PNTSTATUS) {                                  \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableSrvCall -- %lx\n",(SRVCALL)) );    \
    RxWaitForStableCondition( &(SRVCALL)->Condition, &(SRVCALL)->TransitionWaitList, (RXCONTEXT), (PNTSTATUS) ); \
    }

#define RxTransitionSrvCall(SRVCALL,CONDITION) \
    RxDbgTrace( 0, Dbg, ("RxTransitionSrvCall -- %lx Condition -- %ld\n",(SRVCALL),(CONDITION)) ); \
    RxUpdateCondition( (CONDITION), &(SRVCALL)->Condition, &(SRVCALL)->TransitionWaitList )

BOOLEAN
RxFinalizeSrvCall (
    OUT PSRV_CALL ThisSrvCall,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

//
// NET_ROOT related routines.
//

PNET_ROOT
RxCreateNetRoot (
    IN PSRV_CALL SrvCall,
    IN PUNICODE_STRING Name,
    IN ULONG NetRootFlags,
    IN PRX_CONNECTION_ID OPTIONAL RxConnectionId
    );

VOID
RxFinishNetRootInitialization (
    IN OUT PNET_ROOT ThisNetRoot,
    IN PMINIRDR_DISPATCH Dispatch,
    IN PUNICODE_STRING  InnerNamePrefix,
    IN ULONG FcbSize,
    IN ULONG SrvOpenSize,
    IN ULONG FobxSize,
    IN ULONG NetRootFlags
    );


#define RxWaitForStableNetRoot(NETROOT,RXCONTEXT)                                   \
    RxDbgTrace(0, Dbg, ("RxWaitForStableNetRoot -- %lx\n",(NETROOT)));    \
    RxWaitForStableCondition(&(NETROOT)->Condition,&(NETROOT)->TransitionWaitList,(RXCONTEXT),NULL)

#define RxTransitionNetRoot(NETROOT,CONDITION) \
    RxDbgTrace(0, Dbg, ("RxTransitionNetRoot -- %lx Condition -- %ld\n",(NETROOT),(CONDITION))); \
    RxUpdateCondition((CONDITION),&(NETROOT)->Condition,&(NETROOT)->TransitionWaitList)

BOOLEAN
RxFinalizeNetRoot (
    OUT PNET_ROOT ThisNetRoot,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

//
// V_NET_ROOT related routines
//

NTSTATUS
RxInitializeVNetRootParameters (
   PRX_CONTEXT RxContext,
   OUT LUID *LogonId,
   OUT PULONG SessionId,
   OUT PUNICODE_STRING *UserNamePtr,
   OUT PUNICODE_STRING *UserDomainNamePtr,
   OUT PUNICODE_STRING *PasswordPtr,
   OUT PULONG Flags
   );

VOID
RxUninitializeVNetRootParameters (
   IN PUNICODE_STRING UserName,
   IN PUNICODE_STRING UserDomainName,
   IN PUNICODE_STRING Password,
   OUT PULONG Flags
   );

PV_NET_ROOT
RxCreateVNetRoot (
    IN PRX_CONTEXT RxContext,
    IN PNET_ROOT NetRoot,
    IN PUNICODE_STRING CanonicalName,
    IN PUNICODE_STRING LocalNetRootName,
    IN PUNICODE_STRING FilePath,
    IN PRX_CONNECTION_ID RxConnectionId
    );

BOOLEAN
RxFinalizeVNetRoot (
    OUT PV_NET_ROOT ThisVNetRoot,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#define RxWaitForStableVNetRoot(VNETROOT,RXCONTEXT)                                   \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableVNetRoot -- %lx\n",(VNETROOT)) );    \
    RxWaitForStableCondition( &(VNETROOT)->Condition, &(VNETROOT)->TransitionWaitList, (RXCONTEXT), NULL )

#define RxTransitionVNetRoot(VNETROOT,CONDITION) \
    RxDbgTrace( 0, Dbg, ("RxTransitionVNetRoot -- %lx Condition -- %ld\n", (VNETROOT), (CONDITION)) ); \
    RxUpdateCondition( (CONDITION), &(VNETROOT)->Condition, &(VNETROOT)->TransitionWaitList )

#ifdef USE_FILESIZE_LOCK

//
//  FCB related routines.
//

#define RxAcquireFileSizeLock(PFCB) { \
    ExAcquireFastMutex( (PFCB)->Specific.Fcb.FileSizeLock ); \
}
#define RxReleaseFileSizeLock(PFCB) { \
    ExReleaseFastMutex((PFCB)->Specific.Fcb.FileSizeLock); \
}

#endif

VOID
RxSetFileSizeWithLock (
    IN OUT PFCB Fcb,
    IN PLONGLONG FileSize
    );

VOID
RxGetFileSizeWithLock (
    IN PFCB Fcb,
    OUT PLONGLONG FileSize
    );

PFCB
RxCreateNetFcb (
    OUT PRX_CONTEXT RxContext,
    IN PV_NET_ROOT VNetRoot,
    IN PUNICODE_STRING Name
    );

#define RxWaitForStableNetFcb(FCB,RXCONTEXT)                                   \
    RxDbgTrace(0, Dbg, ("RxWaitForStableNetFcb -- %lx\n",(FCB)));    \
    RxWaitForStableCondition( &(FCB)->Condition, &(FCB)->NonPaged->TransitionWaitList, (RXCONTEXT), NULL )

#define RxTransitionNetFcb(FCB,CONDITION) \
    RxDbgTrace(0, Dbg, ("RxTransitionNetFcb -- %lx Condition -- %ld\n",(FCB),(CONDITION))); \
    RxUpdateCondition( (CONDITION), &(FCB)->Condition, &(FCB)->NonPaged->TransitionWaitList )


#define RxFormInitPacket(IP,I1,I1a,I2,I3,I4a,I4b,I5,I6,I7) (\
            IP.pAttributes = I1, \
            IP.pNumLinks = I1a, \
            IP.pCreationTime = I2, \
            IP.pLastAccessTime = I3, \
            IP.pLastWriteTime = I4a, \
            IP.pLastChangeTime = I4b, \
            IP.pAllocationSize = I5, \
            IP.pFileSize = I6, \
            IP.pValidDataLength = I7, \
          &IP)

#if DBG
#define ASSERT_CORRECT_FCB_STRUCTURE_DBG_ONLY(___thisfcb) {\
    ASSERT( ___thisfcb->NonPaged == ___thisfcb->CopyOfNonPaged );       \
    ASSERT( ___thisfcb->NonPaged->FcbBackPointer == ___thisfcb );       \
    }
#else
#define ASSERT_CORRECT_FCB_STRUCTURE_DBG_ONLY(___thisfcb)
#endif

#define ASSERT_CORRECT_FCB_STRUCTURE(THIS_FCB__) { \
    ASSERT( NodeTypeIsFcb(THIS_FCB__));                                 \
    ASSERT( THIS_FCB__->NonPaged != NULL );                             \
    ASSERT( NodeType(THIS_FCB__->NonPaged) == RDBSS_NTC_NONPAGED_FCB);  \
    ASSERT_CORRECT_FCB_STRUCTURE_DBG_ONLY(THIS_FCB__) \
    }

RX_FILE_TYPE
RxInferFileType (
    IN PRX_CONTEXT RxContext
    );

VOID
RxFinishFcbInitialization (
    IN OUT PMRX_FCB Fcb,
    IN RX_FILE_TYPE FileType,
    IN PFCB_INIT_PACKET InitPacket OPTIONAL
    );

#define RxWaitForStableSrvOpen(SRVOPEN,RXCONTEXT)                                   \
    RxDbgTrace( 0, Dbg, ("RxWaitForStableFcb -- %lx\n",(SRVOPEN)) );    \
    RxWaitForStableCondition( &(SRVOPEN)->Condition, &(SRVOPEN)->TransitionWaitList, (RXCONTEXT), NULL )

#define RxTransitionSrvOpen(SRVOPEN,CONDITION) \
    RxDbgTrace( 0, Dbg, ("RxTransitionSrvOpen -- %lx Condition -- %ld\n",(SRVOPEN),(CONDITION)) ); \
    RxUpdateCondition( (CONDITION), &(SRVOPEN)->Condition, &(SRVOPEN)->TransitionWaitList )

VOID
RxRemoveNameNetFcb (
    OUT PFCB ThisFcb
    );

VOID
RxpReferenceNetFcb (
   PFCB Fcb
   );

LONG
RxpDereferenceNetFcb (
   PFCB Fcb
   );

BOOLEAN
RxpDereferenceAndFinalizeNetFcb (
    OUT PFCB ThisFcb,
    IN PRX_CONTEXT RxContext,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#if DBG
extern BOOLEAN RxLoudFcbOpsOnExes;
BOOLEAN
RxLoudFcbMsg(
    PUCHAR msg,
    PUNICODE_STRING Name
    );
#else
#define RxLoudFcbMsg(a,b) (FALSE)
#endif


//
//  SRV_OPEN related methods
//

PSRV_OPEN
RxCreateSrvOpen (
    IN PV_NET_ROOT VNetRoot,
    IN OUT PFCB Fcb
    );

VOID
RxTransitionSrvOpenState (
    OUT PSRV_OPEN ThisSrvOpen,
    IN RX_BLOCK_CONDITION Condition
    );

BOOLEAN
RxFinalizeSrvOpen (
    OUT PSRV_OPEN ThisSrvOpen,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#if 0
#else
INLINE 
PUNICODE_STRING
GET_ALREADY_PREFIXED_NAME (
    PMRX_SRV_OPEN SrvOpen,
    PMRX_FCB Fcb)
{
    PFCB ThisFcb = (PFCB)Fcb;

#if DBG
    if (SrvOpen != NULL ) {
        ASSERT( NodeType( SrvOpen ) == RDBSS_NTC_SRVOPEN );
        ASSERT( ThisFcb != NULL );
        ASSERT( NodeTypeIsFcb( Fcb) );
        ASSERT( SrvOpen->pFcb == Fcb );
        ASSERT( SrvOpen->pAlreadyPrefixedName == &ThisFcb->PrivateAlreadyPrefixedName );
    }
#endif

    return( &ThisFcb->PrivateAlreadyPrefixedName);
}
#endif

#define GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(Rxcontext) \
        (GET_ALREADY_PREFIXED_NAME( (Rxcontext)->pRelevantSrvOpen, (Rxcontext)->pFcb ))

//
//  FOBX related routines
//

PMRX_FOBX
RxCreateNetFobx (
    OUT PRX_CONTEXT RxContext,
    IN PMRX_SRV_OPEN MrxSrvOpen
    );

BOOLEAN
RxFinalizeNetFobx (
    OUT PFOBX ThisFobx,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize
    );

#endif // _FCB_STRUCTS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\mrx.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    mrx.h

Abstract:

    This module defines the interface between the MINI Redirectors and the RDBSS.
    The inteface is a dispatch table for the normal file system operations. In
    addition routines are provided for registrations/deregistration of mini
    redirectors.

Author:

    Joe Linn (JoeLinn)    8-17-94

Revision History:

Notes:

    The interface definition between the mini redirectors and the wrapper
    consists of two parts, the data structures used and the dispatch vector.
    The data structures are defined in mrxfcb.h while the signatures of the
    various entries in the dispatch vector and the dispatch vector itself is
    defined in this file.

--*/

#ifndef _RXMINIRDR_
#define _RXMINIRDR_

#include <mrxfcb.h>     // RDBSS data structures shared with the mini redirectors

// The following macros encapsulate commonly used operations in the mini redirector.
// These include setting the status/information associated with the completion of
// a request etc.


// The following three macros are used for passing back operation status from the
// minirdr to the NT wrapper. information passed back is either the open_action
// for a create or the actual byte count or an operation. these should be passed
// back directly in the rxcontext.

#define RxSetIoStatusStatus(RXCONTEXT, STATUS)  \
            (RXCONTEXT)->CurrentIrp->IoStatus.Status = (STATUS)

#define RxSetIoStatusInfo(RXCONTEXT, INFORMATION) \
             ((RXCONTEXT))->CurrentIrp->IoStatus.Information = (INFORMATION)

#define RxGetIoStatusInfo(RXCONTEXT) \
             ((RXCONTEXT)->CurrentIrp->IoStatus.Information)

#define RxShouldPostCompletion()  ((KeGetCurrentIrql() >= DISPATCH_LEVEL))

///
/// The mini rdr's register/unregister with the RDBSS whenever they are loaded/unloaded.
/// The registartion process is a two way hand shake in which the mini rdr informs the RDBSS
/// by invoking the registartion routine. The RDBSS completes the initialization by invoking
/// the Start routine in the dispatch vector.
///

#define RX_REGISTERMINI_FLAG_DONT_PROVIDE_UNCS            0x00000001
#define RX_REGISTERMINI_FLAG_DONT_PROVIDE_MAILSLOTS       0x00000002
#define RX_REGISTERMINI_FLAG_DONT_INIT_DRIVER_DISPATCH    0x00000004
#define RX_REGISTERMINI_FLAG_DONT_INIT_PREFIX_N_SCAVENGER 0x00000008

NTSTATUS
NTAPI
RxRegisterMinirdr(
    OUT PRDBSS_DEVICE_OBJECT *DeviceObject, //the deviceobject that was created
    IN OUT PDRIVER_OBJECT DriverObject,    // the minirdr driver object
    IN  PMINIRDR_DISPATCH MrdrDispatch,    // the mini rdr dispatch vector
    IN  ULONG             Controls,
    IN  PUNICODE_STRING   DeviceName,
    IN  ULONG DeviceExtensionSize,
    IN  DEVICE_TYPE DeviceType,
    IN  ULONG DeviceCharacteristics
    );

VOID
NTAPI
RxMakeLateDeviceAvailable(
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

VOID
NTAPI
__RxFillAndInstallFastIoDispatch(
    IN     PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN OUT PFAST_IO_DISPATCH FastIoDispatch,
    IN     ULONG             FastIoDispatchSize
    );
#define RxFillAndInstallFastIoDispatch(__devobj,__fastiodisp) {\
    __RxFillAndInstallFastIoDispatch(&__devobj->RxDeviceObject,\
                                     &__fastiodisp,            \
                                     sizeof(__fastiodisp)); \
    }

VOID
NTAPI
RxpUnregisterMinirdr(
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject);

NTSTATUS
RxStartMinirdr (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

NTSTATUS
RxStopMinirdr (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

NTSTATUS
RxSetDomainForMailslotBroadcast (
    IN PUNICODE_STRING DomainName
    );

NTSTATUS
RxFsdDispatch(
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN PIRP Irp
    );

typedef
NTSTATUS
(NTAPI *PMRX_CALLDOWN) (
    IN OUT struct _RX_CONTEXT * RxContext
    );

typedef
NTSTATUS
(NTAPI *PMRX_CALLDOWN_CTX) (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

typedef
NTSTATUS
(NTAPI *PMRX_CHKDIR_CALLDOWN) (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN     PUNICODE_STRING      DirectoryName
    );

typedef
NTSTATUS
(NTAPI *PMRX_CHKFCB_CALLDOWN) (
    IN struct _FCB * Fcb1,
    IN struct _FCB * Fcb2
    );

//
// The two important abstractions used in the interface between the mini rdr and RDBSS are
// Server Calls and Net Roots. The former corresponds to the context associated with a
// server with which a connection has been established and the later corresponds to a
// share on a server ( This could also be viewed as a portion of the name space which has
// been claimed by a mini rdr).
//
// The creation of Server calls and net roots typically involve atleast one network round trip.
// In order to provide for asynchronous operations to continue these operations are modelled
// as a two phase activity. Each calldown to a mini rdr for creating a server call and net root is
// accompanied by a callup from the mini rdr to the RDBSS notifying with the completion status
// of the request. Currently these are synchronous!
//
// The creation of Srv calls is further complicated by the fact that the RDBSS has to choose
// from a number of mini rdr's to establish a connection with a server. In order to provide
// the RDBSS with maximum flexibility in choosing the mini rdr's that it wishes to deploy the
// creation of server calls involves a third phase in which the RDBSS notifies the mini rdr of
// a winner. All the losing mini rdrs destroy the associated context.
//

typedef enum _RX_BLOCK_CONDITION {
    Condition_Uninitialized = 0,
    Condition_InTransition,
    Condition_Closing,
    Condition_Good,
    Condition_Bad,
    Condition_Closed
    } RX_BLOCK_CONDITION, *PRX_BLOCK_CONDITION;

#define StableCondition(X) ((X) >= Condition_Good)

// The routine for notifying the RDBSS about the completion status of the NetRoot creation
// request.

typedef
VOID
(NTAPI *PMRX_NETROOT_CALLBACK) (
    IN OUT struct _MRX_CREATENETROOT_CONTEXT *pCreateContext
    );

// this routine allows the minirdr to specify the netrootname. NetRootName and RestOfName are set
// to point to the appropriate places within FilePathName. SrvCall is used to find the lengthof the srvcallname.

typedef
VOID
(NTAPI *PMRX_EXTRACT_NETROOT_NAME) (
    IN  PUNICODE_STRING FilePathName,
    IN  PMRX_SRV_CALL   SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    );

// The resumption context for the RDBSS.
typedef struct _MRX_CREATENETROOT_CONTEXT {
    PRX_CONTEXT           RxContext;
    PV_NET_ROOT           pVNetRoot;
    KEVENT                FinishEvent;
    NTSTATUS              VirtualNetRootStatus;
    NTSTATUS              NetRootStatus;
    RX_WORK_QUEUE_ITEM    WorkQueueItem;
    PMRX_NETROOT_CALLBACK Callback;
} MRX_CREATENETROOT_CONTEXT, *PMRX_CREATENETROOT_CONTEXT;


// the calldown from RDBSS to the mini rdr for creating a netroot.
typedef
NTSTATUS
(NTAPI *PMRX_CREATE_V_NET_ROOT)(
    IN OUT PMRX_CREATENETROOT_CONTEXT pContext
    );

// the calldown for querying a net root state.
typedef
NTSTATUS
(NTAPI *PMRX_UPDATE_NETROOT_STATE)(
    IN OUT PMRX_NET_ROOT pNetRoot
    );

// The routine for notifying the RDBSS about the completion status of the SrvCall creation
// request.

typedef
VOID
(NTAPI *PMRX_SRVCALL_CALLBACK) (
    IN OUT struct _MRX_SRVCALL_CALLBACK_CONTEXT *pContext
    );

// The resumption context for the RDBSS.
typedef struct _MRX_SRVCALL_CALLBACK_CONTEXT {
    struct _MRX_SRVCALLDOWN_STRUCTURE *SrvCalldownStructure; //could be computed
    ULONG                             CallbackContextOrdinal;
    PRDBSS_DEVICE_OBJECT              RxDeviceObject;
    NTSTATUS                          Status;
    PVOID                             RecommunicateContext;
} MRX_SRVCALL_CALLBACK_CONTEXT, *PMRX_SRVCALL_CALLBACK_CONTEXT;

// The context passed from the RDBSS to the mini rdr for creating a server call.
typedef struct _MRX_SRVCALLDOWN_STRUCTURE {
    KEVENT                       FinishEvent;
    LIST_ENTRY                   SrvCalldownList;
    PRX_CONTEXT                  RxContext;
    PMRX_SRV_CALL                SrvCall;
    PMRX_SRVCALL_CALLBACK        CallBack;
    BOOLEAN                      CalldownCancelled;
    ULONG                        NumberRemaining;
    ULONG                        NumberToWait;
    ULONG                        BestFinisherOrdinal;
    PRDBSS_DEVICE_OBJECT         BestFinisher;
    MRX_SRVCALL_CALLBACK_CONTEXT CallbackContexts[1];
} MRX_SRVCALLDOWN_STRUCTURE;

// the calldown from the RDBSS to the mini rdr for creating a server call
typedef
NTSTATUS
(NTAPI *PMRX_CREATE_SRVCALL)(
    IN OUT PMRX_SRV_CALL                 pSrvCall,
    IN OUT PMRX_SRVCALL_CALLBACK_CONTEXT SrvCallCallBackContext
    );

// the calldown from the RDBSS to the mini rdr for notifying the mini rdr's of the winner.
typedef
NTSTATUS
(NTAPI *PMRX_SRVCALL_WINNER_NOTIFY)(
    IN OUT PMRX_SRV_CALL SrvCall,
    IN     BOOLEAN       ThisMinirdrIsTheWinner,
    IN OUT PVOID         RecommunicateContext
    );

//
// The prototypes for calldown routines relating to various file system operations
//
typedef
VOID
(NTAPI *PMRX_NEWSTATE_CALLDOWN) (
    IN OUT PVOID Context
    );

typedef
NTSTATUS
(NTAPI *PMRX_DEALLOCATE_FOR_FCB) (
    IN OUT PMRX_FCB pFcb
    );

typedef
NTSTATUS
(NTAPI *PMRX_DEALLOCATE_FOR_FOBX) (
    IN OUT PMRX_FOBX pFobx
    );

typedef
NTSTATUS
(NTAPI *PMRX_IS_LOCK_REALIZABLE) (
    IN OUT PMRX_FCB pFcb,
    IN PLARGE_INTEGER  ByteOffset,
    IN PLARGE_INTEGER  Length,
    IN ULONG  LowIoLockFlags
    );

typedef
NTSTATUS
(NTAPI *PMRX_FORCECLOSED_CALLDOWN) (
    IN OUT PMRX_SRV_OPEN pSrvOpen
    );

typedef
NTSTATUS
(NTAPI *PMRX_FINALIZE_SRVCALL_CALLDOWN) (
    IN OUT PMRX_SRV_CALL pSrvCall,
    IN     BOOLEAN       Force
    );

typedef
NTSTATUS
(NTAPI *PMRX_FINALIZE_V_NET_ROOT_CALLDOWN) (
    IN OUT PMRX_V_NET_ROOT  pVirtualNetRoot,
    IN     PBOOLEAN         Force
    );

typedef
NTSTATUS
(NTAPI *PMRX_FINALIZE_NET_ROOT_CALLDOWN) (
    IN OUT PMRX_NET_ROOT  pNetRoot,
    IN     PBOOLEAN       Force
    );

typedef
ULONG
(NTAPI *PMRX_EXTENDFILE_CALLDOWN) (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    );

typedef
BOOLEAN
(*PRX_LOCK_ENUMERATOR) (
    IN OUT struct _MRX_SRV_OPEN_ * SrvOpen,
    IN OUT PVOID *ContinuationHandle,
       OUT PLARGE_INTEGER FileOffset,
       OUT PLARGE_INTEGER LockRange,
       OUT PBOOLEAN IsLockExclusive
    );
typedef
NTSTATUS
(NTAPI *PMRX_CHANGE_BUFFERING_STATE_CALLDOWN) (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT struct _MRX_SRV_OPEN_  * SrvOpen,
    IN     PVOID              pMRxContext
    );

typedef
NTSTATUS
(NTAPI *PMRX_PREPARSE_NAME) (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN PUNICODE_STRING Name
    );

typedef
NTSTATUS
(NTAPI *PMRX_GET_CONNECTION_ID) (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN OUT struct _RX_CONNECTION_ID * UniqueId
    );

//
// Buffering state/Policy management TBD
//
typedef enum _MINIRDR_BUFSTATE_COMMANDS {
    MRDRBUFSTCMD__COMMAND_FORCEPURGE0,
    MRDRBUFSTCMD__1,
    MRDRBUFSTCMD__2,
    MRDRBUFSTCMD__3,
    MRDRBUFSTCMD__4,
    MRDRBUFSTCMD__5,
    MRDRBUFSTCMD__6,
    MRDRBUFSTCMD__7,
    MRDRBUFSTCMD__8,
    MRDRBUFSTCMD__9,
    MRDRBUFSTCMD__10,
    MRDRBUFSTCMD__11,
    MRDRBUFSTCMD__12,
    MRDRBUFSTCMD__13,
    MRDRBUFSTCMD__14,
    MRDRBUFSTCMD__15,
    MRDRBUFSTCMD__16,
    MRDRBUFSTCMD__17,
    MRDRBUFSTCMD__18,
    MRDRBUFSTCMD__19,
    MRDRBUFSTCMD__20,
    MRDRBUFSTCMD__21,
    MRDRBUFSTCMD__22,
    MRDRBUFSTCMD__23,
    MRDRBUFSTCMD__24,
    MRDRBUFSTCMD__25,
    MRDRBUFSTCMD__26,
    MRDRBUFSTCMD__27,
    MRDRBUFSTCMD__28,
    MRDRBUFSTCMD__29,
    MRDRBUFSTCMD__30,
    MRDRBUFSTCMD__31,
    MRDRBUFSTCMD_MAXXX
} MINIRDR_BUFSTATE_COMMANDS;

#define RXMakeMRDRBUFSTCMD(x)               ((ULONG)(1<<MRDRBUFSTCMD__##x))
#define MINIRDR_BUFSTATE_COMMAND_FORCEPURGE ( RXMakeMRDRBUFSTCMD(COMMAND_FORCEPURGE0) )
#define MINIRDR_BUFSTATE_COMMAND_MASK       ((MINIRDR_BUFSTATE_COMMAND_FORCEPURGE))

typedef
NTSTATUS
(NTAPI *PMRX_COMPUTE_NEW_BUFFERING_STATE) (
    IN OUT PMRX_SRV_OPEN pSrvOpen,
    IN     PVOID         pMRxContext,
       OUT PULONG        pNewBufferingState
    );

typedef enum _LOWIO_OPS {
  LOWIO_OP_READ=0,
  LOWIO_OP_WRITE,
  LOWIO_OP_SHAREDLOCK,
  LOWIO_OP_EXCLUSIVELOCK,
  LOWIO_OP_UNLOCK,
  LOWIO_OP_UNLOCK_MULTIPLE,
  //LOWIO_OP_UNLOCKALLBYKEY,
  LOWIO_OP_FSCTL,
  LOWIO_OP_IOCTL,
  LOWIO_OP_NOTIFY_CHANGE_DIRECTORY,
  LOWIO_OP_CLEAROUT,
  LOWIO_OP_MAXIMUM
} LOWIO_OPS;

typedef
NTSTATUS
(NTAPI *PLOWIO_COMPLETION_ROUTINE) (
    IN struct _RX_CONTEXT *RxContext
    );

typedef LONGLONG RXVBO;

// we may, at some point, want a smarter implementation of this. we don't statically allocate the first
// element because that would make unlock behind much harder.
typedef struct _LOWIO_LOCK_LIST *PLOWIO_LOCK_LIST;
typedef struct _LOWIO_LOCK_LIST {
    PLOWIO_LOCK_LIST Next;
    ULONG    LockNumber;
    RXVBO    ByteOffset;
    LONGLONG Length;
    BOOLEAN ExclusiveLock;
} LOWIO_LOCK_LIST;

VOID
NTAPI
RxFinalizeLockList(
    struct _RX_CONTEXT *RxContext
    );

typedef struct _XXCTL_LOWIO_COMPONENT{
           ULONG          Flags;
           union {
               ULONG          FsControlCode;
               ULONG          IoControlCode;
           };
           ULONG          InputBufferLength;
           PVOID          pInputBuffer;
           ULONG          OutputBufferLength;
           PVOID          pOutputBuffer;
           UCHAR          MinorFunction;
} XXCTL_LOWIO_COMPONENT;

typedef struct _LOWIO_CONTEXT {
    USHORT Operation;  // padding!
    USHORT Flags;
    PLOWIO_COMPLETION_ROUTINE CompletionRoutine;
    PERESOURCE Resource;
    ERESOURCE_THREAD ResourceThreadId;
    union {
        struct {
           ULONG    Flags;
           PMDL     Buffer;
           RXVBO    ByteOffset;
           ULONG    ByteCount;
           ULONG    Key;
           PNON_PAGED_FCB NonPagedFcb;
        } ReadWrite;
        struct {
           union {
               PLOWIO_LOCK_LIST LockList;
               LONGLONG       Length;
           };
           //these fields are not used if locklist is used
           ULONG          Flags;
           RXVBO          ByteOffset;
           ULONG          Key;
        } Locks;
        XXCTL_LOWIO_COMPONENT FsCtl;
        XXCTL_LOWIO_COMPONENT IoCtl; //these must be the same
        struct {
           BOOLEAN        WatchTree;
           ULONG          CompletionFilter;
           ULONG          NotificationBufferLength;
           PVOID          pNotificationBuffer;
        } NotifyChangeDirectory;
    } ParamsFor;
} LOWIO_CONTEXT;

#define LOWIO_CONTEXT_FLAG_SYNCCALL    0x0001  //this is set if lowiocompletion is called from lowiosubmit
#define LOWIO_CONTEXT_FLAG_SAVEUNLOCKS 0x0002  //WRAPPER INTERNAL: on NT, it means the unlock routine add unlocks to the list
#define LOWIO_CONTEXT_FLAG_LOUDOPS     0x0004  //WRAPPER INTERNAL: on NT, it means read and write routines generate dbg output
#define LOWIO_CONTEXT_FLAG_CAN_COMPLETE_AT_DPC_LEVEL     0x0008  //WRAPPER INTERNAL: on NT, it means the completion routine maybe can
                                                                 //    complete when called at DPC. otherwise it cannnot. currently
                                                                 //    none can.

#define LOWIO_READWRITEFLAG_PAGING_IO          0x01
#define LOWIO_READWRITEFLAG_EXTENDING_FILESIZE 0x02
#define LOWIO_READWRITEFLAG_EXTENDING_VDL      0x04

//these must match the SL_ values in io.h (ntifs.h) since the flags field is just copied
#define LOWIO_LOCKSFLAG_FAIL_IMMEDIATELY 0x01
#define LOWIO_LOCKSFLAG_EXCLUSIVELOCK    0x02

#if (LOWIO_LOCKSFLAG_FAIL_IMMEDIATELY!=SL_FAIL_IMMEDIATELY)
#error LOWIO_LOCKSFLAG_FAIL_IMMEDIATELY!=SL_FAIL_IMMEDIATELY
#endif
#if (LOWIO_LOCKSFLAG_EXCLUSIVELOCK!=SL_EXCLUSIVE_LOCK)
#error LOWIO_LOCKSFLAG_EXCLUSIVELOCK!=SL_EXCLUSIVE_LOCK
#endif

//
// The six important data structures (SRV_CALL,NET_ROOT,V_NET_ROOT,FCB,SRV_OPEN and
// FOBX) that are an integral part of the mini rdr architecture have a corresponding
// counterpart in every mini rdr implementation. In order to provide maximal flexibility
// and at the same time enhance performance the sizes and the desired allocation
// behaviour are communicated at the registration time of a mini rdr.
//
// There is no single way in which these extensions can be managed which will
// address the concerns of flexibility as well as performance. The solution adopted
// in the current architecture that meets the dual goals in most cases. The solution
// and the rationale is as follows ...
//
// Each mini rdr implementor specifies the size of the data structure extensions
// alongwith a flag specfying if the allocation/free of the extensions are to be
// managed by the wrapper.
//
// In all those cases where a one to one relationship exists between the wrapper
// data structure and the corresponding mini rdr counterpart specifying the flag
// results in maximal performance gains. There are a certain data structures for
// which many instances of a wrapper data structure map onto the same extension in
// the mini redirector. In such cases the mini rdr implementor will be better off
// managing the allocation/deallocation of the data structure extension without the
// intervention of the wrapper.
//
// Irrespective of the mechanism choosen the convention is to always associate the
// extension with the Context field in the corresponding RDBSS data structure.
// !!!NO EXCEPTIONS!!!
//
// The remaining field in all the RDBSS data structures, i.e., Context2 is left to
// the discretion og the mini rdr implementor.
//
//
// The SRV_CALL extension is not handled currently. This is because of further fixes
// required in RDBSS w.r.t the mecahsnism used to select the mini rdr and to allow several
// minis to share the srvcall.
//
// Please do not use it till further notice; rather, the mini should manage its own srcall
// storage. There is a finalization calldown that assists in this endeavor.

#define RDBSS_MANAGE_SRV_CALL_EXTENSION   (0x1)
#define RDBSS_MANAGE_NET_ROOT_EXTENSION   (0x2)
#define RDBSS_MANAGE_V_NET_ROOT_EXTENSION (0x4)
#define RDBSS_MANAGE_FCB_EXTENSION        (0x8)
#define RDBSS_MANAGE_SRV_OPEN_EXTENSION   (0x10)
#define RDBSS_MANAGE_FOBX_EXTENSION       (0x20)

#define RDBSS_NO_DEFERRED_CACHE_READAHEAD    (0x1000)

typedef struct _MINIRDR_DISPATCH {
    NODE_TYPE_CODE   NodeTypeCode;                  // Normal Header
    NODE_BYTE_SIZE   NodeByteSize;

    ULONG  MRxFlags;                // Flags to control the allocation of extensions.
                                    // and various other per-minirdr policies

    ULONG  MRxSrvCallSize;          // size of the SRV_CALL extensions
    ULONG  MRxNetRootSize;          // size of the NET_ROOT extensions
    ULONG  MRxVNetRootSize;         // size of the V_NET_ROOT extensions
    ULONG  MRxFcbSize;              // size of FCB extensions
    ULONG  MRxSrvOpenSize;          // size of SRV_OPEN extensions
    ULONG  MRxFobxSize;             // size of FOBX extensions

    // Call downs for starting/stopping the mini rdr
    PMRX_CALLDOWN_CTX                  MRxStart;
    PMRX_CALLDOWN_CTX                  MRxStop;

    // Call down for cancelling outstanding requests
    PMRX_CALLDOWN                      MRxCancel;

    // Call downs related to creating/opening/closing file system objects
    PMRX_CALLDOWN                      MRxCreate;
    PMRX_CALLDOWN                      MRxCollapseOpen;
    PMRX_CALLDOWN                      MRxShouldTryToCollapseThisOpen;
    PMRX_CALLDOWN                      MRxFlush;
    PMRX_CALLDOWN                      MRxZeroExtend;
    PMRX_CALLDOWN                      MRxTruncate;
    PMRX_CALLDOWN                      MRxCleanupFobx;
    PMRX_CALLDOWN                      MRxCloseSrvOpen;
    PMRX_DEALLOCATE_FOR_FCB            MRxDeallocateForFcb;
    PMRX_DEALLOCATE_FOR_FOBX           MRxDeallocateForFobx;
    PMRX_IS_LOCK_REALIZABLE            MRxIsLockRealizable;
    PMRX_FORCECLOSED_CALLDOWN          MRxForceClosed;
    PMRX_CHKFCB_CALLDOWN               MRxAreFilesAliased;

    // call downs related to nonNT style printing.....note that the connect goes thru
    // the normal srvcall/netroot interface
    PMRX_CALLDOWN                      MRxOpenPrintFile;
    PMRX_CALLDOWN                      MRxClosePrintFile;
    PMRX_CALLDOWN                      MRxWritePrintFile;
    PMRX_CALLDOWN                      MRxEnumeratePrintQueue;

    // call downs related to unsatisfied requests, i.e., time outs
    PMRX_CALLDOWN                      MRxClosedSrvOpenTimeOut;
    PMRX_CALLDOWN                      MRxClosedFcbTimeOut;

    // call downs related to query/set  information on file system objects
    PMRX_CALLDOWN                      MRxQueryDirectory;
    PMRX_CALLDOWN                      MRxQueryFileInfo;
    PMRX_CALLDOWN                      MRxSetFileInfo;
    PMRX_CALLDOWN                      MRxSetFileInfoAtCleanup;
    PMRX_CALLDOWN                      MRxQueryEaInfo;
    PMRX_CALLDOWN                      MRxSetEaInfo;
    PMRX_CALLDOWN                      MRxQuerySdInfo;
    PMRX_CALLDOWN                      MRxSetSdInfo;
    PMRX_CALLDOWN                      MRxQueryQuotaInfo;
    PMRX_CALLDOWN                      MRxSetQuotaInfo;
    PMRX_CALLDOWN                      MRxQueryVolumeInfo;
    PMRX_CALLDOWN                      MRxSetVolumeInfo;
    PMRX_CHKDIR_CALLDOWN               MRxIsValidDirectory;

    // call downs related to buffer management
    PMRX_COMPUTE_NEW_BUFFERING_STATE   MRxComputeNewBufferingState;

    // call downs related to Low I/O management (reads/writes on file system objects)
    PMRX_CALLDOWN                      MRxLowIOSubmit[LOWIO_OP_MAXIMUM+1];
    PMRX_EXTENDFILE_CALLDOWN             MRxExtendForCache;
    PMRX_EXTENDFILE_CALLDOWN             MRxExtendForNonCache;
    PMRX_CHANGE_BUFFERING_STATE_CALLDOWN MRxCompleteBufferingStateChangeRequest;

    // call downs related to name space management
    PMRX_CREATE_V_NET_ROOT             MRxCreateVNetRoot;
    PMRX_FINALIZE_V_NET_ROOT_CALLDOWN  MRxFinalizeVNetRoot;
    PMRX_FINALIZE_NET_ROOT_CALLDOWN    MRxFinalizeNetRoot;
    PMRX_UPDATE_NETROOT_STATE          MRxUpdateNetRootState;
    PMRX_EXTRACT_NETROOT_NAME          MRxExtractNetRootName;

    // call downs related to establishing connections with servers
    PMRX_CREATE_SRVCALL                MRxCreateSrvCall;
    PMRX_CREATE_SRVCALL                MRxCancelCreateSrvCall;
    PMRX_SRVCALL_WINNER_NOTIFY         MRxSrvCallWinnerNotify;
    PMRX_FINALIZE_SRVCALL_CALLDOWN     MRxFinalizeSrvCall;

    PMRX_CALLDOWN                      MRxDevFcbXXXControlFile;

    // new calldowns

    // Allow a client to preparse the name
    PMRX_PREPARSE_NAME                 MRxPreparseName;

    // call down for controlling multi-plexing
    PMRX_GET_CONNECTION_ID             MRxGetConnectionId;

} MINIRDR_DISPATCH, *PMINIRDR_DISPATCH;


#endif   // _RXMINIRDR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\lowio.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lowio.h

Abstract:

    This module defines all of the structures and prototypes for Low IO.

Author:

    Joe Linn (JoeLinn)    8-17-94

Revision History:

--*/

#ifndef _RXLOWIO_
#define _RXLOWIO_

#include "mrx.h" // mini redirector related definitions ....

#ifndef WIN9X
extern FAST_MUTEX RxLowIoPagingIoSyncMutex;
#endif

#define RxLowIoIsMdlLocked(MDL)  ( \
      RxMdlIsLocked((MDL)) || RxMdlSourceIsNonPaged((MDL))   \
      )

#define RxLowIoIsBufferLocked(LOWIOCONTEXT)                          \
   ( ((LOWIOCONTEXT)->Operation > LOWIO_OP_WRITE )  ||               \
     ((LOWIOCONTEXT)->ParamsFor.ReadWrite.Buffer == NULL) ||         \
     (                                                               \
      ((LOWIOCONTEXT)->ParamsFor.ReadWrite.Buffer != NULL) &&        \
      RxLowIoIsMdlLocked(((LOWIOCONTEXT)->ParamsFor.ReadWrite.Buffer)) \
     )                                                               \
   )

typedef struct _LOWIO_PER_FCB_INFO {
    LIST_ENTRY PagingIoReadsOutstanding;
    LIST_ENTRY PagingIoWritesOutstanding;
} LOWIO_PER_FCB_INFO, *PLOWIO_PER_FCB_INFO;

PVOID
NTAPI
RxLowIoGetBufferAddress (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
NTAPI
RxLowIoPopulateFsctlInfo (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
NTAPI
RxLowIoSubmit(
    PRX_CONTEXT RxContext,
    PLOWIO_COMPLETION_ROUTINE CompletionRoutine
    );

NTSTATUS
NTAPI
RxLowIoCompletion(
    PRX_CONTEXT RxContext
    );

VOID
NTAPI
RxInitializeLowIoContext(
    PLOWIO_CONTEXT LowIoContext,
    ULONG Operation
    );

VOID
RxInitializeLowIoPerFcbInfo(
    PLOWIO_PER_FCB_INFO LowIoPerFcbInfo
    );


#endif   // _RXLOWIO_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\midatlax.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    midatlas.h

Abstract:

    This module defines the data structure used in mapping MIDS to the corresponding requests/
    contexts associated with them.

Author:

    Balan Sethu Raman (SethuR) 26-Aug-95    Created

Notes:

   MID (Multiplex ID) is used at both the server and the client ( redirector ) to distinguish
   between the concurrently active requests on any connection. This data structure has been
   designed to meet the following criterion.

   1) It should scale well to handle the differing capabilities of a server, e.g., the typical
   NT server permits 50 outstanding requests on any connection. The CORE level servers can go as
   low as one and on Gateway machines the desired number can be very high ( in the oreder of thousands)

   2) The two primary operations that need to be handled well are
      i) mapping a MID to the context associated with it.
         -- This routine will be invoked to process every packet received along any connection
         at both the server and the client.
      ii) generating a new MID for sending requests to the server.
         -- This will be used at the client both for max. command enforcement as well as
         tagging each concurrent request with a unique id.

    The most common case is that of a connection between a NT client and a NT server. All
    design decisions have been made in order to ensure that the solutions are optimal
    for this case.

    The MID data structure must be efficiently able to manage the unique tagging and identification
    of a number of mids ( typically 50 ) from a possible combination of 65536 values. In order to
    ensure a proper time space tradeoff the lookup is organized as a three level hierarchy.

    The 16 bits used to represent a MID  are split upinto three bit fields. The length of the
    rightmost field ( least signifiant ) is decided by the number of mids that are to be
    allocated on creation. The remaining length is split up equally between the next two
    fields, e.g., if 50 mids are to be allocated on creation , the length of the first field
    is 6 ( 64 ( 2 ** 6 ) is greater than 50 ), 5 and 5.

--*/

#ifndef _MIDATLAX_H_
#define _MIDATLAX_H_

typedef struct _RX_MID_ATLAS {
   USHORT      MaximumNumberOfMids;
   USHORT      MidsAllocated;
   USHORT      NumberOfMidsInUse;
   USHORT      NumberOfMidsDiscarded;
   USHORT      MaximumMidFieldWidth;
   USHORT      Reserved;
   USHORT      MidQuantum;
   UCHAR       MidQuantumFieldWidth;
   UCHAR       NumberOfLevels;
   LIST_ENTRY  MidMapFreeList;
   LIST_ENTRY  MidMapExpansionList;
   struct _MID_MAP_ *pRootMidMap;
} RX_MID_ATLAS, *PRX_MID_ATLAS;

typedef
VOID (*PCONTEXT_DESTRUCTOR)(
      PVOID pContext);

#define RxGetMaximumNumberOfMids(pMidAtlas) \
        ((pMidAtlas)->MaximumNumberOfMids)

#define RxGetNumberOfMidsInUse(pMidAtlas) \
        ((pMidAtlas)->NumberOfMidsInUse)

PRX_MID_ATLAS
RxCreateMidAtlas(
         USHORT MaximumNumberOfEntries,
         USHORT InitialAllocation);

VOID
RxDestroyMidAtlas(
         PRX_MID_ATLAS pMidAtlas,
         PCONTEXT_DESTRUCTOR pContextDestructor);

PVOID
RxMapMidToContext(
         PRX_MID_ATLAS pMidAtlas,
         USHORT     Mid);

NTSTATUS
RxAssociateContextWithMid(
         PRX_MID_ATLAS pMidAtlas,
         PVOID      pContext,
         PUSHORT    pNewMid);

NTSTATUS
RxMapAndDissociateMidFromContext(
         PRX_MID_ATLAS pMidAtlas,
         USHORT Mid,
         PVOID *pContextPointer);

NTSTATUS
RxReassociateMid(
         PRX_MID_ATLAS pMidAtlas,
         USHORT     Mid,
         PVOID      pNewContext);

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\namcache.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    namcache.h

Abstract:

The NAME_CACHE structure is used to remember the name strings of recent
operations performed at the server so the client can suppress redundant
requests.  For example if an open has recently failed with file not found and
the client app tries it again with an upcased string then we can fail it
immediately with STATUS_OBJECT_NAME_NOT_FOUND without hitting the server.  In
general the algorithm is to put a time window and SMB operation count limit on
the NAME_CACHE entry.  The time window is usually 2 seconds so if NAME_CACHE
entry is more than 2 seconds old the match will fail and the request will go to
the server.  If the request fails again at the server the NAME_CACHE is updated
with another 2 second window.  If the SMB operation count doesn't match then one
or more SMBs have been sent to the server which could make this NAME_CACHE entry
invalid.  So again this operation will get sent to the server.

A NAME_CACHE struct has a mini-rdr portion and an RDBSS portion.  The mini-rdr
portion has a context field (see below), an NTSTATUS field for the result of a
prior server operation on this name entry and a context extension pointer for
some additional mini-rdr specific storage that can be co-allocated with the
NAME_CACHE structure.  See RxNameCacheInitialize().

The SMB operation count is an example of mini-rdr specific state which could be
saved in the context field of MRX_NAME_CACHE.  When the wrapper routine
RxNameCacheCheckEntry() is called it will perform an equality check between the
context field and a supplied parameter as part of finding a match in the name
cache.  When a NAME_CACHE entry is created or updated it is the mini-rdr's job
to supply an appropriate value for this field.

The RDBSS portion of the NAME_CACHE struct contains the name (in a UNICODE
STRING) and the expiration time of the entry.  The MaximumEntries field is used
to limit the number of NAME_CACHE entries created in case a poorly behaved
program were to generate a large number of opens with bad file names and so
consume large quanities of pool.

The NAME_CACHE_CONTROL struct is used to manage a given name cache.  It has
a free list, an active list and a lock used to synchronize updates.

Currently there are name caches for:
   1. OBJECT_NAME_NOT_FOUND - 2 second window, any SMB op sent to the
      server will invalidate it.  This is because you could have the case
      where the client app has a file (foo) open which an app on the server could
      use to signal the creation of a file (bar) on the server.  When the client
      reads file foo and learns that file bar has been created on the
      server then a hit in the name cache which matches bar can't return an
      error.  So this optimization only handles the case of successive file
      opens on the same file which does not yet exist.  Happens in WORD.

Author:

    David Orbits          [davidor]   9-Sep-1996

Revision History:

--*/

#ifndef _NAME_CACHE_DEFINED_
#define _NAME_CACHE_DEFINED_


#ifdef __cplusplus
typedef struct _MRX_NAME_CACHE_ : public MRX_NORMAL_NODE_HEADER {
#else // !__cplusplus
typedef struct _MRX_NAME_CACHE_ {
    MRX_NORMAL_NODE_HEADER;
#endif // __cplusplus

    // !!!! changes above this require realignment with fcb.h

    ULONG Context;                // Operation Count snapshot when entry made
    PVOID ContextExtension;       // Pointer to mini-rdr extension area
    NTSTATUS PriorStatus;         // Saved Status from last attempt at operation

} MRX_NAME_CACHE, *PMRX_NAME_CACHE;


#ifdef __cplusplus
typedef struct _NAME_CACHE : public MRX_NAME_CACHE {
    // I didn't find any use of the spacer in the union below,
    // and the MRX_NAME_CACHE is by definition larger than
    // MRX_NORMAL_NODE_HEADER, so I didn't worry about the union
#else // !__cplusplus
typedef struct _NAME_CACHE {
    //
    // The portion of NAME_CACHE visible to mini redirectors.
    //
    union {
        MRX_NAME_CACHE;
        struct {
           MRX_NORMAL_NODE_HEADER spacer;
        };
    };
#endif // __cplusplus
    //
    // The portion of NAME_CACHE visible to RDBSS.
    //
    LARGE_INTEGER ExpireTime;     // Time when entry expires
    LIST_ENTRY Link;              // Entry on free or active list
    UNICODE_STRING Name;          // Cached name
    ULONG HashValue;              // Hash value of name
    BOOLEAN CaseInsensitive;      // Controls name string compare

} NAME_CACHE, *PNAME_CACHE;


typedef struct _NAME_CACHE_CONTROL_ {

    FAST_MUTEX NameCacheLock;     // Lock to synchronize access to the list
    LIST_ENTRY ActiveList;        // List of active name cache entries
    LIST_ENTRY FreeList;          // Free list of NAME_CACHE structs
    ULONG EntryCount;             // Current number of NAME_CACHE entries allocated
    ULONG MaximumEntries;         // Max number of entries we will allocate
    ULONG MRxNameCacheSize;       // Size of Mini-rdr storage area in entry
    //
    // Stats
    //
    ULONG NumberActivates;        // Number of times cache was updated
    ULONG NumberChecks;           // Number of times cache was checked
    ULONG NumberNameHits;         // Number of times a valid match was returned
    ULONG NumberNetOpsSaved;      // Number of times mini-rdr saved a net op

    ULONG Spare[4];

} NAME_CACHE_CONTROL, *PNAME_CACHE_CONTROL;


//
// Return status for RxNameCacheCheckEntry()
//
typedef enum _RX_NC_CHECK_STATUS {
    RX_NC_SUCCESS = 0,
    RX_NC_TIME_EXPIRED,
    RX_NC_MRXCTX_FAIL
} RX_NC_CHECK_STATUS;



//
// Mini-rdr function to count the number of times the cached state avoided
// a trip to the server.
//
#define RxNameCacheOpSaved(_NCC) (_NCC)->NumberNetOpsSaved += 1



VOID
RxNameCacheInitialize(
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN ULONG MRxNameCacheSize,
    IN ULONG MaximumEntries
    );

PNAME_CACHE
RxNameCacheCreateEntry (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PUNICODE_STRING Name,
    IN BOOLEAN CaseInsensitive
    );

PNAME_CACHE
RxNameCacheFetchEntry (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PUNICODE_STRING Name
    );

RX_NC_CHECK_STATUS
RxNameCacheCheckEntry (
    IN PNAME_CACHE NameCache,
    IN ULONG MRxContext
    );

VOID
RxNameCacheActivateEntry (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PNAME_CACHE NameCache,
    IN ULONG LifeTime,
    IN ULONG MRxContext
    );

VOID
RxNameCacheExpireEntry (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PNAME_CACHE NameCache
    );

VOID
RxNameCacheExpireEntryWithShortName (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PUNICODE_STRING Name
    );

VOID
RxNameCacheFreeEntry (
    IN PNAME_CACHE_CONTROL NameCacheCtl,
    IN PNAME_CACHE NameCache
    );

VOID
RxNameCacheFinalize (
    IN PNAME_CACHE_CONTROL NameCacheCtl
    );

#endif // _NAME_CACHE_DEFINED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\mrxfcb.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mrxfFcb.h

Abstract:

    This module defines the macros/inline functions and function prototypes used by
    the mini redirectors to access the RDBSS wrapper data structures.

    IMPORTANT: All mini redirector writers cannot and should not make any assumptions
    about the layout of the RDBSS wrapper data structures. They are not guaranteed to
    be the same across platforms and even on a single platform are liable to change
    across versions.

    The following six data structure abstractions are available to the mini
    redirector writer.

       1) Server Call Context (SRV_CALL)
            The context associated with each known file system server.

       2) Net Roots (NET_ROOT)
            The root of a file system volume( local/remote) opened by the user.

       3) Virtual Net Roots (V_NET_ROOT)
            The view of a file system volume on a server. The view can be
            constrained along multiple dimensions. As an example the view can be
            associated with a logon id. which will constrain the operations that
            can be performed on the file system volume.

       4) File Control Blocks (FCB)
            The RDBSS data structure associated with each unique file opened.

       5) File Object Extensions (FOXB)

       6) ServerSide Open Context (SRV_OPEN)

    A common convention that is adopted for defining Flags in all of these data structures
    is to define a ULONG ( 32 ) flags and split them into two groups -- those that are visible
    to the mini redirector and those that are invisible. These flags are not meant for use
    by the mini redirector writers and are reserved for the wrapper.

Author:

    Balan Sethu Raman    [SethuR]   23-Oct-1995

Revision History:

--*/

#ifndef __MRXFCB_H__
#define __MRXFCB_H__

// The SRVCALL flags are split into two groups, i.e., visible to mini rdrs and invisible to mini rdrs.
// The visible ones are defined above and the definitions for the invisible ones can be found
// in fcb.h. The convention that has been adopted is that the lower 16 flags will be visible
// to the mini rdr and the upper 16 flags will be reserved for the wrapper. This needs to be
// enforced in defining new flags.

#define SRVCALL_FLAG_MAILSLOT_SERVER              (0x1)
#define SRVCALL_FLAG_FILE_SERVER                  (0x2)
#define SRVCALL_FLAG_CASE_INSENSITIVE_NETROOTS    (0x4)
#define SRVCALL_FLAG_CASE_INSENSITIVE_FILENAMES   (0x8)
#define SRVCALL_FLAG_DFS_AWARE_SERVER             (0x10)
#define SRVCALL_FLAG_FORCE_FINALIZED              (0x20)

typedef struct _MRX_NORMAL_NODE_HEADER {
   NODE_TYPE_CODE           NodeTypeCode;
   NODE_BYTE_SIZE           NodeByteSize;
   ULONG                    NodeReferenceCount;
} MRX_NORMAL_NODE_HEADER;

#ifdef __cplusplus
typedef struct _MRX_SRV_CALL_ : public MRX_NORMAL_NODE_HEADER {
#else // !__cplusplus
typedef struct _MRX_SRV_CALL_ {
    MRX_NORMAL_NODE_HEADER;
#endif // __cplusplus

   // !!!! changes above this require realignment with fcb.h

   // the context fields for extensions required by the mini redirectors

   PVOID                    Context;
   PVOID                    Context2;

   // Associated DeviceObject which also contains the dispatch vector

   PRDBSS_DEVICE_OBJECT     RxDeviceObject;

   // the srv call name, the server principal name and the server domain name.

   PUNICODE_STRING          pSrvCallName;
   PUNICODE_STRING          pPrincipalName;
   PUNICODE_STRING          pDomainName;

   // Flags used to denote the state of the SRV_CALL.

   ULONG                    Flags;

   // Server parameters updated by the mini redirectors.
   LONG                     MaximumNumberOfCloseDelayedFiles;

   // Status return from the transport in case of failure
   NTSTATUS                 Status;

} MRX_SRV_CALL, *PMRX_SRV_CALL;

// The various types of NET_ROOT's currently supported by the wrapper.
#define   NET_ROOT_DISK      ((UCHAR)0)
#define   NET_ROOT_PIPE      ((UCHAR)1)
#define   NET_ROOT_COMM      ((UCHAR)2)
#define   NET_ROOT_PRINT     ((UCHAR)3)
#define   NET_ROOT_WILD      ((UCHAR)4)
#define   NET_ROOT_MAILSLOT  ((UCHAR)5)
typedef UCHAR NET_ROOT_TYPE, *PNET_ROOT_TYPE;

// The pipe buffer size for transferring cannot be larger than 0xffff
#define   MAX_PIPE_BUFFER_SIZE    0xFFFF

// The possible states associated with a NET_ROOT. These have been defined to be
// line with the definitions foe the LanManager service to avoid redundant mappings.
// These MUST agree with sdkinc\lmuse.h use_ok, etc.....

#define   MRX_NET_ROOT_STATE_GOOD         ((UCHAR)0)
#define   MRX_NET_ROOT_STATE_PAUSED       ((UCHAR)1)
#define   MRX_NET_ROOT_STATE_DISCONNECTED ((UCHAR)2)
#define   MRX_NET_ROOT_STATE_ERROR        ((UCHAR)3)
#define   MRX_NET_ROOT_STATE_CONNECTED    ((UCHAR)4)
#define   MRX_NET_ROOT_STATE_RECONN       ((UCHAR)5)
typedef UCHAR MRX_NET_ROOT_STATE, *PMRX_NET_ROOT_STATE;

// The file systems on the remote servers provide varying levels of functionality to
// detect aliasing between file names. As an example consider two shares on the same
// file system volume. In the absence of any support from the file system on the server
// the correct and conservative approach is to flush all the files to the server as
// opposed to all the files on the same NET_ROOT to preserve coherency and handle
// delayed close operations.

#define   MRX_PURGE_SAME_NETROOT         ((UCHAR)0)
#define   MRX_PURGE_SAME_SRVCALL         ((UCHAR)1)
//these are not implemented yet....
//#define   MRX_PURGE_SAME_FCB           ((UCHAR)2)
//#define   MRX_PURGE_SAME_VOLUME        ((UCHAR)3)
//#define   MRX_PURGE_ALL                ((UCHAR)4)
typedef UCHAR MRX_PURGE_RELATIONSHIP, *PMRX_PURGE_RELATIONSHIP;

#define   MRX_PURGE_SYNC_AT_NETROOT         ((UCHAR)0)
#define   MRX_PURGE_SYNC_AT_SRVCALL         ((UCHAR)1)
typedef UCHAR MRX_PURGE_SYNCLOCATION, *PMRX_PURGE_SYNCLOCATION;

// The NET_ROOT flags are split into two groups, i.e., visible to mini rdrs and
// invisible to mini rdrs. The visible ones are defined above and the definitions
// for the invisible ones can be found in fcb.h. The convention that has been
// adopted is that the lower 16 flags will be visible to the mini rdr and the
// upper 16 flags will be reserved for the wrapper. This needs to be enforced
// in defining new flags.

#define NETROOT_FLAG_SUPPORTS_SYMBOLIC_LINKS  ( 0x0001 )
#define NETROOT_FLAG_DFS_AWARE_NETROOT        ( 0x0002 )
#define NETROOT_FLAG_DEFER_READAHEAD          ( 0x0004 )
#define NETROOT_FLAG_VOLUMEID_INITIALIZED     ( 0x0008 )
#define NETROOT_FLAG_FINALIZE_INVOKED         ( 0x0010 )
#define NETROOT_FLAG_UNIQUE_FILE_NAME         ( 0x0020 )

//
// Read ahead amount used for normal data files (32k)

#define DEFAULT_READ_AHEAD_GRANULARITY           (0x08000)

//
// the wrapper implements throttling for certain kinds of operations:
//      PeekNamedPipe/ReadNamedPipe
//      LockFile
//
// a minirdr can set the timing parameters for this in the netroot. leaving them
// as zero will disable throttling.

typedef struct _NETROOT_THROTTLING_PARAMETERS {
    ULONG Increment;     // Supplies the increase in delay in milliseconds, each time a request
                         // to the network fails.
    ULONG MaximumDelay;  // Supplies the longest delay the backoff package can introduce
                         // in milliseconds.
} NETROOT_THROTTLING_PARAMETERS, *PNETROOT_THROTTLING_PARAMETERS;

#define RxInitializeNetRootThrottlingParameters(__tp,__incr,__maxdelay) { \
       PNETROOT_THROTTLING_PARAMETERS tp = (__tp);                         \
       tp->Increment = (__incr);                                   \
       tp->MaximumDelay = (__maxdelay);                            \
}

#ifdef __cplusplus
typedef struct _MRX_NET_ROOT_ : public MRX_NORMAL_NODE_HEADER {
#else // !__cplusplus
typedef struct _MRX_NET_ROOT_ {
    MRX_NORMAL_NODE_HEADER;
#endif // __cplusplus

   // the MRX_SRV_CALL instance with which this MRX_NET_ROOT instance is associated

   PMRX_SRV_CALL      pSrvCall;

   // !!!! changes above this require realignment with fcb.h

   // the context fields used by the mini redirectors for recording
   // additional state.

   PVOID              Context;
   PVOID              Context2;

   // The flags used to denote the state of the NET_ROOT instance.

   ULONG              Flags;

   // We count the number of fcbs, srvopens on the netroot

   ULONG NumberOfFcbs;
   ULONG NumberOfSrvOpens;

   // The current state and the purge relationships based on the support
   // provided by the file system on the server.

   MRX_NET_ROOT_STATE     MRxNetRootState;
   NET_ROOT_TYPE          Type;
   MRX_PURGE_RELATIONSHIP PurgeRelationship;
   MRX_PURGE_SYNCLOCATION PurgeSyncLocation;

   // the type of device, i.e., file system volume, printer, com port etc.

   DEVICE_TYPE            DeviceType;

   // Name of the NET_ROOT instance

   PUNICODE_STRING        pNetRootName;

   // the name to be prepended to all FCBS associated with this NET_ROOT

   UNICODE_STRING     InnerNamePrefix;

   // Parameters based upon the type of the NET_ROOT.

   ULONG  ParameterValidationStamp;
   union {
      struct {
         ULONG  DataCollectionSize;
         NETROOT_THROTTLING_PARAMETERS PipeReadThrottlingParameters;
      } NamedPipeParameters;

      struct {
         ULONG  ClusterSize;
         ULONG  ReadAheadGranularity;
         NETROOT_THROTTLING_PARAMETERS LockThrottlingParameters;
         ULONG  RenameInfoOverallocationSize; //could be a USHORT
         GUID   VolumeId;
      } DiskParameters;
   };
} MRX_NET_ROOT, *PMRX_NET_ROOT;


// The VNET_ROOT flags are split into two groups, i.e., visible to mini rdrs and
// invisible to mini rdrs. The visible ones are defined below and the definitions
// for the invisible ones can be found in fcb.h. The convention that has been
// adopted is that the lower 16 flags will be visible to the mini rdr and the
// upper 16 flags will be reserved for the wrapper. This needs to be enforced
// in defining new flags.

#define VNETROOT_FLAG_CSCAGENT_INSTANCE   0x00000001
#define VNETROOT_FLAG_FINALIZE_INVOKED    0x00000002
#define VNETROOT_FLAG_FORCED_FINALIZE     0x00000004
#define VNETROOT_FLAG_NOT_FINALIZED    0x00000008

#ifdef __cplusplus
typedef struct _MRX_V_NET_ROOT_ : public MRX_NORMAL_NODE_HEADER {
#else // !__cplusplus
typedef struct _MRX_V_NET_ROOT_ {
    MRX_NORMAL_NODE_HEADER;
#endif // __cplusplus

   // the MRX_NET_ROOT instance with which the MRX_V_NET_ROOT instance is associated

   PMRX_NET_ROOT      pNetRoot;

   // !!!! changes above this require realignment with fcb.h

   // the context fields provided for storing additional information as deemed
   // necessary by the mini redirectors

   PVOID              Context;
   PVOID              Context2;

   ULONG              Flags;

   // This field should not be updated by the mini redirectors. Its usage is intended
   // to provide an easy mechanism for accessing certain state information

   ULONG              NumberOfOpens;

   // We count the number of Fobxss on the virtual netroot

   ULONG              NumberOfFobxs;

   // the security parameters associated with the V_NET_ROOT instance.

   LUID               LogonId;

   // These are the parameters supplied by the used in a NtCreateFile call in
   // which the FILE_CREATE_TREE_CONNECTION flag is specified as part of the
   // CreateOptions.

   PUNICODE_STRING    pUserDomainName;
   PUNICODE_STRING    pUserName;
   PUNICODE_STRING    pPassword;
   ULONG              SessionId;
   NTSTATUS           ConstructionStatus;
   BOOLEAN            IsExplicitConnection;
} MRX_V_NET_ROOT, *PMRX_V_NET_ROOT;


//  the following flags describe the fcb state. the fcbstate is readonly
//  for minirdrs. the buffering/cacheing flags are set in the wrapper in
//  response to changebufferingstate calls


#define FCB_STATE_WRITECACHEING_ENABLED          ( 0x08000000 )
#define FCB_STATE_WRITEBUFFERING_ENABLED         ( 0x04000000 )
#define FCB_STATE_READCACHEING_ENABLED           ( 0x02000000 )
#define FCB_STATE_READBUFFERING_ENABLED          ( 0x01000000 )
#define FCB_STATE_OPENSHARING_ENABLED            ( 0x00800000 )
#define FCB_STATE_COLLAPSING_ENABLED             ( 0x00400000 )
#define FCB_STATE_LOCK_BUFFERING_ENABLED         ( 0x00200000 )
#define FCB_STATE_FILESIZECACHEING_ENABLED       ( 0x00100000 )
#define FCB_STATE_FILETIMECACHEING_ENABLED       ( 0x00080000 )

#define FCB_STATE_TIME_AND_SIZE_ALREADY_SET      ( 0x00040000 )

#define FCB_STATE_ORPHANED                       ( 0x00000080 )

#define FCB_STATE_DELETE_ON_CLOSE                ( 0x00000001 )

//
// ALL FIELDS IN AN FCB ARE READONLY EXCEPT Context and Context2....
// Also, Context is read only the the mini has specified RDBSS_MANAGE_FCB_EXTENSION
typedef struct _MRX_FCB_ {
   FSRTL_ADVANCED_FCB_HEADER Header;

   // The MRX_NET_ROOT instance with which this is associated

   PMRX_NET_ROOT    pNetRoot;

   // !!!! changes above this require realignment with fcb.h

   // the context fields to store additional information as deemed necessary by the
   // mini redirectors.

   PVOID            Context;
   PVOID            Context2;

   // The reference count: in a different place because we must prefix with
   // the FSRTL_COMMON_FCB_HEADER structure.

   ULONG            NodeReferenceCount;

    //
    //  The internal state of the Fcb.  THIS FIELD IS READONLY FOR MINIRDRS
    //

    ULONG           FcbState;

    //  A count of the number of file objects that have been opened for
    //  this file/directory, but not yet been cleaned up yet.  This count
    //  is only used for data file objects, not for the Acl or Ea stream
    //  file objects.  This count gets decremented in RxCommonCleanup,
    //  while the OpenCount below gets decremented in RxCommonClose.

    CLONG           UncleanCount;

    //  A count of the number of file objects that have been opened for
    //  this file/directory, but not yet been cleaned up yet and for which
    //  cacheing is not supported. This is used in cleanup.c to tell if extra
    //  purges are required to maintain coherence.

    CLONG           UncachedUncleanCount;

    //  A count of the number of file objects that have opened
    //  this file/directory.  For files & directories the FsContext of the
    //  file object points to this record.

    CLONG           OpenCount;


   // The outstanding locks count: if this count is nonzero, the we silently
   // ignore adding LOCK_BUFFERING in a ChangeBufferingState request. This field
   // is manipulated by interlocked operations so you only have to have the fcb
   // shared to manipulate it but you have to have it exclusive to use it.

   ULONG            OutstandingLockOperationsCount;

   // The actual allocation length as opposed to the valid data length

   ULONGLONG        ActualAllocationLength;

   // Attributes of the MRX_FCB,

   ULONG            Attributes;

   // Intended for future use, currently used to round off allocation to
   // DWORD boundaries.

   BOOLEAN          Spare1;
   BOOLEAN          fShouldBeOrphaned;
   BOOLEAN          fMiniInited;

   // Type of the associated MRX_NET_ROOT, intended to avoid pointer chasing.

   UCHAR            CachedNetRootType;

    //  Header for the list of srv_opens for this FCB....
    //  THIS FIELD IS READONLY FOR MINIS

    LIST_ENTRY              SrvOpenList;

    //  changes whenever the list changes..prevents extra lookups
    //  THIS FIELD IS READONLY FOR MINIS

    ULONG                   SrvOpenListVersion;

} MRX_FCB, *PMRX_FCB;


// The following flags define the various types of buffering that can be selectively
// enabled or disabled for each SRV_OPEN.
//

#define SRVOPEN_FLAG_DONTUSE_READ_CACHEING                  (0x1)
#define SRVOPEN_FLAG_DONTUSE_WRITE_CACHEING                 (0x2)
#define SRVOPEN_FLAG_CLOSED                                 (0x4)
#define SRVOPEN_FLAG_CLOSE_DELAYED                          (0x8)
#define SRVOPEN_FLAG_FILE_RENAMED                           (0x10)
#define SRVOPEN_FLAG_FILE_DELETED                           (0x20)
#define SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_PENDING         (0x40)
#define SRVOPEN_FLAG_COLLAPSING_DISABLED                    (0x80)
#define SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_REQUESTS_PURGED (0x100)
#define SRVOPEN_FLAG_NO_BUFFERING_STATE_CHANGE              (0x200)
#define SRVOPEN_FLAG_ORPHANED                               (0x400)

#ifdef __cplusplus
typedef struct _MRX_SRV_OPEN_ : public MRX_NORMAL_NODE_HEADER {
#else // !__cplusplus
typedef struct _MRX_SRV_OPEN_ {
    MRX_NORMAL_NODE_HEADER;
#endif // __cplusplus

    // the MRX_FCB instance with which the SRV_OPEN is associated.

    PMRX_FCB pFcb;

    // the V_NET_ROOT instance with which the SRV_OPEN is associated

    PMRX_V_NET_ROOT pVNetRoot;

    // !!!! changes above this require realignment with fcb.h

    // the context fields to store additional state information as deemed necessary
    // by the mini redirectors

    PVOID        Context;
    PVOID        Context2;

    // The flags are split into two groups, i.e., visible to mini rdrs and invisible
    // to mini rdrs. The visible ones are defined above and the definitions for the
    // invisible ones can be found in fcb.h. The convention that has been adopted is
    // that the lower 16 flags will be visible to the mini rdr and the upper 16 flags
    // will be reserved for the wrapper. This needs to be enforced in defining new flags.

    ULONG        Flags;

    // the name alongwith the MRX_NET_ROOT prefix, i.e. fully qualified name

    PUNICODE_STRING pAlreadyPrefixedName;


    // the number of Fobx's associated with this open for which a cleanup IRP
    // has not been processed.

    CLONG        UncleanFobxCount;

    // the number of local opens associated with this open on the server

    CLONG        OpenCount;

    // the Key assigned by the mini redirector for this SRV_OPEN. Since the various mini
    // redirectors do not always get to pick the unique id for a open instance, the key
    // used to identify the open to the server is different for different mini redirectors
    // based upon the convention adopted at the server.

    PVOID        Key;

    // the access and sharing rights specified for this SRV_OPEN. This is used in
    // determining is subsequent open requests can be collapsed  with an existing
    // SRV_OPEN instance.

    ACCESS_MASK  DesiredAccess;
    ULONG        ShareAccess;
    ULONG        CreateOptions;

    // The BufferingFlags field is temporal.....it does not really belong to the
    // srvopen; rather the srvopen is used as a representative of the fcb. On
    // each open, the bufferingflags field of the srvopen is taken as the minirdr's
    // contribution to the buffering state. On an oplock break, a srvopen is passed
    // (the one that's being broken) whose bufferflags field is taken as the new
    // proxy. On a close that changes the minirdr's contribution, the minirdr should
    // take steps to cause a ChangeBufferingState to the new state.
    //
    // just to reiterate, the field is just used to carry the information from
    // the minirdr to RxChangeBufferingState and does not hold longterm coherent
    // information.

    ULONG        BufferingFlags;

    // List Entry to wire the SRV_OPEN to the list of SRV_OPENS maintained as
    // part of theFCB
    //  THIS FIELD IS READONLY FOR MINIS

    ULONG       ulFileSizeVersion;

    LIST_ENTRY    SrvOpenQLinks;

} MRX_SRV_OPEN, *PMRX_SRV_OPEN;

#define FOBX_FLAG_DFS_OPEN        (0x0001)
#define FOBX_FLAG_BAD_HANDLE      (0x0002)
#define FOBX_FLAG_BACKUP_INTENT   (0x0004)
#define FOBX_FLAG_NOT_USED        (0x0008)

#define FOBX_FLAG_FLUSH_EVEN_CACHED_READS   (0x0010)
#define FOBX_FLAG_DONT_ALLOW_PAGING_IO      (0x0020)
#define FOBX_FLAG_DONT_ALLOW_FASTIO_READ    (0x0040)

typedef struct _MRX_PIPE_HANDLE_INFORMATION {

    ULONG         TypeOfPipe;
    ULONG         ReadMode;
    ULONG         CompletionMode;

} MRX_PIPE_HANDLE_INFORMATION, *PMRX_PIPE_HANDLE_INFORMATION;

#ifdef __cplusplus
typedef struct _MRX_FOBX_ : public MRX_NORMAL_NODE_HEADER {
#else // !__cplusplus
typedef struct _MRX_FOBX_ {
    MRX_NORMAL_NODE_HEADER;
#endif // __cplusplus

    // the MRX_SRV_OPEN instance with which the FOBX is associated

    PMRX_SRV_OPEN    pSrvOpen;

    // the FILE_OBJECT with which this FOBX is associated
    // In certain instances the I/O subsystem creates a FILE_OBJECT instance
    // on the stack in the interests of efficiency. In such cases this field
    // is NULL.

    PFILE_OBJECT     AssociatedFileObject;

    // !!!! changes above this require realignment with fcb.h

    // The fields provided to accomodate additional state to be associated
    // by the various mini redirectors

    PVOID            Context;
    PVOID            Context2;

    // The FOBX flags are split into two groups, i.e., visible to mini rdrs and invisible to mini rdrs.
    // The visible ones are defined above and the definitions for the invisible ones can be found
    // in fcb.h. The convention that has been adopted is that the lower 16 flags will be visible
    // to the mini rdr and the upper 16 flags will be reserved for the wrapper. This needs to be
    // enforced in defining new flags.

    ULONG            Flags;

    union {
        struct {
            //
            //  The query template is used to filter directory query requests.
            //  It originally is set to null and on the first call the NtQueryDirectory
            //  it is set to the input filename or "*" if the name is not supplied.
            //  All subsquent queries then use this template.

            UNICODE_STRING UnicodeQueryTemplate;
        }; //for directories

        PMRX_PIPE_HANDLE_INFORMATION PipeHandleInformation;   //for pipes
    };

    //
    //  The following field is used as an offset into the Eas for a
    //  particular file.  This will be the offset for the next
    //  Ea to return.  A value of 0xffffffff indicates that the
    //  Ea's are exhausted.
    //

    // This field is manipulated directly by the smbmini....maybe it should move down
    // one thing is that it is a reminder that NT allows a resume on getting EAs

    ULONG OffsetOfNextEaToReturn;
} MRX_FOBX, *PMRX_FOBX;

// Resource accquisition routines.
//
// The synchronization resources of interest to mini redirector writers are
// primarily associated with the FCB. There is a paging I/O resource and a
// regular resource. The paging I/O resource is managed by the wrapper. The only
// resource accesible to mini redirector writers is the regular resource which
// should be accessed using the supplied routines.

extern NTSTATUS
RxAcquireExclusiveFcbResourceInMRx(
    PMRX_FCB pFcb);

extern NTSTATUS
RxAcquireSharedFcbResourceInMRx(
    PMRX_FCB pFcb);

extern VOID
RxReleaseFcbResourceInMRx(
    PMRX_FCB pFcb);


#endif // __MRXFCB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\nodetype.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in the RDBSS.
    Every major data structure in the file system is assigned a node
    type code that is.  This code is the first CSHORT in the structure and is
    followed by a CSHORT containing the size, in bytes, of the structure.

Author:

    JoeLinn     [Joelinn]    9-July-1994

Revision History:

--*/

#ifndef _NODETYPE_INCLUDED_
#define _NODETYPE_INCLUDED_


typedef USHORT          NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;
typedef CSHORT NODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME, *PRECORD_NAME;
//

#define NodeType(Ptr) (*((PNODE_TYPE_CODE)(Ptr)))


typedef struct _NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT {
      NODE_TYPE_CODE NodeTypeCode;
      NODE_BYTE_SIZE NodeByteSize;
}  NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT;

#ifdef __cplusplus
typedef struct _NODE_TYPE_CODE_AND_SIZE : public NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT {
#else // !__cplusplus
typedef struct _NODE_TYPE_CODE_AND_SIZE {
      NODE_TYPE_CODE_AND_SIZE_NO_REFCOUNT;
#endif // __cplusplus
      ULONG          NodeReferenceCount; //this is for guys with reference counts....not everyone has one
}  NODE_TYPE_CODE_AND_SIZE;


#define ZeroAndInitializeNodeType(Ptr,TType,Size) {\
        RtlZeroMemory( Ptr, Size );   \
        ((NODE_TYPE_CODE_AND_SIZE *)(Ptr))->NodeTypeCode = TType;   \
        ((NODE_TYPE_CODE_AND_SIZE *)(Ptr))->NodeByteSize = (CSHORT)Size;    \
        }


//
// N O D E T Y P E S


// 0xeb00 was selected as being far from the other codes
// 0xec00 was added so that we could encode the structure type in the code.

#define NTC_UNDEFINED                    ((NODE_TYPE_CODE)0x0000)



#define RDBSS_STORAGE_NTC(x) (0xec00+(x))

// these are here to ensure that we don't use any of the old cairo storage types.
#define StorageTypeDirectory (@@@)
#define StorageTypeFile (@@@)

typedef enum _RX_FILE_TYPE {
    FileTypeNotYetKnown   = 0,
    FileTypeDirectory = 2,
    FileTypeFile      = 3
} RX_FILE_TYPE;
//according to markz, i should plan on the number of STORAGE_NTCs growing to bytesize!!
typedef enum _RDBSS_STORAGE_TYPE_CODES{
     RDBSS_NTC_STORAGE_TYPE_UNKNOWN		       = RDBSS_STORAGE_NTC(FileTypeNotYetKnown),
     RDBSS_NTC_STORAGE_TYPE_DIRECTORY     	   = RDBSS_STORAGE_NTC(FileTypeDirectory),
     RDBSS_NTC_STORAGE_TYPE_FILE		       = RDBSS_STORAGE_NTC(FileTypeFile),

     RDBSS_NTC_OPENTARGETDIR_FCB   =  RDBSS_STORAGE_NTC(0xff),   //must be an fcb type and not the same
     RDBSS_NTC_IPC_SHARE           =  RDBSS_STORAGE_NTC(0xfe),
     RDBSS_NTC_MAILSLOT            =  RDBSS_STORAGE_NTC(0xfd),
     RDBSS_NTC_SPOOLFILE           =  RDBSS_STORAGE_NTC(0xfc),

     RDBSS_NTC_SRVCALL         =      (NODE_TYPE_CODE)0xeb10,
     RDBSS_NTC_NETROOT         =      (NODE_TYPE_CODE)0xeb11,
     RDBSS_NTC_V_NETROOT       =      (NODE_TYPE_CODE)0xeb12,

//Local filesystems sometimes need volume opens. these are not yet
//    implemented but we reserve the nodetype now.

     RDBSS_NTC_VOLUME_FCB      =      (NODE_TYPE_CODE)0xeb1f,


     RDBSS_NTC_SRVOPEN         =      (NODE_TYPE_CODE)0xeb1c,
     RDBSS_NTC_INTERNAL_SRVOPEN =     (NODE_TYPE_CODE)0xeb1d,
     RDBSS_NTC_DEVICE_FCB      =      (NODE_TYPE_CODE)0xeb9a,

     RDBSS_NTC_DATA_HEADER     =      (NODE_TYPE_CODE)0xeb00,
     RDBSS_NTC_VCB             =      (NODE_TYPE_CODE)0xeb01,
     RDBSS_NTC_ROOT_DCB        =      (NODE_TYPE_CODE)0xeb04,
     RDBSS_NTC_FOBX            =      (NODE_TYPE_CODE)0xeb07,
     RDBSS_NTC_RX_CONTEXT     =       (NODE_TYPE_CODE)0xeb08,

     RDBSS_NTC_PREFIX_TABLE    =      (NODE_TYPE_CODE)0xeb0d,
     RDBSS_NTC_PREFIX_ENTRY    =      (NODE_TYPE_CODE)0xeb0e,

     RDBSS_NTC_FCB_TABLE       =      (NODE_TYPE_CODE)0xeb09,
     RDBSS_NTC_FCB_TABLE_ENTRY =      (NODE_TYPE_CODE)0xeb0a,

     RDBSS_NTC_RXCE_TRANSPORT  =      (NODE_TYPE_CODE)0xeb71,
     RDBSS_NTC_RXCE_ADDRESS    =      (NODE_TYPE_CODE)0xeb72,
     RDBSS_NTC_RXCE_CONNECTION =      (NODE_TYPE_CODE)0xeb73,
     RDBSS_NTC_RXCE_VC         =      (NODE_TYPE_CODE)0xeb74,

     RDBSS_NTC_NONPAGED_FCB     =      (NODE_TYPE_CODE)0xebfd,
     RDBSS_NTC_COMMON_DISPATCH  =      (NODE_TYPE_CODE)0xebfe,
     RDBSS_NTC_MINIRDR_DISPATCH =      (NODE_TYPE_CODE)0xebff

} RDBSS_STORAGE_TYPE_CODES;

#define RDBSS_NTC_FCB                      RDBSS_NTC_STORAGE_TYPE_FILE

#define NodeTypeIsFcb(FCB) \
    (  ((NodeType(FCB)&0xff00)== RDBSS_STORAGE_NTC(0)) ||  ((NodeType(FCB)&0xfff0)==0xeb90)   )

// a mask to alter the type of a data structure once it is marked for scavenging so
// that subsequent tests will fail.

#define RX_SCAVENGER_MASK (0x1000)


//
//  The following definitions are used to generate meaningful blue bugcheck
//  screens.  On a bugcheck the file system can output 4 ulongs of useful
//  information.  The first ulong will have encoded the line number of the
//  bugcheck call in the low order 16 bits. The high order bits can be whatever
//  the caller wants. In the wrapper, we actually define file identifiers as well.
//  However, the system also displays quire a but of the backtrace; this shows
//  the .sys file of the caller and it is frequently the case that the linenumber
//  is completely disambiguating.

//  Each individual wrapper file that calls bugcheck has defined at the
//  start of the file a constant called BugCheckFileId with one of the
//  RDBSS_BUG_CHECK_ values defined below and then use RxBugCheck to bugcheck
//  the system.
//


typedef enum _RDBSS_BUG_CHECK_CODES {

     RDBSS_BUG_CHECK_FCBSTRUC  = 0xfcb00000,
     RDBSS_BUG_CHECK_CACHESUP  = 0xca550000,
     RDBSS_BUG_CHECK_CLEANUP   = 0xc1ee0000,
     RDBSS_BUG_CHECK_CLOSE     = 0xc10e0000,
     RDBSS_BUG_CHECK_NTEXCEPT  = 0xbaad0000,

} RDBSS_BUG_CHECK_CODES;

// we overload on the original redirector's bugcheck code using the stack
// backtrace to differentiate among consumers

#define RDBSS_FILE_SYSTEM RDR_FILE_SYSTEM
#define RxBugCheck(A,B,C) { \
        KeBugCheckEx(RDBSS_FILE_SYSTEM, \
                     BugCheckFileId | ((ULONG)(__LINE__)), \
                     A, B, C ); \
        }


//
//  In this module we'll also define some globally known constants
//

#define UCHAR_NUL                        0x00
#define UCHAR_SOH                        0x01
#define UCHAR_STX                        0x02
#define UCHAR_ETX                        0x03
#define UCHAR_EOT                        0x04
#define UCHAR_ENQ                        0x05
#define UCHAR_ACK                        0x06
#define UCHAR_BEL                        0x07
#define UCHAR_BS                         0x08
#define UCHAR_HT                         0x09
#define UCHAR_LF                         0x0a
#define UCHAR_VT                         0x0b
#define UCHAR_FF                         0x0c
#define UCHAR_CR                         0x0d
#define UCHAR_SO                         0x0e
#define UCHAR_SI                         0x0f
#define UCHAR_DLE                        0x10
#define UCHAR_DC1                        0x11
#define UCHAR_DC2                        0x12
#define UCHAR_DC3                        0x13
#define UCHAR_DC4                        0x14
#define UCHAR_NAK                        0x15
#define UCHAR_SYN                        0x16
#define UCHAR_ETB                        0x17
#define UCHAR_CAN                        0x18
#define UCHAR_EM                         0x19
#define UCHAR_SUB                        0x1a
#define UCHAR_ESC                        0x1b
#define UCHAR_FS                         0x1c
#define UCHAR_GS                         0x1d
#define UCHAR_RS                         0x1e
#define UCHAR_US                         0x1f
#define UCHAR_SP                         0x20

#endif // _NODETYPE_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\ntrxdef.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    NtRxDef.h

Abstract:

    This module defines a whole host of macros that orient the code towards NT
    as opposed to Win9x.

Author:

    Joe Linn     [JoeLinn]   19-aug-1994

Revision History:
    Jim McNelis  [jimmcn]    14-mar-1995    added OAL defines.
    Sethu        [SethuR]    15-mar-1995    include OAL defines for RX_DATA_BUFFER (aka MDL )

--*/

#ifndef _RX_NTDEFS_DEFINED_
#define _RX_NTDEFS_DEFINED_

#define INLINE __inline

//from winbase.h:
#ifndef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE ((HANDLE)-1)
#endif //ifndef INVALID_HANDLE_VALUE

#define RxDeviceType(__xxx) ((DEVICE_TYPE)FILE_DEVICE_##__xxx)

// this macro is used in various places to assist in defining sets of constants
// that can be used to set/clear/test specific bits in a flags-type field
#define RX_DEFINE_FLAG(a,c,d)  a = ((1<<c)&d),

//we need this constant various places
#define TICKS_PER_SECOND (10 * 1000 * 1000)
#define TICKS_PER_MILLESECOND (10 * 1000)


int
RxSprintf(char *, const char *, ...);
#ifndef WRAPPER_CALLS_ONLY
#define RxSprintf sprintf
#endif //ifndef WRAPPER_CALLS_ONLY

//  the next set of macros defines how to get things out of the RxContext; however, RxContext is not
//  a macro parameter; rather, the appropriate pointers are just captured from whatever RxContext happens
//  to be around. Q: "why would you use RxCaptureFcb and then reference thru capFcb instead of just having
//  a macro like RxGetFcb() === RxContext->Fcb?" A: it is done this way to help with optimization. when you make
//  the RxGetFcb() call, the Fcb will have to be reloaded from the RxContext if you have called any procs; however,
//  it will not have to be reloaded with the capture technique.

#ifndef MINIRDR__NAME
#define RxCaptureFcb PFCB __C_Fcb = (PFCB)(RxContext->pFcb)
#define RxCaptureFobx PFOBX __C_Fobx = (PFOBX)(RxContext->pFobx)
#else
#define RxCaptureFcb PMRX_FCB __C_Fcb = (RxContext->pFcb)
#define RxCaptureFobx PMRX_FOBX __C_Fobx = (RxContext->pFobx)
#endif

#define RxCaptureRequestPacket PIRP __C_Irp = RxContext->CurrentIrp
#define RxCaptureParamBlock PIO_STACK_LOCATION __C_IrpSp = RxContext->CurrentIrpSp
#define RxCaptureFileObject PFILE_OBJECT __C_FileObject = __C_IrpSp-> FileObject

//
// the "cap" prefix means "Captured from the RxContext....."; it's ok after you get used to it

#define capFcb __C_Fcb
#define capFobx __C_Fobx
#define capPARAMS __C_IrpSp
#define capReqPacket __C_Irp
#define capFileObject __C_FileObject

#define RXCOMPRESSIONAPI

RXCOMPRESSIONAPI
NTSTATUS
RxDecompressBuffer (
    IN USHORT CompressionFormat,
    OUT PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    OUT PULONG FinalUncompressedSize
    );

RXCOMPRESSIONAPI
NTSTATUS
RxDecompressFragment (
    IN USHORT CompressionFormat,
    OUT PUCHAR UncompressedFragment,
    IN ULONG UncompressedFragmentSize,
    IN PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN ULONG FragmentOffset,
    OUT PULONG FinalUncompressedSize,
    IN PVOID WorkSpace
    );

RXCOMPRESSIONAPI
NTSTATUS
RxDescribeChunk (
    IN USHORT CompressionFormat,
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    OUT PULONG ChunkSize
    );

RXCOMPRESSIONAPI
NTSTATUS
RxReserveChunk (
    IN USHORT CompressionFormat,
    IN OUT PUCHAR *CompressedBuffer,
    IN PUCHAR EndOfCompressedBufferPlus1,
    OUT PUCHAR *ChunkBuffer,
    IN ULONG ChunkSize
    );

RXCOMPRESSIONAPI
NTSTATUS
RxCompressChunks (
    IN PUCHAR UncompressedBuffer,
    IN ULONG UncompressedBufferSize,
    OUT PUCHAR CompressedBuffer,
    IN ULONG CompressedBufferSize,
    IN OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PVOID WorkSpace
    );


// The following routines are used for pool allocation. On a checked build
// additional information, we add in callsite information and go to a set of
// routines that over perform various kinds of checking and guarding. On a free
// build we forego this luxury and go straight for the allocation.


#ifdef RX_POOL_WRAPPER

//
// These routines do various debug checks on the pool and the block
// being freed.
//
extern VOID *_RxAllocatePoolWithTag( ULONG PoolType, ULONG NumberOfBytes, ULONG Tag, PSZ File, ULONG line );
extern VOID  _RxFreePool( PVOID PoolBlock, PSZ File, ULONG line );
extern BOOLEAN _RxCheckMemoryBlock( PVOID PoolBlock, PSZ File, ULONG line );

#define RxAllocatePoolWithTag( type, size, tag ) \
        _RxAllocatePoolWithTag( type, size, tag, __FILE__, __LINE__ )

//#define RxAllocatePool( type, size ) \
//        _RxAllocatePoolWithTag( type, size, '??xR', __FILE__, __LINE__ )

#define RxFreePool( ptr ) \
        _RxFreePool( ptr, __FILE__, __LINE__ )

#define RxCheckMemoryBlock( ptr ) \
        _RxCheckMemoryBlock( ptr, __FILE__, __LINE__ )

#else  // NOT RX_POOL_WRAPPER

//
// For retail builds, we want to go right to the regular (de)allocator
//
//extern VOID *RxAllocatePool( ULONG PoolType, ULONG NumberOfBytes );
extern VOID *RxAllocatePoolWithTag( ULONG PoolType, ULONG NumberOfBytes, ULONG Tag );
extern VOID  RxFreePool( PVOID PoolBlock );
//extern BOOLEAN RxCheckMemoryBlock( PVOID PoolBlock, PSZ File, ULONG line );

#define RxCheckMemoryBlock( ptr ) {NOTHING;}

#endif // RX_POOL_WRAPPER

#define RxAllocatePool( type, size ) \
        RxAllocatePoolWithTag( type, size, '??xR' )

#if !DBG
#ifndef WRAPPER_CALLS_ONLY
#ifndef RX_POOL_WRAPPER
#define RxAllocatePoolWithTag ExAllocatePoolWithTag
#define RxFreePool ExFreePool
#endif //RX_POOL_WRAPPER
#endif //WRAPPER_CALLS_ONLY
#endif


extern NTSTATUS
RxDuplicateString(
         PUNICODE_STRING *pCopy,
         PUNICODE_STRING pOriginal,
         POOL_TYPE    PoolType);

#define RxIsResourceOwnershipStateExclusive(__r) (__r->Flag&ResourceOwnedExclusive)

#define RxProtectMdlFromFree(pMdl) {NOTHING;}
#define RxUnprotectMdlFromFree(pMdl) {NOTHING;}
#define RxMdlIsProtected(pMdl) (FALSE)
#define RxTakeOwnershipOfMdl(pMdl) {NOTHING;}
#define RxDisownMdl(pMdl) {NOTHING;}
#define RxMdlIsOwned(pMdl) (TRUE)

#define RxAllocateMdl(pBuffer,BufferSize) \
        IoAllocateMdl(pBuffer,BufferSize,FALSE,FALSE,NULL)

#define RxMdlIsLocked(pMdl)         ((pMdl)->MdlFlags & MDL_PAGES_LOCKED)
#define RxMdlSourceIsNonPaged(pMdl) ((pMdl)->MdlFlags & MDL_SOURCE_IS_NONPAGED_POOL)
#define RxMdlIsPartial(pMdl)        ((pMdl)->MdlFlags & MDL_PARTIAL)

#undef RxProbeAndLockPages
#define RxProbeAndLockPages(pMdl,Mode,Access,Status)              \
        Status = STATUS_SUCCESS;                                  \
        try {                                                     \
           MmProbeAndLockPages((pMdl), (Mode), (Access));         \
        } except (EXCEPTION_EXECUTE_HANDLER) {                    \
           Status = GetExceptionCode();                           \
        }

//
// Macros for dealing with network header MDLs
//

// This is the amount of space we preallocate in front of the smb header to hold
// transport headers.  This number came from the server.  I suspect it is a worse case
// value for all the transports that support MDL_NETWORK_HEADER

#define TRANSPORT_HEADER_SIZE 64 // IPX_HEADER_SIZE+MAC_HEADER_SIZE

// Mdls that are marked with the MDL_NETWORK_HEADER flag have extra space allocated before
// the current start address that can be used for prepending lower-level headers.  The idea
// is that when we want to prepend another header, we take the current mdl and adjust it to
// include this extra header at the front of the message.  This is not strictly kosher and relies
// on the behavior that the page the current header is on, and the page that the prepended header
// is on, is the same page.  The way the macros work is that if they are not on the same page,
// we don't set the NETWORK_HEADER flag, and the transport will use a second Mdl for the header.
//
// Note that the other wierd thing about this is that we don't use the true buffer sizes.  The
// buffer address is really offset TRANSPORT_HEADER_SIZE into the buffer.  The buffer size passed
// in the buffer size without the TRANSPORT_HEADER_SIZE included.  Thus if the addition of the
// TRANSPORT_HEADER_SIZE would cause the Mdl to span an additonal page, this optimization won't
// work.

#define RxInitializeHeaderMdl( pMdl, Va, Len ) { \
            MmInitializeMdl( pMdl, Va, Len ); \
            if (pMdl->ByteOffset >= TRANSPORT_HEADER_SIZE) { \
                pMdl->MdlFlags |= MDL_NETWORK_HEADER; \
            } \
        }

#define RxAllocateHeaderMdl( pBuffer, BufferSize, pMdl ) { \
            pMdl = RxAllocateMdl( pBuffer, BufferSize ); \
            if ( (pMdl) && (pMdl->ByteOffset >= TRANSPORT_HEADER_SIZE) ) { \
                pMdl->MdlFlags |= MDL_NETWORK_HEADER; \
            } \
        }

#define RxMdlIsHeader(pMdl)         ((pMdl)->MdlFlags & MDL_NETWORK_HEADER)

#define RxBuildPartialHeaderMdl( SourceMdl, TargetMdl, Va, Len ) { \
    IoBuildPartialMdl( SourceMdl, TargetMdl, Va, Len ); \
    if ( (SourceMdl->MdlFlags & MDL_NETWORK_HEADER) && \
         (TargetMdl->ByteOffset >= TRANSPORT_HEADER_SIZE) ) { \
            TargetMdl->MdlFlags |= MDL_NETWORK_HEADER; \
    } \
}

#define RxBuildHeaderMdlForNonPagedPool( pMdl) MmBuildMdlForNonPagedPool( pMdl )

#define RxProbeAndLockHeaderPages( pMdl, Mode, Access, Status ) \
         RxProbeAndLockPages( pMdl, Mode, Access, Status )

#define RxUnlockHeaderPages( pMdl ) MmUnlockPages( pMdl )




//  the next set of macros defines the prototype and the argument list for the toplevel (Common)
//  routines. these routines are just below the dispatch level and this is where the commonality
//  between win9x and NT begins. In addition, the RXCOMMON_SIGNATURE and accompanying capture macros
//  could be platform specific as well. We must pass at least the RxContext; but on a RISC machine with
//  lots of registers we could pass a lot more. An adjustment would have to be made in the
//  RxFsdCommonDispatch in this case since the parameters are not yet captured at that point.

// the reason why do say "RXSTATUS RxCommonRead (RXCOMMON_SIGNATURE)" instead
// of "RxCommon(Read)" is so that the standard tags programs will work. "RxCommon(Read):
// doesn;t look like a procedure definition

#define  RXCOMMON_SIGNATURE \
      PRX_CONTEXT RxContext

#define  RXCOMMON_ARGUMENTS \
      RxContext

#define RxGetRequestorProcess(RXCONTEXT) IoGetRequestorProcess(RXCONTEXT->CurrentIrp)

//
//  RxGetRequestorProcess() returns what IoGetRequestorProcess() returns, which
//  is a pointer to a process structure.  Truncating this to 32 bits does
//  not yield a value that is unique to the process.
//
//  When a 32 bit value that is unique to the process is desired,
//  RxGetRequestorProcessId() must be used instead.
//

#define RxGetRequestorProcessId(RXCONTEXT) \
              IoGetRequestorProcessId((RXCONTEXT)->CurrentIrp)

#define RxMarkContextPending(RXCONTEXT) \
              IoMarkIrpPending((RXCONTEXT)->CurrentIrp)

#define RxSetCancelRoutine(pIrp, pCancelRoutine)      \
        {                                             \
           KIRQL CurrentIrql;                         \
           IoAcquireCancelSpinLock(&CurrentIrql);     \
           IoSetCancelRoutine(pIrp,pCancelRoutine);   \
           IoReleaseCancelSpinLock(CurrentIrql);      \
        }

//we do this as a macro because we may want to record that we did this adjustment so that
//people who QFI for standardinfo will be forced to the net to get the right answer and that would
//probably be better as a routine

#define RxAdjustAllocationSizeforCC(FCB) {\
        if ((FCB)->Header.FileSize.QuadPart > (FCB)->Header.AllocationSize.QuadPart) {       \
            PMRX_NET_ROOT NetRoot = (FCB)->pNetRoot;                              \
            ULONGLONG ClusterSize = NetRoot->DiskParameters.ClusterSize;                     \
            ULONGLONG FileSize = (FCB)->Header.FileSize.QuadPart;                            \
            ASSERT(ClusterSize!=0);                                                          \
            (FCB)->Header.AllocationSize.QuadPart = (FileSize+ClusterSize)&~(ClusterSize-1); \
        }                                                                                    \
        ASSERT ((FCB)->Header.ValidDataLength.QuadPart <= (FCB)->Header.FileSize.QuadPart);  \
    }


#endif // _RX_NTDEFS_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\prefix.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    prefix.h

Abstract:

    This module defines the data structures that enable the RDBSS to use the prefix package
    to catalog its server and netroot names. For the moment, file/directory names use the same stuff.

Author:

    Joe Linn (JoeLinn)    8-8-94

Revision History:

--*/

#ifndef _RXPREFIX_
#define _RXPREFIX_

// this stuff is implemented in prefix.c

/*
   The current implementation uses a table that has as components:

     1) a prefix table
     2) a queue
     3) a version
     4) a lock

   You use the lock in the normal way: shared to lookup; eclusive to change. the version changes
   eith each change. The reason that we have the queue is that the prefix table package allows
   caller to be enumerating at a time..... the Q/version approach allows multiple guys at a time.
   The Q could be used as a faster lookup for filenames but the prefix table is definitely the
   right thing for netroots.

*/

typedef struct _RX_CONNECTION_ID {
    union {
        ULONG SessionID;
        LUID  Luid;
    };
} RX_CONNECTION_ID, *PRX_CONNECTION_ID;

ULONG
RxTableComputeHashValue (
    IN  PUNICODE_STRING  Name
    );

PVOID
RxPrefixTableLookupName(
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  CanonicalName,
    OUT PUNICODE_STRING  RemainingName,
    IN  PRX_CONNECTION_ID ConnectionId
    );

PRX_PREFIX_ENTRY
RxPrefixTableInsertName (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY ThisEntry,
    IN     PVOID            Container,
    IN     PULONG           ContainerRefCount,
    IN     USHORT           CaseInsensitiveLength,
    IN     PRX_CONNECTION_ID ConnectionId
    );

VOID
RxRemovePrefixTableEntry(
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY Entry
    );

VOID
RxDereferenceEntryContainer(
    IN OUT PRX_PREFIX_ENTRY Entry,
    IN  PRX_PREFIX_TABLE PrefixTable
    );

BOOLEAN
RxIsNameTableEmpty(
    IN PRX_PREFIX_TABLE ThisTable);

#if 0
#define RX_PREFIXTABLELOCK_ARGS ,__FILE__,__LINE__
#define RX_PREFIXTABLELOCK_PARAMS ,PSZ FileName,ULONG LineNumber
#else
#define RX_PREFIXTABLELOCK_ARGS
#define RX_PREFIXTABLELOCK_PARAMS
#endif

#define RxAcquirePrefixTableLockShared(pPrefixTable,Wait) \
        RxpAcquirePrefixTableLockShared((pPrefixTable),(Wait),TRUE RX_PREFIXTABLELOCK_ARGS)

#define RxAcquirePrefixTableLockExclusive(pPrefixTable,Wait) \
        RxpAcquirePrefixTableLockExclusive((pPrefixTable),(Wait),TRUE RX_PREFIXTABLELOCK_ARGS)

#define RxReleasePrefixTableLock(pPrefixTable)  \
        RxpReleasePrefixTableLock((pPrefixTable),TRUE RX_PREFIXTABLELOCK_ARGS)

extern BOOLEAN
RxpAcquirePrefixTableLockShared(
   PRX_PREFIX_TABLE pTable,
   BOOLEAN Wait,
   BOOLEAN ProcessBufferingStateChangeRequests RX_PREFIXTABLELOCK_PARAMS);

extern BOOLEAN
RxpAcquirePrefixTableLockExclusive(
   PRX_PREFIX_TABLE pTable,
   BOOLEAN Wait,
   BOOLEAN ProcessBufferingStateChangeRequests RX_PREFIXTABLELOCK_PARAMS);

extern VOID
RxExclusivePrefixTableLockToShared(PRX_PREFIX_TABLE pTable);

extern VOID
RxpReleasePrefixTableLock(
   PRX_PREFIX_TABLE pTable,
   BOOLEAN ProcessBufferingStateChangeRequests RX_PREFIXTABLELOCK_PARAMS);

#define RxIsPrefixTableLockExclusive(PTABLE) ExIsResourceAcquiredExclusiveLite(&(PTABLE)->TableLock)
#define RxIsPrefixTableLockAcquired(PTABLE) ( ExIsResourceAcquiredSharedLite(&(PTABLE)->TableLock) || \
                                              ExIsResourceAcquiredExclusiveLite(&(PTABLE)->TableLock) )

VOID
RxInitializePrefixTable(
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN     ULONG            TableSize OPTIONAL, //0=>use default
    IN     BOOLEAN          CaseInsensitiveMatch
    );

VOID
RxFinalizePrefixTable(
    IN OUT PRX_PREFIX_TABLE ThisTable
    );

//
// Rx form of a table entry.
typedef struct _RX_PREFIX_ENTRY {

    NODE_TYPE_CODE NodeTypeCode;                 // Normal Header for Refcounted Structure
    NODE_BYTE_SIZE NodeByteSize;

    USHORT CaseInsensitiveLength;                //the initial part of the name that is always case insensitive
    USHORT Spare1;

    //UNICODE_PREFIX_TABLE_ENTRY TableEntry;       // Actual table linkage
    ULONG SavedHashValue;
    LIST_ENTRY HashLinks;

    LIST_ENTRY   MemberQLinks;                   // queue of the set members

    UNICODE_STRING Prefix;                       // Name of the entry

    PULONG         ContainerRefCount;            // Pointer to the reference count of the container
    PVOID          ContainingRecord;             // don't know the parent type...nor do all callers!
                                                 // thus, i need this backptr.
    PVOID          Context;                      // some space that alternate table routines can use

    RX_CONNECTION_ID ConnectionId;               // Used for controlled multiplexing

} RX_PREFIX_ENTRY, *PRX_PREFIX_ENTRY;

//
// Rx form of name table. wraps in a lock and a queue.  Originally, this implementation used the prefix tables
// in Rtl which don't allow an empty string entry. so, we special case this.

#define RX_PREFIX_TABLE_DEFAULT_LENGTH 32

typedef
PVOID
(*PRX_TABLE_LOOKUPNAME) (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  CanonicalName,
    OUT PUNICODE_STRING  RemainingName
    );

typedef
PRX_PREFIX_ENTRY
(*PRX_TABLE_INSERTENTRY) (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY ThisEntry
    );

typedef
VOID
(*PRX_TABLE_REMOVEENTRY) (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY Entry
    );

typedef struct _RX_PREFIX_TABLE {

    NODE_TYPE_CODE NodeTypeCode;         // Normal Header
    NODE_BYTE_SIZE NodeByteSize;

    ULONG Version;                       // version stamp changes on each insertion/removal

    LIST_ENTRY MemberQueue;              // queue of the inserted names

    ERESOURCE TableLock;                 // Resource used to control table access

    PRX_PREFIX_ENTRY TableEntryForNull;  // PrefixEntry for the Null string

    BOOLEAN CaseInsensitiveMatch;
    BOOLEAN IsNetNameTable;              //we may act differently for this....esp for debug!
    ULONG TableSize;
#if DBG
    ULONG Lookups;
    ULONG FailedLookups;
    ULONG Considers;
    ULONG Compares;
#endif
    LIST_ENTRY HashBuckets[RX_PREFIX_TABLE_DEFAULT_LENGTH];

} RX_PREFIX_TABLE, *PRX_PREFIX_TABLE;


#endif   // _RXPREFIX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rxassert.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxAssert.h

Abstract:

    This module declares the prototypes and global data used by the special RDBSS assert facilties.

Author:

    Joe Linn     [JoeLinn]    21-oct-1996

Revision History:


Notes:


--*/

#ifndef _RDBSSASSERT_INCLUDED_
#define _RDBSSASSERT_INCLUDED_

VOID RxDbgBreakPoint(ULONG LineNumber);

//only do this is my routine is the one of interest.......

#ifdef RDBSS_ASSERTS

#if 0
#if !DBG

//here, ntifs will have already defined the asserts away..........
//   so, we just put them back.....this code is duplicated from ntifs.h


#undef ASSERT
#define ASSERT( exp ) \
    if (!(exp)) \
        RxDbgBreakPoint(__LINE__)

#undef ASSERTMSG
#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RxDbgBreakPoint(__LINE__)

#endif //!DBG
#endif

//this will make asserts go to our routine

#define RtlAssert RxAssert
VOID
RxAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    );

#endif //ifdef RDBSS_ASSERTS


#endif // _RDBSSASSERT_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\ntddnfs2.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
This file just builds on the old rdr's dd file.

I am just using the same fsctl code as rdr1....easy to change later.....

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    ntddnfs2.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the redirector file system device.

Author:



Revision History:

    Joe Linn       (JoeLinn) 08-aug-1994  Started changeover to rdr2

--*/

#ifndef _NTDDNFS2_
#define _NTDDNFS2_

#include <ntddnfs.h>

#define FSCTL_LMR_DEBUG_TRACE            _RDR_CONTROL_CODE(219, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_LMMR_STFFTEST              _RDR_CONTROL_CODE(239, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_LMMR_TEST                  _RDR_CONTROL_CODE(238, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define IOCTL_LMMR_TESTLOWIO             _RDR_CONTROL_CODE(237, METHOD_BUFFERED, FILE_ANY_ACCESS)

//this means whatever the minirdr wants
#define IOCTL_LMMR_MINIRDR_DBG           _RDR_CONTROL_CODE(236, METHOD_NEITHER,  FILE_ANY_ACCESS)

#endif  // ifndef _NTDDNFS2_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rxce.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rxce.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the redirector file system connection engine.

Revision History:

    Balan Sethu Raman (SethuR) 06-Feb-95    Created

Notes:

    The Connection engine is designed to map and emulate the TDI specs. as closely
    as possible. This implies that on NT we will have a very efficient mechanism
    which fully exploits the underlying TDI implementation.

    There are four important data structures that are created/manipulated by the
    various functions associated with the connection engine. Thesr are
    RXCE_TRANSPORT,RXCE_ADDRESS,RXCE_CONNECTION and RXCE_VC.

    The mini redirector writers can embed these data structures in the corresponding
    definitions and invoke the two routines provided for each type to build and
    tear down the connection engine portions. These routines do not allocate/free
    the memory associated with these instances. This provides a flexible mechanism
    for the mini redirector writers to manage instances.

--*/

#ifndef _RXCE_H_
#define _RXCE_H_

#include <nodetype.h>
#include <rxcehdlr.h>    // TDI related definitions.
#include <rxworkq.h>
//
// The connection engine deals with three kinds of entities, transports, transport
// addresses and transport connections. The transports are bindings to the various
// transport service providers on any system. The transport addresses are the
// local connection end points. The connections are transport connections between
// endpoints.  Each connection encapsulates a  number of virtual circuits
// ( typically 1 ).
//

// All the four node types are tagged with  the following signature which is used
// extensively in validating them

typedef struct _RXCE_SIGNATURE_ {
    union {
        struct {
            USHORT  Type;
            CSHORT  Size;
        };

        ULONG   Signature;
    };
} RXCE_SIGNATURE, *PRXCE_SIGNATURE;

//
// RXCE_TRANSPORT encapsulates all the parameters w.r.t. a TRANSPORT
// as regards the connection engine.
//

#ifdef __cplusplus
typedef struct _RXCE_TRANSPORT_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_TRANSPORT_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    UNICODE_STRING                Name;

    PDEVICE_OBJECT                pDeviceObject;             // Device object for transport
    HANDLE                        ControlChannel;            // Control Channel
    PFILE_OBJECT                  pControlChannelFileObject; // File object for the control channel

    PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;             // Transport Provider Information.

    LONG                          ConnectionCount;           // Number of connections on xport.
    LONG                          VirtualCircuitCount;       // no. of connections
    ULONG                         QualityOfService;          // quality of service provided.
} RXCE_TRANSPORT;

#define RXCE_TRANSPORT_SIGNATURE ((sizeof(RXCE_TRANSPORT) << 16) | RDBSS_NTC_RXCE_TRANSPORT)

#define RxCeIsTransportValid(pTransport)    \
        ((pTransport)->Signature == RXCE_TRANSPORT_SIGNATURE)

extern NTSTATUS
NTAPI
RxCeBuildTransport(
    IN PRXCE_TRANSPORT pRxCeTransport,
    IN PUNICODE_STRING pTransportName,
    IN ULONG           QualityOfService);

extern NTSTATUS
NTAPI
RxCeTearDownTransport(
    IN PRXCE_TRANSPORT pTransport);

extern NTSTATUS
RxCeQueryAdapterStatus(
    PRXCE_TRANSPORT         pTransport,
    struct _ADAPTER_STATUS *pAdapterStatus);

extern NTSTATUS
RxCeQueryTransportInformation(
    PRXCE_TRANSPORT             pTransport,
    PRXCE_TRANSPORT_INFORMATION pTransportInformation);

//
// RXCE_ADDRESS encapsulates all the parameters w.r.t. a local transport address
// as regards the connection engine.
//

#ifdef __cplusplus
typedef struct _RXCE_ADDRESS_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_ADDRESS_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    PRXCE_TRANSPORT             pTransport;          // the transport handle
    PTRANSPORT_ADDRESS          pTransportAddress;   // the transport address
    PVOID					    pContext;            // the context used in event dispatch
    PRXCE_ADDRESS_EVENT_HANDLER pHandler;            // the address event handler
    PMDL                        pReceiveMdl;         // the MDL for handling Receives Supplied by client
    HANDLE                      hAddress;            // handle to the address object
    PFILE_OBJECT                pFileObject;         // the file object for the address
    LONG                        ConnectionCount;     // no. of connections
    LONG                        VirtualCircuitCount; // no. of vcs
} RXCE_ADDRESS;

#define RXCE_ADDRESS_SIGNATURE ((sizeof(RXCE_ADDRESS) << 16) | RDBSS_NTC_RXCE_ADDRESS)

#define RxCeIsAddressValid(pAddress)    \
        ((pAddress)->Signature == RXCE_ADDRESS_SIGNATURE)

extern NTSTATUS
NTAPI
RxCeBuildAddress(
    IN OUT PRXCE_ADDRESS            pAddress,
    IN  PRXCE_TRANSPORT             pTransport,
    IN  PTRANSPORT_ADDRESS          pTransportAddress,
    IN  PRXCE_ADDRESS_EVENT_HANDLER pHandler,
    IN  PVOID                       pEventContext);

extern NTSTATUS
NTAPI
RxCeTearDownAddress(
    IN PRXCE_ADDRESS pAddress);

//
// RxCe Connection Establishment methods ....
//
//
// RXCE_CONNECTION encapsulates all the information w.r.t. a connection
// as regards the connection engine.
//

#ifdef __cplusplus
typedef struct _RXCE_CONNECTION_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_CONNECTION_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    PRXCE_ADDRESS                   pAddress;            // the local address for this connection
    ULONG                           VirtualCircuitCount; // the number of virtual circuits associated with the connection
    PVOID			                pContext;            // the context used in event dispatch
    PRXCE_CONNECTION_EVENT_HANDLER  pHandler;            // the event handler for the connection
    PRXCE_CONNECTION_INFORMATION    pConnectionInformation; // the remote address ...
} RXCE_CONNECTION;

#define RXCE_CONNECTION_SIGNATURE ((sizeof(RXCE_CONNECTION) << 16) | RDBSS_NTC_RXCE_CONNECTION)

#define RxCeIsConnectionValid(pConnection)    \
        ((pConnection)->Signature == RXCE_CONNECTION_SIGNATURE)

//
// The following enumerated type defines the various choices presented for
// selecting the transport over which a connection should be established
//

typedef enum _RXCE_CONNECTION_CREATE_OPTIONS_ {
    RxCeSelectFirstSuccessfulTransport,
    RxCeSelectBestSuccessfulTransport,
    RxCeSelectAllSuccessfulTransports
} RXCE_CONNECTION_CREATE_OPTIONS,
  *PRXCE_CONNECTION_CREATE_OPTIONS;

typedef struct _RXCE_CONNECTION_COMPLETION_CONTEXT_ {
    NTSTATUS            Status;
    ULONG               AddressIndex;
    PRXCE_CONNECTION    pConnection;
    PRXCE_VC            pVc;
    RX_WORK_QUEUE_ITEM  WorkQueueItem;
    
    // This is used to pass the UNICODE DNS name returned back from TDI
    PRXCE_CONNECTION_INFORMATION pConnectionInformation;
} RXCE_CONNECTION_COMPLETION_CONTEXT,
  *PRXCE_CONNECTION_COMPLETION_CONTEXT;

typedef
NTSTATUS
(*PRXCE_CONNECTION_COMPLETION_ROUTINE)(
    PRXCE_CONNECTION_COMPLETION_CONTEXT pCompletionContext);

extern NTSTATUS
NTAPI
RxCeBuildConnection(
    IN  PRXCE_ADDRESS                           pLocalAddress,
    IN  PRXCE_CONNECTION_INFORMATION            pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER          pHandler,
    IN  PVOID                                   pEventContext,
    IN OUT PRXCE_CONNECTION                     pConnection,
    IN OUT PRXCE_VC                             pVc);

extern NTSTATUS
NTAPI
RxCeBuildConnectionOverMultipleTransports(
    IN OUT PRDBSS_DEVICE_OBJECT         pMiniRedirectorDeviceObject,
    IN  RXCE_CONNECTION_CREATE_OPTIONS  CreateOption,
    IN  ULONG                           NumberOfAddresses,
    IN  PRXCE_ADDRESS                   *pLocalAddressPointers,
    IN  PUNICODE_STRING                 pServerName,
    IN  PRXCE_CONNECTION_INFORMATION    pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER  pHandler,
    IN  PVOID                           pEventContext,
    IN  PRXCE_CONNECTION_COMPLETION_ROUTINE     pCompletionRoutine,
    IN OUT PRXCE_CONNECTION_COMPLETION_CONTEXT  pCompletionContext);

extern NTSTATUS
NTAPI
RxCeTearDownConnection(
    IN PRXCE_CONNECTION pConnection);


extern NTSTATUS
NTAPI
RxCeCancelConnectRequest(
    IN  PRXCE_ADDRESS                pLocalAddress,
    IN  PUNICODE_STRING              pServerName,
    IN  PRXCE_CONNECTION_INFORMATION pConnectionInformation);


//
// RXCE_VC encapsulates all the information w.r.t a virtual circuit (VC)
// connection to a particular server as regards the connection engine.
//
// Typically one VC is associated with a connection. However, there are instances in
// which more than one VC can be associated with a connection. In order to efficiently
// handle the common case well and at the same time provide an extensible mechanism we
// define a collection data structure ( a list ) which subsumes the allocation for
// one virtual circuit. It is also imperative that we restrict the knowledge of
// how this collection is organized to as few methods as possible in order to
// enable optimization/restructuring of this data structure at a later time.
//

#define RXCE_VC_ACTIVE       ((LONG)0xaa)
#define RXCE_VC_DISCONNECTED ((LONG)0xdd)
#define RXCE_VC_TEARDOWN     ((LONG)0xbb)

#ifdef __cplusplus
typedef struct _RXCE_VC_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_VC_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    PRXCE_CONNECTION         pConnection;         // the referenced connection instance
    HANDLE                   hEndpoint;           // local endpoint for the connection
    PFILE_OBJECT             pEndpointFileObject; // the end point file object.
    LONG                     State;               // status of the Vc.
    CONNECTION_CONTEXT       ConnectionId;        // local endpoint for the connection.
    PMDL                     pReceiveMdl;         // the MDl for handling receives.
    PKEVENT                  pCleanUpEvent;       // sychronize event for clean up transports
} RXCE_VC;

#define RXCE_VC_SIGNATURE ((sizeof(RXCE_VC) << 16) | RDBSS_NTC_RXCE_VC)

#define RxCeIsVcValid(pVc)    \
        ((pVc)->Signature == RXCE_VC_SIGNATURE)

extern NTSTATUS
NTAPI
RxCeBuildVC(
    IN OUT PRXCE_VC         pVc,
    IN     PRXCE_CONNECTION Connection);

extern NTSTATUS
NTAPI
RxCeTearDownVC(
    IN PRXCE_VC  pVc);

extern NTSTATUS
NTAPI
RxCeInitiateVCDisconnect(
    IN PRXCE_VC  pVc);

extern NTSTATUS
NTAPI
RxCeQueryInformation(
    IN PRXCE_VC                          pVc,
    IN RXCE_CONNECTION_INFORMATION_CLASS InformationClass,
    OUT PVOID                            pInformation,
    IN ULONG                             Length);

//
// RxCe Data transmission methods
//

//
// Send options
//
// The following flags are equivalent to the TDI flags. In addition
// there are RXCE specific flags which are defined from the other end of
// a dword.
//

#define RXCE_SEND_EXPEDITED            TDI_SEND_EXPEDITED
#define RXCE_SEND_NO_RESPONSE_EXPECTED TDI_SEND_NO_RESPONSE_EXPECTED
#define RXCE_SEND_NON_BLOCKING         TDI_SEND_NON_BLOCKING

//
// The ASYNCHRONOUS and SYNCHRONOUS option available RxCeSend and RxCeSendDatagram
// distinguish between two situations. In the asynchronous case control returns to
// the caller once the request has been successfully submitted to the underlying
// transport. The results for any given request are communicated back using the
// SendCompletion  callback routine. The pCompletionContext parameter in RxCeSend and
// RxCeSendDatagram is passed back in the callback routine to assist the caller in
// disambiguating the requests.
//
// In the synchronous case the request is submitted to the underlying transport and the
// control does not return to the caller till the request completes.
//
// Note that in the synchrnous case the pCompletionContext parameter is ignored and the
// status that is returned correpsonds to the completion status of the operations.
//
// The benefit of ASYNCHRONOUS and SYNCHRONOUS options depends on the underlying
// transport. In a Virtual Circuit environment a SYNCHRONOUS option implies that the
// control does not return till the data reaches the server. On the other hand
// for datagram oriented transports there is very little difference between the two.
//

#define RXCE_FLAGS_MASK (0xff000000)

#define RXCE_SEND_SYNCHRONOUS (0x10000000)

// The following bit signifies if an RX_MEM_DESC(MDL) is to be sent in its entirety
// or only portions of it need to be sent.

#define RXCE_SEND_PARTIAL     (0x20000000)

extern NTSTATUS
NTAPI
RxCeSend(
    IN PRXCE_VC          pVc,
    IN ULONG             SendOptions,
    IN PMDL              pMdl,
    IN ULONG             SendLength,
    IN PVOID             pCompletionContext);

extern NTSTATUS
NTAPI
RxCeSendDatagram(
    IN PRXCE_ADDRESS                hAddress,
    IN PRXCE_CONNECTION_INFORMATION pConnectionInformation,
    IN ULONG                        SendOptions,
    IN PMDL                         pMdl,
    IN ULONG                        SendLength,
    IN PVOID                        pCompletionContext);

extern PIRP 
RxCeAllocateIrpWithMDL(
    IN CCHAR   StackSize,
    IN BOOLEAN ChargeQuota,
    IN PMDL    Buffer);

extern VOID 
RxCeFreeIrp(PIRP pIrp);


#endif  // _RXCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rx.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rx.h

Abstract:

    This module is the overall h-file-wrapper for RDBSS.

Revision History:

    Balan Sethu Raman (SethuR) 06-Feb-95    Created

Notes:


--*/

#ifndef _RX_H_
#define _RX_H_

#include "rxovride.h"   // common compile environment
#include "ntifs.h"      // NT file system driver include file.

#ifdef RX_PRIVATE_BUILD
//no one should be using these
#ifdef IoGetTopLevelIrp
#error  IoGetTopLevelIrp is deffed
#else
#define IoGetTopLevelIrp() IoxxxxxxGetTopLevelIrp()
#endif
#ifdef IoSetTopLevelIrp
#error  IoSetTopLevelIrp is deffed
#else
#define IoSetTopLevelIrp(irp) IoxxxxxxSetTopLevelIrp(irp)
#endif
#endif //ifdef RX_PRIVATE_BUILD


//
//  These macros sugarcoat flag manipulation just a bit
//

#ifndef BooleanFlagOn
#define BooleanFlagOn(Flags,SingleFlag) ((BOOLEAN)((((Flags) & (SingleFlag)) != 0)))
#endif

#ifndef SetFlag
#define SetFlag(Flags,SetOfFlags) { \
    (Flags) |= (SetOfFlags);        \
}
#endif

#ifndef FlagOn
//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))
#endif

#ifndef ClearFlag
#define ClearFlag(Flags,SetOfFlags) { \
    (Flags) &= ~(SetOfFlags);         \
}
#endif

// define INLINE to be the appropriate keyword for ANSI C
#define INLINE __inline

#include "rxtypes.h"

#ifndef MINIRDR__NAME
#include "rxpooltg.h"   // RX pool tag macros
#endif

#include "ntrxdef.h"
#include "rxce.h"       // RxCe functions
#include "rxcehdlr.h"   // RxCe event handler specifications
#include "fcbtable.h"   // FCB table data structures
#include "midatlax.h"   // mid atlas structures
#include "mrxfcb.h"
#include "namcache.h"   // structs and func defs for name cache routines
#include "rxworkq.h"
#include "rxprocs.h"
#include "rxexcept.h"

#ifndef MINIRDR__NAME
#include "rxdata.h"
#include "rxcommon.h"
#include "buffring.h"
#endif

#endif // #ifdef _RX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rdbss.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rdbss.h

Abstract:

    This module defines the RDBSS specific data structures

Author:

    Balan Sethu Raman [SethuR]  16-July-95 -- Created

Revision History:

Notes:

    All the data structures that are exposed to the mini redirector writers need to be
    consolidated in this module.

--*/

#ifndef _RDBSS_H_
#define _RDBSS_H_

//
// In the previous redirector implementation the file system statistics and the network
// protocol statistics were combined into one data structure ( and correctly so ) since
// the old redirector supported only one protocol. However this does not apply to the
// new redirector (RDR2) since there are more than one mini redirectors and the two
// need to be distingushed. The RDBSS_STATISTICS structure provides the file system
// level statistics while the protocol level statistics definition is under the control of
// the mini redirector implementers.
//
// The staistics can be obtained by issuing the FSCTL_RDBSS_GET_STATISTICS. If no mini
// redirector name is provided the RDBSS_STATISTICS are returned and if a mini
// redirctor name is provided the statistics of the appropriate mini redirector are
// returned ( the call is passed through to the appropriate mini redirector ).
//

typedef struct _RDBSS_STATISTICS {
   LARGE_INTEGER   StatisticsStartTime;

   LARGE_INTEGER   PagingReadBytesRequested;
   LARGE_INTEGER   NonPagingReadBytesRequested;
   LARGE_INTEGER   CacheReadBytesRequested;
   LARGE_INTEGER   NetworkReadBytesRequested;

   LARGE_INTEGER   PagingWriteBytesRequested;
   LARGE_INTEGER   NonPagingWriteBytesRequested;
   LARGE_INTEGER   CacheWriteBytesRequested;
   LARGE_INTEGER   NetworkWriteBytesRequested;

   ULONG           InitiallyFailedOperations;
   ULONG           FailedCompletionOperations;

   ULONG           ReadOperations;
   ULONG           RandomReadOperations;
   ULONG           WriteOperations;
   ULONG           RandomWriteOperations;

   ULONG           NumberOfSrvCalls;
   ULONG           NumberOfSrvOpens;
   ULONG           NumberOfNetRoots;
   ULONG           NumberOfVirtualNetRoots;
} RDBSS_STATISTICS, *PRDBSS_STATISTICS;

// This call is provided for the benefit of mini redirector implementers. Each mini
// redirector writer is free to choose the appropriate division of labour between
// the RDBSS and the corresponding mini redirector in maintaining the statistics.

extern NTSTATUS
RdbssGetStatistics(PRDBSS_STATISTICS pRdbssStatistics);

#endif // _RDBSS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rxcehdlr.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rxcehdlr.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the redirector file system connection engine.

Revision History:

    Balan Sethu Raman (SethuR) 06-Feb-95    Created

Notes:

    The Connection engine is designed to map and emulate the TDI specs. as closely
    as possible. This implies that on NT we will have a very efficient mechanism
    which fully exploits the underlying TDI implementation.

    All the necessary types can be redefined in terms of the types defined in
    \nt\private\inc\tdi.h in the case of NT. For Win95 we will provide the
    appropriate definitions.

--*/

#ifndef _RXCEHDLR_H_
#define _RXCEHDLR_H_

#include "tdi.h"

typedef TDI_PROVIDER_INFO RXCE_TRANSPORT_PROVIDER_INFO;
typedef RXCE_TRANSPORT_PROVIDER_INFO* PRXCE_TRANSPORT_PROVIDER_INFO;

typedef TDI_CONNECTION_INFORMATION RXCE_CONNECTION_INFORMATION;
typedef RXCE_CONNECTION_INFORMATION* PRXCE_CONNECTION_INFORMATION;

typedef TDI_CONNECTION_INFORMATION RXCE_CONNECTION_INFORMATION;
typedef RXCE_CONNECTION_INFORMATION* PRXCE_CONNECTION_INFORMATION;

typedef TDI_CONNECTION_INFO RXCE_CONNECTION_INFO;
typedef RXCE_CONNECTION_INFO* PRXCE_CONNECTION_INFO;

#ifdef __cplusplus
typedef struct _RXCE_TRANSPORT_INFORMATION_ : public RXCE_TRANSPORT_PROVIDER_INFO {
#else // !__cplusplus
typedef struct _RXCE_TRANSPORT_INFORMATION_ {
   RXCE_TRANSPORT_PROVIDER_INFO;
#endif // __cplusplus

   ULONG  ConnectionCount;
   ULONG  QualityOfService;
} RXCE_TRANSPORT_INFORMATION, *PRXCE_TRANSPORT_INFORMATION;

typedef enum _RXCE_CONNECTION_INFORMATION_CLASS_ {
    RxCeTransportProviderInformation = 1,
    RxCeConnectionInformation,
    RxCeConnectionEndpointInformation,
    RxCeRemoteAddressInformation
} RXCE_CONNECTION_INFORMATION_CLASS,
  *PRXCE_CONNECTION_INFORMATION_CLASS;

typedef struct _RXCE_VC_         *PRXCE_VC;
typedef struct _RXCE_CONNECTION_ *PRXCE_CONNECTION;
typedef struct _RXCE_ADDRESS_    *PRXCE_ADDRESS;
typedef struct _RXCE_TRANSPORT_  *PRXCE_TRANSPORT;

//
// Disconnection indication prototype. This is invoked when a connection is
// being disconnected for a reason other than the user requesting it.
//

typedef
NTSTATUS
(*PRXCE_IND_DISCONNECT)(
    IN PVOID            pRxCeEventContext,
    IN PRXCE_VC         pVc,
    IN int              DisconnectDataLength,
    IN PVOID            DisconnectData,
    IN int              DisconnectInformationLength,
    IN PVOID            DisconnectInformation,
    IN ULONG            DisconnectFlags
    );

//
// A protocol error has occurred when this indication happens. This indication
// occurs only for errors of the worst type; the address this indication is
// delivered to is no longer usable for protocol-related operations, and
// should not be used for operations henceforth. All connections associated
// it are invalid.
//

typedef
NTSTATUS
(*PRXCE_IND_ENDPOINT_ERROR)(
    IN PVOID    pRxCeEventContext,    // the event context.
    IN NTSTATUS Status                // status code indicating error type.
    );


typedef
NTSTATUS
(*PRXCE_IND_CONNECTION_ERROR)(
    IN PVOID       pRxCeEventContext,    // the event context.
    PRXCE_VC       pVc,                  // the associated VC handle
    IN NTSTATUS    Status                // status code indicating error type.
    );

//
// RXCE_IND_RECEIVE indication handler definition.  This client routine is
// called by the transport provider when a connection-oriented TSDU is received
// that should be presented to the client.
//
// A Receive event handler can return one of three distinguished error codes to
// initiate a different course of action in the connection engine.
//
// STATUS_SUCCESS -- Data was copied directly from the TSDU. The amout of data that
// was taken is indicated in the parameter BytesTaken.
//
// STATUS_MORE_PROCESSING_REQUIRED -- The client has returned a buffer into which the
// data should be copied. This is typically the case when BytesAvailable is greater than
// BytesIndicated. In such cases the RxCe will copy the remaining data into the buffer
// that is specified. Note that when this status code is returned from the client it is
// conceivable that the client can demand more data than is available to be copied into
// the buffer. In such cases the subsequent indications till this criterion is met is not
// passed back to the user till the copy is completed. On completion of this copy the
// RxCe notifies the client by invoking the RxCeDataReadyEventHandler.
//
// STATUS_DATA_NOT_ACCEPTED - The client has refused the data.
//

typedef
NTSTATUS
(*PRXCE_IND_RECEIVE)(
    IN PVOID pRxCeEventContext,       // the context provided during registration
    IN PRXCE_VC    pVc,           // the associated VC handle
    IN ULONG ReceiveFlags,            // the receive flags
    IN ULONG BytesIndicated,          // the number of received bytes indicated
    IN ULONG BytesAvailable,          // the total number of bytes available
    OUT ULONG *BytesTaken,            // return indication of the bytes consumed
    IN PVOID Tsdu,                    // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL *pDataBufferPointer,     // the buffer for copying the bytes not indicated.
    OUT PULONG  pDataBufferSize       // amount of data to copy
    );


//
// RXCE_IND_RECEIVE_DATAGRAM indication handler definition.  This client routine
// is called by the transport provider when a connectionless TSDU is received
// that should be presented to the client.
//
// A Receive event handler can return one of three distinguished error codes to
// initiate a different course of action in the connection engine.
//
// STATUS_SUCCESS -- Data was copied directly from the TSDU. The amout of data that
// was taken is indicated in the parameter BytesTaken.
//
// STATUS_MORE_PROCESSING_REQUIRED -- The client has returned a buffer into which the
// data should be copied. This is typically the case when BytesAvailable is greater than
// BytesIndicated. In such cases the RxCe will copy the remaining data into the buffer
// that is specified. Note that when this status code is returned from the client it is
// conceivable that the client can demand more data than is available to be copied into
// the buffer. In such cases the subsequent indications till this criterion is met is not
// passed back to the user till the copy is completed. On completion of this copy the
// RxCe notifies the client by invoking the RxCeDataReadyEventHandler.
//
// STATUS_DATA_NOT_ACCEPTED - The client has refused the data.
//
//

typedef
NTSTATUS
(*PRXCE_IND_RECEIVE_DATAGRAM)(
    IN PVOID   pRxCeEventContext,      // the event context
    IN int     SourceAddressLength,    // length of the originator of the datagram
    IN PVOID   SourceAddress,          // string describing the originator of the datagram
    IN int     OptionsLength,          // options for the receive
    IN PVOID   Options,                //
    IN ULONG   ReceiveDatagramFlags,   //
    IN ULONG   BytesIndicated,         // number of bytes this indication
    IN ULONG   BytesAvailable,         // number of bytes in complete Tsdu
    OUT ULONG  *BytesTaken,            // number of bytes used
    IN PVOID   Tsdu,                   // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL *pDataBufferPointer,      // the buffer in which data is to be copied.
    OUT PULONG  pDataBufferSize        // amount of data to copy
    );

//
// This indication is delivered if expedited data is received on the connection.
// This will only occur in providers that support expedited data.
//
// A Receive event handler can return one of three distinguished error codes to
// initiate a different course of action in the connection engine.
//
// STATUS_SUCCESS -- Data was copied directly from the TSDU. The amout of data that
// was taken is indicated in the parameter BytesTaken.
//
// STATUS_MORE_PROCESSING_REQUIRED -- The client has returned a buffer into which the
// data should be copied. This is typically the case when BytesAvailable is greater than
// BytesIndicated. In such cases the RxCe will copy the remaining data into the buffer
// that is specified. Note that when this status code is returned from the client it is
// conceivable that the client can demand more data than is available to be copied into
// the buffer. In such cases the subsequent indications till this criterion is met is not
// passed back to the user till the copy is completed. On completion of this copy the
// RxCe notifies the client by invoking the RxCeDataReadyEventHandler.
//
// STATUS_DATA_NOT_ACCEPTED - The client has refused the data.
//

typedef
NTSTATUS
(*PRXCE_IND_RECEIVE_EXPEDITED)(
    IN PVOID pRxCeEventContext,     // the context provided during registration
    IN PRXCE_VC     pVc,        // the associated VC handle
    IN ULONG ReceiveFlags,          //
    IN ULONG BytesIndicated,        // number of bytes in this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used by indication routine
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL *pDataBufferPointer,   // the buffer in which data is to be copied.
    OUT PULONG  pDataBufferSize     // amount of data to copy
    );

//
// This indication is delivered if there is room for a send in the buffer of
// a buffering protocol.
//

typedef
NTSTATUS
(*PRXCE_IND_SEND_POSSIBLE)(
    IN PVOID pRxCeEventContext,
    IN PRXCE_VC pVc,
    IN ULONG BytesAvailable);

//
// RxCeDataReadyEventHandler -- This is invoked when the desired data is available
// for client consumption. This always follows a receive indication in which the
// client returns a buffer for copying the remaining data
//

typedef
NTSTATUS
(*PRXCE_IND_DATA_READY)(
   IN PVOID         pEventContext,
   IN PMDL  pBuffer,
   IN ULONG         CopiedDataSize,
   IN NTSTATUS      CopyDataStatus);


//
// RxCeSendCompleteEventHandler -- This is invoked when the send has been successfully completed
// The buffer and the length sent are passed in as parameters
//

typedef
NTSTATUS
(*PRXCE_IND_SEND_COMPLETE)(
   IN PVOID       pEventContext,
   IN PVOID       pCompletionContext,
   IN NTSTATUS    Status);


typedef
NTSTATUS
(*PRXCE_IND_CONNECTION_SEND_COMPLETE)(
   IN PVOID          pEventContext,
   IN PRXCE_VC       pVc,
   IN PVOID          pCompletionContext,
   IN NTSTATUS       Status);

//
// Event Handler Dispatch Vector definitions ....
//

typedef struct _RXCE_ADDRESS_EVENT_HANDLER_ {
   PRXCE_IND_ENDPOINT_ERROR   RxCeErrorEventHandler;
   PRXCE_IND_RECEIVE_DATAGRAM RxCeReceiveDatagramEventHandler;
   PRXCE_IND_DATA_READY       RxCeDataReadyEventHandler;
   PRXCE_IND_SEND_POSSIBLE    RxCeSendPossibleEventHandler;
   PRXCE_IND_SEND_COMPLETE    RxCeSendCompleteEventHandler;
} RXCE_ADDRESS_EVENT_HANDLER, *PRXCE_ADDRESS_EVENT_HANDLER;

typedef struct _RXCE_CONNECTION_EVENT_HANDLER_ {
   PRXCE_IND_DISCONNECT                   RxCeDisconnectEventHandler;
   PRXCE_IND_CONNECTION_ERROR             RxCeErrorEventHandler;
   PRXCE_IND_RECEIVE                      RxCeReceiveEventHandler;
   PRXCE_IND_RECEIVE_DATAGRAM             RxCeReceiveDatagramEventHandler;
   PRXCE_IND_RECEIVE_EXPEDITED            RxCeReceiveExpeditedEventHandler;
   PRXCE_IND_SEND_POSSIBLE                RxCeSendPossibleEventHandler;
   PRXCE_IND_DATA_READY                   RxCeDataReadyEventHandler;
   PRXCE_IND_CONNECTION_SEND_COMPLETE     RxCeSendCompleteEventHandler;
} RXCE_CONNECTION_EVENT_HANDLER, *PRXCE_CONNECTION_EVENT_HANDLER;

#endif // _RXCEHDLR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rxcommon.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    RxCommon.h

Abstract:

    This module prototypes the upper level common routines.

Author:

    Joe Linn     [JoeLinn]   30-jan-1995

Revision History:

--*/

#ifndef _COMMON_STUFF_DEFINED_
#define _COMMON_STUFF_DEFINED_

NTSTATUS
RxCommonDevFCBCleanup ( RXCOMMON_SIGNATURE );      //  implemented in DevFCB.c

NTSTATUS
RxCommonDevFCBClose ( RXCOMMON_SIGNATURE );        //  implemented in DevFCB.c

NTSTATUS
RxCommonDevFCBIoCtl ( RXCOMMON_SIGNATURE );        //  implemented in DevFCB.c

NTSTATUS
RxCommonDevFCBFsCtl ( RXCOMMON_SIGNATURE );        //  implemented in DevFCB.c


NTSTATUS
RxCommonCleanup ( RXCOMMON_SIGNATURE );            //  implemented in Cleanup.c

NTSTATUS
RxCommonClose ( RXCOMMON_SIGNATURE );              //  implemented in Close.c

NTSTATUS
RxCommonCreate ( RXCOMMON_SIGNATURE );             //  implemented in Create.c

NTSTATUS
RxCommonDirectoryControl ( RXCOMMON_SIGNATURE );   //  implemented in DirCtrl.c

NTSTATUS
RxCommonDeviceControl ( RXCOMMON_SIGNATURE );      //  implemented in DevCtrl.c

NTSTATUS
RxCommonQueryEa ( RXCOMMON_SIGNATURE );            //  implemented in Ea.c

NTSTATUS
RxCommonSetEa ( RXCOMMON_SIGNATURE );              //  implemented in Ea.c

NTSTATUS
RxCommonQueryQuotaInformation ( RXCOMMON_SIGNATURE );            //  implemented in Ea.c

NTSTATUS
RxCommonSetQuotaInformation ( RXCOMMON_SIGNATURE );              //  implemented in Ea.c

NTSTATUS
RxCommonQueryInformation ( RXCOMMON_SIGNATURE );   //  implemented in FileInfo.c

NTSTATUS
RxCommonSetInformation ( RXCOMMON_SIGNATURE );     //  implemented in FileInfo.c

NTSTATUS
RxCommonFlushBuffers ( RXCOMMON_SIGNATURE );       //  implemented in Flush.c

NTSTATUS
RxCommonFileSystemControl ( RXCOMMON_SIGNATURE );  //  implemented in FsCtrl.c

NTSTATUS
RxCommonLockControl ( RXCOMMON_SIGNATURE );        //  implemented in LockCtrl.c

NTSTATUS
RxCommonShutdown ( RXCOMMON_SIGNATURE );           //  implemented in Shutdown.c

NTSTATUS
RxCommonRead ( RXCOMMON_SIGNATURE );               //  implemented in Read.c

NTSTATUS
RxCommonQueryVolumeInfo ( RXCOMMON_SIGNATURE );    //  implemented in VolInfo.c

NTSTATUS
RxCommonSetVolumeInfo ( RXCOMMON_SIGNATURE );      //  implemented in VolInfo.c

NTSTATUS
RxCommonWrite ( RXCOMMON_SIGNATURE );              //  implemented in Write.c

//FsRtl lock package callbacks referenced in fcbstruc.c

NTSTATUS
RxLockOperationCompletion (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
RxUnlockOperation (
    IN PVOID Context,
    IN PFILE_LOCK_INFO LockInfo
    );


// some read routines that need headers
VOID
RxStackOverflowRead (
    IN PVOID Context,
    IN PKEVENT Event
    );

NTSTATUS
RxPostStackOverflowRead (
    IN PRX_CONTEXT RxContext
    );

// the cancel routine
VOID
RxCancelRoutine(
      PDEVICE_OBJECT    pDeviceObject,
      PIRP              pIrp);

#endif // _COMMON_STUFF_DEFINED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rxdata.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxData.h

Abstract:

    This module declares the global data used by the RDBSS file system.

Author:

    Joe Linn     [JoeLinn]    1-aug-1994

Revision History:

--*/

#ifndef _RDBSSDATA_
#define _RDBSSDATA_

//

extern RX_DISPATCHER RxDispatcher;
extern RX_WORK_QUEUE_DISPATCHER RxDispatcherWorkQueues;

//this constants are  the same as the versions in ntexapi.h
//   but drivers are not supposed to import that!

#define  RX_PROCESSOR_ARCHITECTURE_INTEL 0
#define  RX_PROCESSOR_ARCHITECTURE_MIPS  1
#define  RX_PROCESSOR_ARCHITECTURE_ALPHA 2
#define  RX_PROCESSOR_ARCHITECTURE_PPC   3
#define  RX_PROCESSOR_ARCHITECTURE_UNKNOWN 0xffff

// RX_CONTEXT serialization

extern KMUTEX RxSerializationMutex;

#define RxAcquireSerializationMutex()                                       \
        KeWaitForSingleObject(&RxSerializationMutex,Executive,KernelMode,FALSE,NULL)

#define RxReleaseSerializationMutex()                  \
        KeReleaseMutex(&RxSerializationMutex,FALSE)

//
//  The global fsd data record, and  global large integer constants
//

extern ULONG    RxElapsedSecondsSinceStart;
extern NTSTATUS RxStubStatus;

extern PRDBSS_DEVICE_OBJECT RxFileSystemDeviceObject;

extern LARGE_INTEGER RxLargeZero;
extern LARGE_INTEGER RxMaxLarge;
extern LARGE_INTEGER Rx30Milliseconds;
extern LARGE_INTEGER RxOneSecond;
extern LARGE_INTEGER RxOneDay;
extern LARGE_INTEGER RxJanOne1980;
extern LARGE_INTEGER RxDecThirtyOne1979;

//
//  The status actually returned by the FsdDispatchStub.....usually not implemented
//

extern NTSTATUS RxStubStatus;

//
//  The FCB for opens that refer to the device object directly or
//       for file objects that reference nonFcbs (like treecons)
//

extern FCB RxDeviceFCB;


#if 0
//
//  Define maximum number of parallel Reads or Writes that will be generated
//  per one request.
//

#define RDBSS_MAX_IO_RUNS_ON_STACK        ((ULONG) 5)

//
//  Define the maximum number of delayed closes.
//

#define RDBSS_MAX_DELAYED_CLOSES          ((ULONG)16)

extern ULONG RxMaxDelayedCloseCount;

#endif //0

#if DBG

//
//  The following variables are used to keep track of the total amount
//  of requests processed by the file system, and the number of requests
//  that end up being processed by the Fsp thread.  The first variable
//  is incremented whenever an Irp context is created (which is always
//  at the start of an Fsd entry point) and the second is incremented
//  by read request.
//

extern ULONG RxFsdEntryCount;
//extern ULONG RxFspEntryCount;
//extern ULONG RxIoCallDriverCount;
//extern ULONG RxTotalTicks[];
extern ULONG RxIrpCodeCount[];


#endif


// The list of active RxContexts being processed by the RDBSS

extern LIST_ENTRY RxSrvCalldownList;
extern LIST_ENTRY RxActiveContexts;
extern LONG RxNumberOfActiveFcbs;


extern UNICODE_STRING s_PipeShareName;
extern UNICODE_STRING s_MailSlotShareName;
extern UNICODE_STRING s_MailSlotServerPrefix;
extern UNICODE_STRING s_IpcShareName;

extern UNICODE_STRING  s_PrimaryDomainName;


#endif // _RDBSSDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rxcontx.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    RxContx.h

Abstract:

    This module defines RxContext data structure. This structure is used to
    describe an Irp whil it is being processed and contains state information
    that allows global resources to be released as the irp is completed.

Author:

    Joe Linn           [JoeLinn]   19-aug-1994

Revision History:

    Balan Sethu Raman  [SethuR]    11-4-95

Notes:

    The RX_CONTEXT is a data structure to which additional information provided
    by the various mini redirectors need to be attached. This can be done in one
    of the following three ways

      1) Allow for context pointers to be defined as part of the RX_CONTEXT which
      the mini redirectors can use to squirrel away their information. This
      implies that every time an RX_CONTEXT is allocated/destroyed the mini
      redirector has to perform an associated allocation/destruction.

      Since RX_CONTEXT's are created/destroyed in great numbers, this is not an
      acceptable solution.

      2) The second approach consists of over allocating RX_CONTEXT's by a
      prespecified amount for each mini redirector which is then reserved for
      use by the mini redirector. Such an approach avoids the additional
      allocation/destruction but complicates the RX_CONTEXT management code in
      the wrapper.

      3) The third approach ( the one that is implemented ) consists of allocating
      a prespecfied area which is the same for all mini redirectors as part of
      each RX_CONTEXT. This is an unformatted area on top of which any desired
      structure can be imposed by the various mini redirectors. Such an approach
      overcomes the disadvantages associated with (1) and (2).

      All mini redirector writers must try and define the associated mini redirector
      contexts to fit into this area. Those mini redirectors who violate this
      rule will incur a significant performance penalty.

--*/

#ifndef _RX_CONTEXT_STRUCT_DEFINED_
#define _RX_CONTEXT_STRUCT_DEFINED_
#ifndef RDBSS_TRACKER
#error tracker must be defined right now
#endif

#define RX_TOPLEVELIRP_CONTEXT_SIGNATURE ('LTxR')
typedef struct _RX_TOPLEVELIRP_CONTEXT {
    union {
#ifndef __cplusplus
        LIST_ENTRY;
#endif // __cplusplus
        LIST_ENTRY ListEntry;
    };
    ULONG Signature;
    PRDBSS_DEVICE_OBJECT RxDeviceObject;
    PRX_CONTEXT RxContext;
    PIRP Irp;
    ULONG Flags;
    PVOID Previous;
    PETHREAD Thread;
} RX_TOPLEVELIRP_CONTEXT, *PRX_TOPLEVELIRP_CONTEXT;

BOOLEAN
RxTryToBecomeTheTopLevelIrp (
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext,
    IN      PIRP Irp,
    IN      PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN      BOOLEAN ForceTopLevel
    );

VOID
__RxInitializeTopLevelIrpContext (
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext,
    IN      PIRP Irp,
    IN      PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN      ULONG Flags
    );
#define RxInitializeTopLevelIrpContext(a,b,c) {__RxInitializeTopLevelIrpContext(a,b,c,0);}

PIRP
RxGetTopIrpIfRdbssIrp (
    void
    );

PRDBSS_DEVICE_OBJECT
RxGetTopDeviceObjectIfRdbssIrp (
    void
    );

VOID
RxUnwindTopLevelIrp (
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext
    );

BOOLEAN
RxIsThisTheTopLevelIrp (
    IN      PIRP Irp
    );


#ifdef RDBSS_TRACKER
typedef struct _RX_FCBTRACKER_CALLINFO {
    ULONG AcquireRelease;
    USHORT SavedTrackerValue;
    USHORT LineNumber;
    PSZ   FileName;
    ULONG Flags;
} RX_FCBTRACKER_CALLINFO, *PRX_FCBTRACKER_CALLINFO;
#define RDBSS_TRACKER_HISTORY_SIZE 32
#endif

#define MRX_CONTEXT_FIELD_COUNT    4
#define MRX_CONTEXT_SIZE   (sizeof(PVOID) * MRX_CONTEXT_FIELD_COUNT)

// Define rxdriver dispatch routine type....almost all of the important routine
// will have this type.

typedef
NTSTATUS
(NTAPI *PRX_DISPATCH) ( RXCOMMON_SIGNATURE );

typedef struct _NT_CREATE_PARAMETERS {
    ACCESS_MASK                  DesiredAccess;
    LARGE_INTEGER                AllocationSize;
    ULONG                        FileAttributes;
    ULONG                        ShareAccess;
    ULONG                        Disposition;
    ULONG                        CreateOptions;
    PIO_SECURITY_CONTEXT         SecurityContext;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    PVOID                        DfsContext;
    PVOID                        DfsNameContext;
} NT_CREATE_PARAMETERS, *PNT_CREATE_PARAMETERS;

typedef struct _RX_CONTEXT {
    // the node type, size and reference count, aka standard header

    NODE_TYPE_CODE     NodeTypeCode;
    NODE_BYTE_SIZE     NodeByteSize;
    ULONG              ReferenceCount;

    // the list entry to wire the context to the list of active contexts

    LIST_ENTRY         ContextListEntry;

    // Major and minor function of the IRP associated with the context

    UCHAR              MajorFunction;
    UCHAR              MinorFunction;

    // this is similar to the same field in Irps; it
    // allows callback routines for async operations
    // to know whether to do asynchronous work or not

    BOOLEAN            PendingReturned;

    // indicates if the associated request is to be posted to a RDBSS worker thread.

    BOOLEAN            PostRequest;

    // Originating Device (required for workque algorithms)
    // not currently used but could be used for local minis

    PDEVICE_OBJECT     RealDevice;

    //  ptr to the originating Irp
    PIRP               CurrentIrp;

    // ptr to the IRP stack location
    PIO_STACK_LOCATION CurrentIrpSp;

    // ptr to the FCB and FOBX, derived from the context pointers in the
    // file object associated with the IRP

    PMRX_FCB           pFcb;
    PMRX_FOBX          pFobx;
    PMRX_SRV_OPEN      pRelevantSrvOpen;
    PNON_PAGED_FCB     NonPagedFcb;

    //  device object calldown (not irpsp.....)

    PRDBSS_DEVICE_OBJECT RxDeviceObject;

    // The original thread in which the request was initiated and the last
    // thread in which some processing associated with the context was done

    PETHREAD           OriginalThread;
    PETHREAD           LastExecutionThread;

    PVOID              LockManagerContext;

    // One word of the context is given to rdbss for dbg information

    PVOID              RdbssDbgExtension;

    RX_SCAVENGER_ENTRY ScavengerEntry;

    // global serial number for this operation

    ULONG              SerialNumber;

    // used by minirdrs to see if multiple calls are part
    // of the same larger operation and (therefore) more cacheable

    ULONG              FobxSerialNumber;

    ULONG              Flags;

    BOOLEAN            FcbResourceAcquired;
    BOOLEAN            FcbPagingIoResourceAcquired;
    UCHAR              MustSucceedDescriptorNumber;

    // mostly you want the individual components...sometimes it's nice as a pair
    // used to record the status when you can't just return it; e.g., when
    // RXSTATUS is not an appropriate return type or if the consumer of the
    // status didn't call directly (lowiocompletions). minirdrs will not need
    // to set the information directly

    union {
        struct {
            union {
                NTSTATUS StoredStatus;
                PVOID    StoredStatusAlignment;
            };
            ULONG_PTR    InformationToReturn;
        };
        IO_STATUS_BLOCK IoStatusBlock;
    };

    // the context fields provided for use by the mini redirectors
    // this is defined as a union to force longlong alignment

    union {
        ULONGLONG          ForceLonglongAligmentDummyField;
        PVOID              MRxContext[MRX_CONTEXT_FIELD_COUNT];
    };

    // The following field is included to fix the problem related to write only
    // opens. This introduces a new field for the mini redirector to squirrel
    // some state. This is redundant and should be removed after Windows 2000.
    // Having a unique field reduces the impact of the change that we are making
    // to the specific code path. It will be ideal to use one of the MRXContext
    // fields defined above

    PVOID WriteOnlyOpenRetryContext;

    // the cancellation routine to be invoked, set by the mini redirector

    PMRX_CALLDOWN      MRxCancelRoutine;

    // private dispatch, if any. used in fspdisp

    PRX_DISPATCH       ResumeRoutine;

    // for posting to worker threads
    // the minirdr can use this for posting within the minirdr
    // a potential problem can arise if the minirdr relies on this both
    // for queueing async stuff and for queueing cancel stuff

    // The OverflowListEntry is used for queueing items to the overflow queue.
    // This is seperate now to allow us to distinguish between an item in the overflow
    // queue and one in the active work queue (for cancellation logic)

    RX_WORK_QUEUE_ITEM WorkQueueItem;
    LIST_ENTRY OverflowListEntry;

    // this event is used for synchronous operations
    // that have to i/f with an underlying async service. it can be used
    // by the minirdr with the following provisions:
    //      1) on entering the minirdr through lowio, it is set to the
    //         nonsignaled state (but a wise user will reset it before using
    //         it....particularly if it's used multiple times.
    //      2) if you are returning STATUS_PENDING on a sync operation, you must
    //         return with it set to the nonsignaled state; that is, either
    //         you don't use it or you reset it in this case

    KEVENT             SyncEvent;

    //this is a list head of operations that are to be released on completion

    LIST_ENTRY         BlockedOperations;

    //this is the mutex that controls serialization of the blocked operations

    PFAST_MUTEX        BlockedOpsMutex;

    // these links are used to serialize pipe operations on a
    //per-file-object basis AND FOR LOTS OF OTHER STUFF

    LIST_ENTRY         RxContextSerializationQLinks;

    union {
        struct {
            union {
                FS_INFORMATION_CLASS FsInformationClass;
                FILE_INFORMATION_CLASS FileInformationClass;
            };
            PVOID   Buffer;
            union {
                LONG   Length;
                LONG   LengthRemaining;
            };
            BOOLEAN ReplaceIfExists;
            BOOLEAN AdvanceOnly;
        } Info;

        struct {
            UNICODE_STRING       SuppliedPathName;
            NET_ROOT_TYPE        NetRootType;
            PIO_SECURITY_CONTEXT pSecurityContext;
        } PrefixClaim;
    };

    // THIS UNION MUST BE LAST....AT SOME POINT, WE MAY START ALLOCATING
    // SMALLER PER OPERATION!

    union{
        struct {
            NT_CREATE_PARAMETERS NtCreateParameters; // a copy of the createparameters
            ULONG                ReturnedCreateInformation;
            PWCH                 CanonicalNameBuffer;  // if the canonical name is larger than available buffer
            PRX_PREFIX_ENTRY     NetNamePrefixEntry;   // the entry returned by the lookup....for dereferencing

            PMRX_SRV_CALL        pSrvCall;              // Server Call being used
            PMRX_NET_ROOT        pNetRoot;              // Net Root being used
            PMRX_V_NET_ROOT      pVNetRoot;             // Virtual Net Root
            //PMRX_SRV_OPEN        pSrvOpen;              // Server Open

            PVOID                EaBuffer;
            ULONG                EaLength;

            ULONG                SdLength;

            ULONG                PipeType;
            ULONG                PipeReadMode;
            ULONG                PipeCompletionMode;

            USHORT               Flags;
            NET_ROOT_TYPE        Type;                 // Type of Net Root(Pipe/File/Mailslot..)

            BOOLEAN              FcbAcquired;
            BOOLEAN              TryForScavengingOnSharingViolation;
            BOOLEAN              ScavengingAlreadyTried;

            BOOLEAN              ThisIsATreeConnectOpen;
            BOOLEAN              TreeConnectOpenDeferred;
            UNICODE_STRING       TransportName;
            UNICODE_STRING       UserName;
            UNICODE_STRING       Password;
            UNICODE_STRING       UserDomainName;
        } Create;
        struct {
            ULONG   FileIndex;
            BOOLEAN RestartScan;
            BOOLEAN ReturnSingleEntry;
            BOOLEAN IndexSpecified;
            BOOLEAN InitialQuery;
        } QueryDirectory;
        struct {
            PMRX_V_NET_ROOT pVNetRoot;
        } NotifyChangeDirectory;
        struct {
            PUCHAR  UserEaList;
            ULONG   UserEaListLength;
            ULONG   UserEaIndex;
            BOOLEAN RestartScan;
            BOOLEAN ReturnSingleEntry;
            BOOLEAN IndexSpecified;
        } QueryEa;
        struct {
            SECURITY_INFORMATION SecurityInformation;
            ULONG Length;
        } QuerySecurity;
        struct {
            SECURITY_INFORMATION SecurityInformation;
            PSECURITY_DESCRIPTOR SecurityDescriptor;
        } SetSecurity;
        struct {
            ULONG   Length;
            PSID    StartSid;
            PFILE_GET_QUOTA_INFORMATION SidList;
            ULONG   SidListLength;
            BOOLEAN RestartScan;
            BOOLEAN ReturnSingleEntry;
            BOOLEAN IndexSpecified;
        } QueryQuota;
        struct {
            ULONG   Length;

        } SetQuota;
        struct {
            PV_NET_ROOT VNetRoot;
            PSRV_CALL   SrvCall;
            PNET_ROOT   NetRoot;
        } DosVolumeFunction;
        struct {
            ULONG         FlagsForLowIo;
            LOWIO_CONTEXT LowIoContext;        // the LOWIO parameters
        }; //no name here....
        LUID          FsdUid;
    } ;
//CODE.IMPROVEMENT remove this to wrapperdbgprivates
    PWCH                 AlsoCanonicalNameBuffer;  // if the canonical name is larger than available buffer
    PUNICODE_STRING      LoudCompletionString;
#ifdef RDBSS_TRACKER
    LONG               AcquireReleaseFcbTrackerX;
    ULONG              TrackerHistoryPointer;
#endif
#ifdef RDBSS_TRACKER
    RX_FCBTRACKER_CALLINFO TrackerHistory[RDBSS_TRACKER_HISTORY_SIZE];
#endif

    ULONG   dwShadowCritOwner;

} RX_CONTEXT;

#define RX_DEFINE_RXC_FLAG(a,c) RX_DEFINE_FLAG(RX_CONTEXT_FLAG_##a,c,0xffffffff)

typedef enum {
    RX_DEFINE_RXC_FLAG(FROM_POOL, 0)
    RX_DEFINE_RXC_FLAG(WAIT, 1)
    RX_DEFINE_RXC_FLAG(WRITE_THROUGH, 2)
    RX_DEFINE_RXC_FLAG(FLOPPY, 3)
    RX_DEFINE_RXC_FLAG(RECURSIVE_CALL, 4)
    RX_DEFINE_RXC_FLAG(THIS_DEVICE_TOP_LEVEL, 5)
    RX_DEFINE_RXC_FLAG(DEFERRED_WRITE, 6)
    RX_DEFINE_RXC_FLAG(VERIFY_READ, 7)
    RX_DEFINE_RXC_FLAG(STACK_IO_CONTEZT, 8)
    RX_DEFINE_RXC_FLAG(IN_FSP, 9)
    RX_DEFINE_RXC_FLAG(CREATE_MAILSLOT, 10)
    RX_DEFINE_RXC_FLAG(MAILSLOT_REPARSE, 11)
    RX_DEFINE_RXC_FLAG(ASYNC_OPERATION, 12)
    RX_DEFINE_RXC_FLAG(NO_COMPLETE_FROM_FSP, 13)
    RX_DEFINE_RXC_FLAG(POST_ON_STABLE_CONDITION, 14)
    RX_DEFINE_RXC_FLAG(FSP_DELAYED_OVERFLOW_QUEUE, 15)
    RX_DEFINE_RXC_FLAG(FSP_CRITICAL_OVERFLOW_QUEUE, 16)
    RX_DEFINE_RXC_FLAG(MINIRDR_INVOKED, 17)
    RX_DEFINE_RXC_FLAG(WAITING_FOR_RESOURCE, 18)
    RX_DEFINE_RXC_FLAG(CANCELLED, 19)
    RX_DEFINE_RXC_FLAG(SYNC_EVENT_WAITERS, 20)
    RX_DEFINE_RXC_FLAG(NO_PREPOSTING_NEEDED, 21)
    RX_DEFINE_RXC_FLAG(BYPASS_VALIDOP_CHECK, 22)
    RX_DEFINE_RXC_FLAG(BLOCKED_PIPE_RESUME, 23)
    RX_DEFINE_RXC_FLAG(IN_SERIALIZATION_QUEUE, 24)
    RX_DEFINE_RXC_FLAG(NO_EXCEPTION_BREAKPOINT, 25)
    RX_DEFINE_RXC_FLAG(NEEDRECONNECT, 26)
    RX_DEFINE_RXC_FLAG(MUST_SUCCEED, 27)
    RX_DEFINE_RXC_FLAG(MUST_SUCCEED_NONBLOCKING, 28)
    RX_DEFINE_RXC_FLAG(MUST_SUCCEED_ALLOCATED, 29)
    RX_DEFINE_RXC_FLAG(MINIRDR_INITIATED, 31)
} RX_CONTEXT_FLAGS;

#define RX_CONTEXT_PRESERVED_FLAGS (RX_CONTEXT_FLAG_FROM_POOL | \
                                    RX_CONTEXT_FLAG_MUST_SUCCEED_ALLOCATED | \
                                    RX_CONTEXT_FLAG_IN_FSP)

#define RX_CONTEXT_INITIALIZATION_FLAGS (RX_CONTEXT_FLAG_WAIT | \
                                         RX_CONTEXT_FLAG_MUST_SUCCEED | \
                                         RX_CONTEXT_FLAG_MUST_SUCCEED_NONBLOCKING)

#define RX_DEFINE_RXC_CREATE_FLAG(a,c) RX_DEFINE_FLAG(RX_CONTEXT_CREATE_FLAG_##a,c,0xffff)

typedef enum {
    RX_DEFINE_RXC_CREATE_FLAG(UNC_NAME, 0)
    RX_DEFINE_RXC_CREATE_FLAG(STRIPPED_TRAILING_BACKSLASH, 1)
    RX_DEFINE_RXC_CREATE_FLAG(ADDEDBACKSLASH, 2)
    RX_DEFINE_RXC_CREATE_FLAG(REPARSE,3)
    RX_DEFINE_RXC_CREATE_FLAG(SPECIAL_PATH, 4)
} RX_CONTEXT_CREATE_FLAGS;

#define RX_DEFINE_RXC_LOWIO_FLAG(a,c) RX_DEFINE_FLAG(RXCONTEXT_FLAG4LOWIO_##a,c,0xffffffff)

typedef enum {
    RX_DEFINE_RXC_LOWIO_FLAG(PIPE_OPERATION, 0)
    RX_DEFINE_RXC_LOWIO_FLAG(PIPE_SYNC_OPERATION, 1)
    RX_DEFINE_RXC_LOWIO_FLAG(READAHEAD, 2)
    RX_DEFINE_RXC_LOWIO_FLAG(THIS_READ_ENLARGED, 3)
    RX_DEFINE_RXC_LOWIO_FLAG(THIS_IO_BUFFERED, 4)
    RX_DEFINE_RXC_LOWIO_FLAG(LOCK_FCB_RESOURCE_HELD, 5)
    RX_DEFINE_RXC_LOWIO_FLAG(LOCK_WAS_QUEUED_IN_LOCKMANAGER, 6)
#ifdef __cplusplus
} RX_CONTEXT_LOWIO_FLAGS;
#else // !__cplusplus
} RX_CONTEXT_CREATE_FLAGS;
#endif // __cplusplus

// Macros used to control whether the wrapper breakpoints on an exception
#if DBG
#define RxSaveAndSetExceptionNoBreakpointFlag(RXCONTEXT,_yyy){ \
    _yyy = RxContext->Flags & RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT;   \
    RxContext->Flags |= RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT;        \
}
#define RxRestoreExceptionNoBreakpointFlag(RXCONTEXT,_yyy){ \
    RxContext->Flags &= ~RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT;        \
    RxContext->Flags |= _yyy;                              \
}
#else
#define RxSaveAndSetExceptionNoBreakpointFlag(_xxx,_yyy)
#define RxRestoreExceptionNoBreakpointFlag(_xxx,_yyy)
#endif

// a macro used to ensure that a context hasn't been freed during a wait
#if DBG
VOID
__RxItsTheSameContext(
    PRX_CONTEXT RxContext,
    ULONG CapturedRxContextSerialNumber,
    ULONG Line,
    PSZ File
    );
#define RxItsTheSameContext() {__RxItsTheSameContext(RxContext,CapturedRxContextSerialNumber,__LINE__,__FILE__);}
#else
#define RxItsTheSameContext() {NOTHING;}
#endif

extern NPAGED_LOOKASIDE_LIST RxContextLookasideList;

// Macros used in the RDBSS to wrap mini rdr calldowns

#define MINIRDR_CALL_THROUGH(STATUS,DISPATCH,FUNC,ARGLIST)                 \
   {                                                                       \
    ASSERT(DISPATCH);                                                      \
    ASSERT( NodeType(DISPATCH) == RDBSS_NTC_MINIRDR_DISPATCH );            \
    if (DISPATCH->FUNC == NULL) {                                          \
        STATUS = STATUS_NOT_IMPLEMENTED;                                   \
    } else {                                                               \
        RxDbgTrace(0, Dbg, ("MiniRdr Calldown - %s\n",#FUNC));             \
        STATUS = DISPATCH->FUNC ARGLIST;                                   \
    }                                                                      \
   }

#define MINIRDR_CALL(STATUS,CONTEXT,DISPATCH,FUNC,ARGLIST)                 \
   {                                                                       \
    ASSERT(DISPATCH);                                                      \
    ASSERT( NodeType(DISPATCH) == RDBSS_NTC_MINIRDR_DISPATCH );            \
    if ( DISPATCH->FUNC == NULL) {                                         \
       STATUS = STATUS_NOT_IMPLEMENTED;                                    \
    } else {                                                               \
       if (!BooleanFlagOn((CONTEXT)->Flags,RX_CONTEXT_FLAG_CANCELLED)) {   \
          RxDbgTrace(0, Dbg, ("MiniRdr Calldown - %s\n",#FUNC));           \
          RtlZeroMemory(&((CONTEXT)->MRxContext[0]),                       \
                        sizeof((CONTEXT)->MRxContext));                    \
          STATUS = DISPATCH->FUNC ARGLIST;                                 \
       } else {                                                            \
          STATUS = STATUS_CANCELLED;                                       \
       }                                                                   \
    }                                                                      \
   }


//VOID
//RxWaitSync (
//    IN PRX_CONTEXT RxContext
//    )

#define  RxWaitSync(RxContext)                                                   \
         RxDbgTrace(+1, Dbg, ("RxWaitSync, RxContext = %08lx\n", (RxContext)));  \
         (RxContext)->Flags |= RX_CONTEXT_FLAG_SYNC_EVENT_WAITERS;               \
         KeWaitForSingleObject( &(RxContext)->SyncEvent,                         \
                               Executive, KernelMode, FALSE, NULL );             \
         RxDbgTrace(-1, Dbg, ("RxWaitSync -> VOID\n", 0 ))

//VOID
//RxSignalSynchronousWaiter (
//    IN PRX_CONTEXT RxContext
//    )

#define RxSignalSynchronousWaiter(RxContext)                       \
        (RxContext)->Flags &= ~RX_CONTEXT_FLAG_SYNC_EVENT_WAITERS; \
        KeSetEvent( &(RxContext)->SyncEvent, 0, FALSE )


#define RxInsertContextInSerializationQueue(pSerializationQueue,RxContext) \
        (RxContext)->Flags |= RX_CONTEXT_FLAG_IN_SERIALIZATION_QUEUE;      \
        InsertTailList(pSerializationQueue,&((RxContext)->RxContextSerializationQLinks))

INLINE PRX_CONTEXT
RxRemoveFirstContextFromSerializationQueue(PLIST_ENTRY pSerializationQueue)
{
   if (IsListEmpty(pSerializationQueue)) {
      return NULL;
   } else {
      PRX_CONTEXT pContext = (PRX_CONTEXT)(CONTAINING_RECORD(pSerializationQueue->Flink,
                                             RX_CONTEXT,
                                             RxContextSerializationQLinks));

      RemoveEntryList(pSerializationQueue->Flink);

      pContext->RxContextSerializationQLinks.Flink = NULL;
      pContext->RxContextSerializationQLinks.Blink = NULL;
      return pContext;
   }
}

// The following macros provide a mechanism for doing an en masse transfer
// from one list onto another. This provides a powerful paradigm for dealing
// with DPC level processing of lists.

#define RxTransferList(pDestination,pSource)                   \
         if (IsListEmpty((pSource))) {                         \
            InitializeListHead((pDestination));              \
         } else {                                              \
            *(pDestination) = *(pSource);                      \
            (pDestination)->Flink->Blink = (pDestination);     \
            (pDestination)->Blink->Flink = (pDestination);     \
            InitializeListHead((pSource));                   \
         }

#define RxTransferListWithMutex(pDestination,pSource,pMutex) \
    {                                                   \
        ExAcquireFastMutex(pMutex);                     \
        RxTransferList(pDestination,pSource);           \
        ExReleaseFastMutex(pMutex);                     \
    }


VOID RxInitializeRxContexter(void);
VOID RxUninitializeRxContexter(void);

NTSTATUS
RxCancelNotifyChangeDirectoryRequestsForVNetRoot(
   PV_NET_ROOT pVNetRoot,
   BOOLEAN  ForceFilesClosed
   );

VOID
RxCancelNotifyChangeDirectoryRequestsForFobx(
   PFOBX pFobx);

NTSTATUS
NTAPI
RxSetMinirdrCancelRoutine(
    IN OUT PRX_CONTEXT   RxContext,
    IN     PMRX_CALLDOWN MRxCancelRoutine);

VOID
NTAPI
RxInitializeContext(
    IN PIRP            Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG           InitialContextFlags,
    IN OUT PRX_CONTEXT RxContext);

PRX_CONTEXT
NTAPI
RxCreateRxContext (
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG InitialContextFlags
    );

VOID
NTAPI
RxPrepareContextForReuse(
   IN OUT PRX_CONTEXT RxContext);

VOID
NTAPI
RxDereferenceAndDeleteRxContext_Real (
    IN PRX_CONTEXT RxContext
    );

VOID
NTAPI
RxReinitializeContext(
   IN OUT PRX_CONTEXT RxContext);

#if DBG
#define RxDereferenceAndDeleteRxContext(RXCONTEXT) {   \
    RxDereferenceAndDeleteRxContext_Real((RXCONTEXT)); \
    (RXCONTEXT) = NULL;                    \
}
#else
#define RxDereferenceAndDeleteRxContext(RXCONTEXT) {   \
    RxDereferenceAndDeleteRxContext_Real((RXCONTEXT)); \
}
#endif //

extern FAST_MUTEX RxContextPerFileSerializationMutex;

NTSTATUS
NTAPI
__RxSynchronizeBlockingOperationsMaybeDroppingFcbLock(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLIST_ENTRY BlockingIoQ,
    IN     BOOLEAN     DropFcbLock
    );
#define RxSynchronizeBlockingOperationsAndDropFcbLock(__x,__y) \
              __RxSynchronizeBlockingOperationsMaybeDroppingFcbLock(__x,__y,TRUE)
#define RxSynchronizeBlockingOperations(__x,__y) \
              __RxSynchronizeBlockingOperationsMaybeDroppingFcbLock(__x,__y,FALSE)

VOID
NTAPI
RxResumeBlockedOperations_Serially(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLIST_ENTRY BlockingIoQ
    );

VOID
RxResumeBlockedOperations_ALL(
    IN OUT PRX_CONTEXT RxContext
    );


VOID
RxCancelBlockingOperation(
    IN OUT PRX_CONTEXT RxContext);

VOID
RxRemoveOperationFromBlockingQueue(
    IN OUT PRX_CONTEXT RxContext);


#endif // _RX_CONTEXT_STRUCT_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rxovride.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxovride.h

Abstract:

    This file has two purposes. First, things that are absolutely global are included here; a macro
    NO_RXOVRIDE_GLOBAL maybe defined to get only the second behaviour.

    Second, this file is used as a shortterm expedient to ensure that the logging version of the wrapper,
    smbmini and rdr2kd is built irrespective of the build environment. indeed, all of the debugging issues
    can be enabled disabled from here instead of juggling all of the sources files. to override what it says
    in this file...define RX_BUILD_FREE_ANYWAY.

Author:

    Joe Linn (JoeLinn)

Revision History:

Notes:



--*/
#ifndef NO_RXOVRIDE_GLOBAL

// define pointer types for all of the important structures..........
#include <struchdr.h>        // RDBSS related definitions

#endif //ifndef NO_RXOVRIDE_GLOBAL


//control the debugging state of the built components
#define RDBSS_TRACKER 1

#if !DBG
#define RX_ORIGINAL_DBG 0
#else
#define RX_ORIGINAL_DBG 1
#endif

#if 0
#ifndef RDBSSTRACE
#define RDBSSTRACE 1
#endif //ifndef RDBSSTRACE
#endif

#ifndef RX_POOL_WRAPPER
#define RX_POOL_WRAPPER 1
#endif //ifndef RX_POOL_WRAPPER

#ifndef RDBSS_ASSERTS
#define RDBSS_ASSERTS 1
#endif //ifndef RDBSS_ASSERTS

#if DBG

#ifndef RDBSSLOG
#define RDBSSLOG 1
#endif //ifndef RDBSSLOG

#else // DBG

#if PRERELEASE
#ifndef RDBSSLOG
#define RDBSSLOG 1
#endif //ifndef RDBSSLOG
#endif  // if PRERELEASE

#endif  // if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rxexcept.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Except.h

Abstract:

    This module prototypes the macros and routines used for exception handling.

Author:

    Joe Linn     [JoeLinn]   24-aug-1994

Revision History:

--*/

#ifndef _EXCEPTION_STUFF_DEFINED_
#define _EXCEPTION_STUFF_DEFINED_


//
//  The following two macro are used by the Fsd/Fsp exception handlers to
//  process an exception.  The first macro is the exception filter used in the
//  Fsd/Fsp to decide if an exception should be handled at this level.
//  The second macro decides if the exception is to be finished off by
//  completing the IRP, and cleaning up the Irp Context, or if we should
//  bugcheck.  Exception values such as RxStatus(FILE_INVALID) (raised by
//  VerfySup.c) cause us to complete the Irp and cleanup, while exceptions
//  such as accvio cause us to bugcheck.
//
//  The basic structure for fsd/fsp exception handling is as follows:
//
//  RxFsdXxx(...)
//  {
//      try {
//
//          ...
//
//      } except(RxExceptionFilter( RxContext, GetExceptionCode() )) {
//
//          Status = RxProcessException( RxContext, GetExceptionCode() );
//      }
//
//      Return Status;
//  }
//
//  To explicitly raise an exception that we expect, such as
//  RxStatus(FILE_INVALID), use the below macro RxRaiseStatus().  To raise a
//  status from an unknown origin (such as CcFlushCache()), use the macro
//  RxNormalizeAndRaiseStatus.  This will raise the status if it is expected,
//  or raise RxStatus(UNEXPECTED_IO_ERROR) if it is not.
//
//  Note that when using these two macros, the original status is placed in
//  RxContext->ExceptionStatus, signaling RxExceptionFilter and
//  RxProcessException that the status we actually raise is by definition
//  expected.
//

LONG
RxExceptionFilter (
    IN PRX_CONTEXT RxContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

NTSTATUS
RxProcessException (
    IN PRX_CONTEXT RxContext,
    IN NTSTATUS ExceptionCode
    );

#define CATCH_EXPECTED_EXCEPTIONS   (FsRtlIsNtstatusExpected(GetExceptionCode()) ?   \
                      EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )


//
//  VOID
//  RxRaiseStatus (
//      IN PRIP_CONTEXT RxContext,
//      IN NT_STATUS Status
//  );
//
//

#define RxRaiseStatus(RXCONTEXT,STATUS) {   \
    ASSERT((RXCONTEXT)!=NULL);              \
    if (RxContext!=NULL) {(RXCONTEXT)->StoredStatus = (STATUS);   }          \
    ExRaiseStatus( (STATUS) );              \
}

//
//  VOID
//  RxNormalAndRaiseStatus (
//      IN PRIP_CONTEXT RxContext,
//      IN NT_STATUS Status
//  );
//

#define RxNormalizeAndRaiseStatus(RXCONTEXT,STATUS) {                         \
    ASSERT((RXCONTEXT)!=NULL);              \
    if (RxContext!=NULL) {(RXCONTEXT)->StoredStatus = (STATUS);   }          \
    if ((STATUS) == (STATUS_VERIFY_REQUIRED)) { ExRaiseStatus((STATUS)); }        \
    ExRaiseStatus(FsRtlNormalizeNtstatus((STATUS),(STATUS_UNEXPECTED_IO_ERROR))); \
}


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }



#endif // _EXCEPTION_STUFF_DEFINED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rxdebug.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxdebug.h

Abstract:

    This module contains the definition of auxilary data structures used in
    debugging. Each of the data structures is conditionalized by its own
    #ifdef tag.

Author:

    Balan Sethu Raman --

--*/

#ifndef _RXDEBUG_H_
#define _RXDEBUG_H_

extern VOID
RxInitializeDebugSupport();

extern VOID
RxTearDownDebugSupport();


#ifdef RX_WJ_DBG_SUPPORT

#define MAX_JOURNAL_BITMAP_SIZE (8 * 1024)


typedef struct _FCB_WRITE_JOURNAL_ {
    LIST_ENTRY      JournalsList;

    PFCB            pFcb;
    PWCHAR pName;

    LONG  WritesInitiated;
    LONG  LowIoWritesInitiated;
    LONG  LowIoWritesCompleted;

    PBYTE pWriteInitiationBitmap;
    PBYTE pLowIoWriteInitiationBitmap;
    PBYTE pLowIoWriteCompletionBitmap;

    BYTE WriteInitiationBitmap[MAX_JOURNAL_BITMAP_SIZE];
    BYTE LowIoWriteInitiationBitmap[MAX_JOURNAL_BITMAP_SIZE];
    BYTE LowIoWriteCompletionBitmap[MAX_JOURNAL_BITMAP_SIZE];

    WCHAR           Path[MAX_PATH] ;

} FCB_WRITE_JOURNAL, *PFCB_WRITE_JOURNAL;

// forward declarations

VOID
RxdInitializeWriteJournalSupport();

VOID
RxdTearDownWriteJournalSupport();

VOID
RxdInitializeFcbWriteJournalDebugSupport(
    PFCB    pFcb);

VOID
RxdTearDownFcbWriteJournalDebugSupport(
    PFCB    pFcb);

VOID
RxdUpdateJournalOnWriteInitiation(
    IN OUT PFCB          pFcb,
    IN     LARGE_INTEGER Offset,
    IN     ULONG         Length);

VOID
RxdUpdateJournalOnLowIoWriteInitiation(
    IN  OUT PFCB            pFcb,
    IN      LARGE_INTEGER   Offset,
    IN      ULONG           Length);

VOID
RxdUpdateJournalOnLowIoWriteCompletion(
    IN  OUT PFCB            pFcb,
    IN      LARGE_INTEGER   Offset,
    IN      ULONG           Length);


#endif // RX_WJ_DBG_SUPPORT

#endif // _RXDEBUG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rxlog.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxLog.h

Abstract:

    This module declares the prototypes and global data used by the RDBSS debug logging facilities.

Author:

    Joe Linn     [JoeLinn]    1-aug-1994

Revision History:

    Balan Sethu Raman [SethuR] 23-April-95 revised log layout

Notes:

    The log records are stored in a circular buffer. Each record is bounded on either side by
    a record descriptor. This record descriptor is four bytes long.

--*/

#ifndef _RDBSSLOG_INCLUDED_
#define _RDBSSLOG_INCLUDED_


typedef enum {
   RX_LOG_UNINITIALIZED,
   RX_LOG_ENABLED,
   RX_LOG_DISABLED,
   RX_LOG_ERROR
} RX_LOGGING_STATE;

typedef struct RX_LOG_ENTRY_HEADER {
    PCHAR Buffer;
} RX_LOG_ENTRY_HEADER, *PRX_LOG_ENTRY_HEADER;


typedef struct RX_LOG {
   RX_SPIN_LOCK         SpinLock;
   RX_LOGGING_STATE     State;
   PRX_LOG_ENTRY_HEADER CurrentEntry;
   PRX_LOG_ENTRY_HEADER BaseEntry;
   PRX_LOG_ENTRY_HEADER EntryLimit;
   ULONG                LogBufferSizeInEntries;
   ULONG                NumberOfEntriesIgnored;
   ULONG                NumberOfLogWriteAttempts;
   ULONG                NumberOfLogWraps;
} RX_LOG, *PRX_LOG;


//the logging facilities are always present. what RDBSSLOG does is to enable generation
//of the calls! on checked builds, you even get the calls unless NO_RDBSSLOG is set.

//extern
//VOID
//RxLogInterlockedAddUlong(
//    PULONG Result,
//    PULONG Counter,
//    ULONG Addend);

extern
VOID
RxDebugControlCommand (
    IN char *ControlString
    );

extern
NTSTATUS
RxInitializeLog(void);

extern
VOID
RxUninitializeLog(void);

extern
VOID
_RxPrintLog(IN ULONG EntriesToPrint OPTIONAL);

extern
VOID
_RxPauseLog(void);

extern
VOID
_RxResumeLog (void);

extern
VOID
_RxLog(char *format, ...);


#define MAX_RX_LOG_ENTRY_SIZE  (48)

#define RDBSSLOG_ASYNC_NAME_PREFIX "[nowait]"
#define RXCONTX_OPERATION_NAME(MajorFunction,Wait) \
    (RxContxOperationNames[(MajorFunction)]+((Wait)?(sizeof(RDBSSLOG_ASYNC_NAME_PREFIX)-1):0))
extern PUCHAR RxContxOperationNames[];

#ifdef RDBSSLOG

                             //
// The arguments to RxLog must be enclosed with an additional pair of parenthesis to enable
// transalation into a null call when logging should be turned off.
// e.g. RxLog(("%s %d", FILE, LINE))
#if DBG
#define RxLog(Args)   _RxLog##Args
#define RxLogRetail(Args)   _RxLog##Args
#else
#define RxLogRetail(Args)   _RxLog##Args
#define RxLog(Args) {NOTHING;}
#endif

#define RxPauseLog()  _RxPauseLog()
#define RxResumeLog() _RxResumeLog()

#else //if notdef  RDBSSLOG

#define RxLog(Args)   {NOTHING;}
#define RxLogRetail(Args) {NOTHING;}
#define RxPauseLog()  {NOTHING;}
#define RxResumeLog() {NOTHING;}

#endif

#endif // _RDBSSLOG_INCLUDED_

#if DBG
#define RxDbgPrint(Args) DbgPrint##Args
#else
#define RxDbgPrint(Args) NOTHING
#endif

LIST_ENTRY RxIrpsList;
KSPIN_LOCK RxIrpsListSpinLock;

typedef struct _RX_IRP_LIST_ITEM {
    LIST_ENTRY  IrpsList;
    PIRP        pIrp;
    PMDL        CopyDataBuffer;
    ULONG       Completed;
} RX_IRP_LIST_ITEM, *PRX_IRP_LIST_ITEM;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rxpooltg.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxpooltg.h

Abstract:

    The global pool tag definitions for RDBSS

Author:

    Balan Sethu Raman (SethuR) - Created  2-March-95

Revision History:

   This file contains all the pool tag definitions related to the SMB mini redirector.
   The mechanism is intended to balance the number of pool tags to be used with the
   total number of tags available in the system.

   By specifying special flags the total number of tags consumed by the mini redirector
   can be controlled.

--*/

#ifndef _RXPOOLTG_H_
#define _RXPOOLTG_H_


#define RX_SRVCALL_POOLTAG      ('cSxR')
#define RX_NETROOT_POOLTAG      ('rNxR')
#define RX_V_NETROOT_POOLTAG    ('nVxR')
#define RX_FCB_POOLTAG          ('cFxR')
#define RX_SRVOPEN_POOLTAG      ('oSxR')
#define RX_FOBX_POOLTAG         ('xFxR')
#define RX_NONPAGEDFCB_POOLTAG  ('fNxR')
#define RX_WORKQ_POOLTAG        ('qWxR')
#define RX_BUFFERING_MANAGER_POOLTAG ('mBxR')
#define RX_MISC_POOLTAG         ('sMxR')
#define RX_IRPC_POOLTAG         ('rIxR')
#define RX_MRX_POOLTAG          ('xMxR')
#define RX_NAME_CACHE_POOLTAG   ('cNxR')

#define RXCE_TRANSPORT_POOLTAG  ('tCxR')
#define RXCE_ADDRESS_POOLTAG    ('aCxR')
#define RXCE_CONNECTION_POOLTAG ('cCxR')
#define RXCE_VC_POOLTAG         ('vCxR')
#define RXCE_TDI_POOLTAG        ('dCxR')

extern ULONG RxExplodePoolTags;

#define RX_DEFINE_POOLTAG(ExplodedPoolTag,DefaultPoolTag)  \
        ((RxExplodePoolTags == 0) ? (DefaultPoolTag) : (ExplodedPoolTag))

#define RX_SRVCALL_PARAMS_POOLTAG   RX_DEFINE_POOLTAG('pSxR',RX_SRVCALL_POOLTAG)
#define RX_V_NETROOT_PARAMS_POOLTAG RX_DEFINE_POOLTAG('pVxR',RX_V_NETROOT_POOLTAG)
#define RX_TIMER_POOLTAG          RX_DEFINE_POOLTAG('mTxR',RX_MISC_POOLTAG)
#define RX_DIRCTL_POOLTAG         RX_DEFINE_POOLTAG('cDxR',RX_MISC_POOLTAG)

#define RXCE_MISC_POOLTAG         RX_DEFINE_POOLTAG('xCxR',RX_MISC_POOLTAG)
#define RXCE_MIDATLAS_POOLTAG     RX_DEFINE_POOLTAG('aMxR',RX_MISC_POOLTAG)

#endif _RXPOOLTG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rxprocs.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxProcs.h

Abstract:

    This module defines all of the globally used procedures in the RDBSS
    file system.

Author:

    Joe Linn     [JoeLinn]

Revision History:

--*/

#ifndef _RDBSSPROCS_
#define _RDBSSPROCS_

#include "rx.h"
#include "backpack.h"
#include "RxTypes.h"
#include "RxAssert.h"
#include "RxLog.h"
#include "RxTrace.h"
#include "RxTimer.h"
#include "RxStruc.h"

extern PVOID RxNull;

//
//  The following macro is for all people who compile with the DBG switch
//  set, not just rdbss dbg users
//

#if DBG

#define DbgDoit(X)         {X;}
#define DebugDoit(X)       {X;}
#define DEBUG_ONLY_DECL(X) X

#else

#define DbgDoit(X)        {NOTHING;}
#define DebugDoit(X)      {NOTHING;}
#define DEBUG_ONLY_DECL(X)

#endif // DBG


//
// utilities


//
// Routines for writing error log entries.
//

/*++

    RxLogFailure, RxLogFailureWithBuffer can be used to record an event in
    the log. The RxLogFailure, RxLogFailureWithBuffer captures the line
    number alongwith the supplied information and writes it to the log. This
    is useful in debugging. RxLogFailureDirect, RxLogBufferDirect do not
    capture the line number

    RxlogEvent is useful for writing events into the log.

--*/
#define RxLogFailure( _DeviceObject, _OriginatorId, _EventId, _Status ) \
            RxLogEventDirect( _DeviceObject, _OriginatorId, _EventId, _Status, __LINE__ )

#define RxLogFailureWithBuffer( _DeviceObject, _OriginatorId, _EventId, _Status, _Buffer, _Length ) \
            RxLogEventWithBufferDirect( _DeviceObject, _OriginatorId, _EventId, _Status, _Buffer, _Length, __LINE__ )

#define RxLogEvent( _DeviceObject, _OriginatorId, _EventId, _Status) \
            RxLogEventDirect(_DeviceObject, _OriginatorId, _EventId, _Status, __LINE__)

VOID
RxLogEventDirect (
    IN PRDBSS_DEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING      OriginatorId,
    IN ULONG                EventId,
    IN NTSTATUS             Status,
    IN ULONG                Line);

VOID
RxLogEventWithBufferDirect(
    IN PVOID            DeviceOrDriverObject,
    IN PUNICODE_STRING  OriginatorId,
    IN ULONG            EventId,
    IN NTSTATUS         Status,
    IN PVOID            DataBuffer,
    IN USHORT           DataBufferLength,
    IN ULONG            LineNumber);

VOID
RxLogEventWithAnnotation (
    IN PRDBSS_DEVICE_OBJECT DeviceObject,
    IN ULONG                EventId,
    IN NTSTATUS             Status,
    IN PVOID                DataBuffer,
    IN USHORT               DataBufferLength,
    IN PUNICODE_STRING      Annotation,
    IN ULONG                AnnotationCount);

BOOLEAN
RxCcLogError(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING FileName,
    IN NTSTATUS Error,
    IN NTSTATUS DeviceError,
    IN UCHAR IrpMajorCode,
    IN PVOID Context
    );



//in create.c
NTSTATUS
RxPrefixClaim (
    IN PRX_CONTEXT RxContext
    );

VOID
RxpPrepareCreateContextForReuse(
    PRX_CONTEXT RxContext);

//in devfcb.c
LUID
RxGetUid (
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext
    );

ULONG
RxGetSessionId (
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RxFindOrCreateConnections (
    IN  PRX_CONTEXT            RxContext,
    IN  PUNICODE_STRING        CanonicalName,
    IN  NET_ROOT_TYPE          NetRootType,
    OUT PUNICODE_STRING        LocalNetRootName,
    OUT PUNICODE_STRING        FilePathName,
    IN OUT LOCK_HOLDING_STATE  *pLockHoldingState,
    IN  PRX_CONNECTION_ID      RxConnectionId
    );

NTSTATUS
RxFindOrCreateVNetRoot(
    PRX_CONTEXT        RxContext,
    PUNICODE_STRING    CanonicalName,
    NET_ROOT_TYPE      NetRootType,
    PV_NET_ROOT        *pVirtualNetRootPointer,
    LOCK_HOLDING_STATE *pLockHoldingState);

//in fileinfo.c
typedef enum _RX_NAME_CONJURING_METHODS {
    VNetRoot_As_Prefix,
    VNetRoot_As_UNC_Name,
    VNetRoot_As_DriveLetter
} RX_NAME_CONJURING_METHODS;

VOID
RxConjureOriginalName (
    IN PFCB   Fcb,
    IN PFOBX  Fobx,
    OUT PLONG pActualNameLength,
    PWCHAR OriginalName,
    IN OUT PLONG pLengthRemaining,
    IN RX_NAME_CONJURING_METHODS NameConjuringMethod
    );

//in cleanup.c
VOID
RxAdjustFileTimesAndSize ( RXCOMMON_SIGNATURE );

//
//  A function that returns finished denotes if it was able to complete the
//  operation (TRUE) or could not complete the operation (FALSE) because the
//  wait value stored in the irp context was false and we would have had
//  to block for a resource or I/O
//

typedef BOOLEAN FINISHED;

//
//   Buffer control routines for data caching, implemented in CacheSup.c
//

FINISHED
RxZeroData (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject,
    IN ULONG StartingZero,
    IN ULONG ByteCount
    );

NTSTATUS
RxCompleteMdl (
    IN PRX_CONTEXT RxContext
    );


VOID
RxSyncUninitializeCacheMap (
    IN PRX_CONTEXT RxContext,
    IN PFILE_OBJECT FileObject
    );

VOID
RxLockUserBuffer (
    IN PRX_CONTEXT RxContext,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    );

PVOID
RxMapSystemBuffer (
    IN PRX_CONTEXT RxContext
    );

PVOID
RxNewMapUserBuffer (
    IN PRX_CONTEXT RxContext
    );

#define RxUpcaseEaName( RXCONTEXT, NAME, UPCASEDNAME ) \
    RtlUpperString( UPCASEDNAME, NAME )


//#define RxDissectName(RXCONTEXT,INPUT_STRING,FIRST_PART,REMAINING_PART) { \
//    FsRtlDissectDbcs( (INPUT_STRING),                                       \
//                      (FIRST_PART),                                         \
//                      (REMAINING_PART) );                                   \
//}
//
//
//#define RxDoesNameContainWildCards(RXCONTEXT,NAME) ( \
//    FsRtlDoesDbcsContainWildCards( &(NAME) )           \
//)
//
//
//#define RxAreNamesEqual(RXCONTEXT,NAMEA,NAMEB) (                         \
//    ((ULONG)(NAMEA).Length == (ULONG)(NAMEB).Length) &&                    \
//    (RtlCompareMemory( &(NAMEA).Buffer[0],                                 \
//                       &(NAMEB).Buffer[0],                                 \
//                       (NAMEA).Length ) == (NAMEA).Length )                \
//)
//
//
//#define RxIsNameValid(RXCONTEXT,NAME,CAN_CONTAIN_WILD_CARDS,PATH_NAME_OK,LEADING_BACKSLAH_OK) ( \
//    FsRtlIsFatDbcsLegal((NAME),                   \
//                        (CAN_CONTAIN_WILD_CARDS), \
//                        (PATH_NAME_OK),           \
//                        (LEADING_BACKSLAH_OK))    \
//)


//even though it passes a serial number, this parameter is not used
#ifdef RDBSS_TRACKER
#define RX_FCBTRACKER_PARAMS ,ULONG LineNumber,PSZ FileName,ULONG SerialNumber
#else
#define RX_FCBTRACKER_PARAMS
#endif

#define FCB_MODE_EXCLUSIVE (1)
#define FCB_MODE_SHARED    (2)
#define FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE (3)
#define FCB_MODE_SHARED_STARVE_EXCLUSIVE (4)

#define CHANGE_BUFFERING_STATE_CONTEXT      ((PRX_CONTEXT)IntToPtr(0xffffffff))
#define CHANGE_BUFFERING_STATE_CONTEXT_WAIT ((PRX_CONTEXT)IntToPtr(0xfffffffe))

NTSTATUS
__RxAcquireFcb(
     IN OUT PMRX_FCB     pFcb,
     IN OUT PRX_CONTEXT  pRxContext,
     IN     ULONG        Mode
     RX_FCBTRACKER_PARAMS
     );

#ifdef  RDBSS_TRACKER
#define RxAcquireExclusiveFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_EXCLUSIVE,__LINE__,__FILE__,0)
#else
#define RxAcquireExclusiveFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_EXCLUSIVE)
#endif

#define RX_GET_MRX_FCB(FCB) ((PMRX_FCB)((FCB)))

#ifdef  RDBSS_TRACKER
#define RxAcquireSharedFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_SHARED,__LINE__,__FILE__,0)
#else
#define RxAcquireSharedFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_SHARED)
#endif

#ifdef  RDBSS_TRACKER
#define RxAcquireSharedFcbWaitForEx(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE,__LINE__,__FILE__,0)
#else
#define RxAcquireSharedFcbWaitForEx(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE)
#endif

#ifdef  RDBSS_TRACKER
#define RxAcquireSharedFcbStarveEx(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_SHARED_STARVE_EXCLUSIVE,__LINE__,__FILE__,0)
#else
#define RxAcquireSharedFcbStarveEx(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_SHARED_STARVE_EXCLUSIVE)
#endif


VOID
__RxReleaseFcb(
    IN PRX_CONTEXT pRxContext,
    IN PMRX_FCB    pFcb
    RX_FCBTRACKER_PARAMS
    );

#ifdef  RDBSS_TRACKER
#define RxReleaseFcb(RXCONTEXT,FCB) \
        __RxReleaseFcb((RXCONTEXT),RX_GET_MRX_FCB(FCB),__LINE__,__FILE__,0)
#else
#define RxReleaseFcb(RXCONTEXT,FCB) \
        __RxReleaseFcb((RXCONTEXT),RX_GET_MRX_FCB(FCB))
#endif

VOID
__RxReleaseFcbForThread(
    IN PRX_CONTEXT      pRxContext,
    IN PMRX_FCB         pFcb,
    IN ERESOURCE_THREAD ResourceThreadId
    RX_FCBTRACKER_PARAMS
    );

#ifdef  RDBSS_TRACKER
#define RxReleaseFcbForThread(RXCONTEXT,FCB,THREAD) \
        __RxReleaseFcbForThread((RXCONTEXT),RX_GET_MRX_FCB(FCB),(THREAD),__LINE__,__FILE__,0)
#else
#define RxReleaseFcbForThread(RXCONTEXT,FCB,THREAD) \
        __RxReleaseFcbForThread((RXCONTEXT),RX_GET_MRX_FCB(FCB),(THREAD))
#endif

#ifdef RDBSS_TRACKER
VOID RxTrackerUpdateHistory(
    PRX_CONTEXT pRxContext,
    PMRX_FCB pFcb,
    ULONG Operation
    RX_FCBTRACKER_PARAMS
    );
#else
#define RxTrackerUpdateHistory(xRXCONTEXT,xFCB,xOPERATION,xLINENUM,xFILENAME,xSERIALNUMBER) {NOTHING;}
#endif

VOID RxTrackPagingIoResource(
    PVOID       pInstance,
    ULONG       Type,
    ULONG       Line,
    PCHAR       File);

//this definition is old......i don't like the format
#define RxFcbAcquiredShared(RXCONTEXT,FCB) (                      \
    ExIsResourceAcquiredSharedLite(RX_GET_MRX_FCB(FCB)->Header.Resource) \
)

#define RxIsFcbAcquiredShared(FCB) (                      \
    ExIsResourceAcquiredSharedLite(RX_GET_MRX_FCB(FCB)->Header.Resource) \
)

#define RxIsFcbAcquiredExclusive(FCB) (                      \
    ExIsResourceAcquiredExclusiveLite(RX_GET_MRX_FCB(FCB)->Header.Resource) \
)

#define RxIsFcbAcquired(FCB) (                      \
    ExIsResourceAcquiredSharedLite(RX_GET_MRX_FCB(FCB)->Header.Resource) | \
    ExIsResourceAcquiredExclusiveLite(RX_GET_MRX_FCB(FCB)->Header.Resource) \
)

#define RxAcquirePagingIoResource(FCB,RxContext)                       \
    ExAcquireResourceExclusiveLite(RX_GET_MRX_FCB(FCB)->Header.PagingIoResource,TRUE);  \
    if (RxContext) { \
        ((PRX_CONTEXT)RxContext)->FcbPagingIoResourceAcquired = TRUE;   \
    } \
    RxTrackPagingIoResource(FCB,1,__LINE__,__FILE__) \

#define RxAcquirePagingIoResourceShared(FCB,FLAG,RxContext) \
    ExAcquireResourceSharedLite(RX_GET_MRX_FCB(FCB)->Header.PagingIoResource,FLAG); \
    if (AcquiredFile) {                                          \
        if (RxContext) {                                     \
            ((PRX_CONTEXT)RxContext)->FcbPagingIoResourceAcquired = TRUE;   \
        }                                                    \
        RxTrackPagingIoResource(FCB,2,__LINE__,__FILE__);    \
    }

#define RxReleasePagingIoResource(FCB,RxContext)                       \
    RxTrackPagingIoResource(FCB,3,__LINE__,__FILE__); \
    if (RxContext) { \
        ((PRX_CONTEXT)RxContext)->FcbPagingIoResourceAcquired = FALSE;   \
    } \
    ExReleaseResourceLite(RX_GET_MRX_FCB(FCB)->Header.PagingIoResource)

#define RxReleasePagingIoResourceForThread(FCB,THREAD,RxContext)    \
    RxTrackPagingIoResource(FCB,3,__LINE__,__FILE__); \
    if (RxContext) { \
        ((PRX_CONTEXT)RxContext)->FcbPagingIoResourceAcquired = FALSE;   \
    } \
    ExReleaseResourceForThreadLite(RX_GET_MRX_FCB(FCB)->Header.PagingIoResource,(THREAD))


//  The following are cache manager call backs

BOOLEAN
RxAcquireFcbForLazyWrite (
    IN PVOID Null,
    IN BOOLEAN Wait
    );

VOID
RxReleaseFcbFromLazyWrite (
    IN PVOID Null
    );

BOOLEAN
RxAcquireFcbForReadAhead (
    IN PVOID Null,
    IN BOOLEAN Wait
    );

VOID
RxReleaseFcbFromReadAhead (
    IN PVOID Null
    );

BOOLEAN
RxNoOpAcquire (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    );

VOID
RxNoOpRelease (
    IN PVOID Fcb
    );

NTSTATUS
RxAcquireForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
RxReleaseForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    );

//
//  VOID
//  RxConvertToSharedFcb (
//      IN PRX_CONTEXT RxContext,
//      IN PFCB Fcb
//      );
//

#define RxConvertToSharedFcb(RXCONTEXT,FCB) {                        \
    ExConvertExclusiveToSharedLite( RX_GET_MRX_FCB(FCB)->Header.Resource ); \
    }

VOID
RxVerifyOperationIsLegal (
    IN PRX_CONTEXT RxContext
    );

//
//  Work queue routines for posting and retrieving an Irp, implemented in
//  workque.c
//

VOID
RxOplockComplete (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
RxPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
RxAddToWorkque (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

NTSTATUS
RxFsdPostRequest (
    IN PRX_CONTEXT RxContext
    );

#define RxFsdPostRequestWithResume(RXCONTEXT,RESUMEROUTINE) \
        (((RXCONTEXT)->ResumeRoutine=(RESUMEROUTINE)),   \
         RxFsdPostRequest((RXCONTEXT)) \
        )

VOID
RxInitializeMRxCalldownContext(
    PMRX_CALLDOWN_CONTEXT pContext,
    PRDBSS_DEVICE_OBJECT  pMRxDeviceObject,
    PMRX_CALLDOWN_ROUTINE pRoutine,
    PVOID                 pParameter);

NTSTATUS
RxCalldownMiniRedirectors(
    LONG                  NumberOfMiniRdrs,
    PMRX_CALLDOWN_CONTEXT pCalldownContext,
    BOOLEAN               PostCalldowns);

//
//  This macro takes a ulong and returns its rounded up word value
//

#define WordAlign(Val) (                    \
    ALIGN_UP( Val, WORD )                   \
    )

//
//  This macro takes a pointer and returns a ULONG_PTR representation of
//  its rounded up word value
//

#define WordAlignPtr(Ptr) (                 \
    ALIGN_UP_POINTER( Ptr, WORD )           \
    )

//
//  This macro takes a ulong and returns its rounded up longword value
//

#define LongAlign(Val) (                    \
    ALIGN_UP( Val, LONG )                   \
    )

//
//  This macro takes a pointer and returns a ULONG_PTR representation of
//  its rounded up word value
//

#define LongAlignPtr(Ptr) (                 \
    ALIGN_UP_POINTER( Ptr, LONG )           \
    )

//
//  This macro takes a ulong and returns its rounded up quadword
//  value
//

#define QuadAlign(Val) (                    \
    ALIGN_UP( Val, ULONGLONG )              \
    )

//
//  This macro takes a pointer and returns a ULONG_PTR representation of
//  its rounded up quadword value
//

#define QuadAlignPtr(Ptr) (                 \
    ALIGN_UP_POINTER( Ptr, ULONGLONG )      \
    )

//
//  This macro takes a pointer and returns whether it's quadword-aligned
//

#define IsPtrQuadAligned(Ptr) (           \
    QuadAlignPtr(Ptr) == (PVOID)(Ptr)     \
    )

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }

#define CopyU4char(Dst,Src) {                                \
    *((UNALIGNED UCHAR4 *)(Dst)) = *((UCHAR4 *)(Src)); \
    }

//
//
// the wrapper doesn't yet implement notify and oplock. rather than remove the code
// we define the calls in such a way as to Noop the effects so that we'll have a head
// start on putting it back later...


/* this is a macro definition we'll reenable when we implement oplocks and notifies
//
//  VOID
//  RxNotifyReportChange (
//      IN PRX_CONTEXT RxContext,
//      IN PVCB Vcb,
//      IN PFCB Fcb,
//      IN ULONG Filter,
//      IN ULONG Action
//      );
//

#define RxNotifyReportChange(I,V,F,FL,A) {                             \
    if ((F)->FullFileName.Buffer == NULL) {                             \
        RxSetFullFileNameInFcb((I),(F));                               \
    }                                                                   \
    FsRtlNotifyFullReportChange( (V)->NotifySync,                       \
                                 &(V)->DirNotifyList,                   \
                                 (PSTRING)&(F)->FullFileName,           \
                                 (USHORT) ((F)->FullFileName.Length -   \
                                           (F)->FinalNameLength),       \
                                 (PSTRING)NULL,                         \
                                 (PSTRING)NULL,                         \
                                 (ULONG)FL,                             \
                                 (ULONG)A,                              \
                                 (PVOID)NULL );                         \
}
*/
#define RxNotifyReportChange(I,V,F,FL,A) \
    RxDbgTrace(0, Dbg, ("RxNotifyReportChange PRETENDING Fcb %08lx %wZ Filter/Action = %08lx/%08lx\n", \
                 (F),&((F)->FcbTableEntry.Path),(FL),(A)))

#if 0
#define FsRtlNotifyFullChangeDirectory(A1,A2,A3,A4,A5,A6,A7,A8,A9,A10) \
    RxDbgTrace(0, Dbg, ("FsRtlNotifyFullReportChange PRETENDING ............\n",0))
#endif

#define FsRtlCheckOplock(A1,A2,A3,A4,A5)  \
        (STATUS_SUCCESS)

#define FsRtlOplockIsFastIoPossible(__a) (TRUE)
//
//  The following procedure is used by the FSP and FSD routines to complete
//  an IRP.
//
//  Note that this macro allows either the Irp or the RxContext to be
//  null, however the only legal order to do this in is:
//
//      RxCompleteRequest_OLD( NULL, Irp, Status );  // completes Irp & preserves context
//      ...
//      RxCompleteRequest_OLD( RxContext, NULL, DontCare ); // deallocates context
//
//  This would typically be done in order to pass a "naked" RxContext off to
//  the Fsp for post processing, such as read ahead.
//
//  The new way is to pass just the RxContext..........

VOID
RxCompleteRequest_Real (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN NTSTATUS Status
    );

#if DBG
#define RxCompleteRequest_OLD(RXCONTEXT,IRP,STATUS) { \
    RxCompleteRequest_Real(RXCONTEXT,IRP,STATUS); \
    (IRP) = NULL;                                   \
    (RXCONTEXT) = NULL;                            \
}
#else
#define RxCompleteRequest_OLD(RXCONTEXT,IRP,STATUS) { \
    RxCompleteRequest_Real(RXCONTEXT,IRP,STATUS); \
}
#endif

NTSTATUS
RxCompleteRequest(
      PRX_CONTEXT pContext,
      NTSTATUS    Status);

#define RxCompleteAsynchronousRequest(RXCONTEXT,STATUS)  \
        RxCompleteRequest(RXCONTEXT,STATUS)

#define RxCompleteContextAndReturn(STATUS) {       \
             NTSTATUS __sss = (STATUS);             \
             RxCompleteRequest(RxContext,__sss); \
             return(__sss);}
#define RxCompleteContext(STATUS) {       \
             NTSTATUS __sss = (STATUS);             \
             RxCompleteRequest(RxContext,__sss);} \

//
//  The Following routine makes a popup
//

VOID
RxPopUpFileCorrupt (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    );

NTSTATUS
RxConstructSrvCall(
    PRX_CONTEXT       pRxContext,
    PSRV_CALL          pSrvCall,
    LOCK_HOLDING_STATE *pLockHoldingState);

NTSTATUS
RxSetSrvCallDomainName(
    PMRX_SRV_CALL    pSrvCall,
    PUNICODE_STRING  pDomainName);

NTSTATUS
RxConstructNetRoot(
    PRX_CONTEXT                 pRxContext,
    PSRV_CALL                   pSrvCall,
    PNET_ROOT                   pNetRoot,
    PV_NET_ROOT                 pVirtualNetRoot,
    LOCK_HOLDING_STATE          *pLockHoldingState);

NTSTATUS
RxConstructVirtualNetRoot(
    PRX_CONTEXT        RxContext,
    PUNICODE_STRING    CanonicalName,
    NET_ROOT_TYPE      NetRootType,
    PV_NET_ROOT        *pVirtualNetRootPointer,
    LOCK_HOLDING_STATE *pLockHoldingState,
    PRX_CONNECTION_ID  RxConnectionId);

NTSTATUS
RxFindOrConstructVirtualNetRoot(
    PRX_CONTEXT        RxContext,
    PUNICODE_STRING    CanonicalName,
    NET_ROOT_TYPE      NetRootType,
    PUNICODE_STRING    RemainingName);

NTSTATUS
RxLowIoFsCtlShell (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxLowIoFsCtlShellCompletion (
    IN PRX_CONTEXT RxContext
    );


NTSTATUS
RxLowIoLockControlShell (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxChangeBufferingState(
    PSRV_OPEN              SrvOpen,
    PVOID                  Context,
    BOOLEAN                ComputeNewState
    );

VOID
RxAssociateSrvOpenKey(
    PMRX_SRV_OPEN pMRxSrvOpen,
    PVOID         SrvOpenKey);

VOID
RxIndicateChangeOfBufferingState(
    PMRX_SRV_CALL pSrvCall,
    PVOID         SrvOpenKey,
    PVOID         pContext);

VOID
RxIndicateChangeOfBufferingStateForSrvOpen(
    PMRX_SRV_CALL pSrvCall,
    PMRX_SRV_OPEN pSrvOpen,
    PVOID         SrvOpenKey,
    PVOID         pContext);


NTSTATUS
RxPrepareToReparseSymbolicLink(
    PRX_CONTEXT     RxContext,
    BOOLEAN         SymbolicLinkEmbeddedInOldPath,
    PUNICODE_STRING pNewPath,
    BOOLEAN         NewPathIsAbsolute,
    BOOLEAN         *pReparseRequired);

BOOLEAN
RxLockEnumerator (
    IN OUT struct _MRX_SRV_OPEN_ * SrvOpen,
    IN OUT PVOID *ContinuationHandle,
       OUT PLARGE_INTEGER FileOffset,
       OUT PLARGE_INTEGER LockRange,
       OUT PBOOLEAN IsLockExclusive
    );

//
// Routines for transitioning data structures to stable states.
//

VOID
RxReference(
    IN OUT PVOID pInstance);

VOID
RxDereference(
    IN OUT PVOID              pInstance,
    IN     LOCK_HOLDING_STATE LockHoldingState);

VOID
RxWaitForStableCondition(
    IN     PRX_BLOCK_CONDITION pCondition,
    IN OUT PLIST_ENTRY         pTransitionWaitList,
    IN OUT PRX_CONTEXT         RxContext,
    OUT    NTSTATUS            *AsyncStatus OPTIONAL);

VOID
RxUpdateCondition(
    IN     RX_BLOCK_CONDITION NewConditionValue,
       OUT RX_BLOCK_CONDITION *pCondition,
    IN OUT PLIST_ENTRY        pTransitionWaitList);

VOID
RxFinalizeNetTable(
    PRDBSS_DEVICE_OBJECT RxDeviceObject,
    BOOLEAN fForceFinalization);

#define RxForceNetTableFinalization(RxDeviceObject) \
            RxFinalizeNetTable(RxDeviceObject,TRUE)

NTSTATUS
RxCloseAssociatedSrvOpen(
    PFOBX       pFobx,
    PRX_CONTEXT RxContext);

NTSTATUS
RxFinalizeConnection(
    IN OUT PNET_ROOT NetRoot,
    IN OUT PV_NET_ROOT VNetRoot OPTIONAL,
    IN BOOLEAN ForceFilesClosed
    );


// routines for manipulating the user's view and the server's view of SHARE_ACCESS.
// the user's view is supported by routines exported by Io...the wrappers just allow
// us to get a msg. the server's view is supported by routines that are essential just
// copies of the Io routines EXCEPT that the Io routines work directly on fileobjects and
// as such cannot be used directly. the routines mentioned are implemented in create.c

#if DBG
VOID
RxDumpWantedAccess(
    PSZ where1,
    PSZ where2,
    PSZ wherelogtag,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess
   );

VOID
RxDumpCurrentAccess(
    PSZ where1,
    PSZ where2,
    PSZ wherelogtag,
    PSHARE_ACCESS ShareAccess
    );
#else
#define RxDumpWantedAccess(w1,w2,wlt,DA,DSA) {NOTHING;}
#define RxDumpCurrentAccess(w1,w2,wlt,SA)  {NOTHING;}
#endif

NTSTATUS
RxCheckShareAccessPerSrvOpens(
    IN PFCB Fcb,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess
    );


VOID
RxUpdateShareAccessPerSrvOpens(
    IN PSRV_OPEN SrvOpen
    );

VOID
RxRemoveShareAccessPerSrvOpens(
    IN OUT PSRV_OPEN SrvOpen
    );

VOID
RxRemoveShareAccessPerSrvOpens(
    IN OUT PSRV_OPEN SrvOpen
    );


#if DBG
NTSTATUS
RxCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update,
    IN PSZ where,
    IN PSZ wherelogtag
    );

VOID
RxRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    );

VOID
RxSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    );

VOID
RxUpdateShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    );
#else
#define RxCheckShareAccess(a1,a2,a3,a4,a5,a6,a7) \
    IoCheckShareAccess(a1,a2,a3,a4,a5)

#define RxRemoveShareAccess(a1,a2,a3,a4) \
    IoRemoveShareAccess(a1,a2)

#define RxSetShareAccess(a1,a2,a3,a4,a5,a6) \
    IoSetShareAccess(a1,a2,a3,a4)

#define RxUpdateShareAccess(a1,a2,a3,a4) \
    IoUpdateShareAccess(a1,a2)
#endif

//LoadUnload

NTSTATUS
RxDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
RxUnload(
    IN PDRIVER_OBJECT DriverObject
    );

//minirdr support

VOID
RxInitializeMinirdrDispatchTable(
    IN PDRIVER_OBJECT DriverObject
    );

ULONG
RxGetNetworkProviderPriority(
    PUNICODE_STRING DeviceName
    );

VOID
RxExtractServerName(
    IN PUNICODE_STRING FilePathName,
    OUT PUNICODE_STRING SrvCallName,
    OUT PUNICODE_STRING RestOfName
    );

VOID
RxCreateNetRootCallBack (
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    );

NTSTATUS
DuplicateTransportAddress(
    PTRANSPORT_ADDRESS *pCopy,
    PTRANSPORT_ADDRESS pOriginal,
    POOL_TYPE          PoolType);

NTSTATUS
RxCepInitializeVC(
    PRXCE_VC         pVc,
    PRXCE_CONNECTION pConnection);

NTSTATUS
DuplicateConnectionInformation(
    PRXCE_CONNECTION_INFORMATION *pCopy,
    PRXCE_CONNECTION_INFORMATION pOriginal,
    POOL_TYPE                    PoolType);

NTSTATUS
RxCepInitializeConnection(
    IN OUT PRXCE_CONNECTION             pConnection,
    IN     PRXCE_ADDRESS                pAddress,
    IN     PRXCE_CONNECTION_INFORMATION pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER  pHandler,
    IN  PVOID                           pEventContext);

NTSTATUS
RxCeInitiateConnectRequest(
    struct _RX_CALLOUT_PARAMETERS_BLOCK_ *pParameterBlock);

VOID
RxCeCleanupConnectCallOutContext(
    struct _RX_CREATE_CONNECTION_CALLOUT_CONTEXT_ *pCreateConnectionContext);

PVOID
RxAllocateObject(
    NODE_TYPE_CODE    NodeType,
    PMINIRDR_DISPATCH pMRxDispatch,
    ULONG             NameLength);

VOID
RxFreeObject(PVOID pObject);

NTSTATUS
RxInitializeSrvCallParameters(
    PRX_CONTEXT RxContext,
    PSRV_CALL   SrvCall);

VOID
RxAddVirtualNetRootToNetRoot(
    PNET_ROOT   pNetRoot,
    PV_NET_ROOT pVNetRoot);

VOID
RxRemoveVirtualNetRootFromNetRoot(
    PNET_ROOT   pNetRoot,
    PV_NET_ROOT pVNetRoot);

VOID
RxOrphanFcbsFromThisVNetRoot (
    IN PV_NET_ROOT ThisVNetRoot
    );

PVOID
RxAllocateFcbObject(
    PRDBSS_DEVICE_OBJECT RxDeviceObject,
    NODE_TYPE_CODE    NodeType,
    POOL_TYPE         PoolType,
    ULONG             NameSize,
    PVOID             pAlreadyAllocatedObject);

VOID
RxFreeFcbObject(PVOID pObject);

VOID
RxPurgeFcb(
    IN  PFCB pFcb);

BOOLEAN
RxFinalizeNetFcb (
    OUT PFCB ThisFcb,
    IN  BOOLEAN   RecursiveFinalize,
    IN  BOOLEAN   ForceFinalize,
    IN  LONG      ReferenceCount
    );

VOID
RxCheckFcbStructuresForAlignment(void);

VOID
RxpPrepareCreateContextForReuse(
    PRX_CONTEXT RxContext);

NTSTATUS
RxLowIoSubmitRETRY (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxLowIoCompletionTail (
    IN PRX_CONTEXT RxContext
    );

VOID
RxRecurrentTimerWorkItemDispatcher (
    IN PVOID Context
    );

NTSTATUS
RxInitializeWorkQueueDispatcher(
   PRX_WORK_QUEUE_DISPATCHER pDispatcher);

VOID
RxInitializeWorkQueue(
   PRX_WORK_QUEUE  pWorkQueue,
   WORK_QUEUE_TYPE WorkQueueType,
   ULONG           MaximumNumberOfWorkerThreads,
   ULONG           MinimumNumberOfWorkerThreads);

VOID
RxTearDownWorkQueueDispatcher(
   PRX_WORK_QUEUE_DISPATCHER pDispatcher);

VOID
RxTearDownWorkQueue(
   PRX_WORK_QUEUE pWorkQueue);

NTSTATUS
RxSpinUpWorkerThread(
   PRX_WORK_QUEUE           pWorkQueue,
   PRX_WORKERTHREAD_ROUTINE Routine,
   PVOID                    Parameter);

VOID
RxSpinUpWorkerThreads(
   PRX_WORK_QUEUE pWorkQueue);

VOID
RxSpinUpRequestsDispatcher(
    PRX_DISPATCHER pDispatcher);

VOID
RxpSpinUpWorkerThreads(
    PRX_WORK_QUEUE pWorkQueue);

VOID
RxpWorkerThreadDispatcher(
   IN PRX_WORK_QUEUE pWorkQueue,
   IN PLARGE_INTEGER pWaitInterval);

VOID
RxBootstrapWorkerThreadDispatcher(
   IN PRX_WORK_QUEUE pWorkQueue);

VOID
RxWorkerThreadDispatcher(
   IN PRX_WORK_QUEUE pWorkQueue);

VOID
RxWorkItemDispatcher(
   PVOID    pContext);

BOOLEAN
RxIsPrefixTableEmpty(
    IN PRX_PREFIX_TABLE   ThisTable);

PRX_PREFIX_ENTRY
RxTableLookupName_ExactLengthMatch (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  Name,
    IN  ULONG            HashValue,
    IN  PRX_CONNECTION_ID OPTIONAL RxConnectionId
    );

PVOID
RxTableLookupName (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  Name,
    OUT PUNICODE_STRING  RemainingName,
    IN  PRX_CONNECTION_ID OPTIONAL RxConnectionId
    );

VOID
RxAcquireFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    );

VOID
RxReleaseFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
RxPrepareRequestForHandling(
    PCHANGE_BUFFERING_STATE_REQUEST pRequest);

VOID
RxPrepareRequestForReuse(
    PCHANGE_BUFFERING_STATE_REQUEST pRequest);

VOID
RxpDiscardChangeBufferingStateRequests(
    IN OUT PLIST_ENTRY pDiscardedRequests);

VOID
RxGatherRequestsForSrvOpen(
    IN OUT PSRV_CALL     pSrvCall,
    IN     PSRV_OPEN     pSrvOpen,
    IN OUT PLIST_ENTRY   pRequestsListHead);

NTSTATUS
RxpLookupSrvOpenForRequestLite(
    IN     PSRV_CALL                       pSrvCall,
    IN OUT PCHANGE_BUFFERING_STATE_REQUEST pRequest);

BOOLEAN
RxContextCheckToFailThisAttempt(
    IN PIRP Irp,
    IN OUT ULONG* InitialContextFlags
    );

ULONG
RxAssignMustSucceedContext(
    IN PIRP Irp,
    IN ULONG InitialContextFlags
    );

PRX_CONTEXT
RxAllocateMustSucceedContext(
    PIRP                    Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG                InitialContextFlags,
    OUT PUCHAR              MustSucceedDescriptorNumber
    );

VOID
RxFreeMustSucceedContext(
    PRX_CONTEXT RxContext
    );

PRX_LOG_ENTRY_HEADER
RxGetNextLogEntry(void);

VOID
RxPrintLog (
    IN ULONG EntriesToPrint OPTIONAL
    );

VOID
RxProcessChangeBufferingStateRequestsForSrvOpen(
      PSRV_OPEN pSrvOpen);

NTSTATUS
RxPurgeFobxFromCache(
    PFOBX   pFobxToBePurged);

BOOLEAN
RxPurgeFobx(
   PFOBX pFobx);

VOID
RxPurgeAllFobxs(
    PRDBSS_DEVICE_OBJECT RxDeviceObject);

VOID
RxUndoScavengerFinalizationMarking(
    PVOID pInstance);

VOID
RxScavengeAllFobxs(
    PRDBSS_DEVICE_OBJECT RxDeviceObject);

ULONG
RxTableComputePathHashValue (
    IN  PUNICODE_STRING  Name
    );

VOID
RxExtractServerName(
    IN PUNICODE_STRING FilePathName,
    OUT PUNICODE_STRING SrvCallName,
    OUT PUNICODE_STRING RestOfName
    );

VOID
RxCreateNetRootCallBack (
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    );

VOID
RxSpinDownOutstandingAsynchronousRequests(
    PRDBSS_DEVICE_OBJECT RxDeviceObject);

NTSTATUS
RxRegisterAsynchronousRequest(
    PRDBSS_DEVICE_OBJECT RxDeviceObject);

VOID
RxDeregisterAsynchronousRequest(
    PRDBSS_DEVICE_OBJECT RxDeviceObject);


BOOLEAN
RxCancelOperationInOverflowQueue(
    PRX_CONTEXT RxContext);

VOID
RxOrphanSrvOpens(
    IN  PV_NET_ROOT ThisVNetRoot
    );


VOID
RxOrphanThisFcb(
    PFCB    pFcb
    );

VOID
RxOrphanSrvOpensForThisFcb(
    PFCB            pFcb,
    IN PV_NET_ROOT  ThisVNetRoot,
    BOOLEAN         fOrphanAll
    );

VOID
RxForceFinalizeAllVNetRoots(
    PNET_ROOT   pNetRoot
    );

#define RxEqualConnectionId( P1, P2 ) RtlEqualMemory( P1, P2, sizeof(RX_CONNECTION_ID) )

#endif // _RDBSSPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rxtrace.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxtrace.h

Abstract:

    This module defines the macros which provide debugging support ( tracing ).

Author:

    Joe Linn     [JoeLinn]    1-aug-1994

Revision History:

--*/

#ifndef _RDBSSTRACE_INCLUDED_
#define _RDBSSTRACE_INCLUDED_

#if !DBG
#undef RDBSSTRACE
#endif // !DBG

typedef struct _DEBUG_TRACE_CONTROLPOINT{
    ULONG ControlPointNumber;
    PSZ Name;
} DEBUG_TRACE_CONTROLPOINT, *PDEBUG_TRACE_CONTROLPOINT;

typedef struct {
    LONG PrintLevel;
    ULONG BreakMask;
    PSZ   Name;
} RX_DEBUG_TRACE_CONTROL, *PRX_DEBUG_TRACE_CONTROL;


#ifdef RDBSSTRACE

//define so that &RX_DEBUG_TRACE_CONTROL is NULL
typedef struct {
    RX_DEBUG_TRACE_CONTROL Junk;
} rxrxrx_AlwaysHelper;


#define RX_DEBUG_TRACE_ALWAYS  (((rxrxrx_AlwaysHelper*)0)->Junk)

// The following macros provide fine grained control for selectively enabling
// and disabling tracing.

#define RXDT_Extern(__x) extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x
#define RXDT_DeclareCategory(__x) extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x
#define RXDT_DefineCategory(__x)  DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x = {0,#__x}

RXDT_Extern(ERROR);
RXDT_Extern(HOOKS);
RXDT_Extern(CATCH_EXCEPTIONS);
RXDT_Extern(UNWIND);
RXDT_Extern(CLEANUP);
RXDT_Extern(CLOSE);
RXDT_Extern(CREATE);
RXDT_Extern(DIRCTRL);
RXDT_Extern(EA);
RXDT_Extern(FILEINFO);
RXDT_Extern(FSCTRL);
RXDT_Extern(LOCKCTRL);
RXDT_Extern(READ);
RXDT_Extern(VOLINFO);
RXDT_Extern(WRITE);
RXDT_Extern(FLUSH);
RXDT_Extern(DEVCTRL);
RXDT_Extern(SHUTDOWN);
RXDT_Extern(PREFIX);
RXDT_Extern(DEVFCB);
RXDT_Extern(ACCHKSUP);
RXDT_Extern(ALLOCSUP);
RXDT_Extern(DIRSUP);
RXDT_Extern(FILOBSUP);
RXDT_Extern(NAMESUP);
RXDT_Extern(VERFYSUP);
RXDT_Extern(CACHESUP);
RXDT_Extern(SPLAYSUP);
RXDT_Extern(DEVIOSUP);
RXDT_Extern(FCBSTRUCTS);
RXDT_Extern(STRUCSUP);
RXDT_Extern(FSP_DISPATCHER);
RXDT_Extern(FSP_DUMP);
RXDT_Extern(RXCONTX);
RXDT_Extern(DISPATCH);
RXDT_Extern(NTFASTIO);
RXDT_Extern(LOWIO);
RXDT_Extern(MINIRDR);
RXDT_Extern(DISCCODE);  //for the browser interface stuff
RXDT_Extern(BROWSER);
RXDT_Extern(CONNECT);
RXDT_Extern(NTTIMER);
RXDT_Extern(SCAVTHRD);
RXDT_Extern(SCAVENGER);
RXDT_Extern(SHAREACCESS);
RXDT_Extern(NAMECACHE);

//connection engines categories

RXDT_Extern(RXCEBINDING);
RXDT_Extern(RXCEDBIMPLEMENTATION);
RXDT_Extern(RXCEMANAGEMENT);
RXDT_Extern(RXCEXMIT);
RXDT_Extern(RXCEPOOL);
RXDT_Extern(RXCETDI);

#else //RDBSSTRACE

#define RXDT_Extern(__x)
#define RXDT_DeclareCategory(__x)
#define RXDT_DefineCategory(__x)

#endif //RDBSSTRACE

#ifdef RDBSSTRACE
extern BOOLEAN RxGlobalTraceSuppress, RxNextGlobalTraceSuppress;
extern ULONG RxGlobalTraceIrpCount;
VOID RxInitializeDebugTrace(void);
#define RxDbgTraceDoit(___x) ___x

#ifndef MINIRDR__NAME
extern LONG RxDebugTraceIndent;
#else
#define RxDebugTraceIndent (*(*___MINIRDR_IMPORTS_NAME).pRxDebugTraceIndent)
#endif

#else

#define RxInitializeDebugTrace()
#define RxDbgTraceDoit(___x)

#endif //RDBSSTRACE



#if DBG

#define RxDT_INDENT_EXCESS 16 //this is the offset for excess-n for the indent
#define RxDT_INDENT_SHIFT 20
#define RxDT_INDENT_MASK  0x3f
#define RxDT_LEVEL_MASK ((1<<RxDT_INDENT_SHIFT)-1)
#define RxDT_SUPPRESS_PRINT  0x80000000
#define RxDT_OVERRIDE_RETURN 0x40000000


// The implementation details of the tracing feature.

VOID
RxDebugTraceActual (
    IN ULONG NewMask,
    IN PCH Format,
    ...
    );

BOOLEAN
RxDbgTraceActualNew (
    IN ULONG NewMask,
    IN OUT PDEBUG_TRACE_CONTROLPOINT ControlPoint
    );

PRX_DEBUG_TRACE_CONTROL
RxDbgTraceFindControlPointActual(
    IN OUT PDEBUG_TRACE_CONTROLPOINT ControlPoint
    );

VOID
RxInitializeDebugTraceControlPoint(
    PSZ Name,
    PDEBUG_TRACE_CONTROLPOINT ControlPoint
    );

extern PCHAR RxIrpCodeToName[];

#endif  //DBG

#ifdef RDBSSTRACE
BOOLEAN
RxDbgTraceDisableGlobally(void);

VOID
RxDbgTraceEnableGlobally(BOOLEAN flag);

VOID
RxDebugTraceDebugCommand(
    PSZ name,
    ULONG level,
    ULONG pointcount
    );

VOID
RxDebugTraceZeroAllPrintLevels(
    void
    );

extern ULONG rdbsstracemarker;

#define RxDTMASK(INDENT,WRITELEVEL) \
         ( (((INDENT)+RxDT_INDENT_EXCESS)<<RxDT_INDENT_SHIFT) + ((WRITELEVEL)&RxDT_LEVEL_MASK))

#define RxDTPrefixRx(___x) RX_##___x

#define RxDbgTraceLV__norx_reverseaction(INDENT,CONTROLPOINT,LEVEL,Z) \
        {BOOLEAN PrintIt = RxDbgTraceActualNew((RxDT_SUPPRESS_PRINT | RxDT_OVERRIDE_RETURN | RxDTMASK((INDENT),(LEVEL))),\
                                               (CONTROLPOINT)); \
         if (!PrintIt) Z;                    \
        }

#define RxDbgTraceLV__norx(INDENT,CONTROLPOINT,LEVEL,Z) \
        {BOOLEAN PrintIt = RxDbgTraceActualNew( RxDTMASK((INDENT),(LEVEL)),(CONTROLPOINT)); \
         if (PrintIt) DbgPrint Z;                    \
        }

#define RxDbgTraceLVUnIndent__norx(INDENT,CONTROLPOINT,LEVEL) \
        {BOOLEAN PrintIt = RxDbgTraceActualNew((RxDT_SUPPRESS_PRINT | RxDTMASK((INDENT),(LEVEL))),(CONTROLPOINT)); \
        }

#define RxDbgTraceLV__(INDENT,CONTROLPOINT,LEVEL,Z) \
        RxDbgTraceLV__norx(INDENT,(&RxDTPrefixRx##CONTROLPOINT),LEVEL,Z)

#define RxDbgTraceLVUnIndent__(INDENT,CONTROLPOINT,LEVEL) \
        RxDbgTraceLVUnIndent__norx(INDENT,(&RxDTPrefixRx##CONTROLPOINT),LEVEL)

#define RxDbgTrace(INDENT,CONTROLPOINT,Z) \
             RxDbgTraceLV__(INDENT,CONTROLPOINT,1,Z) \

#define RxDbgTraceLV(INDENT,CONTROLPOINT,LEVEL,Z) \
             RxDbgTraceLV__(INDENT,CONTROLPOINT,LEVEL,Z) \

#define RxDbgTraceUnIndent(INDENT,CONTROLPOINT) \
             RxDbgTraceLVUnIndent__(INDENT,CONTROLPOINT,1)

// do not define this for nonrdbsstrace; so to catch references not ifdef'd
#define RxDbgTraceFindControlPoint(CONTROLPOINT) (RxDbgTraceFindControlPointActual(&RxDTPrefixRx##CONTROLPOINT))


#define DebugBreakPoint(CONTROLPOINT,MASKBIT) {           \
    if (((MASKBIT) == 0)                                     \
         || (RxDbgTraceFindControlPoint(CONTROLPOINT)->BreakMask & (1<<((MASKBIT)-1)) )) { \
        DbgBreakPoint();                                     \
    }                                                        \
}

#define DebugUnwind(X) {                                                      \
    if (AbnormalTermination()) {                                              \
        RxDbgTrace(0, (DEBUG_TRACE_UNWIND), ( #X ", Abnormal termination.\n", 0)); \
    }                                                                         \
}

#ifdef RX_PERFPORMANCE_TIMER
extern LONG RxPerformanceTimerLevel;

#define TimerStart(LEVEL) {                     \
    LARGE_INTEGER TStart, TEnd;                 \
    LARGE_INTEGER TElapsed;                     \
    TStart = KeQueryPerformanceCounter( NULL ); \

#define TimerStop(LEVEL,s)                                    \
    TEnd = KeQueryPerformanceCounter( NULL );                 \
    TElapsed.QuadPart = TEnd.QuadPart - TStart.QuadPart;      \
    RxTotalTicks[RxLogOf(LEVEL)] += TElapsed.LowPart;       \
    if (FlagOn( RxPerformanceTimerLevel, (LEVEL))) {         \
        DbgPrint("Time of %s %ld\n", (s), TElapsed.LowPart ); \
    }                                                         \
}
#endif //RX_PERFPORMANCE_TIMER

#else  // RDBSSTRACE

#define RxDbgTraceLV__norx_reverseaction(INDENT,CONTROLPOINT,LEVEL,Z)      {NOTHING;}
#define RxDbgTraceLV(INDENT,CONTROLPOINTNUM,LEVEL,Z)     {NOTHING;}
#define RxDbgTraceLVUnIndent(INDENT,CONTROLPOINTNUM,LEVEL)     {NOTHING;}
#define RxDbgTrace(INDENT,CONTROLPOINTNUM,Z)     {NOTHING;}
#define RxDbgTraceUnIndent(INDENT,CONTROLPOINTNUM)     {NOTHING;}
#define DebugBreakPoint(CONTROLPOINTNUM,MASKBIT) {NOTHING;}
#define DebugUnwind(X)                   {NOTHING;}
#define RxDbgTraceDisableGlobally() FALSE
#define RxDbgTraceEnableGlobally(f) {NOTHING;}

#ifdef RX_PERFPORMANCE_TIMER
#define TimerStart(LEVEL)
#define TimerStop(LEVEL,s)
#endif

#endif // RDBSSTRACE


#endif // _RDBSSTRACE_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rxtypes.h ===
#ifndef _RXTYPES_INCL
#define _RXTYPES_INCL

#include "nodetype.h"

typedef PVOID RX_HANDLE, *PRX_HANDLE;
typedef KSPIN_LOCK  RX_SPIN_LOCK;
typedef PKSPIN_LOCK PRX_SPIN_LOCK;


// String definitions
// The RX_STRING type corresponds to a UNICODE_STRING and all the Rtl functions that are
// available to manipulate Unicode strings can be used to manipulate the strings
//

typedef struct _BINDING_HANDLE {
    RX_HANDLE pTdiEmulationContext;  // Win9X net structure
    RX_HANDLE pTransportInformation; // tdi transport information.
} RX_BINDING_HANDLE, *PRX_BINDING_HANDLE;

typedef UNICODE_STRING UNICODE_STRING;
typedef UNICODE_STRING*     PUNICODE_STRING;


// This structure is transient.  Most fields in this structure allow us to
// move through the bind/addname part of activating a net.  Runtime info
// for the rxce and long term context is kept elsewhere.

typedef struct _RX_BINDING_CONTEXT {
    PUNICODE_STRING         pTransportName;       // Transport Name (unicode string).
    ULONG              QualityOfService;     // Requested QOS.
    // Common fields.
    PRX_BINDING_HANDLE pBindHandle;          // Handle to transport bind info.
    } RX_BINDING_CONTEXT, *PRX_BINDING_CONTEXT;
#endif      // _RXTYPES_INCL


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rxtimer.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    RxTimer.h

Abstract:

    This module defines the prototypes and structures for the timer on the rdbss architecture.
    What is provided is a 55ms timer...that is, if you register a routine then you get a call
    every 55ms. On NT, you're at DPC level.

    Also contained here are the routines for posting to a thread from DPC level.


Author:

    Joe Linn     [JoeLinn]   2-mar-95

Revision History:

    Balan Sethu Raman [SethuR] 7-March-95
         Modified signatures to provide one shot timer service. Merged timer entry and
         work item definitions.

--*/

#ifndef _RXTIMER_H_
#define _RXTIMER_H_

//
// The RX_WORK_ITEM encapsulates the context for posting to a worker thread as well as
// a timer routine to be triggered after a specific interval.
//

typedef struct _RX_WORK_ITEM_ {
    RX_WORK_QUEUE_ITEM       WorkQueueItem;
    ULONG                    LastTick;
    ULONG                    Options;
} RX_WORK_ITEM, *PRX_WORK_ITEM;

extern NTSTATUS
NTAPI
RxPostOneShotTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORK_ITEM            pWorkItem,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext,
    IN LARGE_INTEGER            TimeInterval);

extern NTSTATUS
NTAPI
RxPostRecurrentTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext,
    IN LARGE_INTEGER            TimeInterval);


extern NTSTATUS
NTAPI
RxCancelTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext
    );


//
// Routines for initializing and tearing down the timer service in RDBSS
//

extern NTSTATUS
NTAPI
RxInitializeRxTimer();

extern VOID
NTAPI
RxTearDownRxTimer(void);

#endif // _RXTIMER_STUFF_DEFINED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rxworkq.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rxworkq.h

Abstract:

    This module defines the data structures required to implement the dispatching
    mechanism in RDBSS for use by RDBSS as well as all the mini redirectors.

Author:

    Balan Sethu Raman [SethuR] 20-Mar-96

--*/

#ifndef _RXWORKQ_H_
#define _RXWORKQ_H_

//
// The worker thread routine prototype definition.
//

typedef
VOID
(NTAPI *PRX_WORKERTHREAD_ROUTINE) (
    IN PVOID Context
    );

//
// The RDBSS needs to keep track of the work items on a per device object basis.
// This enables the race conditions associated with loading/unloading as well as
// a mechanism for preventing a single mini redirector from unfairly hogging all
// the resources.
//

#ifdef __cplusplus
typedef struct _RX_WORK_QUEUE_ITEM_ : public WORK_QUEUE_ITEM {
        // the work queue item as defined in NTOS
#else // !__cplusplus
typedef struct _RX_WORK_QUEUE_ITEM_ {
   WORK_QUEUE_ITEM;     // the work queue item as defined in NTOS
#endif // __cplusplus

   PRDBSS_DEVICE_OBJECT pDeviceObject;
} RX_WORK_QUEUE_ITEM, *PRX_WORK_QUEUE_ITEM;

//
// There are certain scenarios in which dispatching of work items is inevitable.
// In such instance the WORK_QUEUE_ITEM is allocated as part of another data
// structure to avoid frequent allocation/freeing. In other scenarios where
// dispatching is rare it pays to avoid the allocation of the memory till it
// is rquired. The RDBSS work queue implementations provide for both these
// scenarios in the form of dispatching and posting work queue requests. In
// the case of dispatching no memory for the WORK_QUEUE_ITEM need be allocated
// by the caller while for posting the memory for WORK_QUEUE_ITEM needs to be
// allocated by the caller.
//

typedef struct _RX_WORK_DISPATCH_ITEM_ {
   RX_WORK_QUEUE_ITEM       WorkQueueItem;
   PRX_WORKERTHREAD_ROUTINE DispatchRoutine;
   PVOID                    DispatchRoutineParameter;
} RX_WORK_DISPATCH_ITEM, *PRX_WORK_DISPATCH_ITEM;

//
// The work queues typically come up in a active state and continue till either
// a non recoverable situation is encountered ( lack of system resources ) when
// it transitions to the Inactive state. When a rundown is initiated it transitions
// to the rundown in progress state.
//

typedef enum _RX_WORK_QUEUE_STATE_ {
   RxWorkQueueActive,
   RxWorkQueueInactive,
   RxWorkQueueRundownInProgress
} RX_WORK_QUEUE_STATE, *PRX_WORK_QUEUE_STATE;

//
// The rundown of work queues is not complete when the threads have been spun down.
// The termination of the threads needs to be ensured before the data structures
// can be torn down. The work queue implementation follows a protocol in which
// each of the threads being spundown stashes a reference to the thread object
// in the rundown context. The rundown issuing thread ( which does not belong to
// the work queue ) waits for the completion of all the threads spundown before
// tearing down the data structures.
//

typedef struct _RX_WORK_QUEUE_RUNDOWN_CONTEXT_ {
   KEVENT      RundownCompletionEvent;
   LONG        NumberOfThreadsSpunDown;
   PETHREAD    *ThreadPointers;
} RX_WORK_QUEUE_RUNDOWN_CONTEXT, *PRX_WORK_QUEUE_RUNDOWN_CONTEXT;

//
// The work queue implementation is built around a KQUEUE implementation. The
// additional support involves the regulation of number of threads that are
// actively waiting for the work items. Each work queue data structure is
// allocated in nonpaged pool and has its own synchronization mechanism ( spinlock).
//
// In addition to the bookkeeing information, i.e., state, type etc. it also includes
// statistics that are gathered over the lifetime of the queue. This will
// provide valuable information in tuning a work queue instance. The number of items
// that have been processed , the number of items that have to be processed and
// the cumulative queue length is recorded. The cumulative queue length is the
// intersiting metric, it is the sum of the number of items awaiting to be processed
// each time an additional work item was queued. The cumulative queue length
// divided by the sum of the total number of items processed and the anumber of
// items to be processed gives an indication of the average length of the
// queue. A value much greater than one signifies that the  minimum number of
// worker threads associated with the work queue can be increased. A value much
// less than one signifies that the maximum number of work threads associated
// with the queue can be decreased.
//

typedef struct _RX_WORK_QUEUE_ {
   USHORT  State;
   BOOLEAN SpinUpRequestPending;
   UCHAR   Type;

   KSPIN_LOCK SpinLock;

   PRX_WORK_QUEUE_RUNDOWN_CONTEXT pRundownContext;

   LONG    NumberOfWorkItemsDispatched;
   LONG    NumberOfWorkItemsToBeDispatched;
   LONG    CumulativeQueueLength;

   LONG    NumberOfSpinUpRequests;
   LONG    MaximumNumberOfWorkerThreads;
   LONG    MinimumNumberOfWorkerThreads;
   LONG    NumberOfActiveWorkerThreads;
   LONG    NumberOfIdleWorkerThreads;
   LONG    NumberOfFailedSpinUpRequests;
   LONG    WorkQueueItemForSpinUpWorkerThreadInUse;

   RX_WORK_QUEUE_ITEM WorkQueueItemForTearDownWorkQueue;
   RX_WORK_QUEUE_ITEM WorkQueueItemForSpinUpWorkerThread;
   RX_WORK_QUEUE_ITEM WorkQueueItemForSpinDownWorkerThread;

   KQUEUE  Queue;

   // The next field is for debugging purposes and will be removed from the
   // FREE build.
   PETHREAD *ThreadPointers;

} RX_WORK_QUEUE, *PRX_WORK_QUEUE;

//
// The dispatching mechanism in RDBSS provides for multiple levels of work queues
// on a per processor basis. There are three levels of work queues currently
// supported, Critical,Delayed and HyperCritical. The distinction between Critical
// and delayed is one of priority where as HyperCritical iss different from the
// other two in that the routines should not block, i.e., wait for any resource.
// This requirement cannot be enforced hence the effectiveness of the dispatching
// mechanism relies on the implicit cooperation of the clients.
//

typedef struct _RX_WORK_QUEUE_DISPATCHER_ {
   RX_WORK_QUEUE     WorkQueue[MaximumWorkQueue];
} RX_WORK_QUEUE_DISPATCHER, *PRX_WORK_QUEUE_DISPATCHER;

//
// The dispatcher typically come up in a active state and continue till either
// a non recoverable situation is encountered ( lack of system resources ) when
// it transitions to the Inactive state. When a rundown is initiated it transitions
// to the rundown in progress state.
//

typedef enum _RX_DISPATCHER_STATE_ {
   RxDispatcherActive,
   RxDispatcherInactive
} RX_DISPATCHER_STATE, *PRX_DISPATCHER_STATE;


//
// The RDBSS dispatching mechanism on any machine is an array of the dispatchers
// associated with each processor. When a work queue item is queued a best effort
// is made to contain the work emanating from a processor onto the same processor.
// This ensures that processor affinities setup by the NT dispatcher are not
// destroyed by the RDBSS dispatching mechanism as this could lead to excessive
// sloshing. When the work needs to be moved there are two metrics that will be
// useful in making the decision, teh amount of delay that will be experienced
// by the work item in the current queue and the effort involved in moving the
// work item to the other queue. It is very easy to quantify the former but very
// difficult to quantify the later.
//

typedef struct _RX_DISPATCHER_ {
   LONG                       NumberOfProcessors;
   PEPROCESS                  OwnerProcess;
   PRX_WORK_QUEUE_DISPATCHER  pWorkQueueDispatcher;

   RX_DISPATCHER_STATE        State;

   LIST_ENTRY                 SpinUpRequests;
   KSPIN_LOCK                 SpinUpRequestsLock;
   KEVENT                     SpinUpRequestsEvent;
   KEVENT                     SpinUpRequestsTearDownEvent;
} RX_DISPATCHER, *PRX_DISPATCHER;

//
// The function prototypes used for dispatching/posting work queue items
//

extern NTSTATUS
NTAPI
RxPostToWorkerThread (
    IN PRDBSS_DEVICE_OBJECT     pMRxDeviceObject,
    IN WORK_QUEUE_TYPE          WorkQueueType,
    IN PRX_WORK_QUEUE_ITEM      pWorkQueueItem,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext
    );

extern NTSTATUS
NTAPI
RxDispatchToWorkerThread(
    IN  PRDBSS_DEVICE_OBJECT     pMRxDeviceObject,
    IN  WORK_QUEUE_TYPE          WorkQueueType,
    IN  PRX_WORKERTHREAD_ROUTINE Routine,
    IN  PVOID                    pContext);

extern BOOLEAN           //should only be called from raised IRQL
NTAPI
RxIsWorkItemQueued(
    IN OUT PWORK_QUEUE_ITEM WorkItem
    );

//
// The routines for initializing/tearing down the dispatching mechanism
//

extern NTSTATUS
RxInitializeDispatcher();

extern NTSTATUS
RxTearDownDispatcher();

extern NTSTATUS
RxInitializeMRxDispatcher(
     IN OUT PRDBSS_DEVICE_OBJECT pMRxDeviceObject);

extern NTSTATUS
RxSpinDownMRxDispatcher(
     IN OUT PRDBSS_DEVICE_OBJECT pMRxDeviceObject);

#endif  _RXWORKQ_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rxstruc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxStruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the Rx file system.

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

    Joe Linn        [joelinn]   aug-1994 moved over to rdbss

--*/

#ifndef _RDBSSSTRUC_
#define _RDBSSSTRUC_

#include "prefix.h"
#include "lowio.h"
#include "scavengr.h"      // scavenger related definitions.
#include "RxContx.h"
#include "mrx.h"
#include "Fcb.h"

//define our byte offsets to be the full 64 bits
typedef LONGLONG RXVBO;

#if 0
//
//  Define who many freed structures we are willing to keep around
//

#define FREE_FOBX_SIZE                   (8)
#define FREE_FCB_SIZE                    (8)
#define FREE_NON_PAGED_FCB_SIZE          (8)

#define FREE_128_BYTE_SIZE               (16)
#define FREE_256_BYTE_SIZE               (16)
#define FREE_512_BYTE_SIZE               (16)
#endif //0


//
//  We will use both a common and private dispatch tables on a per FCB basis to (a) get
//  some encapsulation and (b) [less important] go a little faster. The driver table then gets
//  optimized for the most common case. Right now we just use the common dispatch...later and
//  Eventually, all the FCBs will have pointers to optimized dispatch tables.
//

//  used to synchronize access to  rxcontxs and structures

extern RX_SPIN_LOCK RxStrucSupSpinLock;


typedef struct _RDBSS_EXPORTS {
    RX_SPIN_LOCK             *pRxStrucSupSpinLock;
    PLONG                    pRxDebugTraceIndent;
} RDBSS_EXPORTS, *PRDBSS_EXPORTS;

extern RDBSS_EXPORTS RxExports;

// this type is used with table locks to track whether or not the lock
// should be released

typedef enum _LOCK_HOLDING_STATE {
    LHS_LockNotHeld,
    LHS_SharedLockHeld,
    LHS_ExclusiveLockHeld
} LOCK_HOLDING_STATE;

//
//  The RDBSS_DATA record is the top record in the Rx file system in-memory
//  data structure.  This structure must be allocated from non-paged pool.
//

typedef struct _RDBSS_DATA {

    //
    //  The type and size of this record (must be RDBSS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //  The Driver object we were initialized with

    PDRIVER_OBJECT DriverObject;

    //
    // Mini Rdr registration related fields
    //

    LONG      NumberOfMinirdrsStarted;

    FAST_MUTEX MinirdrRegistrationMutex;
    LIST_ENTRY RegisteredMiniRdrs;          //protected by the mutex
    LONG       NumberOfMinirdrsRegistered;  //protected by the mutex

    //
    //  A pointer to our EPROCESS struct, which is a required input to the
    //  Cache Management subsystem.
    //

    PEPROCESS OurProcess;

#if 0
    //
    //  This is the ExWorkerItem that does both kinds of deferred closes.
    //

    RX_WORK_QUEUE_ITEM RxCloseItem;
#endif //0

    //
    //  Cache manager call back structures, which must be passed on each call
    //  to CcInitializeCacheMap.
    //

    CACHE_MANAGER_CALLBACKS CacheManagerCallbacks;
    CACHE_MANAGER_CALLBACKS CacheManagerNoOpCallbacks;

    //  To control access to the global Rx data record

    ERESOURCE Resource;

} RDBSS_DATA;
typedef RDBSS_DATA *PRDBSS_DATA;

extern RDBSS_DATA RxData;

extern PEPROCESS
RxGetRDBSSProcess();

//
// Note: A Strategy needs to be in place to deal with requests for stopping the
// RDBSS when requests are active.
//

typedef enum _RX_RDBSS_STATE_ {
   RDBSS_STARTABLE = 0,  //RDBSS_START_IN_PROGRESS,
   RDBSS_STARTED,
   RDBSS_STOP_IN_PROGRESS
   //this state deleted with cause! RDBSS_STOPPED
} RX_RDBSS_STATE, *PRX_RDBSS_STATE;

typedef struct _RDBSS_STARTSTOP_CONTEXT_ {
   RX_RDBSS_STATE State;
   ULONG          Version;
   PRX_CONTEXT    pStopContext;
} RDBSS_STARTSTOP_CONTEXT, *PRDBSS_STARTSTOP_CONTEXT;

typedef struct _MRX_CALLDOWN_COMPLETION_CONTEXT_ {
   LONG     WaitCount;
   KEVENT   Event;
} MRX_CALLDOWN_COMPLETION_CONTEXT,
  *PMRX_CALLDOWN_COMPLETION_CONTEXT;

typedef
NTSTATUS
(NTAPI *PMRX_CALLDOWN_ROUTINE) (
    IN OUT PVOID pCalldownParameter);


typedef struct _MRX_CALLDOWN_CONTEXT_ {
   RX_WORK_QUEUE_ITEM               WorkQueueItem;
   PRDBSS_DEVICE_OBJECT             pMRxDeviceObject;
   PMRX_CALLDOWN_COMPLETION_CONTEXT pCompletionContext;
   PMRX_CALLDOWN_ROUTINE            pRoutine;
   NTSTATUS                         CompletionStatus;
   PVOID                            pParameter;
} MRX_CALLDOWN_CONTEXT, *PMRX_CALLDOWN_CONTEXT;

typedef struct _RX_DISPATCHER_CONTEXT_ {
   LONG     NumberOfWorkerThreads;
   PKEVENT  pTearDownEvent;
} RX_DISPATCHER_CONTEXT, *PRX_DISPATCHER_CONTEXT;

#define RxSetRdbssState(RxDeviceObject,NewState)                \
        {                                                       \
           KIRQL SavedIrql;                                     \
           KeAcquireSpinLock(&RxStrucSupSpinLock,&SavedIrql);   \
           RxDeviceObject->StartStopContext.State = (NewState); \
           KeReleaseSpinLock(&RxStrucSupSpinLock,SavedIrql);    \
        }

#define RxGetRdbssState(RxDeviceObject)         \
        (RxDeviceObject)->StartStopContext.State

extern BOOLEAN
RxIsOperationCompatibleWithRdbssState(PIRP pIrp);

//
//  The RDBSS Device Object is an I/O system device object with additions for
//  the various structures needed by each minirdr: the dispatch, export-to-minirdr
//  structure, MUP call characteristics, list of active operations, etc.
//

typedef struct _RDBSS_DEVICE_OBJECT {

    union {
        DEVICE_OBJECT DeviceObject;
#ifndef __cplusplus
        DEVICE_OBJECT;
#endif // __cplusplus
    };

    ULONG RegistrationControls;
    PRDBSS_EXPORTS    RdbssExports;      //stuff that the minirdr needs to know
    PDEVICE_OBJECT    RDBSSDeviceObject; // set to NULL if monolithic
    PMINIRDR_DISPATCH Dispatch; // the mini rdr dispatch vector
    UNICODE_STRING    DeviceName;

    ULONG             NetworkProviderPriority;

    HANDLE            MupHandle;

    BOOLEAN           RegisterUncProvider;
    BOOLEAN           RegisterMailSlotProvider;
    BOOLEAN           RegisteredAsFileSystem;
    BOOLEAN           Unused;

    LIST_ENTRY        MiniRdrListLinks;

    ULONG             NumberOfActiveFcbs;
    ULONG             NumberOfActiveContexts;

    struct {
        LARGE_INTEGER   PagingReadBytesRequested;
        LARGE_INTEGER   NonPagingReadBytesRequested;
        LARGE_INTEGER   CacheReadBytesRequested;
        LARGE_INTEGER   FastReadBytesRequested;
        LARGE_INTEGER   NetworkReadBytesRequested;
        ULONG           ReadOperations;
        ULONG           FastReadOperations;
        ULONG           RandomReadOperations;

        LARGE_INTEGER   PagingWriteBytesRequested;
        LARGE_INTEGER   NonPagingWriteBytesRequested;
        LARGE_INTEGER   CacheWriteBytesRequested;
        LARGE_INTEGER   FastWriteBytesRequested;
        LARGE_INTEGER   NetworkWriteBytesRequested;
        ULONG           WriteOperations;
        ULONG           FastWriteOperations;
        ULONG           RandomWriteOperations;
    };

    //
    //  The following field tells how many requests for this volume have
    //  either been enqueued to ExWorker threads or are currently being
    //  serviced by ExWorker threads.  If the number goes above
    //  a certain threshold, put the request on the overflow queue to be
    //  executed later.
    //

    LONG PostedRequestCount[MaximumWorkQueue];

    //
    //  The following field indicates the number of IRP's waiting
    //  to be serviced in the overflow queue.
    //

    LONG OverflowQueueCount[MaximumWorkQueue];

    //
    //  The following field contains the queue header of the overflow queue.
    //  The Overflow queue is a list of IRP's linked via the IRP's ListEntry
    //  field.
    //

    LIST_ENTRY OverflowQueue[MaximumWorkQueue];

    //
    //  The following spinlock protects access to all the above fields.
    //

    RX_SPIN_LOCK OverflowQueueSpinLock;

    //
    // The following fields are required for synchronization with async.
    // requests issued by the RDBSS on behalf of this mini redirector on
    // on shutdown.
    //

    LONG    AsynchronousRequestsPending;

    PKEVENT pAsynchronousRequestsCompletionEvent;

    RDBSS_STARTSTOP_CONTEXT StartStopContext;

    RX_DISPATCHER_CONTEXT   DispatcherContext;

    struct _RX_PREFIX_TABLE  *pRxNetNameTable; //some guys may want to share
    struct _RX_PREFIX_TABLE  RxNetNameTableInDeviceObject;

    PRDBSS_SCAVENGER pRdbssScavenger; //for sharing
    RDBSS_SCAVENGER RdbssScavengerInDeviceObject;

} RDBSS_DEVICE_OBJECT;

typedef RDBSS_DEVICE_OBJECT *PRDBSS_DEVICE_OBJECT;

INLINE VOID
NTAPI
RxUnregisterMinirdr(
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
)
{
    PDEVICE_OBJECT RDBSSDeviceObject;

    RDBSSDeviceObject = RxDeviceObject->RDBSSDeviceObject;

    RxpUnregisterMinirdr(RxDeviceObject);

    if (RDBSSDeviceObject != NULL) {
        ObDereferenceObject(RDBSSDeviceObject);
    }
}

extern FAST_MUTEX RxMinirdrRegistrationMutex;
extern LIST_ENTRY RxRegisteredMiniRdrs;
extern ULONG RxNumberOfMinirdrs;

#endif // _RDBSSSTRUC_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\scavengr.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    scavengr.h

Abstract:

    This module defines data structures related to scavenging in the RDBSS

Author:

    Balan Sethu Raman     [SethuR]   9-Sep-1995

Revision History:


Notes:

    The dormant file limit must be made configurable on a per server basis

--*/

#ifndef _SCAVENGR_H_
#define _SCAVENGR_H_

// currently, only a single scavengermutex is across all scavenging operations
// for all underlying deviceobjects
extern KMUTEX       RxScavengerMutex;

// An instance of this data structure is embedded as part of those data structures
// that are scavenged, i.e., FCB, RX_CONTEXT, etc.

#define RX_SCAVENGER_ENTRY_TYPE_MARKER   (0x0001)
#define RX_SCAVENGER_ENTRY_TYPE_FCB      (0x0002)

#define RX_SCAVENGER_OP_PURGE            (0x0001)
#define RX_SCAVENGER_OP_CLOSE            (0x0002)

#define RX_SCAVENGER_INITIATED_OPERATION     (0x0001)

typedef enum _RX_SCAVENGER_ENTRY_STATE {
   RX_SCAVENGING_INACTIVE,
   RX_SCAVENGING_PENDING,
   RX_SCAVENGING_IN_PROGRESS,
   RX_SCAVENGING_AWAITING_RESPONSE
} RX_SCAVENGER_ENTRY_STATE, *PRX_SCAVENGER_ENTRY_STATE;

typedef struct _RX_SCAVENGER_ENTRY {
   // List of related items to be scavenged
   LIST_ENTRY  List;

   UCHAR        Type;
   UCHAR        Operation;
   UCHAR        State;
   UCHAR        Flags;

   struct _RX_SCAVENGER_ENTRY *pContinuationEntry;
} RX_SCAVENGER_ENTRY, *PRX_SCAVENGER_ENTRY;


#define RxInitializeScavengerEntry(pScavengerEntry)      \
        (pScavengerEntry)->State  = 0;                   \
        (pScavengerEntry)->Flags  = 0;                   \
        (pScavengerEntry)->Type   = 0;                   \
        (pScavengerEntry)->Operation = 0;                \
        InitializeListHead(&(pScavengerEntry)->List);  \
        (pScavengerEntry)->pContinuationEntry = NULL

#define RX_SCAVENGER_MUTEX_ACQUIRED (1)

typedef enum _RDBSS_SCAVENGER_STATE {
   RDBSS_SCAVENGER_INACTIVE,
   RDBSS_SCAVENGER_DORMANT,
   RDBSS_SCAVENGER_ACTIVE,
   RDBSS_SCAVENGER_SUSPENDED
} RDBSS_SCAVENGER_STATE, *PRDBSS_SCAVENGER_STATE;

typedef struct _RDBSS_SCAVENGER {
   RDBSS_SCAVENGER_STATE State;

   LONG                 MaximumNumberOfDormantFiles;
   LONG                 NumberOfDormantFiles;

   ULONG                 SrvCallsToBeFinalized;
   ULONG                 NetRootsToBeFinalized;
   ULONG                 VNetRootsToBeFinalized;
   ULONG                 FcbsToBeFinalized;
   ULONG                 SrvOpensToBeFinalized;
   ULONG                 FobxsToBeFinalized;

   LIST_ENTRY            SrvCallFinalizationList;
   LIST_ENTRY            NetRootFinalizationList;
   LIST_ENTRY            VNetRootFinalizationList;
   LIST_ENTRY            FcbFinalizationList;
   LIST_ENTRY            SrvOpenFinalizationList;
   LIST_ENTRY            FobxFinalizationList;

   LIST_ENTRY            ClosePendingFobxsList;

   RX_WORK_ITEM          WorkItem;
   KEVENT                SyncEvent;

   PETHREAD              CurrentScavengerThread;
   PNET_ROOT             CurrentNetRootForClosePendingProcessing;
   PFCB                  CurrentFcbForClosePendingProcessing;
   KEVENT                ClosePendingProcessingSyncEvent;
} RDBSS_SCAVENGER, *PRDBSS_SCAVENGER;

#if 0
//this is not used anywhere
typedef struct _RX_FCB_SCAVENGER_ {
   ULONG               State;
   ULONG               OperationsCompleted;
   PRX_SCAVENGER_ENTRY pLastActiveMarkerEntry;
   LIST_ENTRY          OperationsPendingList;
   LIST_ENTRY          OperationsInProgressList;
   LIST_ENTRY          OperationsAwaitingResponseList;
} RX_FCB_SCAVENGER, *PRX_FCB_SCAVENGER;

#define RxInitializeFcbScavenger(pFcbScavenger)                              \
    (pFcbScavenger)->pLastActiveMarkerEntry = NULL;                          \
    (pFcbScavenger)->OperationsCompleted    = 0;                             \
    (pFcbScavenger)->State                  = 0;                             \
    InitializeListHead(&(pFcbScavenger)->OperationsPendingList);           \
    InitializeListHead(&(pFcbScavenger)->OperationsInProgressList);        \
    InitializeListHead(&(pFcbScavenger)->OperationsAwaitingResponseList)
#endif

#define RxInitializeRdbssScavenger(pScavenger)                              \
    (pScavenger)->State = RDBSS_SCAVENGER_INACTIVE;                         \
    (pScavenger)->SrvCallsToBeFinalized = 0;                                \
    (pScavenger)->NetRootsToBeFinalized = 0;                                \
    (pScavenger)->VNetRootsToBeFinalized = 0;                               \
    (pScavenger)->FcbsToBeFinalized = 0;                                    \
    (pScavenger)->SrvOpensToBeFinalized = 0;                                \
    (pScavenger)->FobxsToBeFinalized = 0;                                   \
    (pScavenger)->NumberOfDormantFiles = 0;                                 \
    (pScavenger)->MaximumNumberOfDormantFiles = 50;                         \
    (pScavenger)->CurrentFcbForClosePendingProcessing = NULL;               \
    (pScavenger)->CurrentNetRootForClosePendingProcessing = NULL;           \
    KeInitializeEvent(&((pScavenger)->SyncEvent),NotificationEvent,FALSE);  \
    KeInitializeEvent(&((pScavenger)->ClosePendingProcessingSyncEvent),NotificationEvent,FALSE);  \
    InitializeListHead(&(pScavenger)->SrvCallFinalizationList);           \
    InitializeListHead(&(pScavenger)->NetRootFinalizationList);           \
    InitializeListHead(&(pScavenger)->VNetRootFinalizationList);          \
    InitializeListHead(&(pScavenger)->SrvOpenFinalizationList);           \
    InitializeListHead(&(pScavenger)->FcbFinalizationList);               \
    InitializeListHead(&(pScavenger)->FobxFinalizationList);              \
    InitializeListHead(&(pScavenger)->ClosePendingFobxsList)


#define RxAcquireScavengerMutex()   \
        KeWaitForSingleObject(&RxScavengerMutex,Executive,KernelMode,FALSE,NULL)

#define RxReleaseScavengerMutex()   \
        KeReleaseMutex(&RxScavengerMutex,FALSE)

extern NTSTATUS
RxMarkFcbForScavengingAtCleanup(PFCB pFcb);

extern NTSTATUS
RxMarkFcbForScavengingAtClose(PFCB pFcb);

extern VOID
RxUpdateScavengerOnCloseCompletion(PFCB pFcb);

extern VOID
RxMarkFobxOnCleanup(PFOBX pFobx, BOOLEAN *pNeedPurge);

extern VOID
RxMarkFobxOnClose(PFOBX pFobx);

extern NTSTATUS
RxPurgeRelatedFobxs(PNET_ROOT pNetRoot,PRX_CONTEXT pRxContext,BOOLEAN AttemptFinalization,PFCB PurgingFcb);
#define DONT_ATTEMPT_FINALIZE_ON_PURGE FALSE
#define ATTEMPT_FINALIZE_ON_PURGE TRUE
//
// the purge_sync context is used to synchronize contexts that are attempting to purge...
// notatbly creates and dirctrls. these are planted in various structures because various minirdrs
// require different granularity of purge operations

typedef struct _PURGE_SYNCHRONIZATION_CONTEXT {
    LIST_ENTRY   ContextsAwaitingPurgeCompletion; // the list of purge requests active for this netroot.
    BOOLEAN      PurgeInProgress;
} PURGE_SYNCHRONIZATION_CONTEXT, *PPURGE_SYNCHRONIZATION_CONTEXT;

VOID
RxInitializePurgeSyncronizationContext (
    PPURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext
    );


extern NTSTATUS
RxScavengeRelatedFcbs(PRX_CONTEXT pRxContext);

extern BOOLEAN
RxScavengeRelatedFobxs(PFCB pFcb);

extern VOID
RxScavengeFobxsForNetRoot(
    struct _NET_ROOT *pNetRoot,
    PFCB             PurgingFcb);

extern VOID
RxpMarkInstanceForScavengedFinalization(
   PVOID pInstance);

extern VOID
RxpUndoScavengerFinalizationMarking(
   PVOID pInstance);

extern VOID
RxTerminateScavenging(
   PRX_CONTEXT pRxContext);

extern BOOLEAN
RxScavengeVNetRoots(
    PRDBSS_DEVICE_OBJECT RxDeviceObject);

extern VOID
RxSynchronizeWithScavenger(
    PRX_CONTEXT RxContext);

#endif // _SCAVENGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\rxwmi.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mupwml.h

Abstract:

    This file defines macro for use by the Rdbss driver

Author:

    yunlin

Revision History:

--*/

#ifndef __RX_RXWML_H__
#define __RX_RXWML_H__

typedef struct _RTL_TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    TIME_FIELDS StandardStart;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    TIME_FIELDS DaylightStart;
    LONG DaylightBias;
} RTL_TIME_ZONE_INFORMATION, *PRTL_TIME_ZONE_INFORMATION;
    
#ifndef _WMIKM_
#define _WMIKM_
#endif

#include "..\wmi\wmlkm.h"
#include "..\wmi\wmlmacro.h"

#define _RX_TRACE_STREAM               0x00
#define _RX_PERF_STREAM                0x01
#define _RX_INSTR_STREAM               0x02

#define _RX_ENABLE_ERROR               0x0001
#define _RX_ENABLE_LOG                 0x0002
#define _RX_ENABLE_TRACE               0x0004
#define _RX_ENABLE_SRVCALL             0x0008
#define _RX_ENABLE_NETROOT             0x0010
#define _RX_ENABLE_VNETROOT            0x0020
#define _RX_ENABLE_FCB                 0x0040
#define _RX_ENABLE_SRVOPEN             0x0080
#define _RX_ENABLE_FOBX                0x0100
#define _RX_ENABLE_TRANSPORT           0x0200
#define _RX_ENABLE_RXCONTEXT           0x0400
#define _RX_ENABLE_UNUSED1             0x0800
#define _RX_ENABLE_UNUSED2             0x1000
#define _RX_ENABLE_UNUSED3             0x2000
#define _RX_ENABLE_UNUSED4             0x4000
#define _RX_ENABLE_PAGEIORES           0x8000

#define _RX_LEVEL_DETAIL               0x1
#define _RX_LEVEL_NORM                 0x2
#define _RX_LEVEL_BRIEF                0x4

#define RX_LOG_STREAM(_stream)   _RX_ ## _stream ## _STREAM
#define RX_LOG_FLAGS(_flag)      _RX_ENABLE_ ## _flag
#define RX_LOG_LEVEL(_level)     _RX_LEVEL_ ## _level

#define RX_LOG(_why, _level, _flag, _type, _arg) \
            WML_LOG(Rdbss_, RX_LOG_STREAM(_why), RX_LOG_LEVEL(_level), _flag, _type, _arg 0)

#define LOGARG(_val)    (_val),
#define LOGNOTHING      0,

#define RxWmiTrace(_flag, _type, _arg)              \
            RX_LOG(TRACE, DETAIL, RX_LOG_FLAGS(_flag), _type, _arg)

#define RxWmiLog(_flag, _type, _arg)              \
            RX_LOG(TRACE, BRIEF, RX_LOG_FLAGS(_flag), _type, _arg)

#define RxWmiTraceError(_status, _flag, _type, _arg)    \
            RX_LOG(TRACE, DETAIL, (RX_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : RX_LOG_FLAGS(ERROR))), _type, _arg)

#define RxWmiLogError(_status, _flag, _type, _arg)    \
            RX_LOG(TRACE, BRIEF, (RX_LOG_FLAGS(_flag) | (NT_SUCCESS(_status) ? 0 : RX_LOG_FLAGS(ERROR))), _type, _arg)

#if 0
#define RX_PERF(_flag, _type, _arg)                    \
            RX_LOG (PERF, HIGH, RX_LOG_FLAGS(_flag), _type, _arg)

#define RX_INSTR(_flag, _type, _arg)                   \
            RX_LOG (INSTR, HIGH, RX_LOG_FLAGS(_flag), _type, _arg)

#define RX_PRINTF(_why, _flag, _type, _fmtstr, _arg)   \
            WML_PRINTF(_MupDrv, RX_LOG_STREAM(_why), RX_LOG_FLAGS(_flag), _type, _fmtstr, _arg 0)

#define RX_DBG_PRINT(_flag, _fmtstr, _arg)             \
            RX_PRINTF(DBGLOG, _flag, MupDefault, _fmtstr, _arg)
            
#define RX_ERR_PRINT (_status, _fmtstr, _arg) \
            if (NT_SUCCESS(_status)) {                \
                RX_PRINTF (DBGLOG, LOG_ERROR, MupDefault, _fmtstr, _arg) \
            }
#endif

typedef enum _RX_WMI_ENUM_ {
  MSG_ID_RxDefault = 1,
  MSG_ID_RxCommonDispatchProblem,
  MSG_ID_RxFsdCommonDispatch_OF,
  MSG_ID_RxInitializeContext,
  MSG_ID_RxCompleteRequest = 5,
  MSG_ID_RxCompleteRequest_NI,
  MSG_ID_RxSynchronizeBlockingOperationsMaybeDroppingFcbLock,
  MSG_ID_RxItsTheSameContext,
  MSG_ID_RxRegisterChangeBufferingStateRequest_1,
  MSG_ID_RxRegisterChangeBufferingStateRequest_2 = 10,
  MSG_ID_RxRegisterChangeBufferingStateRequest_3,
  MSG_ID_RxPrepareRequestForHandling_1,
  MSG_ID_RxPrepareRequestForHandling_2,
  MSG_ID_RxpDiscardChangeBufferingStateRequests,
  MSG_ID_RxpDispatchChangeBufferingStateRequests = 15,
  MSG_ID_RxpProcessChangeBufferingStateRequests_1,
  MSG_ID_RxpProcessChangeBufferingStateRequests_2,
  MSG_ID_RxpProcessChangeBufferingStateRequests_3,
  MSG_ID_RxpProcessChangeBufferingStateRequests_4,
  MSG_ID_RxpProcessChangeBufferingStateRequests_5 = 20,
  MSG_ID_RxLastChanceHandlerForChangeBufferingStateRequests_1,
  MSG_ID_RxLastChanceHandlerForChangeBufferingStateRequests_2,
  MSG_ID_RxLastChanceHandlerForChangeBufferingStateRequests_3,
  MSG_ID_RxProcessFcbChangeBufferingStateRequest_1,
  MSG_ID_RxProcessFcbChangeBufferingStateRequest_2 = 25,
  MSG_ID_RxProcessFcbChangeBufferingStateRequest_3,
  MSG_ID_RxProcessFcbChangeBufferingStateRequest_4,
  MSG_ID_RxChangeBufferingState_1,
  MSG_ID_RxChangeBufferingState_2,
  MSG_ID_RxChangeBufferingState_3 = 30,
  MSG_ID_RxChangeBufferingState_4,
  MSG_ID_RxChangeBufferingState_5,
  MSG_ID_RxFlushFcbInSystemCache,
  MSG_ID_RxPurgeFcbInSystemCache,
  MSG_ID_RxCopyCreateParameters_1 = 35,
  MSG_ID_RxCopyCreateParameters_2,
  MSG_ID_RxFindOrCreateFcb,
  MSG_ID_RxSearchForCollapsibleOpen,
  MSG_ID_RxCollapseOrCreateSrvOpen,
  MSG_ID_RxCommonCreate_1 = 40,
  MSG_ID_RxCommonCreate_2,
  MSG_ID_RxCommonCreate_3,
  MSG_ID_RxCommonCreate_4,
  MSG_ID_RxCommonCreate_5,
  MSG_ID_RxCommonClose_1 = 45,
  MSG_ID_RxCommonClose_2,
  MSG_ID_RxCloseAssociatedSrvOpen,
  MSG_ID_RxpCancelRoutine,
  MSG_ID_RxCancelNotifyChangeDirectoryRequestsForVNetRoot,
  MSG_ID_RxCancelNotifyChangeDirectoryRequestsForFobx = 50,
  MSG_ID_RxCommonDirectoryControl,
  MSG_ID_RxQueryDirectory_1,
  MSG_ID_RxQueryDirectory_2,
  MSG_ID_RxQueryDirectory_3,
  MSG_ID_RxCommonQueryInformation_1 = 55,
  MSG_ID_RxCommonQueryInformation_2,
  MSG_ID_RxCommonSetInformation_1,
  MSG_ID_RxCommonSetInformation_2,
  MSG_ID_RxSetBasicInfo,
  MSG_ID_RxSetDispositionInfo = 60,
  MSG_ID_RxSetRenameInfo,
  MSG_ID_RxSetPositionInfo,
  MSG_ID_RxSetAllocationInfo_1,
  MSG_ID_RxSetAllocationInfo_2,
  MSG_ID_RxSetEndOfFileInfo_1 = 65,
  MSG_ID_RxSetEndOfFileInfo_2,
  MSG_ID_RxSetEndOfFileInfo_3,
  MSG_ID_RxSetEndOfFileInfo_4,
  MSG_ID_RxQueryBasicInfo,
  MSG_ID_RxQueryStandardInfo = 70,
  MSG_ID_RxQueryInternalInfo,
  MSG_ID_RxQueryEaInfo,
  MSG_ID_RxQueryPositionInfo,
  MSG_ID_RxQueryNameInfo,
  MSG_ID_RxQueryAlternateNameInfo = 75,
  MSG_ID_RxQueryCompressedInfo,
  MSG_ID_RxSetPipeInfo,
  MSG_ID_RxQueryPipeInfo,
  MSG_ID_RxCommonFlushBuffers,
  MSG_ID_RxCommonFileSystemControl = 80,
  MSG_ID_RxLowIoFsCtlShell,
  MSG_ID_RxLowIoFsCtlShellCompletion_1,
  MSG_ID_RxLowIoFsCtlShellCompletion_2,
  MSG_ID_RxCommonLockControl_1,
  MSG_ID_RxCommonLockControl_2 = 85,
  MSG_ID_RxCommonLockControl_3,
  MSG_ID_RxCommonLockControl_4,
  MSG_ID_RxCommonLockControl_5,
  MSG_ID_RxLockOperationCompletion_1,
  MSG_ID_RxLockOperationCompletion_2 = 90,
  MSG_ID_RxLockOperationCompletion_3,
  MSG_ID_RxLockOperationCompletion_4,
  MSG_ID_RxLockOperationCompletion_5,
  MSG_ID_RxLockOperationCompletion_6,
  MSG_ID_RxLockOperationCompletion_7 = 95,
  MSG_ID_RxLockOperationCompletion_8,
  MSG_ID_RxLockOperationCompletionWithAcquire_1,
  MSG_ID_RxLockOperationCompletionWithAcquire_2,
  MSG_ID_RxLockOperationCompletionWithAcquire_3,
  MSG_ID_RxUnlockOperation = 100,
  MSG_ID_RxLowIoLockControlShellCompletion_1,
  MSG_ID_RxLowIoLockControlShellCompletion_2,
  MSG_ID_RxFinalizeLockList,
  MSG_ID_RxLowIoLockControlShell,
  MSG_ID_RxRegisterMinirdr = 105,
  MSG_ID_RxCommonDevFCBClose,
  MSG_ID_RxCommonDevFCBCleanup,
  MSG_ID_RxCommonDevFCBFsCtl,
  MSG_ID_RxCommonDevFCBQueryVolInfo,
  MSG_ID_RxExceptionFilter_1 = 110,
  MSG_ID_RxExceptionFilter_2,
  MSG_ID_RxFastIoRead_1,
  MSG_ID_RxFastIoRead_2,
  MSG_ID_RxFastIoRead_3,
  MSG_ID_RxFastIoWrite_1 = 115,
  MSG_ID_RxFastIoWrite_2,
  MSG_ID_RxFastIoCheckIfPossible,
  MSG_ID_RxFspDispatch,
  MSG_ID_RxFsdPostRequest,
  MSG_ID_RxGetNetworkProviderPriority = 120,
  MSG_ID_RxAccrueProviderFromServiceName_1,
  MSG_ID_RxAccrueProviderFromServiceName_2,
  MSG_ID_RxConstructProviderOrder_1,
  MSG_ID_RxConstructProviderOrder_2,
  MSG_ID_RxCommonRead_1 = 125,
  MSG_ID_RxCommonRead_2,
  MSG_ID_RxCommonRead_3,
  MSG_ID_RxCommonRead_4,
  MSG_ID_RxLowIoReadShellCompletion_1,
  MSG_ID_RxLowIoReadShellCompletion_2 = 130,
  MSG_ID_RxLowIoReadShellCompletion_3,
  MSG_ID_RxLowIoReadShell_1,
  MSG_ID_RxLowIoReadShell_2,
  MSG_ID_RxSetDomainForMailslotBroadcast_1,
  MSG_ID_RxSetDomainForMailslotBroadcast_2 = 135,
  MSG_ID_RxCommonQueryVolumeInformation_1,
  MSG_ID_RxCommonQueryVolumeInformation_2,
  MSG_ID_RxCommonSetVolumeInformation_1,
  MSG_ID_RxCommonSetVolumeInformation_2,
  MSG_ID_RxCommonWrite_1 = 140,
  MSG_ID_RxCommonWrite_2,
  MSG_ID_RxCommonWrite_3,
  MSG_ID_RxCommonWrite_4,
  MSG_ID_RxCommonWrite_5,
  MSG_ID_RxCommonWrite_6 = 145,
  MSG_ID_RxCommonWrite_7,
  MSG_ID_RxLowIoWriteShellCompletion_1,
  MSG_ID_RxLowIoWriteShellCompletion_2,
  MSG_ID_RxLowIoWriteShell_1,
  MSG_ID_RxLowIoWriteShell_2 =150,
  MSG_ID_RxFinalizeNetTable_1,
  MSG_ID_RxFinalizeNetTable_2,
  MSG_ID_RxFinalizeConnection,
  MSG_ID_RxFinalizeSrvCall,
  MSG_ID_RxFinalizeNetRoot = 155,
  MSG_ID_RxFinalizeVNetRoot,
  MSG_ID_RxCreateNetFcb_1,
  MSG_ID_RxCreateNetFcb_2,
  MSG_ID_RxCreateNetFcb_3,
  MSG_ID_RxFinalizeNetFcb = 160,
  MSG_ID_RxCreateSrvOpen,
  MSG_ID_RxFinalizeSrvOpen,
  MSG_ID_RxCreateNetFobx,
  MSG_ID_RxFinalizeNetFobx_1,
  MSG_ID_RxFinalizeNetFobx_2 = 165,
  MSG_ID_RxUninitializeMidMap,
  MSG_ID_RxAcquireFcb_1,
  MSG_ID_RxAcquireFcb_2,
  MSG_ID_RxCeBindToTransport,
  MSG_ID_RxCeTearDownTransport = 170,
  MSG_ID_RxCeQueryAdapterStatus,
  MSG_ID_RxCeQueryTransportInformation,
  MSG_ID_RxCeBuildAddress,
  MSG_ID_RxCeBuildVC,
  MSG_ID_RxCeInitiateVCDisconnect = 175,
  MSG_ID_RxCeTearDownVC,
  MSG_ID_RxCeBuildConnection,
  MSG_ID_RxCeCleanupConnectCallOutContext,
  MSG_ID_RxCeCompleteConnectRequest,
  MSG_ID_RxCeBuildConnectionOverMultipleTransports_1 = 180,
  MSG_ID_RxCeBuildConnectionOverMultipleTransports_2,
  MSG_ID_RxCeTearDownConnection,
  MSG_ID_RxCeSend,
  MSG_ID_RxCeSendDatagram,
  MSG_ID_RxFindOrCreateConnections_1 = 185,
  MSG_ID_RxFindOrCreateConnections_2,
  MSG_ID_RxFinishSrvCallConstruction,
  MSG_ID_RxConstructSrvCall,
  MSG_ID_RxFindOrConstructVirtualNetRoot,
  MSG_ID_RxSpinUpWorkerThread = 190,
  MSG_ID_RxSpinUpRequestsDispatcher,
  MSG_ID_RxpWorkerThreadDispatcher,
  MSG_ID_RxWorkItemDispatcher,
  MSG_ID_RxDispatchToWorkerThread,
  MSG_ID_RxPostToWorkerThread = 195,
  MSG_ID_RxPurgeFobxFromCache,
  MSG_ID_RxPurgeFobx_1,
  MSG_ID_RxPurgeFobx_2,
  MSG_ID_RxPurgeFobx_3,
  MSG_ID_RxPurgeFobx_4 = 200,
  MSG_ID_RxPurgeRelatedFobxs_1,
  MSG_ID_RxPurgeRelatedFobxs_2,
  MSG_ID_RxPurgeAllFobxs,
  MSG_ID_RxpMarkInstanceForScavengedFinalization,
  MSG_ID_RxScavengerFinalizeEntries = 205,
  MSG_ID_RxCeBuildTransport,
  MSG_ID_RxLastChanceHandlerForChangeBufferingStateRequests_4,
  MSG_ID_RxInsertWorkQueueItem,
  MSG_ID_RxRefSrvcall,
  MSG_ID_RxRefNetRoot = 210,
  MSG_ID_RxRefVNetRoot,
  MSG_ID_RxRefFcb,
  MSG_ID_RxRefSrvOpen,
  MSG_ID_RxRefFobx,
  MSG_ID_RxDerefSrvcall = 215,
  MSG_ID_RxDerefNetRoot,
  MSG_ID_RxDerefVNetRoot,
  MSG_ID_RxDerefFcb,
  MSG_ID_RxDerefSrvOpen,
  MSG_ID_RxDerefFobx = 220,
  MSG_ID_RxTdiAsynchronousConnectCompletion,
  MSG_ID_RxPurgeRelatedFobxs_3,
  MSG_ID_RxTrackPagingIoResource_1,
  MSG_ID_RxTrackPagingIoResource_2,
  MSG_ID_RxTrackPagingIoResource_3 = 225,
  MSG_ID_RxSetSimpleInfo,
} RX_WMI_ENUM; 

            
#define WML_ID(_id)    ((MSG_ID_ ## _id) & 0xFF)
#define WML_GUID(_id)  ((MSG_ID_ ## _id) >> 8)

extern WML_CONTROL_GUID_REG Rdbss_ControlGuids[];

#endif /* __RX_RXWML_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\inc\struchdr.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    StrucHdr.h

Abstract:

    This module predefines the strucs for important data structures so that we can always talk about 'em....
    even tho they're not defined yet.

Author:

    Joe Linn     [joelinn]    8-19-94

Revision History:

--*/

#ifndef _RDBSSSTRUCHDR_
#define _RDBSSSTRUCHDR_

#define IMPORTANT_STRUCTURE(x) struct _##x; typedef struct _##x *P##x

IMPORTANT_STRUCTURE(NODE_TYPE_CODE_AND_SIZE);

IMPORTANT_STRUCTURE(RX_PREFIX_ENTRY);
IMPORTANT_STRUCTURE(RX_PREFIX_TABLE);

IMPORTANT_STRUCTURE(RX_FSD_DISPATCH_VECTOR);
IMPORTANT_STRUCTURE(RDBSS_DATA);
IMPORTANT_STRUCTURE(RDBSS_EXPORTS);
IMPORTANT_STRUCTURE(VCB);
IMPORTANT_STRUCTURE(RDBSS_DEVICE_OBJECT);
IMPORTANT_STRUCTURE(DSCB);

IMPORTANT_STRUCTURE(FILE_NAME_NODE);
IMPORTANT_STRUCTURE(REPINNED_BCBS);
IMPORTANT_STRUCTURE(RDBSS_IO_CONTEXT);
IMPORTANT_STRUCTURE(IO_RUNS);
IMPORTANT_STRUCTURE(DELETE_CONTEXT);
IMPORTANT_STRUCTURE(FLOPPY_FLUSH_CONTEXT);
IMPORTANT_STRUCTURE(CLOSE_CONTEXT);
IMPORTANT_STRUCTURE(CLEAN_AND_DIRTY_VOLUME_PACKET);


IMPORTANT_STRUCTURE(SRV_CALL);
IMPORTANT_STRUCTURE(NET_ROOT);
IMPORTANT_STRUCTURE(V_NET_ROOT);
IMPORTANT_STRUCTURE(NON_PAGED_FCB);
IMPORTANT_STRUCTURE(FCB);
IMPORTANT_STRUCTURE(SRV_OPEN);
IMPORTANT_STRUCTURE(FOBX);
IMPORTANT_STRUCTURE(RX_CONTEXT);
IMPORTANT_STRUCTURE(LOWIO_CONTEXT);

IMPORTANT_STRUCTURE(EA_RANGE);

IMPORTANT_STRUCTURE(MINIRDR_DISPATCH);
IMPORTANT_STRUCTURE(RDBSS_EXPORTS);
IMPORTANT_STRUCTURE(MRX_SRVCALL_CALLBACK_CONTEXT);
IMPORTANT_STRUCTURE(MRX_SRVCALLDOWN_STRUCTURE);
IMPORTANT_STRUCTURE(MRX_CREATENETROOT_CONTEXT);


#endif // _RDBSSSTRUCHDR_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\backpack.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    backpack.c

Abstract:

    This module contains the package for pseudo polling. When a caller
    requests the same operation and gets the same error return the rdr
    must prevent flooding the network by backing off requests. Examples
    of when this is desirable are receiving 0 bytes on consequtive reads
    and consequtive fails on a file lock.

    If the caller is flooding the network, the rdr will return the 0 bytes
    for a pipe read or lock fail to the user until NextTime is reached.
    When NextTime is reached BackOff will indicate that the network should
    be used.

Author:

    Colin Watson (colinw) 02-Jan-1991

Notes:

    Typical usage would be demonstrated by fsctrl.c on the peek request.

    1) Each time peek is called it calls RxShouldRequestBeThrottled.
        When the result is true, the wrapper returns to the caller a response
        indicating there is no data at the other end of the pipe.

        When the result is false, a request is made to the network.

    2) If the reply from the server to the peek in step 1 indicates that
    there is no data in the pipe then the wrapper calls RxInitiateOrContinueThrottling.

    3) Whenever there is data in the pipe or when this workstation may
    unblock the pipe (eg. the workstation writing to the pipe)
    RxTerminateThrottling is called.

Revision History:

    ColinWatson   [ColinW]       24-Dec-1990   Created
    Joe Linn      [JoeLinn]      10-Oct-1996   Lifted from rdr1 and massaged for rdr2

--*/

#include "precomp.h"
#pragma hdrstop


#ifdef  ALLOC_PRAGMA
//#pragma alloc_text(PAGE3FILE, RxBackOff)  spinlock
//#pragma alloc_text(PAGE3FILE, RxBackPackFailure)  spinlock
#endif


BOOLEAN
RxShouldRequestBeThrottled (
    IN PTHROTTLING_STATE pBP
    )
/*++

Routine Description:

    This routine is called each time a request is made to find out if a the
    request should be sent to the network or a standard reply should be
    returned to the caller.

Arguments:

    pBP   -  supplies back pack data for this request.

Return Value:

    TRUE when caller should not access the network.


--*/

{
    LARGE_INTEGER CurrentTime,SavedThrottlingTime;
    BOOLEAN result;


    //  If the previous request worked then we should access the network.

    if (( pBP->CurrentIncrement == 0 ) ||
        ( pBP->MaximumDelay == 0 )) {
        return FALSE;
    }

    //  If the delay has expired then access the network.

    KeQuerySystemTime(&CurrentTime);

    InterlockedIncrement(&pBP->NumberOfQueries);

    SavedThrottlingTime.QuadPart = 0;

    RxAcquireSerializationMutex();

    SavedThrottlingTime.QuadPart = pBP->NextTime.QuadPart;

    RxReleaseSerializationMutex();

    result = (CurrentTime.QuadPart < SavedThrottlingTime.QuadPart);

    RxLog(("shouldthrttle=%x (%x)\n",result,pBP));

    return(result);
}

VOID
RxInitiateOrContinueThrottling (
    IN PTHROTTLING_STATE pBP
    )
/*++

Routine Description:

    This routine is called each time a request fails.

Arguments:

    pBP   -  supplies back pack data for this request.

Return Value:

    None.

--*/

{
    LARGE_INTEGER CurrentTime,NextTime;

    KeQuerySystemTime(&CurrentTime);

    if (pBP->CurrentIncrement < pBP->MaximumDelay ) {

        //
        //  We have reached NextTime but not our maximum delay limit.
        //

        InterlockedIncrement(&pBP->CurrentIncrement);
    }

    //  NextTime = CurrentTime + (Interval * CurrentIncrement )

    NextTime.QuadPart = CurrentTime.QuadPart +
                        (pBP->Increment.QuadPart * pBP->CurrentIncrement);

    RxAcquireSerializationMutex();

    pBP->NextTime.QuadPart = NextTime.QuadPart;

    RxReleaseSerializationMutex();
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\cancel.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cancel.c

Abstract:

    This module implements the support for cancelling operations in the RDBSS driver

Author:

    Balan Sethu Raman [SethuR]    7-June-95

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The debug trace level
//

#define Dbg  (DEBUG_TRACE_CANCEL)


NTSTATUS
RxSetMinirdrCancelRoutine(
    IN  OUT PRX_CONTEXT   RxContext,
    IN      PMRX_CALLDOWN MRxCancelRoutine)
/*++

Routine Description:

    The routine sets up a  mini rdr cancel routine for an RxContext.

Arguments:

    RxContext - the context

    MRxCancelRoutine - the cancel routine

Return Value:

    None.

Notes:

--*/
{
   NTSTATUS Status;
   KIRQL   SavedIrql;

   KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

   if (!FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_CANCELLED)) {
      RxContext->MRxCancelRoutine = MRxCancelRoutine;
      Status = STATUS_SUCCESS;
   } else {
      Status = STATUS_CANCELLED;
   }

   KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

   return Status;
}

VOID
RxpCancelRoutine(
    PRX_CONTEXT pRxContext)
/*++

Routine Description:

    This routine is invoked to the underlying mini rdr cancel routine at a non
    DPC level

Arguments:

    RxContext - the context

Return Value:

    None.

Notes:

--*/
{
    PMRX_CALLDOWN MRxCancelRoutine;

    PAGED_CODE();

    MRxCancelRoutine = pRxContext->MRxCancelRoutine;

    if (MRxCancelRoutine != NULL) {
        (MRxCancelRoutine)(pRxContext);
    } else {
        if (!RxCancelOperationInOverflowQueue(pRxContext)) {

            //RxCancelBlockingOperation(pRxContext);
        }
    }

    RxLog((
        "Dec RxC %lx L %ld %lx\n",
        pRxContext,__LINE__,pRxContext->ReferenceCount));
    RxWmiLog(LOG,
             RxpCancelRoutine,
             LOGPTR(pRxContext)
             LOGULONG(pRxContext->ReferenceCount));

    RxDereferenceAndDeleteRxContext(pRxContext);
}

VOID
RxCancelRoutine(
      PDEVICE_OBJECT    pDeviceObject,
      PIRP              pIrp)
/*++

Routine Description:

    The cancel routine for RDBSS

Arguments:

    pDeviceObject - the device object

    pIrp          - the IRP to be cancelled

Return Value:

    None.

Notes:

    Any request can be in one of three states in RDBSS ---

    1) the request is being processed.

    2) the request is waiting for the results of a calldown to a minirdr.

    3) the request is waiting on a resource.

    Any request that has been accepted by RDBSS ( the corresponding RxContext has been
    created and the cancel routine has been set ) is a valid target for cancel. The RDBSS
    driver does not make any effort to cancel requests that are in state (1) as described
    above.

    The cancelling action is invoked on those requests which are either in state (2),
    state(3) or when it is about to transition to/from either of these states.

    In order to expedite cancelling a similar strategy needs to be in place for the mini
    redirectors. This is provided by enabling the mini redirectors to register a cancel routine
    and rreserving fields in the RxContext for the mini redirectors to store the state information.

    As part of the RDBSS cancel routine the following steps will be taken .....

    1) Locate the RxContext corresponding to the given IRP.

    2) If the RxContext is waiting for a minirdr invoke the appropriate cancel routine.

    Note that the request is not immediately completed in all cases. This implies that there
    will be latencies in cancelling a request. The goal is to minimise the latency rather
    than completely eliminate them.

--*/
{
    KIRQL         SavedIrql;
    PRX_CONTEXT   pRxContext;
    PLIST_ENTRY   pListEntry;

    // Locate the context corresponding to the given Irp.
    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

    pListEntry = RxActiveContexts.Flink;

    while (pListEntry != &RxActiveContexts) {
        pRxContext = CONTAINING_RECORD(pListEntry,RX_CONTEXT,ContextListEntry);

        if (pRxContext->CurrentIrp == pIrp) {
            break;
        } else {
            pListEntry = pListEntry->Flink;
        }
    }

    if ((pListEntry != &RxActiveContexts) &&
        !FlagOn(pRxContext->Flags,RX_CONTEXT_FLAG_CANCELLED)) {
        SetFlag( pRxContext->Flags, RX_CONTEXT_FLAG_CANCELLED );
        InterlockedIncrement(&pRxContext->ReferenceCount);
    } else {
        pRxContext       = NULL;
    }

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

    IoReleaseCancelSpinLock(pIrp->CancelIrql);

    if (pRxContext != NULL) {
        if (!RxShouldPostCompletion()) {
            RxpCancelRoutine(pRxContext);
        } else {
            RxDispatchToWorkerThread(
                RxFileSystemDeviceObject,
                CriticalWorkQueue,
                RxpCancelRoutine,
                pRxContext);
        }
    }
}

NTSTATUS
RxCancelNotifyChangeDirectoryRequestsForVNetRoot(
    PV_NET_ROOT pVNetRoot,
    BOOLEAN ForceFilesClosed
    
    )
/*++

Routine Description:

    This routine cancels all the outstanding requests for a given instance of V_NET_ROOT. The
    V_NET_ROOT's are created/deleted are independent of the files that are opened/manipulated
    in them. Therefore it is imperative that when a delete operation is attempted
    all the outstanding requests are cancelled.

Arguments:

    pVNetRoot - the V_NET_ROOT instance about to be deleted
    
    ForceFilesClosed - if true force close, otherwise fai if opens exist

Return Value:

    None.

Notes:

--*/
{
    KIRQL         SavedIrql;
    PRX_CONTEXT   pRxContext;
    PLIST_ENTRY   pListEntry;
    LIST_ENTRY    CancelledContexts;
    PMRX_CALLDOWN MRxCancelRoutine;
    NTSTATUS      Status = STATUS_SUCCESS;
        
    InitializeListHead(&CancelledContexts);

    // Locate the context corresponding to the given Irp.
    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

    pListEntry = RxActiveContexts.Flink;

    while (pListEntry != &RxActiveContexts) {
        pRxContext = CONTAINING_RECORD(pListEntry,RX_CONTEXT,ContextListEntry);
        pListEntry = pListEntry->Flink;

        if ((pRxContext->MajorFunction == IRP_MJ_DIRECTORY_CONTROL) &&
            (pRxContext->MinorFunction == IRP_MN_NOTIFY_CHANGE_DIRECTORY) &&
            (pRxContext->pFcb != NULL) &&
            (pRxContext->NotifyChangeDirectory.pVNetRoot == (PMRX_V_NET_ROOT)pVNetRoot) &&
            (pRxContext->MRxCancelRoutine != NULL)) {
            
            if (!ForceFilesClosed)
            {
                Status = STATUS_FILES_OPEN;
                break;
            }
            
            SetFlag( pRxContext->Flags, RX_CONTEXT_FLAG_CANCELLED );
            RemoveEntryList(&pRxContext->ContextListEntry);
            InsertTailList(&CancelledContexts,&pRxContext->ContextListEntry);
            InterlockedIncrement(&pRxContext->ReferenceCount);
        }
    }

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

    if (Status == STATUS_SUCCESS)
    {
        while (!IsListEmpty(&CancelledContexts)) {
            pListEntry = RemoveHeadList(&CancelledContexts);

            InitializeListHead(pListEntry);
            pRxContext = CONTAINING_RECORD(pListEntry,RX_CONTEXT,ContextListEntry);

            //check to see if this guy is already completed..........if so, don't call down.
            if (pRxContext->CurrentIrp != NULL) {
                MRxCancelRoutine = pRxContext->MRxCancelRoutine;
                pRxContext->MRxCancelRoutine = NULL;

                ASSERT(MRxCancelRoutine != NULL);

                RxLog(("CCtx %lx CRtn %lx\n",pRxContext,MRxCancelRoutine));
                RxWmiLog(LOG,
                         RxCancelNotifyChangeDirectoryRequestsForVNetRoot,
                         LOGPTR(pRxContext)
                         LOGPTR(MRxCancelRoutine));

                (MRxCancelRoutine)(pRxContext);
            }

            RxDereferenceAndDeleteRxContext(pRxContext);
        }
    }
    return Status;
}

VOID
RxCancelNotifyChangeDirectoryRequestsForFobx(
    PFOBX pFobx)
/*++

Routine Description:

    This routine cancels all the outstanding requests for a given FileObject This
    handles the case when a directory handle is closed while it has outstanding
    change notify requests pending.

Arguments:

    pFobx - the FOBX instance about to be closed

Return Value:

    None.

Notes:

--*/
{
    KIRQL         SavedIrql;
    PRX_CONTEXT   pRxContext;
    PLIST_ENTRY   pListEntry;
    LIST_ENTRY    CancelledContexts;
    PMRX_CALLDOWN MRxCancelRoutine;

    InitializeListHead(&CancelledContexts);

    // Locate the context corresponding to the given Irp.
    KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );

    pListEntry = RxActiveContexts.Flink;

    while (pListEntry != &RxActiveContexts) {
        pRxContext = CONTAINING_RECORD(pListEntry,RX_CONTEXT,ContextListEntry);
        pListEntry = pListEntry->Flink;

        if ((pRxContext->MajorFunction == IRP_MJ_DIRECTORY_CONTROL) &&
            (pRxContext->MinorFunction == IRP_MN_NOTIFY_CHANGE_DIRECTORY) &&
            (pRxContext->pFobx == (PMRX_FOBX)pFobx) &&
            (pRxContext->MRxCancelRoutine != NULL)) {

            SetFlag( pRxContext->Flags, RX_CONTEXT_FLAG_CANCELLED );
            RemoveEntryList(&pRxContext->ContextListEntry);
            InsertTailList(&CancelledContexts,&pRxContext->ContextListEntry);
            InterlockedIncrement(&pRxContext->ReferenceCount);
        }
    }

    KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

    while (!IsListEmpty(&CancelledContexts)) {
        pListEntry = RemoveHeadList(&CancelledContexts);

        InitializeListHead(pListEntry);
        pRxContext = CONTAINING_RECORD(pListEntry,RX_CONTEXT,ContextListEntry);

        // check to see if this IRP is already completed..........if so,
        // don't call down.

        if (pRxContext->CurrentIrp != NULL) {
            MRxCancelRoutine = pRxContext->MRxCancelRoutine;
            pRxContext->MRxCancelRoutine = NULL;

            ASSERT(MRxCancelRoutine != NULL);

            RxLog(("CCtx %lx CRtn %lx\n",pRxContext,MRxCancelRoutine));
            RxWmiLog(LOG,
                     RxCancelNotifyChangeDirectoryRequestsForFobx,
                     LOGPTR(pRxContext)
                     LOGPTR(MRxCancelRoutine));

            (MRxCancelRoutine)(pRxContext);
        }

        RxDereferenceAndDeleteRxContext(pRxContext);
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\cachesup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    cache.c

Abstract:

    This module implements the cache management routines for the Rx
    FSD and FSP, by calling the Common Cache Manager.

Author:

    JoeLinn    Created.



Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_CACHESUP)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CACHESUP)


BOOLEAN
RxLockEnumerator (
    IN OUT struct _MRX_SRV_OPEN_ * SrvOpen,
    IN OUT PVOID *ContinuationHandle,
       OUT PLARGE_INTEGER FileOffset,
       OUT PLARGE_INTEGER LockRange,
       OUT PBOOLEAN IsLockExclusive
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCompleteMdl)
//#pzragma alloc_text(PAGE, RxZeroData)
#pragma alloc_text(PAGE, RxSyncUninitializeCacheMap)
#pragma alloc_text(PAGE, RxLockEnumerator)
#endif

// we can't use the Io system exported form of this because he does it on a file object. during a state
// change, we don't know which fileobject it applies to (altho, i suppose we could walk the list and
// find out). so we need to apply this to the fcb instead.
#define RxIsFcbOpenedExclusively(FCB) ( ((FCB)->ShareAccess.SharedRead \
                                            + (FCB)->ShareAccess.SharedWrite \
                                            + (FCB)->ShareAccess.SharedDelete) == 0 )

NTSTATUS
RxCompleteMdl (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine performs the function of completing Mdl read and write
    requests.  It should be called only from RxFsdRead and RxFsdWrite.

Arguments:

    RxContext  - the Rx Context

Return Value:

    RXSTATUS - Will always be RxStatus(PENDING) or STATUS_SUCCESS.

--*/

{
    RxCaptureParamBlock;
    RxCaptureFileObject;
    RxCaptureRequestPacket;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCompleteMdl\n", 0 ));
    RxDbgTrace( 0, Dbg, ("RxContext = %08lx\n", RxContext ));
    RxDbgTrace( 0, Dbg, ("Irp        = %08lx\n", capReqPacket ));

    switch( RxContext->MajorFunction ) {
    case IRP_MJ_READ:

        CcMdlReadComplete( capFileObject, capReqPacket->MdlAddress );
        break;

    case IRP_MJ_WRITE:

        ASSERT( FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT ));
        CcMdlWriteComplete( capFileObject, &capPARAMS->Parameters.Write.ByteOffset, capReqPacket->MdlAddress );
        capReqPacket->IoStatus.Status = STATUS_SUCCESS;
        break;

    default:

        RxDbgTrace( 0, (DEBUG_TRACE_ERROR), ("Illegal Mdl Complete.\n", 0));
        RxBugCheck( RxContext->MajorFunction, 0, 0 );
    }

    //
    // Mdl is now deallocated.
    //

    capReqPacket->MdlAddress = NULL;

    //
    // Complete the request and exit right away.
    //

    RxCompleteRequest( RxContext, STATUS_SUCCESS );

    RxDbgTrace(-1, Dbg, ("RxCompleteMdl -> RxStatus(SUCCESS\n)", 0 ));

    return STATUS_SUCCESS;
}

VOID
RxSyncUninitializeCacheMap (
    IN PRX_CONTEXT RxContext,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    The routine performs a CcUnitializeCacheMap to LargeZero synchronously.  That
    is it waits on the Cc event.  This call is useful when we want to be certain
    when a close will actually some in.

Return Value:

    None.

--*/

{
    CACHE_UNINITIALIZE_EVENT UninitializeCompleteEvent;
    NTSTATUS WaitStatus;

    PAGED_CODE();

    KeInitializeEvent( &UninitializeCompleteEvent.Event,
                       SynchronizationEvent,
                       FALSE);

    CcUninitializeCacheMap( FileObject,
                            &RxLargeZero,
                            &UninitializeCompleteEvent );

    //
    //  Now wait for the cache manager to finish purging the file.
    //  This will garentee that Mm gets the purge before we
    //  delete the Vcb.
    //

    WaitStatus = KeWaitForSingleObject( &UninitializeCompleteEvent.Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

    ASSERT (NT_SUCCESS(WaitStatus));
}


BOOLEAN
RxLockEnumerator (
    IN OUT struct _MRX_SRV_OPEN_ * SrvOpen,
    IN OUT PVOID *ContinuationHandle,
       OUT PLARGE_INTEGER FileOffset,
       OUT PLARGE_INTEGER LockRange,
       OUT PBOOLEAN IsLockExclusive
    )
/*++

Routine Description:

    This routine is called from a minirdr to enumerate the filelocks on an FCB; it gets
    one lock on each call. currently, we just pass thru to the fsrtl routine which is very funky
    because it keeps the enumeration state internally; as a result, only one enumeration can be in progress
    at any time. we can change over to something better if it's ever required.


Arguments:

    SrvOpen - a srvopen on the fcb to be enumerated.

    ContinuationHandle - a handle passed back and forth representing the state of the enumeration.
                         if a NULL is passed in, then we are to start at the beginning.

    FileOffset,LockRange,IsLockExclusive - the description of the returned lock

Return Value:

    a BOOLEAN. FALSE means you've reached the end of the list; TRUE means the returned lock data is valid

--*/
{
    PFILE_LOCK_INFO p;
    ULONG LockNumber;
    PFCB Fcb = (PFCB)(SrvOpen->pFcb);

    PAGED_CODE();

    RxDbgTrace(0,Dbg,("FCB (%lx) LOCK Enumeration Buffering Flags(%lx)\n",Fcb,Fcb->FcbState));
    if (!FlagOn(Fcb->FcbState,FCB_STATE_LOCK_BUFFERING_ENABLED)) {
       return FALSE;
    }

    LockNumber = PtrToUlong(*ContinuationHandle);
    p = FsRtlGetNextFileLock( &Fcb->Specific.Fcb.FileLock, (BOOLEAN)(LockNumber==0) );
    LockNumber++;
    if (p==NULL) {
        return(FALSE);
    }
    RxDbgTrace(0, Dbg, ("Rxlockenum %08lx\n", LockNumber ));
    *FileOffset = p->StartingByte;
    *LockRange = p->Length;
    *IsLockExclusive = p->ExclusiveLock;
    *ContinuationHandle = LongToPtr(LockNumber);
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\cleanup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Cleanup.c

Abstract:

    This module implements the File Cleanup routine for Rx called by the
    dispatch driver.

Author:

    Joe Linn     [JoeLinn]    12-sep-94

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_CLEANUP)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLEANUP)


BOOLEAN
RxUninitializeCacheMap(
    IN OUT PRX_CONTEXT RxContext,
    IN     PFILE_OBJECT FileObject,
    IN     PLARGE_INTEGER TruncateSize
    );

#if DBG
//this is just a dbg thing
extern
BOOLEAN
RxLockEnumerator (
    IN OUT struct _MRX_SRV_OPEN_ * SrvOpen,
    IN OUT PVOID *ContinuationHandle,
       OUT PLARGE_INTEGER FileOffset,
       OUT PLARGE_INTEGER LockRange,
       OUT PBOOLEAN IsLockExclusive
    );

BOOLEAN
RxFakeLockEnumerator (
    IN OUT struct _SRV_OPEN * SrvOpen,
    IN OUT PVOID *ContinuationHandle,
       OUT PLARGE_INTEGER FileOffset,
       OUT PLARGE_INTEGER LockRange,
       OUT PBOOLEAN IsLockExclusive
    );

VOID
RxDumpSerializationQueue(
    PLIST_ENTRY SQ,
    PSZ         TagText1,
    PSZ         TagText2
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxDumpSerializationQueue)
#endif

#endif //if DBG

VOID
RxCleanupPipeQueues (
    IN PRX_CONTEXT RxContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonCleanup)
#pragma alloc_text(PAGE, RxAdjustFileTimesAndSize)
#pragma alloc_text(PAGE, RxCleanupPipeQueues)
#pragma alloc_text(PAGE, RxUninitializeCacheMap)
#endif



NTSTATUS
RxCommonCleanup ( RXCOMMON_SIGNATURE )

/*++

Routine Description:

    This is the common routine for cleanup of a file/directory called by
    both the fsd and fsp threads.

    Cleanup is invoked whenever the last handle to a file object is
    closed.  This is different than the Close operation which is invoked
    when the last reference to a file object is deleted.

    The function of cleanup is to essentially "cleanup" the
    file/directory after a user is done with it.  The Fcb/Dcb remains
    around (because MM still has the file object referenced) but is now
    available for another user to open (i.e., as far as the user is
    concerned the file object is now closed).  See close for a more complete
    description of what close does.

    Please see the discussion in openclos.txt.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    NODE_TYPE_CODE TypeOfOpen  = NodeType(capFcb);
    NET_ROOT_TYPE  NetRootType;
    PNET_ROOT      NetRoot;

    PSHARE_ACCESS ShareAccess = NULL;

    PLARGE_INTEGER TruncateSize = NULL;
    LARGE_INTEGER  LocalTruncateSize;

    BOOLEAN UninitializeCacheMap = FALSE;
    BOOLEAN LastUncleanOnGoodFcb = FALSE;
    BOOLEAN NeedPurge            = FALSE;
    BOOLEAN NeedDelete           = FALSE;

    BOOLEAN AcquiredFcb          = FALSE;
    BOOLEAN AcquiredTableLock    = FALSE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonCleanup IrpC/Fobx/Fcb/FileObj = %08lx %08lx %08lx %08lx\n",
                               RxContext,capFobx,capFcb,capFileObject));
    RxLog(("CommonCleanup %lx %lx %lx\n",RxContext,capFobx,capFcb));

    // If this cleanup is for the case of directories opened for renames etc.,
    // where there is no file object cleanup succeeds immediately.
    if (!capFobx) {
        if (capFcb->UncleanCount > 0) {
           InterlockedDecrement(&capFcb->UncleanCount);
        }
        //RxMarkFcbForScavengingAtCleanup(capFcb);
        RxDbgTrace(-1, Dbg, ("Cleanup nullfobx open\n", 0));
        return(STATUS_SUCCESS);
    }

    // Cleanup applies to certain types of opens. If it is not one of those
    // abort immediately.
    if ((TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE) &&
        (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_DIRECTORY) &&
        (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_UNKNOWN) &&
        (TypeOfOpen != RDBSS_NTC_SPOOLFILE)) {
       RxLog(("RxCC Invalid Open %lx %lx %lx\n",RxContext,capFobx,capFcb));
       RxBugCheck( TypeOfOpen, 0, 0 );
    }

    // Ensure that the object has not been cleaned up before. This should
    // never occur.
    ASSERT( !FlagOn( capFileObject->Flags, FO_CLEANUP_COMPLETE ));

    RxMarkFobxOnCleanup(capFobx,&NeedPurge);

    // Acquire the FCB. In most cases no further resource acquisition is required
    // to complete the cleanup operation. The only exceptions are when the file
    // was initially opened with the DELETE_ON_CLOSE option. In such cases the
    // FCB table lock of the associated NET_ROOT instance is required.

    Status = RxAcquireExclusiveFcb( RxContext, capFcb );
    if (Status != STATUS_SUCCESS) {
       RxDbgTrace(-1, Dbg, ("RxCommonCleanup Failed to acquire FCB -> %lx\n)", Status));
       return Status;
    }

    AcquiredFcb = TRUE;
    capFobx->AssociatedFileObject = NULL;

    if (FlagOn(capFcb->FcbState,FCB_STATE_ORPHANED)) {
       ASSERT( capFcb->UncleanCount );
       InterlockedDecrement(&capFcb->UncleanCount);
       if (FlagOn(capFileObject->Flags,FO_NO_INTERMEDIATE_BUFFERING)) {
           capFcb->UncachedUncleanCount--;
       }

       MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxCleanupFobx,(RxContext));
       ASSERT( capFobx->SrvOpen->UncleanFobxCount );

       capFobx->SrvOpen->UncleanFobxCount--;

       RxUninitializeCacheMap( RxContext, capFileObject, NULL );

       RxReleaseFcb(RxContext,capFcb);

       return STATUS_SUCCESS;
    }

    NetRoot     = (PNET_ROOT)capFcb->pNetRoot;
    NetRootType = capFcb->pNetRoot->Type ;

    if ( FlagOn(capFobx->Flags, FOBX_FLAG_DELETE_ON_CLOSE) ) {
        SetFlag( capFcb->FcbState, FCB_STATE_DELETE_ON_CLOSE );
    }

    RxCancelNotifyChangeDirectoryRequestsForFobx(capFobx);

    ShareAccess = &capFcb->ShareAccess;
    LastUncleanOnGoodFcb = (capFcb->UncleanCount == 1);

    if (LastUncleanOnGoodFcb && FlagOn(capFcb->FcbState, FCB_STATE_DELETE_ON_CLOSE)) {
        //  if we can't get it right way, drop the Fcb and acquire/acquire
        //  to perserve lock order. No one else can change the counts while we have
        //  the fcb lock; neither can a file become DELETE_ON_CLOSE or be opened via
        //  CommonCreate. If we are not deleting, get rid of the tablelock after we
        //  verify the count.

        if ( RxAcquireFcbTableLockExclusive(&NetRoot->FcbTable, FALSE) ) {
            // this is the fast way....hope it works
            AcquiredTableLock = TRUE;
        } else {
            // Release the FCB and reqcquire the locks in the correct order.
            // PrefixTableLock followed by the FCB.
            AcquiredFcb = FALSE;
            RxReleaseFcb( RxContext, capFcb );

            (VOID)RxAcquireFcbTableLockExclusive(&NetRoot->FcbTable, TRUE);
            AcquiredTableLock = TRUE;

            Status = RxAcquireExclusiveFcb( RxContext, capFcb );
            if (Status != STATUS_SUCCESS) {
                AcquiredTableLock = FALSE;
                RxReleaseFcbTableLock(&NetRoot->FcbTable);
                RxDbgTrace(-1, Dbg, ("RxCommonCleanup Failed to acquire FCB -> %lx\n)", Status));
                return Status;
            }
            AcquiredFcb = TRUE;
        }

        if (capFcb->UncleanCount != 1) {
            RxReleaseFcbTableLock(&NetRoot->FcbTable);
            AcquiredTableLock = FALSE;
            NeedDelete = FALSE;
        } else {
            NeedDelete = TRUE;
        }
    }

    try {
        switch (NetRootType) {
        case NET_ROOT_PIPE:
        case NET_ROOT_PRINT:
           {
               // If the file object corresponds to a pipe or spool file additional
               // cleanup operations are required. This deals with the special
               // serialization mechanism for pipes.

               RxCleanupPipeQueues(RxContext);
           }
           break;
        case NET_ROOT_DISK:
           {
              switch (TypeOfOpen) {
              case RDBSS_NTC_STORAGE_TYPE_FILE :
                 {
                    // If the file object corresponds to a disk file, assert the locks
                    // and update the associated file times and sizes.

                    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

                    LowIoContext->Flags |= LOWIO_CONTEXT_FLAG_SAVEUNLOCKS;

                    FsRtlFastUnlockAll(
                              &capFcb->Specific.Fcb.FileLock,
                              capFileObject,
                              IoGetRequestorProcess( capReqPacket ),
                              RxContext );

                    if (LowIoContext->ParamsFor.Locks.LockList != NULL) {
                        RxDbgTrace(0, Dbg, ("--->before init, locklist=%08lx\n", LowIoContext->ParamsFor.Locks.LockList));
                        RxInitializeLowIoContext(LowIoContext,LOWIO_OP_UNLOCK_MULTIPLE);
                        LowIoContext->ParamsFor.Locks.Flags = 0;     //no flags
                        Status = RxLowIoLockControlShell(RxContext);
                    }

                    RxAdjustFileTimesAndSize(RXCOMMON_ARGUMENTS);

                    // If the file object corresponds to a disk file/directory and this
                    // is the last cleanup call for the FCB additional processing is required.
                    if (LastUncleanOnGoodFcb) {
                       try {
                           // If the file object was marked DELETE_ON_CLOSE set the file size to
                           // zero ( synchronizing with the paging resource)
                           if (NeedDelete) {
                              RxAcquirePagingIoResource(capFcb,RxContext);

                              capFcb->Header.FileSize.QuadPart = 0;

                              if (TypeOfOpen == RDBSS_NTC_STORAGE_TYPE_FILE) {
                                 capFcb->Header.ValidDataLength.QuadPart = 0;
                              }

                              RxReleasePagingIoResource(capFcb,RxContext);
                           } else {
                              // If the file object was not marked for deletion and it is not
                              // a paging file ensure that the portion between the valid data
                              // length and the file size is zero extended.
                              if (!FlagOn(capFcb->FcbState, FCB_STATE_PAGING_FILE) &&
                                  (capFcb->Header.ValidDataLength.QuadPart <
                                   capFcb->Header.FileSize.QuadPart)) {
                                  RxDbgTrace(0, Dbg, ("---------->zeroextend!!!!!!!\n", 0));
                                  MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxZeroExtend,(RxContext));

                                  capFcb->Header.ValidDataLength.QuadPart =
                                                              capFcb->Header.FileSize.QuadPart;
                              }
                           }

                           // If the file object was marked for truncation capture the
                           // sizes for uninitializing the cache maps subsequently.
                           if (FlagOn(capFcb->FcbState, FCB_STATE_TRUNCATE_ON_CLOSE)) {

                               RxDbgTrace(0, Dbg, ("truncate file allocation\n", 0));

                               MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxTruncate,(RxContext));

                               //  Setup to truncate the Cache Map because
                               //  this is the only way we have of trashing the
                               //  truncated pages.

                               LocalTruncateSize = capFcb->Header.FileSize;
                               TruncateSize = &LocalTruncateSize;

                               //  Mark the Fcb as having now been truncated, just
                               //  in case we have to reprocess this later.

                               capFcb->FcbState &= ~FCB_STATE_TRUNCATE_ON_CLOSE;
                           }

                       } except ( CATCH_EXPECTED_EXCEPTIONS ) {

                           DbgPrint("!!! Handling Exceptions\n");
                           NOTHING;
                       }
                    }

                    // Purging can be done now if this FCB does not support collapsed opens
                    if (!NeedPurge) {
                        NeedPurge = (LastUncleanOnGoodFcb &&
                                     (NeedDelete ||
                                      !FlagOn(capFcb->FcbState,FCB_STATE_COLLAPSING_ENABLED)));
                    } else {
                        if (!LastUncleanOnGoodFcb) {
                            NeedPurge = FALSE;
                        }
                    }

                    UninitializeCacheMap = TRUE;
                 }
                 break;
              case RDBSS_NTC_STORAGE_TYPE_DIRECTORY :
              case RDBSS_NTC_STORAGE_TYPE_UNKNOWN :
              default:
                 break;
              }
           }
           break;
        default:
           break;
        }

        //  We've just finished everything associated with an unclean
        //  fcb so now decrement the unclean count before releasing
        //  the resource.

        ASSERT( capFcb->UncleanCount );
        InterlockedDecrement(&capFcb->UncleanCount);

        if (FlagOn(capFileObject->Flags,FO_NO_INTERMEDIATE_BUFFERING)) {
            capFcb->UncachedUncleanCount--;
        }

        MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxCleanupFobx,(RxContext));

        ASSERT( capFobx->SrvOpen->UncleanFobxCount );
        capFobx->SrvOpen->UncleanFobxCount--;

        //  If this was the last cached open, and there are open
        //  non-cached handles, attempt a flush and purge operation
        //  to avoid cache coherency overhead from these non-cached
        //  handles later.  We ignore any I/O errors from the flush.

        if (capFcb->NonPaged->SectionObjectPointers.DataSectionObject != NULL) {
            RxLog(("Cleanup Flush %lx\n",RxContext));
            RxFlushFcbInSystemCache(capFcb, TRUE);
        }

        if (!FlagOn( capFileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ) &&
            (capFcb->UncachedUncleanCount != 0) &&
            (capFcb->UncachedUncleanCount == capFcb->UncleanCount) &&
            (capFcb->NonPaged->SectionObjectPointers.DataSectionObject != NULL)) {

            RxLog(("Cleanup Flush 1111 %lx\n",RxContext));
            RxPurgeFcbInSystemCache(
                capFcb,
                NULL,
                0,
                FALSE,
                TRUE );
        }

        // do we need a flush?
        if (!NeedDelete && NeedPurge) {
            RxDbgTrace(0, Dbg, ("CleanupPurge:CCFlush\n", 0));

            RxLog(("Cleanup Flush 2222 %lx\n",RxContext));
            RxFlushFcbInSystemCache( capFcb, TRUE );
        }

        // cleanup the cache map to get rid of pages that are no longer part
        // of the file. amazingly, this works even if we didn't init the Cachemap!!!!!

        if (UninitializeCacheMap) {

            RxLog(("Cleanup Flush 3333 %lx\n",RxContext));
            RxUninitializeCacheMap( RxContext, capFileObject, TruncateSize );
        }

        //  finish up a delete...we have to purge because MM is holding the file open....
        //  just for the record, NeedPurge is set for files and clear for directories......

        if (NeedDelete || NeedPurge) {

            RxLog(("Cleanup Flush 4444 %lx\n",RxContext));

            RxPurgeFcbInSystemCache(
                capFcb,
                NULL,
                0,
                FALSE,
                !NeedDelete );

            if (NeedDelete) {
                RxRemoveNameNetFcb( capFcb );
                RxReleaseFcbTableLock(&NetRoot->FcbTable);
                AcquiredTableLock = FALSE;
            }
        }

        //  The Close Call and the Cleanup Call may be far apart. The share access
        //  must be cleaned up if the file was mapped through this File Object.
        if ((ShareAccess != NULL) &&
            (NetRootType == NET_ROOT_DISK)) {
            ASSERT (NetRootType == NET_ROOT_DISK);
            RxRemoveShareAccess( capFileObject, ShareAccess, "Cleanup the Share access", "ClnUpShr" );
        }

        if (TypeOfOpen == RDBSS_NTC_STORAGE_TYPE_FILE) {
            //  Coordinate the cleanup operation with the oplock state.
            //  Cleanup operations can always cleanup immediately.

            FsRtlCheckOplock( &capFcb->Specific.Fcb.Oplock, capReqPacket,
                              RxContext, NULL, NULL );

            //capFcb->Header.IsFastIoPossible = RxIsFastIoPossible( capFcb );
        }

        if (AcquiredFcb) {
            AcquiredFcb = FALSE;
            RxReleaseFcb( RxContext, capFcb );
        }

        //  A local filesystem would do this..........
        //  If the NET_ROOT is on a removeable media, flush the volume.  We do
        //  this in lieu of write through for removeable media for
        //  performance considerations.  That is, data is guaranteed
        //  to be out when NtCloseFile returns.
        //  The file needs to  be flushed

        // The cleanup for this file object has been successfully completed at
        // this point.

        SetFlag( capFileObject->Flags, FO_CLEANUP_COMPLETE );
        Status = STATUS_SUCCESS;

    } finally {

        DebugUnwind( RxCommonCleanup );

        if (AcquiredFcb) {
           RxReleaseFcb( RxContext, capFcb );
        }

        if (AcquiredTableLock) {
            RxReleaseFcbTableLock(&NetRoot->FcbTable);
        }

        IF_DEBUG {
           if (AbnormalTermination()) {
              RxDbgTrace(-1, Dbg, ("RxCommonCleanup -> Abnormal Termination %08lx\n", Status));
           } else {
              RxDbgTrace(-1, Dbg, ("RxCommonCleanup -> %08lx\n", Status));
           }
        }
    }

    return Status;
}

VOID
RxAdjustFileTimesAndSize  ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This routine is used to adjust the times and the filesize on a cleanup
    or a flush.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    BOOLEAN UpdateFileSize;
    BOOLEAN UpdateLastWriteTime;
    BOOLEAN UpdateLastAccessTime;
    BOOLEAN UpdateLastChangeTime;

    LARGE_INTEGER CurrentTime;

    PAGED_CODE();

    //if there's no cachemap then we don't have to send because the guy is
    //tracking everything on the other end.
    //LOCAL.MINI for a localminiFS we would still have to do this; so the answer to this question
    // (whether to do it or not) should be exposed in the fcb/fobx
    if ( capFileObject->PrivateCacheMap == NULL ) return;

    KeQuerySystemTime( &CurrentTime );

    //
    //  Note that we HAVE to use BooleanFlagOn() here because
    //  FO_FILE_SIZE_CHANGED > 0x80 (i.e., not in the first byte).
    //

    UpdateFileSize = BooleanFlagOn(capFileObject->Flags, FO_FILE_SIZE_CHANGED);

    UpdateLastWriteTime = FlagOn(capFileObject->Flags, FO_FILE_MODIFIED) &&
                          !FlagOn(capFobx->Flags, FOBX_FLAG_USER_SET_LAST_WRITE);

    UpdateLastChangeTime = FlagOn(capFileObject->Flags, FO_FILE_MODIFIED) &&
                          !FlagOn(capFobx->Flags, FOBX_FLAG_USER_SET_LAST_CHANGE);

    UpdateLastAccessTime =
        (UpdateLastWriteTime ||
         (FlagOn(capFileObject->Flags, FO_FILE_FAST_IO_READ) &&
          !FlagOn(capFobx->Flags, FOBX_FLAG_USER_SET_LAST_ACCESS)));

    if (UpdateFileSize      ||
        UpdateLastWriteTime ||
        UpdateLastChangeTime ||
        UpdateLastAccessTime ) {

        ULONG    NotifyFilter = 0;
        BOOLEAN  DoTheTimeUpdate = FALSE;

        FILE_BASIC_INFORMATION       BasicInformation;
        FILE_END_OF_FILE_INFORMATION EofInformation;

        RxDbgTrace(0, Dbg, ("Update Time and/or file size on File\n", 0));
        RtlZeroMemory(&BasicInformation,sizeof(BasicInformation));

        try {     //for finally
            try {   //for exceptions

                if (UpdateLastWriteTime) {

                    //
                    //  Update its time of last write

                    DoTheTimeUpdate = TRUE;
                    capFcb->LastWriteTime = CurrentTime;
                    BasicInformation.LastWriteTime = CurrentTime;

                    NotifyFilter |= FILE_NOTIFY_CHANGE_ATTRIBUTES
                                    | FILE_NOTIFY_CHANGE_LAST_WRITE;

                }

                if (UpdateLastChangeTime) {

                    //
                    //  Update its time of last write

                    DoTheTimeUpdate = TRUE;
                    BasicInformation.ChangeTime = capFcb->LastChangeTime;

                    //NotifyFilter |= FILE_NOTIFY_CHANGE_ATTRIBUTES
                    //                | FILE_NOTIFY_CHANGE_LAST_CHANGE;

                }

                if (UpdateLastAccessTime) {

                    DoTheTimeUpdate = TRUE;
                    capFcb->LastAccessTime = CurrentTime;
                    BasicInformation.LastAccessTime = CurrentTime;

                    NotifyFilter |= FILE_NOTIFY_CHANGE_LAST_ACCESS;

                }

                if (DoTheTimeUpdate) {
                    NTSTATUS Status;  //if it doesn't work.....sigh
                    RxContext->Info.FileInformationClass = (FileBasicInformation);
                    RxContext->Info.Buffer = &BasicInformation;
                    RxContext->Info.Length = sizeof(BasicInformation);
                    MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxSetFileInfoAtCleanup,(RxContext));
                }

                if (UpdateFileSize) {
                    NTSTATUS Status;  //if it doesn't work.....sigh
                    EofInformation.EndOfFile = capFcb->Header.FileSize;
                    RxContext->Info.FileInformationClass = (FileEndOfFileInformation);
                    RxContext->Info.Buffer = &EofInformation;
                    RxContext->Info.Length = sizeof(EofInformation);
                    MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxSetFileInfoAtCleanup,(RxContext));
                    NotifyFilter |= FILE_NOTIFY_CHANGE_SIZE;
                }

                //RxNotifyReportChange( RxContext, Vcb, Fcb,
                //                       NotifyFilter,
                //                       FILE_ACTION_MODIFIED );

                //MINIRDR_CALL(Status,capFcb->MRxDispatch,MRxSetTimeAndSize,(RxContext));
            } except( CATCH_EXPECTED_EXCEPTIONS ) {
                NOTHING;
            }
        } finally {
            NOTHING;
        }
    }
}


#define RxMoveAllButFirstToAnotherList(List1,List2) { \
        PLIST_ENTRY FrontListEntry = (List1)->Flink;       \
        if (FrontListEntry->Flink == (List1)) {            \
            (List2)->Flink = (List2)->Blink = (List2);     \
        } else {                                           \
            (List2)->Blink = (List1)->Blink;               \
            (List2)->Blink->Flink = (List2);               \
            (List1)->Blink = FrontListEntry;               \
            (List2)->Flink = FrontListEntry->Flink;        \
            FrontListEntry->Flink = (List1);               \
            (List2)->Flink->Blink = (List2);               \
        }                                                  \
}
#if DBG
PSZ RxDSQTagText[FOBX_NUMBER_OF_SERIALIZATION_QUEUES] = {"read","write"};
VOID
RxDumpSerializationQueue(
    PLIST_ENTRY SQ,
    PSZ         TagText1,
    PSZ         TagText2
    )
{
    PLIST_ENTRY ListEntry;
    PAGED_CODE();

    if (IsListEmpty(SQ)) {
        RxDbgTrace(0, Dbg, ("RxDumpSerializationQueue %s%s is empty\n", TagText1, TagText2));
        return;
    }

    RxDbgTrace(0, Dbg, ("RxDumpSerializationQueue %s%s:\n", TagText1, TagText2));
    for (ListEntry=SQ->Flink;
         ListEntry!=SQ;
         ListEntry=ListEntry->Flink) {
        //print out the contexts and the major op for validation
        PRX_CONTEXT RxContext = CONTAINING_RECORD( ListEntry,RX_CONTEXT,RxContextSerializationQLinks);
        RxDbgTrace(0, Dbg, ("        rxc=%08lx op=%02lx\n", RxContext, RxContext->MajorFunction));
    }
}
#else
#define RxDumpSerializationQueue(___r,___t12,___t13) {NOTHING;}
#endif

VOID
RxCleanupPipeQueues (
    IN PRX_CONTEXT RxContext
    )
{
    RxCaptureFcb; RxCaptureFobx;
    LIST_ENTRY SecondaryBlockedQs[FOBX_NUMBER_OF_SERIALIZATION_QUEUES];
    PLIST_ENTRY PrimaryBlockedQs = &capFobx->Specific.NamedPipe.ReadSerializationQueue;
    ULONG i;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCleanupPipeQueues \n"));

    //for pipes there are two sources of unhappiness...........
    //first, we have to get rid of any blocked operations.
    //second, if there are blocking operations that have already gone by then we have to send the
    //        close smb early so that the server will, in turn, complete the outstanding
    ExAcquireFastMutexUnsafe(&RxContextPerFileSerializationMutex);

    for (i=0;i<FOBX_NUMBER_OF_SERIALIZATION_QUEUES;i++) {
        RxDumpSerializationQueue(&PrimaryBlockedQs[i],RxDSQTagText[i],"Primary");
        if (!IsListEmpty(&PrimaryBlockedQs[i])) {
            RxMoveAllButFirstToAnotherList(
                   &PrimaryBlockedQs[i],
                   &SecondaryBlockedQs[i]);
            RxDumpSerializationQueue(&PrimaryBlockedQs[i],RxDSQTagText[i],"Primary");
            RxDumpSerializationQueue(&SecondaryBlockedQs[i],RxDSQTagText[i],"Secondary");
        } else {
            InitializeListHead(&SecondaryBlockedQs[i]);
        }
    }


    ExReleaseFastMutexUnsafe(&RxContextPerFileSerializationMutex);

    for (i=0;i<FOBX_NUMBER_OF_SERIALIZATION_QUEUES;i++) {
        for (;!IsListEmpty(&SecondaryBlockedQs[i]);) {
            PLIST_ENTRY FrontListEntry = (&SecondaryBlockedQs[i])->Flink;
            PRX_CONTEXT FrontRxContext = CONTAINING_RECORD( FrontListEntry,RX_CONTEXT,RxContextSerializationQLinks);
            RemoveEntryList(FrontListEntry);

            FrontRxContext->RxContextSerializationQLinks.Flink = NULL;
            FrontRxContext->RxContextSerializationQLinks.Blink = NULL;

            if (!FlagOn(FrontRxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
                RxDbgTrace(0, Dbg, ("  unblocking %08lx\n",FrontRxContext));
                RxContext->StoredStatus = STATUS_PIPE_CLOSING;
                RxSignalSynchronousWaiter(FrontRxContext);
            } else {
                RxDbgTrace(0, Dbg, ("  completing %08lx\n",FrontRxContext));
                RxCompleteAsynchronousRequest( FrontRxContext, STATUS_PIPE_CLOSING );
            }
        }
    }

    RxDbgTrace(-1, Dbg, ("RxCleanupPipeQueues exit\n"));
    return;
}


BOOLEAN
RxFakeLockEnumerator (
    IN OUT struct _SRV_OPEN * SrvOpen,
    IN OUT PVOID *ContinuationHandle,
       OUT PLARGE_INTEGER FileOffset,
       OUT PLARGE_INTEGER LockRange,
       OUT PBOOLEAN IsLockExclusive
    )
/*++

Routine Description:

    THIS ROUTINE IS A FAKE THAT IS JUST USED FOR TESTING PURPOSES!

    This routine is called from a minirdr to enumerate the filelocks on an FCB; it gets
    one lock on each call. currently, we just pass thru to the fsrtl routine which is very funky
    because it keeps the enumeration state internally; as a result, only one enumeration can be in progress
    at any time. we can change over to something better if it's ever required.


Arguments:

    SrvOpen - a srvopen on the fcb to be enumerated.

    ContinuationHandle - a handle passed back and forth representing the state of the enumeration.
                         if a NULL is passed in, then we are to start at the beginning.

    FileOffset,LockRange,IsLockExclusive - the description of the returned lock

Return Value:

    a BOOLEAN. FALSE means you've reached the end of the list; TRUE means the returned lock data is valid

--*/
{
    ULONG LockNumber;

    LockNumber = PtrToUlong(*ContinuationHandle);
    if (LockNumber>=12) {
        return(FALSE);
    }
    LockNumber++;
    RxDbgTrace(0, Dbg, ("Rxlockenum %08lx\n", LockNumber ));
    FileOffset->QuadPart = LockNumber;
    LockRange->QuadPart = 1;
    *IsLockExclusive = (LockNumber&0x4)==0;
    *ContinuationHandle = LongToPtr(LockNumber);
    return TRUE;
}

BOOLEAN
RxUninitializeCacheMap(
    IN OUT PRX_CONTEXT RxContext,
    IN     PFILE_OBJECT FileObject,
    IN     PLARGE_INTEGER TruncateSize
    )
/*++

Routine Description:

    This routine is a wrapper for CcUninitializeCacheMap.

Arguments:

    IN PFILE_OBJECT FileObject - Supplies the file object for the file to purge.
    IN PLARGE_INTEGER TruncateSize - Specifies the new size for the file.


Return Value:

    BOOLEAN - TRUE if file has been immediately purged, FALSE if we had to wait.

Note:
    The file must be locked exclusively before calling this routine.


--*/
{
    BOOLEAN CacheReturnValue;
    CACHE_UNINITIALIZE_EVENT PurgeCompleteEvent;
    PFCB Fcb = FileObject->FsContext;
    NTSTATUS    Status;

    PAGED_CODE();

    ASSERT ( NodeTypeIsFcb(Fcb) );

    //
    //  Make sure that this thread owns the FCB.
    //

    ASSERT  ( RxIsFcbAcquiredExclusive ( Fcb )  );

    //
    //  Now uninitialize the cache managers own file object.  This is
    //  done basically simply to allow us to wait until the cache purge
    //  is complete.
    //

    KeInitializeEvent(&PurgeCompleteEvent.Event, SynchronizationEvent, FALSE);

    //RxLog(( "ccunini1", &Fcb->FileName, 2,
    //        (TruncateSize == NULL) ? 0xffffffff : TruncateSize->LowPart,
    //        (ULONG)&PurgeCompleteEvent ));
    CacheReturnValue = CcUninitializeCacheMap(FileObject, TruncateSize, &PurgeCompleteEvent);

    //
    //  Release the lock on the FCB that our caller applied.
    //

    RxReleaseFcb( RxContext, Fcb );

    //
    //  Now wait for the cache manager to finish purging the file.
    //

    KeWaitForSingleObject(&PurgeCompleteEvent.Event,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL);

    //
    //  Re-acquire the FCB lock once we've waited for the
    //  cache manager to finish the uninitialize.
    //

    Status = RxAcquireExclusiveFcb( RxContext, Fcb );
    ASSERT(Status == STATUS_SUCCESS);
    return(CacheReturnValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\create.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Create.c

Abstract:

    This module implements the File Create routine for Rx called by the
    dispatch driver.

    The implementation of SL_OPEN_TARGET_DIRECTORY is a bit unusual...we don't
    actually do it unless the minirdr specifically requests it.
    Instead, we just get the fcb built and then return it. The nodetype is set so
    that no operations can be done except close/cleanup. In this way, we will not
    take an extra trip to the server or a trip to an incorrect server for rename
    operations. If SL_OPEN... can be used for something other than rename, a
    minirdr that uses this facility is toast.

Author:

    Joe Linn      [JoeLinn]    8-aug-94

Revision History:

    Balan Sethu Raman [SethuR]    17-July-95

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntddmup.h>
#include <fsctlbuf.h>
#include <dfsfsctl.h>

#if 0 && defined(REMOTE_BOOT)
BOOLEAN LogAllFiles = FALSE;
BOOLEAN WatchAllFiles = FALSE;
BOOLEAN FirstWatchOnly = FALSE;
BOOLEAN IsFirstWatch = TRUE;
#endif

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)

#ifdef LOG_SHARINGCHECKS
#define RxLogForSharingCheck(x) RxLog(x)
#else
#define RxLogForSharingCheck(x)
#endif

LUID RxSecurityPrivilege = { SE_SECURITY_PRIVILEGE, 0 };

#define StorageType(co) ((co) & FILE_STORAGE_TYPE_MASK)
#define StorageFlag(co) ((co) & FILE_STORAGE_TYPE_SPECIFIED)
#define IsStorageTypeSpecified(co)  (StorageFlag(co) == FILE_STORAGE_TYPE_SPECIFIED)
#define MustBeDirectory(co) ((co) & FILE_DIRECTORY_FILE)
#define MustBeFile(co)      ((co) & FILE_NON_DIRECTORY_FILE)

//
// Where 0 represents a SessionId, the following path formats are used:
//
// "\;m:0\Server\Share" for drive based connections
//
// "\;:0\Server\Share"  for UNC based connections
//
// The SessionId is always 0 for NT 5, and a number representing a
// unique session for Hydra.
//
#define DRIVE_BASED_PATH_IDENTIFIER (L';')

// The following is used to enable tracing when a specific file name is seen.
// Tracing continues for a specified number of IRPs.
// Usage:
// Break in with debugger and set DbgTriggerNameStr to the ansi string for the
// file name to trigger on (with trailing null).
// Set DbgTriggerIrpCount to the number of IRPs to trace after the Create is
// seen on the name string.
// Set DbgTriggerState to zero and then continue.
//
#ifdef RDBSSTRACE

UNICODE_STRING DbgTriggerUStr = {0,0,NULL};
STRING DbgTriggerNameStr = {0,0,NULL};
CHAR DbgTriggerName[120] = "\\;F:\\davidor4\\nb4\\clients\\client1\\~DMTMP\\WINWORD\\~WRD0003.tmp";
#define DBG_TRIGGER_INIT 0
#define DBG_TRIGGER_LOOKING 1
#define DBG_TRIGGER_FOUND 2
ULONG DbgTriggerState = DBG_TRIGGER_FOUND;
ULONG DbgTriggerIrpCount = 130;
ULONG RxGlobalTraceIrpCount = 0;

#endif

extern BOOLEAN DisableByteRangeLockingOnReadOnlyFiles;

VOID
RxSetFullNameInFcb(
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN PUNICODE_STRING FinalName
    );

VOID
RxCopyCreateParameters (
    PRX_CONTEXT RxContext
    );

VOID
RxFreeCanonicalNameBuffer(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
RxAllocateCanonicalNameBuffer(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PUNICODE_STRING CanonicalName,
    IN     ULONG BufferSizeRequired);

NTSTATUS
RxFirstCanonicalize(
    IN OUT PRX_CONTEXT     RxContext,
    IN     PUNICODE_STRING FileName,
    IN OUT PUNICODE_STRING CanonicalName,
    OUT    PNET_ROOT_TYPE  pNetRootType
    );

NTSTATUS
RxCanonicalizeFileNameByServerSpecs(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PUNICODE_STRING RemainingName
    );

NTSTATUS
RxCanonicalizeNameAndObtainNetRoot(
    IN OUT PRX_CONTEXT     RxContext,
    IN     PUNICODE_STRING FileName,
    OUT    PUNICODE_STRING RemainingName
    );

NTSTATUS
RxFindOrCreateFcb(
    IN OUT PRX_CONTEXT RxContext,
    IN PUNICODE_STRING RemainingName
    );

VOID
RxSetupNetFileObject(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
RxSearchForCollapsibleOpen (
    IN OUT PRX_CONTEXT RxContext,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG ShareAccess
    );

NTSTATUS
RxCollapseOrCreateSrvOpen (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
RxCreateFromNetRoot(
    IN OUT PRX_CONTEXT RxContext,
    IN PUNICODE_STRING RemainingName
    );

NTSTATUS
RxCreateTreeConnect (
    RXCOMMON_SIGNATURE
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonCreate)
#pragma alloc_text(PAGE, RxAllocateCanonicalNameBuffer)
#pragma alloc_text(PAGE, RxFreeCanonicalNameBuffer)
#pragma alloc_text(PAGE, RxFirstCanonicalize)
#pragma alloc_text(PAGE, RxCanonicalizeFileNameByServerSpecs)
#pragma alloc_text(PAGE, RxCanonicalizeNameAndObtainNetRoot)
#pragma alloc_text(PAGE, RxFindOrCreateFcb)
#pragma alloc_text(PAGE, RxSearchForCollapsibleOpen)
#pragma alloc_text(PAGE, RxCollapseOrCreateSrvOpen)
#pragma alloc_text(PAGE, RxSetupNetFileObject)
#pragma alloc_text(PAGE, RxCreateFromNetRoot)
#pragma alloc_text(PAGE, RxPrefixClaim)
#pragma alloc_text(PAGE, RxCreateTreeConnect)
#pragma alloc_text(PAGE, RxCheckShareAccessPerSrvOpens)
#pragma alloc_text(PAGE, RxUpdateShareAccessPerSrvOpens)
#pragma alloc_text(PAGE, RxRemoveShareAccessPerSrvOpens)
#pragma alloc_text(PAGE, RxGetSessionId)
#endif

#if DBG
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxDumpWantedAccess)
#pragma alloc_text(PAGE, RxDumpCurrentAccess)
#pragma alloc_text(PAGE, RxCheckShareAccess)
#pragma alloc_text(PAGE, RxRemoveShareAccess)
#pragma alloc_text(PAGE, RxSetShareAccess)
#pragma alloc_text(PAGE, RxUpdateShareAccess)
#endif
#endif

INLINE VOID
RxCopyCreateParameters (
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This uses the RxContext as a base to reach out and get the values of the NT
    create parameters. The idea is to centralize this code.

    It also implements such as ideas as (a) it must be a directory if a backslash
    was stripped and (b) unbuffered is translated to write-through.

Arguments:

    RxContext - the context instance

Notes:

--*/
{
    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;

    RxDbgTrace(+1, Dbg, ("RxCopyCreateParameters\n"));

    cp->SecurityContext =  capPARAMS->Parameters.Create.SecurityContext;

    if ((cp->SecurityContext->AccessState != NULL) &&
        (cp->SecurityContext->AccessState->SecurityDescriptor != NULL)) {
        RxContext->Create.SdLength = RtlLengthSecurityDescriptor(
                                         cp->SecurityContext->AccessState->SecurityDescriptor);

        RxDbgTrace( 0, Dbg, ("->SecurityCtx/SdLength    = %08lx %08lx\n",
                                     cp->SecurityContext,
                                     RxContext->Create.SdLength));
        RxLog((" SDss %lx %lx\n", cp->SecurityContext, RxContext->Create.SdLength));
        RxWmiLog(LOG,
                 RxCopyCreateParameters_1,
                 LOGPTR(cp->SecurityContext)
                 LOGULONG(RxContext->Create.SdLength));
    }

    if (cp->SecurityContext->SecurityQos != NULL) {
        cp->ImpersonationLevel = cp->SecurityContext->SecurityQos->ImpersonationLevel;
    } else {
        cp->ImpersonationLevel =  DEFAULT_IMPERSONATION_LEVEL;
    }

    cp->DesiredAccess = cp->SecurityContext->DesiredAccess;
    cp->AllocationSize = capReqPacket->Overlay.AllocationSize;
    cp->FileAttributes = capPARAMS->Parameters.Create.FileAttributes &  FILE_ATTRIBUTE_VALID_FLAGS;
    cp->ShareAccess = capPARAMS->Parameters.Create.ShareAccess & FILE_SHARE_VALID_FLAGS;
    cp->Disposition = (((capPARAMS->Parameters.Create.Options)) >> 24) & 0x000000ff;
    cp->CreateOptions = capPARAMS->Parameters.Create.Options & FILE_VALID_OPTION_FLAGS;


    cp->DfsContext    = capFileObject->FsContext2;
    cp->DfsNameContext = capFileObject->FsContext;

    ASSERT(cp->DfsContext == NULL ||
           cp->DfsContext == UIntToPtr(DFS_OPEN_CONTEXT) ||
           cp->DfsContext == UIntToPtr(DFS_DOWNLEVEL_OPEN_CONTEXT) ||
           cp->DfsContext == UIntToPtr(DFS_CSCAGENT_NAME_CONTEXT) ||
           cp->DfsContext == UIntToPtr(DFS_USER_NAME_CONTEXT));

    ASSERT(cp->DfsNameContext == NULL ||
           ((PDFS_NAME_CONTEXT)cp->DfsNameContext)->NameContextType == DFS_OPEN_CONTEXT ||
           ((PDFS_NAME_CONTEXT)cp->DfsNameContext)->NameContextType == DFS_DOWNLEVEL_OPEN_CONTEXT ||
           ((PDFS_NAME_CONTEXT)cp->DfsNameContext)->NameContextType == DFS_CSCAGENT_NAME_CONTEXT ||
           ((PDFS_NAME_CONTEXT)cp->DfsNameContext)->NameContextType == DFS_USER_NAME_CONTEXT);

    capFileObject->FsContext2 = NULL;
    capFileObject->FsContext = NULL;

    // The FsContext field was placed as the pFcb in the RX_CONTEXT.  Clear it also
    RxContext->pFcb = NULL;

    if (FlagOn(RxContext->Create.Flags,RX_CONTEXT_CREATE_FLAG_STRIPPED_TRAILING_BACKSLASH)){
        cp->CreateOptions |= FILE_DIRECTORY_FILE;
    }

    RxContext->Create.ReturnedCreateInformation = 0;

    RxContext->Create.EaLength = capPARAMS->Parameters.Create.EaLength;
    if (RxContext->Create.EaLength) {
        RxContext->Create.EaBuffer = capReqPacket->AssociatedIrp.SystemBuffer;
        RxDbgTrace( 0, Dbg, ("->System(Ea)Buffer/EALength    = %08lx %08lx\n",
                                     capReqPacket->AssociatedIrp.SystemBuffer,
                                     capPARAMS->Parameters.Create.EaLength));
        RxLog((" EAs %lx %lx\n",
                 capReqPacket->AssociatedIrp.SystemBuffer,
                 capPARAMS->Parameters.Create.EaLength));
        RxWmiLog(LOG,
                 RxCopyCreateParameters_2,
                 LOGPTR(capReqPacket->AssociatedIrp.SystemBuffer)
                 LOGULONG(capPARAMS->Parameters.Create.EaLength));
    } else {
        RxContext->Create.EaBuffer = NULL;
    }

    RxDbgTrace(-1, Dbg, ("RxCopyNtCreateParameters\n"));
}

#if DBG
#define DEBUG_TAG(___xxx) ,(___xxx)
#else
#define DEBUG_TAG(_xxx)
#endif

VOID
RxFreeCanonicalNameBuffer(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine is called to free the canonical name buffer and reset the state.
    COULD BE INLINED!

Arguments:

    RxContext - the current workitem

Return Value:

    none

--*/
{
    ASSERT (RxContext->Create.CanonicalNameBuffer == RxContext->AlsoCanonicalNameBuffer);
    if (RxContext->Create.CanonicalNameBuffer) {
        RxFreePool( RxContext->Create.CanonicalNameBuffer );
        RxContext->Create.CanonicalNameBuffer = NULL;
        RxContext->AlsoCanonicalNameBuffer = NULL;
    }
    ASSERT ( RxContext->Create.CanonicalNameBuffer == NULL );
}

NTSTATUS
RxAllocateCanonicalNameBuffer(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PUNICODE_STRING CanonicalName,
    IN     ULONG BufferSizeRequired)
/*++

Routine Description:

    This routine is called to perform the first level of canonicalization on the name.
    Essentially, this amounts to copying the name and then upcasing the first or the first/second
    components.

Arguments:

    RxContext - the current workitem
    CanonicalName - the canonicalized name

Return Value:

    NTSTATUS - The Fsd status for the Operation.
       SUCCESS means that everything worked and processing should continue
       otherwise....failcomplete the operation.

--*/
{
    PAGED_CODE();

    ASSERT (RxContext->Create.CanonicalNameBuffer == NULL);

    CanonicalName->Buffer = (PWCHAR)RxAllocatePoolWithTag(
                                        PagedPool | POOL_COLD_ALLOCATION,
                                        BufferSizeRequired,
                                        RX_MISC_POOLTAG);

    if (CanonicalName->Buffer == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RxDbgTrace(0, Dbg, ("RxAllocateCanonicalNameBuffer allocated %08lx length %08lx\n",
                                CanonicalName->Buffer,BufferSizeRequired));

    RxContext->Create.CanonicalNameBuffer = CanonicalName->Buffer;
    RxContext->AlsoCanonicalNameBuffer = CanonicalName->Buffer;
    CanonicalName->MaximumLength = (USHORT)BufferSizeRequired;
    CanonicalName->Length = 0;

    return STATUS_SUCCESS;
}



NTSTATUS
RxFirstCanonicalize(
    IN OUT PRX_CONTEXT     RxContext,
    IN     PUNICODE_STRING FileName,
    IN OUT PUNICODE_STRING CanonicalName,
    OUT    PNET_ROOT_TYPE  pNetRootType
    )
/*++

Routine Description:

    This routine is called to perform the first level of canonicalization on the
    name. Essentially, this amounts to copying the name and then upcasing the
    first or the first/second components. In addition for pipe/mailslot UNC names
    the appropriate mapping from  pipe,mailslot to IPC$ is done by this routine.
    This routine also adds the appropriate prefix to distinguish deviceless
    connects(UNC names ).

    In addition to canonicalization this routine also deduces the NET_ROOT_TYPE by
    the information provided in the UNC name.

    Last, as a side effect of this call, the UNC_NAME flag of the RX_CONTEXT is
    set to record that this name came in as a UNC_NAME. This is finally stored in
    the FOBX and used in conjuring the original filename for QueryInfoFile/NameInfo.

Arguments:

    RxContext     - the current workitem

    FileName      - the initial filename

    CanonicalName - the canonicalized name

    pNetRootType  - placeholder for the deduced net root type

Return Value:

    NTSTATUS - The Fsd status for the Operation.
       SUCCESS means that everything worked and processing should continue
       otherwise....failcomplete the operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureParamBlock;

    ULONG    CanonicalNameLength;
    BOOLEAN  SynthesizeCanonicalName = FALSE;
    BOOLEAN  ItIsAUNCName = FALSE;
    BOOLEAN  MungeNameForDevicelessTreeConnect = FALSE;
    NET_ROOT_TYPE  DeducedNetRootType = NET_ROOT_WILD;

    UNICODE_STRING ServerName;
    UNICODE_STRING ShareName;
    UNICODE_STRING RemainingName;
    ULONG SessionId;
    WCHAR IdBuffer[16]; // From RtlIntegerToUnicodeString()
    UNICODE_STRING IdString;

    ULONG RxContextFlags = 0;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxFirstCanonicalize entry, filename=%wZ\n",FileName));
    if (FileName->Length == 0) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    // for core servers in particular, it's important to get the service string correct.......
    // so, if this is a devicefull netuse the we will get the netroottype by looking at the string

    if ((FileName->Length > sizeof(L"\\;m:"))
         && (FileName->Buffer[0] == OBJ_NAME_PATH_SEPARATOR)
         && (FileName->Buffer[1] == DRIVE_BASED_PATH_IDENTIFIER)
       ) {

        // it looks like a deviceful netuse.....look for the "early colon"
        // The following test for the classification of net root types is predicated
        // upon the use of single drive letters for Disk files and multiple letters
        // for print shares. This will have to be reworked when the support for
        // extended drive letters is provided.
        if (FileName->Buffer[3] == L':') {
            DeducedNetRootType = NET_ROOT_DISK;
        } else {
            DeducedNetRootType = NET_ROOT_PRINT;
        }
    }

    if ((FileName->Buffer[0] == OBJ_NAME_PATH_SEPARATOR) &&
        (FileName->Buffer[1] != DRIVE_BASED_PATH_IDENTIFIER)) {
        PWCHAR pBuffer,pEndOfName;

        // This is a UNC path name presented by the user.
        RemainingName.Length = RemainingName.MaximumLength = FileName->Length -  sizeof(WCHAR);
        RemainingName.Buffer = &FileName->Buffer[1];
        ItIsAUNCName = TRUE;
        SetFlag(RxContext->Create.Flags,RX_CONTEXT_CREATE_FLAG_UNC_NAME);

        //
        // UNC tree connect path names have the following format:
        // "\;:0\Server\Share where 0 represents the SessionId of the session.
        //
        SessionId = RxGetSessionId (capPARAMS);
        IdString.Length = 0;
        IdString.MaximumLength = sizeof(IdBuffer);
        IdString.Buffer = IdBuffer;
        RtlIntegerToUnicodeString( SessionId, 10, &IdString );

        // scan till the second separator. This will give us the server name.
        ServerName.Buffer = RemainingName.Buffer;
        pEndOfName = (PWCHAR)((PCHAR)RemainingName.Buffer + RemainingName.Length);
        pBuffer    = RemainingName.Buffer;
        while ((pBuffer != pEndOfName) && (*pBuffer != OBJ_NAME_PATH_SEPARATOR)) {
            pBuffer++;
        }

        ServerName.Length    = (USHORT)((PCHAR)pBuffer - (PCHAR)ServerName.Buffer);
        RemainingName.Length = (USHORT)((PCHAR)pEndOfName - (PCHAR)pBuffer);
        RemainingName.Buffer = pBuffer;

        RxDbgTrace(0, Dbg, ("RxFirstCanonicalize entry, remainingname=%wZ\n",&RemainingName));

        // Apply the transformation for mapping PIPE shares to IPC$ shares.
        // Note that this needs to be done only if the share name is specified.
        // since the mup always passes in the trailing slash account for it
        if (RemainingName.Length > sizeof(WCHAR)) {
            // The second separator has been located. Compare to see if the name
            // maps needs to be munged from PIPE or MAILSLOT to IPC$. Note that the
            // leading / is accounted for as part of the compare

            ShareName = RemainingName;

            // Check to see if it is a named pipe connection
            if (ShareName.Length >= s_PipeShareName.Length) {
                if (ShareName.Length == s_PipeShareName.Length ||
                    ShareName.Length > s_PipeShareName.Length &&
                    ShareName.Buffer[s_PipeShareName.Length/2] == OBJ_NAME_PATH_SEPARATOR) {
                    ShareName.Length = s_PipeShareName.Length;
                    SynthesizeCanonicalName = RtlEqualUnicodeString(
                                                  &ShareName,
                                                  &s_PipeShareName,
                                                  TRUE);              // case insensitive
                } else {
                    SynthesizeCanonicalName = FALSE;
                }
            } else {
                SynthesizeCanonicalName = FALSE;
            }

            if (SynthesizeCanonicalName) {
                ShareName = s_IpcShareName;
                DeducedNetRootType = NET_ROOT_PIPE;
                RemainingName.Length -= s_PipeShareName.Length;
                RemainingName.Buffer = (PWCHAR)((PCHAR)RemainingName.Buffer + s_PipeShareName.Length);
            } else {
                BOOLEAN FoundIPCdollar;

                ShareName = RemainingName;

                if (ShareName.Length >= s_IpcShareName.Length) {
                    ShareName.Length = s_IpcShareName.Length;
                    FoundIPCdollar = RtlEqualUnicodeString(
                                         &ShareName,
                                         &s_IpcShareName,
                                         TRUE);            // Case insensitive
                } else {
                    FoundIPCdollar = FALSE;
                }

                if (FoundIPCdollar) {
                    DeducedNetRootType = NET_ROOT_PIPE;
                    ASSERT(SynthesizeCanonicalName == FALSE);
                } else {
                    ShareName = RemainingName;

                    if (ShareName.Length >= s_MailSlotShareName.Length) {
                        if (ShareName.Length == s_MailSlotShareName.Length ||
                            ShareName.Length > s_MailSlotShareName.Length &&
                            ShareName.Buffer[s_MailSlotShareName.Length/2] == OBJ_NAME_PATH_SEPARATOR) {
                            ShareName.Length = s_MailSlotShareName.Length;
                            SynthesizeCanonicalName = RtlEqualUnicodeString(
                                                          &ShareName,
                                                          &s_MailSlotShareName,
                                                          TRUE);            // Case insensitive
                        } else {
                            SynthesizeCanonicalName = FALSE;
                        }
                    } else {
                        SynthesizeCanonicalName = FALSE;
                    }

                    if (SynthesizeCanonicalName) {
                        WCHAR LastCharacterInServerName;

                        DeducedNetRootType = NET_ROOT_MAILSLOT;
                        RxContext->Flags |= RX_CONTEXT_FLAG_CREATE_MAILSLOT;

                        // It is a mailslot share. Check to see if further reduction to canonical
                        // form is required.
                        LastCharacterInServerName =
                            ServerName.Buffer[(ServerName.Length/sizeof(WCHAR)) - 1];

                        if ((LastCharacterInServerName == L'*') &&
                            (ServerName.Length == sizeof(WCHAR))) {
                            ShareName = s_MailSlotShareName;
                            ServerName = s_PrimaryDomainName;
                            RemainingName.Length -= s_MailSlotShareName.Length;
                            RemainingName.Buffer = (PWCHAR)(
                                                       (PCHAR)RemainingName.Buffer +
                                                       s_MailSlotShareName.Length);
                        } else {
                            SynthesizeCanonicalName = FALSE;
                        }
                    }
                }
            }

            if (SynthesizeCanonicalName) {
                CanonicalNameLength = sizeof(WCHAR)     +  //  obj name separator
                                      ServerName.Length +
                                      ShareName.Length  +
                                      RemainingName.Length;

                RxContext->Flags |= RxContextFlags;
                if (RxContext->Flags & RX_CONTEXT_FLAG_CREATE_MAILSLOT) {
                    CanonicalNameLength += s_MailSlotServerPrefix.Length;
                }
            } else {
                CanonicalNameLength = FileName->Length;
            }
        } else {
            Status = STATUS_OBJECT_NAME_INVALID;
            CanonicalNameLength     = FileName->Length;
            SynthesizeCanonicalName = FALSE;
        }
    } else {
        CanonicalNameLength     = FileName->Length;
        SynthesizeCanonicalName = FALSE;
    }

    *pNetRootType = DeducedNetRootType;

    if (Status == STATUS_SUCCESS) {
        // if this is a UNC name AND this is a tree connect then we have to munge
        // the name so as to avoid a conflict by adding '\;:'

        if (ItIsAUNCName &&
            !SynthesizeCanonicalName) {
            MungeNameForDevicelessTreeConnect = TRUE;
            CanonicalNameLength += (3 * sizeof(WCHAR));

            // Hydra adds '\;:0' where 0 represents a SessionId
            CanonicalNameLength += IdString.Length;
        }

        if (!SynthesizeCanonicalName &&
            !MungeNameForDevicelessTreeConnect) {
            if (FileName->Buffer[0] != OBJ_NAME_PATH_SEPARATOR) {
                Status = STATUS_OBJECT_PATH_INVALID;
            }
        }

        if (Status == STATUS_SUCCESS) {
            Status = RxAllocateCanonicalNameBuffer(
                         RxContext,
                         CanonicalName,
                         CanonicalNameLength);
        }

        if (Status ==STATUS_SUCCESS) {
            if (!SynthesizeCanonicalName) {
                if (!MungeNameForDevicelessTreeConnect) {
                    RtlCopyUnicodeString(CanonicalName,FileName);
                } else {
                    CanonicalName->Buffer[0] = OBJ_NAME_PATH_SEPARATOR;
                    CanonicalName->Buffer[1] = DRIVE_BASED_PATH_IDENTIFIER;
                    CanonicalName->Buffer[2] = L':';
                    CanonicalName->Length    = 3*sizeof(WCHAR);

                    RtlAppendUnicodeStringToString(
                        CanonicalName,
                        &IdString);

                    RtlAppendUnicodeStringToString(
                        CanonicalName,
                        FileName);
                }
            } else {
                PCHAR pCanonicalNameBuffer = (PCHAR)CanonicalName->Buffer;

                // The name has to be synthesized from the appropriate components.
                // Copy the initial prefix
                ASSERT(CanonicalName->MaximumLength == CanonicalNameLength);
                CanonicalName->Length = (USHORT)CanonicalNameLength;
                CanonicalName->Buffer[0] = OBJ_NAME_PATH_SEPARATOR;
                pCanonicalNameBuffer += sizeof(WCHAR);

                if (MungeNameForDevicelessTreeConnect) {
                    CanonicalName->Buffer[1] = DRIVE_BASED_PATH_IDENTIFIER;
                    CanonicalName->Buffer[2] = L':';
                    CanonicalName->Buffer[3] = OBJ_NAME_PATH_SEPARATOR;
                    pCanonicalNameBuffer += 3*sizeof(WCHAR);
                }

                if (RxContext->Flags & RX_CONTEXT_FLAG_CREATE_MAILSLOT) {
                    RtlCopyMemory(
                        pCanonicalNameBuffer,
                        s_MailSlotServerPrefix.Buffer,
                        s_MailSlotServerPrefix.Length);

                    pCanonicalNameBuffer += s_MailSlotServerPrefix.Length;
                }

                // Copy the server name
                RtlCopyMemory(
                    pCanonicalNameBuffer,
                    ServerName.Buffer,
                    ServerName.Length);
                pCanonicalNameBuffer += ServerName.Length;

                // Copy the share name. Ensure that the share name includes the leading
                // OBJ_NAME_PATH_SEPARATOR
                ASSERT(ShareName.Buffer[0] == OBJ_NAME_PATH_SEPARATOR);
                RtlCopyMemory(
                    pCanonicalNameBuffer,
                    ShareName.Buffer,
                    ShareName.Length);
                pCanonicalNameBuffer += ShareName.Length;

                // Copy the remaining name
                RtlCopyMemory(
                    pCanonicalNameBuffer,
                    RemainingName.Buffer,
                    RemainingName.Length);

#ifdef _WIN64
                //
                // (fcf) This should be addressed.  I was finding that
                // CanonicalName->Length was ending up too large by 32 bytes
                // (16 chars).
                //
                // In the code above, CanonicalNameLength (and therefore
                // CanonicalName->Length) is padded with (16 * sizeof(WCHAR))
                // to accomodate a 16-character session ID... yet that
                // ID is not copied in some circumstances, such as this
                // code path where SynthesizeCanonicalName == TRUE.
                //
                // Someone more familiar with the code should figure out why
                // this isn't causing a problem on 32-bit builds and what
                // the correct fix is.
                //

                CanonicalName->Length =
                    (USHORT)((pCanonicalNameBuffer + RemainingName.Length) -
                    (PCHAR)CanonicalName->Buffer);
#endif

                RxDbgTrace(0,Dbg,("Final Munged Name .....%wZ\n", CanonicalName));
            }
        }
    }

    RxDbgTrace(-1, Dbg, ("RxFirstCanonicalize exit, status=%08lx\n",Status));
    return Status;
}

//#define RX2C_USE_ALTERNATES_FOR_DEBUG  1
#ifndef RX2C_USE_ALTERNATES_FOR_DEBUG
#define RX2C_IS_SEPARATOR(__c) ((__c==OBJ_NAME_PATH_SEPARATOR)||(__c==L':'))
#define RX2C_IS_DOT(__c) ((__c==L'.'))
#define RX2C_IS_COLON(__c) ((__c==L':'))
#else
#define RX2C_IS_SEPARATOR(__c) ((__c==OBJ_NAME_PATH_SEPARATOR)||(__c==L':')||(__c==L'!'))
#define RX2C_IS_DOT(__c) ((__c==L'.')||(__c==L'q'))
#define RX2C_IS_COLON(__c) ((__c==L':'))
#endif

NTSTATUS
RxCanonicalizeFileNameByServerSpecs(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PUNICODE_STRING RemainingName
    )
/*++

Routine Description:

    This routine is called to canonicalize a filename according to the way that
    the server wants it.

Arguments:

    RxContext - the current workitem

    RemainingName  - the  filename

Return Value:

    NTSTATUS - The Fsd status for the Operation.
       MORE_PROCESSING_REQUIRED means that everything worked and processing
       should continue otherwise....failcomplete the operation.

--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;
    PWCHAR Buffer = RemainingName->Buffer;
    ULONG Length = RemainingName->Length / sizeof(WCHAR);
    ULONG i,o;  //input and output pointers

    PAGED_CODE();

    if (Length==0) {
        return(Status);
    }

    RxDbgTrace(+1, Dbg, ("RxCanonicalizeFileNameByServerSpecs Rname=%wZ\n", RemainingName));

    for (i=o=0;i<Length;) {
        ULONG firstchar,lastchar; //first and last char of the component
        //find a component starting at i: [\][^\]* is the format

        firstchar = i;
        for (lastchar=i+1;;lastchar++) {
            if (  (lastchar>=Length) || RX2C_IS_SEPARATOR(Buffer[lastchar]) ) {
                lastchar--;
                break;
            }
        }

        IF_DEBUG {
            UNICODE_STRING Component;
            Component.Buffer = &Buffer[firstchar];
            Component.Length = (USHORT)(sizeof(WCHAR)*(lastchar-firstchar+1));
            RxDbgTraceLV(0, Dbg, 1001, ("RxCanonicalizeFileNameByServerSpecs component=%wZ\n", &Component));
        }

        //firstchar..lastchar describe the component
        //according to darrylh, . and .. are illegal now
        //i believe that consecutive slashes are also illegal

        switch (lastchar-firstchar) {
        case 0: //length 1
            // the two bad cases are a backslash or a dot. if the backslash is at the end then that's okay
            if ( (RX2C_IS_SEPARATOR(Buffer[firstchar])&&(firstchar!=Length-1))
                 || RX2C_IS_DOT(Buffer[firstchar])
               ) {
                if (lastchar!=0) {
                    // it is ok if two colons stick together, i.e. \\server\share\foo::stream
                    if (!RX2C_IS_COLON(Buffer[lastchar+1])) {
                        goto BADRETURN;
                    }
                } else {
                    // it is fine if the colon follows the share, i.e. \\server\share\:stream
                    if (!RX2C_IS_COLON(Buffer[1])) {
                        goto BADRETURN;
                    }
                }
            }
            break;

        case 1: //length 2
            //bad cases: \. and ..
            if (  RX2C_IS_DOT(Buffer[firstchar+1])
                  && (RX2C_IS_SEPARATOR(Buffer[firstchar])
                  || RX2C_IS_DOT(Buffer[firstchar]) )
               ) {
                goto BADRETURN;
            }
            break;

        case 2: //length 3
            if ( (RX2C_IS_SEPARATOR(Buffer[firstchar])
                 && RX2C_IS_DOT(Buffer[firstchar+1])
                 && RX2C_IS_DOT(Buffer[firstchar+2]))
               ) {
                goto BADRETURN;
            }
            break;

        }
        //DOWNLEVEL this is where you limit by component length. o will be the back ptr
        //but for no downlevel....do nothing.
        i = lastchar + 1;
    }

    RxDbgTraceUnIndent(-1,Dbg);
    return(Status);

BADRETURN:
    RxDbgTrace(-1, Dbg, ("RxCanonicalizeFileNameByServerSpecs BADRETURN \n"));
    return(STATUS_OBJECT_PATH_SYNTAX_BAD);
}

NTSTATUS
RxCanonicalizeNameAndObtainNetRoot(
    IN OUT PRX_CONTEXT     RxContext,
    IN     PUNICODE_STRING FileName,
    OUT    PUNICODE_STRING RemainingName
    )
/*++

Routine Description:

    This routine is called to find out the server or netroot associated with a
    name. In addition, the name is canonicalized according to what flags are set
    in the srvcall.

Arguments:

    RxContext - the current workitem

    FileName  - the initial filename

    CanonicalName - the canonicalized name. an initial string is passed in; if it
                    is not big enough then a bigger one is allocated and freed
                    when the rxcontx is freed.

    RemainingName - the name of the file after the netroot prefix is removed; it
                    has been canonicalized. This points into the same buffer as
                    canonical name.

Return Value:

    NTSTATUS - The Fsd status for the Operation.
       SUCCESS means that everything worked and processing should continue
       otherwise....failcomplete the operation.

--*/
{
    NTSTATUS Status;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    UNICODE_STRING     CanonicalName;

    PFILE_OBJECT       RelatedFileObject = capFileObject->RelatedFileObject;
    LOCK_HOLDING_STATE LockHoldingState = LHS_LockNotHeld;
    NET_ROOT_TYPE      NetRootType = NET_ROOT_WILD;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCanonicalizeName -> %08lx\n", 0));

    RemainingName->Buffer = NULL;
    RemainingName->Length = RemainingName->MaximumLength = 0;

    CanonicalName.Buffer = NULL;
    CanonicalName.Length = CanonicalName.MaximumLength = 0;

    if (!RelatedFileObject) {
        Status = RxFirstCanonicalize(
                     RxContext,
                     FileName,
                     &CanonicalName,
                     &NetRootType);

        if (Status!=STATUS_SUCCESS) {
            RxDbgTraceUnIndent(-1,Dbg);
            return(Status);
        }
    } else {

        PFCB RelatedFcb = (PFCB)(RelatedFileObject->FsContext);
        PFOBX RelatedFobx = (PFOBX)(RelatedFileObject->FsContext2);
        ULONG AllocationNeeded;
        PV_NET_ROOT RelatedVNetRoot;
        PUNICODE_STRING RelatedVNetRootName,RelatedFcbName;

        if ((RelatedFcb == NULL) ||
            (RelatedFobx == NULL)) {
            RxDbgTraceUnIndent(-1,Dbg);
            return STATUS_INVALID_PARAMETER;
        }

        RelatedVNetRoot = (PV_NET_ROOT)(RelatedFobx->SrvOpen->pVNetRoot);

        if (!NodeTypeIsFcb(RelatedFcb) ||
            (RelatedVNetRoot == NULL)  ||
            (NodeType(RelatedVNetRoot) != RDBSS_NTC_V_NETROOT)) {
            RxDbgTraceUnIndent(-1,Dbg);
            return STATUS_INVALID_PARAMETER;
        }

        RelatedVNetRootName = &RelatedVNetRoot->PrefixEntry.Prefix;
        RelatedFcbName = &RelatedFcb->FcbTableEntry.Path;

        //relative open......
        //    we have to ensure that we have a canonical name buffer that is
        //    long enough so we add the name of the current file to the sum of
        //    the vnetroot length of the relative file and the prefixname (not
        //    the alreadyprefixedname) of the relative file. plus some slop for
        //    chars. If this is greater than the maximum value for a USHORT we
        // reject the name as being invalid since we cannot represent it in
        // a UNICODE_STRING

        AllocationNeeded = RelatedVNetRootName->Length
                            + RelatedFcbName->Length
                            + FileName->Length
                            + 3 * sizeof(WCHAR);

        if (AllocationNeeded <= 0xffff) {
            // you may need some backslashs/colons in the middle

            Status = RxAllocateCanonicalNameBuffer(
                         RxContext,
                         &CanonicalName,
                         AllocationNeeded);
        } else {
            Status = STATUS_OBJECT_PATH_INVALID;
        }

        if (Status!=STATUS_SUCCESS) {
            RxDbgTraceUnIndent(-1,Dbg);
            return(Status);
        }

        RtlMoveMemory( CanonicalName.Buffer,
                       RelatedVNetRootName->Buffer,
                       RelatedVNetRootName->Length );
        RtlMoveMemory( ((PBYTE)(CanonicalName.Buffer)) + RelatedVNetRootName->Length,
                       RelatedFcbName->Buffer,
                       RelatedFcbName->Length );

        CanonicalName.Length = (USHORT)(RelatedVNetRootName->Length
                                          + RelatedFcbName->Length);

        RxDbgTrace(0,Dbg,("Name From Related Fileobj.....%wZ\n", &CanonicalName));
        if (FileName->Length != 0) {
            //add on the rest...there are special cases here! with ':' for streams.........
            ULONG LastWCharIndex = (CanonicalName.Length/sizeof(WCHAR)) - 1;
            if (CanonicalName.Buffer[LastWCharIndex] != OBJ_NAME_PATH_SEPARATOR
                   && (FileName->Buffer[0] != L':' )  ) {
                ASSERT(CanonicalName.Length < CanonicalName.MaximumLength);
                CanonicalName.Length += sizeof(WCHAR);
                CanonicalName.Buffer[LastWCharIndex+1] = OBJ_NAME_PATH_SEPARATOR;
            }
            ASSERT (CanonicalName.MaximumLength >= CanonicalName.Length + FileName->Length);
            RxDbgTrace(0,Dbg,("Name From Related Fileobj w/ trailer.....%wZ\n", &CanonicalName));
            RtlMoveMemory(((PCHAR)CanonicalName.Buffer)+CanonicalName.Length,
                          FileName->Buffer,FileName->Length);
            CanonicalName.Length += FileName->Length;
        }

        if (FlagOn(RelatedFobx->Flags,RX_CONTEXT_CREATE_FLAG_UNC_NAME)){
            //if the related guy was a UNC, we're a UNC
            SetFlag(RxContext->Create.Flags,RX_CONTEXT_CREATE_FLAG_UNC_NAME);
        }

        RxDbgTrace(0,Dbg,("Final Name From Related Fileobj.....%wZ\n", &CanonicalName));
    }

    Status = RxFindOrConstructVirtualNetRoot(
                 RxContext,
                 &CanonicalName,
                 NetRootType,
                 RemainingName);

    if ((Status != STATUS_SUCCESS) &&
        (Status != STATUS_PENDING) &&
        (RxContext->Flags & RX_CONTEXT_FLAG_MAILSLOT_REPARSE)) {

        ASSERT(CanonicalName.Buffer == RxContext->Create.CanonicalNameBuffer);

        RxFreeCanonicalNameBuffer(RxContext);

        Status = RxFirstCanonicalize(
                     RxContext,
                     FileName,
                     &CanonicalName,
                     &NetRootType);

        if (Status == STATUS_SUCCESS) {
            Status = RxFindOrConstructVirtualNetRoot(
                         RxContext,
                         &CanonicalName,
                         NetRootType,
                         RemainingName);
        }
    }

    if (FsRtlDoesNameContainWildCards( RemainingName )) {
        Status = STATUS_OBJECT_NAME_INVALID;
    }

    if (Status == STATUS_SUCCESS) {
        RxDbgTrace( 0, Dbg, ("RxCanonicalizeName SrvCall-> %08lx\n", RxContext->Create.pSrvCall));
        RxDbgTrace( 0, Dbg, ("RxCanonicalizeName Root-> %08lx\n", RxContext->Create.pNetRoot));

        Status = RxCanonicalizeFileNameByServerSpecs(RxContext,RemainingName);

        if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
            RxDbgTrace(0, Dbg, ("RxCanonicalizeName Remaining -> %wZ\n", RemainingName));
        }
    }

    if( (NT_SUCCESS(Status) || (Status == STATUS_MORE_PROCESSING_REQUIRED)) &&
        (RxContext->Create.pNetRoot != NULL) )
    {
        NTSTATUS PreparseStatus;

        // Allow the Mini-RDR to do any extra "scanning" of the name
        MINIRDR_CALL(PreparseStatus,
                     RxContext,
                     RxContext->Create.pNetRoot->pSrvCall->RxDeviceObject->Dispatch,
                     MRxPreparseName,
                     (RxContext, &CanonicalName));
    }

   RxDbgTrace(-1, Dbg, ("RxCanonicalizeName Status -> %08lx\n", Status));
   return Status;
}

NTSTATUS
RxFindOrCreateFcb(
    IN OUT PRX_CONTEXT RxContext,
    IN PUNICODE_STRING RemainingName
    )
/*++

Routine Description:

    This routine is called to either find the Fcb associated with the
    name or to create it.  If everything succeeds, it returns with a
    reference on the name and with the fcblock held exclusive.

    so, that's a total of two things for success:
      1) fcb lock held exclusive
      2) reference on the fcb ( be it through lookup or taking an additional
         reference on create)

    The current strategy is to not delete the Fcb if things don't work out and
    to let it be scavenged.  this is a good strategy unless we are being bombarded
    with open requests that fail in which case we should change over to something
    different.  for this reason, i record in the irp context if the fcb is built here.

Arguments:

    RxContext - the current workitem

    RemainingName - the name of the file after the netroot prefix is removed; it has been
                    canonicalized.

Return Value:

    RXSTATUS - The Fsd status for the Irp

Notes:

    On Exit -- the FCB resource would have been accquired exclusive if successful

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PV_NET_ROOT VNetRoot = (PV_NET_ROOT)RxContext->Create.pVNetRoot;
    PNET_ROOT   NetRoot  = (PNET_ROOT)RxContext->Create.pNetRoot;
    PFCB        Fcb;

    ULONG       TableVersion;
    CLONG       RemainingNameLength;

    BOOLEAN     FcbTableLockAcquired;
    BOOLEAN     FcbTableLockAcquiredExclusive = FALSE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxFindOrCreateFcb -> %08lx\n", 0));

    ASSERT(NetRoot == (PNET_ROOT)VNetRoot->NetRoot);

    // Acquire the NET_ROOT's FcbTable lock shared to beginwith. This will
    // ensure maximal concurrency and in those cases when the lookup fails
    // this will be converted to an exclusive lock before proceeding further.

    RxAcquireFcbTableLockShared(&NetRoot->FcbTable, TRUE);
    FcbTableLockAcquired = TRUE;

    TableVersion = NetRoot->FcbTable.Version;
    RemainingNameLength = RemainingName->Length;

    Fcb = RxFcbTableLookupFcb(
              &NetRoot->FcbTable,
              RemainingName);

    IF_DEBUG {
        if (Fcb) {
            RxLoudFcbMsg("RxFindOrCreateFcb found: ",&(Fcb->FcbTableEntry.Path));
            RxDbgTrace(0, Dbg, ("                   ----->Found Prefix Name=%wZ\n",
                            &Fcb->FcbTableEntry.Path ));
        } else {
            RxDbgTrace(0, Dbg, ("Name not found - %wZ\n", RemainingName));
            RxDbgTrace(0, Dbg, ("Fcb is NULL!!\n"));
            RxLoudFcbMsg("RxFindOrCreateFcb fcbisnull found: ",RemainingName);
        }
    }

    // If it has been marked for orphaning, lets do it!
    if( Fcb && Fcb->fShouldBeOrphaned )
    {
        // Release our reference from the first lookup
        RxDereferenceNetFcb( Fcb );

        // Switch to an exclusive table lock so we know we're the only one referencing this FCB
        RxReleaseFcbTableLock( &NetRoot->FcbTable );
        FcbTableLockAcquired = FALSE;
        RxAcquireFcbTableLockExclusive( &NetRoot->FcbTable, TRUE );
        FcbTableLockAcquired = TRUE;
        FcbTableLockAcquiredExclusive = TRUE;

        // Make sure it is still in the table
        Fcb = RxFcbTableLookupFcb(
                  &NetRoot->FcbTable,
                  RemainingName);

        if( Fcb && Fcb->fShouldBeOrphaned )
        {
            RxOrphanThisFcb( Fcb );
            RxDereferenceNetFcb( Fcb );
            Fcb = NULL;
        }
    }

    if ((Fcb == NULL) ||
        (Fcb->FcbTableEntry.Path.Length != RemainingNameLength)) {
        // Convert the shared lock that is currently held to an exclusive lock.
        // This will necessiate another lookup if the FCB table was updated during
        // this interval

        if( !FcbTableLockAcquiredExclusive )
        {
            RxReleaseFcbTableLock( &NetRoot->FcbTable );
            FcbTableLockAcquired = FALSE;

            RxAcquireFcbTableLockExclusive(&NetRoot->FcbTable, TRUE);
            FcbTableLockAcquired = TRUE;
        }

        if (TableVersion != NetRoot->FcbTable.Version) {
            Fcb = RxFcbTableLookupFcb(
                      &NetRoot->FcbTable,
                      RemainingName);
        }

        if ((Fcb == NULL) ||
            (Fcb->FcbTableEntry.Path.Length != RemainingNameLength)) {
            //we have to build it
            try {
                Fcb = RxCreateNetFcb( RxContext, VNetRoot, RemainingName );

                if (Fcb == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    Status = STATUS_SUCCESS;
                }

                if (Status == STATUS_SUCCESS) {
                    Status = RxAcquireExclusiveFcb( RxContext, Fcb );

                    if (Status == STATUS_SUCCESS) {
                        RxContext->Create.FcbAcquired = TRUE;
                    } else {
                        RxContext->Create.FcbAcquired = FALSE;
                    }
                }
            } finally {
                if (AbnormalTermination()) {
                    RxReleaseFcbTableLock( &NetRoot->FcbTable );
                    FcbTableLockAcquired = FALSE;

                    if (Fcb)
                    {
                        RxTransitionNetFcb(Fcb,Condition_Bad);

                        ExAcquireResourceExclusiveLite(Fcb->Header.Resource,TRUE);
                        if (!RxDereferenceAndFinalizeNetFcb(Fcb,NULL,FALSE,FALSE)) {
                            ExReleaseResourceLite(Fcb->Header.Resource);
                        }
                    }
                }
            }
        }
    }

    if (FcbTableLockAcquired) {
        RxReleaseFcbTableLock( &NetRoot->FcbTable );
    }

    if (Status == STATUS_SUCCESS) {
       RxContext->pFcb = (PMRX_FCB)Fcb;
       RxLog(("Found or created FCB %lx Condition %lx\n",Fcb,Fcb->Condition));
       RxWmiLog(LOG,
                RxFindOrCreateFcb,
                LOGPTR(Fcb)
                LOGULONG(Fcb->Condition));
       if (!RxContext->Create.FcbAcquired){
           // if the FCB was not newly built then ensure that it is in a stable
           // condition before proceeding further. Note that since a reference
           // to this FCB is held by this routine it cannot be finalized
           // before the control can return to this routine.

           RxWaitForStableNetFcb(Fcb,RxContext);

           Status = RxAcquireExclusiveFcb( RxContext, Fcb );
           if (Status == STATUS_SUCCESS) {
               RxContext->Create.FcbAcquired = TRUE;
           }
       }
    }

    RxDbgTrace(-1, Dbg, ("RxFindOrCreateFcb Fcb=%08lx\n", RxContext->pFcb));

    if (RxContext->pFcb)
    {
        RxDbgTrace(-1, Dbg, ("RxFindOrCreateFcb name=%wZ\n", &(((PFCB)(RxContext->pFcb))->FcbTableEntry.Path)));
    }

    return Status;
}

NTSTATUS
RxSearchForCollapsibleOpen (
    IN OUT PRX_CONTEXT RxContext,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG ShareAccess
    )
/*++

Routine Description:

    This routine is called to seach the list of available srvopens on
    the fcb to see if we can collapse onto an existing open.
    If we search the whole list w/o finding a collapse, then we return
    STATUS_NOT_FOUND.

Arguments:

    RxContext - the current workitem


Return Value:

    STATUS_SUCCESS -- a SRV_OPEN instance was found.
    STATUS_MORE_PROCESSING_REQUIRED -- no SRV_OPEN instance was found.

--*/
{
    RxCaptureParamBlock;
    RxCaptureFileObject;
    RxCaptureFcb;

    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;
    ULONG    Disposition;
    ULONG    CurrentCreateOptions;
    BOOLEAN  AllowCollapse;

    PNET_ROOT pNetRoot = (PNET_ROOT)(RxContext->Create.pNetRoot);
    PFCB      pFcb = (PFCB)(RxContext->pFcb);
    PSRV_OPEN pSrvOpen = NULL;

    PAGED_CODE();

    if (FlagOn(
            RxContext->Create.NtCreateParameters.CreateOptions,
            FILE_OPEN_FOR_BACKUP_INTENT)) {

        ClearFlag(pFcb->FcbState,FCB_STATE_COLLAPSING_ENABLED);
        RxScavengeRelatedFobxs(pFcb);

        RxPurgeFcbInSystemCache(
            pFcb,
            NULL,
            0,
            FALSE,
            TRUE);

        return STATUS_NOT_FOUND;
    }

    // if the create specifies a special create disposition then we don't
    // collapse; as well, we give the minirdr the opportunity to defeat
    // collapsing by a calldown

    CurrentCreateOptions  = RxContext->Create.NtCreateParameters.CreateOptions;
    Disposition = RxContext->Create.NtCreateParameters.Disposition;
    AllowCollapse = (Disposition == FILE_OPEN) || (Disposition == FILE_OPEN_IF);

    if (AllowCollapse && (pFcb->MRxDispatch != NULL)) { //should be an ASSERT??
        NTSTATUS CollapseStatus;

        ASSERT(RxContext->pRelevantSrvOpen == NULL);
        ASSERT(pFcb->MRxDispatch->MRxShouldTryToCollapseThisOpen!=NULL);

        CollapseStatus =
                  pFcb->MRxDispatch->MRxShouldTryToCollapseThisOpen(RxContext);
        AllowCollapse = (CollapseStatus == STATUS_SUCCESS);
    }

    if (!AllowCollapse) {
        //it may be that there is an existing open that keeps this open from working....
        //if so, prepurge
        NTSTATUS SharingStatus;

        SharingStatus = RxCheckShareAccessPerSrvOpens(
                            pFcb,
                            DesiredAccess,
                            ShareAccess);

        if (SharingStatus != STATUS_SUCCESS) {
            ClearFlag(pFcb->FcbState,FCB_STATE_COLLAPSING_ENABLED);
            RxScavengeRelatedFobxs(pFcb);

            RxPurgeFcbInSystemCache(
                pFcb,
                NULL,
                0,
                FALSE,
                TRUE);
        }

        return STATUS_NOT_FOUND;
    }

    if ((pFcb->NetRoot == (PNET_ROOT)RxContext->Create.pNetRoot) &&
        (pFcb->pNetRoot->Type == NET_ROOT_DISK)) {

        BOOLEAN FobxsScavengingAttempted = FALSE;
        BOOLEAN FcbPurgingAttempted      = FALSE;

        // Search the list of SRV_OPEN's to determine if this open request can be
        // collapsed with an existing SRV_OPEN.

        for (;;) {
            PLIST_ENTRY pSrvOpenListEntry;

            pSrvOpenListEntry = pFcb->SrvOpenList.Flink;

            for (;;) {
                if (pSrvOpenListEntry == &pFcb->SrvOpenList) {
                    // If the end of the list of SRV_OPEN's has been reached then it
                    // is time to go to the server, i.e., create a new SRV_OPEN.
                    Status = STATUS_NOT_FOUND;
                    break;
                }

                pSrvOpen = (PSRV_OPEN)CONTAINING_RECORD(pSrvOpenListEntry,SRV_OPEN,SrvOpenQLinks);

                if ((pSrvOpen->pVNetRoot == RxContext->Create.pVNetRoot) &&
                    (pSrvOpen->DesiredAccess == DesiredAccess) &&
                    (pSrvOpen->ShareAccess == ShareAccess) &&
                    !FlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_COLLAPSING_DISABLED) &&
                    !FlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_CLOSED) &&
                    !FlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_FILE_RENAMED) &&
                    !FlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_FILE_DELETED))   {

                    if ((pSrvOpen->CreateOptions & FILE_OPEN_REPARSE_POINT) !=
                        (CurrentCreateOptions & FILE_OPEN_REPARSE_POINT)) {
                        FobxsScavengingAttempted = TRUE;
                        FcbPurgingAttempted = TRUE;
                        Status = STATUS_NOT_FOUND;
                        break;
                    }

                    // If a SRV_OPEN with identical DesiredAccess and ShareAccess
                    // has been found which has not been renamed/deleted then the
                    // new open request can be collapsed onto the existing open.
                    if (DisableByteRangeLockingOnReadOnlyFiles ||
                        !FlagOn(pSrvOpen->pFcb->Attributes,FILE_ATTRIBUTE_READONLY)) {
                        Status = STATUS_SUCCESS;
                        break;
                    }

                } else {
                    if (pSrvOpen->pVNetRoot != RxContext->Create.pVNetRoot) {
                        // the file is accessed by another user. It needs to be purged out
                        // if the current user is going to use it.

                        RxContext->Create.TryForScavengingOnSharingViolation = TRUE;

                        // Don't collapse srvopens belonging to different vnetroots
                        pSrvOpenListEntry = pSrvOpenListEntry->Flink;
                        continue;

                    }

                    // If the existing SRV_OPEN does not match the access required by the
                    // new open request ensure that the new open request does not conflict
                    // with the existing SRV_OPEN's. If it does scavenging/purging needs
                    // to be attempted before forwarding the request to the server.

                    Status = RxCheckShareAccessPerSrvOpens(
                                 pFcb,
                                 DesiredAccess,
                                 ShareAccess);

                    if (Status != STATUS_SUCCESS) {
                        break;
                    }

                    Status = STATUS_MORE_PROCESSING_REQUIRED;
                }

                pSrvOpenListEntry = pSrvOpenListEntry->Flink;
            }

            if (Status == STATUS_SUCCESS) {
                // a collapsible open was found. return it.
                RxContext->pRelevantSrvOpen = (PMRX_SRV_OPEN)pSrvOpen;
                ASSERT(pFcb->MRxDispatch->MRxShouldTryToCollapseThisOpen!=NULL);

                if(pFcb->MRxDispatch->MRxShouldTryToCollapseThisOpen(RxContext) == STATUS_SUCCESS)
                {

                    if (FlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_CLOSE_DELAYED)) {
                        RxLog(("****** Delayed Close worked reusing SrvOpen(%lx)\n",pSrvOpen));
                        RxWmiLog(LOG,
                                 RxSearchForCollapsibleOpen,
                                 LOGPTR(pSrvOpen));
                        InterlockedDecrement(&pNetRoot->SrvCall->NumberOfCloseDelayedFiles);
                        ClearFlag(pSrvOpen->Flags,SRVOPEN_FLAG_CLOSE_DELAYED);
                    }

                    break;
                }
                else
                {
                    Status = STATUS_NOT_FOUND;
                }
            }

            if (!FobxsScavengingAttempted) {
                // No SRV_OPEN instance onto which the new request can be collapsed was
                // found. Attempt to scavenge any FOBX's, i.e., ensure that all the
                // delayed close operations on the FOBX are done before checking again.

                FobxsScavengingAttempted = TRUE;
                ClearFlag(pFcb->FcbState,FCB_STATE_COLLAPSING_ENABLED);
                RxScavengeRelatedFobxs(pFcb);
                continue;
            }

            if (!FcbPurgingAttempted) {
                // No SRV_OPEN instance was found. Ensure that the potential references
                // held by the memory manager/cache manager can be purged before the
                // open request to the server can be attempted.

                RxPurgeFcbInSystemCache(
                    pFcb,
                    NULL,
                    0,
                    FALSE,
                    TRUE);

                FcbPurgingAttempted = TRUE;
                continue;
            }

            break;
        }
    } else {
        Status = STATUS_NOT_FOUND;
    }

    if (Status == STATUS_SHARING_VIOLATION) {
        // A local sharing violation was detected.
        RxContext->Create.TryForScavengingOnSharingViolation = TRUE;
    }

    return Status;
}

NTSTATUS
RxCollapseOrCreateSrvOpen (
    IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

    This routine is called to either find a SRV_OPEN instance that can be
    collapsed onto or, failing that, to build a fresh one IN
    TRANSITION.  The fcblock will already be held exclusive and the
    tablelock will be either exclusive or shared.  If everything
    succeeds, it returns with a reference on the srvopen and with the
    fcblock still held excl BUT we always release the tablelock.  IF
    IT FAILS, THEN IT COMPLETES THE RXCONTEXT FROM HERE WHICH, IN
    TURN, WILL RELEASE THE FCBLOCK.

    The minirdr is consulted to determine if a collapse is possible so
    there is no reason to call twice.  If the minirdr determines to
    collapse, then it will do so and passback a returnable status.
    Thus, RxStatus(SUCCESS) is an terminating return from here.  For this
    reason, we return RxStatus(MORE_PROCESSING_REQUIRED) as the
    nonterminating return and the minirdr routine uses the same.

    RxContext->SrvOpen contains either the collapsed or built srvopen.

Arguments:

    RxContext - the current workitem


Return Value:

    RxStatus(MORE_PROCESSING_REQUIRED) - further processing of the newly
    constructed SRV_OPEN instance is required.

    RxStatus(SUCCESS) - the SRV_OPEN instance was found/constructed successfully

Notes:

    On Entry -- the FCB resource must have been acquired exclusive

--*/
{
    NTSTATUS  Status = STATUS_NOT_FOUND;

    PNET_ROOT NetRoot = (PNET_ROOT)(RxContext->Create.pNetRoot);

    RxCaptureFcb;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    ACCESS_MASK DesiredAccess = capPARAMS->Parameters.Create.SecurityContext->DesiredAccess
                                           & FILE_ALL_ACCESS;
    ULONG       ShareAccess = capPARAMS->Parameters.Create.ShareAccess & FILE_SHARE_VALID_FLAGS;

    RX_BLOCK_CONDITION FcbCondition;

    ULONG   CreateOptions;
    BOOLEAN DeleteOnClose;
    BOOLEAN NoIntermediateBuffering;
    BOOLEAN PagingIoResourceTaken = FALSE;
    ULONG Disposition = RxContext->Create.NtCreateParameters.Disposition;

    PSRV_OPEN SrvOpen;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCollapseOrCreateSrvOpen -> %08lx\n", 0));

    CreateOptions           = capPARAMS->Parameters.Create.Options;
    NoIntermediateBuffering = BooleanFlagOn( CreateOptions, FILE_NO_INTERMEDIATE_BUFFERING );
    DeleteOnClose           = BooleanFlagOn( CreateOptions, FILE_DELETE_ON_CLOSE );

    ASSERT  ( RxIsFcbAcquiredExclusive ( capFcb )  );

    //this ensures that the fcb will not be finalized while we are in the minirdr
    capFcb->UncleanCount++;

    if (!DeleteOnClose) {
        Status = RxSearchForCollapsibleOpen(
                    RxContext,
                    DesiredAccess,
                    ShareAccess );

        if (Status == STATUS_SUCCESS) {
            RxContext->CurrentIrp->IoStatus.Information = FILE_OPENED;
        }
    }

    if ( Status == STATUS_NOT_FOUND ) {
        RxDbgTrace(0, Dbg, ("No collapsible srvopens found for %wZ\n", &capFcb->FcbTableEntry.Path));

        try {
            SrvOpen = RxCreateSrvOpen(
                          (PV_NET_ROOT)RxContext->Create.pVNetRoot,
                          capFcb );
            if (SrvOpen != NULL) {
                SrvOpen->DesiredAccess = DesiredAccess;
                SrvOpen->ShareAccess = ShareAccess;
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        } except (CATCH_EXPECTED_EXCEPTIONS) {
            //note: we do not give back the FCB!!!!
            RxDbgTrace(-1, Dbg, ("RxCollapseOrCreateSrvOpen EXCEPTION %08lx\n",
                                        GetExceptionCode()));
            return RxProcessException( RxContext, GetExceptionCode() );
        } //try

        RxContext->pRelevantSrvOpen = (PMRX_SRV_OPEN)SrvOpen;

        if (Status == STATUS_SUCCESS) {
            RxInitiateSrvOpenKeyAssociation(SrvOpen);

            //calldown.....
            IF_DEBUG {RxContext->CurrentIrp->IoStatus.Information = 0xabcdef;}

            MINIRDR_CALL(Status,
                         RxContext,
                         capFcb->MRxDispatch,
                         MRxCreate,
                         (RxContext));

            //help other minirdr writers find this bug, i.e. they should use the new way
            DbgDoit( ASSERT(RxContext->CurrentIrp->IoStatus.Information == 0xabcdef);  )

            // if this is a successful overwrite, then truncate the file
            if ((Disposition==FILE_OVERWRITE) || (Disposition==FILE_OVERWRITE_IF)) {
                if (Status==STATUS_SUCCESS) {
                    RxAcquirePagingIoResource(capFcb,RxContext);
                    capFcb->Header.FileSize.QuadPart = 0;
                    capFcb->Header.AllocationSize.QuadPart = 0;
                    capFcb->Header.ValidDataLength.QuadPart = 0;
                    RxContext->CurrentIrpSp->FileObject->SectionObjectPointer
                                          = &((PFCB)(capFcb))->NonPaged->SectionObjectPointers;
                    CcSetFileSizes( RxContext->CurrentIrpSp->FileObject,
                                   (PCC_FILE_SIZES)&capFcb->Header.AllocationSize
                                  );
                    RxReleasePagingIoResource(capFcb,RxContext);
                }
            } else if( Status == STATUS_SUCCESS ) {

                RxContext->CurrentIrpSp->FileObject->SectionObjectPointer
                                      = &((PFCB)(capFcb))->NonPaged->SectionObjectPointers;

                if( CcIsFileCached(RxContext->CurrentIrpSp->FileObject) ) {

                    //
                    //  Since the file is cached, we need to update the sizes the cache manager
                    //  has with the ones we just got back from the server.  If the server is
                    //  behaving properly, this will be a nop.  But we have to protect ourselves
                    //  from a bad server that returns updated file sizes that we do not know about.
                    //

                    RxAdjustAllocationSizeforCC( capFcb );

                    try {

                        CcSetFileSizes( RxContext->CurrentIrpSp->FileObject,
                                        (PCC_FILE_SIZES)&capFcb->Header.AllocationSize );

                    } except( EXCEPTION_EXECUTE_HANDLER ) {

                        //
                        //  We took an exception setting the file sizes.  This can happen
                        //  if the cache manager was not able to allocate resources.  We
                        //  cannot restore the previous sizes, since we do not know what they
                        //  were.  The best we can do is purge the file from the cache.
                        //

                        RxPurgeFcbInSystemCache( capFcb,
                                                 NULL,
                                                 0,
                                                 TRUE,
                                                 TRUE );
                    }
                }
            }


            RxContext->CurrentIrp->IoStatus.Information
                           = RxContext->Create.ReturnedCreateInformation;
                           
                           
            SrvOpen->OpenStatus = Status;
            

            RxTransitionSrvOpen(SrvOpen, //SrvOpenAsWrapperSrvOpen(SrvOpen),
                               (Status==STATUS_SUCCESS)?Condition_Good
                                                       :Condition_Bad
                                );


            RxDumpCurrentAccess("shareaccess status after calldown....","","ShrAccPostMini",&capFcb->ShareAccess);
            RxDbgTrace(0, Dbg, ("RxCollapseOrCreateSrvOpen   Back from the minirdr, Status=%08lx\n", Status ));

            ASSERT  ( RxIsFcbAcquiredExclusive ( capFcb )  );

            RxCompleteSrvOpenKeyAssociation(SrvOpen);

            if (Status != STATUS_SUCCESS) {
               FcbCondition = Condition_Bad;
               RxDereferenceSrvOpen(SrvOpen,LHS_ExclusiveLockHeld);
               RxContext->pRelevantSrvOpen = NULL;

               if (RxContext->pFobx != NULL) {
                   RxDereferenceNetFobx(RxContext->pFobx,LHS_ExclusiveLockHeld);
                   RxContext->pFobx = NULL;
               }

            } else {
               if (DeleteOnClose) {
                  ClearFlag(capFcb->FcbState,FCB_STATE_COLLAPSING_ENABLED);
               }

               SrvOpen->CreateOptions =  RxContext->Create.NtCreateParameters.CreateOptions;
               FcbCondition = Condition_Good;
            }
        } else {
            FcbCondition = Condition_Bad;
        }

        RxLog(("Transitioning FCB %lx Condition %lx\n",capFcb,FcbCondition));
        RxWmiLog(LOG,
                 RxCollapseOrCreateSrvOpen,
                 LOGPTR(capFcb)
                 LOGULONG(FcbCondition));

        RxTransitionNetFcb(capFcb,FcbCondition);
    } else if (Status == STATUS_SUCCESS) {
       BOOLEAN fTransitionProcessingRequired = FALSE;

       // An existing SRV_OPEN instance has been found. This instance can be in
       // one of the following two states -- either it has already transitioned
       // into a stable state or it is in the process of being constructed. In
       // the later case this routine needs to wait for this transition to occur.
       // Note that both the reference count and the OpenCount need to be
       // incremented before releasing the resource. An incremented reference
       // count by itself will not ensure that the Close request on a SRV_OPEN
       // will be delayed till the threads waiting for the transitioning of the
       // SRV_OPEN have had a chance to process it.

       SrvOpen = (PSRV_OPEN)(RxContext->pRelevantSrvOpen);
       if (!StableCondition(SrvOpen->Condition)) {
          fTransitionProcessingRequired = TRUE;
          RxDbgTrace(0,Dbg,("waiting for stable srv open (%lx)\n",SrvOpen));

          RxReferenceSrvOpen(SrvOpen);
          SrvOpen->OpenCount++;

          RxReleaseFcb(RxContext,capFcb);
          RxContext->Create.FcbAcquired = FALSE;

          RxWaitForStableSrvOpen(SrvOpen,RxContext);

          Status = RxAcquireExclusiveFcb(RxContext,capFcb);
          if (Status == STATUS_SUCCESS) {
              RxContext->Create.FcbAcquired = TRUE;
          }
       }

       if (SrvOpen->Condition == Condition_Good) {

          MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxCollapseOpen,(RxContext));
          RxDbgTrace(0, Dbg, ("RxCollapseOrCreateSrvOpen   Back from the minirdr, Status=%08lx\n", Status ));

          ASSERT  ( RxIsFcbAcquiredExclusive ( capFcb )  );
       } else {
          Status =  SrvOpen->OpenStatus;
       }

       if (fTransitionProcessingRequired) {
          SrvOpen->OpenCount--;
          RxDereferenceSrvOpen(SrvOpen,LHS_ExclusiveLockHeld);
       }
    }

    capFcb->UncleanCount--;  //now that we're back from the minirdr

    RxDbgTrace(-1, Dbg, ("RxCollapseOrCreateSrvOpen SrvOpen %08lx Status %08lx\n"
                                , RxContext->pRelevantSrvOpen, Status));
    return Status;
}

VOID
RxSetupNetFileObject(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine is called to finish setting up the fileobject based on the
    information in the Irpcontext.

Arguments:

    RxContext - the current workitem


Return Value:

    none

--*/
{
    RxCaptureParamBlock;
    RxCaptureFileObject;
    RxCaptureFcb;

    PVOID VcbOrFcbOrDcb = RxContext->pFcb;

    PAGED_CODE();

    ASSERT((RxContext->pFobx == NULL) || (NodeType(RxContext->pFobx) == RDBSS_NTC_FOBX));

    if ( VcbOrFcbOrDcb != NULL ) {
        //  Set the Vpb field in the file object, and if we were given an
        //  Fcb or Dcb move the field over to point to the nonpaged Fcb/Dcb
        if (NodeType(VcbOrFcbOrDcb) == RDBSS_NTC_VCB) {
            NOTHING;
        } else {
            //  If this is a temporary file, note it in the FcbState
            if (FlagOn(((PFCB)VcbOrFcbOrDcb)->FcbState, FCB_STATE_TEMPORARY) &&
                (capFileObject != NULL)) {
                SetFlag(capFileObject->Flags, FO_TEMPORARY_FILE);
            }
        }
    }

    //  Now set the fscontext fields of the file object
    if (capFileObject != NULL) {
        capFileObject->FsContext  = VcbOrFcbOrDcb;
        if (RxContext->pFobx != NULL) {
            ULONG_PTR StackBottom,StackTop;

            IoGetStackLimits( &StackTop, &StackBottom);

            // Determine if the FileObject passed in is on the stack. If it is do
            // not squirrel away the file object in the FOBX. Otherwise stash it
            // away.

            if (((ULONG_PTR)capFileObject <= StackBottom) ||
                ((ULONG_PTR)capFileObject >= StackTop)) {

                RxContext->pFobx->AssociatedFileObject = capFileObject;
            } else {

                RxContext->pFobx->AssociatedFileObject = NULL;
            }

            if (RxContext->Create.NtCreateParameters.DfsContext == UIntToPtr(DFS_OPEN_CONTEXT)) {
                SetFlag(RxContext->pFobx->Flags,FOBX_FLAG_DFS_OPEN);
                RxDbgTrace(
                    0,
                    Dbg,
                    ("RxSetupNetFileObject %lx Dfs aware FOBX\n", RxContext->pFobx));
            } else {
                ClearFlag(RxContext->pFobx->Flags,FOBX_FLAG_DFS_OPEN);
                RxDbgTrace(
                    0,
                    Dbg,
                    ("RxSetupNetFileObject %lx Dfs unaware FOBX\n", RxContext->pFobx));
            }

        }

        capFileObject->FsContext2 = RxContext->pFobx;
        capFileObject->SectionObjectPointer = &capFcb->NonPaged->SectionObjectPointers;
        // The create is being completed successfully. Turn off the remaining
        // desired access flags in the IRP. This is required by Praerit/Robert
        // to facilitate policy code.
        if (capPARAMS->Parameters.Create.SecurityContext != NULL) {
            capPARAMS->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess |=
                    capPARAMS->Parameters.Create.SecurityContext->AccessState->RemainingDesiredAccess;
            capPARAMS->Parameters.Create.SecurityContext->AccessState->RemainingDesiredAccess = 0;
        }
    }
}

VOID
RxpPrepareCreateContextForReuse(
    PRX_CONTEXT RxContext)
/*++

Routine Description:

    This routine prepares an instance of RX_CONTEXT for reuse. This centralizes all
    the actions required to be undone, i.e., accquistion of resources etc.

Arguments:

    RxContext - the current workitem

--*/
{
    ASSERT(RxContext->MajorFunction == IRP_MJ_CREATE);

    RxDbgTrace(0, Dbg, ("RxpPrepareCreateContextForReuse canonname %08lx\n",
                                RxContext->Create.CanonicalNameBuffer));
    //the order is important here...release the fcb first
    if (RxContext->Create.FcbAcquired) {
        RxReleaseFcb( RxContext, RxContext->pFcb );
        RxContext->Create.FcbAcquired = FALSE;
    }

    RxFreeCanonicalNameBuffer(RxContext);

    if ((RxContext->Create.pVNetRoot != NULL) ||
        (RxContext->Create.NetNamePrefixEntry != NULL)) {

        PRX_PREFIX_TABLE  pRxNetNameTable
                      = RxContext->RxDeviceObject->pRxNetNameTable;

        RxAcquirePrefixTableLockShared( pRxNetNameTable , TRUE);

        // Dereference the data structures associated with the create operation
        if (RxContext->Create.pVNetRoot != NULL) {
            RxDereferenceVNetRoot((PV_NET_ROOT)(RxContext->Create.pVNetRoot),LHS_SharedLockHeld);
            RxContext->Create.pVNetRoot = NULL;
        }

        RxReleasePrefixTableLock( pRxNetNameTable );
    }
}

NTSTATUS
RxCreateFromNetRoot(
    IN OUT PRX_CONTEXT RxContext,
    IN PUNICODE_STRING RemainingName
    )
/*++

Routine Description:

    This routine is called during from CommonCreate once a good netroot has
    been established. This routine builds an Fcb, if necessary, and tries to
    collapse the open onto an existing open if it can. If it cannot, then it
    constructs an InTransition srv_open on this netroot and passes the open down
    to the minirdr. By the time that we get here, there is a reference on the
    netroot but we do not have the netname tablelock. When we complete the context,
    this reference is removed.

Arguments:

    RxContext - the current workitem

    RemainingName - the name of the file after the netroot prefix is removed;
                    it has been canonicalized.

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/
{
    NTSTATUS    Status;

    PV_NET_ROOT VNetRoot;
    PNET_ROOT   NetRoot;
    PFCB        Fcb;
    PSRV_OPEN   SrvOpen;
    PFOBX       Fobx;

    RxCaptureParamBlock;
    RxCaptureFileObject;

    ACCESS_MASK DesiredAccess;
    ULONG       ShareAccess;
    BOOLEAN     OpenTargetDirectory;

    PNT_CREATE_PARAMETERS cp;

    PAGED_CODE();

    VNetRoot = (PV_NET_ROOT)RxContext->Create.pVNetRoot;
    NetRoot  = (PNET_ROOT)RxContext->Create.pNetRoot;
    Fcb      = NULL;
    SrvOpen  = NULL;
    Fobx     = NULL;

    DesiredAccess = capPARAMS->Parameters.Create.SecurityContext->DesiredAccess
                    & FILE_ALL_ACCESS;
    ShareAccess   = capPARAMS->Parameters.Create.ShareAccess
                    & FILE_SHARE_VALID_FLAGS;

    OpenTargetDirectory = capPARAMS->Flags & SL_OPEN_TARGET_DIRECTORY;

    cp = &RxContext->Create.NtCreateParameters;

    RxDbgTrace(+1, Dbg, ("RxCreateFromNetRoot   Name=%wZ\n", RemainingName ));

    // A Create request cannot succeed without a valid NET_ROOT instance.
    if (RxContext->Create.pNetRoot == NULL){
        RxDbgTrace(-1, Dbg, ("RxCreateFromNetRoot   Couldn't create the FCB: No NetRoot!!\n"));
        return STATUS_NO_SUCH_FILE;
    }

    // we cannot proceed unless this device owns the srvcall.
    if (RxContext->RxDeviceObject != RxContext->Create.pNetRoot->pSrvCall->RxDeviceObject){
        RxDbgTrace(-1, Dbg, ("RxCreateFromNetRoot   wrong DeviceObject!!!!!\n"));
        return STATUS_BAD_NETWORK_PATH;
    }

    // The DFS driver builds up a logical name space from different physical
    // volumes. In order to distinguish processing the DFS driver sets the
    // FsContext2 field to DFS_OPEN_CONTEXT or DFS_DOWWNLEVEL_OPEN_CONTEXT. At
    // this point in the control flow the V_NET_ROOT has been determined. This
    // in turn determines the NET_ROOT and SRV_CALL instance and indirectly
    // also determines the Server type. Uplevel opens can only be permitted to
    // servers that are DFS aware.

    if ((cp->DfsContext  == UIntToPtr(DFS_OPEN_CONTEXT)) &&
        !BooleanFlagOn(NetRoot->pSrvCall->Flags,SRVCALL_FLAG_DFS_AWARE_SERVER)) {
        return STATUS_DFS_UNAVAILABLE;
    }

    if ((cp->DfsContext  == UIntToPtr(DFS_DOWNLEVEL_OPEN_CONTEXT)) &&
        BooleanFlagOn(NetRoot->Flags,NETROOT_FLAG_DFS_AWARE_NETROOT)) {
        return STATUS_OBJECT_TYPE_MISMATCH;
    }

    if (NetRoot->Type == NET_ROOT_PRINT) {
        // allow share read and write to the printer server
        ShareAccess = FILE_SHARE_VALID_FLAGS;
    }

    // if the create request is for opening the target directory for a rename
    // a fake FCB needs to be created.

    if (OpenTargetDirectory) {
        if (cp->DesiredAccess & DELETE) {
            RxPurgeRelatedFobxs(
                              VNetRoot->NetRoot,
                              RxContext,
                              ATTEMPT_FINALIZE_ON_PURGE,
                              NULL);
        }

        Fcb = RxCreateNetFcb( RxContext, VNetRoot, RemainingName );

        if (Fcb != NULL) {
            Fcb->Header.NodeTypeCode = (USHORT)RDBSS_NTC_OPENTARGETDIR_FCB;
            RxContext->Create.FcbAcquired = FALSE;

            // Normally the FileObjects reference the associated SRV_OPEN instance
            // via the FileObjectExtension(FOBX). In this case there is no
            // corresponding SRV_OPEN and a reference on the FCB is maintained.

            RxContext->Create.NetNamePrefixEntry = NULL; //don't let it deref the netroot!!!!

            capFileObject->FsContext = Fcb;

            if (RxContext->pFobx != NULL) {
                if (capFileObject->FsContext2 == UIntToPtr(DFS_OPEN_CONTEXT)) {
                    SetFlag(RxContext->pFobx->Flags,FOBX_FLAG_DFS_OPEN);
                } else {
                    ClearFlag(RxContext->pFobx->Flags,FOBX_FLAG_DFS_OPEN);
                }
            }

            capFileObject->FsContext2 = NULL;

            Fcb->UncleanCount++;
            Fcb->OpenCount++;

            Status = RxAcquireExclusiveFcb( RxContext, Fcb );
            if (Status == STATUS_SUCCESS) {
                RxReferenceNetFcb(Fcb);
                RxReleaseFcb( RxContext, Fcb);
            } else {
                RxDbgTrace(-1, Dbg, ("RxCreateFromNetRoot -- Couldn't acquire FCB:(%lx) %lx!\n",Fcb,Status));
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        return Status;
    }

    Status = RxFindOrCreateFcb(RxContext,RemainingName);
    DbgDoit(
        if (RxContext->pFcb == NULL) {
            ASSERT(Status != STATUS_SUCCESS);
        }
    )

    if ( (Status != STATUS_SUCCESS) || (RxContext->pFcb == NULL) ) {

        RxDbgTrace(-1, Dbg, ("RxCreateFromNetRoot   Couldn't create the FCB%c\n", '!' ));
        return Status;
    }

    Fcb = (PFCB)(RxContext->pFcb);

    // If the Create request is for a mailslot no further processing is required.

    if (RxContext->Flags & RX_CONTEXT_FLAG_CREATE_MAILSLOT) {
        Fcb->Header.NodeTypeCode = (USHORT)RDBSS_NTC_MAILSLOT;
    } else {
        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (Status == STATUS_SUCCESS) {
        RxTransitionNetFcb(Fcb,Condition_Good);
        RxLog(("Transitioning FCB %lx Condition %lx\n",Fcb,Fcb->Condition));
        RxWmiLog(LOG,
                 RxCollapseOrCreateSrvOpen,
                 LOGPTR(Fcb)
                 LOGULONG(Fcb->Condition));

        Fcb->OpenCount++;
        RxSetupNetFileObject( RxContext );
        return Status;
    }

    // This Create request is for a file/directory or pipe for which further
    // processing is required. At this point the corresponding FCB resource
    // has been accquired ( even for newly constructed FCB's). If this is not the
    // first open then those requests that do not meet the necessary share access
    // constraints can be rejected quickly. Note that this early check avoids
    // a potential Network trip in some cases.

    RxDumpCurrentAccess("shareaccess status before anything....","","DumpAcc000",&Fcb->ShareAccess);
    if (Fcb->OpenCount > 0) {
        Status = RxCheckShareAccess(
                     DesiredAccess,
                     ShareAccess,
                     capFileObject,
                     &Fcb->ShareAccess,
                     FALSE,
                     "early check per useropens","EarlyPerUO" );

        if (Status != STATUS_SUCCESS) {
            RxDereferenceNetFcb(Fcb);
            return (Status);
        }
    }

    if ((cp->CreateOptions & FILE_DELETE_ON_CLOSE) &&
        (cp->DesiredAccess & ~DELETE) == 0) {

        // if the file is opened for delete only, we push out possible delayed close on this file
        // so that mini rdr has the opportunity to do the perfomance optimization, i.e. delete the
        // file without even open it.
        RxPurgeFcbInSystemCache(
            Fcb,
            NULL,
            0,
            TRUE,
            FALSE);
        RxScavengeRelatedFobxs(Fcb);
    }

    // A valid FCB which meets the Share access requirements of the create
    // request is on hand. The associated SRV_OPEN should be either located
    // amongst the existing SRV_OPEN's or a new SRV_OPEN instance needs to
    // be constructed.

    try {
        ULONG   CreateOptions;
        BOOLEAN DeleteOnClose;
        BOOLEAN NoIntermediateBuffering;

        Status = RxCollapseOrCreateSrvOpen(RxContext);

        IF_DEBUG {
            if (Status == STATUS_SUCCESS) {
                RxDbgTrace(0, Dbg, ("RxCreateFromNetRoot   Collapsed onto %08lx\n",
                                   RxContext->pRelevantSrvOpen ));
            } else {
                RxDbgTrace(0, Dbg, ("RxCreateFromNetRoot   Error in Srvopen Collapse %08lx\n", Status ));
            }
        }

        if (Status != STATUS_SUCCESS) {
            try_return( Status );
        }


        SrvOpen = (PSRV_OPEN)(RxContext->pRelevantSrvOpen);
        Fobx    = (PFOBX)(RxContext->pFobx);

        CreateOptions    = capPARAMS->Parameters.Create.Options;
        NoIntermediateBuffering = BooleanFlagOn( CreateOptions, FILE_NO_INTERMEDIATE_BUFFERING );
        DeleteOnClose           = BooleanFlagOn( CreateOptions, FILE_DELETE_ON_CLOSE );

        // If the FCB has multiple SRV_OPEN instances associated with it then it
        // is possible for the Share access associated with the FCB has changed
        // if the FCB resource was dropped by the mini redirector.

        if (Fcb->OpenCount > 0) {
            Status = RxCheckShareAccess(
                         DesiredAccess,
                         ShareAccess,
                         capFileObject,
                         &Fcb->ShareAccess,
                         FALSE,
                         "second check per useropens","2ndAccPerUO" );

            if (Status != STATUS_SUCCESS) {
            
                //
                //  When this Fobx goes away it will remove an open from the SrvOpen.
                //  Add a reference to the SrvOpen here to account for this.  This
                //  will prevent the SrvOpen from getting closed prematurely.
                //

                SrvOpen->OpenCount++;
            
                RxDereferenceNetFobx(RxContext->pFobx,LHS_LockNotHeld);
                RxContext->pFobx = NULL;
                try_return (Status);
            }
        } else {
            if (RxContext->Create.pNetRoot->Type != NET_ROOT_PIPE) {
                RxSetShareAccess(
                    DesiredAccess,
                    ShareAccess,
                    capFileObject,
                    &Fcb->ShareAccess,
                    "initial shareaccess setup","InitShrAcc");
            }
        }

        RxSetupNetFileObject( RxContext );

        RxDumpCurrentAccess(
            "shareaccess status after checkorset....",
            "",
            "CurrentAcc",
            &Fcb->ShareAccess);

        // At this point the necessary infrastructure to handle the create
        // request successfully has been established. What remains to be done
        // is the appropriate initialization of the FileObject( owned by IO
        // subsystem), the FileObjectExtension(FOBX owned by RDBSS) and updating
        // the fields associated with the SRV_OPEN and the FCB. This largely
        // depends upon whether the FCB/SRV_OPEN was newly constructed or
        // was collapsed.
        //
        // SRV_OPEN changes
        //     1) For a newly constructed SRV_OPEN the buffering state needs to
        //        be updated
        //
        // FCB changes
        //     1) for an existing FCB the SHARE ACCESS needs to be updated.
        //
        // In all the cases the corresponing OpenCounts and UncleanCounts needs
        // to be updated.
        //

        if ((Fcb->OpenCount > 0) &&
            (RxContext->Create.pNetRoot->Type != NET_ROOT_PIPE)) {
            RxUpdateShareAccess(
                capFileObject,
                &Fcb->ShareAccess,
                "update share access",
                "UpdShrAcc" );
        }

        //incrementing the uncleancount must be done before RxChangeBufferingState
        //because that routine will purge the cache otherwise if unclenacount==0

        Fcb->UncleanCount++;

        if (FlagOn(capFileObject->Flags,FO_NO_INTERMEDIATE_BUFFERING)) {
            Fcb->UncachedUncleanCount++;
        } else {
            //maybe we should turn on the FO_CACHE_SUPPORTED flag
        }

        // For the first open, we want to initialize the Fcb buffering state flags
        // to the default value
        if ( (SrvOpen->OpenCount == 0) &&
             (Fcb->UncleanCount == 1)  &&
             (!FlagOn(SrvOpen->Flags,SRVOPEN_FLAG_NO_BUFFERING_STATE_CHANGE)) ) {
             RxChangeBufferingState(SrvOpen,NULL,FALSE);
        }

        //  this might be from a previous usage.
        ClearFlag(Fcb->FcbState, FCB_STATE_DELAY_CLOSE);

        // Reference the Objects as needed
        Fcb->OpenCount++;
        SrvOpen->UncleanFobxCount++;
        SrvOpen->OpenCount++;

        SrvOpen->ulFileSizeVersion = Fcb->ulFileSizeVersion;
        
        // For NoIntermediateBuffering opens, we need to disable cacheing on
        // this FCB
        if( NoIntermediateBuffering )
        {
           SetFlag( SrvOpen->Flags, SRVOPEN_FLAG_DONTUSE_READ_CACHEING );
           SetFlag( SrvOpen->Flags, SRVOPEN_FLAG_DONTUSE_WRITE_CACHEING );
           ClearFlag( Fcb->FcbState, FCB_STATE_READCACHEING_ENABLED );
           ClearFlag( Fcb->FcbState, FCB_STATE_WRITECACHEING_ENABLED );
           RxPurgeFcbInSystemCache( Fcb, NULL, 0, TRUE, TRUE );
        }

        RxUpdateShareAccessPerSrvOpens(SrvOpen);


        // The file object extensions needs to be updated with configuration
        // information for pipes and spool files. In addition the appropriate
        // flags needs to be set based upon the parameters specfied in the
        // request.
        // For spool files the WriteSerializationQueue is the only field of
        // interest.

        //  Mark the DeleteOnClose bit if the operation was successful.
        if ( DeleteOnClose ) {
            SetFlag( Fobx->Flags, FOBX_FLAG_DELETE_ON_CLOSE );
        }

        if (Fobx != NULL) {

            // fill in various type-specific fields of the fobx

            switch (RxContext->Create.pNetRoot->Type) {

            case NET_ROOT_PIPE:
                capFileObject->Flags |= FO_NAMED_PIPE;
                //lack of break intentional

            case NET_ROOT_PRINT:
                Fobx->PipeHandleInformation = &Fobx->Specific.NamedPipe.PipeHandleInformation;
                Fobx->Specific.NamedPipe.CollectDataTime.QuadPart = 0;
                Fobx->Specific.NamedPipe.CollectDataSize
                              = RxContext->Create.pNetRoot->NamedPipeParameters.DataCollectionSize;
                Fobx->Specific.NamedPipe.TypeOfPipe      = RxContext->Create.PipeType;
                Fobx->Specific.NamedPipe.ReadMode        = RxContext->Create.PipeReadMode;
                Fobx->Specific.NamedPipe.CompletionMode  = RxContext->Create.PipeCompletionMode;
                InitializeListHead(&Fobx->Specific.NamedPipe.ReadSerializationQueue);
                InitializeListHead(&Fobx->Specific.NamedPipe.WriteSerializationQueue);
                break;

            default:

		
                NOTHING;
            }
        }

try_exit: NOTHING;

    } finally {

        RxDbgTrace(0, Dbg, ("--->Fobx=%08lx, Ref=%08lx\n", Fobx, (Fobx)?Fobx->NodeReferenceCount:0 ));
        RxDbgTrace(0, Dbg, ("--->SrvOpen=%08lx, Ref=%08lx\n", SrvOpen, (SrvOpen)?SrvOpen->NodeReferenceCount:0 ));
        RxDbgTrace(0, Dbg, ("--->Fcb=%08lx, Ref=%08lx\n", Fcb, (Fcb)?Fcb->NodeReferenceCount:0 ));

        //get rid of the reference on the fcb; we also finalize here if we can

        if (Fcb->OpenCount == 0) {

            // if we have the lock we can finalize.........

            if (RxContext->Create.FcbAcquired) {

                //try to finalize right now

                RxContext->Create.FcbAcquired = !RxDereferenceAndFinalizeNetFcb(Fcb,RxContext,FALSE,FALSE);

                //the tracker gets very unhappy if you don't do this!
                if (!RxContext->Create.FcbAcquired) {
                    RxTrackerUpdateHistory(RxContext,NULL,'rrCr',__LINE__,__FILE__,0);
                }
            }

        } else {

            //cant finalize now.....just remove our reference.......

            RxDereferenceNetFcb(Fcb);

        }

    }

    RxDbgTrace(-1, Dbg, ("Exiting RxCreateFromNetRoot status=%08lx\n", Status));

    return(Status);
}


NTSTATUS
RxPrefixClaim (
    IN  PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine handles the call down from the MUP to claim a name. We pass the name down
    to the routine for finding/creating connections.

Arguments:

    IN PRX_CONTEXT RxContext - Describes the ioctl and Context

Return Value:

RXSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureRequestPacket;
    RxCaptureParamBlock;

    PQUERY_PATH_REQUEST  qpRequest;
    PQUERY_PATH_RESPONSE qpResponse;
    UNICODE_STRING       FilePathName;
    UNICODE_STRING       CanonicalName;
    UNICODE_STRING       RemainingName;

    NET_ROOT_TYPE NetRootType = NET_ROOT_WILD;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("RxPrefixClaim -> %08lx\n", 0));

    //
    // Initialize RemainingName.
    //
    RemainingName.Buffer = NULL;
    RemainingName.Length = 0;
    RemainingName.MaximumLength = 0;

    if (capReqPacket->RequestorMode == UserMode) {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        return Status;
    }

    qpResponse = METHODNEITHER_OriginalOutputBuffer(capReqPacket);

    if (RxContext->MajorFunction == IRP_MJ_DEVICE_CONTROL) {
        qpRequest  = METHODNEITHER_OriginalInputBuffer(capPARAMS);

        RxContext->MajorFunction = IRP_MJ_CREATE;

        RxContext->PrefixClaim.SuppliedPathName.Buffer =
            (PWCHAR)RxAllocatePoolWithTag(
                        NonPagedPool,
                        qpRequest->PathNameLength,
                        RX_MISC_POOLTAG);

        if (RxContext->PrefixClaim.SuppliedPathName.Buffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }

        RtlCopyMemory(
            RxContext->PrefixClaim.SuppliedPathName.Buffer,
            qpRequest->FilePathName,
            qpRequest->PathNameLength);

        RxContext->PrefixClaim.SuppliedPathName.Length =
            (USHORT)qpRequest->PathNameLength;

        RxContext->PrefixClaim.SuppliedPathName.Length =
            (USHORT)qpRequest->PathNameLength;

        RtlZeroMemory(
            &RxContext->Create,
            sizeof(RxContext->Create));

        RxContext->Create.ThisIsATreeConnectOpen = TRUE;
        RxContext->Create.NtCreateParameters.SecurityContext =
            qpRequest->SecurityContext;
    } else {
        ASSERT(RxContext->MajorFunction == IRP_MJ_CREATE);
        ASSERT(RxContext->PrefixClaim.SuppliedPathName.Buffer != NULL);
    }

    FilePathName  = RxContext->PrefixClaim.SuppliedPathName;
    RemainingName = FilePathName;

    Status = RxFirstCanonicalize(
                 RxContext,
                 &FilePathName,
                 &CanonicalName,
                 &NetRootType);

    if (Status == STATUS_SUCCESS) {

        Status = RxFindOrConstructVirtualNetRoot(
                     RxContext,
                     &CanonicalName,
                     NetRootType,
                     &RemainingName);

    }

FINALLY:

    if (Status != STATUS_PENDING) {
        if (Status == STATUS_SUCCESS) {
            qpResponse->LengthAccepted =
                RxContext->PrefixClaim.SuppliedPathName.Length -
                RemainingName.Length;
        }

        if (RxContext->MajorFunction == IRP_MJ_CREATE) {
            if (RxContext->PrefixClaim.SuppliedPathName.Buffer != NULL) {
                RxFreePool(RxContext->PrefixClaim.SuppliedPathName.Buffer);
            }

            RxpPrepareCreateContextForReuse(RxContext);

            RxContext->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        }
    }

    RxDbgTrace(0, Dbg, ("RxPrefixClaim -> Status %08lx\n", Status));

    return Status;
}

NTSTATUS
RxCreateTreeConnect (
    RXCOMMON_SIGNATURE
    )
/*++

Routine Description:

    This is the routine for creating/opening a TC.

Arguments:

    RXCOMMON_SIGNATURE - the normal common arguments

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    UNICODE_STRING     CanonicalName,RemainingName;
    PUNICODE_STRING    OriginalName = &capFileObject->FileName;
    LOCK_HOLDING_STATE LockHoldingState = LHS_LockNotHeld;

    NET_ROOT_TYPE NetRootType = NET_ROOT_WILD;

    ULONG EaInformationLength;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCreateTreeConnect entry\n"));

    CanonicalName.Length = CanonicalName.MaximumLength = 0;
    CanonicalName.Buffer = NULL;

    Status = RxFirstCanonicalize(
                 RxContext,
                 OriginalName,
                 &CanonicalName,
                 &NetRootType);

    if (Status!=STATUS_SUCCESS) {
        RxDbgTraceUnIndent(-1,Dbg);
        return(Status);
    }

    RxContext->Create.ThisIsATreeConnectOpen = TRUE;
    RxContext->Create.TreeConnectOpenDeferred = FALSE;

    RxContext->Create.TransportName.Length = 0;
    RxContext->Create.TransportName.MaximumLength = 0;
    RxContext->Create.TransportName.Buffer = NULL;

    RxContext->Create.UserName.Length = 0;
    RxContext->Create.UserName.MaximumLength = 0;
    RxContext->Create.UserName.Buffer = NULL;

    RxContext->Create.Password.Length = 0;
    RxContext->Create.Password.MaximumLength = 0;
    RxContext->Create.Password.Buffer = NULL;

    RxContext->Create.UserDomainName.Length = 0;
    RxContext->Create.UserDomainName.MaximumLength = 0;
    RxContext->Create.UserDomainName.Buffer = NULL;

    EaInformationLength = capPARAMS->Parameters.Create.EaLength;
    if (EaInformationLength > 0) {
        BOOLEAN DeferredConnection = FALSE;
        BOOLEAN CredentialsSupplied = FALSE;

        PFILE_FULL_EA_INFORMATION pEaEntry;

        pEaEntry = (PFILE_FULL_EA_INFORMATION)capReqPacket->AssociatedIrp.SystemBuffer;
        ASSERT(pEaEntry != NULL);

        for(;;) {
            PUNICODE_STRING pTargetStringPtr;

            if (strcmp(pEaEntry->EaName, EA_NAME_CONNECT) == 0) {
                DeferredConnection = TRUE;
            } else if ((strcmp(pEaEntry->EaName, EA_NAME_USERNAME) == 0) ||
                       (strcmp(pEaEntry->EaName, EA_NAME_PASSWORD) == 0) ||
                       (strcmp(pEaEntry->EaName, EA_NAME_DOMAIN) == 0)) {
                CredentialsSupplied = TRUE;
            }

            pTargetStringPtr = NULL;

            RxDbgTrace(0,Dbg,("RxCreateTreeConnect: Processing EA name %s\n",
                            pEaEntry->EaName));

            if (strcmp(pEaEntry->EaName, EA_NAME_TRANSPORT) == 0) {
                pTargetStringPtr = &RxContext->Create.TransportName;
            } else if (strcmp(pEaEntry->EaName, EA_NAME_USERNAME) == 0) {
                pTargetStringPtr = &RxContext->Create.UserName;
            } else if (strcmp(pEaEntry->EaName, EA_NAME_PASSWORD) == 0) {
                pTargetStringPtr = &RxContext->Create.Password;
            } else if (strcmp(pEaEntry->EaName, EA_NAME_DOMAIN) == 0) {
                pTargetStringPtr = &RxContext->Create.UserDomainName;
            } else {
                RxDbgTrace(0,Dbg,("RxCreateTreeConnect: Invalid EA name/value %s\n",
                                             pEaEntry->EaName));
            }

            if (pTargetStringPtr != NULL) {
                pTargetStringPtr->Length        = pEaEntry->EaValueLength;
                pTargetStringPtr->MaximumLength = pEaEntry->EaValueLength;
                pTargetStringPtr->Buffer        = (PWSTR)(pEaEntry->EaName + pEaEntry->EaNameLength + 1);
            }

            if (pEaEntry->NextEntryOffset == 0) {
                break;
            } else {
                pEaEntry = (PFILE_FULL_EA_INFORMATION)
                           ((PCHAR) pEaEntry + pEaEntry->NextEntryOffset);
            }
        }

        if (!CredentialsSupplied && DeferredConnection) {
            RxContext->Create.TreeConnectOpenDeferred = TRUE;
        }
    }

    Status = RxFindOrConstructVirtualNetRoot( RxContext,
                                              &CanonicalName,
                                              NetRootType,
                                              &RemainingName );

    if(Status == STATUS_NETWORK_CREDENTIAL_CONFLICT) {
        // Scavenge the VNetRoots
        RxScavengeVNetRoots(RxContext->RxDeviceObject);

        Status = RxFindOrConstructVirtualNetRoot(
                    RxContext,
                    &CanonicalName,
                    NetRootType,
                    &RemainingName);
    }


    // We have to check whether the path is valid if it is provided.
    if ((Status == STATUS_SUCCESS) && (RemainingName.Length > 0)) {
        MINIRDR_CALL(Status,
                     RxContext,
                     RxContext->Create.pNetRoot->pSrvCall->RxDeviceObject->Dispatch,
                     MRxIsValidDirectory,
                     (RxContext,&RemainingName)
                     );
    }

    if (Status == STATUS_SUCCESS) {
        BOOLEAN TakeAdditionalReferenceOnVNetRoot = FALSE;
        PV_NET_ROOT pVNetRoot = (PV_NET_ROOT)RxContext->Create.pVNetRoot;

        RxReferenceVNetRoot(pVNetRoot);

        TakeAdditionalReferenceOnVNetRoot =
            (InterlockedCompareExchange(
                &pVNetRoot->AdditionalReferenceForDeleteFsctlTaken,
                1,
                0) == 0);

        if ( !TakeAdditionalReferenceOnVNetRoot ) {
            // The net use connections have a two phase delete protocol. An FSCTL to
            // delete the connection is used followed by a close of the corresponding file
            // object. The additional reference ensures that the finalization is delayed till
            // the actual close of the correspomnding file object.

            RxDereferenceVNetRoot(pVNetRoot,LHS_LockNotHeld);
        }

        capFileObject->FsContext  = &RxDeviceFCB;
        capFileObject->FsContext2 = RxContext->Create.pVNetRoot;

        pVNetRoot->IsExplicitConnection = TRUE;
        RxContext->Create.pVNetRoot->NumberOfOpens++;

        RxContext->Create.pVNetRoot = NULL;
        RxContext->Create.pNetRoot  = NULL;
        RxContext->Create.pSrvCall  = NULL;
    }

    RxDbgTrace(-1, Dbg, ("RxCreateTreeConnect exit, status=%08lx\n", Status));
    return Status;
}

NTSTATUS
RxPrepareToReparseSymbolicLink(
     PRX_CONTEXT     RxContext,
     BOOLEAN         SymbolicLinkEmbeddedInOldPath,
     PUNICODE_STRING pNewPath,
     BOOLEAN         NewPathIsAbsolute,
     BOOLEAN         *pReparseRequired)
/*++

Routine Description:

    This routine sets up the file object name to facilitate a reparse. This routine
    is used by the mini redirectors to traverse symbolic links.

Arguments:

    RxContext - the RDBSS context

    SymbolicLinkEmbeddedInOldPath - if TRUE a symbolic link was encountered as part of the
                traversal of the old path.

    pNewPath  - the new path name to be traversed.

    NewPathIsAbsolute - if FALSE, \Device\Mup should be prepended to pNewPath. If TRUE,
                pNewPath is the full path to which to reparse. In this case, the buffer
                containing pNewPath is used directly, rather than allocating a new one.

    pReparseRequired - set to TRUE if Reparse is required.

Return Value:

    NTSTATUS - the return status for the operation

Notes:

    The second parameter passed to this routine is a very important one. In order
    to preserve the correct semantics it should be carefully used. As an example
    consider the old path \A\B\C\D wherein C happens to be symbolic link. In such
    cases the symbolic link is embedded in the path as opposed to the case when
    D happens to be a symbolic link. In the former case the reparse constitutes
    an intermediate step as opposed to the later case when it constitutes the
    final step of the name resolution.

    If DELETE access is specified the OPEN is denied for all in which the symbolic
    link is not embedded. It is possible that if DELETE access were the only one
    specified then the OPEN attempt must succeed without reparse. This will be
    conformant with UNIX symbolic link semantics.

    As part of this routine the RxContext is also tagged appropriately. This ensures
    that the return value can be crosschecked with the invocation of this routine.
    Once this routine is invoked the mini rdr has to return STATUS_REPARSE.

    The value of *pReparseRequired assumes significance only if STATUS_SUCCESS is
    returned from this routine. FALSE implies that no reparse attempt is required
    and the symbolic link file itself should be manipulated as opposed to the
    target of the link. TRUE implies that a reparse attempt was successfully setup.
    In such cases it is imperative that the mini redirector return STATUS_REPARSE
    for the associated MRxCreate call. The wrapper will initiate a check for this.

--*/
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    *pReparseRequired = FALSE;

    if (RxContext->MajorFunction == IRP_MJ_CREATE) {
        ACCESS_MASK DesiredAccess = RxContext->Create.NtCreateParameters.DesiredAccess;

        Status = STATUS_SUCCESS;

        // Check the Create Parameters to determine the type of ACCESS specified.
        // if only DELETE access was specified then no reparse is required and the
        // operation is to be performed on the link itself.
        if (!SymbolicLinkEmbeddedInOldPath) {
            RxDbgTrace(0, Dbg, ("Desired Access In Reparse %lx\n",DesiredAccess));
            if (DesiredAccess & DELETE) {
                *pReparseRequired = FALSE;
                if (DesiredAccess & ~DELETE) {
                    Status = STATUS_ACCESS_DENIED;
                }
            } else {
                // If the appropriate flags were specified in the CREATE parameters then
                // the reparse is to be suppressed since the intention is to open the link
                // itself as opposed to the TARGET.
                // TBD. -- The exact combination of flags will be determined for NT 5.0.

                // If none of the above conditions were satisfied then the reparse is required
                *pReparseRequired = TRUE;
            }
        } else {
            *pReparseRequired = TRUE;
        }

        if (*pReparseRequired) {
            PWSTR  pFileNameBuffer;
            USHORT DeviceNameLength,ReparsePathLength;

            if (!NewPathIsAbsolute) {

                DeviceNameLength = wcslen(DD_MUP_DEVICE_NAME) * sizeof(WCHAR);

                // On a reparse attempt the I/O subsystem will null out the related file
                // object field.

                ReparsePathLength = (DeviceNameLength + pNewPath->Length);

                pFileNameBuffer = ExAllocatePoolWithTag(
                                      PagedPool | POOL_COLD_ALLOCATION ,
                                      ReparsePathLength,
                                      RX_MISC_POOLTAG);

                if (pFileNameBuffer != NULL) {
                    // Copy the device name
                    RtlCopyMemory(
                        pFileNameBuffer,
                        DD_MUP_DEVICE_NAME,
                        DeviceNameLength);

                    // Copy the new name
                    RtlCopyMemory(
                        ((PBYTE)pFileNameBuffer + DeviceNameLength),
                        pNewPath->Buffer,
                        pNewPath->Length);

                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }

            } else {
                pFileNameBuffer = pNewPath->Buffer;
                ReparsePathLength = pNewPath->Length;
            }

            // Free up the buffer associated with the old name.
            ExFreePool(capFileObject->FileName.Buffer);

            // Set up the file object with the new name.
            capFileObject->FileName.Buffer = pFileNameBuffer;
            capFileObject->FileName.Length = ReparsePathLength;
            capFileObject->FileName.MaximumLength = capFileObject->FileName.Length;

            // Mark the RxContext so that the return code can be verified. A mini
            // redirector has to return STATUS_REPARSE is this routine was invoked
            // as a response to MRxCreate. This will be enforced by marking the
            // RxContext appropriately and comparing the returned status code against
            // the expected value.
            SetFlag(RxContext->Create.Flags,RX_CONTEXT_CREATE_FLAG_REPARSE);
        }
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    RxDbgTrace(0, Dbg, ("RxPrepareToReparseSymbolicLink : ReparseReqd: %lx, Status %lx\n",*pReparseRequired,Status));
    return Status;
}

NTSTATUS
RxCommonCreate ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This is the common routine for creating/opening a file called by
    both the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - the return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    UNICODE_STRING RemainingName;

    PAGED_CODE();

#if 0 && defined(REMOTE_BOOT)
    {
        PWCH buffer = ExAllocatePoolWithTag( NonPagedPool, capFileObject->FileName.Length + 2,RX_MISC_POOLTAG );
        //PWCH b2;
        BOOLEAN watchFile = FALSE;
        BOOLEAN logFile = FALSE;
        if ( buffer != NULL ) {
            RtlCopyMemory( buffer, capFileObject->FileName.Buffer, capFileObject->FileName.Length );
            buffer[capFileObject->FileName.Length/sizeof(WCHAR)] = 0;
            //b2 = wcsstr(buffer,L"\\IMirror\\");
            //if ( b2 != NULL ) {
            //    b2 += wcslen(L"\\IMirror\\");
            //    if ( (*b2 != 0) &&
            //         (wcsstr(b2,L"Clients") == NULL) &&
            //         (wcsstr(b2,L"CLIENTS") == NULL) &&
            //         (wcsstr(b2,L"Setup") == NULL) &&
            //         (wcsstr(b2,L"SETUP") == NULL) ) {
            //        logFile = TRUE;
            //    }
            //}
            //if ( (wcsstr(buffer,L"%systemroot%") != NULL) || (wcsstr(buffer,L"%SystemRoot%") != NULL) ) {
            //    watchFile = TRUE;
            //}
            //if ( (wcsstr(buffer,L"msvcrt20") != NULL) || (wcsstr(buffer,L"MSVCRT20") != NULL) ) {
            //    if (capPARAMS->Parameters.Create.SecurityContext->DesiredAccess & FILE_WRITE_ATTRIBUTES) {
            //        watchFile = TRUE;
            //    }
            //}
            if ( WatchAllFiles ) watchFile = TRUE;
            if ( watchFile && (!FirstWatchOnly || IsFirstWatch) ) {
                logFile = TRUE;
                IsFirstWatch = FALSE;
            }
            if ( LogAllFiles ) logFile = TRUE;
            if ( logFile ) {
                DbgPrint( "RxCommonCreate: create IRP for %ws %x\n", buffer, capFileObject );
            }
            if ( watchFile || (0 && logFile) ) {
                //DbgBreakPoint();
            }
            ExFreePool(buffer);
        }
    }
#endif // defined(REMOTE_BOOT)

    // check for the case of a device open; if so, handle and get out now
    if ( (capFileObject->FileName.Length == 0)  &&
         (capFileObject->RelatedFileObject == NULL)        ) {

        //here we are just opening the device; set the FsContext&counts and get out

        capFileObject->FsContext = &RxDeviceFCB;
        capFileObject->FsContext2 = NULL;
        RxDeviceFCB.OpenCount++;
        RxDeviceFCB.UncleanCount++;

        capReqPacket->IoStatus.Information = FILE_OPENED;

        RxDbgTrace(0, Dbg, ("RxDeviceCreate, File = %08lx\n", capFileObject));


        RxLog(("DevOpen %lx %lx %lx",RxContext,capFileObject,RxContext->RxDeviceObject));
        RxLog(("DevOpen2 %wZ",&RxContext->RxDeviceObject->DeviceName));
        RxWmiLog(LOG,
                 RxCommonCreate_1,
                 LOGPTR(RxContext)
                 LOGPTR(capFileObject)
                 LOGPTR(RxContext->RxDeviceObject)
                 LOGUSTR(RxContext->RxDeviceObject->DeviceName));

        return STATUS_SUCCESS;
    }

    if ((capPARAMS->Parameters.Create.Options & FILE_STRUCTURED_STORAGE) ==
    FILE_STRUCTURED_STORAGE) {

    // FILE_STRUCTURED_STORAGE is used by NSS for structured storage
    // opens.  Blocking this disables NSS access across the network.
    //
    // Note that FILE_COPY_STRUCTURED_STORAGE should not be blocked, as
    // it is needed by CopyFile

    return STATUS_INVALID_PARAMETER;
    }


    //
    // Init the file name that will trigger the trace to start.
    // To trigger on a different file edit DbgTriggerName with debugger (don't
    // forget the null).  Set DbgTriggerIrpCount to number of IRPs to trace and
    // then set DbgTriggerState to 0.
    //

    RxDbgTraceDoit(
        if (DbgTriggerState == DBG_TRIGGER_INIT) {
            DbgTriggerState = DBG_TRIGGER_LOOKING;
            DbgTriggerNameStr.Length = (USHORT)strlen(DbgTriggerName);
            DbgTriggerNameStr.MaximumLength = (USHORT)strlen(DbgTriggerName);
            DbgTriggerNameStr.Buffer = &DbgTriggerName[0];

            RtlAnsiStringToUnicodeString(&DbgTriggerUStr, &DbgTriggerNameStr, TRUE);
        }
    );

    //
    // If we find a match on the open file name the enable tracing for the
    // next DbgTriggerIrpCount's worth of IRPs.
    //
    RxDbgTraceDoit(
        if ((DbgTriggerState == DBG_TRIGGER_LOOKING) &&
            RtlEqualUnicodeString(&DbgTriggerUStr, &capFileObject->FileName, TRUE)) {
            DbgTriggerState = DBG_TRIGGER_FOUND;
            RxGlobalTraceIrpCount = DbgTriggerIrpCount;
            RxGlobalTraceSuppress = FALSE;
        }
    );

    RxDbgTrace(+1, Dbg, ("RxCommonCreate\n", 0 ));
    RxDbgTrace( 0, Dbg, ("Irp                        = %08lx\n", capReqPacket ));
    RxDbgTrace( 0, Dbg, ("->IrpFlags                 = %08lx\n", capReqPacket->Flags ));
    RxDbgTrace( 0, Dbg, ("->FileObject(Related)     = %08lx %08lx\n",     //ok4->FileObj
                                 capFileObject,
                                 capFileObject->RelatedFileObject ));
    RxDbgTrace( 0, Dbg, (" ->FileName        = (%lx) %wZ\n",
                                 capFileObject->FileName.Length,
                                 &capFileObject->FileName ));
    RxDbgTrace( 0, Dbg, ("->AllocationSize(Lo/Hi)    = %08lx %08lx\n",
                                 capReqPacket->Overlay.AllocationSize.LowPart,
                                 capReqPacket->Overlay.AllocationSize.HighPart ));
    RxDbgTrace( 0, Dbg, ("->DesiredAccess/Options    = %08lx %08lx\n",
                                 capPARAMS->Parameters.Create.SecurityContext->DesiredAccess,
                                 capPARAMS->Parameters.Create.Options ));
    RxDbgTrace( 0, Dbg, ("->Attribs/ShrAccess/SPFlags= %04x %04lx %08lx\n",
                                  capPARAMS->Parameters.Create.FileAttributes,
                                  capPARAMS->Parameters.Create.ShareAccess,
                                  capPARAMS->Flags ));

    RxLog(("Open %lx %lx %lx %lx %lx %lx %lx\n",
        RxContext,capFileObject, //1,2
        capPARAMS->Parameters.Create.Options,                       //3
        capPARAMS->Flags,                                           //4
        capPARAMS->Parameters.Create.FileAttributes,                //5
        capPARAMS->Parameters.Create.ShareAccess,                   //6
        capPARAMS->Parameters.Create.SecurityContext->DesiredAccess //7
    ));
    RxWmiLog(LOG,
             RxCommonCreate_2,
             LOGPTR(RxContext)
             LOGPTR(capFileObject)
             LOGULONG(capPARAMS->Parameters.Create.Options)
             LOGUCHAR(capPARAMS->Flags)
             LOGXSHORT(capPARAMS->Parameters.Create.FileAttributes)
             LOGXSHORT(capPARAMS->Parameters.Create.ShareAccess)
             LOGULONG(capPARAMS->Parameters.Create.SecurityContext->DesiredAccess));

    RxLog((" fn %wZ\n", &capFileObject->FileName));
    RxWmiLog(LOG,
             RxCommonCreate_3,
             LOGUSTR(capFileObject->FileName));

    if (capFileObject->RelatedFileObject){
        PFCB RelatedFcb = (PFCB)(capFileObject->RelatedFileObject->FsContext);
        RxDbgTrace( 0, Dbg, (" ->RelatedFileName        = %wZ\n",
                                     &(RelatedFcb->FcbTableEntry.Path) ));
        RxLog((
            " relat %lx %wZ\n",
            capFileObject->RelatedFileObject,
            &(RelatedFcb->FcbTableEntry.Path)));
        RxWmiLog(LOG,
                 RxCommonCreate_4,
                 LOGPTR(capFileObject->RelatedFileObject)
                 LOGUSTR(RelatedFcb->FcbTableEntry.Path));
    }

    if (capPARAMS->Flags&SL_OPEN_TARGET_DIRECTORY) {
        RxDbgTrace( 0, Dbg, (" ->OpenTargetDirectory\n"));
        RxLog((" OpenTargetDir!\n"));
        RxWmiLog(LOG,
                 RxCommonCreate_5,
                 LOGULONG(Status));
    }


    RxCopyCreateParameters(RxContext);

    if (capPARAMS->Parameters.Create.Options & FILE_CREATE_TREE_CONNECTION) {
       Status = RxCreateTreeConnect( RxContext );
    } else {

       //
       //
       //
       //  It's here because Mark says he can't avoid sending me double beginning
       //  backslashes win the Win32 layer.
       //

       if ((capFileObject->FileName.Length > sizeof(WCHAR)) &&
           (capFileObject->FileName.Buffer[1] == L'\\') &&
           (capFileObject->FileName.Buffer[0] == L'\\')) {

            capFileObject->FileName.Length -= sizeof(WCHAR);

            RtlMoveMemory(
                &capFileObject->FileName.Buffer[0],
                &capFileObject->FileName.Buffer[1],
                capFileObject->FileName.Length );

            //
            //  If there are still two beginning backslashes, the name is bogus.
            //

            if ((capFileObject->FileName.Length > sizeof(WCHAR)) &&
                (capFileObject->FileName.Buffer[1] == L'\\') &&
                (capFileObject->FileName.Buffer[0] == L'\\')) {

                RxDbgTrace(-1, Dbg, ("RxCommonCreate -> OBJECT_NAME_INVALID[slashes]\n)", 0));

                // RxCompleteContextAndReturn( RxStatus(OBJECT_NAME_INVALID) );
                return STATUS_OBJECT_NAME_INVALID;
            }
        }


        do {
            //
            //  If the file name has a trailing \, and the request is to
            //  operate on a file (not a directory), then the file name is
            //  invalid.
            //


            if ((capFileObject->FileName.Length>0)
                 &&(capFileObject->FileName.Buffer[(capFileObject->FileName.Length/sizeof(WCHAR))-1] == L'\\')) {
                ULONG co = capPARAMS->Parameters.Create.Options;
                if (MustBeFile (co)) {
                    RxDbgTrace(-1, Dbg, ("RxCommonCreate -> OBJECT_NAME_INVALID[trailing+MBFile]\n)", 0));
                    return(Status = STATUS_OBJECT_NAME_INVALID);
                }
                capFileObject->FileName.Length -= sizeof(WCHAR);
                SetFlag(RxContext->Create.Flags,RX_CONTEXT_CREATE_FLAG_STRIPPED_TRAILING_BACKSLASH);
            }


            //
            //  If we have Write Through set in the FileObject, then set the FileObject
            //  flag as well, so that the fast write path call to FsRtlCopyWrite
            //  knows it is Write Through.
            //

            if (FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WRITE_THROUGH)) {
                capFileObject->Flags |= FO_WRITE_THROUGH;
            }

            // Convert the name to its canonical form, i.e. without . and .. and with the luid
            // on the front as appropriate. try to avoid a pool operation by using an stack-based buffer


            Status = RxCanonicalizeNameAndObtainNetRoot(
                         RxContext,
                         &capFileObject->FileName,
                         &RemainingName);

            if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
                RxDbgTrace(0, Dbg, ("RxCommonCreate -> Couldn't canonicalize %08lx\n", Status));
            } else {
                RxDbgTrace(0, Dbg, ("RxCommonCreate NetRootGoodWasGood status =%08lx\n", Status));

                Status = RxCreateFromNetRoot(RxContext,&RemainingName);

                RxDbgTrace(0, Dbg, ("RxCommonCreate RxCreateFromNetRoot status =%08lx\n", Status));

                switch (Status) {
                case STATUS_SHARING_VIOLATION:
                    {
                        ULONG Disposition = RxContext->Create.NtCreateParameters.Disposition;
                        ASSERT(!FlagOn(RxContext->Create.Flags,RX_CONTEXT_CREATE_FLAG_REPARSE));

                        if (Disposition != FILE_CREATE) {
                            if ( RxContext->Create.TryForScavengingOnSharingViolation &&
                                !RxContext->Create.ScavengingAlreadyTried &&
                                RxContext->Create.pVNetRoot != NULL) {
                                PV_NET_ROOT pVNetRoot;

                                NTSTATUS PurgeStatus;
                                NT_CREATE_PARAMETERS NtCreateParameters;

                                NtCreateParameters = RxContext->Create.NtCreateParameters;

                                // Reference the VNetRoot instance. Reinitialize
                                // the context ( this will drop the FCB if it has
                                // been accquired. purge the FOBX's related to the
                                // NET_ROOT instance and resume the create
                                // operation if it was sucssesful
                                pVNetRoot = (PV_NET_ROOT)(RxContext->Create.pVNetRoot);
                                RxReferenceVNetRoot(pVNetRoot);

                                // reinitialize the context
                                RxpPrepareCreateContextForReuse(RxContext);
                                RxReinitializeContext(RxContext);

                                // Reinitialize the Create parameters.
                                RxContext->Create.NtCreateParameters = NtCreateParameters;
                                RxCopyCreateParameters(RxContext);

                                PurgeStatus = RxPurgeRelatedFobxs(
                                                  pVNetRoot->NetRoot,
                                                  RxContext,
                                                  DONT_ATTEMPT_FINALIZE_ON_PURGE,
                                                  NULL);

                                    // Map the SUCCESS code for continuation
                                Status = STATUS_MORE_PROCESSING_REQUIRED;
                                RxContext->Create.ScavengingAlreadyTried = TRUE;

                                // Ensure that any buffering state change pending
                                // requests have been processed. This will cover the
                                // cases when owing to processing delays the oplock
                                // response did not make it to the server and it
                                // returned SHARING_VIOLATION.
                                {
                                    PSRV_CALL pSrvCall;

                                    pSrvCall = (PSRV_CALL)pVNetRoot->pNetRoot->pSrvCall;

                                    RxReferenceSrvCall(pSrvCall);

                                    RxpProcessChangeBufferingStateRequests(
                                        pSrvCall,
                                        FALSE); // do not update handler state
                                }


                                // Drop the reference on the V_NET_ROOT instance
                                RxDereferenceVNetRoot(pVNetRoot,LHS_LockNotHeld);
                            }
                        } else {
                            Status = STATUS_OBJECT_NAME_COLLISION;
                        }
                    }
                    break;

                case STATUS_REPARSE:
                    {
                        // Ensure that the IRP is approrpiately marked for reparsing.
                        RxContext->CurrentIrp->IoStatus.Information = IO_REPARSE;
                        RxDbgTrace(0, Dbg, ("RxCommonCreate(Reparse) IRP %lx New Name %wZ status =%08lx\n",
                                       capReqPacket,&capFileObject->FileName, Status));
                    }
                    break;

                default:
                    ASSERT(!FlagOn(RxContext->Create.Flags,RX_CONTEXT_CREATE_FLAG_REPARSE));
                    break;
                }
            }
        } while (Status == STATUS_MORE_PROCESSING_REQUIRED);
    }

    if (Status == STATUS_RETRY) {
        RxpPrepareCreateContextForReuse(RxContext);
    }

    ASSERT(Status != STATUS_PENDING);

    RxDbgTraceUnIndent(-1,Dbg);

#if 0 && defined(REMOTE_BOOT)
    if ( LogAllFiles ) {
        DbgPrint( "RxCommonCreate: status %x creating %wZ %x %x\n", Status, &capFileObject->FileName, capFileObject, capFileObject->FsContext );
    }
#endif

    return Status;
}


//these next routines are essentially just copies of the same routines from io\iosubs.c
//i cannot just use them directly because they make all sorts of assumptions about wanting to
//update the file object

#define RxSetAccessVariables(xxx) {\
    ReadAccess = (BOOLEAN) ((DesiredAccess & (FILE_EXECUTE  | FILE_READ_DATA)) != 0);        \
    WriteAccess = (BOOLEAN) ((DesiredAccess & (FILE_WRITE_DATA | FILE_APPEND_DATA)) != 0);   \
    DeleteAccess = (BOOLEAN) ((DesiredAccess & DELETE) != 0);                                \
}
#define RxSetShareVariables(xxx) {\
    SharedRead = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_READ) != 0);                     \
    SharedWrite = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_WRITE) != 0);                   \
    SharedDelete = (BOOLEAN) ((DesiredShareAccess & FILE_SHARE_DELETE) != 0);                 \
}


#if DBG
VOID
RxDumpWantedAccess(
    PSZ where1,
    PSZ where2,
    PSZ wherelogtag,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess
   )
{
    BOOLEAN ReadAccess,WriteAccess,DeleteAccess;
    BOOLEAN SharedRead,SharedWrite,SharedDelete;
    RxSetAccessVariables(SrvOpen);
    RxSetShareVariables(SrvOpen);

    PAGED_CODE();

    //(VOID)(DbgPrint
    RxDbgTrace(0, (DEBUG_TRACE_SHAREACCESS),
       ("%s%s wanted = %s%s%s:%s%s%s\n", where1,where2,
                            ReadAccess?"R":"",
                            WriteAccess?"W":"",
                            DeleteAccess?"D":"",
                            SharedRead?"SR":"",
                            SharedWrite?"SW":"",
                            SharedDelete?"SD":""
       ));
    RxLogForSharingCheck(
       ("%s%s wanted = %s%s%s:%s%s%s\n", wherelogtag,  where2,
                            ReadAccess?"R":"",
                            WriteAccess?"W":"",
                            DeleteAccess?"D":"",
                            SharedRead?"SR":"",
                            SharedWrite?"SW":"",
                            SharedDelete?"SD":""
       ));
}

VOID
RxDumpCurrentAccess(
    PSZ where1,
    PSZ where2,
    PSZ wherelogtag,
    PSHARE_ACCESS ShareAccess
    )
{
    PAGED_CODE();

//    (VOID)(DbgPrint
    RxDbgTrace(0, (DEBUG_TRACE_SHAREACCESS),
       ("%s%s current = %d[%d][%d][%d]:[%d][%d][%d]\n", where1, where2,
                         ShareAccess->OpenCount,
                         ShareAccess->Readers,
                         ShareAccess->Writers,
                         ShareAccess->Deleters,
                         ShareAccess->SharedRead,
                         ShareAccess->SharedWrite,
                         ShareAccess->SharedDelete
       ));
    RxLogForSharingCheck(
       ("%s%s current = %d[%d][%d][%d]:[%d][%d][%d]\n", wherelogtag, where2,
                         ShareAccess->OpenCount,
                         ShareAccess->Readers,
                         ShareAccess->Writers,
                         ShareAccess->Deleters,
                         ShareAccess->SharedRead,
                         ShareAccess->SharedWrite,
                         ShareAccess->SharedDelete
       ));
}

NTSTATUS
RxCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update,
    IN PSZ where,
    IN PSZ wherelogtag
    )
{
    NTSTATUS Status;
    PAGED_CODE();

    RxDumpWantedAccess(where,"",wherelogtag,
                       DesiredAccess,DesiredShareAccess
                       );
    RxDumpCurrentAccess(where,"",wherelogtag,ShareAccess);
    Status = IoCheckShareAccess(DesiredAccess,
                                DesiredShareAccess,
                                FileObject,
                                ShareAccess,
                                Update);

    return(Status);
}

VOID
RxRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    )
{
    PAGED_CODE();

    RxDumpCurrentAccess(where,"before",wherelogtag,ShareAccess);
    IoRemoveShareAccess(FileObject, ShareAccess);
    RxDumpCurrentAccess(where,"after",wherelogtag,ShareAccess);
}

VOID
RxSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    )
{
    PAGED_CODE();

    RxDumpCurrentAccess(where,"before",wherelogtag,ShareAccess);
    IoSetShareAccess(DesiredAccess, DesiredShareAccess, FileObject, ShareAccess);
    RxDumpCurrentAccess(where,"after",wherelogtag,ShareAccess);
}

VOID
RxUpdateShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    )
{
    PAGED_CODE();

    RxDumpCurrentAccess(where,"before",wherelogtag,ShareAccess);
    IoUpdateShareAccess(FileObject,ShareAccess);
    RxDumpCurrentAccess(where,"after",wherelogtag,ShareAccess);
}
#endif
NTSTATUS
RxCheckShareAccessPerSrvOpens(
    IN PFCB Fcb,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess
    )

/*++

Routine Description:

    This routine is invoked to determine whether or not a new accessor to
    a file actually has shared access to it.  The check is made according
    to:

        1)  How the file is currently opened.

        2)  What types of shared accesses are currently specified.

        3)  The desired and shared accesses that the new open is requesting.

    This check is made against the sharing state represented by the actual SrvOpens
    on an Fcb so that we know whether we have to initiate close-behind.


Arguments:

    DesiredAccess - Desired access of current open request.

    DesiredShareAccess - Shared access requested by current open request.

    Fcb - Pointer to the file object of the current open request.


Return Value:

    The final status of the access check is the function value.  If the
    accessor has access to the file, STATUS_SUCCESS is returned.  Otherwise,
    STATUS_SHARING_VIOLATION is returned.

Note:

    Note that the ShareAccess parameter must be locked against other accesses
    from other threads while this routine is executing.  Otherwise the counts
    will be out-of-synch.

--*/

{
    ULONG ocount;
    PSHARE_ACCESS ShareAccess = &Fcb->ShareAccessPerSrvOpens;
    BOOLEAN ReadAccess,WriteAccess,DeleteAccess;
    BOOLEAN SharedRead,SharedWrite,SharedDelete;

    PAGED_CODE();

    //
    // Set the access type in the file object for the current accessor.
    // Note that reading and writing attributes are not included in the
    // access check.
    //

    RxSetAccessVariables(SrvOpen);

    //
    // There is no more work to do unless the user specified one of the
    // sharing modes above.
    //

    if (ReadAccess || WriteAccess || DeleteAccess) {

        RxSetShareVariables(SrvOpen);
        RxDumpWantedAccess("RxCheckShareAccessPerSrvOpens","","AccChkPerSO",
                            DesiredAccess,DesiredShareAccess
                           );
        RxDumpCurrentAccess("RxCheckShareAccessPerSrvOpens","","AccChkPerSO",ShareAccess);

        //
        // Now check to see whether or not the desired accesses are compatible
        // with the way that the file is currently open.
        //

        ocount = ShareAccess->OpenCount;

        if ( (ReadAccess && (ShareAccess->SharedRead < ocount))
             ||
             (WriteAccess && (ShareAccess->SharedWrite < ocount))
             ||
             (DeleteAccess && (ShareAccess->SharedDelete < ocount))
             ||
             ((ShareAccess->Readers != 0) && !SharedRead)
             ||
             ((ShareAccess->Writers != 0) && !SharedWrite)
             ||
             ((ShareAccess->Deleters != 0) && !SharedDelete)
           ) {

            //
            // The check failed.  Simply return to the caller indicating that the
            // current open cannot access the file.
            //

            //DbgPrint("***** FCB Share Access Check (%lx) Status(%lx)\n",Fcb,STATUS_SHARING_VIOLATION);
            return STATUS_SHARING_VIOLATION;

        }
    }

    //DbgPrint("***** FCB Share Access Check (%lx) Status(%lx)\n",Fcb,STATUS_SUCCESS);
    return STATUS_SUCCESS;
}

VOID
RxUpdateShareAccessPerSrvOpens(
    IN PSRV_OPEN SrvOpen
    )

/*++

Routine Description:

    This routine is invoked to update the access information about how the
    file is currently opened by introducing the contribution of this srvopen. the wrapper
    actually keeps up with two states: (a) the access state according to the files that the user
    can see, and (b) the access state according to the srvopens on the file. this rouinte manipulates
    the latter.

Arguments:


Return Value:


Note:

    Note that the ShareAccess parameter must be locked against other accesses
    from other threads while this routine is executing.  Otherwise the counts
    will be out-of-synch.

--*/

{
    //ULONG ocount;
    PSHARE_ACCESS ShareAccess = &SrvOpen->Fcb->ShareAccessPerSrvOpens;
    BOOLEAN ReadAccess,WriteAccess,DeleteAccess;
    BOOLEAN SharedRead,SharedWrite,SharedDelete;
    ACCESS_MASK DesiredAccess = SrvOpen->DesiredAccess;
    ULONG DesiredShareAccess = SrvOpen->ShareAccess;

    PAGED_CODE();

    if (!FlagOn(SrvOpen->Flags,SRVOPEN_FLAG_SHAREACCESS_UPDATED)) {
        //
        // Set the access type in the file object for the current accessor.
        // Note that reading and writing attributes are not included in the
        // access check.
        //

        RxSetAccessVariables(SrvOpen);

        //
        // There is no more work to do unless the user specified one of the
        // sharing modes above.
        //

        if (ReadAccess || WriteAccess || DeleteAccess) {

            RxSetShareVariables(SrvOpen);
            RxDumpWantedAccess("RxUpdateShareAccessPerSrvOpens","","AccUpdPerSO",
                                DesiredAccess,DesiredShareAccess
                               );
            RxDumpCurrentAccess("RxUpdateShareAccessPerSrvOpens","","AccUpdPerSO",ShareAccess);

            ShareAccess->OpenCount++;

            ShareAccess->Readers += ReadAccess;
            ShareAccess->Writers += WriteAccess;
            ShareAccess->Deleters += DeleteAccess;

            ShareAccess->SharedRead += SharedRead;
            ShareAccess->SharedWrite += SharedWrite;
            ShareAccess->SharedDelete += SharedDelete;
        }

        SetFlag(SrvOpen->Flags,SRVOPEN_FLAG_SHAREACCESS_UPDATED);
    }
}

VOID
RxRemoveShareAccessPerSrvOpens(
    IN OUT PSRV_OPEN SrvOpen
    )
/*++

Routine Description:

    This routine is invoked to remove the access and share access information
    in a file system Share Access structure for a given open instance.

Arguments:

    ShareAccess - Pointer to the share access structure that describes
         how the file is currently being accessed.

Return Value:

    None.

--*/

{
    PSHARE_ACCESS ShareAccess = &SrvOpen->Fcb->ShareAccessPerSrvOpens;
    BOOLEAN ReadAccess,WriteAccess,DeleteAccess;
    BOOLEAN SharedRead,SharedWrite,SharedDelete;
    ACCESS_MASK DesiredAccess = SrvOpen->DesiredAccess;
    ULONG DesiredShareAccess = SrvOpen->ShareAccess;

    PAGED_CODE();

    //
    // If this accessor wanted some type of access other than READ_ or
    // WRITE_ATTRIBUTES, then account for the fact that he has closed the
    // file.  Otherwise, he hasn't been accounted for in the first place
    // so don't do anything.
    //

    RxSetAccessVariables(SrvOpen);

    if (ReadAccess || WriteAccess || DeleteAccess) {

        RxSetShareVariables(SrvOpen);
        RxDumpWantedAccess("RxRemoveShareAccessPerSrvOpens","","AccRemPerSO",
                            DesiredAccess,DesiredShareAccess
                           );
        RxDumpCurrentAccess("RxRemoveShareAccessPerSrvOpens","","AccRemPerSO",ShareAccess);

        //
        // Decrement the number of opens in the Share Access structure.
        //

        ShareAccess->OpenCount--;

        ShareAccess->Readers -= ReadAccess;
        ShareAccess->Writers -= WriteAccess;
        ShareAccess->Deleters -= DeleteAccess;

        ShareAccess->SharedRead -= SharedRead;
        ShareAccess->SharedWrite -= SharedWrite;
        ShareAccess->SharedDelete -= SharedDelete;
    }
}

ULONG
RxGetSessionId(
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine gets the effective SessionId to be used for this create.

Arguments:

    SubjectSecurityContext - Supplies the information from IrpSp.

Return Value:

    None

--*/
{
    ULONG SessionId;
    PQUERY_PATH_REQUEST QpReq;
    PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxGetSessionId ... \n", 0));

    // If QUERY_PATH_REQUEST, must access from Type3InputBuffer
    if( (IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL) &&
        (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_REDIR_QUERY_PATH) ) {

        QpReq = (PQUERY_PATH_REQUEST)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
        SubjectSecurityContext = &QpReq->SecurityContext->AccessState->SubjectSecurityContext;
    }
    else if( (IrpSp->MajorFunction == IRP_MJ_CREATE) && (IrpSp->Parameters.Create.SecurityContext != NULL) ) {

        SubjectSecurityContext = &IrpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext;

    }
    else {
        // Return 0 for cases we do not handle
        return( 0 );
    }

    //  Is the thread currently impersonating someone else?

    if (SubjectSecurityContext->ClientToken != NULL) {

        //
        //  If its impersonating someone that is logged in locally then use
        //  the local id.
        //

        SeQuerySessionIdToken(SubjectSecurityContext->ClientToken, &SessionId);

    } else {

        //
        //  Use the processes LogonId
        //

        SeQuerySessionIdToken(SubjectSecurityContext->PrimaryToken, &SessionId);
    }

    RxDbgTrace(-1, Dbg, (" ->SessionId = %08lx\n", SessionId));

    return SessionId;
}

#if 0
VOID
RxUpcaseLeadingComponents(
    IN OUT PUNICODE_STRING CanonicalName
    )
/*++

Routine Description:

    This routine is called to upcase the leading components of a name. Either 2 or 3 components are
    upcased depending on the name (i.e. whether it's a UNC name or a vnetrootname). the operation is performed
    in place!

Arguments:

    RxContext - the current workitem
    CanonicalName - the name being canonicalized

Return Value:

    none

--*/
{
    ULONG ComponentsToUpcase,wcLength,i;
    UNICODE_STRING ShortenedCanonicalName;

    PAGED_CODE();

    ComponentsToUpcase =  (*(CanonicalName->Buffer+1) == L';')?3:2;
    wcLength = CanonicalName->Length/sizeof(WCHAR);
    for (i=1;;i++) { //note: don't start at zero
        if (i>=wcLength) break;
        if (CanonicalName->Buffer[i]!=OBJ_NAME_PATH_SEPARATOR) continue;
        ComponentsToUpcase--;
        if (ComponentsToUpcase==0) break;
    }
    ShortenedCanonicalName.Buffer = CanonicalName->Buffer;
    ShortenedCanonicalName.MaximumLength = CanonicalName->MaximumLength;
    ShortenedCanonicalName.Length = (USHORT)(i*sizeof(WCHAR));
    RtlUpcaseUnicodeString(&ShortenedCanonicalName,&ShortenedCanonicalName,FALSE); //don't allocate
    RxDbgTrace(0, Dbg, ("RxUpcaseLeadingComponents -> %wZ\n", &ShortenedCanonicalName));
    return;
}
#endif //if 0


#if 0

UNICODE_STRING InterestingNames[] = {
    32, 32, L"CreateParent.txt",
};

DWORD
IsInterestingFile(
    PUNICODE_STRING pFileName
    )
{
    int i;

    for (i=0; i< sizeof(InterestingNames)/sizeof(UNICODE_STRING); ++i)
    {
        if (pFileName->Length > InterestingNames[i].Length)
        {
            UNICODE_STRING uTemp;
            uTemp.Length = uTemp.MaximumLength = InterestingNames[i].Length;
            uTemp.Buffer = pFileName->Buffer + (pFileName->Length - InterestingNames[i].Length)/sizeof(WCHAR);
            if(RtlCompareUnicodeString(&uTemp, &InterestingNames[i], TRUE)==0)
            {
//                DbgPrint("Interesting string %wZ \n", pFileName);
                return i+1;
            }
        }
    }
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\close.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Close.c

Abstract:

    This module implements the File Close routine for Rx called by the
    dispatch driver.


Author:

    Joe Linn     [JoeLinn]    sep-9-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_CLOSE)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLOSE)

enum _CLOSE_DEBUG_BREAKPOINTS {
    CloseBreakPoint_BeforeCloseFakeFcb = 1,
    CloseBreakPoint_AfterCloseFakeFcb
};

VOID
RxPurgeNetFcb(
    IN OUT PFCB        pFcb,
    IN OUT PRX_CONTEXT pRxContext
   );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonClose)
#pragma alloc_text(PAGE, RxPurgeNetFcb)
#pragma alloc_text(PAGE, RxCloseAssociatedSrvOpen)
#endif

NTSTATUS
RxCommonClose ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    Close is invoked whenever the last reference to a file object is deleted.
    Cleanup is invoked when the last handle to a file object is closed, and
    is called before close.

Arguments:


Return Value:

    RXSTATUS - The return status for the operation

Notes:

    The CLOSE handling strategy in RDBSS is predicated upon the axiom that the
    workload on the server should be minimized as and when possible.

    There are a number of applications which repeatedly close and open the same
    file, e.g., batch file processing. In these cases the same file is opened,
    a line/buffer is read, the file is closed and the same set of operations are
    repeated over and over again.

    This is handled in RDBSS by a delayed processing of the CLOSE request. There
    is a delay ( of about 10 seconds ) between completing the request and initiating
    processing on the request. This opens up a window during which a subsequent
    OPEN can be collapsed onto an existing SRV_OPEN. The time interval can be tuned
    to meet these requirements.

--*/
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    TYPE_OF_OPEN TypeOfOpen = NodeType(capFcb);

    BOOLEAN AcquiredFcb       = FALSE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonClose IrpC/Fobx/Fcb = %08lx %08lx %08lx\n",
                               RxContext,capFobx,capFcb));
    RxLog(("CClose %lx %lx %lx %lx\n",RxContext,capFobx,capFcb,capFileObject));
    RxWmiLog(LOG,
             RxCommonClose_1,
             LOGPTR(RxContext)
             LOGPTR(capFobx)
             LOGPTR(capFcb)
             LOGPTR(capFileObject));

    Status = RxAcquireExclusiveFcb( RxContext, capFcb );
    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("RxCommonClose Cannot acquire FCB(%lx) %lx\n",capFcb,Status));
        return Status;
    }

    AcquiredFcb = TRUE;

    try {
        switch (TypeOfOpen) {
        case RDBSS_NTC_STORAGE_TYPE_UNKNOWN:
        case RDBSS_NTC_STORAGE_TYPE_FILE:
        case RDBSS_NTC_STORAGE_TYPE_DIRECTORY:
        case RDBSS_NTC_OPENTARGETDIR_FCB:
        case RDBSS_NTC_IPC_SHARE:
        case RDBSS_NTC_MAILSLOT:
        case RDBSS_NTC_SPOOLFILE:
            {
                PSRV_OPEN SrvOpen     = NULL;
                BOOLEAN   fDelayClose = FALSE;

                RxDbgTrace(0, Dbg, ("Close UserFileOpen/UserDirectoryOpen/OpenTargetDir %04lx\n", TypeOfOpen));

                RxReferenceNetFcb(capFcb);

                if (capFobx) {
                    SrvOpen = capFobx->SrvOpen;

                    if ((NodeType(capFcb) != RDBSS_NTC_STORAGE_TYPE_DIRECTORY) &&
                        (!FlagOn(capFcb->FcbState,FCB_STATE_ORPHANED))         &&
                        (!FlagOn(capFcb->FcbState,FCB_STATE_DELETE_ON_CLOSE))  &&
                        (FlagOn(capFcb->FcbState,FCB_STATE_COLLAPSING_ENABLED))) {
                        PSRV_CALL pSrvCall = capFcb->NetRoot->SrvCall;

                        RxLog(("@@@@DelayCls FOBX %lx SrvOpen %lx@@\n",capFobx,SrvOpen));
                        RxWmiLog(LOG,
                                 RxCommonClose_2,
                                 LOGPTR(capFobx)
                                 LOGPTR(SrvOpen));

                        // If this is the last open instance and the close is being delayed
                        // mark the SRV_OPEN. This will enable us to respond to buffering
                        // state change requests with a close operation as opposed to
                        // the regular flush/purge response.

                        // We also check the COLLAPSING_DISABLED flag to determine whether its even necessary to delay
                        // close the file.  If we cannot collapse the open, no reason to delay its closure.  Delaying here
                        // caused us to stall for 10 seconds on an oplock break to a delay closed file because the final close
                        // caused by the break was delay-closed again, resulting in a delay before the oplock break is satisfied.
                        if ( (SrvOpen->OpenCount == 1) && !FlagOn( SrvOpen->Flags, SRVOPEN_FLAG_COLLAPSING_DISABLED ) ) {
                            if (InterlockedIncrement(&pSrvCall->NumberOfCloseDelayedFiles) <
                                pSrvCall->MaximumNumberOfCloseDelayedFiles) {

                                fDelayClose = TRUE;
                                SrvOpen->Flags |= SRVOPEN_FLAG_CLOSE_DELAYED;
                            } else {
                                RxDbgTrace(0,Dbg,("Not delaying files because count exceeded limit\n"));
                                InterlockedDecrement(&pSrvCall->NumberOfCloseDelayedFiles);
                            }
                        }
                    }

                    if (!fDelayClose) {
                        PNET_ROOT NetRoot = (PNET_ROOT)capFcb->pNetRoot;

                        if (NetRoot->Type != NET_ROOT_PRINT &&
                            FlagOn(capFobx->Flags, FOBX_FLAG_DELETE_ON_CLOSE)) {

                            RxScavengeRelatedFobxs(capFcb);
                            RxSynchronizeWithScavenger(RxContext);
                            RxReleaseFcb(NULL,capFcb);

                            RxAcquireFcbTableLockExclusive( &NetRoot->FcbTable, TRUE);

                            RxOrphanThisFcb(capFcb);

                            RxReleaseFcbTableLock( &NetRoot->FcbTable );

                            Status = RxAcquireExclusiveFcb(NULL,capFcb);
                            ASSERT(Status == STATUS_SUCCESS);
                        }
                    }

                    RxMarkFobxOnClose(capFobx);
                }

                if (!fDelayClose) {
                    Status = RxCloseAssociatedSrvOpen(capFobx,RxContext);

                    if (capFobx != NULL) {
                        RxDereferenceNetFobx(capFobx,LHS_ExclusiveLockHeld);
                    }
                } else {
                    ASSERT(capFobx != NULL);
                    RxDereferenceNetFobx(capFobx,LHS_SharedLockHeld);
                }

                AcquiredFcb = !RxDereferenceAndFinalizeNetFcb(capFcb,RxContext,FALSE,FALSE);
                capFileObject->FsContext = IntToPtr(0xffffffff);

                if (AcquiredFcb) {
                    AcquiredFcb = FALSE;
                    RxReleaseFcb( RxContext, capFcb );
                } else {
                    //the tracker gets very unhappy if you don't do this!
                    RxTrackerUpdateHistory(RxContext,NULL,'rrCr',__LINE__,__FILE__,0);
                }
            }
            break;

        default:
            RxBugCheck( TypeOfOpen, 0, 0 );
            break;
        }
    } finally {
        if (AbnormalTermination()) {
            if (AcquiredFcb) {
                RxReleaseFcb( RxContext, capFcb );
            }
        } else {
            ASSERT( !AcquiredFcb );
        }

        RxDbgTrace(-1, Dbg, ("RxCommonClose -> %08lx\n", Status));
    }

    return Status;
}

VOID
RxPurgeNetFcb(
    IN OUT PFCB        pFcb,
    IN OUT PRX_CONTEXT pRxContext
    )
/*++

Routine Description:

    This routine initiates the purge on an FCB instance

Arguments:

    pFcb      - the FOBX instance for which close processing is to be initiated

    RxContext - the context

Return Value:

Notes:

    On entry to this routine the FCB must have been accquired exclusive.

    On exit there is no change in resource ownership

--*/
{
    NTSTATUS Status;
    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("CleanupPurge:MmFlushImage\n", 0));

    MmFlushImageSection(
        &pFcb->NonPaged->SectionObjectPointers,
        MmFlushForWrite);

    // we dont pass in the context here because it is not necessary to track this
    // release because of the subsequent acquire...........

    RxReleaseFcb( NULL, pFcb );

    MmForceSectionClosed(
        &pFcb->NonPaged->SectionObjectPointers,
        TRUE);

    Status = RxAcquireExclusiveFcb(NULL,pFcb);
    ASSERT(Status == STATUS_SUCCESS);
}

NTSTATUS
RxCloseAssociatedSrvOpen(
    IN OUT PFOBX       pFobx,
    IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

    This routine initiates the close processing for an FOBX. The FOBX close
    processing can be trigerred in one of three ways ....

    1) Regular close processing on receipt of the IRP_MJ_CLOSE for the associated
    file object.

    2) Delayed close processing while scavenging the FOBX. This happens when the
    close processing was delayed in anticipation of an open and no opens are
    forthcoming.

    3) Delayed close processing on receipt of a buffering state change request
    for a close that was delayed.

Arguments:

    pFobx     - the FOBX instance for which close processing is to be initiated.
                It is NULL for MAILSLOT files.

    RxContext - the context parameter is NULL for case (2).

Return Value:

Notes:

    On entry to this routine the FCB must have been accquired exclusive.

    On exit there is no change in resource ownership

--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;

    PFCB        pFcb;
    PSRV_OPEN   pSrvOpen;
    PRX_CONTEXT pLocalRxContext;

    PAGED_CODE();

    // Distinguish between those cases where there is a real SRV_OPEN instance
    // from those that do not have one, e.g., mailslot files.
    if (pFobx == NULL) {
        if (RxContext != NULL) {
            pFcb = (PFCB)(RxContext->pFcb);
            pSrvOpen = NULL;
        } else {
            Status = STATUS_SUCCESS;
        }
    } else {
        if (pFobx->Flags & FOBX_FLAG_SRVOPEN_CLOSED) {
            RxMarkFobxOnClose(pFobx);
            Status = STATUS_SUCCESS;
        } else {
            pSrvOpen = pFobx->SrvOpen;

            if (pSrvOpen->Flags & SRVOPEN_FLAG_CLOSED) {
                pFcb = pSrvOpen->Fcb;

                ASSERT(RxIsFcbAcquiredExclusive( pFcb ));

                pFobx->Flags    |= FOBX_FLAG_SRVOPEN_CLOSED;

                if (pSrvOpen->OpenCount > 0) {
                    pSrvOpen->OpenCount--;
                }

                RxMarkFobxOnClose(pFobx);
                Status = STATUS_SUCCESS;
            } else {
                pFcb = pSrvOpen->Fcb;
            }
        }
    }

    // If there is no corresponding open on the server side or if the close
    // processing has already been accomplished there is no further processing
    // required. In other cases w.r.t scavenged close processing a new
    // context might have to be created.

    if ((Status == STATUS_MORE_PROCESSING_REQUIRED &&
        (pLocalRxContext = RxContext) == NULL)) {
        pLocalRxContext = RxCreateRxContext(
                              NULL,
                              pSrvOpen->Fcb->RxDeviceObject,
                              RX_CONTEXT_FLAG_WAIT|RX_CONTEXT_FLAG_MUST_SUCCEED_NONBLOCKING);

        if (pLocalRxContext != NULL) {
            pLocalRxContext->MajorFunction = IRP_MJ_CLOSE;
            pLocalRxContext->pFcb  = (PMRX_FCB)pFcb;
            pLocalRxContext->pFobx = (PMRX_FOBX)pFobx;
            if (pFobx != NULL)
            {
                pLocalRxContext->pRelevantSrvOpen = (PMRX_SRV_OPEN)(pFobx->SrvOpen);
            }
            Status           = STATUS_MORE_PROCESSING_REQUIRED;
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    // if the context creation was successful and the close processing for
    // the SRV_OPEN instance needs to be initiated with the mini rdr
    // proceed.

    if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
        ASSERT(RxIsFcbAcquiredExclusive( pFcb ));

        // Mark the Fobx instance on the initiation of the close operation. This
        // is the complement to the action taken on cleanup. It ensures
        // that the infrastructure setup for delayed close processing is undone.
        // For those instances in which the FOBS is NULL the FCB is manipulated
        // directly

        if (pFobx != NULL) {
            RxMarkFobxOnClose(pFobx);
        } else {
            InterlockedDecrement(&pFcb->OpenCount);
        }

        if (pSrvOpen != NULL) {
            if (pSrvOpen->Condition == Condition_Good) {
                if (pSrvOpen->OpenCount > 0) {
                    pSrvOpen->OpenCount--;
                }

                if (pSrvOpen->OpenCount == 1) {
                    if (!IsListEmpty(&pSrvOpen->FobxList)) {
                        PFOBX remainingFobx;

                        remainingFobx = CONTAINING_RECORD(
                                            pSrvOpen->FobxList.Flink,
                                            FOBX,
                                            FobxQLinks);
                        if (!IsListEmpty(&remainingFobx->ScavengerFinalizationList)) {
                            pSrvOpen->Flags |= SRVOPEN_FLAG_CLOSE_DELAYED;
                        }
                    }
                }

                // Purge the FCB before initiating the close processing with
                // the mini redirectors
                if ((pSrvOpen->OpenCount == 0) &&
                    (Status == STATUS_MORE_PROCESSING_REQUIRED) &&
                    (RxContext == NULL)) {
                    RxPurgeNetFcb(pFcb,pLocalRxContext);
                }

                // Since PurgeNetFcb drops and reacquires the resource, ensure that
                // the SrvOpen is still valid before proceeding with the
                // finalization.

                pSrvOpen = pFobx->SrvOpen;

                if ((pSrvOpen != NULL) &&
                    ((pSrvOpen->OpenCount == 0) ||
                     (FlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_ORPHANED))) &&
                    !FlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_CLOSED) &&
                    (Status == STATUS_MORE_PROCESSING_REQUIRED)) {
                    ASSERT(RxIsFcbAcquiredExclusive( pFcb ));

                    MINIRDR_CALL(
                        Status,
                        pLocalRxContext,
                        pFcb->MRxDispatch,
                        MRxCloseSrvOpen,
                        (pLocalRxContext));

                    RxLog(("MRXClose %lx %lx %lx %lx %lx\n",RxContext,pFcb,pSrvOpen,pFobx,Status));
                    RxWmiLog(LOG,
                             RxCloseAssociatedSrvOpen,
                             LOGPTR(RxContext)
                             LOGPTR(pFcb)
                             LOGPTR(pSrvOpen)
                             LOGPTR(pFobx)
                             LOGULONG(Status));

                    pSrvOpen->Flags |= SRVOPEN_FLAG_CLOSED;

                    if (FlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_CLOSE_DELAYED)) {
                        InterlockedDecrement(&pFcb->NetRoot->SrvCall->NumberOfCloseDelayedFiles);
                    }

                    RxRemoveShareAccessPerSrvOpens(pSrvOpen);

                    // Ensure that any buffering state change requests for this
                    // SRV_OPEN instance which was closed is purged from the
                    // buffering manager data structures.

                    RxPurgeChangeBufferingStateRequestsForSrvOpen(pSrvOpen);

                    RxDereferenceSrvOpen(pSrvOpen,LHS_ExclusiveLockHeld);
                } else {
                    Status = STATUS_SUCCESS;
                }

                pFobx->Flags    |= FOBX_FLAG_SRVOPEN_CLOSED;
            } else {
                Status = STATUS_SUCCESS;
            }
        } else {
            ASSERT((NodeType(pFcb) == RDBSS_NTC_OPENTARGETDIR_FCB) ||
                   (NodeType(pFcb) == RDBSS_NTC_IPC_SHARE) ||
                   (NodeType(pFcb) == RDBSS_NTC_MAILSLOT));
            RxDereferenceNetFcb(pFcb);
            Status = STATUS_SUCCESS;
        }

        if (pLocalRxContext != RxContext) {
            RxDereferenceAndDeleteRxContext(pLocalRxContext);
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\devctrl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DevCtrl.c

Abstract:

    This module implements the File System Device Control routines for Rx
    called by the dispatch driver.

Author:

Revision History:

   Balan Sethu Raman [19-July-95] -- Hook it up to the mini rdr call down.

--*/

#include "precomp.h"
#pragma hdrstop

#include "ntddmup.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DEVCTRL)

NTSTATUS
RxLowIoIoCtlShellCompletion( RXCOMMON_SIGNATURE );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonDeviceControl)
#pragma alloc_text(PAGE, RxLowIoIoCtlShellCompletion)
#endif


NTSTATUS
RxCommonDeviceControl ( RXCOMMON_SIGNATURE )

/*++

Routine Description:

    This is the common routine for doing Device control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

    InFsp - Indicates if this is the fsp thread or someother thread

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureParamBlock;

    BOOLEAN SubmitLowIoRequest = TRUE;
    ULONG IoControlCode = capPARAMS->Parameters.DeviceIoControl.IoControlCode;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonDeviceControl\n", 0));
    RxDbgTrace( 0, Dbg, ("Irp           = %08lx\n", capReqPacket));
    RxDbgTrace( 0, Dbg, ("MinorFunction = %08lx\n", capPARAMS->MinorFunction));

    //
    //

    if (IoControlCode == IOCTL_REDIR_QUERY_PATH) {
        Status = (STATUS_INVALID_DEVICE_REQUEST);
        SubmitLowIoRequest = FALSE;
    }

    if (SubmitLowIoRequest) {
        RxInitializeLowIoContext(&RxContext->LowIoContext,LOWIO_OP_IOCTL);
        Status = RxLowIoSubmit(RxContext,RxLowIoIoCtlShellCompletion);

        if( Status == STATUS_PENDING )
        {
            // Another thread will complete the request, but we must remove our reference count.
            RxDereferenceAndDeleteRxContext( RxContext );
        }
    }

    RxDbgTrace(-1, Dbg, ("RxCommonDeviceControl -> %08lx\n", Status));
    return Status;
}

NTSTATUS
RxLowIoIoCtlShellCompletion( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This is the completion routine for IoCtl requests passed down to the mini rdr

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    RxCaptureRequestPacket;
    //RxCaptureFcb;
    //RxCaptureFobx;
    //RxCaptureParamBlock;
    //RxCaptureFileObject;

    NTSTATUS       Status        = STATUS_SUCCESS;
    //NODE_TYPE_CODE TypeOfOpen    = NodeType(capFcb);
    PLOWIO_CONTEXT pLowIoContext  = &RxContext->LowIoContext;
    //ULONG          FsControlCode = capPARAMS->Parameters.FileSystemControl.FsControlCode;

    PAGED_CODE();

    Status = RxContext->StoredStatus;
    RxDbgTrace(+1, Dbg, ("RxLowIoIoCtlShellCompletion  entry  Status = %08lx\n", Status));

    switch (Status) {   //maybe success vs warning vs error
    case STATUS_SUCCESS:
    case STATUS_BUFFER_OVERFLOW:
       //capReqPacket->IoStatus.Information = pLowIoContext->ParamsFor.IoCtl.OutputBufferLength;
       capReqPacket->IoStatus.Information = RxContext->InformationToReturn;
       break;
    //case STATUS(CONNECTION_INVALID:
    default:
       break;
    }

    capReqPacket->IoStatus.Status = Status;
    RxDbgTrace(-1, Dbg, ("RxLowIoIoCtlShellCompletion  exit  Status = %08lx\n", Status));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\drventry.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxInit.c

Abstract:

    This module implements the externally visible DRIVER_INITIALIZATION routine for the RDBSS;
    actually, it's just a passthru. for nonmonolithic, we need the name to be DriverEntry; for nonmono-
    we need the name NOT to be DriverEntry.

Author:

    Joe Linn [JoeLinn]    20-jul-1994

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is just a wrapper.

Arguments:


Return Value:

--*/

{
    NTSTATUS Status;
    //
    //  Setup Unload Routine
    Status =  RxDriverEntry(DriverObject, RegistryPath);
    if (Status == STATUS_SUCCESS) {
        DriverObject->DriverUnload = RxUnload;
    }

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ea.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Ea.c

Abstract:

    This module implements the EA routines for Rx called by
    the dispatch driver.

Author:

    Joe Linn      [JoeLi]  1-Jan-95

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_EA)



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonQueryEa)
#pragma alloc_text(PAGE, RxCommonSetEa)
#pragma alloc_text(PAGE, RxCommonQuerySecurity)
#pragma alloc_text(PAGE, RxCommonSetSecurity)
#endif

typedef
NTSTATUS
(NTAPI *PRX_MISC_OP_ROUTINE) (
    RXCOMMON_SIGNATURE);

NTSTATUS
RxpCommonMiscOp(
    RXCOMMON_SIGNATURE,
    PRX_MISC_OP_ROUTINE pMiscOpRoutine)
{
    NTSTATUS Status;

    RxCaptureFcb;

    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    if ((TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE) &&
        (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_DIRECTORY)) {

        RxDbgTrace(-1, Dbg, ("RxpCommonMiscOp -> %08lx\n", STATUS_INVALID_PARAMETER));

        return STATUS_INVALID_PARAMETER;
    }

    if (!FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT)) {

        RxDbgTrace(0, Dbg, ("RxpCommonMiscOp:  Set Ea must be waitable....posting\n", 0));

        Status = RxFsdPostRequest( RxContext );

        RxDbgTrace(-1, Dbg, ("RxpCommonMiscOp -> %08lx\n", Status ));

        return Status;
    }

    Status = RxAcquireExclusiveFcb( RxContext, capFcb );
    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("RxpCommonMiscOp -> Error Acquiring Fcb %08lx\n", Status ));
        return Status;
    }

    try {

        Status = (*pMiscOpRoutine)(
                     RxContext);
    } finally {

        DebugUnwind( *pMiscOpRoutine );

        RxReleaseFcb( RxContext, capFcb );

        RxDbgTrace(-1, Dbg, ("RxpCommonMiscOp -> %08lx\n", Status));
    }

    return Status;
}

NTSTATUS
RxpCommonQuerySecurity(
    RXCOMMON_SIGNATURE)
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureParamBlock;

    PUCHAR  Buffer;
    ULONG   UserBufferLength;

    UserBufferLength  = capPARAMS->Parameters.QuerySecurity.Length;

    RxContext->QuerySecurity.SecurityInformation =
        capPARAMS->Parameters.QuerySecurity.SecurityInformation;

    RxLockUserBuffer(
        RxContext,
        IoModifyAccess,
        UserBufferLength );

    //lock before map so that map will get userbuffer instead of assoc buffer
    Buffer = RxNewMapUserBuffer( RxContext );
    RxDbgTrace(0, Dbg, ("RxCommonQuerySecurity -> Buffer = %08lx\n", Buffer));

    if ((Buffer != NULL) ||
        (UserBufferLength == 0)) {
        RxContext->Info.Buffer = Buffer;
        RxContext->Info.LengthRemaining = UserBufferLength;

        MINIRDR_CALL(
            Status,
            RxContext,
            capFcb->MRxDispatch,
            MRxQuerySdInfo,
            (RxContext));

        capReqPacket->IoStatus.Information = RxContext->InformationToReturn;
    } else {
        capReqPacket->IoStatus.Information = 0;
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
RxCommonQuerySecurity ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This is the common routine for querying File ea called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The return status for the operation

        STATUS_NO_MORE_EAS(warning):

            If the index of the last Ea + 1 == EaIndex.

        STATUS_NONEXISTENT_EA_ENTRY(error):

            EaIndex > index of last Ea + 1.

        STATUS_EAS_NOT_SUPPORTED(error):

            Attempt to do an operation to a server that did not negotiate
            "KNOWS_EAS".

        STATUS_BUFFER_OVERFLOW(warning):

            User did not supply an EaList, at least one but not all Eas
            fit in the buffer.

        STATUS_BUFFER_TOO_SMALL(error):

            Could not fit a single Ea in the buffer.

            User supplied an EaList and not all Eas fit in the buffer.

        STATUS_NO_EAS_ON_FILE(error):
            There were no eas on the file.

        STATUS_SUCCESS:

            All Eas fit in the buffer.


        If STATUS_BUFFER_TOO_SMALL is returned then IoStatus.Information is set
        to 0.

Note:

    This code assumes that this is a buffered I/O operation.  If it is ever
    implemented as a non buffered operation, then we have to put code to map
    in the users buffer here.

--*/
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureParamBlock;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonQuerySecurity...\n", 0));
    RxDbgTrace( 0, Dbg, (" Wait                = %08lx\n", FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT)));
    RxDbgTrace( 0, Dbg, (" Irp                 = %08lx\n", capReqPacket ));
    RxDbgTrace( 0, Dbg, (" ->UserBuffer        = %08lx\n", capReqPacket->UserBuffer ));
    RxDbgTrace( 0, Dbg, (" ->Length            = %08lx\n", capPARAMS->Parameters.QuerySecurity.Length ));
    RxDbgTrace( 0, Dbg, (" ->SecurityInfo      = %08lx\n", capPARAMS->Parameters.QuerySecurity.SecurityInformation ));

    Status = RxpCommonMiscOp(
                 RxContext,
                 RxpCommonQuerySecurity);

    RxDbgTrace(-1, Dbg, ("RxCommonQuerySecurity -> %08lx\n", Status));

    return Status;
}

NTSTATUS
RxpCommonSetSecurity(
    RXCOMMON_SIGNATURE)
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureParamBlock;

    RxContext->SetSecurity.SecurityInformation =
        capPARAMS->Parameters.SetSecurity.SecurityInformation;

    RxContext->SetSecurity.SecurityDescriptor =
        capPARAMS->Parameters.SetSecurity.SecurityDescriptor;

    RxDbgTrace(0, Dbg, ("RxCommonSetSecurity -> Descr/Info = %08lx/%08lx\n",
                                RxContext->SetSecurity.SecurityDescriptor,
                                RxContext->SetSecurity.SecurityInformation ));

    MINIRDR_CALL(
        Status,
        RxContext,
        capFcb->MRxDispatch,
        MRxSetSdInfo,
        (RxContext));

    return Status;
}

NTSTATUS
RxCommonSetSecurity ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This routine implements the common Set Ea File Api called by the
    the Fsd and Fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The appropriate status for the Irp

--*/
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonSetSecurity...\n", 0));
    RxDbgTrace( 0, Dbg, (" Wait                = %08lx\n", FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT)));
    RxDbgTrace( 0, Dbg, (" Irp                 = %08lx\n", capReqPacket ));

    Status = RxpCommonMiscOp(
                 RxContext,
                 RxpCommonSetSecurity);

    RxDbgTrace(-1, Dbg, ("RxCommonSetSecurity -> %08lx\n", Status));

    return Status;
}

NTSTATUS
RxpCommonQueryEa(
    RXCOMMON_SIGNATURE)
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureParamBlock;

    PUCHAR  Buffer;
    ULONG   UserBufferLength;

    UserBufferLength  = capPARAMS->Parameters.QueryEa.Length;

    RxContext->QueryEa.UserEaList        = capPARAMS->Parameters.QueryEa.EaList;
    RxContext->QueryEa.UserEaListLength  = capPARAMS->Parameters.QueryEa.EaListLength;
    RxContext->QueryEa.UserEaIndex       = capPARAMS->Parameters.QueryEa.EaIndex;
    RxContext->QueryEa.RestartScan       = BooleanFlagOn(capPARAMS->Flags, SL_RESTART_SCAN);
    RxContext->QueryEa.ReturnSingleEntry = BooleanFlagOn(capPARAMS->Flags, SL_RETURN_SINGLE_ENTRY);
    RxContext->QueryEa.IndexSpecified    = BooleanFlagOn(capPARAMS->Flags, SL_INDEX_SPECIFIED);


    RxLockUserBuffer( RxContext, IoModifyAccess, UserBufferLength );

    //lock before map so that map will get userbuffer instead of assoc buffer
    Buffer = RxNewMapUserBuffer( RxContext );

    if ((Buffer != NULL) ||
        (UserBufferLength == 0)) {
        RxDbgTrace(0, Dbg, ("RxCommonQueryEa -> Buffer = %08lx\n", Buffer));

        RxContext->Info.Buffer = Buffer;
        RxContext->Info.LengthRemaining = UserBufferLength;

        MINIRDR_CALL(
            Status,
            RxContext,
            capFcb->MRxDispatch,
            MRxQueryEaInfo,
            (RxContext));

        //In addition to manipulating the LengthRemaining and filling the buffer,
        // the minirdr also updates the fileindex (capFobx->OffsetOfNextEaToReturn)

        capReqPacket->IoStatus.Information = capPARAMS->Parameters.QueryEa.Length - RxContext->Info.LengthRemaining;
    } else {
        capReqPacket->IoStatus.Information = 0;
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
RxCommonQueryEa ( RXCOMMON_SIGNATURE )

/*++

Routine Description:

    This is the common routine for querying File ea called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The return status for the operation

        STATUS_NO_MORE_EAS(warning):

            If the index of the last Ea + 1 == EaIndex.

        STATUS_NONEXISTENT_EA_ENTRY(error):

            EaIndex > index of last Ea + 1.

        STATUS_EAS_NOT_SUPPORTED(error):

            Attempt to do an operation to a server that did not negotiate
            "KNOWS_EAS".

        STATUS_BUFFER_OVERFLOW(warning):

            User did not supply an EaList, at least one but not all Eas
            fit in the buffer.

        STATUS_BUFFER_TOO_SMALL(error):

            Could not fit a single Ea in the buffer.

            User supplied an EaList and not all Eas fit in the buffer.

        STATUS_NO_EAS_ON_FILE(error):
            There were no eas on the file.

        STATUS_SUCCESS:

            All Eas fit in the buffer.


        If STATUS_BUFFER_TOO_SMALL is returned then IoStatus.Information is set
        to 0.

Note:

    This code assumes that this is a buffered I/O operation.  If it is ever
    implemented as a non buffered operation, then we have to put code to map
    in the users buffer here.


--*/
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureParamBlock;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonQueryEa...\n", 0));
    RxDbgTrace( 0, Dbg, (" Wait                = %08lx\n", FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT)));
    RxDbgTrace( 0, Dbg, (" Irp                 = %08lx\n", capReqPacket ));
    RxDbgTrace( 0, Dbg, (" ->SystemBuffer      = %08lx\n", capReqPacket->AssociatedIrp.SystemBuffer ));
    RxDbgTrace( 0, Dbg, (" ->UserBuffer        = %08lx\n", capReqPacket->UserBuffer ));
    RxDbgTrace( 0, Dbg, (" ->Length            = %08lx\n", capPARAMS->Parameters.QueryEa.Length ));
    RxDbgTrace( 0, Dbg, (" ->EaList            = %08lx\n", capPARAMS->Parameters.QueryEa.EaList ));
    RxDbgTrace( 0, Dbg, (" ->EaListLength      = %08lx\n", capPARAMS->Parameters.QueryEa.EaListLength ));
    RxDbgTrace( 0, Dbg, (" ->EaIndex           = %08lx\n", capPARAMS->Parameters.QueryEa.EaIndex ));
    RxDbgTrace( 0, Dbg, (" ->RestartScan       = %08lx\n", FlagOn(capPARAMS->Flags, SL_RESTART_SCAN)));
    RxDbgTrace( 0, Dbg, (" ->ReturnSingleEntry = %08lx\n", FlagOn(capPARAMS->Flags, SL_RETURN_SINGLE_ENTRY)));
    RxDbgTrace( 0, Dbg, (" ->IndexSpecified    = %08lx\n", FlagOn(capPARAMS->Flags, SL_INDEX_SPECIFIED)));

    Status = RxpCommonMiscOp(
                 RxContext,
                 RxpCommonQueryEa);

    RxDbgTrace(-1, Dbg, ("RxCommonQueryEa -> %08lx\n", Status));

    return Status;
}

NTSTATUS
RxpCommonSetEa(
    RXCOMMON_SIGNATURE)
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    PUCHAR Buffer;
    ULONG UserBufferLength;

    //  Reference our input parameters to make things easier

    UserBufferLength  = capPARAMS->Parameters.SetEa.Length;

    capFileObject->Flags |= FO_FILE_MODIFIED;
    RxLockUserBuffer(
        RxContext,
        IoModifyAccess,
        UserBufferLength );

    //unless we lock first, rxmap actually gets the systembuffer!
    Buffer = RxNewMapUserBuffer( RxContext );

    if ((Buffer != NULL) ||
        (UserBufferLength == 0)) {
        ULONG ErrorOffset;

        RxDbgTrace(0, Dbg, ("RxCommonSetEa -> Buffer = %08lx\n", Buffer));

        //
        //  Check the validity of the buffer with the new eas.
        //

        Status = IoCheckEaBufferValidity(
                     (PFILE_FULL_EA_INFORMATION) Buffer,
                     UserBufferLength,
                     &ErrorOffset );

        if (!NT_SUCCESS( Status )) {
            capReqPacket->IoStatus.Information = ErrorOffset;
            return Status;
        }
    } else {
        capReqPacket->IoStatus.Information = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    capReqPacket->IoStatus.Information = 0;
    RxContext->Info.Buffer = Buffer;
    RxContext->Info.Length = UserBufferLength;

    MINIRDR_CALL(
        Status,
        RxContext,
        capFcb->MRxDispatch,
        MRxSetEaInfo,
        (RxContext));

    return Status;
}


NTSTATUS
RxCommonSetEa ( RXCOMMON_SIGNATURE )

/*++

Routine Description:

    This routine implements the common Set Ea File Api called by the
    the Fsd and Fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The appropriate status for the Irp

--*/

{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureParamBlock;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonSetEa...\n", 0));
    RxDbgTrace( 0, Dbg, (" Wait                = %08lx\n", FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT)));
    RxDbgTrace( 0, Dbg, (" Irp                 = %08lx\n", capReqPacket ));
    RxDbgTrace( 0, Dbg, (" ->SystemBuffer      = %08lx\n", capReqPacket->UserBuffer ));
    RxDbgTrace( 0, Dbg, (" ->Length            = %08lx\n", capPARAMS->Parameters.SetEa.Length ));


    Status = RxpCommonMiscOp(
                 RxContext,
                 RxpCommonSetEa);

    RxDbgTrace(-1, Dbg, ("RxCommonSetEa -> %08lx\n", Status));

    return Status;
}

NTSTATUS
RxpCommonQueryQuotaInformation(
    RXCOMMON_SIGNATURE)
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureParamBlock;
    RxCaptureFcb;

    PUCHAR  Buffer;
    ULONG   UserBufferLength;

    UserBufferLength  = capPARAMS->Parameters.QueryQuota.Length;

    RxContext->QueryQuota.SidList        = capPARAMS->Parameters.QueryQuota.SidList;
    RxContext->QueryQuota.SidListLength  = capPARAMS->Parameters.QueryQuota.SidListLength;
    RxContext->QueryQuota.StartSid       = capPARAMS->Parameters.QueryQuota.StartSid;
    RxContext->QueryQuota.Length         = capPARAMS->Parameters.QueryQuota.Length;

    RxContext->QueryQuota.RestartScan       = BooleanFlagOn(capPARAMS->Flags, SL_RESTART_SCAN);
    RxContext->QueryQuota.ReturnSingleEntry = BooleanFlagOn(capPARAMS->Flags, SL_RETURN_SINGLE_ENTRY);
    RxContext->QueryQuota.IndexSpecified    = BooleanFlagOn(capPARAMS->Flags, SL_INDEX_SPECIFIED);


    RxLockUserBuffer(
        RxContext,
        IoModifyAccess,
        UserBufferLength );

    //lock before map so that map will get userbuffer instead of assoc buffer
    Buffer = RxNewMapUserBuffer( RxContext );

    if ((Buffer != NULL) ||
        (UserBufferLength == 0)) {
        RxDbgTrace(0, Dbg, ("RxCommonQueryQuota -> Buffer = %08lx\n", Buffer));

        RxContext->Info.Buffer = Buffer;
        RxContext->Info.LengthRemaining = UserBufferLength;

        MINIRDR_CALL(
            Status,
            RxContext,
            capFcb->MRxDispatch,
            MRxQueryQuotaInfo,
            (RxContext));

        capReqPacket->IoStatus.Information = RxContext->Info.LengthRemaining;
    } else {
        capReqPacket->IoStatus.Information = 0;
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
RxCommonQueryQuotaInformation(
    RXCOMMON_SIGNATURE)
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureParamBlock;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonQueryQueryQuotaInformation...\n", 0));
    RxDbgTrace( 0, Dbg, (" Wait                = %08lx\n", FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT)));
    RxDbgTrace( 0, Dbg, (" Irp                 = %08lx\n", capReqPacket ));
    RxDbgTrace( 0, Dbg, (" ->SystemBuffer      = %08lx\n", capReqPacket->AssociatedIrp.SystemBuffer ));
    RxDbgTrace( 0, Dbg, (" ->UserBuffer        = %08lx\n", capReqPacket->UserBuffer ));
    RxDbgTrace( 0, Dbg, (" ->Length            = %08lx\n", capPARAMS->Parameters.QueryQuota.Length ));
    RxDbgTrace( 0, Dbg, (" ->StartSid          = %08lx\n", capPARAMS->Parameters.QueryQuota.StartSid ));
    RxDbgTrace( 0, Dbg, (" ->SidList           = %08lx\n", capPARAMS->Parameters.QueryQuota.SidList ));
    RxDbgTrace( 0, Dbg, (" ->SidListLength     = %08lx\n", capPARAMS->Parameters.QueryQuota.SidListLength ));
    RxDbgTrace( 0, Dbg, (" ->RestartScan       = %08lx\n", FlagOn(capPARAMS->Flags, SL_RESTART_SCAN)));
    RxDbgTrace( 0, Dbg, (" ->ReturnSingleEntry = %08lx\n", FlagOn(capPARAMS->Flags, SL_RETURN_SINGLE_ENTRY)));
    RxDbgTrace( 0, Dbg, (" ->IndexSpecified    = %08lx\n", FlagOn(capPARAMS->Flags, SL_INDEX_SPECIFIED)));

    Status = RxpCommonMiscOp(
                 RxContext,
                 RxpCommonQueryQuotaInformation);

    return Status;
}

NTSTATUS
RxpCommonSetQuotaInformation(
    RXCOMMON_SIGNATURE)
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureParamBlock;
    RxCaptureFcb;

    PUCHAR  Buffer;
    ULONG   UserBufferLength;

    PAGED_CODE();

    UserBufferLength  = capPARAMS->Parameters.SetQuota.Length;

    RxLockUserBuffer(
        RxContext,
        IoModifyAccess,
        UserBufferLength );

    //lock before map so that map will get userbuffer instead of assoc buffer
    Buffer = RxNewMapUserBuffer( RxContext );

    if ((Buffer != NULL) ||
        (UserBufferLength == 0)) {
        RxDbgTrace(0, Dbg, ("RxCommonQueryQuota -> Buffer = %08lx\n", Buffer));

        RxContext->Info.Buffer = Buffer;
        RxContext->Info.LengthRemaining = UserBufferLength;

        MINIRDR_CALL(
            Status,
            RxContext,
            capFcb->MRxDispatch,
            MRxSetQuotaInfo,
            (RxContext));
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
RxCommonSetQuotaInformation(
    RXCOMMON_SIGNATURE)
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureParamBlock;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonSetQuotaInformation...\n", 0));
    RxDbgTrace( 0, Dbg, (" Wait                = %08lx\n", FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT)));
    RxDbgTrace( 0, Dbg, (" Irp                 = %08lx\n", capReqPacket ));

    Status = RxpCommonMiscOp(
                 RxContext,
                 RxpCommonSetQuotaInformation);

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dirctrl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DirCtrl.c

Abstract:

    This module implements the File Directory Control routines for Rx called
    by the dispatch driver.

Author:

    Joe Linn     [Joe Linn]    4-oct-94

    Balan Sethu Raman [SethuR] 16-Oct-95  Hook in the notify change API routines

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_DIRCTRL)


WCHAR Rx8QMdot3QM[12] = { DOS_QM, DOS_QM, DOS_QM, DOS_QM, DOS_QM, DOS_QM, DOS_QM, DOS_QM,
                           L'.', DOS_QM, DOS_QM, DOS_QM};

WCHAR RxStarForTemplate[] = L"*";

//
//  Local procedure prototypes
//

NTSTATUS
RxQueryDirectory ( RXCOMMON_SIGNATURE );

NTSTATUS
RxNotifyChangeDirectory ( RXCOMMON_SIGNATURE );

NTSTATUS
RxLowIoNotifyChangeDirectoryCompletion( RXCOMMON_SIGNATURE );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonDirectoryControl)
#pragma alloc_text(PAGE, RxNotifyChangeDirectory)
#pragma alloc_text(PAGE, RxQueryDirectory)
#pragma alloc_text(PAGE, RxLowIoNotifyChangeDirectoryCompletion)
#endif

NTSTATUS
RxCommonDirectoryControl ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This is the common routine for doing directory control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;

    PAGED_CODE();

    //
    //  Get a pointer to the current Irp stack location
    //

    RxDbgTrace(+1, Dbg, ("RxCommonDirectoryControl IrpC/Fobx/Fcb = %08lx %08lx %08lx\n",
                               RxContext,capFobx,capFcb));
    RxDbgTrace( 0, Dbg, ("MinorFunction = %08lx\n", capPARAMS->MinorFunction ));
    RxLog(("CommDirC %lx %lx %lx %ld\n",RxContext,capFobx,capFcb,capPARAMS->MinorFunction));
    RxWmiLog(LOG,
             RxCommonDirectoryControl,
             LOGPTR(RxContext)
             LOGPTR(capFobx)
             LOGPTR(capFcb)
             LOGUCHAR(capPARAMS->MinorFunction));

    //  This is to fix bug 174103 in our rdpdr minirdr.  As we can't determine
    //  the exact storage type in some cases.  We'll have a real fix for Beta2.
    //
    //if (NodeType(capFcb) != RDBSS_NTC_STORAGE_TYPE_DIRECTORY) {
    //    return STATUS_NOT_SUPPORTED;
    //}

    //
    //  We know this is a directory control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //

    switch ( capPARAMS->MinorFunction ) {

    case IRP_MN_QUERY_DIRECTORY:
        Status = RxQueryDirectory( RxContext );

        // in case of session time out, STATUS_RETRY is returned
        //if (Status == STATUS_RETRY) {
            //in case of remote boot reconnect, the handle on the server has been delete.
            //query directory has to start from beginning.
            //Status = STATUS_INVALID_NETWORK_RESPONSE;

        //}
        break;

    case IRP_MN_NOTIFY_CHANGE_DIRECTORY:
        Status = RxNotifyChangeDirectory( RxContext );

        if (Status == STATUS_PENDING) {
            RxDereferenceAndDeleteRxContext(RxContext);
        }
        break;

    default:
        RxDbgTrace(0, Dbg, ("Invalid Directory Control Minor Function %08lx\n", capPARAMS->MinorFunction));
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    RxDbgTrace(-1, Dbg, ("RxCommonDirectoryControl -> %08lx\n", Status));

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
RxQueryDirectory  ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This routine performs the query directory operation.  It is responsible
    for either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;
    TYPE_OF_OPEN TypeOfOpen = NodeType(capFcb);

    PFCB Dcb = capFcb;
    CLONG UserBufferLength;

    PUNICODE_STRING UniArgFileName;
    FILE_INFORMATION_CLASS FileInformationClass;
    BOOLEAN PostQuery = FALSE;

    PAGED_CODE();


    //
    //  Display the input values.
    //
    RxDbgTrace(+1, Dbg, ("RxQueryDirectory...\n", 0));
    RxDbgTrace( 0, Dbg, (" Wait              = %08lx\n", FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT)));
    RxDbgTrace( 0, Dbg, (" Irp               = %08lx\n", capReqPacket));
    RxDbgTrace( 0, Dbg, (" ->UserBufLength   = %08lx\n", capPARAMS->Parameters.QueryDirectory.Length));
    RxDbgTrace( 0, Dbg, (" ->FileName = %08lx\n", capPARAMS->Parameters.QueryDirectory.FileName));
    IF_DEBUG {
        if (capPARAMS->Parameters.QueryDirectory.FileName) {
            RxDbgTrace( 0, Dbg, (" ->     %wZ\n", capPARAMS->Parameters.QueryDirectory.FileName ));
    }}
    RxDbgTrace( 0, Dbg, (" ->FileInformationClass = %08lx\n", capPARAMS->Parameters.QueryDirectory.FileInformationClass));
    RxDbgTrace( 0, Dbg, (" ->FileIndex       = %08lx\n", capPARAMS->Parameters.QueryDirectory.FileIndex));
    RxDbgTrace( 0, Dbg, (" ->UserBuffer      = %08lx\n", capReqPacket->UserBuffer));
    RxDbgTrace( 0, Dbg, (" ->RestartScan     = %08lx\n", FlagOn( capPARAMS->Flags, SL_RESTART_SCAN )));
    RxDbgTrace( 0, Dbg, (" ->ReturnSingleEntry = %08lx\n", FlagOn( capPARAMS->Flags, SL_RETURN_SINGLE_ENTRY )));
    RxDbgTrace( 0, Dbg, (" ->IndexSpecified  = %08lx\n", FlagOn( capPARAMS->Flags, SL_INDEX_SPECIFIED )));

    RxLog(("Qry %lx %d %ld %lx %d\n",
           RxContext, BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT), //1,2
           capPARAMS->Parameters.QueryDirectory.Length, capPARAMS->Parameters.QueryDirectory.FileName, //3,4
           capPARAMS->Parameters.QueryDirectory.FileInformationClass //5
          ));
    RxWmiLog(LOG,
             RxQueryDirectory_1,
             LOGPTR(RxContext)
             LOGULONG(RxContext->Flags)
             LOGULONG(capPARAMS->Parameters.QueryDirectory.Length)
             LOGPTR(capPARAMS->Parameters.QueryDirectory.FileName)
             LOGULONG(capPARAMS->Parameters.QueryDirectory.FileInformationClass));
    RxLog(("  alsoqry  %d %lx %lx\n",
           capPARAMS->Parameters.QueryDirectory.FileIndex, capReqPacket->UserBuffer, capPARAMS->Flags //1,2,3
          ));
    RxWmiLog(LOG,
             RxQueryDirectory_2,
             LOGULONG(capPARAMS->Parameters.QueryDirectory.FileIndex)
             LOGPTR(capReqPacket->UserBuffer)
             LOGUCHAR(capPARAMS->Flags));
    if (capPARAMS->Parameters.QueryDirectory.FileName) {
        RxLog((" QryName %wZ\n",
                     ((PUNICODE_STRING)capPARAMS->Parameters.QueryDirectory.FileName)));
        RxWmiLog(LOG,
                 RxQueryDirectory_3,
                 LOGUSTR(*capPARAMS->Parameters.QueryDirectory.FileName));
    }


//#ifndef _CAIRO_
//    if (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_DIRECTORY ) {
//        RxDbgTrace(-1, Dbg, ("RxQueryDirectory -> RxStatus(INVALID_PARAMETER\n)", 0));
//        return STATUS_INVALID_PARAMETER;
//    }
//#endif // _CAIRO_


    //
    //  If this is the initial query, then grab exclusive access in
    //  order to update the search string in the Fobx.  We may
    //  discover that we are not the initial query once we grab the Fcb
    //  and downgrade our status.
    //

    if (capFobx == NULL) {
        return STATUS_OBJECT_NAME_INVALID;
    }

    if (capFcb->pNetRoot->Type != NET_ROOT_DISK) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  Reference our input parameters to make things easier
    //

    UserBufferLength = capPARAMS->Parameters.QueryDirectory.Length;
    FileInformationClass = capPARAMS->Parameters.QueryDirectory.FileInformationClass;
    UniArgFileName = (PUNICODE_STRING) capPARAMS->Parameters.QueryDirectory.FileName;


    RxContext->QueryDirectory.FileIndex = capPARAMS->Parameters.QueryDirectory.FileIndex;
    RxContext->QueryDirectory.RestartScan       = BooleanFlagOn(capPARAMS->Flags, SL_RESTART_SCAN);
    RxContext->QueryDirectory.ReturnSingleEntry = BooleanFlagOn(capPARAMS->Flags, SL_RETURN_SINGLE_ENTRY);
    RxContext->QueryDirectory.IndexSpecified    = BooleanFlagOn(capPARAMS->Flags, SL_INDEX_SPECIFIED);
    RxContext->QueryDirectory.InitialQuery = (BOOLEAN)((capFobx->UnicodeQueryTemplate.Buffer == NULL) &&
                                                        !FlagOn(capFobx->Flags, FOBX_FLAG_MATCH_ALL));

    if (RxContext->QueryDirectory.IndexSpecified) {
       return STATUS_NOT_IMPLEMENTED;
    }

    if (RxContext->QueryDirectory.InitialQuery) {
        Status = RxAcquireExclusiveFcb(RxContext,Dcb);

        if (Status == STATUS_LOCK_NOT_GRANTED) {
            PostQuery = TRUE;
        } else if (Status != STATUS_SUCCESS) {
           RxDbgTrace(0, Dbg, ("RxQueryDirectory -> Could not acquire Dcb(%lx) %lx\n",Dcb,Status));
           return Status;
        } else if (capFobx->UnicodeQueryTemplate.Buffer != NULL) {
            RxContext->QueryDirectory.InitialQuery = FALSE;
            RxConvertToSharedFcb( RxContext, Dcb );
        }
    } else {
        Status = RxAcquireExclusiveFcb(RxContext,Dcb);

        if (Status == STATUS_LOCK_NOT_GRANTED) {
            PostQuery = TRUE;
        } else if (Status != STATUS_SUCCESS) {
            RxDbgTrace(0, Dbg, ("RxQueryDirectory -> Could not acquire Dcb(%lx) %lx\n",Dcb,Status));
            return Status;
        }
    }

    if (PostQuery) {
        RxDbgTrace(0, Dbg, ("RxQueryDirectory -> Enqueue to Fsp\n", 0));
        Status = RxFsdPostRequest( RxContext );
        RxDbgTrace(-1, Dbg, ("RxQueryDirectory -> %08lx\n", Status));

        return Status;
    }

    if (FlagOn(Dcb->FcbState,FCB_STATE_ORPHANED)) {
        RxReleaseFcb( RxContext, Dcb );
        return STATUS_FILE_CLOSED;
    }

    try {

        Status = STATUS_SUCCESS;

        //
        //  Determine where to start the scan.  Highest priority is given
        //  to the file index.  Lower priority is the restart flag.  If
        //  neither of these is specified, then the existing value in the
        //  Fobx is used.
        //

        if (!RxContext->QueryDirectory.IndexSpecified && RxContext->QueryDirectory.RestartScan) {
            RxContext->QueryDirectory.FileIndex = 0;
        }

        //
        //  If this is the first try then allocate a buffer for the file
        //  name.
        //

        if (RxContext->QueryDirectory.InitialQuery) {

            ASSERT(    !FlagOn( capFobx->Flags, FOBX_FLAG_FREE_UNICODE )  );

            //
            //  If either:
            //
            //  - No name was specified
            //  - An empty name was specified
            //  - We received a '*'
            //  - The user specified the DOS equivolent of ????????.???
            //
            //  then match all names.
            //

            if ((UniArgFileName == NULL) ||
                (UniArgFileName->Length == 0) ||
                (UniArgFileName->Buffer == NULL) ||
                ((UniArgFileName->Length == sizeof(WCHAR)) &&
                 (UniArgFileName->Buffer[0] == L'*')) ||
                ((UniArgFileName->Length == 12*sizeof(WCHAR)) &&
                 (RtlCompareMemory( UniArgFileName->Buffer,
                                    Rx8QMdot3QM,
                                    12*sizeof(WCHAR) )) == 12*sizeof(WCHAR))) {

                capFobx->ContainsWildCards = TRUE;

                capFobx->UnicodeQueryTemplate.Buffer = RxStarForTemplate;
                capFobx->UnicodeQueryTemplate.Length = sizeof(WCHAR);
                capFobx->UnicodeQueryTemplate.MaximumLength = sizeof(WCHAR);

                SetFlag( capFobx->Flags, FOBX_FLAG_MATCH_ALL );

            } else {

                PVOID TemplateBuffer;

                //
                //  See if the name has wild cards & allocate template buffer
                //

                capFobx->ContainsWildCards =
                    FsRtlDoesNameContainWildCards( UniArgFileName );

                TemplateBuffer = RxAllocatePoolWithTag(
                                     PagedPool,
                                     UniArgFileName->Length,
                                     RX_DIRCTL_POOLTAG);

                if (TemplateBuffer != NULL) {

                    //
                    //  Validate that the length is in sizeof(WCHAR) increments
                    //

                    if(FlagOn( UniArgFileName->Length, 1 )) {
                        Status = STATUS_INVALID_PARAMETER;  
                        RxFreePool( TemplateBuffer );
                    } else {

                        RxDbgTrace( 0, Dbg, ("RxQueryDirectory -> TplateBuffer = %08lx\n", TemplateBuffer) );
                        capFobx->UnicodeQueryTemplate.Buffer = TemplateBuffer;
                        capFobx->UnicodeQueryTemplate.Length = UniArgFileName->Length;
                        capFobx->UnicodeQueryTemplate.MaximumLength = UniArgFileName->Length;

                        RtlMoveMemory( capFobx->UnicodeQueryTemplate.Buffer,
                                       UniArgFileName->Buffer,UniArgFileName->Length );

                        RxDbgTrace( 0, Dbg, ("RxQueryDirectory -> Template = %wZ\n", &Fobx->UnicodeQueryTemplate) );
                        SetFlag( capFobx->Flags, FOBX_FLAG_FREE_UNICODE );
                    }
                } else {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            if (Status == STATUS_SUCCESS) {
               //
               //  We convert to shared access before going to the net.
               //

               RxConvertToSharedFcb( RxContext, Dcb );
            }
        }

        if (Status == STATUS_SUCCESS) {
           RxLockUserBuffer( RxContext, IoModifyAccess, UserBufferLength );
           RxContext->Info.FileInformationClass = FileInformationClass;
           RxContext->Info.Buffer = RxNewMapUserBuffer( RxContext );
           RxContext->Info.LengthRemaining = UserBufferLength;

           if (RxContext->Info.Buffer != NULL) {
               MINIRDR_CALL(Status,RxContext,Dcb->MRxDispatch,MRxQueryDirectory,
                               (RxContext)
                          ); //minirdr updates the fileindex

               if (RxContext->PostRequest) {
                   RxDbgTrace(0, Dbg, ("RxQueryDirectory -> Enqueue to Fsp from minirdr\n", 0));
                   Status = RxFsdPostRequest( RxContext );
               } else {
                   capReqPacket->IoStatus.Information = UserBufferLength - RxContext->Info.LengthRemaining;
               }
           } else {
               if (capReqPacket->MdlAddress != NULL) {
                   Status = STATUS_INSUFFICIENT_RESOURCES;
               } else {
                   Status = STATUS_INVALID_PARAMETER;
               }
           }
        }
    } finally {

        DebugUnwind( RxQueryDirectory );

        RxReleaseFcb( RxContext, Dcb );

        RxDbgTrace(-1, Dbg, ("RxQueryDirectory -> %08lx\n", Status));

    }

    return Status;
}

NTSTATUS
RxNotifyChangeDirectory  ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This routine performs the notify change directory operation.  It is
    responsible for either completing or enqueuing the operation.

Arguments:

    RxContext - the RDBSS context for the operation

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;

    ULONG   CompletionFilter;
    BOOLEAN WatchTree;

    PLOWIO_CONTEXT pLowIoContext  = &RxContext->LowIoContext;
    TYPE_OF_OPEN TypeOfOpen = NodeType(capFcb);

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxNotifyChangeDirectory...\n", 0));
    RxDbgTrace( 0, Dbg, (" Wait               = %08lx\n", FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT)));
    RxDbgTrace( 0, Dbg, (" Irp                = %08lx\n", capReqPacket));
    RxDbgTrace( 0, Dbg, (" ->CompletionFilter = %08lx\n", capPARAMS->Parameters.NotifyDirectory.CompletionFilter));

    //  Always set the wait flag in the Irp context for the original request.
    SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_WAIT );

    //  Check on the type of open.  We return invalid parameter for all
    //  but UserDirectoryOpens.
    RxInitializeLowIoContext(pLowIoContext,LOWIO_OP_NOTIFY_CHANGE_DIRECTORY);

    //  Reference our input parameter to make things easier
    CompletionFilter = capPARAMS->Parameters.NotifyDirectory.CompletionFilter;
    WatchTree = BooleanFlagOn( capPARAMS->Flags, SL_WATCH_TREE );

    try {
        RxLockUserBuffer(
            RxContext,
            IoWriteAccess,
            capPARAMS->Parameters.NotifyDirectory.Length);

        pLowIoContext->ParamsFor.NotifyChangeDirectory.WatchTree = WatchTree;
        pLowIoContext->ParamsFor.NotifyChangeDirectory.CompletionFilter = CompletionFilter;

        pLowIoContext->ParamsFor.NotifyChangeDirectory.NotificationBufferLength =
                  capPARAMS->Parameters.NotifyDirectory.Length;

        if (capReqPacket->MdlAddress != NULL) {
            pLowIoContext->ParamsFor.NotifyChangeDirectory.pNotificationBuffer =
                      MmGetSystemAddressForMdlSafe(
                          capReqPacket->MdlAddress,
                          NormalPagePriority);

            if (pLowIoContext->ParamsFor.NotifyChangeDirectory.pNotificationBuffer
                == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                Status = RxLowIoSubmit(
                             RxContext,
                             RxLowIoNotifyChangeDirectoryCompletion);
            }
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
    } finally {
        DebugUnwind( RxNotifyChangeDirectory );

        RxDbgTrace(-1, Dbg, ("RxNotifyChangeDirectory -> %08lx\n", Status));
    }

    return Status;
}

NTSTATUS
RxLowIoNotifyChangeDirectoryCompletion( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This is the completion routine for NotifyChangeDirectory requests passed down
    to thr mini redirectors

Arguments:

    RxContext -- the RDBSS context associated with the operation

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    RxCaptureRequestPacket;

    NTSTATUS       Status;
    PLOWIO_CONTEXT pLowIoContext  = &RxContext->LowIoContext;

    PAGED_CODE();

    Status = RxContext->StoredStatus;
    RxDbgTrace(+1, Dbg, ("RxLowIoChangeNotifyDirectoryShellCompletion  entry  Status = %08lx\n", Status));

    capReqPacket->IoStatus.Information = RxContext->InformationToReturn;
    capReqPacket->IoStatus.Status = Status;

    RxDbgTrace(-1, Dbg, ("RxLowIoChangeNotifyDirectoryShellCompletion  exit  Status = %08lx\n", Status));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\fileinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FileInfo.c

Abstract:

    This module implements the File Information routines for Rx called by
    the dispatch driver.

Author:

    Joe Linn     [JoeLinn]   5-oct-94

Revision History:

    Balan Sethu Raman 15-May-95 --  reworked to fit in pipe FSCTL's

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg (DEBUG_TRACE_FILEINFO)

NTSTATUS
RxQueryBasicInfo (
    IN PRX_CONTEXT RxContext,
    IN OUT PFILE_BASIC_INFORMATION Buffer
    );

NTSTATUS
RxQueryStandardInfo (
    IN PRX_CONTEXT RxContext,
    IN OUT PFILE_STANDARD_INFORMATION Buffer
    );

NTSTATUS
RxQueryInternalInfo (
    IN PRX_CONTEXT RxContext,
    IN OUT PFILE_INTERNAL_INFORMATION Buffer
    );

NTSTATUS
RxQueryEaInfo (
    IN PRX_CONTEXT RxContext,
    IN OUT PFILE_EA_INFORMATION Buffer
    );

NTSTATUS
RxQueryPositionInfo (
    IN PRX_CONTEXT RxContext,
    IN OUT PFILE_POSITION_INFORMATION Buffer
    );

NTSTATUS
RxQueryNameInfo (
    IN PRX_CONTEXT RxContext,
    IN OUT PFILE_NAME_INFORMATION Buffer
    );

NTSTATUS
RxQueryAlternateNameInfo (
    IN PRX_CONTEXT RxContext,
    IN OUT PFILE_NAME_INFORMATION Buffer
    );

NTSTATUS
RxQueryCompressedInfo (
    IN PRX_CONTEXT RxContext,
    IN OUT PFILE_COMPRESSION_INFORMATION Buffer
    );

NTSTATUS
RxQueryPipeInfo (
    IN PRX_CONTEXT RxContext,
    IN OUT PVOID pPipeInformation
    );

NTSTATUS
RxSetBasicInfo (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxSetDispositionInfo (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxSetRenameInfo (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxSetPositionInfo (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxSetAllocationInfo (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxSetEndOfFileInfo (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxSetPipeInfo(
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxSetSimpleInfo(
    IN PRX_CONTEXT RxContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonQueryInformation)
#pragma alloc_text(PAGE, RxCommonSetInformation)
#pragma alloc_text(PAGE, RxSetAllocationInfo)
#pragma alloc_text(PAGE, RxQueryBasicInfo)
#pragma alloc_text(PAGE, RxQueryEaInfo)
#pragma alloc_text(PAGE, RxQueryInternalInfo)
#pragma alloc_text(PAGE, RxQueryNameInfo)
#pragma alloc_text(PAGE, RxQueryAlternateNameInfo)
#pragma alloc_text(PAGE, RxQueryPositionInfo)
#pragma alloc_text(PAGE, RxQueryStandardInfo)
#pragma alloc_text(PAGE, RxQueryPipeInfo)
#pragma alloc_text(PAGE, RxSetBasicInfo)
#pragma alloc_text(PAGE, RxSetDispositionInfo)
#pragma alloc_text(PAGE, RxSetEndOfFileInfo)
#pragma alloc_text(PAGE, RxSetPositionInfo)
#pragma alloc_text(PAGE, RxSetRenameInfo)
#pragma alloc_text(PAGE, RxSetPipeInfo)
#pragma alloc_text(PAGE, RxSetSimpleInfo)
#pragma alloc_text(PAGE, RxConjureOriginalName)
#pragma alloc_text(PAGE, RxQueryCompressedInfo)
#endif

NTSTATUS
RxpSetInfoMiniRdr(
    PRX_CONTEXT            RxContext,
    FILE_INFORMATION_CLASS FileInformationClass)
{
    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureParamBlock;

    NTSTATUS Status;

    RxContext->Info.FileInformationClass = FileInformationClass;
    RxContext->Info.Buffer = capReqPacket->AssociatedIrp.SystemBuffer;
    RxContext->Info.Length = capPARAMS->Parameters.SetFile.Length;
    MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxSetFileInfo,(RxContext));

    return Status;
}

NTSTATUS
RxpQueryInfoMiniRdr(
    PRX_CONTEXT            RxContext,
    FILE_INFORMATION_CLASS InformationClass,
    PVOID                  Buffer)
{
    RxCaptureFcb;

    NTSTATUS Status;

    RxContext->Info.FileInformationClass = InformationClass;
    RxContext->Info.Buffer = Buffer;

    MINIRDR_CALL(
        Status,
        RxContext,
        capFcb->MRxDispatch,
        MRxQueryFileInfo,
        (RxContext));

    return Status;
}

 NTSTATUS
RxCommonQueryInformation ( RXCOMMON_SIGNATURE )
/*++
Routine Description:

    This is the common routine for querying file information called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    NODE_TYPE_CODE         TypeOfOpen = NodeType(capFcb);
    PVOID                  Buffer = NULL;
    FILE_INFORMATION_CLASS FileInformationClass = capPARAMS->Parameters.QueryFile.FileInformationClass;

    BOOLEAN FcbAcquired = FALSE;
    BOOLEAN PostIrp     = FALSE;

    PFILE_ALL_INFORMATION AllInfo;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonQueryInformation...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, capFobx, capFcb));
    RxDbgTrace( 0, Dbg, ("               Buffer     %08lx Length  %08lx FileInfoClass %08lx\n",
                             capReqPacket->AssociatedIrp.SystemBuffer,
                             capPARAMS->Parameters.QueryFile.Length,
                             capPARAMS->Parameters.QueryFile.FileInformationClass
                             ));
    RxLog(("QueryFileInfo %lx %lx %lx\n",RxContext,capFcb,capFobx));
    RxWmiLog(LOG,
             RxCommonQueryInformation_1,
             LOGPTR(RxContext)
             LOGPTR(capFcb)
             LOGPTR(capFobx));
    RxLog(("  alsoqfi %lx %lx %ld\n",
                 capReqPacket->AssociatedIrp.SystemBuffer,
                 capPARAMS->Parameters.QueryFile.Length,
                 capPARAMS->Parameters.QueryFile.FileInformationClass
                 ));
    RxWmiLog(LOG,
             RxCommonQueryInformation_2,
             LOGPTR(capReqPacket->AssociatedIrp.SystemBuffer)
             LOGULONG(capPARAMS->Parameters.QueryFile.Length)
             LOGULONG(capPARAMS->Parameters.QueryFile.FileInformationClass));

    RxContext->Info.LengthRemaining = (LONG)capPARAMS->Parameters.QueryFile.Length;

    try {
        // Obtain the Request packet's(user's) buffer
        Buffer = RxMapSystemBuffer(RxContext);

        if (Buffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            try_return(Status);
        }
        // Zero the buffer
        RtlZeroMemory(
            Buffer,
            RxContext->Info.LengthRemaining);

        //  Case on the type of open we're dealing with
        switch (TypeOfOpen) {
        case RDBSS_NTC_STORAGE_TYPE_FILE:
        case RDBSS_NTC_STORAGE_TYPE_UNKNOWN:
        case RDBSS_NTC_STORAGE_TYPE_DIRECTORY:
            {
               //  Acquire shared access to the fcb, except for a paging file
               //  in order to avoid deadlocks with Mm.
               if (!FlagOn( capFcb->FcbState, FCB_STATE_PAGING_FILE )) {

                   if (FileInformationClass != FileNameInformation) {

                       //  If this is FileCompressedFileSize, we need the Fcb
                       //  exclusive.
                       if (FileInformationClass != FileCompressionInformation) {
                           Status = RxAcquireSharedFcb(RxContext,capFcb);
                       } else {
                           Status = RxAcquireExclusiveFcb( RxContext, capFcb );
                       }

                       if (Status == STATUS_LOCK_NOT_GRANTED) {
                           RxDbgTrace(0, Dbg, ("Cannot acquire Fcb\n", 0));
                           try_return( PostIrp = TRUE );
                       } else if (Status != STATUS_SUCCESS) {
                           try_return(PostIrp = FALSE);
                       }

                       FcbAcquired = TRUE;
                   }
               }

               //
               //  Based on the information class, call down to the minirdr
               //  we either complete or we post

               switch (FileInformationClass) {

               case FileAllInformation:

                   //
                   //  For the all information class we'll typecast a local
                   //  pointer to the output buffer and then call the
                   //  individual routines to fill in the buffer.
                   //

                   AllInfo = Buffer;

           // can't rely on QueryXXInfo functions to calculate LengthRemaining due to
           // possible allignment issues
           RxContext->Info.LengthRemaining = (LONG)capPARAMS->Parameters.QueryFile.Length
                                             - FIELD_OFFSET(FILE_ALL_INFORMATION, BasicInformation);

                   Status = RxQueryBasicInfo( RxContext, &AllInfo->BasicInformation );
           if (Status!=STATUS_SUCCESS) break;

           RxContext->Info.LengthRemaining = (LONG)capPARAMS->Parameters.QueryFile.Length
                                              - FIELD_OFFSET(FILE_ALL_INFORMATION, StandardInformation);

                   Status = RxQueryStandardInfo( RxContext, &AllInfo->StandardInformation );
                   if (Status!=STATUS_SUCCESS) break;

           RxContext->Info.LengthRemaining = (LONG)capPARAMS->Parameters.QueryFile.Length
                                             - FIELD_OFFSET(FILE_ALL_INFORMATION, InternalInformation);

                   Status = RxQueryInternalInfo( RxContext, &AllInfo->InternalInformation );
                   if (Status!=STATUS_SUCCESS) break;

           RxContext->Info.LengthRemaining = (LONG)capPARAMS->Parameters.QueryFile.Length
                                             - FIELD_OFFSET(FILE_ALL_INFORMATION, EaInformation);

                   Status = RxQueryEaInfo( RxContext, &AllInfo->EaInformation );
                   if (Status!=STATUS_SUCCESS) break;

           RxContext->Info.LengthRemaining = (LONG)capPARAMS->Parameters.QueryFile.Length
                                             - FIELD_OFFSET(FILE_ALL_INFORMATION, PositionInformation);

                   Status = RxQueryPositionInfo( RxContext, &AllInfo->PositionInformation );
                   if (Status!=STATUS_SUCCESS) break;

           RxContext->Info.LengthRemaining = (LONG)capPARAMS->Parameters.QueryFile.Length
                                             - FIELD_OFFSET(FILE_ALL_INFORMATION, NameInformation);

                   //QueryNameInfo could return buffer-overflow!!!
                   Status = RxQueryNameInfo( RxContext, &AllInfo->NameInformation );
                   break;

               case FileBasicInformation:

                   Status = RxQueryBasicInfo( RxContext, Buffer );
                   break;

               case FileStandardInformation:

                   Status = RxQueryStandardInfo( RxContext, Buffer );
                   break;

               case FileInternalInformation:

                   Status = RxQueryInternalInfo( RxContext, Buffer );
                   break;

               case FileEaInformation:

                   Status = RxQueryEaInfo( RxContext, Buffer );
                   break;

               case FilePositionInformation:

                   Status = RxQueryPositionInfo( RxContext, Buffer );
                   break;

               case FileNameInformation:

                   Status = RxQueryNameInfo( RxContext, Buffer );
                   break;

               case FileAlternateNameInformation:

                   Status = RxQueryAlternateNameInfo( RxContext, Buffer );
                   break;

               case FileCompressionInformation:

                   Status = RxQueryCompressedInfo( RxContext, Buffer );
                   break;

               case FilePipeInformation:
               case FilePipeLocalInformation:
               case FilePipeRemoteInformation:

                   Status = RxQueryPipeInfo( RxContext, Buffer);
                   break;

               default:
                   //anything that we don't understand, we just remote
                   RxContext->StoredStatus = RxpQueryInfoMiniRdr(
                                                 RxContext,
                                                 FileInformationClass,
                                                 Buffer);

                   Status = RxContext->StoredStatus;
                   break;
               }

               //  If we overflowed the buffer, set the length to 0 and change the
               //  status to RxStatus(BUFFER_OVERFLOW).
               if ( RxContext->Info.LengthRemaining < 0 ) {
                   Status = STATUS_BUFFER_OVERFLOW;
                   RxContext->Info.LengthRemaining = capPARAMS->Parameters.QueryFile.Length;
               }

               //  Set the information field to the number of bytes actually filled in
               //  and then complete the request  LARRY DOES THIS UNDER "!NT_ERROR"
               capReqPacket->IoStatus.Information = capPARAMS->Parameters.QueryFile.Length
                                                            - RxContext->Info.LengthRemaining;
            }
            break;
        case RDBSS_NTC_MAILSLOT:
           Status = STATUS_NOT_IMPLEMENTED;
           break;
        default:
            RxDbgTrace(0,Dbg,("RxCommonQueryInformation: Illegal Type of Open = %08lx\n", TypeOfOpen));
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
    try_exit:

        if ((Status == STATUS_SUCCESS) &&
            (PostIrp || RxContext->PostRequest)) {
            Status = RxFsdPostRequest( RxContext );
        }

    } finally {

        DebugUnwind( RxCommonQueryInformation );

        if (FcbAcquired)
        {
           RxReleaseFcb( RxContext, capFcb );
        }

        RxDbgTrace(-1, Dbg, ("RxCommonQueryInformation -> %08lx\n", Status));
    }

    return Status;
}

NTSTATUS
RxCommonSetInformation ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This is the common routine for setting file information called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The return status for the operation
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;

    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);
    PNET_ROOT      NetRoot = (PNET_ROOT)capFcb->pNetRoot;
    FILE_INFORMATION_CLASS FileInformationClass = capPARAMS->Parameters.SetFile.FileInformationClass;
    BOOLEAN Wait = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN FcbAcquired = FALSE;
    BOOLEAN NetRootTableLockAcquired = FALSE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonSetInformation...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, capFobx, capFcb));
    RxDbgTrace( 0, Dbg, ("               Buffer     %08lx Length  %08lx FileInfoClass %08lx Replace %08lx\n",
                             capReqPacket->AssociatedIrp.SystemBuffer,
                             capPARAMS->Parameters.QueryFile.Length,
                             capPARAMS->Parameters.QueryFile.FileInformationClass,
                             capPARAMS->Parameters.SetFile.ReplaceIfExists
                             ));

    RxLog(("SetFileInfo %lx %lx %lx\n",RxContext,capFcb,capFobx));
    RxWmiLog(LOG,
             RxCommonSetInformation_1,
             LOGPTR(RxContext)
             LOGPTR(capFcb)
             LOGPTR(capFobx));
    RxLog(("  alsosfi %lx %lx %ld %lx\n",
                 capReqPacket->AssociatedIrp.SystemBuffer,
                 capPARAMS->Parameters.QueryFile.Length,
                 capPARAMS->Parameters.QueryFile.FileInformationClass,
                 capPARAMS->Parameters.SetFile.ReplaceIfExists
                 ));
    RxWmiLog(LOG,
             RxCommonSetInformation_2,
             LOGPTR(capReqPacket->AssociatedIrp.SystemBuffer)
             LOGULONG(capPARAMS->Parameters.QueryFile.Length)
             LOGULONG(capPARAMS->Parameters.QueryFile.FileInformationClass)
             LOGUCHAR(capPARAMS->Parameters.SetFile.ReplaceIfExists));

    FcbAcquired = FALSE;
    Status = STATUS_SUCCESS;

    try {
        //  Case on the type of open we're dealing with
        switch (TypeOfOpen) {
        case RDBSS_NTC_STORAGE_TYPE_FILE:

            if (!FlagOn( capFcb->FcbState, FCB_STATE_PAGING_FILE )) {

                //
                //  We check whether we can proceed
                //  based on the state of the file oplocks.
                //

                Status = FsRtlCheckOplock( &capFcb->Specific.Fcb.Oplock,
                                           capReqPacket,
                                           RxContext,
                                           NULL,
                                           NULL );

                if (Status != STATUS_SUCCESS) {

                    try_return( Status );
                }

                //
                //  Set the flag indicating if Fast I/O is possible  this for LOCAL filesystems
                //

                //capFcb->Header.IsFastIoPossible = RxIsFastIoPossible( capFcb );
            }
            break;

        case RDBSS_NTC_STORAGE_TYPE_DIRECTORY:
        case RDBSS_NTC_STORAGE_TYPE_UNKNOWN:
        case RDBSS_NTC_SPOOLFILE:
            break;

        case RDBSS_NTC_MAILSLOT:
            try_return((Status = STATUS_NOT_IMPLEMENTED));
            break;

        default:
            DbgPrint ("SetFile, Illegal TypeOfOpen = %08lx\n", TypeOfOpen);
            try_return((Status = STATUS_INVALID_PARAMETER));
            //RxBugCheck( TypeOfOpen, 0, 0 );
        }

        //
        // If the FileInformationClass is FileEndOfFileInformation and the 
        // AdvanceOnly field in IrpSp->Parameters is TRUE then we don't need
        // to proceed any further. Only local file systems care about this
        // call. This is the AdvanceOnly callback  all FAT does with this is
        // use it as a hint of a good time to punch out the directory entry.
        // NTFS is much the same way. This is pure PagingIo (dovetailing with
        // lazy writer sync) to metadata streams and cant block behind other
        // user file cached IO.
        //
        if (FileInformationClass == FileEndOfFileInformation) {
            if (capPARAMS->Parameters.SetFile.AdvanceOnly) {
                RxDbgTrace(-1, Dbg, ("RxCommonSetInfo (no advance) -> %08lx\n", RxContext));
                RxLog(("RxCommonSetInfo SetEofAdvance-NOT! %lx\n", RxContext));
                RxWmiLog(LOG,
                         RxSetEndOfFileInfo_2,
                         LOGPTR(RxContext));
                try_return(Status = STATUS_SUCCESS);
            }
        }

        //
        //  In the following two cases, we cannot have creates occuring
        //  while we are here, so acquire the exclusive lock on netroot prefix table.
        //

        if ((FileInformationClass == FileDispositionInformation) ||
            (FileInformationClass == FileRenameInformation)) {
            RxPurgeRelatedFobxs(
                (PNET_ROOT)capFcb->pNetRoot,
                RxContext,
                ATTEMPT_FINALIZE_ON_PURGE,
                capFcb);

            RxScavengeFobxsForNetRoot(
                (PNET_ROOT)capFcb->pNetRoot,
                capFcb);

            if (!RxAcquireFcbTableLockExclusive(&NetRoot->FcbTable, Wait)) {

                RxDbgTrace(0, Dbg, ("Cannot acquire NetRootTableLock\n", 0));

                Status = STATUS_PENDING;
                RxContext->PostRequest = TRUE;

                try_return( Status );
            }

            NetRootTableLockAcquired = TRUE;
        }

        //
        //  Acquire exclusive access to the Fcb,  We use exclusive
        //  because it is probable that the subroutines
        //  that we call will need to monkey with file allocation,
        //  create/delete extra fcbs.  So we're willing to pay the
        //  cost of exclusive Fcb access.
        //
        //  Note that we do not acquire the resource for paging file
        //  operations in order to avoid deadlock with Mm.
        //

        if (!FlagOn( capFcb->FcbState, FCB_STATE_PAGING_FILE )) {

            Status = RxAcquireExclusiveFcb( RxContext, capFcb );
            if (Status == STATUS_LOCK_NOT_GRANTED) {

                RxDbgTrace(0, Dbg, ("Cannot acquire Fcb\n", 0));

                Status = STATUS_SUCCESS;

                RxContext->PostRequest = TRUE;

                try_return( Status );
            } else  if (Status != STATUS_SUCCESS) {
                try_return( Status );
            }

            FcbAcquired = TRUE;
        }

        Status = STATUS_SUCCESS;

        //
        //  Based on the information class we'll do different
        //  actions.  Each of the procedures that we're calling will either
        //  complete the request of send the request off to the fsp
        //  to do the work.
        //

        switch (FileInformationClass) {

        case FileBasicInformation:

            Status = RxSetBasicInfo( RxContext );
            break;

        case FileDispositionInformation:
            {
                PFILE_DISPOSITION_INFORMATION Buffer;

                Buffer = capReqPacket->AssociatedIrp.SystemBuffer;

                //  Check if the user wants to delete the file; if so,
                // check for situations where we cannot delete.

                if (Buffer->DeleteFile) {
                    //  Make sure there is no process mapping this file as an image.

                    if (!MmFlushImageSection(
                            &capFcb->NonPaged->SectionObjectPointers,
                            MmFlushForDelete)) {

                        RxDbgTrace(-1, Dbg, ("Cannot delete user mapped image\n", 0));

                        Status = STATUS_CANNOT_DELETE;
                    }

                    if (Status == STATUS_SUCCESS) {
                        // In the case of disposition information this name is being
                        // deleted. In such cases the collapsing of new create requests
                        // onto this FCB should be prohibited. This can be accomplished
                        // by removing the FCB name from the FCB table. Subsequently the
                        // FCB table lock can be dropped.

                        ASSERT(FcbAcquired && NetRootTableLockAcquired);

                        RxRemoveNameNetFcb(capFcb);

                        RxReleaseFcbTableLock(&NetRoot->FcbTable);
                        NetRootTableLockAcquired = FALSE;
                     }
                }

                if (Status == STATUS_SUCCESS) {
                    Status = RxSetDispositionInfo( RxContext );
                }
            }
            break;

        case FileMoveClusterInformation:
        case FileLinkInformation:
        case FileRenameInformation:

            //
            //  We proceed with this operation only if we can wait
            //

            if (!FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT)) {

                Status = RxFsdPostRequest( RxContext );

            } else {
                ClearFlag(capFcb->FcbState,FCB_STATE_COLLAPSING_ENABLED);

                Status = RxSetRenameInfo( RxContext );

                if ((Status == STATUS_SUCCESS) &&
                    (FileInformationClass == FileRenameInformation)) {
                    ASSERT(FcbAcquired && NetRootTableLockAcquired);

                    RxRemoveNameNetFcb(capFcb);
                }
            }

            break;

        case FilePositionInformation:

            Status = RxSetPositionInfo( RxContext );
            break;


        case FileAllocationInformation:

            Status = RxSetAllocationInfo( RxContext );
            break;

        case FileEndOfFileInformation:

            Status = RxSetEndOfFileInfo( RxContext );
            break;

        case FilePipeInformation:
        case FilePipeLocalInformation:
        case FilePipeRemoteInformation:

            Status = RxSetPipeInfo(RxContext);
            break;

    case FileValidDataLengthInformation:

            if(!MmCanFileBeTruncated(&capFcb->NonPaged->SectionObjectPointers, NULL)) {
            Status = STATUS_USER_MAPPED_FILE;
            break;
            }
            Status = RxSetSimpleInfo(RxContext);
            break;

        case FileShortNameInformation:

            Status = RxSetSimpleInfo(RxContext);
            break;


        default:

            Status = STATUS_INVALID_PARAMETER;
            break;
        }

    try_exit:

        if ((Status == STATUS_SUCCESS) &&
             RxContext->PostRequest) {
            Status = RxFsdPostRequest( RxContext );
        }

    } finally {

        DebugUnwind( RxCommonSetInformation );

        if (FcbAcquired)
        {
           RxReleaseFcb( RxContext, capFcb );
        }

        if (NetRootTableLockAcquired)
        {
           RxReleaseFcbTableLock(&NetRoot->FcbTable);
        }

        RxDbgTrace(-1, Dbg, ("RxCommonSetInformation -> %08lx\n", Status));
    }

    return Status;
}

NTSTATUS
RxSetBasicInfo (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    (Interal Support Routine)
    This routine performs the set basic information for rx.  It either
    completes the request or enqueues it off to the fsp.

Arguments:

    RxContext - Supplies the irp being processed

Return Value:

    RXSTATUS - The result of this operation if it completes without
               an exception.

--*/
{
    NTSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock; RxCaptureFileObject;


    PFILE_BASIC_INFORMATION Buffer;

    BOOLEAN ModifyCreation = FALSE;
    BOOLEAN ModifyLastAccess = FALSE;
    BOOLEAN ModifyLastWrite = FALSE;
    BOOLEAN ModifyLastChange = FALSE;
    ULONG NotifyFilter = 0;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxSetBasicInfo...\n", 0));
    RxLog(("RxSetBasicInfo\n"));
    RxWmiLog(LOG,
             RxSetBasicInfo,
             LOGPTR(RxContext));
    //
    // call down. if we're successful, then fixup all the fcb data.

    Status = RxpSetInfoMiniRdr(RxContext,FileBasicInformation);

    if (!NT_SUCCESS(Status)) {
        RxDbgTrace(-1, Dbg, ("RxSetBasicInfo -> %08lx\n", Status));
        return Status;
    }

    //
    // now we have to update the info in the fcb, both the absolute info AND whether changes were made

    Buffer = capReqPacket->AssociatedIrp.SystemBuffer;

    try {

        //
        //  Check if the user specified a non-zero creation time
        //

        if (Buffer->CreationTime.QuadPart != 0 ) {

            ModifyCreation = TRUE;

            NotifyFilter = FILE_NOTIFY_CHANGE_CREATION;
        }

        //
        //  Check if the user specified a non-zero last access time
        //

        if (Buffer->LastAccessTime.QuadPart != 0 ) {

            ModifyLastAccess = TRUE;

            NotifyFilter |= FILE_NOTIFY_CHANGE_LAST_ACCESS;
        }

        //
        //  Check if the user specified a non-zero last write time
        //

        if (Buffer->LastWriteTime.QuadPart != 0 ) {


            ModifyLastWrite = TRUE;

            NotifyFilter |= FILE_NOTIFY_CHANGE_LAST_WRITE;
        }


        if (Buffer->ChangeTime.QuadPart != 0 ) {


            ModifyLastChange = TRUE;

            //NotifyFilter |= FILE_NOTIFY_CHANGE_LAST_CHANGE;
        }


        //
        //  Check if the user specified a non zero file attributes byte
        //

        if (Buffer->FileAttributes != 0) {

            USHORT Attributes;

            //
            //  Remove the normal attribute flag
            //

            Attributes = (USHORT)(Buffer->FileAttributes & ~FILE_ATTRIBUTE_NORMAL);

            //
            //  Make sure that for a file the directory bit is not set
            //  and for a directory that the bit is set
            //

            if (NodeType(capFcb) != RDBSS_NTC_STORAGE_TYPE_DIRECTORY) {

                Attributes &= ~FILE_ATTRIBUTE_DIRECTORY;

            } else {

                Attributes |= FILE_ATTRIBUTE_DIRECTORY;
            }

            //
            //  Mark the FcbState temporary flag correctly.
            //

            if (FlagOn(Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY)) {

                SetFlag( capFcb->FcbState, FCB_STATE_TEMPORARY );

                SetFlag( capFileObject->Flags, FO_TEMPORARY_FILE );

            } else {

                ClearFlag( capFcb->FcbState, FCB_STATE_TEMPORARY );

                ClearFlag( capFileObject->Flags, FO_TEMPORARY_FILE );
            }

            //
            //  Set the new attributes byte, and mark the bcb dirty
            //

            capFcb->Attributes = Attributes;

            NotifyFilter |= FILE_NOTIFY_CHANGE_ATTRIBUTES;
        }

        if ( ModifyCreation ) {

            //
            //  Set the new last write time in the dirent, and mark
            //  the bcb dirty
            //

            capFcb->CreationTime = Buffer->CreationTime;
            //
            //  Now because the user just set the creation time we
            //  better not set the creation time on close
            //

            SetFlag( capFobx->Flags, FOBX_FLAG_USER_SET_CREATION );
        }

        if ( ModifyLastAccess ) {

            //
            //  Set the new last write time in the dirent, and mark
            //  the bcb dirty
            //

            capFcb->LastAccessTime = Buffer->LastAccessTime;
            //
            //  Now because the user just set the last access time we
            //  better not set the last access time on close
            //

            SetFlag( capFobx->Flags, FOBX_FLAG_USER_SET_LAST_ACCESS );
        }

        if ( ModifyLastWrite ) {

            //
            //  Set the new last write time in the dirent, and mark
            //  the bcb dirty
            //

            capFcb->LastWriteTime = Buffer->LastWriteTime;
            //
            //  Now because the user just set the last write time we
            //  better not set the last write time on close
            //

            SetFlag( capFobx->Flags, FOBX_FLAG_USER_SET_LAST_WRITE );
        }

        if ( ModifyLastChange ) {

            //
            //  Set the new last write time in the dirent, and mark
            //  the bcb dirty
            //

            capFcb->LastChangeTime = Buffer->ChangeTime;
            //
            //  Now because the user just set the last write time we
            //  better not set the last write time on close
            //

            SetFlag( capFobx->Flags, FOBX_FLAG_USER_SET_LAST_CHANGE );
        }

        //
        //  If we modified any of the values, we report this to the notify
        //  package.
        //

        if (NotifyFilter != 0) {

            RxNotifyReportChange( RxContext,
                                   capFcb->Vcb,
                                   capFcb,
                                   NotifyFilter,
                                   FILE_ACTION_MODIFIED );
        }

    //try_exit: NOTHING;
    } finally {

        DebugUnwind( RxSetBasicInfo );

        //RxUnpinBcb( RxContext, DirentBcb );

        RxDbgTrace(-1, Dbg, ("RxSetBasicInfo -> %08lx\n", Status));
    }

    return Status;
}

NTSTATUS
RxSetDispositionInfo (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    (Internal Support Routine)
    This routine performs the set disposition information for rx.  It either
    completes the request or enqueues it off to the fsp.

Arguments:

    RxContext - Supplies the irp being processed

Return Value:

    RXSTATUS - The result of this operation if it completes without
               an exception.

--*/
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    PFILE_DISPOSITION_INFORMATION Buffer;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxSetDispositionInfo...\n", 0));
    RxLog(("RxSetDispositionInfo\n"));
    RxWmiLog(LOG,
             RxSetDispositionInfo,
             LOGPTR(RxContext));

    Buffer = capReqPacket->AssociatedIrp.SystemBuffer;

    //
    //call down and check for success

    Status = RxpSetInfoMiniRdr(RxContext,FileDispositionInformation);;

    if (!NT_SUCCESS(Status)) {
        RxDbgTrace(-1, Dbg, ("RxSetDispositionInfo -> %08lx\n", Status));
        return Status;
    }

    //
    //  if successful, record the correct state in the fcb

    if (Buffer->DeleteFile) {

        capFcb->FcbState |= FCB_STATE_DELETE_ON_CLOSE;
        capFileObject->DeletePending = TRUE;

    } else {

        //
        //  The user doesn't want to delete the file so clear
        //  the delete on close bit
        //

        RxDbgTrace(0, Dbg, ("User want to not delete file\n", 0));

        capFcb->FcbState &= ~FCB_STATE_DELETE_ON_CLOSE;
        capFileObject->DeletePending = FALSE;
    }

    RxDbgTrace(-1, Dbg, ("RxSetDispositionInfo -> RxStatus(SUCCESS)\n", 0));

    return STATUS_SUCCESS;
}

NTSTATUS
RxSetRenameInfo (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    (Internal Support Routine)
    This routine performs the set name information for rx.  It either
    completes the request or enqueues it off to the fsp.

Arguments:

    Irp - Supplies the irp being processed

Return Value:

    RXSTATUS - The result of this operation if it completes without
               an exception.

--*/
{
    NTSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxSetRenameInfo ......FileObj = %08lx\n",
                    capPARAMS->Parameters.SetFile.FileObject));
    RxLog(("RxSetRenameInfo %lx %lx\n",
                   capPARAMS->Parameters.SetFile.FileObject,
                   capPARAMS->Parameters.SetFile.ReplaceIfExists ));
    RxWmiLog(LOG,
             RxSetRenameInfo,
             LOGPTR(capPARAMS->Parameters.SetFile.FileObject)
             LOGUCHAR(capPARAMS->Parameters.SetFile.ReplaceIfExists));

    RxContext->Info.ReplaceIfExists = capPARAMS->Parameters.SetFile.ReplaceIfExists;
    if (capPARAMS->Parameters.SetFile.FileObject){
        // here we have to translate the name. the fcb of the fileobject has the
        // translation already....all we have to do is to allocate a buffer, copy
        // and calldown
        PFILE_OBJECT RenameFileObject = capPARAMS->Parameters.SetFile.FileObject;
        PFCB RenameFcb = (PFCB)(RenameFileObject->FsContext);
        PFILE_RENAME_INFORMATION RenameInformation;
        ULONG allocate_size;

        ASSERT (NodeType(RenameFcb)==RDBSS_NTC_OPENTARGETDIR_FCB);

        RxDbgTrace(0, Dbg, ("-->RenameTarget is %wZ,over=%08lx\n",
                                &(RenameFcb->FcbTableEntry.Path),
                                capFcb->pNetRoot->DiskParameters.RenameInfoOverallocationSize));
        if (RenameFcb->pNetRoot != capFcb->pNetRoot) {
            RxDbgTrace(-1, Dbg, ("RxSetRenameInfo -> %s\n", "NOT SAME DEVICE!!!!!!"));
            return(STATUS_NOT_SAME_DEVICE);
        }

        allocate_size = FIELD_OFFSET(FILE_RENAME_INFORMATION, FileName[0])
                             + RenameFcb->FcbTableEntry.Path.Length
                             + capFcb->pNetRoot->DiskParameters.RenameInfoOverallocationSize;
        RxDbgTrace(0, Dbg, ("-->AllocSize is %08lx\n", allocate_size));
        RenameInformation = RxAllocatePool( PagedPool, allocate_size );
        if (RenameInformation != NULL) {
            try {
                *RenameInformation = *((PFILE_RENAME_INFORMATION)(capReqPacket->AssociatedIrp.SystemBuffer));
                RenameInformation->FileNameLength = RenameFcb->FcbTableEntry.Path.Length;

                RtlMoveMemory(
                    &RenameInformation->FileName[0],
                    RenameFcb->FcbTableEntry.Path.Buffer,
                    RenameFcb->FcbTableEntry.Path.Length);

                RxContext->Info.FileInformationClass = (capPARAMS->Parameters.SetFile.FileInformationClass);
                RxContext->Info.Buffer = RenameInformation;
                RxContext->Info.Length = allocate_size;
                MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxSetFileInfo,(RxContext));

               //we don't change the name in the fcb? a la rdr1
            } finally {
                RxFreePool(RenameInformation);
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        Status = RxpSetInfoMiniRdr(
                     RxContext,
                     capPARAMS->Parameters.SetFile.FileInformationClass);
    }

    RxDbgTrace(-1, Dbg, ("RxSetRenameInfo -> %08lx\n", Status));

    return Status;
}

NTSTATUS
RxSetPositionInfo (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    (Internal Support Routine)
    This routine performs the set position information for rx.  It either
    completes the request or enqueues it off to the fsp.

Arguments:

    RxContext - Supplies the irp being processed

Return Value:

    RXSTATUS - The result of this operation if it completes without
               an exception.

--*/
{
    //RXSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock; RxCaptureFileObject;

    PFILE_POSITION_INFORMATION Buffer;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxSetPositionInfo...\n", 0));
    RxLog(("RxSetPositionInfo\n"));
    RxWmiLog(LOG,
             RxSetPositionInfo,
             LOGPTR(RxContext));

    //this does not call down.........
    ////MINIRDR_CALL(Status,Fcb->NetRoot,MRxSetPositionInfo,(RxContext));
    //SETINFO_MINIRDR_CALL(FilePositionInformation);;
    //
    //if (!NT_SUCCESS(Status)) {
    //    RxDbgTrace(-1, Dbg, ("RxSetBasicInfo -> %08lx\n", Status));
    //    return Status;
    //}

    Buffer = capReqPacket->AssociatedIrp.SystemBuffer;

    //
    //  Check if the file does not use intermediate buffering.  If it
    //  does not use intermediate buffering then the new position we're
    //  supplied must be aligned properly for the device
    //

    if (FlagOn( capFileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING )) {

        PDEVICE_OBJECT DeviceObject;

        DeviceObject = capPARAMS->DeviceObject;

        if ((Buffer->CurrentByteOffset.LowPart & DeviceObject->AlignmentRequirement) != 0) {

            RxDbgTrace(0, Dbg, ("Cannot set position due to aligment conflict\n", 0));
            RxDbgTrace(-1, Dbg, ("RxSetPositionInfo -> %08lx\n", STATUS_INVALID_PARAMETER));

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  The input parameter is fine so set the current byte offset and
    //  complete the request
    //

    RxDbgTrace(0, Dbg, ("Set the new position to %08lx\n", Buffer->CurrentByteOffset));

    capFileObject->CurrentByteOffset = Buffer->CurrentByteOffset;

    RxDbgTrace(-1, Dbg, ("RxSetPositionInfo -> %08lx\n", STATUS_SUCCESS));

    return STATUS_SUCCESS;
}

NTSTATUS
RxSetAllocationInfo (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    (Internal Support Routine)
    This routine performs the set Allocation information for rx.  It either
    completes the request or enqueues it off to the fsp.

Arguments:

    RxContext - Supplies the irp being processed

Return Value:

    RXSTATUS - The result of this operation if it completes without
               an exception.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    PFILE_ALLOCATION_INFORMATION Buffer;

    LONGLONG NewAllocationSize;

    BOOLEAN CacheMapInitialized = FALSE;
    LARGE_INTEGER OriginalFileSize;
    LARGE_INTEGER OriginalAllocationSize;

    PAGED_CODE();

    Buffer = capReqPacket->AssociatedIrp.SystemBuffer;

    NewAllocationSize = Buffer->AllocationSize.QuadPart;

    RxDbgTrace(+1, Dbg, ("RxSetAllocationInfo.. to %08lx\n", NewAllocationSize));
    RxLog(("SetAlloc %lx %lx %lx\n", capFcb->Header.FileSize.LowPart,
                   (ULONG)NewAllocationSize, capFcb->Header.AllocationSize.LowPart
          ));
    RxWmiLog(LOG,
             RxSetAllocationInfo_1,
             LOGULONG(capFcb->Header.FileSize.LowPart)
             LOGULONG((ULONG)NewAllocationSize)
             LOGULONG(capFcb->Header.AllocationSize.LowPart));

    //  This is kinda gross, but if the file is not cached, but there is
    //  a data section, we have to cache the file to avoid a bunch of
    //  extra work.

    if ((capFileObject->SectionObjectPointer->DataSectionObject != NULL) &&
        (capFileObject->SectionObjectPointer->SharedCacheMap == NULL) &&
        (capReqPacket->RequestorMode != KernelMode)) {

        if ( FlagOn( capFileObject->Flags, FO_CLEANUP_COMPLETE ) ) {
            return STATUS_FILE_CLOSED;
        }

        RxAdjustAllocationSizeforCC(capFcb);

        //
        //  Now initialize the cache map.
        //

        CcInitializeCacheMap( capFileObject,
                              (PCC_FILE_SIZES)&capFcb->Header.AllocationSize,
                              FALSE,
                              &RxData.CacheManagerCallbacks,
                              capFcb );

        CacheMapInitialized = TRUE;
    }

    //LOCAL.FSD this is a local fsd thing
    ////
    ////  Now mark the fact that the file needs to be truncated on close
    ////
    //
    //capFcb->FcbState |= FCB_STATE_TRUNCATE_ON_CLOSE;

    //
    //  Now mark that the time on the dirent needs to be updated on close.
    //

    SetFlag( capFileObject->Flags, FO_FILE_MODIFIED );

    try {
        //  Check here if we will be decreasing file size and synchonize with
        //  paging IO.

        RxGetFileSizeWithLock(capFcb,&OriginalFileSize.QuadPart);

        if ( OriginalFileSize.QuadPart > Buffer->AllocationSize.QuadPart ) {

            //
            //  Before we actually truncate, check to see if the purge
            //  is going to fail.
            //

            if (!MmCanFileBeTruncated( capFileObject->SectionObjectPointer,
                                       &Buffer->AllocationSize )) {

                try_return( Status = STATUS_USER_MAPPED_FILE );
            }


            (VOID)RxAcquirePagingIoResource(capFcb,RxContext);

            RxSetFileSizeWithLock(capFcb,&NewAllocationSize);

            //
            //  If we reduced the file size to less than the ValidDataLength,
            //  adjust the VDL.
            //

            if (capFcb->Header.ValidDataLength.QuadPart > NewAllocationSize) {

                capFcb->Header.ValidDataLength.QuadPart = NewAllocationSize;
            }

            RxReleasePagingIoResource(capFcb,RxContext);
        }

        OriginalAllocationSize.QuadPart = capFcb->Header.AllocationSize.QuadPart;
        capFcb->Header.AllocationSize.QuadPart = NewAllocationSize;

        Status = RxpSetInfoMiniRdr(
                     RxContext,
                     FileAllocationInformation);

        if (!NT_SUCCESS(Status)) {
            capFcb->Header.AllocationSize.QuadPart =  OriginalAllocationSize.QuadPart;
            RxDbgTrace(-1, Dbg, ("RxSetAllocationInfo -> %08lx\n", Status));
            try_return (Status);
        }

        //
        //  Now check if we needed to change the file size accordingly.
        //

        if( OriginalAllocationSize.QuadPart != NewAllocationSize ) {

            //
            //  Tell the cache manager we reduced the file size or increased the allocationsize
            //  The call is unconditional, because MM always wants to know.
            //

            try {

                CcSetFileSizes( capFileObject, (PCC_FILE_SIZES)&capFcb->Header.AllocationSize );

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                Status = GetExceptionCode();

                //
                //  Cache manager was not able to extend the file.  Restore the file to
                //  its previous state.
                //
                //  NOTE:  If this call to the mini-RDR fails, there is nothing we can do.
                //

                capFcb->Header.AllocationSize.QuadPart =  OriginalAllocationSize.QuadPart;

                RxpSetInfoMiniRdr( RxContext,
                                   FileAllocationInformation );

                try_return( Status );
            }

            //ASSERT( capFileObject->DeleteAccess || capFileObject->WriteAccess );

            //
            //  Report that we just reduced the file size.
            //

            RxNotifyReportChange(
                RxContext,
                capFcb->Vcb,
                capFcb,
                FILE_NOTIFY_CHANGE_SIZE,
                FILE_ACTION_MODIFIED );
        }

    try_exit: NOTHING;
    } finally {
        if (CacheMapInitialized) {

            CcUninitializeCacheMap( capFileObject, NULL, NULL );
        }
    }

    RxLog(("SetAllocExit %lx %lx\n",
            capFcb->Header.FileSize.LowPart,
            capFcb->Header.AllocationSize.LowPart
          ));
    RxWmiLog(LOG,
             RxSetAllocationInfo_2,
             LOGULONG(capFcb->Header.FileSize.LowPart)
             LOGULONG(capFcb->Header.AllocationSize.LowPart));

    RxDbgTrace(-1, Dbg, ("RxSetAllocationInfo -> %08lx\n", STATUS_SUCCESS));

    return Status;
}

NTSTATUS
RxSetEndOfFileInfo (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    (Internal Support Routine)
    This routine performs the set End of File information for rx.  It either
    completes the request or enqueues it off to the fsp.

Arguments:

    RxContext - Supplies the irp being processed

Return Value:

    RXSTATUS - The result of this operation if it completes without
               an exception.

--*/
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    NTSTATUS SetFileSizeStatus;

    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock; RxCaptureFileObject;

    PFILE_END_OF_FILE_INFORMATION Buffer;

    LONGLONG NewFileSize;
    LONGLONG OriginalFileSize;
    LONGLONG OriginalAllocationSize;
    LONGLONG OriginalValidDataLength;

    BOOLEAN CacheMapInitialized = FALSE;
    BOOLEAN PagingIoResourceAcquired = FALSE;

    PAGED_CODE();

    Buffer = capReqPacket->AssociatedIrp.SystemBuffer;
    NewFileSize = Buffer->EndOfFile.QuadPart;

    RxDbgTrace(+1, Dbg, ("RxSetEndOfFileInfo...Old,New,Alloc %08lx,%08lx,%08lx\n",
                       capFcb->Header.FileSize.LowPart,
                       (ULONG)NewFileSize,
                       capFcb->Header.AllocationSize.LowPart));
    RxLog(("SetEof %lx %lx %lx %lx\n", RxContext, capFcb->Header.FileSize.LowPart,
                   (ULONG)NewFileSize, capFcb->Header.AllocationSize.LowPart
          ));
    RxWmiLog(LOG,
             RxSetEndOfFileInfo_1,
             LOGPTR(RxContext)
             LOGULONG(capFcb->Header.FileSize.LowPart)
             LOGULONG((ULONG)NewFileSize)
             LOGULONG(capFcb->Header.AllocationSize.LowPart));

    //
    //  File Size changes are only allowed on a file and not a directory
    //

    if (NodeType(capFcb) != RDBSS_NTC_STORAGE_TYPE_FILE) {

        RxDbgTrace(0, Dbg, ("Cannot change size of a directory\n", 0));

        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    try {
        // remember everything
        OriginalFileSize = capFcb->Header.FileSize.QuadPart;
        OriginalAllocationSize = capFcb->Header.AllocationSize.QuadPart;
        OriginalValidDataLength = capFcb->Header.ValidDataLength.QuadPart;

        //
        //  This is kinda gross, but if the file is not cached, but there is
        //  a data section, we have to cache the file to avoid a bunch of
        //  extra work.
        //

        if ((capFileObject->SectionObjectPointer->DataSectionObject != NULL) &&
            (capFileObject->SectionObjectPointer->SharedCacheMap == NULL) &&
            (capReqPacket->RequestorMode != KernelMode)) {

            if ( FlagOn( capFileObject->Flags, FO_CLEANUP_COMPLETE ) ) {
                try_return( STATUS_FILE_CLOSED );
            }

            RxAdjustAllocationSizeforCC(capFcb);

            //
            //  Now initialize the cache map.
            //

            CcInitializeCacheMap( capFileObject,
                                  (PCC_FILE_SIZES)&capFcb->Header.AllocationSize,
                                  FALSE,
                                  &RxData.CacheManagerCallbacks,
                                  capFcb );

            CacheMapInitialized = TRUE;
        }

        //
        //  Do a special case here for the lazy write of file sizes.
        //

        // only a localFSD does this....not a rdr. this is consistent with the rdr1 imnplementaion
        if (FALSE &&capPARAMS->Parameters.SetFile.AdvanceOnly) {

            ASSERT(!"you shouldn't be trying a advance only.....");
            //
            //  Only attempt this if the file hasn't been "deleted on close"
            //

            if (FALSE && !capFileObject->DeletePending) {

                //
                //  Make sure we don't set anything higher than the alloc size. current
                //  filesize is the best. the cachemanager will try to extend to a page
                //  boundary if you're not careful!!!
                //

                if ( NewFileSize > capFcb->Header.FileSize.QuadPart ){  //capture the header ptr

                    NewFileSize = capFcb->Header.FileSize.QuadPart;
                    //try_return (Status = RxStatus(SUCCESS));

                }

                ASSERT( NewFileSize <= capFcb->Header.AllocationSize.QuadPart );

                Status = RxpSetInfoMiniRdr(
                             RxContext,
                             FileEndOfFileInformation);

                if (!NT_SUCCESS(Status)) {
                    RxDbgTrace(-1, Dbg, ("RxSetEndOfFileInfo1 status -> %08lx\n", Status));
                    try_return (Status);
                }

                RxNotifyReportChange(
                    RxContext,
                    Vcb,
                    capFcb,
                    FILE_NOTIFY_CHANGE_SIZE,
                    FILE_ACTION_MODIFIED );
            } else {

                RxDbgTrace(0, Dbg, ("Cannot set size on deleted file.\n", 0));
            }

            try_return( Status = STATUS_SUCCESS );
        }

        //
        //  At this point we have enough allocation for the file.
        //  So check if we are really changing the file size
        //

        if (capFcb->Header.FileSize.QuadPart != NewFileSize) {

            if ( NewFileSize < capFcb->Header.FileSize.QuadPart ) {

                //
                //  Before we actually truncate, check to see if the purge
                //  is going to fail.
                //

                if (!MmCanFileBeTruncated( capFileObject->SectionObjectPointer,
                                           &Buffer->EndOfFile )) {

                    try_return( Status = STATUS_USER_MAPPED_FILE );
                }
            }

            //
            //  MM always wants to know if the filesize is changing;
            //  serialize here with paging io since we are truncating the file size.
            //

            PagingIoResourceAcquired =
                RxAcquirePagingIoResource(capFcb,RxContext);

            //
            //  Set the new file size
            //

            capFcb->Header.FileSize.QuadPart = NewFileSize;

            //
            //  If we reduced the file size to less than the ValidDataLength,
            //  adjust the VDL.
            //

            if (capFcb->Header.ValidDataLength.QuadPart > NewFileSize) {

                capFcb->Header.ValidDataLength.QuadPart = NewFileSize;
            }

            //
            //  Check if the new file size is greater than the current
            //  allocation size.  If it is then we need to increase the
            //  allocation size.  A clever minirdr might override this calculation
            //  with a bigger number.
            //

            //if ( NewFileSize > capFcb->Header.AllocationSize.QuadPart ) {

                //
                //  Change the file allocation
                //

                capFcb->Header.AllocationSize.QuadPart = NewFileSize;
            //}

            Status = RxpSetInfoMiniRdr(
                         RxContext,
                         FileEndOfFileInformation);

            if (Status == STATUS_SUCCESS) {
                if (PagingIoResourceAcquired) {
                    RxReleasePagingIoResource(capFcb,RxContext);
                    PagingIoResourceAcquired = FALSE;
                }

                //
                //  We must now update the cache mapping (benign if not cached).
                //

                SetFileSizeStatus = STATUS_SUCCESS;

                try {
                    CcSetFileSizes(
                        capFileObject,
                        (PCC_FILE_SIZES)&capFcb->Header.AllocationSize );
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    SetFileSizeStatus = GetExceptionCode();
                }

                if (SetFileSizeStatus != STATUS_SUCCESS) {
                    Status = SetFileSizeStatus;
                    try_return(Status);
                }
            }

            if (Status == STATUS_SUCCESS) {
                //
                //  Report that we just changed the file size.
                //

                RxNotifyReportChange(
                    RxContext,
                    Vcb,
                    capFcb,
                    FILE_NOTIFY_CHANGE_SIZE,
                    FILE_ACTION_MODIFIED );
            }

            //LOCAL.FSD this is a local fsd idea
            ////
            ////  Mark the fact that the file will need to checked for
            ////  truncation on cleanup.
            ////
            //
            //SetFlag( capFcb->FcbState, FCB_STATE_TRUNCATE_ON_CLOSE );
        } else {
            //
            //  Set our return status to success
            //

            Status = STATUS_SUCCESS;
        }

        //
        //  Set this handle as having modified the file
        //

        capFileObject->Flags |= FO_FILE_MODIFIED;

    try_exit: NOTHING;

    } finally {

        DebugUnwind( RxSetEndOfFileInfo );

        if (( AbnormalTermination() || !NT_SUCCESS(Status) )) {
            RxDbgTrace(-1, Dbg, ("RxSetEndOfFileInfo2 status -> %08lx\n", Status));

            capFcb->Header.FileSize.QuadPart = OriginalFileSize;
            capFcb->Header.AllocationSize.QuadPart = OriginalAllocationSize;
            capFcb->Header.ValidDataLength.QuadPart = OriginalValidDataLength;

            if (capFileObject->SectionObjectPointer->SharedCacheMap != NULL) {
                *CcGetFileSizePointer(capFileObject) = capFcb->Header.FileSize;
            }

            RxLog(("SetEofabnormalorbadstatus %lx %lx", RxContext,Status));
            RxWmiLog(LOG,
                     RxSetEndOfFileInfo_3,
                     LOGPTR(RxContext)
                     LOGULONG(Status));
        }

        if (PagingIoResourceAcquired) {
            RxReleasePagingIoResource(capFcb,RxContext);
        }

        if (CacheMapInitialized) {
            CcUninitializeCacheMap( capFileObject, NULL, NULL );
        }

        RxDbgTrace(-1, Dbg, ("RxSetEndOfFileInfo -> %08lx\n", Status));
    }

    if (Status == STATUS_SUCCESS) {
        RxLog(
            ("SetEofexit %lx %lx %lx\n",
             capFcb->Header.FileSize.LowPart,
             (ULONG)NewFileSize,
             capFcb->Header.AllocationSize.LowPart
            ));
        RxWmiLog(LOG,
                 RxSetEndOfFileInfo_4,
                 LOGPTR(RxContext)
                 LOGULONG(capFcb->Header.FileSize.LowPart)
                 LOGULONG((ULONG)NewFileSize)
                 LOGULONG(capFcb->Header.AllocationSize.LowPart));
    }
    return Status;
}

#define QUERY_MINIRDR_CALL(FILEINFOCLASS) {\
          MINIRDR_CALL(RxContext->StoredStatus,RxContext,Fcb->MRxDispatch,MRxQueryFileInfo, \
                                      (RxContext,FILEINFOCLASS,Buffer,pLengthRemaining)); \
          RxDbgTraceUnIndent(-1,Dbg); \
          return RxContext->StoredStatus; }

BOOLEAN RxForceQFIPassThrough = FALSE;

NTSTATUS
RxQueryBasicInfo (
    IN PRX_CONTEXT RxContext,
    IN OUT PFILE_BASIC_INFORMATION Buffer
    )
/*++
 Description:

    (Internal Support Routine)
    This routine performs the query basic information function for fat.

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

Return Value:

    STATUS_SUCCESS if the call was successful, otherwise the appropriate error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxQueryBasicInfo...\n", 0));
    RxLog(("RxQueryBasicInfo\n"));
    RxWmiLog(LOG,
             RxQueryBasicInfo,
             LOGPTR(RxContext));

    //  Zero out the output buffer, and set it to indicate that
    //  the query is a normal file.  Later we might overwrite the
    //  attribute.
    RtlZeroMemory( Buffer, sizeof(FILE_BASIC_INFORMATION) );

    Status = RxpQueryInfoMiniRdr(
                 RxContext,
                 FileBasicInformation,
                 Buffer);

    return Status;
}

NTSTATUS
RxQueryStandardInfo (
    IN PRX_CONTEXT RxContext,
    IN OUT PFILE_STANDARD_INFORMATION Buffer
    )
/*++
Routine Description:

    This routine performs the query standard information function for fat.

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

Return Value:

    STATUS_SUCCESS/STATUS_PENDING or an appropriate error code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    PMRX_SRV_OPEN pSrvOpen;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxQueryStandardInfo...\n", 0));
    RxLog(("RxQueryStandardInfo\n"));
    RxWmiLog(LOG,
             RxQueryStandardInfo,
             LOGPTR(RxContext));

    //
    //  Zero out the output buffer, and fill in the number of links
    //  and the delete pending flag.
    //

    RtlZeroMemory( Buffer, sizeof(FILE_STANDARD_INFORMATION) );

    pSrvOpen = capFobx->pSrvOpen;

    switch (NodeType(capFcb)) {
    case RDBSS_NTC_STORAGE_TYPE_DIRECTORY:
    case RDBSS_NTC_STORAGE_TYPE_FILE:

        // If the file was not opened with back up intent then the wrapper has
        // all the information that is required. In the cases that this is
        // specified we fill in the information from the mini redirector. This
        // is because backup pograms rely upon fields that are not available
        // in the wrapper and that which cannot be cached easily.

        if (!FlagOn(pSrvOpen->CreateOptions,FILE_OPEN_FOR_BACKUP_INTENT)) {
            //copy in all the stuff that we know....it may be enough.....
            Buffer->NumberOfLinks = capFcb->NumberOfLinks;
            Buffer->DeletePending = BooleanFlagOn( capFcb->FcbState, FCB_STATE_DELETE_ON_CLOSE );
            Buffer->Directory = (NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_DIRECTORY);

            if (Buffer->NumberOfLinks == 0) {
                // This swicth is required because of compatibility reasons with
                // the old redirector.
                Buffer->NumberOfLinks = 1;
            }

            if (NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE) {
                Buffer->AllocationSize = capFcb->Header.AllocationSize;
                //Buffer->EndOfFile = capFcb->Header.FileSize;
                RxGetFileSizeWithLock(capFcb,&Buffer->EndOfFile.QuadPart);
            }

            if ( !RxForceQFIPassThrough
                 && FlagOn(capFcb->FcbState,FCB_STATE_FILESIZECACHEING_ENABLED) ) {

                //if we don't have to go to the mini, adjust the size and get out.......
                RxContext->Info.LengthRemaining -= sizeof(FILE_STANDARD_INFORMATION);
                break;

            }
        }
        // falls thru

    default:

        Status = RxpQueryInfoMiniRdr(
                     RxContext,
                     FileStandardInformation,
                     Buffer);
        break;

    }

    RxDbgTrace( 0, Dbg, ("LengthRemaining = %08lx\n", RxContext->Info.LengthRemaining));
    RxDbgTrace(-1, Dbg, ("RxQueryStandardInfo -> VOID\n", 0));

    return Status;
}

NTSTATUS
RxQueryInternalInfo (
    IN PRX_CONTEXT RxContext,
    IN OUT PFILE_INTERNAL_INFORMATION Buffer
    )
/*++
Routine Description:

    (Internal Support Routine)
    This routine performs the query internal information function for fat.

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

Return Value:

    STATUS_SUCCESS/STATUS_PENDING or an appropriate error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureParamBlock;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxQueryInternalInfo...\n", 0));
    RxLog(("RxQueryInternalInfo\n"));
    RxWmiLog(LOG,
             RxQueryInternalInfo,
             LOGPTR(RxContext));

    Status = RxpQueryInfoMiniRdr(
                 RxContext,
                 FileInternalInformation,
                 Buffer);

    RxDbgTrace(-1, Dbg, ("RxQueryInternalInfo...Status %lx\n", Status));
    return Status;
}

NTSTATUS
RxQueryEaInfo (
    IN PRX_CONTEXT              RxContext,
    IN OUT PFILE_EA_INFORMATION Buffer
    )
/*++
Routine Description:

    This routine performs the query Ea information function for fat.

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

Return Value:

    STATUS_SUCCESS/STATUS_PENDING or an appropriate error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureParamBlock;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxQueryEaInfo...\n", 0));
    RxLog(("RxQueryEaInfo\n"));
    RxWmiLog(LOG,
             RxQueryEaInfo,
             LOGPTR(RxContext));

    Status = RxpQueryInfoMiniRdr(
                 RxContext,
                 FileEaInformation,
                 Buffer);

    if ((capPARAMS->Parameters.QueryFile.FileInformationClass == FileAllInformation) &&
        (Status == STATUS_NOT_IMPLEMENTED)) {
        RxContext->Info.LengthRemaining -= sizeof( FILE_EA_INFORMATION );
        Status = STATUS_SUCCESS;
    }

    RxDbgTrace(-1, Dbg, ("RxQueryEaInfo...Status %lx\n", Status));
    return Status;
}

NTSTATUS
RxQueryPositionInfo (
    IN PRX_CONTEXT RxContext,
    IN OUT PFILE_POSITION_INFORMATION Buffer
    )
/*++
Routine Description:

    This routine performs the query position information function for fat.

Arguments:

    RxContext  - the RDBSS context

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

Return Value:

    STATUS_SUCCESS/STATUS_PENDING or an appropriate error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxQueryPositionInfo...\n", 0));
    RxLog(("RxQueryPositionInfo\n"));
    RxWmiLog(LOG,
             RxQueryPositionInfo,
             LOGPTR(RxContext));

    Buffer->CurrentByteOffset = capFileObject->CurrentByteOffset;

    RxContext->Info.LengthRemaining -= sizeof( FILE_POSITION_INFORMATION );

    RxDbgTrace( 0, Dbg, ("LengthRemaining = %08lx\n", RxContext->Info.LengthRemaining));
    RxDbgTrace(-1, Dbg, ("RxQueryPositionInfo...Status %lx\n", Status));
    return Status;
}

VOID
RxConjureOriginalName (
    IN     PFCB    Fcb,
    IN     PFOBX   Fobx,
    OUT    PLONG   pActualNameLength,
           PWCHAR  OriginalName,
    IN OUT PLONG   pLengthRemaining,
    IN RX_NAME_CONJURING_METHODS NameConjuringMethod
    )
/*++
Routine Description:

    This routine conjures up the original name of an Fcb. it is used in querynameinfo below and
    also in RxCanonicalizeAndObtainPieces in the create path for relative opens. for relative opens, we return
    a name of the form \;m:\server\share\.....\name which is how it came down from createfile. otherwise, we give
    back the name relative to the vnetroot.

Arguments:

    Fcb - Supplies the Fcb whose original name is to be conjured

    pActualNameLength - the place to store the actual name length. not all of it will be conjured
                        if the buffer is too small.

    OriginalName - Supplies a pointer to the buffer where the name is to conjured

    pLengthRemaining - Supplies the length of the Name buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

    VNetRootAsPrefix - if true, give back the name as "\;m:", if false, give it back w/o net part.

Return Value:

    None


--*/
{
    PNET_ROOT NetRoot = (PNET_ROOT)Fcb->pNetRoot;
    PUNICODE_STRING NetRootName = &NetRoot->PrefixEntry.Prefix;
    PUNICODE_STRING FcbName = &Fcb->FcbTableEntry.Path;
    PWCHAR CopyBuffer,FcbNameBuffer;
    LONG BytesToCopy,BytesToCopy2;
    LONG FcbNameSuffixLength,PreFcbLength;
    LONG InnerPrefixLength;

    RX_NAME_CONJURING_METHODS OrigianlNameConjuringMethod = NameConjuringMethod;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxConjureOriginalFilename...\n", 0));
    RxDbgTrace(0, Dbg, ("--> NetRootName = %wZ\n", NetRootName));
    RxDbgTrace(0, Dbg, ("--> FcbNameName = %wZ\n", FcbName));
    RxDbgTrace(0, Dbg, ("--> ,AddedBS = %08lx\n",
                         FlagOn(Fcb->FcbState,FCB_STATE_ADDEDBACKSLASH)));

    // here, we have to copy in the vnetrootprefix and the servershare stuff.
    // first figure out the size of the two pieces: prefcblength is the part that comes
    // from the [v]netroot; fcbnamesuffix is the part that is left of the filename after
    // the vnetroot prefix is skipped

    if ((!Fcb->VNetRoot) ||
        (Fcb->VNetRoot->PrefixEntry.Prefix.Buffer[1] != L';') ||
        (FlagOn(Fobx->Flags,FOBX_FLAG_UNC_NAME)) ){

        CopyBuffer = NetRootName->Buffer;
        PreFcbLength = NetRootName->Length;
        InnerPrefixLength = 0;

        NameConjuringMethod = VNetRoot_As_Prefix; //override whatever was passed

    } else {

        PV_NET_ROOT VNetRoot = Fcb->VNetRoot;
        PUNICODE_STRING VNetRootName = &VNetRoot->PrefixEntry.Prefix;

        ASSERT( NodeType(VNetRoot) == RDBSS_NTC_V_NETROOT );
        RxDbgTrace(0, Dbg, ("--> VNetRootName = %wZ\n", VNetRootName));
        RxDbgTrace(0, Dbg, ("--> VNetRootNamePrefix = %wZ\n", &VNetRoot->NamePrefix));

        InnerPrefixLength = VNetRoot->NamePrefix.Length;
        RxDbgTrace(0, Dbg, ("--> ,IPrefixLen = %08lx\n", InnerPrefixLength));

        CopyBuffer = VNetRootName->Buffer;
        PreFcbLength = VNetRootName->Length;

        if (NameConjuringMethod == VNetRoot_As_UNC_Name) {
            // move up past the drive information
            for (;;) {
                CopyBuffer++; PreFcbLength -= sizeof(WCHAR);
                if (PreFcbLength == 0) break;
                if (*CopyBuffer == L'\\') break;
            }
        }
    }

    if (FlagOn(Fcb->FcbState,FCB_STATE_ADDEDBACKSLASH)) {
        InnerPrefixLength += sizeof(WCHAR);
    }

    //  next, Copyin the NetRoot Part  OR the VNetRoot part.
    //  If we overflow, set *pLengthRemaining to -1 as a flag.

    if (NameConjuringMethod != VNetRoot_As_DriveLetter) {

        if (*pLengthRemaining < PreFcbLength) {

            BytesToCopy = *pLengthRemaining;
            *pLengthRemaining = -1;

        } else {

            BytesToCopy = PreFcbLength;
            *pLengthRemaining -= BytesToCopy;
        }

        RtlCopyMemory( OriginalName,
                       CopyBuffer,
                       BytesToCopy );

        BytesToCopy2 = BytesToCopy;

    } else {

        PreFcbLength = 0;
        BytesToCopy2 = 0;

        if ((FcbName->Length > InnerPrefixLength)
            && ( *((PWCHAR)(((PCHAR)FcbName->Buffer)+InnerPrefixLength)) != OBJ_NAME_PATH_SEPARATOR )) {
            InnerPrefixLength -= sizeof(WCHAR);
        }
    }

    FcbNameSuffixLength = FcbName->Length - InnerPrefixLength;

    if (FcbNameSuffixLength <= 0) {
        FcbNameBuffer = L"\\";
        FcbNameSuffixLength = 2;
        InnerPrefixLength = 0;
    } else {
        FcbNameBuffer = FcbName->Buffer;
    }

    //report how much is really needed
    *pActualNameLength = PreFcbLength + FcbNameSuffixLength;

    // the netroot part has been copied; finally, copy in the part of the name
    // that is past the prefix

    if (*pLengthRemaining != -1) {

        //  Next, Copyin the Fcb Part
        //  If we overflow, set *pLengthRemaining to -1 as a flag.
        //

        if (*pLengthRemaining < FcbNameSuffixLength) {

            BytesToCopy = *pLengthRemaining;
            *pLengthRemaining = -1;

        } else {

            BytesToCopy = FcbNameSuffixLength;
            *pLengthRemaining -= BytesToCopy;
        }

        RtlCopyMemory( ((PCHAR)OriginalName)+PreFcbLength,
                       ((PCHAR)FcbNameBuffer)+InnerPrefixLength,
                       BytesToCopy );
    } else {

        //DbgPrint("No second copy\n");
        DbgDoit(BytesToCopy=0;);
    }

    RxDbgTrace(-1, Dbg, ("RxConjureOriginalFilename -> VOID\n", 0));

    return;
}

NTSTATUS
RxQueryNameInfo (
    IN     PRX_CONTEXT            RxContext,
    IN OUT PFILE_NAME_INFORMATION Buffer
    )
/*++
Routine Description:

    This routine performs the query name information function.  what makes this hard is that
    we have to return partial results.

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

Return Value:

    STATUS_SUCCESS if the name fits
    STATUS_BUFFER_OVERFLOW otherwise

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb; RxCaptureFobx;
    PLONG pLengthRemaining = &RxContext->Info.LengthRemaining;
    LONG OriginalLengthRemaining = RxContext->Info.LengthRemaining;
    RxDbgTrace(+1, Dbg, ("RxQueryNameInfo...\n", 0));
    RxLog(("RxQueryNameInfo\n"));
    RxWmiLog(LOG,
             RxQueryNameInfo,
             LOGPTR(RxContext));

    PAGED_CODE();


    *pLengthRemaining -= FIELD_OFFSET(FILE_NAME_INFORMATION, FileName[0]);

    if (*pLengthRemaining < 0) {
        *pLengthRemaining = 0;
        Status = STATUS_BUFFER_OVERFLOW;
    } else {
        RxConjureOriginalName(capFcb,capFobx,
                              &Buffer->FileNameLength,
                              &Buffer->FileName[0],
                              pLengthRemaining,
                              VNetRoot_As_UNC_Name //VNetRoot_As_DriveLetter
                              );
        RxDbgTrace( 0, Dbg, ("*pLengthRemaining = %08lx\n", *pLengthRemaining));
        if (*pLengthRemaining < 0) {
            *pLengthRemaining = 0;
            Status = STATUS_BUFFER_OVERFLOW;
        }
    }


    RxDbgTrace(-1, Dbg, ("RxQueryNameInfo -> %08lx\n", Status));
    return Status;
}

NTSTATUS
RxQueryAlternateNameInfo (
    IN     PRX_CONTEXT            RxContext,
    IN OUT PFILE_NAME_INFORMATION Buffer
    )
/*++
Routine Description:

    This routine queries the short name of the file.

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

Return Value:

    STATUS_SUCCESS/STATUS_PENDING or an appropriate error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureParamBlock;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxQueryAlternateNameInfo...\n", 0));
    RxLog(("RxQueryAlternateNameInfo\n"));
    RxWmiLog(LOG,
             RxQueryAlternateNameInfo,
             LOGPTR(RxContext));

    Status = RxpQueryInfoMiniRdr(
                 RxContext,
                 FileAlternateNameInformation,
                 Buffer);

    RxDbgTrace(-1, Dbg, ("RxQueryAlternateNameInfo...Status %lx\n", Status));

    return Status;
}

NTSTATUS
RxQueryCompressedInfo (
    IN     PRX_CONTEXT                   RxContext,
    IN OUT PFILE_COMPRESSION_INFORMATION Buffer
    )
/*++
Routine Description:

    This routine performs the query compressed file size function for fat.
    This is only defined for compressed volumes.

Arguments:

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

Return Value:

    STATUS_SUCCESS/STATUS_PENDING or an appropriate error code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureParamBlock;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxQueryCompressedFileSize...\n", 0));
    RxLog(("RxQueryCompressedFileSize\n"));
    RxWmiLog(LOG,
             RxQueryCompressedInfo,
             LOGPTR(RxContext));

    //  Start by flushing the file.  We have to do this since the compressed
    //  file size is not defined until the file is actually written to disk.

    Status = RxFlushFcbInSystemCache(capFcb, TRUE);

    if (!NT_SUCCESS(Status)) {
        RxNormalizeAndRaiseStatus( RxContext, Status );
    }

    Status = RxpQueryInfoMiniRdr(
                 RxContext,
                 FileCompressionInformation,
                 Buffer);

    RxDbgTrace( 0, Dbg, ("LengthRemaining = %08lx\n", RxContext->Info.LengthRemaining));
    RxDbgTrace(-1, Dbg, ("RxQueryCompressedFileSize -> Status\n", Status));

    return Status;
}



NTSTATUS
RxSetPipeInfo(
   IN OUT PRX_CONTEXT RxContext)
/*++
Routine Description:

    This routine updates the FILE_PIPE_INFORMATION/FILE_PIPE_REMOTE_INFORMATION
    associated with an instance of a named pipe

Arguments:

    RxContext -- the associated RDBSS context

Return Value:

    STATUS_SUCCESS/STATUS_PENDING or an appropriate error code

--*/
{
   NTSTATUS Status = STATUS_SUCCESS;

   RxCaptureRequestPacket;
   RxCaptureFobx;
   RxCaptureFcb;
   RxCaptureParamBlock;
   RxCaptureFileObject;

   FILE_INFORMATION_CLASS FileInformationClass = capPARAMS->Parameters.QueryFile.FileInformationClass;
   BOOLEAN PostIrp = FALSE;

    PAGED_CODE();

   RxDbgTrace(+1, Dbg, ("RxSetPipeInfo...\n", 0));
   RxLog(("RxSetPipeInfo\n"));
   RxWmiLog(LOG,
            RxSetPipeInfo,
            LOGPTR(RxContext));

   if (capFcb->pNetRoot->Type != NET_ROOT_PIPE) {
      Status = STATUS_INVALID_PARAMETER;
   } else {
      switch (FileInformationClass) {
      case FilePipeInformation:
         {
            if (capPARAMS->Parameters.SetFile.Length == sizeof(FILE_PIPE_INFORMATION)) {
               PFILE_PIPE_INFORMATION pPipeInfo = (PFILE_PIPE_INFORMATION)capReqPacket->AssociatedIrp.SystemBuffer;

               if ((pPipeInfo->ReadMode != capFobx->Specific.NamedPipe.ReadMode) ||
                   (pPipeInfo->CompletionMode != capFobx->Specific.NamedPipe.CompletionMode)) {
                  RxContext->Info.FileInformationClass = (FilePipeInformation);
                  RxContext->Info.Buffer = pPipeInfo;
                  RxContext->Info.Length = sizeof(FILE_PIPE_INFORMATION);
                  MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxSetFileInfo,(RxContext));

                  if (Status == STATUS_SUCCESS) {
                     capFobx->Specific.NamedPipe.ReadMode       = pPipeInfo->ReadMode;
                     capFobx->Specific.NamedPipe.CompletionMode = pPipeInfo->CompletionMode;
                  }
               }
            } else {
               Status = STATUS_INVALID_PARAMETER;
            }
         }
         break;
      case FilePipeLocalInformation:
         {
            Status = STATUS_INVALID_PARAMETER;
         }
         break;
      case FilePipeRemoteInformation:
         {
            if (capPARAMS->Parameters.SetFile.Length == sizeof(FILE_PIPE_REMOTE_INFORMATION)) {
               PFILE_PIPE_REMOTE_INFORMATION pPipeRemoteInfo = (PFILE_PIPE_REMOTE_INFORMATION)capReqPacket->AssociatedIrp.SystemBuffer;

               capFobx->Specific.NamedPipe.CollectDataTime = pPipeRemoteInfo->CollectDataTime;
               capFobx->Specific.NamedPipe.CollectDataSize = pPipeRemoteInfo->MaximumCollectionCount;
            } else {
               Status = STATUS_INVALID_PARAMETER;
            }
         }
         break;
      default:
         Status = STATUS_INVALID_PARAMETER;
         break;
      }
   }

   RxDbgTrace(-1, Dbg, ("RxSetPipeInfo: Status ....%lx\n", Status));

   return Status;
}

NTSTATUS
RxSetSimpleInfo(
   IN OUT PRX_CONTEXT RxContext)
/*++
Routine Description:

    This routine updates file information that is changed through
    a simple MiniRdr Call.
    Right now this consists of ShortNameInfo & ValdiDataLengthInfo

Arguments:

    RxContext -- the associated RDBSS context

Return Value:

    STATUS_SUCCESS/STATUS_PENDING or an appropriate error code

--*/
{
    RxCaptureParamBlock;
    FILE_INFORMATION_CLASS FileInformationClass = capPARAMS->Parameters.SetFile.FileInformationClass;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    // logging code
    RxDbgTrace(+1, Dbg, ("RxSetSimpleInfo: %d\n", FileInformationClass));
    RxLog(("RxSetSimpleInfo\n"));
    RxWmiLog(LOG,
         RxSetSimpleInfo,
         LOGPTR(RxContext));


    // call the MiniRdr
    Status =  RxpSetInfoMiniRdr(RxContext,FileInformationClass);

    // logging code
    RxDbgTrace(-1, Dbg, ("RxSetSimpleInfo: Status ....%lx\n", Status));

    return Status;
}

NTSTATUS
RxQueryPipeInfo(
    IN PRX_CONTEXT RxContext,
    IN OUT PVOID   pBuffer
    )
/*++
Routine Description:

    This routine queries the FILE_PIPE_INFORMATION/FILE_PIPE_REMOTE_INFORMATION
    and FILE_PIPE_LOCAL_INFORMATION associated with an instance of a named pipe

Arguments:

    RxContext -- the associated RDBSS context

    pBuffer   -- the buffer for query information

Return Value:

    STATUS_SUCCESS/STATUS_PENDING or an appropriate error code

--*/
{
   NTSTATUS Status = STATUS_SUCCESS;

   RxCaptureRequestPacket;
   RxCaptureFcb; RxCaptureFobx;
   RxCaptureParamBlock;
   RxCaptureFileObject;

   FILE_INFORMATION_CLASS FileInformationClass = capPARAMS->Parameters.QueryFile.FileInformationClass;
   PLONG pLengthRemaining = &RxContext->Info.LengthRemaining;
   BOOLEAN PostIrp = FALSE;

    PAGED_CODE();

   RxDbgTrace(+1, Dbg, ("RxQueryPipeInfo...\n", 0));
   RxLog(("RxQueryPipeInfo\n"));
   RxWmiLog(LOG,
            RxQueryPipeInfo,
            LOGPTR(RxContext));

   if (capFcb->pNetRoot->Type != NET_ROOT_PIPE) {
      Status = STATUS_INVALID_PARAMETER;
   } else {
      switch (FileInformationClass) {
      case FilePipeInformation:
         if (*pLengthRemaining >= sizeof(FILE_PIPE_INFORMATION)) {
            PFILE_PIPE_INFORMATION pPipeInfo = (PFILE_PIPE_INFORMATION)pBuffer;

            pPipeInfo->ReadMode       = capFobx->Specific.NamedPipe.ReadMode;
            pPipeInfo->CompletionMode = capFobx->Specific.NamedPipe.CompletionMode;

            //  Update the buffer length
            *pLengthRemaining -= sizeof( FILE_PIPE_INFORMATION );
         } else {
            Status = STATUS_BUFFER_OVERFLOW;
         }
         break;
      case FilePipeLocalInformation:
         if (*pLengthRemaining >= sizeof(FILE_PIPE_LOCAL_INFORMATION)) {
            PFILE_PIPE_LOCAL_INFORMATION pPipeLocalInfo = (PFILE_PIPE_LOCAL_INFORMATION)pBuffer;


            Status = RxpQueryInfoMiniRdr(
                         RxContext,
                         FilePipeLocalInformation,
                         pBuffer);
         } else {
            Status = STATUS_BUFFER_OVERFLOW;
         }
         break;
      case FilePipeRemoteInformation:
         if (*pLengthRemaining >= sizeof(FILE_PIPE_REMOTE_INFORMATION)) {
            PFILE_PIPE_REMOTE_INFORMATION pPipeRemoteInfo = (PFILE_PIPE_REMOTE_INFORMATION)pBuffer;

            pPipeRemoteInfo->CollectDataTime        = capFobx->Specific.NamedPipe.CollectDataTime;
            pPipeRemoteInfo->MaximumCollectionCount = capFobx->Specific.NamedPipe.CollectDataSize;

            //  Update the buffer length
            *pLengthRemaining -= sizeof( FILE_PIPE_REMOTE_INFORMATION );
         } else {
            Status = STATUS_BUFFER_OVERFLOW;
         }
         break;
      default:
         Status = STATUS_INVALID_PARAMETER;
         break;
      }
   }

   RxDbgTrace( 0, Dbg, ("RxQueryPipeInfo: *pLengthRemaining = %08lx\n", *pLengthRemaining));

   return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\lockctrl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    LockCtrl.c

Abstract:

    This module implements the Lock Control routines for Rx called
    by the dispatch driver.

Author:

    Joe Linn     [JoeLinn]    9-Nov-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOCKCTRL)


NTSTATUS
RxLowIoLockControlShell (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxLowIoLockControlShellCompletion (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxLockOperationCompletionWithAcquire (
    IN PRX_CONTEXT RxContext
    );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonLockControl)
#pragma alloc_text(PAGE, RxLockOperationCompletion)
#pragma alloc_text(PAGE, RxLockOperationCompletionWithAcquire)
#pragma alloc_text(PAGE, RxUnlockOperation)
#pragma alloc_text(PAGE, RxLowIoLockControlShellCompletion)
#pragma alloc_text(PAGE, RxFinalizeLockList)
#pragma alloc_text(PAGE, RxLowIoLockControlShell)
#endif


NTSTATUS
RxCommonLockControl ( RXCOMMON_SIGNATURE )

/*++

Routine Description:

    This is the common routine for doing Lock control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    BOOLEAN OplockPostIrp = FALSE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonLockControl...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, capFobx, capFcb));
    RxDbgTrace( 0, Dbg, ("MinorFunction = %08lx\n", capPARAMS->MinorFunction));
    RxLog(("Lock %lx %lx %lx %lx\n", RxContext, capFobx, capFcb, capPARAMS->MinorFunction));
    RxWmiLog(LOG,
             RxCommonLockControl_1,
             LOGPTR(RxContext)
             LOGPTR(capFobx)
             LOGPTR(capFcb)
             LOGUCHAR(capPARAMS->MinorFunction));

    //
    //  If the file is not a user file open then we reject the request
    //  as an invalid parameter
    //

    if (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE) {

        RxDbgTrace(-1, Dbg, ("RxCommonLockControl -> RxStatus(INVALID_PARAMETER\n)", 0));
        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Acquire shared access to the Fcb and enqueue the Irp if we didn't
    //  get access.
    //

    Status = RxAcquireSharedFcb( RxContext, capFcb );
    if (Status == STATUS_LOCK_NOT_GRANTED) {

        Status = RxFsdPostRequest( RxContext );
        RxDbgTrace(-1, Dbg, ("RxCommonLockControl -> %08lx\n", Status));
        return Status;

    } else if (Status != STATUS_SUCCESS) {

       RxDbgTrace(-1, Dbg, ("RxCommonLockControl -> error accquiring Fcb (%lx) %08lx\n", capFcb, Status));
       return Status;
    }

    SetFlag(RxContext->FlagsForLowIo,RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD);

    try {

        // tell the buffering change guys that locks are outstanding

        InterlockedIncrement(&capFcb->OutstandingLockOperationsCount);

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        Status = FsRtlCheckOplock( &capFcb->Specific.Fcb.Oplock,
                                   capReqPacket,
                                   RxContext,
                                   RxOplockComplete,
                                   NULL );

        if (Status != STATUS_SUCCESS) {

            OplockPostIrp = TRUE;
            try_return( NOTHING );
        }

        // setup the bit telling the unlock routine whether to pitch or save the unlocks passed down
        // from fsrtl.

        switch (capPARAMS->MinorFunction) {
        case IRP_MN_LOCK:

            //find out if this lock is realizable......if not, don't proceed........
            if ((capFcb->MRxDispatch != NULL) && (capFcb->MRxDispatch->MRxIsLockRealizable != NULL)) {

                Status = capFcb->MRxDispatch->MRxIsLockRealizable(
                                           (PMRX_FCB)capFcb,
                                           &capPARAMS->Parameters.LockControl.ByteOffset,
                                           capPARAMS->Parameters.LockControl.Length,
                                           capPARAMS->Flags
                                           );
            }

            if (Status != STATUS_SUCCESS) {
                try_return( Status );
            }

            if (!FlagOn(capPARAMS->Flags,SL_FAIL_IMMEDIATELY)) {
                // we cannot handout in the lock queue with the resource held
                RxReleaseFcb( RxContext, capFcb );
                ClearFlag(RxContext->FlagsForLowIo,RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD);
            }
            break;

        case IRP_MN_UNLOCK_SINGLE:
            break;
        case IRP_MN_UNLOCK_ALL:
        case IRP_MN_UNLOCK_ALL_BY_KEY:
            LowIoContext->Flags |= LOWIO_CONTEXT_FLAG_SAVEUNLOCKS;
            break;
        }
        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request; take a reference before we go in that will be removed
        //  by the LockOperationComplete guy.
        //

        RxLog(("Inc RxC %lx L %ld %lx\n", RxContext,__LINE__,RxContext->ReferenceCount));
        RxWmiLog(LOG,
                 RxCommonLockControl_2,
                 LOGPTR(RxContext)
                 LOGULONG(RxContext->ReferenceCount));
        InterlockedIncrement(&RxContext->ReferenceCount);

        // Store the current thread id. in the lock manager context to
        // distinguisgh between the case when the request was pended in the
        // lock manager and the case when it was immediately satisfied.

        InterlockedExchangePointer(
            &RxContext->LockManagerContext,
            PsGetCurrentThread());

        try {
            Status = FsRtlProcessFileLock(
                         &capFcb->Specific.Fcb.FileLock,
                         capReqPacket,
                         RxContext );
        } except(EXCEPTION_EXECUTE_HANDLER) {
              return RxProcessException( RxContext, GetExceptionCode() );
        }
        
        // call the completion wrapper that reacquires the resource

        if ((Status == STATUS_SUCCESS) &&
            !BooleanFlagOn(
                RxContext->FlagsForLowIo,
                RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD)) {

            // if we get queued then we have to keep the refcount up to prevent early finalization
            // from later in this routine. so take a reference here and set up to remove it
            // if we call down to lowio

            RxLog(("Inc RxC %lx L %ld %lx\n", RxContext,__LINE__,RxContext->ReferenceCount));
            RxWmiLog(LOG,
                     RxCommonLockControl_3,
                     LOGPTR(RxContext)
                     LOGULONG(RxContext->ReferenceCount));
            InterlockedIncrement(&RxContext->ReferenceCount);

            SetFlag(
                RxContext->FlagsForLowIo,
                RXCONTEXT_FLAG4LOWIO_LOCK_WAS_QUEUED_IN_LOCKMANAGER);

            Status = RxLockOperationCompletionWithAcquire( RXCOMMON_ARGUMENTS );

            if (Status != STATUS_PENDING) {

                //take back the reference....didn't need it. this cannot
                // be the last one, so we just decrement

                RxLog(("Dec RxC %lx L %ld %lx\n", RxContext,__LINE__,RxContext->ReferenceCount));
                RxWmiLog(LOG,
                         RxCommonLockControl_4,
                         LOGPTR(RxContext)
                         LOGULONG(RxContext->ReferenceCount));
                InterlockedDecrement(&RxContext->ReferenceCount);
            }
        } else if (Status == STATUS_PENDING) {
            InterlockedExchangePointer(
                &RxContext->LockManagerContext,
                NULL);
        }

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        //capFcb->Header.IsFastIoPossible = RxIsFastIoPossible( capFcb );

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( RxCommonLockControl );

        //
        //  If resources have been acquired, release them under the right conditions.
        //  the right conditions are these:
        //     1) if we have abnormal termination. here we obviously release the since no one else will.
        //     2) if the underlying call did not succeed: Status==Pending.
        //     3) if we posted the request
        //  We also take away a opcount since the context is about to be completed.

        if (AbnormalTermination() || (Status!=STATUS_PENDING) || OplockPostIrp) {

            if (FlagOn(RxContext->FlagsForLowIo,RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD)) {
                InterlockedDecrement(&capFcb->OutstandingLockOperationsCount);
                RxReleaseFcb( RxContext, capFcb );
            }
        } else {

            // here the guy below is going to handle the completion....but, we
            // don't know the finish order....in all likelihood the deletecontext
            // call below just reduces the refcount but the guy may already have
            // finished in which case this will really delete the context.

            RxLog(("Dec RxC %lx L %ld %lx\n", RxContext,__LINE__,RxContext->ReferenceCount));
            RxWmiLog(LOG,
                     RxCommonLockControl_5,
                     LOGPTR(RxContext)
                     LOGULONG(RxContext->ReferenceCount));
            RxDereferenceAndDeleteRxContext(RxContext);
        }

        RxDbgTrace(-1, Dbg, ("RxCommonLockControl -> %08lx\n", Status));
    } //finally

    return Status;
}

#define RDBSS_LOCK_MANAGER_REQUEST_RESUMED (IntToPtr(0xaaaaaaaa)) // Sundown: sign-extended.


NTSTATUS
RxLockOperationCompletion (
    IN PVOID Context,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called after the FSRTL lock package has processed a lock
    operation. If locks are not being held, we call down to the correct minirdr
    routine. BTW, we do not actually complete the packet here. that is either
    done above (fsd or fsp) or it will be done asynchronously.

    The logic for locks is greatly complicated by locks that do not fail
    immediately but wait until they can be completed. If the request is not of
    this type then we will go into the normal lowio stuff from here.

    If the request is !failimmediately, then there are two cases depending on
    whether or not the lock was enqueued. In both cases, we have to reacquire
    the resource before we can proceed. In the case where the lock was NOT
    enqueued, we back up into CommonLock where there is code to call back into
    this routine with the resource held. Then things proceed as normal.

    However, if we did wait in the lock queue then we will have to post to a
    worker thread to get our work. Here, PENDING is returned to CommonLock so he
    removes one refcount leaving only one for this routine. However, the normal
    entrystate for this routine is 2 refcounts....one that is taken away here
    and one that belongs to whoever completes the request. So, we take an extra
    one before we post.  Posting leaves us still with two cases: locks-buffered
    vs locks-not-buffered. In the locks-buffered case, we come back in here with
    2 refcounts; we take awayone here and the fspdispatch takes away the other
    when it completes. Finally, if locks are not buffered then we go to the
    wire: since it is async, pending could be returned. no-pending is just as
    before. With pending, lowio takes an extra reference that belongs to the
    completion routine and that leaves one reference to take away on this path.
    Unlike commonlock, fspdispatch does not have the clause that takes away a
    reference on pending-returned. SOOOOOO, we take one away here if lowio
    returns pending AND we were enqueued. got that???

    A minirdr should not go for an indefinite stay at the wire with the resource
    held; if necessary, it should drop the resource and reacquire it.

Arguments:

    IN PVOID Context - Provides the context supplied to FsRtlProcessFileLock.
                       In this case, it is the original RxContext.

    IN PIRP Irp - Supplies an IRP describing the lock operation.

Return Value:

    RXSTATUS - Final status of operation..

--*/
{
    PRX_CONTEXT RxContext = Context;
    NTSTATUS    Status = Irp->IoStatus.Status;

    PVOID       LockManagerContext;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxLockOperationCompletion -> RxContext = %08lx, 1stStatus= %08lx\n", RxContext, Status));
    RxLog(("LockCompEntry %lx %lx\n", RxContext, Status));
    RxWmiLog(LOG,
             RxLockOperationCompletion_1,
             LOGPTR(RxContext)
             LOGULONG(Status));

    ASSERT(Context);

    // the comments in rdr1 say that this can happen even tho i cannot find it
    // in the code. be safe!

    if ((Context==NULL)) {
        RxLog(("NULLCONTEXT %lx %lx\n", RxContext, Status));
        RxWmiLog(LOG,
                 RxLockOperationCompletion_2,
                 LOGPTR(RxContext)
                 LOGULONG(Status));
        RxDbgTrace(-1, Dbg, ("RxLockOperationCompletion NULLCONTEXT-> Status = %08lx\n", Status));
        return Status;
    }

    ASSERT( Irp == RxContext->CurrentIrp);

    // The LockManagerContext field in the RxContext supplied to the lock
    // manager routine is initialized to the thread id. of the thread submitting
    // the request and set to RDBSS_LOCK_MANAGER_REQUEST_PENDING on return if
    // STATUS_PENDING is returned. Thus if this routine is called with the
    // value in this field is not equal to either the current thread id. or
    // RDBSS_LOCK_MANAGER_REQUEST_RESUMED, we are guaranteed that this request
    // was pended in the the lock manager.

    LockManagerContext = InterlockedExchangePointer(
                             &RxContext->LockManagerContext,
                             RDBSS_LOCK_MANAGER_REQUEST_RESUMED);

    if ((LockManagerContext != PsGetCurrentThread()) &&
        (LockManagerContext != RDBSS_LOCK_MANAGER_REQUEST_RESUMED)) {
        //here we were hung out in the lock queue........turn the operation to
        // async and post to get the resource back. read the notes above to see
        // why we inc the refcount

        RxLog(("Inc RxC %lx L %ld %lx\n", RxContext,__LINE__,RxContext->ReferenceCount));
        RxWmiLog(LOG,
                 RxLockOperationCompletion_3,
                 LOGPTR(RxContext)
                 LOGULONG(RxContext->ReferenceCount));

        InterlockedIncrement(&RxContext->ReferenceCount);

        SetFlag(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);
        SetFlag(
            RxContext->FlagsForLowIo,
            RXCONTEXT_FLAG4LOWIO_LOCK_WAS_QUEUED_IN_LOCKMANAGER);

        RxDbgTrace( -1, Dbg, ("Posing Queued LockReq = %08lx\n", RxContext));

        if (FlagOn(RxContext->FlagsForLowIo,
                   RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD)) {
            RxReleaseFcb( RxContext, RxContext->pFcb );
            ClearFlag(RxContext->FlagsForLowIo,RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD);
        }

        Status = RxFsdPostRequestWithResume(
                     RxContext,
                     RxLockOperationCompletionWithAcquire);

        return(Status);
    }

    { //new scope so i can use the capture macros
    RxCaptureFcb;
    RxCaptureParamBlock;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    // if we dropped the resource before we came in, then we reacquire it now.
    // the guy above me must be the commonlock routine and he come back down
    // thru the reacquire wrapper...sort of a post without posting

    if (!FlagOn(RxContext->FlagsForLowIo,RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD)) {
        Status = STATUS_SUCCESS;
        RxLog(("ResDropUp! %lx %lx\n",RxContext,capFcb->FcbState));
        RxWmiLog(LOG,
                 RxLockOperationCompletion_4,
                 LOGPTR(RxContext)
                 LOGULONG(capFcb->FcbState));
        RxDbgTrace(-1, Dbg, ("RxLockOperationCompletion Resdropup-> Status = %08lx\n", Status));
        return Status;
    }

    // this is the normal case. remove the extra reference. this cannot
    // be the last one, so we just decrement

    RxLog(("Dec RxC %lx L %ld %lx\n", RxContext,__LINE__,RxContext->ReferenceCount));
    RxWmiLog(LOG,
             RxLockOperationCompletion_5,
             LOGPTR(RxContext)
             LOGULONG(RxContext->ReferenceCount));
    InterlockedDecrement(&RxContext->ReferenceCount);

    // if we have nonsuccess, just get out!

    if (!NT_SUCCESS(Status)) {
        RxLog(("NONSUCCESS %lx %lx\n", RxContext, Status));
        RxWmiLog(LOG,
                 RxLockOperationCompletion_6,
                 LOGPTR(RxContext)
                 LOGULONG(Status));
        RxDbgTrace(-1, Dbg, ("RxLockOperationCompletion NONSUCCESS-> Rxc,Status =%08lx %08lx\n",RxContext,Status));
        return Status;
    }

    // if locks are buffered, just get out

    if (FlagOn(capFcb->FcbState,FCB_STATE_LOCK_BUFFERING_ENABLED)) {
        Status = STATUS_SUCCESS;
        RxLog(("LocksBuffered! %lx %lx %lx\n",
                      RxContext,
                      capFcb->FcbState,
                      RxContext->ReferenceCount));
        RxWmiLog(LOG,
                 RxLockOperationCompletion_7,
                 LOGPTR(RxContext)
                 LOGULONG(capFcb->FcbState)
                 LOGULONG(RxContext->ReferenceCount));
        RxDbgTrace(-1, Dbg, ("RxLockOperationCompletion LockOpBuffered-> Status = %08lx\n", Status));
        return Status;
    }

    // otherwise, let's go to the mini

    RxInitializeLowIoContext(LowIoContext,LOWIO_OP_UNLOCK);
    LowIoContext->ParamsFor.Locks.ByteOffset = capPARAMS->Parameters.LockControl.ByteOffset.QuadPart;
    LowIoContext->ParamsFor.Locks.Key = capPARAMS->Parameters.LockControl.Key;
    LowIoContext->ParamsFor.Locks.Flags = 0;     //no flags

    switch (capPARAMS->MinorFunction) {
    case IRP_MN_LOCK:
        LowIoContext->Operation = (capPARAMS->Flags & SL_EXCLUSIVE_LOCK)
                                                 ?LOWIO_OP_EXCLUSIVELOCK
                                                 :LOWIO_OP_SHAREDLOCK;
        LowIoContext->ParamsFor.Locks.Flags = capPARAMS->Flags;
        LowIoContext->ParamsFor.Locks.Length = (*capPARAMS->Parameters.LockControl.Length).QuadPart;
        break;

    case IRP_MN_UNLOCK_SINGLE:
        LowIoContext->ParamsFor.Locks.Length = (*capPARAMS->Parameters.LockControl.Length).QuadPart;
        break;

    case IRP_MN_UNLOCK_ALL:
    case IRP_MN_UNLOCK_ALL_BY_KEY:
        if (LowIoContext->ParamsFor.Locks.LockList == NULL){
            RxDbgTrace(-1, Dbg, ("RxLockOperationCompletion -> Nothing to unlock\n"));
            return STATUS_SUCCESS;
        }
        LowIoContext->Operation = LOWIO_OP_UNLOCK_MULTIPLE;
        break;

    }

    RxDbgTrace( 0, Dbg, ("--->Operation = %08lx\n", LowIoContext->Operation));

    Status = RxLowIoLockControlShell(RxContext);

    if ((Status == STATUS_PENDING) &&
        FlagOn(
            RxContext->FlagsForLowIo,
            RXCONTEXT_FLAG4LOWIO_LOCK_WAS_QUEUED_IN_LOCKMANAGER)) {

        // the fsp dispatch routine doesn't have a clause to take away a
        // reference on pended operations. so, if we were queued AND we are
        // returning pending back thru the fsp, then take away a reference here.

        RxLog(("Dec RxC %lx L %ld %lx\n", RxContext,__LINE__,RxContext->ReferenceCount));
        RxWmiLog(LOG,
                 RxLockOperationCompletion_8,
                 LOGPTR(RxContext)
                 LOGULONG(RxContext->ReferenceCount));
        RxDereferenceAndDeleteRxContext(RxContext);
    }

    RxDbgTrace(-1, Dbg, ("RxLockOperationCompletion -> Status = %08lx\n", Status));
    return Status;

    }// end of scope introduced for capture macros
}

NTSTATUS
RxLockOperationCompletionWithAcquire ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This routine is responsible to get the resource back in case we were held up
    in the lock queue. Then it calls the LockOperationComplete. Of course, it has
    to mess around with giving the resource back for abnormal termination and the
    like.

    Two things are invariant ... first, when we get here there are two references
    on the rxcontext. also, unless we return pending, the fsp guy above will try
    to complete this request. here's what we do.

    this routine is refcount-neutral: it always takes away as many as it places.
    it has to place refcount on the context if it acquires the resource in order
    to maintain the invariant that a context always!!!!! has the same number of
    releases as acquires. if it takes this refcount, then it releases it
    EVEN IF THE FCB IS NOT RELEASED HERE. (it might be relased on the async
    path instead.)

    Last, we can also be called from the original commonlock routine. in this
    case, we take care of releasing the fcb and clear the flag so that it will
    not be released above.

Arguments:


Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock;
    BOOLEAN ReleaseFcb = FALSE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxLockOperationCompletionWithAcquire...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, capFobx, capFcb));
    RxDbgTrace( 0, Dbg, ("MinorFunction = %08lx\n", capPARAMS->MinorFunction));
    RxLog(("LockAcq %lx %lx %lx %lx\n", RxContext, capFobx, capFcb, capPARAMS->MinorFunction));
    RxWmiLog(LOG,
             RxLockOperationCompletionWithAcquire_1,
             LOGPTR(RxContext)
             LOGPTR(capFobx)
             LOGPTR(capFcb)
             LOGUCHAR(capPARAMS->MinorFunction));

    //
    //  Acquire shared access to the Fcb
    //

    Status = RxAcquireSharedFcb( RxContext, capFcb );
    if (Status == STATUS_LOCK_NOT_GRANTED) {

        Status = RxFsdPostRequestWithResume(RxContext,RxLockOperationCompletionWithAcquire);
        RxDbgTrace(-1, Dbg, ("RxLockOperationCompletionWithAcquire -> %08lx\n", Status));
        return Status;

    } else if (Status != STATUS_SUCCESS) {

       RxDbgTrace(-1, Dbg, ("RxLockOperationCompletionWithAcquire -> error accquiring Fcb (%lx) %08lx\n", capFcb, Status));
       return Status;
    }

    SetFlag(RxContext->FlagsForLowIo,RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD);

    RxLog(("Inc RxC %lx L %ld %lx\n", RxContext,__LINE__,RxContext->ReferenceCount));
    RxWmiLog(LOG,
             RxLockOperationCompletionWithAcquire_2,
             LOGPTR(RxContext)
             LOGULONG(RxContext->ReferenceCount));
    InterlockedIncrement(&RxContext->ReferenceCount); // we MUST!!! deref

    try {
        // Call the guy to complete the lock request....with the resrouce held

        Status = RxLockOperationCompletion(RxContext,capReqPacket);

    } finally {

        DebugUnwind( RxLockOperationCompletionWithAcquire );

        //  If resources have been acquired, release them under the right conditions.
        //  the right conditions are these:
        //     1) if we have abnormal termination. here we obviously release the
        //        resource since no one else will.
        //     2) if the underlying call did not succeed: Status==Pending.
        //  We also take away a opcount since the context is about to be completed.

        if (AbnormalTermination() || (Status!=STATUS_PENDING)) {

            ReleaseFcb = TRUE;

        } else {

            //here the guy below is going to handle the completion

            ASSERT(FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));
        }

        if (ReleaseFcb) {

            InterlockedDecrement(&capFcb->OutstandingLockOperationsCount);
            RxReleaseFcb( RxContext, capFcb );
            ClearFlag(RxContext->FlagsForLowIo,RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD);

        }

        //
        // if we took a refcount we MUST deref no matter what!

        RxLog(("Dec RxC %lx L %ld %lx\n", RxContext,__LINE__,RxContext->ReferenceCount));
        RxWmiLog(LOG,
                 RxLockOperationCompletionWithAcquire_3,
                 LOGPTR(RxContext)
                 LOGULONG(RxContext->ReferenceCount));
        RxDereferenceAndDeleteRxContext(RxContext);

        RxDbgTrace(-1, Dbg, ("RxLockOperationCompletionWithAcquire -> %08lx\n", Status));

    } //finally

    return Status;
}


VOID
RxUnlockOperation (
    IN PVOID Context,
    IN PFILE_LOCK_INFO LockInfo
    )

/*++

Routine Description:

    This routine is called after the FSRTL lock package has determined that a
    locked region is to be unlocked. We do one of two things as determined by a
    bit in the lowio_flags field. If the bit is clear, we just ignore the call.
    This happens on unlock single calls that are passed down to the minirdr
    exactly as a single lock. For a unlock_all or unlock_all_by_key, we use
    these calls to get an enumeration of the lock set. then, these go thru lowIO
    but using the list method.


Arguments:

    IN PVOID Context - Provides the context supplied to FsRtlProcessFileLock.
                       In this case, it is the RxContext of the Ongoing unlock
                       operation OR of a cleanup operation

    IN PFILE_LOCK_INFO LockInfo - Describes the region being unlock

Return Value:

    RXSTATUS - Status of unlock operation (it can't really fail, though).

--*/

{
    PRX_CONTEXT RxContext = Context;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();


    RxDbgTrace(+1, Dbg, ("RxUnlockOperation -> RxContext/LowByte = %08lx/%08lx\n",
                        RxContext,LockInfo->StartingByte.LowPart));
    RxLog(("Unlck %x %x",RxContext,LockInfo->StartingByte.LowPart));
    RxWmiLog(LOG,
             RxUnlockOperation,
             LOGPTR(RxContext)
             LOGULONG(LockInfo->StartingByte.LowPart));

    //    If there is a NULL context, this means that this routine was called
    //    on behalf of a failed lock request, so we return immediately.
    //

    if ( Context != NULL ) {

        RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock; RxCaptureFileObject;
        PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

        ASSERT(capFileObject == LockInfo->FileObject);  //ok4->FileObj

        if (FlagOn(LowIoContext->Flags,LOWIO_CONTEXT_FLAG_SAVEUNLOCKS)
                && !FlagOn(capFcb->FcbState,FCB_STATE_LOCK_BUFFERING_ENABLED)) {
            PLOWIO_LOCK_LIST LockList,ThisElement;
            LockList = LowIoContext->ParamsFor.Locks.LockList;

            ThisElement = RxAllocatePoolWithTag(PagedPool,sizeof(LOWIO_LOCK_LIST),'LLxR');

            if (ThisElement==NULL) {
                RxDbgTrace(-1, Dbg, ("RxUnlockOperation FAILED ALLOCATION!\n"));
                return;
            }

            ThisElement->LockNumber = (LockList==NULL)?1:LockList->LockNumber+1;
            ThisElement->Next = LockList;
            ThisElement->ByteOffset = LockInfo->StartingByte.QuadPart;
            ThisElement->Length = LockInfo->Length.QuadPart;
            LowIoContext->ParamsFor.Locks.LockList = ThisElement;
        }

    }

    RxDbgTrace(-1, Dbg, ("RxUnlockOperation -> status=%08lx\n", Status));
    return;
}


//
//  Internal support routine
//


NTSTATUS
RxLowIoLockControlShellCompletion (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    This routine postprocesses a read request after it comes back from the
    minirdr.  It does callouts to handle compression, buffering and
    shadowing.  It is the opposite number of LowIoLockControlShell.

    This will be called from LowIo; for async, originally in the
    completion routine.  If RxStatus(MORE_PROCESSING_REQUIRED) is returned,
    LowIo will call again in a thread.  If this was syncIo, you'll be back
    in the user's thread; if async, lowIo will requeue to a thread.
    Currrently, we always get to a thread before anything; this is a bit slower
    than completing at DPC time,
    but it's aheckuva lot safer and we may often have stuff to do
    (like decompressing, shadowing, etc) that we don't want to do at DPC
    time.

Arguments:

    RxContext - the usual

Return Value:

    whatever value supplied by the caller or RxStatus(MORE_PROCESSING_REQUIRED).

--*/

{
    NTSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureParamBlock;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    BOOLEAN  SynchronousIo = !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);

    PAGED_CODE();

    Status = RxContext->StoredStatus;
    RxDbgTrace(+1, Dbg, ("RxLowIoLockControlShellCompletion  entry  Status = %08lx\n", Status));
    RxLog(("LkShlComp"));
    RxWmiLog(LOG,
             RxLowIoLockControlShellCompletion_1,
             LOGPTR(RxContext));

    switch (Status) {
    case STATUS_SUCCESS:
        break;
    case STATUS_FILE_LOCK_CONFLICT:
        break;
    case STATUS_CONNECTION_INVALID:
        //NOT YET IMPLEMENTED here is where the failover will happen
        //first we give the local guy current minirdr another chance...then we go
        //to fullscale retry
        //return(RxStatus(DISCONNECTED));   //special....let LowIo get us back
        break;
    }

    //for a unlock_multiple, get rid of the lock_list
    if (LowIoContext->Operation == LOWIO_OP_UNLOCK_MULTIPLE) {
        RxFinalizeLockList(RxContext);
    }

    if (FlagOn(LowIoContext->Flags,LOWIO_CONTEXT_FLAG_SYNCCALL)){
        //if we're being called from lowioubmit then just get out
        RxDbgTrace(-1, Dbg, ("RxLowIoLockControlShellCompletion  syncexit  Status = %08lx\n", Status));
        return(Status);
    }

    //
    // so we're doing an asynchronous completion. well, the only reason why we would be
    // trying a lock at the server would be if the lock manager already completed it
    // successfully! but if it didn't complete successfully at the server then we have
    // to remove it.

    if ((Status != STATUS_SUCCESS)
            && (RxContext->MajorFunction == IRP_MJ_LOCK_CONTROL)
            && (RxContext->MinorFunction == IRP_MN_LOCK)) {
        RxCaptureFileObject;     //new scope for capture macro
        NTSTATUS LocalStatus;

        LocalStatus = FsRtlFastUnlockSingle (
                    &capFcb->Specific.Fcb.FileLock,
                    capFileObject,
                    (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.ByteOffset,
                    (PLARGE_INTEGER)&LowIoContext->ParamsFor.Locks.Length,
                    IoGetRequestorProcess( capReqPacket ),
                    LowIoContext->ParamsFor.Locks.Key,
                    NULL,
                    TRUE
                    );
         RxLog(("RetractLck %lx %lx %lx",RxContext,Status,LocalStatus));
         RxWmiLog(LOG,
                  RxLowIoLockControlShellCompletion_2,
                  LOGPTR(RxContext)
                  LOGULONG(Status)
                  LOGULONG(LocalStatus));
    }

    //
    //otherwise we have to do the end of the lock from here

    InterlockedDecrement(&capFcb->OutstandingLockOperationsCount);
    RxReleaseFcbForThread( RxContext, capFcb, LowIoContext->ResourceThreadId );

    ASSERT(Status != STATUS_RETRY);
    if ( Status != STATUS_RETRY){
        ASSERT (RxContext->MajorFunction == IRP_MJ_LOCK_CONTROL);
    }

    RxDbgTrace(-1, Dbg, ("RxLowIoLockControlShellCompletion  exit  Status = %08lx\n", Status));
    return(Status);
}

VOID
RxFinalizeLockList(
    struct _RX_CONTEXT *RxContext
    )

/*++

Routine Description:

    This routine runs down a lock lis and frees each member

Arguments:

    RxContext - the usual

Return Value:

    n/a

--*/

{
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PLOWIO_LOCK_LIST LockList = LowIoContext->ParamsFor.Locks.LockList;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxFinalizeLockList  entry   rxcontext=%08lx\n", RxContext));
    //RxLog(("%s\n","skL"));
    RxWmiLog(LOG,
             RxFinalizeLockList,
             LOGPTR(RxContext));

    for(;;){
        PLOWIO_LOCK_LIST NextLockList;
        if (LockList==NULL) break;
        NextLockList = LockList->Next;
        RxFreePool(LockList);
        LockList = NextLockList;
    }

    RxDbgTrace(-1, Dbg, ("RxFinalizeLockList  exit  \n"));
    return;
}


#define RxSdwWrite(RXCONTEXT)  STATUS_MORE_PROCESSING_REQUIRED
NTSTATUS
RxLowIoLockControlShell (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    This routine preprocesses a read request before it goes down to the minirdr.
    It does callouts to handle compression, buffering and shadowing. It is the
    opposite number of LowIoLockControlShellCompletion. By the time we get here,
    we are going to the wire. Lock buffering is handled in the
    lockcompletionroutine (not lowio)

Arguments:

    RxContext - the usual

Return Value:

    whatever value is returned by a callout....or by LowIo.

--*/

{
    NTSTATUS Status;
    RxCaptureFcb; RxCaptureParamBlock;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxLowIoLockControlShell  entry             %08lx\n", 0));
    RxLog(("%s\n","skL"));
    RxWmiLog(LOG,
             RxLowIoLockControlShell,
             LOGPTR(RxContext));

    Status = RxLowIoSubmit(RxContext,RxLowIoLockControlShellCompletion);

    RxDbgTrace(-1, Dbg, ("RxLowIoLockControlShell  exit  Status = %08lx\n", Status));
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\fsctrl.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FsCtrl.c

Abstract:

    This module implements the File System Control routines for Rdbss.
    Fsctls on the device fcb are handled in another module.

Author:

   Joe Linn [JoeLinn] 7-mar-95

Revision History:

   Balan Sethu Raman 18-May-95 -- Integrated with mini rdrs

--*/

#include "precomp.h"
#pragma hdrstop
#include <dfsfsctl.h>
#include "fsctlbuf.h"

//  The local debug trace level

#define Dbg                              (DEBUG_TRACE_FSCTRL)

//  Local procedure prototypes

NTSTATUS
RxUserFsCtrl ( RXCOMMON_SIGNATURE );

NTSTATUS
TranslateSisFsctlName (
    IN PWCHAR InputName,
    OUT PUNICODE_STRING RelativeName,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN PUNICODE_STRING NetRootName
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonFileSystemControl)
#pragma alloc_text(PAGE, RxUserFsCtrl)
#pragma alloc_text(PAGE, RxLowIoFsCtlShell)
#pragma alloc_text(PAGE, RxLowIoFsCtlShellCompletion)
#pragma alloc_text(PAGE, TranslateSisFsctlName)
#endif

NTSTATUS
RxCommonFileSystemControl ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This is the common routine for doing FileSystem control operations called
    by both the fsd and fsp threads. What happens is that we pick off fsctls that
    we know about and remote the rest....remoting means sending them thru the
    lowio stuff which may/will pick off a few more. the ones that we pick off here
    (and currently return STATUS_NOT_IMPLEMENTED) and the ones for being an oplock
    provider and for doing volume mounts....we don't even have volume fcbs
    yet since this is primarily a localFS concept.
    nevertheless, these are not passed thru to the mini.

Arguments:


Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    RxCaptureRequestPacket;
    RxCaptureParamBlock;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureFileObject;

    NTSTATUS       Status;
    NODE_TYPE_CODE TypeOfOpen;
    BOOLEAN        TryLowIo = TRUE;
    ULONG FsControlCode = capPARAMS->Parameters.FileSystemControl.FsControlCode;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonFileSystemControl %08lx\n", RxContext));
    RxDbgTrace( 0, Dbg, ("Irp           = %08lx\n", capReqPacket));
    RxDbgTrace( 0, Dbg, ("MinorFunction = %08lx\n", capPARAMS->MinorFunction));
    RxDbgTrace( 0, Dbg, ("FsControlCode = %08lx\n", FsControlCode));

    RxLog(("FsCtl %x %x %x %x",RxContext,capReqPacket,capPARAMS->MinorFunction,FsControlCode));
    RxWmiLog(LOG,
             RxCommonFileSystemControl,
             LOGPTR(RxContext)
             LOGPTR(capReqPacket)
             LOGUCHAR(capPARAMS->MinorFunction)
             LOGULONG(FsControlCode));

    ASSERT(capPARAMS->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL);

    // Validate the buffers passed in for the FSCTL
    if ((capReqPacket->RequestorMode == UserMode) &&
        (!FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_IN_FSP))) {
        try {
            switch (FsControlCode & 3) {
            case METHOD_NEITHER:
                {
                    PVOID pInputBuffer,pOutputBuffer;
                    ULONG InputBufferLength,OutputBufferLength;

                    Status = STATUS_SUCCESS;

                    pInputBuffer  = METHODNEITHER_OriginalInputBuffer(capPARAMS);
                    pOutputBuffer = METHODNEITHER_OriginalOutputBuffer(capReqPacket);

                    InputBufferLength = capPARAMS->Parameters.FileSystemControl.InputBufferLength;
                    OutputBufferLength = capPARAMS->Parameters.FileSystemControl.OutputBufferLength;

                    if (pInputBuffer != NULL) {
                        ProbeForRead(
                            pInputBuffer,
                            InputBufferLength,
                            1);

                        ProbeForWrite(
                            pInputBuffer,
                            InputBufferLength,
                            1);
                    } else if (InputBufferLength != 0) {
                        Status = STATUS_INVALID_USER_BUFFER;
                    }

                    if (Status == STATUS_SUCCESS) {
                        if (pOutputBuffer != NULL) {
                            ProbeForRead(
                                pOutputBuffer,
                                OutputBufferLength,
                                1);

                            ProbeForWrite(
                                pOutputBuffer,
                                OutputBufferLength,
                                1);
                        } else if (OutputBufferLength != 0) {
                            Status = STATUS_INVALID_USER_BUFFER;
                        }
                    }
                }
                break;

            case METHOD_BUFFERED:
            case METHOD_IN_DIRECT:
            case METHOD_OUT_DIRECT:
                {
                    Status = STATUS_SUCCESS;
                }
                break;
            }
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            Status = STATUS_INVALID_USER_BUFFER;
        }

        if (Status != STATUS_SUCCESS) {
            return Status;
        }
    }

    switch (capPARAMS->MinorFunction) {
    case IRP_MN_USER_FS_REQUEST:
    case IRP_MN_TRACK_LINK:
        {

            RxDbgTrace( 0, Dbg, ("FsControlCode = %08lx\n", FsControlCode));
            switch (FsControlCode) {
            case FSCTL_REQUEST_OPLOCK_LEVEL_1:
            case FSCTL_REQUEST_OPLOCK_LEVEL_2:
            case FSCTL_REQUEST_BATCH_OPLOCK:
            case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
            case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
            case FSCTL_OPLOCK_BREAK_NOTIFY:
            case FSCTL_OPLOCK_BREAK_ACK_NO_2:
                {
                    // fsrtl oplock package is handled in common for all minirdrs

                    //Status = RxOplockRequest( RXCOMMON_ARGUMENTS, &PostToFsp );
                    Status = STATUS_NOT_IMPLEMENTED;
                    TryLowIo = FALSE;
                }
                break;

            case FSCTL_LOCK_VOLUME:
            case FSCTL_UNLOCK_VOLUME:
            case FSCTL_DISMOUNT_VOLUME:
            case FSCTL_MARK_VOLUME_DIRTY:
            case FSCTL_IS_VOLUME_MOUNTED:
                {
                    //  Decode the file object, the only type of opens we accept are
                    //  user volume opens.
                    TypeOfOpen    = NodeType(capFcb);

                    if (TypeOfOpen != RDBSS_NTC_VOLUME_FCB) {
                        Status = STATUS_INVALID_PARAMETER;
                    } else {
                        Status = STATUS_NOT_IMPLEMENTED;
                    }
                    TryLowIo = FALSE;
                }
                break;

            case FSCTL_DFS_GET_REFERRALS:
            case FSCTL_DFS_REPORT_INCONSISTENCY:
                {
                    if (!BooleanFlagOn(capFcb->pNetRoot->pSrvCall->Flags,SRVCALL_FLAG_DFS_AWARE_SERVER)) {
                        TryLowIo = FALSE;
                        Status = STATUS_DFS_UNAVAILABLE;
                    }
                }
                break;

            case FSCTL_LMR_GET_LINK_TRACKING_INFORMATION:
                {
                    // Validate the parameters and reject illformed requests

                    ULONG                      OutputBufferLength;
                    PLINK_TRACKING_INFORMATION pLinkTrackingInformation;

                    OutputBufferLength = capPARAMS->Parameters.FileSystemControl.OutputBufferLength;
                    pLinkTrackingInformation = capReqPacket->AssociatedIrp.SystemBuffer;

                    TryLowIo = FALSE;

                    if ((OutputBufferLength < sizeof(LINK_TRACKING_INFORMATION)) ||
                        (pLinkTrackingInformation == NULL) ||
                        (capFcb->pNetRoot->Type != NET_ROOT_DISK)) {
                        Status = STATUS_INVALID_PARAMETER;
                    } else {
                        BYTE Buffer[
                                sizeof(FILE_FS_OBJECTID_INFORMATION)];

                        PFILE_FS_OBJECTID_INFORMATION pVolumeInformation;

                        pVolumeInformation = (PFILE_FS_OBJECTID_INFORMATION)Buffer;
                        RxContext->Info.FsInformationClass = FileFsObjectIdInformation;
                        RxContext->Info.Buffer = pVolumeInformation;
                        RxContext->Info.LengthRemaining = sizeof(Buffer);

                        MINIRDR_CALL(
                            Status,
                            RxContext,
                            capFcb->MRxDispatch,
                            MRxQueryVolumeInfo,
                            (RxContext));

                        if ((Status == STATUS_SUCCESS) ||
                            (Status == STATUS_BUFFER_OVERFLOW)) {
                            // Copy the volume Id onto the net root.
                            RtlCopyMemory(
                                &capFcb->pNetRoot->DiskParameters.VolumeId,
                                pVolumeInformation->ObjectId,
                                sizeof(GUID));

                            RtlCopyMemory(
                                pLinkTrackingInformation->VolumeId,
                                &capFcb->pNetRoot->DiskParameters.VolumeId,
                                sizeof(GUID));

                            if (FlagOn(capFcb->pNetRoot->Flags,NETROOT_FLAG_DFS_AWARE_NETROOT)) {
                                pLinkTrackingInformation->Type = DfsLinkTrackingInformation;
                            } else {
                                pLinkTrackingInformation->Type = NtfsLinkTrackingInformation;
                            }

                            capReqPacket->IoStatus.Information = sizeof(LINK_TRACKING_INFORMATION);
                            Status   = STATUS_SUCCESS;
                        }
                    }

                    capReqPacket->IoStatus.Status = Status;
                }
                break;

            case FSCTL_SET_ZERO_DATA:
                {
                    PFILE_ZERO_DATA_INFORMATION ZeroRange;

                    Status = STATUS_SUCCESS;

                    // Verify if the request is well formed...
                    // a. check if the input buffer length is OK
                    if (capPARAMS->Parameters.FileSystemControl.InputBufferLength <
                        sizeof( FILE_ZERO_DATA_INFORMATION )) {

                        Status = STATUS_INVALID_PARAMETER;
                    } else {
                        //
                        // b: ensure the ZeroRange request is properly formed.
                        //

                        ZeroRange = (PFILE_ZERO_DATA_INFORMATION)capReqPacket->AssociatedIrp.SystemBuffer;

                        if ((ZeroRange->FileOffset.QuadPart < 0) ||
                            (ZeroRange->BeyondFinalZero.QuadPart < 0) ||
                            (ZeroRange->FileOffset.QuadPart > ZeroRange->BeyondFinalZero.QuadPart)) {

                            Status = STATUS_INVALID_PARAMETER;
                        }
                    }

                    if (Status == STATUS_SUCCESS) {
                        // Before the request can be processed ensure that there
                        // are no user mapped sections

                        if (!MmCanFileBeTruncated(
                                &capFcb->NonPaged->SectionObjectPointers,
                                NULL)) {

                            Status = STATUS_USER_MAPPED_FILE;
                        }
                    }

                    TryLowIo = (Status == STATUS_SUCCESS);
                }
                break;

            case FSCTL_SET_COMPRESSION:
            case FSCTL_SET_SPARSE:
                {
                    // Ensure that the close is not delayed is for these FCB's
                    Status = RxAcquireExclusiveFcb( RxContext, capFcb );

                    if ((Status == STATUS_LOCK_NOT_GRANTED) &&
                        (!BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT))) {

                        RxDbgTrace(0, Dbg, ("Cannot acquire Fcb\n", 0));

                        RxContext->PostRequest = TRUE;
                    }

                    if (Status != STATUS_SUCCESS) {
                        TryLowIo = FALSE;
                    } else {
                        ClearFlag(capFcb->FcbState,FCB_STATE_COLLAPSING_ENABLED);

                        if (FsControlCode == FSCTL_SET_SPARSE) {
                            if (NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE) {
                                capFcb->Attributes |= FILE_ATTRIBUTE_SPARSE_FILE;

                                capFobx->pSrvOpen->BufferingFlags = 0;

                                RxChangeBufferingState(
                                    (PSRV_OPEN)capFobx->pSrvOpen,
                                    NULL,
                                    FALSE);
                            } else {
                                Status = STATUS_NOT_SUPPORTED;
                            }
                        }

                        RxReleaseFcb(RxContext,capFcb);
                    }
                }
                break;

            case FSCTL_SIS_COPYFILE:
                {
                    //
                    // This is the single-instance store copy FSCTL. The input
                    // paths are fully qualified NT paths and must be made
                    // relative to the share (which must be the same for both
                    // names).
                    //

                    PSI_COPYFILE copyFile = capReqPacket->AssociatedIrp.SystemBuffer;
                    ULONG bufferLength = capPARAMS->Parameters.FileSystemControl.InputBufferLength;
                    PWCHAR source;
                    PWCHAR dest;
                    UNICODE_STRING sourceString;
                    UNICODE_STRING destString;

                    memset(&sourceString, 0, sizeof(sourceString));
                    memset(&destString, 0, sizeof(destString));
                    
                    // Validate the buffer passed in
                    if ((copyFile == NULL) ||
                        (bufferLength < sizeof(SI_COPYFILE))) {
                        Status = STATUS_INVALID_PARAMETER;
                        TryLowIo = FALSE;
                        break;
                    }


                    //
                    // Get pointers to the two names.
                    //

                    source = copyFile->FileNameBuffer;
                    dest = source + (copyFile->SourceFileNameLength / sizeof(WCHAR));

                    //
                    // Verify that the inputs are reasonable.
                    //

                    if ( (copyFile->SourceFileNameLength > bufferLength) ||
                         (copyFile->DestinationFileNameLength > bufferLength) ||
                         (copyFile->SourceFileNameLength < sizeof(WCHAR)) ||
                         (copyFile->DestinationFileNameLength < sizeof(WCHAR)) ||
                         ((FIELD_OFFSET(SI_COPYFILE,FileNameBuffer) +
                           copyFile->SourceFileNameLength +
                           copyFile->DestinationFileNameLength) > bufferLength) ||
                         (*(source + (copyFile->SourceFileNameLength/sizeof(WCHAR)-1)) != 0) ||
                         (*(dest + (copyFile->DestinationFileNameLength/sizeof(WCHAR)-1)) != 0) ) {
                        Status = STATUS_INVALID_PARAMETER;
                        TryLowIo = FALSE;
                        break;
                    }

                    //
                    // Perform symbolic link translation on the source and destination names,
                    // and ensure that they translate to redirector names.
                    //

                    Status = TranslateSisFsctlName(
                                 source,
                                 &sourceString,
                                 capFcb->RxDeviceObject,
                                 &((PNET_ROOT)capFcb->pNetRoot)->PrefixEntry.Prefix );
                    if ( !NT_SUCCESS(Status) ) {
                        TryLowIo = FALSE;
                        break;
                    }

                    Status = TranslateSisFsctlName(
                                 dest,
                                 &destString,
                                 capFcb->RxDeviceObject,
                                 &((PNET_ROOT)capFcb->pNetRoot)->PrefixEntry.Prefix );
                    if ( !NT_SUCCESS(Status) ) {
                        RtlFreeUnicodeString( &sourceString );
                        TryLowIo = FALSE;
                        break;
                    }

                    //
                    // Convert the paths in the input buffer into share-relative
                    // paths.
                    //

                    if ( (ULONG)(sourceString.MaximumLength + destString.MaximumLength) >
                         (copyFile->SourceFileNameLength + copyFile->DestinationFileNameLength) ) {
                        PSI_COPYFILE newCopyFile;
                        ULONG length = FIELD_OFFSET(SI_COPYFILE,FileNameBuffer) +
                                            sourceString.MaximumLength + destString.MaximumLength;
                        ASSERT( length > capPARAMS->Parameters.FileSystemControl.InputBufferLength );
                        newCopyFile = RxAllocatePoolWithTag(
                                        NonPagedPool,
                                        length,
                                        RX_MISC_POOLTAG);
                        if (newCopyFile == NULL) {
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                            TryLowIo = FALSE;
                            break;
                        }
                        newCopyFile->Flags = copyFile->Flags;
                        ExFreePool( copyFile );
                        copyFile = newCopyFile;
                        capReqPacket->AssociatedIrp.SystemBuffer = copyFile;
                        capPARAMS->Parameters.FileSystemControl.InputBufferLength = length;
                    }

                    copyFile->SourceFileNameLength = sourceString.MaximumLength;
                    copyFile->DestinationFileNameLength = destString.MaximumLength;
                    source = copyFile->FileNameBuffer;
                    dest = source + (copyFile->SourceFileNameLength / sizeof(WCHAR));
                    RtlCopyMemory( source, sourceString.Buffer, copyFile->SourceFileNameLength );
                    RtlCopyMemory( dest, destString.Buffer, copyFile->DestinationFileNameLength );

                    RtlFreeUnicodeString( &sourceString );
                    RtlFreeUnicodeString( &destString );
                }
                break;

            default:
                break;
            }
        }
        break;

    default:
        break;
    }

    if (TryLowIo) {
        Status = RxLowIoFsCtlShell(RxContext);
    }

    if (RxContext->PostRequest) {
        Status = RxFsdPostRequest(RxContext);
    } else {
        if (Status == STATUS_PENDING) {
            RxDereferenceAndDeleteRxContext(RxContext);
        }
    }

    RxDbgTrace(-1, Dbg, ("RxCommonFileSystemControl -> %08lx\n", Status));

    return Status;
}

ULONG RxEnablePeekBackoff = 1;

NTSTATUS
RxLowIoFsCtlShell( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This is the common routine for implementing the user's requests made
    through NtFsControlFile.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    RxCaptureFcb;
    RxCaptureRequestPacket;
    RxCaptureParamBlock;
    RxCaptureFobx;
    RxCaptureFileObject;

    NTSTATUS       Status        = STATUS_SUCCESS;
    BOOLEAN        PostToFsp     = FALSE;

    NODE_TYPE_CODE TypeOfOpen    = NodeType(capFcb);
    PLOWIO_CONTEXT pLowIoContext  = &RxContext->LowIoContext;
    ULONG          FsControlCode = capPARAMS->Parameters.FileSystemControl.FsControlCode;
    BOOLEAN        SubmitLowIoRequest = TRUE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxLowIoFsCtlShell...\n", 0));
    RxDbgTrace( 0, Dbg, ("FsControlCode = %08lx\n", FsControlCode));

    RxInitializeLowIoContext(pLowIoContext,LOWIO_OP_FSCTL);

    switch (capPARAMS->MinorFunction) {
    case IRP_MN_USER_FS_REQUEST:
        {
            //  The RDBSS filters out those FsCtls that can be handled without the intervention
            //  of the mini rdr's. Currently all FsCtls are forwarded down to the mini rdr.
            switch (FsControlCode) {
            case FSCTL_PIPE_PEEK:
            {
                if ((capReqPacket->AssociatedIrp.SystemBuffer != NULL) &&
                    (capPARAMS->Parameters.FileSystemControl.OutputBufferLength >=
                     (ULONG)FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER, Data[0]))) {

                    PFILE_PIPE_PEEK_BUFFER pPeekBuffer;

                    pPeekBuffer = (PFILE_PIPE_PEEK_BUFFER)capReqPacket->AssociatedIrp.SystemBuffer;

                    RtlZeroMemory(
                        pPeekBuffer,
                        capPARAMS->Parameters.FileSystemControl.OutputBufferLength);

                    if (RxShouldRequestBeThrottled(&capFobx->Specific.NamedPipe.ThrottlingState) &&
                        RxEnablePeekBackoff) {

                        SubmitLowIoRequest = FALSE;

                        RxDbgTrace(
                            0, (DEBUG_TRACE_ALWAYS),
                            ("RxLowIoFsCtlShell: Throttling Peek Request\n"));

                        capReqPacket->IoStatus.Information = FIELD_OFFSET(FILE_PIPE_PEEK_BUFFER,Data);
                        pPeekBuffer->ReadDataAvailable = 0;
                        pPeekBuffer->NamedPipeState    = FILE_PIPE_CONNECTED_STATE;
                        pPeekBuffer->NumberOfMessages  = MAXULONG;
                        pPeekBuffer->MessageLength     = 0;

                        RxContext->StoredStatus = STATUS_SUCCESS;

                        Status = RxContext->StoredStatus;
                    } else {
                        RxDbgTrace(
                            0, (DEBUG_TRACE_ALWAYS),
                            ("RxLowIoFsCtlShell: Throttling queries %ld\n",
                             capFobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries));

                        RxLog(
                            ("ThrottlQs %lx %lx %lx %ld\n",
                             RxContext,capFobx,&capFobx->Specific.NamedPipe.ThrottlingState,
                             capFobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries));
                        RxWmiLog(LOG,
                                 RxLowIoFsCtlShell,
                                 LOGPTR(RxContext)
                                 LOGPTR(capFobx)
                                 LOGULONG(capFobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries));
                    }
                } else {
                    RxContext->StoredStatus = STATUS_INVALID_PARAMETER;
                }
            }
            break;

            default:
                break;
            }
        }
        break;

    default:
        break;
    }

    if (SubmitLowIoRequest) {
        Status = RxLowIoSubmit(RxContext,RxLowIoFsCtlShellCompletion);
    }

    RxDbgTrace(-1, Dbg, ("RxLowIoFsCtlShell -> %08lx\n", Status ));
    return Status;
}

NTSTATUS
RxLowIoFsCtlShellCompletion( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This is the completion routine for FSCTL requests passed down to the mini rdr

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;

    NTSTATUS       Status;
    PLOWIO_CONTEXT pLowIoContext  = &RxContext->LowIoContext;
    ULONG          FsControlCode = pLowIoContext->ParamsFor.FsCtl.FsControlCode;

    PAGED_CODE();

    Status = RxContext->StoredStatus;
    RxDbgTrace(+1, Dbg, ("RxLowIoFsCtlShellCompletion  entry  Status = %08lx\n", Status));

    switch (FsControlCode) {
    case FSCTL_PIPE_PEEK:
       {
          if ((Status == STATUS_SUCCESS) ||
              (Status == STATUS_BUFFER_OVERFLOW)) {
             // In the case of Peek operations a throttle mechanism is in place to
             // prevent the network from being flodded with requests which return 0
             // bytes.

             PFILE_PIPE_PEEK_BUFFER pPeekBuffer;

             pPeekBuffer = (PFILE_PIPE_PEEK_BUFFER)pLowIoContext->ParamsFor.FsCtl.pOutputBuffer;

             if (pPeekBuffer->ReadDataAvailable == 0) {

                 // The peek request returned zero bytes.

                 RxDbgTrace(0, (DEBUG_TRACE_ALWAYS), ("RxLowIoFsCtlShellCompletion: Enabling Throttling for Peek Request\n"));
                 RxInitiateOrContinueThrottling(&capFobx->Specific.NamedPipe.ThrottlingState);
                 RxLog(("ThrottlYes %lx %lx %lx %ld\n",
                                   RxContext,capFobx,&capFobx->Specific.NamedPipe.ThrottlingState,
                                   capFobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries));
                 RxWmiLog(LOG,
                          RxLowIoFsCtlShellCompletion_1,
                          LOGPTR(RxContext)
                          LOGPTR(capFobx)
                          LOGULONG(capFobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries));
             } else {

                 RxDbgTrace(0, (DEBUG_TRACE_ALWAYS), ("RxLowIoFsCtlShellCompletion: Disabling Throttling for Peek Request\n"));
                 RxTerminateThrottling(&capFobx->Specific.NamedPipe.ThrottlingState);
                 RxLog(("ThrottlNo %lx %lx %lx %ld\n",
                                   RxContext,capFobx,&capFobx->Specific.NamedPipe.ThrottlingState,
                                   capFobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries));
                 RxWmiLog(LOG,
                          RxLowIoFsCtlShellCompletion_2,
                          LOGPTR(RxContext)
                          LOGPTR(capFobx)
                          LOGULONG(capFobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries));
             }

             capReqPacket->IoStatus.Information = RxContext->InformationToReturn;
          }
       }
       break;
    default:
       if ((Status == STATUS_BUFFER_OVERFLOW) ||
           (Status == STATUS_SUCCESS)) {
          capReqPacket->IoStatus.Information = RxContext->InformationToReturn;
       }
       break;
    }

    capReqPacket->IoStatus.Status = Status;

    RxDbgTrace(-1, Dbg, ("RxLowIoFsCtlShellCompletion  exit  Status = %08lx\n", Status));
    return Status;
}

NTSTATUS
TranslateSisFsctlName(
    IN PWCHAR InputName,
    OUT PUNICODE_STRING RelativeName,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN PUNICODE_STRING NetRootName
    )

/*++

Routine Description:

    This routine converts a fully qualified name into a share-relative name.
    It is used to munge the input buffer of the SIS_COPYFILE FSCTL, which
    takes two fully qualified NT paths as inputs.

    The routine operates by translating the input path as necessary to get
    to an actual device name, verifying that the target device is the
    redirector, and verifying that the target server/share is the one on
    which the I/O was issued.

Arguments:

Return Value:

--*/

{
    NTSTATUS status;
    UNICODE_STRING currentString;
    UNICODE_STRING testString;
    PWCHAR p;
    PWCHAR q;
    HANDLE handle;
    OBJECT_ATTRIBUTES objectAttributes;
    PWCHAR translationBuffer = NULL;
    ULONG translationLength;
    ULONG remainingLength;
    ULONG resultLength;

    RtlInitUnicodeString( &currentString, InputName );

    p = currentString.Buffer;

    if (!p)
    {
        return STATUS_INVALID_PARAMETER;
    }

    if ( (*p == L'\\') && (*(p+1) == L'\\') ) {

        //
        // Special case for name that starts with \\ (i.e., a UNC name):
        // assume that the \\ would translate to the redirector's name and
        // skip the translation phase.
        //

        p++;

    } else {

        //
        // The outer loop is executed each time a translation occurs.
        //

        while ( TRUE ) {

            //
            // Walk through any directory objects at the beginning of the string.
            //

            if ( *p != L'\\' ) {
                status =  STATUS_OBJECT_NAME_INVALID;
                goto error_exit;
            }
            p++;

            //
            // The inner loop is executed while walking the directory tree.
            //

            while ( TRUE ) {

                q = wcschr( p, L'\\' );

                if ( q == NULL ) {
                    testString.Length = currentString.Length;
                } else {
                    testString.Length = (USHORT)(q - currentString.Buffer) * sizeof(WCHAR);
                }
                testString.Buffer = currentString.Buffer;
                remainingLength = currentString.Length - testString.Length + sizeof(WCHAR);

                InitializeObjectAttributes(
                    &objectAttributes,
                    &testString,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL
                    );

                status = ZwOpenDirectoryObject( &handle, DIRECTORY_TRAVERSE, &objectAttributes );

                //
                // If we were unable to open the object as a directory, then break out
                // of the inner loop and try to open it as a symbolic link.
                //

                if ( !NT_SUCCESS(status) ) {
                    if ( status != STATUS_OBJECT_TYPE_MISMATCH ) {
                        goto error_exit;
                    }
                    break;
                }

                //
                // We opened the directory. Close it and try the next element of the path.
                //

                ZwClose( handle );

                if ( q == NULL ) {

                    //
                    // The last element of the name is an object directory. Clearly, this
                    // is not a redirector path.
                    //

                    status = STATUS_OBJECT_TYPE_MISMATCH;
                    goto error_exit;
                }

                p = q + 1;
            }

            //
            // Try to open the current name as a symbolic link.
            //

            status = ZwOpenSymbolicLinkObject( &handle, SYMBOLIC_LINK_QUERY, &objectAttributes );

            //
            // If we were unable to open the object as a symbolic link, then break out of
            // the outer loop and verify that this is a redirector name.
            //

            if ( !NT_SUCCESS(status) ) {
                if ( status != STATUS_OBJECT_TYPE_MISMATCH ) {
                    goto error_exit;
                }
                break;
            }

            //
            // The object is a symbolic link. Translate it.
            //

            testString.MaximumLength = 0;
            status = ZwQuerySymbolicLinkObject( handle, &testString, &translationLength );
            if ( !NT_SUCCESS(status) && (status != STATUS_BUFFER_TOO_SMALL) ) {
                ZwClose( handle );
                goto error_exit;
            }

            resultLength = translationLength + remainingLength;
            p = RxAllocatePoolWithTag( PagedPool|POOL_COLD_ALLOCATION, resultLength, RX_MISC_POOLTAG );
            if ( p == NULL ) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                ZwClose( handle );
                goto error_exit;
            }

            testString.MaximumLength = (USHORT)translationLength;
            testString.Buffer = p;
            status = ZwQuerySymbolicLinkObject( handle, &testString, NULL );
            ZwClose( handle );
            if ( !NT_SUCCESS(status) ) {
                RxFreePool( p );
                goto error_exit;
            }
            if ( testString.Length > translationLength ) {
                status = STATUS_OBJECT_NAME_INVALID;
                RxFreePool( p );
                goto error_exit;
            }

            RtlCopyMemory( (PCHAR)p + testString.Length, q, remainingLength );
            currentString.Buffer = p;
            currentString.Length = (USHORT)(resultLength - sizeof(WCHAR));
            currentString.MaximumLength = (USHORT)resultLength;

            if ( translationBuffer != NULL ) {
                RxFreePool( translationBuffer );
            }
            translationBuffer = p;
        }

        //
        // We have a result name. Verify that it is a redirector name.
        //

        if ( !RtlPrefixUnicodeString( &RxDeviceObject->DeviceName, &currentString, TRUE ) ) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto error_exit;
        }

        //
        // Skip over the redirector device name.
        //

        p = currentString.Buffer + (RxDeviceObject->DeviceName.Length / sizeof(WCHAR));
        if ( *p != L'\\' ) {
            status = STATUS_OBJECT_NAME_INVALID;
            goto error_exit;
        }

        //
        // Skip over the drive letter, if present.
        //

        if ( *(p + 1) == L';' ) {
            p = wcschr( ++p, L'\\' );
            if ( p == NULL ) {
                status = STATUS_OBJECT_NAME_INVALID;
                goto error_exit;
            }
        }
    }

    //
    // Verify that the next part of the string is the correct net root name.
    //

    currentString.Length -= (USHORT)(p - currentString.Buffer) * sizeof(WCHAR);
    currentString.Buffer = p;

    if ( !RtlPrefixUnicodeString( NetRootName, &currentString, TRUE ) ) {
        status = STATUS_OBJECT_NAME_INVALID;
        goto error_exit;
    }
    p += NetRootName->Length / sizeof(WCHAR);
    if ( *p != L'\\' ) {
        status = STATUS_OBJECT_NAME_INVALID;
        goto error_exit;
    }
    p++;
    if ( *p == 0 ) {
        status = STATUS_OBJECT_NAME_INVALID;
        goto error_exit;
    }

    //
    // Copy the rest of the string after the redirector name to a new buffer.
    //

    RtlCreateUnicodeString( RelativeName, p );

    status = STATUS_SUCCESS;

error_exit:

    if ( translationBuffer != NULL ) {
        RxFreePool( translationBuffer );
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\flush.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Flush.c

Abstract:

    This module implements the File Flush buffers routine for Rx called by the
    dispatch driver.

    In a future version of the wrapper, it may be that flush will be routed thru lowio.

Author:

    Joe Linn     [JoeLinn]    15-dec-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FLUSH)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonFlushBuffers)
#endif



NTSTATUS
RxCommonFlushBuffers ( RXCOMMON_SIGNATURE )

/*++

Routine Description:

    This is the common routine for flushing file buffers.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock; RxCaptureFileObject;
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;


    BOOLEAN FcbAcquired = FALSE;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonFlush...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, capFobx, capFcb));
    RxLog(("%s %lx %lx %lx\n","slF",RxContext,capFcb,capFobx));
    RxWmiLog(LOG,
             RxCommonFlushBuffers,
             LOGPTR(RxContext)
             LOGPTR(capFcb)
             LOGPTR(capFobx));

    //
    //  CcFlushCache is always synchronous, so if we can't wait enqueue
    //  the irp to the Fsp.

    if ( !FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT) ) {

        Status = RxFsdPostRequest( RxContext );

        RxDbgTrace(-1, Dbg, ("RxCommonFlushBuffers -> %08lx\n", Status ));
        return Status;
    }

    Status = STATUS_SUCCESS;

    try {

        //
        //  Case on the type of open that we are trying to flush
        //

        switch (TypeOfOpen) {

        case RDBSS_NTC_STORAGE_TYPE_FILE:

            RxDbgTrace(0, Dbg, ("Flush User File Open\n", 0));

            Status = RxAcquireExclusiveFcb( RxContext, capFcb );

            if (Status != STATUS_SUCCESS) break;

            FcbAcquired = TRUE;

            //
            //  If the file is cached then flush its cache
            //

            Status = RxFlushFcbInSystemCache(capFcb, TRUE);

            if (!NT_SUCCESS( Status )) break;

            //rdrs don't do this.....only local FSs
            ////
            ////  Check if we should be changing the time or file size
            //
            //RxAdjustFileTimesAndSize(RXCOMMON_ARGUMENTS);

            // if we make this lowio.........
            ////
            ////  Initialize LowIO_CONTEXT block in the RxContext and Calldown
            //
            //RxInitializeLowIoContext(LowIoContext,LOWIO_OP_FLUSH);
            //
            //Status = RxLowIoFlushShell(RxContext);

            MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxFlush,(RxContext));
            break;

        case RDBSS_NTC_SPOOLFILE:

            RxDbgTrace(0, Dbg, ("Flush Sppol File\n", 0));

            Status = RxAcquireExclusiveFcb( RxContext, capFcb );

            if (Status != STATUS_SUCCESS) break;

            FcbAcquired = TRUE;

            // should this be low io???
            ////
            ////  Initialize LowIO_CONTEXT block in the RxContext and Calldown
            //
            //RxInitializeLowIoContext(LowIoContext,LOWIO_OP_FLUSH);
            //
            //Status = RxLowIoFlushShell(RxContext);

            MINIRDR_CALL(Status,RxContext,capFcb->MRxDispatch,MRxFlush,(RxContext));
            break;

        default:

            Status = STATUS_INVALID_DEVICE_REQUEST;
        }


    } finally {

        DebugUnwind( RxCommonFlushBuffers );

        if (FcbAcquired) { RxReleaseFcb( RxContext, capFcb ); }

        //
        //  If this is a normal termination then pass the request on
        //  to the target device object.
        //

        if (!AbnormalTermination()) {

            NOTHING;

        }

    }

    RxDbgTrace(-1, Dbg, ("RxCommonFlushBuffers -> %08lx\n", Status));
    return Status;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\minirdr.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    minirdr.c

Abstract:

    This module implements minirdr registration functions.

Author:

    Joe Linn (JoeLinn)    2-2-95

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxRegisterMinirdr)
#pragma alloc_text(PAGE, RxMakeLateDeviceAvailable)
#pragma alloc_text(PAGE, RxpUnregisterMinirdr)
#endif

//
// The debug trace level
//

#define Dbg                              (0)

#ifdef ALLOC_PRAGMA
#endif

// #define BBT_UPDATE 1

#ifdef BBT_UPDATE
extern VOID RxUpdate(PVOID pContext);

HANDLE   RxHandle  = INVALID_HANDLE_VALUE;
PETHREAD RxPointer = NULL;
#endif 


NTSTATUS
NTAPI
RxRegisterMinirdr(
    OUT PRDBSS_DEVICE_OBJECT *DeviceObject,
    IN OUT PDRIVER_OBJECT     DriverObject,    // the minirdr driver object
    IN  PMINIRDR_DISPATCH     MrdrDispatch,    // the mini rdr dispatch vector
    IN  ULONG                 Controls,
    IN  PUNICODE_STRING       DeviceName,
    IN  ULONG                 DeviceExtensionSize,
    IN  DEVICE_TYPE           DeviceType,
    IN  ULONG                 DeviceCharacteristics
    )
/*++

Routine Description:

    The routine adds the registration information to the minirdr registration table. As well, it builds
    a device object; the MUP registration is at start time. Also, we fill in the deviceobject so that we are catching
    all the calls.

Arguments:

    DeviceObject   - where the created device object is to be stored
    ProtocolMarker - a 4byte marker denoting the FileLevel Protocol
                             ('LCL ', 'SMB ', 'NCP ', and 'NFS ') are used
    MrdrDispatch   - the dispatch table for finding the server/netroot discovery routines
    Context        - whatever PVOID the underlying guy wants
    MupAction      - whether/how the MUP registration is done
    DeviceName,DeviceExtensionSize,DeviceType,DeviceCharacteristics
                   - the params for the device object that is to be built these are adjusted a bit
                     bfore they're passed to Io

Return Value:

    --

--*/
{
    NTSTATUS Status;
    PRDBSS_DEVICE_OBJECT RxDeviceObject;

    PAGED_CODE();

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), (" RxRegisterMinirdr  Name = %wZ", DeviceName));

    if (DeviceObject==NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    // Create the device object.
    Status = IoCreateDevice(DriverObject,
                            sizeof(RDBSS_DEVICE_OBJECT) - sizeof(DEVICE_OBJECT) + DeviceExtensionSize,
                            DeviceName,
                            DeviceType,
                            DeviceCharacteristics,
                            FALSE,
                            (PDEVICE_OBJECT *)(&RxDeviceObject));
    
    if (Status != STATUS_SUCCESS) {
        return(Status);
    }

    if (RxData.DriverObject == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // If the Mini-Redir is being built in a monolithic fashion, then the 
    // device object "RxFileSystemDeviceObject" would not have been created
    // in the RxDriverEntry function. Hence we set RxDeviceObject->RDBSSDeviceObject
    // to NULL. When the "monolithic" Mini-Redir gets unloaded, a check is done
    // to see if RxDeviceObject->RDBSSDeviceObject is NULL. If it is not NULL,
    // then the device object is dereferenced. This happens in the function
    // RxUnregisterMinirdr.
    //
    // Don't allow myself to be unloaded.

#ifndef MONOLITHIC_MINIRDR
    RxDeviceObject->RDBSSDeviceObject = (PDEVICE_OBJECT)RxFileSystemDeviceObject;
    ObReferenceObject((PDEVICE_OBJECT)RxFileSystemDeviceObject);

    // Reset the Unload routine. This prevents rdbss from being unloaded individually
    RxData.DriverObject->DriverUnload = NULL;
#else
    RxDeviceObject->RDBSSDeviceObject = NULL;
    RxFileSystemDeviceObject->ReferenceCount++;
#endif

    *DeviceObject = RxDeviceObject;
    RxDeviceObject->RdbssExports = &RxExports;
    RxDeviceObject->Dispatch = MrdrDispatch;
    RxDeviceObject->RegistrationControls = Controls;
    RxDeviceObject->DeviceName = *DeviceName;
    RxDeviceObject->RegisterUncProvider =
             !BooleanFlagOn(Controls,RX_REGISTERMINI_FLAG_DONT_PROVIDE_UNCS);
    RxDeviceObject->RegisterMailSlotProvider =
             !BooleanFlagOn(Controls,RX_REGISTERMINI_FLAG_DONT_PROVIDE_MAILSLOTS);

    {
        LONG Index;

        for (Index = 0; Index < MaximumWorkQueue; Index++) {
            InitializeListHead( &RxDeviceObject->OverflowQueue[Index] );
        }
    }

    KeInitializeSpinLock( &RxDeviceObject->OverflowQueueSpinLock );

    RxDeviceObject->NetworkProviderPriority = RxGetNetworkProviderPriority(DeviceName);
    RxLog(("RegMini %x %wZ\n",RxDeviceObject->NetworkProviderPriority,DeviceName));
    RxWmiLog(LOG,
             RxRegisterMinirdr,
             LOGULONG(RxDeviceObject->NetworkProviderPriority)
             LOGUSTR(*DeviceName));

    ExAcquireFastMutexUnsafe(&RxData.MinirdrRegistrationMutex);

    InsertTailList(&RxData.RegisteredMiniRdrs,&RxDeviceObject->MiniRdrListLinks);
    //no need for interlock.....we're inside the mutex
    //InterlockedIncrement(&RxData.NumberOfMinirdrsRegistered);
    RxData.NumberOfMinirdrsRegistered++;

    ExReleaseFastMutexUnsafe(&RxData.MinirdrRegistrationMutex);

    if (!FlagOn(Controls,RX_REGISTERMINI_FLAG_DONT_INIT_DRIVER_DISPATCH)) {
        RxInitializeMinirdrDispatchTable(DriverObject);
    }

    if (!FlagOn(Controls,RX_REGISTERMINI_FLAG_DONT_INIT_PREFIX_N_SCAVENGER)) {
        //  Initialize the netname table
        RxDeviceObject->pRxNetNameTable = &RxDeviceObject->RxNetNameTableInDeviceObject;
        RxInitializePrefixTable( RxDeviceObject->pRxNetNameTable, 0, FALSE);
        RxDeviceObject->RxNetNameTableInDeviceObject.IsNetNameTable = TRUE;

        // Initialize the scavenger data structures
        RxDeviceObject->pRdbssScavenger = &RxDeviceObject->RdbssScavengerInDeviceObject;
        RxInitializeRdbssScavenger(RxDeviceObject->pRdbssScavenger);
    }

    RxDeviceObject->pAsynchronousRequestsCompletionEvent = NULL;

#ifdef BBT_UPDATE
    if (RxHandle == INVALID_HANDLE_VALUE) {
        NTSTATUS Status;

        Status = PsCreateSystemThread(
                     &RxHandle,
                     PROCESS_ALL_ACCESS,
                     NULL,
                     NULL,
                     NULL,
                     RxUpdate,
                     NULL);

        if (Status == STATUS_SUCCESS) {
            Status = ObReferenceObjectByHandle(
                         RxHandle,
                         THREAD_ALL_ACCESS,
                         NULL,
                         KernelMode,
                         &RxPointer,
                         NULL);

            if (Status != STATUS_SUCCESS) {
                RxPointer = NULL;
            }

            ZwClose(RxHandle);
        } else {
            RxHandle = INVALID_HANDLE_VALUE;
        }
    }
#endif 

    return((STATUS_SUCCESS));
}


VOID
NTAPI
RxMakeLateDeviceAvailable(
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    The routine diddles the device object to make a "late device" available.
    A late device is one that is not created in the driver's load routine.
    Non-late devices are diddled by the driverload code in the io subsystem; but
    for late devices we have to do this by hand. This is a routine instead of a
    macro in order that other stuff might have to be done here....it's only
    executed once per device object.

Arguments:

    DeviceObject   - where the created device object is to be stored

Return Value:

    --

--*/
{
    PAGED_CODE();
    RxDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    return;
}

VOID
RxpUnregisterMinirdr(
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    )

/*++

Routine Description:

Arguments:

Return Value:

    --

--*/
{
    PAGED_CODE();

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), (" RxUnregisterMinirdr  Name = %wZ\n",&RxDeviceObject->DeviceName));
    ExAcquireFastMutexUnsafe(&RxData.MinirdrRegistrationMutex);
    RemoveEntryList(&RxDeviceObject->MiniRdrListLinks);
    //no need for interlock.....we're inside the mutex
    //InterlockedDecrement(&RxData.NumberOfMinirdrsRegistered);
    RxData.NumberOfMinirdrsRegistered--;

    if (RxData.NumberOfMinirdrsRegistered == 0) {
        // Allow rdbss being unloaded after mini rdr driver is unregistered
        RxData.DriverObject->DriverUnload = RxUnload;
    }

    ExReleaseFastMutexUnsafe(&RxData.MinirdrRegistrationMutex);

    if (!FlagOn(RxDeviceObject->RegistrationControls,
        RX_REGISTERMINI_FLAG_DONT_INIT_PREFIX_N_SCAVENGER)) {

        RxForceNetTableFinalization(RxDeviceObject);
        RxFinalizePrefixTable(&RxDeviceObject->RxNetNameTableInDeviceObject);
        //no finalization is defined for scavenger structure
    }

    RxSpinDownOutstandingAsynchronousRequests(RxDeviceObject);

    // Spin down any worker threads associated with this minirdr
    RxSpinDownMRxDispatcher(RxDeviceObject);

    IoDeleteDevice(&RxDeviceObject->DeviceObject);

#ifdef BBT_UPDATE
    if (RxPointer != NULL) {
       RxHandle = INVALID_HANDLE_VALUE;
       KeWaitForSingleObject(
            RxPointer,
            Executive,
            KernelMode,
            FALSE,
            NULL);
        
        ASSERT(PsIsThreadTerminating(RxPointer));
        ObDereferenceObject(RxPointer);

        RxPointer = NULL;
    }
#endif 
}


VOID
RxSpinDownOutstandingAsynchronousRequests(
    PRDBSS_DEVICE_OBJECT RxDeviceObject)
/*++

Routine Description:

    This routine spins down all the outstanding requests associated with a
    mini redirector before it can be unloaded

Arguments:

    RxDeviceObject -- the mini redirector's device object


--*/
{
    BOOLEAN WaitForSpinDown = FALSE;
    KEVENT SpinDownEvent;

    KeInitializeEvent(
        &SpinDownEvent,
        NotificationEvent,
        FALSE);

    RxAcquireSerializationMutex();

    ASSERT(RxDeviceObject->pAsynchronousRequestsCompletionEvent == NULL);

    WaitForSpinDown = (RxDeviceObject->AsynchronousRequestsPending != 0);

    RxDeviceObject->pAsynchronousRequestsCompletionEvent = &SpinDownEvent;

    RxReleaseSerializationMutex();

    if (WaitForSpinDown) {
        KeWaitForSingleObject(
            &SpinDownEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL);
    }
}


NTSTATUS
RxRegisterAsynchronousRequest(
    PRDBSS_DEVICE_OBJECT RxDeviceObject)
/*++

Routine Description:

    This routine registers an asynchronous request. On successful completion
    the mini redirector cannot be unloaded till the request completes

Arguments:

    RxDeviceObject - the mini redirector device object

Return Value:

    STATUS_SUCCESS if successful

--*/
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;

    RxAcquireSerializationMutex();

    if (RxDeviceObject->pAsynchronousRequestsCompletionEvent == NULL) {
        RxDeviceObject->AsynchronousRequestsPending++;
        Status = STATUS_SUCCESS;
    }

    RxReleaseSerializationMutex();

    return Status;
}

VOID
RxDeregisterAsynchronousRequest(
    PRDBSS_DEVICE_OBJECT RxDeviceObject)
/*++

Routine Description:

    This routine signals the completion of an asynchronous request. It resumes
    unloading if required.

Arguments:

    RxDeviceObject - the mini redirector device object

--*/
{
    PKEVENT pEvent = NULL;

    RxAcquireSerializationMutex();

    RxDeviceObject->AsynchronousRequestsPending--;

    if ((RxDeviceObject->AsynchronousRequestsPending == 0) &&
        (RxDeviceObject->pAsynchronousRequestsCompletionEvent != NULL)) {
        pEvent = RxDeviceObject->pAsynchronousRequestsCompletionEvent;
    }

    RxReleaseSerializationMutex();

    if (pEvent != NULL) {
        KeSetEvent(
            pEvent,
            IO_NO_INCREMENT,
            FALSE);
    }
}

#ifdef BBT_UPDATE
WCHAR   Request_Name[] = L"\\??\\UNC\\landyw-bear\\bbt\\bbt.txt";

VOID
RxUpdate(PVOID pContext)
{
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    RequestName;

    RequestName.Buffer = Request_Name;
    RequestName.MaximumLength = wcslen(Request_Name) * sizeof(WCHAR);
    RequestName.Length = RequestName.MaximumLength;

    InitializeObjectAttributes(
        &ObjectAttributes,
        &RequestName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    for (;;) {
        PHYSICAL_ADDRESS StartAddress;
        LARGE_INTEGER    NumberOfBytes;
        HANDLE           FileHandle;

        struct {
            LIST_ENTRY Link;
            SIZE_T Size;
            CHAR Data[];
        } *Request;

        NumberOfBytes.QuadPart = 0x2;
        StartAddress.QuadPart = 0;

        MmAddPhysicalMemory(
            &StartAddress,
            &NumberOfBytes);

        Request = (PVOID)(StartAddress.QuadPart);

        if (Request != NULL) {
            Status = ZwCreateFile(
                         &FileHandle,
                         (FILE_APPEND_DATA | SYNCHRONIZE),
                         &ObjectAttributes,
                         &IoStatusBlock,
                         NULL,
                         FILE_ATTRIBUTE_NORMAL,
                         (FILE_SHARE_WRITE | FILE_SHARE_READ | FILE_SHARE_DELETE),
                         FILE_OPEN,
                         FILE_NO_INTERMEDIATE_BUFFERING,
                         NULL,
                         0);


            if (Status == STATUS_SUCCESS) {
                LARGE_INTEGER ByteOffset;

                ByteOffset.QuadPart = -1;

                Status = ZwWriteFile(
                            FileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            Request->Data,
                            (ULONG)Request->Size,
                            &ByteOffset,
                            NULL);                           


                Status = ZwClose(FileHandle);
            }

            ExFreePool(Request);
        }


        if (RxHandle == INVALID_HANDLE_VALUE) {
            break;
        }
    }

    PsTerminateSystemThread(STATUS_SUCCESS);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ntdevfcb.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NtDevFcb.c

Abstract:

    This module implements the FSD level Close, CleanUp, and  FsCtl and IoCtl routines for RxDevice
    files.  Also, the createroutine is not here; rather, it is called from CommonCreate and
    not called directly by the dispatch driver.

    Each of the pieces listed (close, cleanup, fsctl, ioctl) has its own little section of the
    file......complete with its own forward-prototypes and alloc pragmas

Author:

    Joe Linn     [JoeLinn]    3-aug-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <ntddnfs2.h>
#include <ntddmup.h>
#include "fsctlbuf.h"
#include "prefix.h"
#include "rxce.h"

//
//  The local trace mask for this part of the module
//

#define Dbg (DEBUG_TRACE_DEVFCB)


NTSTATUS
RxXXXControlFileCallthru(
    IN PRX_CONTEXT RxContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonDevFCBFsCtl)
#pragma alloc_text(PAGE, RxXXXControlFileCallthru)
#pragma alloc_text(PAGE, RxCommonDevFCBClose)
#pragma alloc_text(PAGE, RxCommonDevFCBCleanup)
#pragma alloc_text(PAGE, RxGetUid)
#endif

NTSTATUS
RxXXXControlFileCallthru(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine calls down to the minirdr to implement ioctl and fsctl controls that
    the wrapper doesn't understand. note that if there is no dispatch defined (i.e. for the
    wrapper's own device object) then we also set Rxcontext->Fobx to NULL so that the caller
    won't try to go thru lowio to get to the minirdr.

Arguments:

    RxContext - the context of the request

Return Value:

    RXSTATUS - The FSD status for the request include the PostRequest field....

--*/
{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    RxCaptureRequestPacket;

    PAGED_CODE();

    if (RxContext->RxDeviceObject->Dispatch == NULL) {
        RxContext->pFobx = NULL; //don't try again on lowio
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    Status = RxLowIoPopulateFsctlInfo (RxContext);

    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    if ((LowIoContext->ParamsFor.FsCtl.InputBufferLength > 0) &&
        (LowIoContext->ParamsFor.FsCtl.pInputBuffer == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    if ((LowIoContext->ParamsFor.FsCtl.OutputBufferLength > 0) &&
        (LowIoContext->ParamsFor.FsCtl.pOutputBuffer == NULL)) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = (RxContext->RxDeviceObject->Dispatch->MRxDevFcbXXXControlFile)(RxContext);

    if (Status!=STATUS_PENDING) {
        capReqPacket->IoStatus.Information = RxContext->InformationToReturn;
    }

    return(Status);
}



NTSTATUS
RxCommonDevFCBClose ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This routine implements the FSD Close for a Device FCB.

Arguments:

    RxDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The FSD status for the IRP

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    PRX_PREFIX_TABLE  pRxNetNameTable
                      = RxContext->RxDeviceObject->pRxNetNameTable;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("RxCommonDevFCBClose\n", 0));
    RxLog(("DevFcbClose %lx %lx\n",RxContext,capFileObject));
    RxWmiLog(LOG,
             RxCommonDevFCBClose,
             LOGPTR(RxContext)
             LOGPTR(capFileObject));

    ASSERT  (NodeType(capFcb) == RDBSS_NTC_DEVICE_FCB);


    // deal with the device fcb
    if (!capFobx) {
        capFcb->OpenCount--;
        return STATUS_SUCCESS;
    }

    //otherwise, it's a connection-type file. you have to get the lock; then case-out
    RxAcquirePrefixTableLockExclusive(pRxNetNameTable, TRUE);

    try {
        switch (NodeType(capFobx)) {
        case RDBSS_NTC_V_NETROOT:
           {
               PV_NET_ROOT VNetRoot = (PV_NET_ROOT)capFobx;

               VNetRoot->NumberOfOpens--;
               RxDereferenceVNetRoot(VNetRoot,LHS_ExclusiveLockHeld);
           }
           break;
        default:
            Status = STATUS_NOT_IMPLEMENTED;
        }
        try_return(NOTHING); //eliminate warning

try_exit: NOTHING;
    } finally {
         RxReleasePrefixTableLock( pRxNetNameTable );
    }

    return Status;
}

NTSTATUS
RxCommonDevFCBCleanup ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This routine implements the FSD part of closing down a handle to a
    device FCB.

Arguments:

    RxDeviceObject - Supplies the volume device object where the
        file being Cleanup exists

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The FSD status for the IRP

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("RxCommonFCBCleanup\n", 0));
    RxLog(("DevFcbCleanup %lx\n",RxContext,capFileObject));
    RxWmiLog(LOG,
             RxCommonDevFCBCleanup,
             LOGPTR(RxContext)
             LOGPTR(capFileObject));

    ASSERT  (NodeType(capFcb) == RDBSS_NTC_DEVICE_FCB);

    // deal with the device fcb
    if (!capFobx) {
        capFcb->UncleanCount--;
        // RxCompleteContextAndReturn( RxStatus(SUCCESS) );
        return STATUS_SUCCESS;
    }

    //otherwise, it's a connection-type file. you have to get the lock; then case-out
    RxAcquirePrefixTableLockShared(RxContext->RxDeviceObject->pRxNetNameTable, TRUE);

    try {
        switch (NodeType(capFobx)) {
        Status = STATUS_SUCCESS;
        case RDBSS_NTC_V_NETROOT:
            //nothing to do
            break;
        default:
            Status = STATUS_INVALID_DEVICE_REQUEST;
        }
        try_return(NOTHING); //eliminate warning

try_exit: NOTHING;
    } finally {
         RxReleasePrefixTableLock( RxContext->RxDeviceObject->pRxNetNameTable );
    }

    // RxCompleteContextAndReturn( Status );
    return Status;
}

//         | *********************|
//         | |   F  S  C  T  L   ||
//         | *********************|
//


NTSTATUS
RxCommonDevFCBFsCtl ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This is the common routine for doing FileSystem control operations called
    by both the fsd and fsp threads

Arguments:

    RxContext - Supplies the Irp to process and stateinfo about where we are

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureFobx;
    RxCaptureParamBlock;

    ULONG FsControlCode = capPARAMS->Parameters.FileSystemControl.FsControlCode;

    PAGED_CODE();

    RxDbgTrace (+1, Dbg, ("RxCommonDevFCBFsCtl     IrpC = %08lx\n", RxContext));
    RxDbgTrace( 0, Dbg, ("MinorFunction = %08lx, ControlCode   = %08lx \n",
                        capPARAMS->MinorFunction, FsControlCode));
    RxLog(("DevFcbFsCtl %lx %lx %lx\n",RxContext,capPARAMS->MinorFunction,FsControlCode));
    RxWmiLog(LOG,
             RxCommonDevFCBFsCtl,
             LOGPTR(RxContext)
             LOGUCHAR(capPARAMS->MinorFunction)
             LOGULONG(FsControlCode));

    //
    //  We know this is a file system control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //

    switch (capPARAMS->MinorFunction) {
    case IRP_MN_USER_FS_REQUEST:
        switch (FsControlCode) {

#ifdef RDBSSLOG

        case FSCTL_LMR_DEBUG_TRACE:

            //
            // This FSCTL is being disabled since no one uses this anymore. If
            // it needs to be reactivated for some reason, the appropriate 
            // checks have to be added to make sure that the IRP->UserBuffer is
            // a valid address. The try/except call below won't protect against
            // a random kernel address being passed.
            //
            return STATUS_INVALID_DEVICE_REQUEST;

            // the 2nd buffer points to the string

            //
            // We need to try/except this call to protect against random buffers
            // being passed in from UserMode.
            //
            try {
                RxDebugControlCommand(capReqPacket->UserBuffer);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                  return STATUS_INVALID_USER_BUFFER;
            }

            Status = STATUS_SUCCESS;

            break;

#endif //RDBSSLOG

        default:
             RxDbgTrace(0, Dbg, ("RxFsdDevFCBFsCTL unknown user request\n"));
             Status = RxXXXControlFileCallthru(RxContext);
             if ( (Status == STATUS_INVALID_DEVICE_REQUEST) && (RxContext->pFobx!=NULL) ) {
                 RxDbgTrace(0, Dbg, ("RxCommonDevFCBFsCtl -> Invoking Lowio for FSCTL\n"));
                 Status = RxLowIoFsCtlShell(RxContext);
             }
        }
        break;
    default :
        RxDbgTrace(0, Dbg, ("RxFsdDevFCBFsCTL nonuser request!!\n", 0));
        Status = RxXXXControlFileCallthru(RxContext);
    }


    if (RxContext->PostRequest) {
       Status = RxFsdPostRequestWithResume(RxContext,RxCommonDevFCBFsCtl);
    }

    RxDbgTrace(-1, Dbg, ("RxCommonDevFCBFsCtl -> %08lx\n", Status));
    return Status;
}

//   | *********************|
//   | |   I  O  C  T  L   ||
//   | *********************|

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonDevFCBIoCtl)
#endif



NTSTATUS
RxCommonDevFCBIoCtl ( RXCOMMON_SIGNATURE )

/*++

Routine Description:

    This is the common routine for doing FileSystem control operations called
    by both the fsd and fsp threads

Arguments:

    RxContext - Supplies the Irp to process and stateinfo about where we are

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    RxCaptureRequestPacket; RxCaptureFobx;
    RxCaptureParamBlock;
    ULONG IoControlCode = capPARAMS->Parameters.DeviceIoControl.IoControlCode;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonDevFCBIoCtl IrpC-%08lx\n", RxContext));
    RxDbgTrace( 0, Dbg, ("ControlCode   = %08lx\n", IoControlCode));

    if (capFobx == NULL) {
        switch (IoControlCode) {
        case IOCTL_REDIR_QUERY_PATH:
            Status = RxPrefixClaim(RxContext);
            break;
    
        default:
            {
                Status = RxXXXControlFileCallthru(RxContext);
                if ((Status != STATUS_PENDING) && RxContext->PostRequest)  {
                    Status = RxFsdPostRequestWithResume(RxContext,RxCommonDevFCBIoCtl);
                }
            }
            break;
        }
    } else {
        Status = STATUS_INVALID_HANDLE;
    }
    
    RxDbgTrace(-1, Dbg, ("RxCommonDevFCBIoCtl -> %08lx\n", Status));

    return Status;
}

//
//  Utility Routine
//
LUID
RxGetUid(
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext
    )

/*++

Routine Description:

    This routine gets the effective UID to be used for this create.

Arguments:

    SubjectSecurityContext - Supplies the information from IrpSp.

Return Value:

    None

--*/
{
    LUID LogonId;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxGetUid ... \n", 0));


    //  Is the thread currently impersonating someone else?

    if (SubjectSecurityContext->ClientToken != NULL) {

        //
        //  If its impersonating someone that is logged in locally then use
        //  the local id.
        //

        SeQueryAuthenticationIdToken(SubjectSecurityContext->ClientToken, &LogonId);

    } else {

        //
        //  Use the processes LogonId
        //

        SeQueryAuthenticationIdToken(SubjectSecurityContext->PrimaryToken, &LogonId);
    }

    RxDbgTrace(-1, Dbg, (" ->UserUidHigh/Low = %08lx %08lx\n", LogonId.HighPart, LogonId.LowPart));

    return LogonId;
}

//                                                  | *********************|
//                                                  | |   V O L I N F O   ||
//                                                  | *********************|

NTSTATUS
RxDevFcbQueryDeviceInfo (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp,
    PFILE_FS_DEVICE_INFORMATION UsersBuffer,
    ULONG BufferSize,
    PULONG ReturnedLength
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonDevFCBQueryVolInfo)
#pragma alloc_text(PAGE, RxDevFcbQueryDeviceInfo)
#endif

NTSTATUS
RxCommonDevFCBQueryVolInfo ( RXCOMMON_SIGNATURE )

/*++

Routine Description:

    This is the common routine for doing FileSystem control operations called
    by both the fsd and fsp threads

Arguments:

    RxContext - Supplies the Irp to process and stateinfo about where we are

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    BOOLEAN PostToFsp = FALSE;
    RxCaptureRequestPacket;
    RxCaptureParamBlock;
    FS_INFORMATION_CLASS InformationClass = capPARAMS->Parameters.QueryVolume.FsInformationClass;
    PVOID UsersBuffer  = capReqPacket->AssociatedIrp.SystemBuffer;
    ULONG BufferSize   = capPARAMS->Parameters.QueryVolume.Length;
    ULONG ReturnedLength;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonDevFCBQueryVolInfo IrpC-%08lx\n", RxContext));
    RxDbgTrace( 0, Dbg, ("ControlCode   = %08lx\n", InformationClass));
    RxLog(("DevFcbQVolInfo %lx %lx\n",RxContext,InformationClass));
    RxWmiLog(LOG,
             RxCommonDevFCBQueryVolInfo,
             LOGPTR(RxContext)
             LOGULONG(InformationClass));

    switch (InformationClass) {

    case FileFsDeviceInformation:

        Status = RxDevFcbQueryDeviceInfo (RxContext, &PostToFsp, UsersBuffer, BufferSize, &ReturnedLength);
        break;

    default:
        Status = STATUS_NOT_IMPLEMENTED;

    };

    RxDbgTrace(-1, Dbg, ("RxCommonDevFCBQueryVolInfo -> %08lx\n", Status));

    if ( PostToFsp ) return RxFsdPostRequestWithResume(RxContext,RxCommonDevFCBQueryVolInfo);

    if (Status==STATUS_SUCCESS) {
        capReqPacket->IoStatus.Information = ReturnedLength;
    }

    // RxCompleteContextAndReturn( Status );
    return Status;

}


NTSTATUS
RxDevFcbQueryDeviceInfo (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp,
    PFILE_FS_DEVICE_INFORMATION UsersBuffer,
    ULONG BufferSize,
    PULONG ReturnedLength
    )

/*++

Routine Description:

    This routine shuts down up the RDBSS filesystem...i.e. we connect to the MUP. We can only shut down
    if there's no netroots and if there's only one deviceFCB handle.

Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context....for later when i need the buffers

Return Value:

RXSTATUS

--*/

{
    NTSTATUS Status;
    RxCaptureFobx;
    BOOLEAN Wait       = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD      = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("RxDevFcbQueryDeviceInfo -> %08lx\n", 0));

    if (BufferSize < sizeof(FILE_FS_DEVICE_INFORMATION)) {
        return STATUS_BUFFER_OVERFLOW;
    };
    UsersBuffer->Characteristics = FILE_REMOTE_DEVICE;
    *ReturnedLength = sizeof(FILE_FS_DEVICE_INFORMATION);

    // deal with the device fcb

    if (!capFobx) {
        UsersBuffer->DeviceType = FILE_DEVICE_NETWORK_FILE_SYSTEM;
        return(STATUS_SUCCESS);
    }

    //otherwise, it's a connection-type file. you have to get the lock; then case-out

    if (!RxAcquirePrefixTableLockShared(RxContext->RxDeviceObject->pRxNetNameTable, Wait)) {
        *PostToFsp = TRUE;
        return STATUS_PENDING;
    }

    try {
        Status = STATUS_SUCCESS;
        switch (NodeType(capFobx)) {
        case RDBSS_NTC_V_NETROOT: {
            PV_NET_ROOT VNetRoot = (PV_NET_ROOT)capFobx;
            PNET_ROOT NetRoot = (PNET_ROOT)VNetRoot->NetRoot;

            if (NetRoot->Type==NET_ROOT_PIPE) {
                NetRoot->DeviceType = RxDeviceType(NAMED_PIPE);
            }

            UsersBuffer->DeviceType = NetRoot->DeviceType;
            }
            break;
        default:
            Status = STATUS_NOT_IMPLEMENTED;
        }
        try_return(NOTHING); //eliminate warning

try_exit: NOTHING;
    } finally {
         RxReleasePrefixTableLock( RxContext->RxDeviceObject->pRxNetNameTable );
    }

    return Status;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ntdisp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Ntdisp.h

Abstract:

    This module prototypes the upper level routines used in dispatching to the implementations

Author:

    Joe Linn     [JoeLinn]   24-aug-1994

Revision History:

--*/

#ifndef _DISPATCH_STUFF_DEFINED_
#define _DISPATCH_STUFF_DEFINED_

VOID
RxInitializeDispatchVectors(
    OUT PDRIVER_OBJECT DriverObject
    );

//
//  The global structure used to contain our fast I/O callbacks; this is
//  exposed because it's needed in read/write; we could use a wrapper....probably should. but since
//  ccinitializecachemap will be macro'd differently for win9x; we'll just doit there.
//

extern FAST_IO_DISPATCH RxFastIoDispatch;

NTSTATUS
RxCommonDevFCBCleanup ( RXCOMMON_SIGNATURE );                          //  implemented in DevFCB.c

NTSTATUS
RxCommonDevFCBClose ( RXCOMMON_SIGNATURE );                            //  implemented in DevFCB.c

NTSTATUS
RxCommonDevFCBIoCtl ( RXCOMMON_SIGNATURE );                //  implemented in DevFCB.c

NTSTATUS
RxCommonDevFCBFsCtl ( RXCOMMON_SIGNATURE );                //  implemented in DevFCB.c

NTSTATUS
RxCommonDevFCBQueryVolInfo ( RXCOMMON_SIGNATURE );                //  implemented in DevFCB.c



//
//
//   contained here are the fastio dispatch routines and the fsrtl callback routines

//
//  The following macro is used to determine if an FSD thread can block
//  for I/O or wait for a resource.  It returns TRUE if the thread can
//  block and FALSE otherwise.  This attribute can then be used to call
//  the FSD & FSP common work routine with the proper wait value.
//

#define CanFsdWait(IRP) IoIsOperationSynchronous(Irp)


//
//  The FSP level dispatch/main routine.  This is the routine that takes
//  IRP's off of the work queue and calls the appropriate FSP level
//  work routine.
//

VOID
RxFspDispatch (                        //  implemented in FspDisp.c
    IN PVOID Context
    );

//
//  The following routines are the FSP work routines that are called
//  by the preceding RxFspDispath routine.  Each takes as input a pointer
//  to the IRP, perform the function, and return a pointer to the volume
//  device object that they just finished servicing (if any).  The return
//  pointer is then used by the main Fsp dispatch routine to check for
//  additional IRPs in the volume's overflow queue.
//
//  Each of the following routines is also responsible for completing the IRP.
//  We moved this responsibility from the main loop to the individual routines
//  to allow them the ability to complete the IRP and continue post processing
//  actions.
//

NTSTATUS
RxCommonCleanup ( RXCOMMON_SIGNATURE );                      //  implemented in Cleanup.c

NTSTATUS
RxCommonClose ( RXCOMMON_SIGNATURE );                        //  implemented in Close.c

VOID
RxFspClose (
    IN PVCB Vcb OPTIONAL
    );

NTSTATUS
RxCommonCreate ( RXCOMMON_SIGNATURE );                       //  implemented in Create.c

NTSTATUS
RxCommonDirectoryControl ( RXCOMMON_SIGNATURE );             //  implemented in DirCtrl.c

NTSTATUS
RxCommonDeviceControl ( RXCOMMON_SIGNATURE );                //  implemented in DevCtrl.c

NTSTATUS
RxCommonQueryEa ( RXCOMMON_SIGNATURE );                      //  implemented in Ea.c

NTSTATUS
RxCommonSetEa ( RXCOMMON_SIGNATURE );                        //  implemented in Ea.c

NTSTATUS
RxCommonQuerySecurity ( RXCOMMON_SIGNATURE );                //  implemented in Ea.c

NTSTATUS
RxCommonSetSecurity ( RXCOMMON_SIGNATURE );                  //  implemented in Ea.c

NTSTATUS
RxCommonQueryInformation ( RXCOMMON_SIGNATURE );             //  implemented in FileInfo.c

NTSTATUS
RxCommonSetInformation ( RXCOMMON_SIGNATURE );               //  implemented in FileInfo.c

NTSTATUS
RxCommonFlushBuffers ( RXCOMMON_SIGNATURE );                 //  implemented in Flush.c

NTSTATUS
RxCommonFileSystemControl ( RXCOMMON_SIGNATURE );            //  implemented in FsCtrl.c

NTSTATUS
RxCommonLockControl ( RXCOMMON_SIGNATURE );                  //  implemented in LockCtrl.c

NTSTATUS
RxCommonShutdown ( RXCOMMON_SIGNATURE );                     //  implemented in Shutdown.c

NTSTATUS
RxCommonRead ( RXCOMMON_SIGNATURE );                         //  implemented in Read.c

NTSTATUS
RxCommonQueryVolumeInformation ( RXCOMMON_SIGNATURE );              //  implemented in VolInfo.c

NTSTATUS
RxCommonSetVolumeInformation ( RXCOMMON_SIGNATURE );                //  implemented in VolInfo.c

NTSTATUS
RxCommonWrite ( RXCOMMON_SIGNATURE );                        //  implemented in Write.c

//  Here are the callbacks used by the I/O system for checking for fast I/O or
//  doing a fast query info call, or doing fast lock calls.
//

BOOLEAN
RxFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
RxFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
RxFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
RxFastQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
RxFastQueryStdInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
RxFastLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
RxFastUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
RxFastUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
RxFastUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
RxFastIoDeviceControl (
    IN struct _FILE_OBJECT *FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    );

//
//  The following macro is used to set the is fast i/o possible field in
//  the common part of the nonpaged fcb
//
//
//      BOOLEAN
//      RxIsFastIoPossible (
//          IN PFCB Fcb
//          );
//

#if 0

instead of this...we set the state to questionable.....this will cause us to be consulted on every call via out
CheckIfFastIoIsPossibleCallOut. in this way, we don't have to be continually setting and resetting this

#define RxIsFastIoPossible(FCB) \
 ((BOOLEAN)                                                                                                 \
      (                                                                                                     \
        ((FCB)->FcbCondition != FcbGood || !FsRtlOplockIsFastIoPossible( &(FCB)->Specific.Fcb.Oplock ))     \
        ?    FastIoIsNotPossible                                                                            \
        :(  (!FsRtlAreThereCurrentFileLocks( &(FCB)->Specific.Fcb.FileLock )                                \
                                          && ((FCB)->NonPaged->OutstandingAsyncWrites == 0) )               \
            ?    FastIoIsPossible                                                                           \
            :    FastIoIsQuestionable                                                                       \
         )                                                                                                  \
       )                                                                                                    \
 )
#endif


VOID
RxAcquireFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    );

VOID
RxReleaseFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    );

//
#endif // _DISPATCH_STUFF_DEFINED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ntdspvec.h ===
/*++

Copyright (c) 1989-1994  Microsoft Corporation

Module Name:

    NtDspVec.h

Abstract:

    This module declares the routines used to initialize a dispatch vector. this includefile is
    essentially private for NT version of the fsd and fspdispatch.

Author:

    Joe Linn     [JoeLinn]    2-Aug-94

Revision History:

--*/

#ifndef _DISPVEC_
#define _DISPVEC_


//
//  Global structures used to dispatch to the actual routines. By having
//  a common dispatch we are able to consolidate handling of stuff like
//  dispatching to a stack overflow thread, irpcontext getting, logging, etc.
//  We may decide later that we
//  would rather save the few cycles that this takes. Eventually, all the FCBs will
//  have pointers to optimized dispatch tables.
//

typedef
NTSTATUS
(*PRXCOMMON_ROUTINE) (
    IN PRX_CONTEXT RxContext
    );

typedef struct _RX_FSD_DISPATCH_VECTOR{
    PRXCOMMON_ROUTINE CommonRoutine;
    ULONG             StackRequirement;
} RX_FSD_DISPATCH_VECTOR, *PRX_FSD_DISPATCH_VECTOR;

extern RX_FSD_DISPATCH_VECTOR RxFsdDispatchVector[IRP_MJ_MAXIMUM_FUNCTION + 1];
extern RX_FSD_DISPATCH_VECTOR RxDeviceFCBVector[IRP_MJ_MAXIMUM_FUNCTION + 1];


#define DISPVECENTRY_SELECT_1(x) RxCommon##x
#define DISPVECENTRY_SELECT_0(x) RxCommonDispatchProblem
#define DISPVECENTRY_SELECT(x,y) DISPVECENTRY_SELECT_##x(y)
#define DISPVECENTRY_NEW(IRPSUFFIX,IMPL,VEC,STACKREQ) \
     {DISPVECENTRY_SELECT(IMPL,VEC),STACKREQ}

#if (IRP_MJ_CREATE != 0x00)
#error IRP_MJ_CREATE has changed!!!
#endif
#if (IRP_MJ_CREATE_NAMED_PIPE != 0x01)
#error IRP_MJ_CREATE_NAMED_PIPE has changed!!!
#endif
#if (IRP_MJ_CLOSE != 0x02)
#error IRP_MJ_CLOSE has changed!!!
#endif
#if (IRP_MJ_READ != 0x03)
#error IRP_MJ_READ has changed!!!
#endif
#if (IRP_MJ_WRITE != 0x04)
#error IRP_MJ_WRITE has changed!!!
#endif
#if (IRP_MJ_QUERY_INFORMATION != 0x05)
#error IRP_MJ_QUERY_INFORMATION has changed!!!
#endif
#if (IRP_MJ_SET_INFORMATION != 0x06)
#error IRP_MJ_SET_INFORMATION has changed!!!
#endif
#if (IRP_MJ_QUERY_EA != 0x07)
#error IRP_MJ_QUERY_EA has changed!!!
#endif
#if (IRP_MJ_SET_EA != 0x08)
#error IRP_MJ_SET_EA has changed!!!
#endif
#if (IRP_MJ_FLUSH_BUFFERS != 0x09)
#error IRP_MJ_FLUSH_BUFFERS has changed!!!
#endif
#if (IRP_MJ_QUERY_VOLUME_INFORMATION != 0x0a)
#error IRP_MJ_QUERY_VOLUME_INFORMATION has changed!!!
#endif
#if (IRP_MJ_SET_VOLUME_INFORMATION != 0x0b)
#error IRP_MJ_SET_VOLUME_INFORMATION has changed!!!
#endif
#if (IRP_MJ_DIRECTORY_CONTROL != 0x0c)
#error IRP_MJ_DIRECTORY_CONTROL has changed!!!
#endif
#if (IRP_MJ_FILE_SYSTEM_CONTROL != 0x0d)
#error IRP_MJ_FILE_SYSTEM_CONTROL has changed!!!
#endif
#if (IRP_MJ_DEVICE_CONTROL != 0x0e)
#error IRP_MJ_DEVICE_CONTROL has changed!!!
#endif
#if (IRP_MJ_INTERNAL_DEVICE_CONTROL != 0x0f)
#error IRP_MJ_INTERNAL_DEVICE_CONTROL has changed!!!
#endif
#if (IRP_MJ_SHUTDOWN != 0x10)
#error IRP_MJ_SHUTDOWN has changed!!!
#endif
#if (IRP_MJ_LOCK_CONTROL != 0x11)
#error IRP_MJ_LOCK_CONTROL has changed!!!
#endif
#if (IRP_MJ_CLEANUP != 0x12)
#error IRP_MJ_CLEANUP has changed!!!
#endif
#if (IRP_MJ_CREATE_MAILSLOT != 0x13)
#error IRP_MJ_CREATE_MAILSLOT has changed!!!
#endif
#if (IRP_MJ_QUERY_SECURITY != 0x14)
#error IRP_MJ_QUERY_SECURITY has changed!!!
#endif
#if (IRP_MJ_SET_SECURITY != 0x15)
#error IRP_MJ_SET_SECURITY has changed!!!
#endif
#if (IRP_MJ_POWER != 0x16)
#error IRP_MJ_POWER has changed!!!
#endif
#if (IRP_MJ_SYSTEM_CONTROL != 0x17)
#error IRP_MJ_SYSTEM_CONTROL has changed!!!
#endif
#if (IRP_MJ_DEVICE_CHANGE != 0x18)
#error IRP_MJ_DEVICE_CHANGE has changed!!!
#endif
#if (IRP_MJ_QUERY_QUOTA != 0x19)
#error IRP_MJ_QUERY_QUOTA has changed!!!
#endif
#if (IRP_MJ_SET_QUOTA != 0x1a)
#error IRP_MJ_SET_QUOTA has changed!!!
#endif
#if (IRP_MJ_PNP != 0x1b)
#error IRP_MJ_PNP has changed!!!
#endif
#if (IRP_MJ_PNP_POWER != IRP_MJ_PNP)
#error IRP_MJ_PNP_POWER has changed!!!
#endif
#if (IRP_MJ_MAXIMUM_FUNCTION != 0x1b)
#error IRP_MJ_MAXIMUM_FUNCTION has changed!!!
#endif

#endif // _DISPVEC_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\nterrlog.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    errorlog.c

Abstract:

    This module implements the error logging in the rdbss.

Author:

    Manny Weiser (mannyw)    11-Feb-92

Revision History:

    Joe Linn (joelinn)       23-feb-95  Convert for rdbss

--*/

#include "precomp.h"
#pragma hdrstop
#include <align.h>
#include <netevent.h>

//
//  The local debug trace level
//
#define MIN(__a,__b) (((__a)<=(__b))?(__a):(__b))


static UNICODE_STRING unknownId = { 6, 6, L"???" };
LONG LDWCount = 0;
NTSTATUS LDWLastStatus;
LARGE_INTEGER LDWLastTime;
PVOID LDWContext;

VOID
RxLogEventWithAnnotation(
    IN PRDBSS_DEVICE_OBJECT DeviceObject,
    IN ULONG                Id,
    IN NTSTATUS             NtStatus,
    IN PVOID                RawDataBuffer,
    IN USHORT               RawDataLength,
    IN PUNICODE_STRING      Annotations,
    IN ULONG                AnnotationCount
    )
/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.

--*/

{
    PIO_ERROR_LOG_PACKET ErrorLogEntry;
    ULONG                AnnotationStringLength = 0;
    ULONG                i;
    PWCHAR               Buffer;
    USHORT               PaddedRawDataLength = 0;

    for ( i = 0; i < AnnotationCount ; i++ ) {
        AnnotationStringLength += (Annotations[i].Length + sizeof(WCHAR));
    }

    //
    // pad the raw data buffer so that the insertion string starts
    // on an even address.
    //

    if ( ARGUMENT_PRESENT( RawDataBuffer ) ) {
        PaddedRawDataLength = (RawDataLength + 1) & ~1;
    }

    ErrorLogEntry = IoAllocateErrorLogEntry(
                        (PDEVICE_OBJECT)DeviceObject,
                        (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
                                PaddedRawDataLength + AnnotationStringLength)
                        );

    if (ErrorLogEntry != NULL) {

        //
        // Fill in the error log entry
        //

        ErrorLogEntry->ErrorCode = Id;
        ErrorLogEntry->MajorFunctionCode = 0;
        ErrorLogEntry->RetryCount = 0;
        ErrorLogEntry->UniqueErrorValue = 0;
        ErrorLogEntry->FinalStatus = NtStatus;
        ErrorLogEntry->IoControlCode = 0;
        ErrorLogEntry->DeviceOffset.QuadPart = 0;
        ErrorLogEntry->DumpDataSize = RawDataLength;
        ErrorLogEntry->StringOffset =
            (USHORT)(FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData) + PaddedRawDataLength);
        ErrorLogEntry->NumberOfStrings = (USHORT)AnnotationCount;

        ErrorLogEntry->SequenceNumber = 0;

        //
        // Append the extra information.
        //
        if ( ARGUMENT_PRESENT( RawDataBuffer ) ) {

            RtlCopyMemory(
                ErrorLogEntry->DumpData,
                RawDataBuffer,
                RawDataLength
                );
        }

        Buffer = (PWCHAR)((PCHAR)ErrorLogEntry->DumpData + PaddedRawDataLength);

        for ( i = 0; i < AnnotationCount ; i++ ) {

            RtlCopyMemory(
                Buffer,
                Annotations[i].Buffer,
                Annotations[i].Length
                );

            Buffer += (Annotations[i].Length/2);
            *Buffer++ = L'\0';
        }

        //
        // Write the entry
        //

        IoWriteErrorLogEntry(ErrorLogEntry);
    }

}


VOID
RxLogEventWithBufferDirect (
    IN PRDBSS_DEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING      OriginatorId,
    IN ULONG                EventId,
    IN NTSTATUS             Status,
    IN PVOID                DataBuffer,
    IN USHORT               DataBufferLength,
    IN ULONG                LineNumber
    )
{
    ULONG LocalBuffer[ 20 ];

    if( !ARGUMENT_PRESENT( OriginatorId ) || OriginatorId->Length == 0 ) {
        OriginatorId = &unknownId;
    }

    LocalBuffer[0] = Status;
    LocalBuffer[1] = LineNumber;

    RtlCopyMemory(
        &LocalBuffer[2],
        DataBuffer,
        MIN( DataBufferLength, sizeof( LocalBuffer ) - 2*sizeof( LocalBuffer[0] ) )
        );

    RxLogEventWithAnnotation(
        DeviceObject,
        EventId,
        Status,
        LocalBuffer,
        (USHORT)MIN( DataBufferLength + sizeof( LocalBuffer[0] ), sizeof( LocalBuffer ) ),
        OriginatorId,
        1
        );

}

VOID
RxLogEventDirect (
    IN PRDBSS_DEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING      OriginatorId,
    IN ULONG                EventId,
    IN NTSTATUS             Status,
    IN ULONG                Line
    )
/*++

Routine Description:

    This function logs an error.  You should use the 'RdrLogFailure'
      macro instead of calling this routine directly.

Arguments:
    Status is the status code showing the failure

    Line is where it happened

Return Value:

    None.

--*/
{
    ULONG LineAndStatus[2];

    LineAndStatus[0] = Line;
    LineAndStatus[1] = Status;

    if( !ARGUMENT_PRESENT( OriginatorId ) || OriginatorId->Length == 0 ) {
        OriginatorId = &unknownId;
    }

    RxLogEventWithAnnotation(
        DeviceObject,
        EventId,
        Status,
        &LineAndStatus,
        sizeof(LineAndStatus),
        OriginatorId,
        1
        );

}

BOOLEAN
RxCcLogError(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING FileName,
    IN NTSTATUS Error,
    IN NTSTATUS DeviceError,
    IN UCHAR IrpMajorCode,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine writes an eventlog entry to the eventlog.

Arguments:

    DeviceObject - The device object who owns the file where it occurred.

    FileName - The filename to use in logging the error (usually the DOS-side name)

    Error - The error to log in the eventlog record

    DeviceError - The actual error that occured in the device - will be logged
                  as user data

Return Value:

    True if successful, false if internal memory allocation failed

--*/

{
    UCHAR ErrorPacketLength;
    UCHAR BasePacketLength;
    ULONG StringLength;
    PIO_ERROR_LOG_PACKET ErrorLogEntry = NULL;
    BOOLEAN Result = FALSE;
    PWCHAR String;

    PAGED_CODE();

    //
    //  Get our error packet, holding the string and status code.  Note we log against the
    //  true filesystem if this is available.
    //
    //  The sizing of the packet is a bit slimy since the dumpdata is already grown by a
    //  ULONG onto the end of the packet.  Since NTSTATUS is ULONG, well, we just work in
    //  place.
    //

    BasePacketLength = sizeof(IO_ERROR_LOG_PACKET);
    if ((BasePacketLength + FileName->Length + sizeof(WCHAR)) <= ERROR_LOG_MAXIMUM_SIZE) {
        ErrorPacketLength = (UCHAR)(BasePacketLength + FileName->Length + sizeof(WCHAR));
    } else {
        ErrorPacketLength = ERROR_LOG_MAXIMUM_SIZE;
    }

    if( Error == IO_LOST_DELAYED_WRITE )
    {
        IoRaiseInformationalHardError( STATUS_LOST_WRITEBEHIND_DATA, FileName, NULL );

        // Increment the CC counter here!
        InterlockedIncrement( &LDWCount );
        KeQuerySystemTime( &LDWLastTime );
        LDWLastStatus = DeviceError;
        LDWContext = Context;
    }

    ErrorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry( DeviceObject,
                                                                    ErrorPacketLength );
    if (ErrorLogEntry) {

        //
        //  Fill in the nonzero members of the packet.
        //

        ErrorLogEntry->MajorFunctionCode = IrpMajorCode;
        ErrorLogEntry->ErrorCode = Error;
        ErrorLogEntry->FinalStatus = DeviceError;

        ErrorLogEntry->DumpDataSize = sizeof(NTSTATUS);
        RtlCopyMemory( &ErrorLogEntry->DumpData, &DeviceError, sizeof(NTSTATUS) );

        //
        //  The filename string is appended to the end of the error log entry. We may
        //  have to smash the middle to fit it in the limited space.
        //

        StringLength = ErrorPacketLength - BasePacketLength - sizeof(WCHAR);

        ASSERT(!(StringLength % sizeof(WCHAR)));

        String = (PWCHAR) ((PUCHAR)ErrorLogEntry + BasePacketLength);
        ErrorLogEntry->NumberOfStrings = 1;
        ErrorLogEntry->StringOffset = BasePacketLength;

        //
        //  If the name does not fit in the packet, divide the name equally to the
        //  prefix and suffix, with an ellipsis " .. " (4 wide characters) to indicate
        //  the loss.
        //

        if (StringLength < FileName->Length) {

            //
            //  Remember, prefix + " .. " + suffix is the length.  Calculate by figuring
            //  the prefix and then get the suffix by whacking the ellipsis and prefix off
            //  the total.
            //

            ULONG NamePrefixSegmentLength = ((StringLength/sizeof(WCHAR))/2 - 2)*sizeof(WCHAR);
            ULONG NameSuffixSegmentLength = StringLength - 4*sizeof(WCHAR) - NamePrefixSegmentLength;

            ASSERT(!(NamePrefixSegmentLength % sizeof(WCHAR)));
            ASSERT(!(NameSuffixSegmentLength % sizeof(WCHAR)));

            RtlCopyMemory( String,
                           FileName->Buffer,
                           NamePrefixSegmentLength );
            String = (PWCHAR)((PCHAR)String + NamePrefixSegmentLength);

            RtlCopyMemory( String,
                           L" .. ",
                           4*sizeof(WCHAR) );
            String += 4;

            RtlCopyMemory( String,
                           (PUCHAR)FileName->Buffer +
                           FileName->Length - NameSuffixSegmentLength,
                           NameSuffixSegmentLength );
            String = (PWCHAR)((PCHAR)String + NameSuffixSegmentLength);

        } else {

            RtlCopyMemory( String,
                           FileName->Buffer,
                           FileName->Length );
            String += FileName->Length/sizeof(WCHAR);
        }

        //
        //  Null terminate the string and send the packet.
        //

        *String = L'\0';

        IoWriteErrorLogEntry( ErrorLogEntry );
        Result = TRUE;
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ntfastio.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NtFastIo.c

Abstract:

    This module implements NT fastio routines.

Author:

    Joe Linn     [JoeLinn]    9-Nov-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_NTFASTIO)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxFastIoRead)
#pragma alloc_text(PAGE, RxFastIoWrite)
#pragma alloc_text(PAGE, RxFastLock)
#pragma alloc_text(PAGE, RxFastUnlockAll)
#pragma alloc_text(PAGE, RxFastUnlockAllByKey)
#pragma alloc_text(PAGE, RxFastUnlockSingle)
#pragma alloc_text(PAGE, RxFastIoCheckIfPossible)
#pragma alloc_text(PAGE, RxFastQueryBasicInfo)
#pragma alloc_text(PAGE, RxFastQueryStdInfo)
#endif


//these declarations would be copied to fsrtl.h
BOOLEAN
FsRtlCopyRead2 (
    IN PFILE_OBJECT      FileObject,
    IN PLARGE_INTEGER    FileOffset,
    IN ULONG             Length,
    IN BOOLEAN           Wait,
    IN ULONG             LockKey,
    OUT PVOID            Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT    DeviceObject,
    IN ULONG_PTR         TopLevelIrpValue
    );
BOOLEAN
FsRtlCopyWrite2 (
    IN PFILE_OBJECT      FileObject,
    IN PLARGE_INTEGER    FileOffset,
    IN ULONG             Length,
    IN BOOLEAN           Wait,
    IN ULONG             LockKey,
    IN PVOID             Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT    DeviceObject,
    IN ULONG_PTR         TopLevelIrpValue
    );

BOOLEAN
RxFastIoRead (
    IN PFILE_OBJECT      FileObject,
    IN PLARGE_INTEGER    FileOffset,
    IN ULONG             Length,
    IN BOOLEAN           Wait,
    IN ULONG             LockKey,
    OUT PVOID            Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT    DeviceObject
    )
{
    BOOLEAN ReturnValue;

    RX_TOPLEVELIRP_CONTEXT TopLevelContext;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxFastIoRead\n"));

    RxLog(("FastRead %lx:%lx:%lx",FileObject,FileObject->FsContext,FileObject->FsContext2));
    RxLog(("------>> %lx@%lx %lx",Length,FileOffset->LowPart,FileOffset->HighPart));
    RxWmiLog(LOG,
             RxFastIoRead_1,
             LOGPTR(FileObject)
             LOGPTR(FileObject->FsContext)
             LOGPTR(FileObject->FsContext2)
             LOGULONG(Length)
             LOGULONG(FileOffset->LowPart)
             LOGULONG(FileOffset->HighPart));

    ASSERT(RxIsThisTheTopLevelIrp(NULL));

    RxInitializeTopLevelIrpContext(
        &TopLevelContext,
        ((PIRP)FSRTL_FAST_IO_TOP_LEVEL_IRP),
        (PRDBSS_DEVICE_OBJECT)DeviceObject);

    ReturnValue =  FsRtlCopyRead2 (
                       FileObject,
                       FileOffset,
                       Length,
                       Wait,
                       LockKey,
                       Buffer,
                       IoStatus,
                       DeviceObject,
                       (ULONG_PTR)(&TopLevelContext)
                       );

    RxDbgTrace(-1, Dbg, ("RxFastIoRead ReturnValue=%x\n", ReturnValue));

    if (ReturnValue) {
        RxLog(
            ("FastReadYes %lx ret %lx:%lx",
             FileObject->FsContext2,IoStatus->Status,IoStatus->Information));
        RxWmiLog(LOG,
                 RxFastIoRead_2,
                 LOGPTR(FileObject->FsContext2)
                 LOGULONG(IoStatus->Status)
                 LOGPTR(IoStatus->Information));
    } else {
        RxLog(("FastReadNo %lx",FileObject->FsContext2));
        RxWmiLog(LOG,
                 RxFastIoRead_3,
                 LOGPTR(FileObject->FsContext2));
    }

    return ReturnValue;
}

BOOLEAN
RxFastIoWrite (
    IN PFILE_OBJECT      FileObject,
    IN PLARGE_INTEGER    FileOffset,
    IN ULONG             Length,
    IN BOOLEAN           Wait,
    IN ULONG             LockKey,
    IN PVOID             Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT    DeviceObject
    )
{
    BOOLEAN ReturnValue;

    RX_TOPLEVELIRP_CONTEXT TopLevelContext;

    PSRV_OPEN SrvOpen;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxFastIoWrite\n"));

    SrvOpen = ((PFOBX)(FileObject->FsContext2))->SrvOpen;
    if (FlagOn(SrvOpen->Flags,SRVOPEN_FLAG_DONTUSE_WRITE_CACHEING)) {
        //if this flag is set, we have to treat this as an unbuffered Io....sigh.
        RxDbgTrace(-1, Dbg, ("RxFastIoWrite DONTUSE_WRITE_CACHEING...failing\n"));
        return FALSE;
    }

    ASSERT(RxIsThisTheTopLevelIrp(NULL));

    RxInitializeTopLevelIrpContext(
        &TopLevelContext,
        ((PIRP)FSRTL_FAST_IO_TOP_LEVEL_IRP),
        (PRDBSS_DEVICE_OBJECT)DeviceObject);

    ReturnValue = FsRtlCopyWrite2 (
                      FileObject,
                      FileOffset,
                      Length,
                      Wait,
                      LockKey,
                      Buffer,
                      IoStatus,
                      DeviceObject,
                      (ULONG_PTR)(&TopLevelContext)
                      );

    RxDbgTrace(-1, Dbg, ("RxFastIoWrite ReturnValue=%x\n", ReturnValue));

    if (ReturnValue) {
        RxLog(
            ("FWY %lx OLP: %lx SLP: %lx IOSB %lx:%lx",
             FileObject->FsContext2,
             FileOffset->LowPart,
             SrvOpen->pFcb->Header.FileSize.LowPart,
             IoStatus->Status,
             IoStatus->Information));
        RxWmiLog(LOG,
                 RxFastIoWrite_1,
                 LOGPTR(FileObject->FsContext2)
                 LOGULONG(FileOffset->LowPart)
                 LOGULONG(SrvOpen->pFcb->Header.FileSize.LowPart)
                 LOGULONG(IoStatus->Status)
                 LOGPTR(IoStatus->Information));
    } else {
        RxLog(("FastWriteNo %lx",FileObject->FsContext2));
        RxWmiLog(LOG,
                 RxFastIoWrite_2,
                 LOGPTR(FileObject->FsContext2));
    }

    return ReturnValue;
}

BOOLEAN
RxFastLock (
    IN PFILE_OBJECT      FileObject,
    IN PLARGE_INTEGER    FileOffset,
    IN PLARGE_INTEGER    Length,
    PEPROCESS            ProcessId,
    ULONG                Key,
    BOOLEAN              FailImmediately,
    BOOLEAN              ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT    DeviceObject
    )
/*++

Routine Description:

    This is a call back routine for doing the fast lock call.

Arguments:

    FileObject - Supplies the file object used in this operation

    FileOffset - Supplies the file offset used in this operation

    Length - Supplies the length used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    FailImmediately - Indicates if the request should fail immediately
        if the lock cannot be granted.

    ExclusiveLock - Indicates if this is a request for an exclusive or
        shared lock

    IoStatus - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results;
    PFCB Fcb = (PFCB)(FileObject->FsContext); //need a macro

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxFastLock\n", 0));

    //
    //  Decode the type of file object we're being asked to process and make
    //  sure it is only a user file open.
    //

    if (NodeType(Fcb) != RDBSS_NTC_STORAGE_TYPE_FILE) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        IoStatus->Information = 0;

        RxDbgTrace(-1, Dbg, ("RxFastLock -> TRUE (RxStatus(INVALID_PARAMETER))\n", 0));
        return TRUE;
    }

    RxDbgTrace(-1, Dbg, ("RxFastLock -> FALSE (fastlocks not yet implemented)\n", 0));
    return FALSE; //stuff past here has been massaged but not tested

    //
    //  Acquire exclusive access to the Fcb this operation can always wait; you need
    //  the resource to synchronize with oplock breaks
    //

    FsRtlEnterFileSystem();

    ExAcquireResourceSharedLite( Fcb->Header.Resource, TRUE );

    try {

        //
        //  We check whether we can proceed
        //  based on the state of the file oplocks.
        //

        if (!FsRtlOplockIsFastIoPossible( &(Fcb)->Specific.Fcb.Oplock )) {

            try_return( Results = FALSE );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request
        //

        if (Results = FsRtlFastLock(
                          &Fcb->Specific.Fcb.FileLock,
                          FileObject,
                          FileOffset,
                          Length,
                          ProcessId,
                          Key,
                          FailImmediately,
                          ExclusiveLock,
                          IoStatus,
                          NULL,
                          FALSE )) {
            //
            //  Set the flag indicating if Fast I/O is possible
            //

            //Fcb->Header.IsFastIoPossible = RxIsFastIoPossible( Fcb );
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( RxFastLock );

        //
        //  Release the Fcb, and return to our caller
        //

        ExReleaseResourceLite( (Fcb)->Header.Resource );

        FsRtlExitFileSystem();

        RxDbgTrace(-1, Dbg, ("RxFastLock -> %08lx\n", Results));
    }

    return Results;
}

BOOLEAN
RxFastUnlockSingle (
    IN PFILE_OBJECT      FileObject,
    IN PLARGE_INTEGER    FileOffset,
    IN PLARGE_INTEGER    Length,
    PEPROCESS            ProcessId,
    ULONG                Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT    DeviceObject
    )
/*++

Routine Description:

    This is a call back routine for doing the fast unlock single call.

Arguments:

    FileObject - Supplies the file object used in this operation

    FileOffset - Supplies the file offset used in this operation

    Length - Supplies the length used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results;
    PFCB Fcb = (PFCB)(FileObject->FsContext);              //need macro

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxFastUnlockSingle\n", 0));

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and make sure
    //  it is only a user file open
    //

    if (NodeType(Fcb) != RDBSS_NTC_STORAGE_TYPE_FILE) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;

        RxDbgTrace(-1, Dbg, ("RxFastUnlockSingle -> TRUE (RxStatus(INVALID_PARAMETER))\n", 0));
        return TRUE;
    }

    RxDbgTrace(-1, Dbg, ("RxFastUnlockSingle -> FALSE (fastlocks not yet implemented)\n", 0));
    return FALSE; //stuff past here has been massaged but not tested

    //
    //  Acquire exclusive access to the Fcb this operation can always wait
    //

    FsRtlEnterFileSystem();

    ExAcquireResourceSharedLite( Fcb->Header.Resource, TRUE );

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if (!FsRtlOplockIsFastIoPossible( &(Fcb)->Specific.Fcb.Oplock )) {

            try_return( Results = FALSE );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockSingle(
                               &Fcb->Specific.Fcb.FileLock,
                               FileObject,
                               FileOffset,
                               Length,
                               ProcessId,
                               Key,
                               NULL,
                               FALSE );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        //Fcb->Header.IsFastIoPossible = RxIsFastIoPossible( Fcb );

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( RxFastUnlockSingle );

        //
        //  Release the Fcb, and return to our caller
        //

        ExReleaseResourceLite( (Fcb)->Header.Resource );

        FsRtlExitFileSystem();

        RxDbgTrace(-1, Dbg, ("RxFastUnlockSingle -> %08lx\n", Results));
    }

    return Results;
}


BOOLEAN
RxFastUnlockAll (
    IN PFILE_OBJECT      FileObject,
    PEPROCESS            ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT    DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock all call.

Arguments:

    FileObject - Supplies the file object used in this operation

    ProcessId - Supplies the process ID used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results;
    PFCB Fcb = (PFCB)(FileObject->FsContext); //need macro

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxFastUnlockAll\n", 0));

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and make sure
    //  it is only a user file open.
    //

    if (NodeType(Fcb) != RDBSS_NTC_STORAGE_TYPE_FILE) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;

        RxDbgTrace(-1, Dbg, ("RxFastUnlockAll -> TRUE (RxStatus(INVALID_PARAMETER))\n", 0));
        return TRUE;
    }

    RxDbgTrace(-1, Dbg, ("RxFastUnlockAll -> FALSE (fastlocks not yet implemented)\n", 0));
    return FALSE; //stuff past here has been massaged but not tested

    //
    //  Acquire exclusive access to the Fcb this operation can always wait
    //

    FsRtlEnterFileSystem();

    (VOID) ExAcquireResourceSharedLite( Fcb->Header.Resource, TRUE );

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if (!FsRtlOplockIsFastIoPossible( &(Fcb)->Specific.Fcb.Oplock )) {

            try_return( Results = FALSE );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockAll(
                               &Fcb->Specific.Fcb.FileLock,
                               FileObject,
                               ProcessId,
                               NULL );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        //Fcb->Header.IsFastIoPossible = RxIsFastIoPossible( Fcb );

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( RxFastUnlockAll );

        //
        //  Release the Fcb, and return to our caller
        //

        ExReleaseResourceLite( (Fcb)->Header.Resource );

        FsRtlExitFileSystem();

        RxDbgTrace(-1, Dbg, ("RxFastUnlockAll -> %08lx\n", Results));
    }

    return Results;
}


BOOLEAN
RxFastUnlockAllByKey (
    IN PFILE_OBJECT      FileObject,
    PVOID                ProcessId,
    ULONG                Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT    DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock all by key call.

Arguments:

    FileObject - Supplies the file object used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results;
    PFCB Fcb = (PFCB)(FileObject->FsContext); //need macro

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxFastUnlockAllByKey\n", 0));

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and make sure
    //  it is only a user file open.
    //

    if (NodeType(Fcb) != RDBSS_NTC_STORAGE_TYPE_FILE) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;

        RxDbgTrace(-1, Dbg, ("RxFastUnlockAll -> TRUE (RxStatus(INVALID_PARAMETER))\n", 0));
        return TRUE;
    }

    RxDbgTrace(-1, Dbg, ("RxFastUnlockAll -> FALSE (fastlocks not yet implemented)\n", 0));
    return FALSE; //stuff past here has been massaged but not tested

    //
    //  Acquire exclusive access to the Fcb this operation can always wait
    //

    FsRtlEnterFileSystem();

    (VOID) ExAcquireResourceSharedLite( Fcb->Header.Resource, TRUE );

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if (!FsRtlOplockIsFastIoPossible( &(Fcb)->Specific.Fcb.Oplock )) {

            try_return( Results = FALSE );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockAllByKey(
                               &Fcb->Specific.Fcb.FileLock,
                               FileObject,
                               ProcessId,
                               Key,
                               NULL );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        //Fcb->Header.IsFastIoPossible = RxIsFastIoPossible( Fcb );

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( RxFastUnlockAllByKey );

        //
        //  Release the Fcb, and return to our caller
        //

        ExReleaseResourceLite( (Fcb)->Header.Resource );

        FsRtlExitFileSystem();

        RxDbgTrace(-1, Dbg, ("RxFastUnlockAllByKey -> %08lx\n", Results));
    }

    return Results;
}


#define RxLogAndReturnFalse(x) { \
    RxLog(("CheckFast fail %lx %s",FileObject,x)); \
    RxWmiLog(LOG,                                  \
             RxFastIoCheckIfPossible,              \
             LOGPTR(FileObject)                  \
             LOGARSTR(x));                         \
    return FALSE;                                  \
}
BOOLEAN
RxFastIoCheckIfPossible (
    IN PFILE_OBJECT      FileObject,
    IN PLARGE_INTEGER    FileOffset,
    IN ULONG             Length,
    IN BOOLEAN           Wait,
    IN ULONG             LockKey,
    IN BOOLEAN           CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT    DeviceObject
    )

/*++

Routine Description:

    This routine checks if fast i/o is possible for a read/write operation

Arguments:

    FileObject - Supplies the file object used in the query

    FileOffset - Supplies the starting byte offset for the read/write operation

    Length - Supplies the length, in bytes, of the read/write operation

    Wait - Indicates if we can wait

    LockKey - Supplies the lock key

    CheckForReadOperation - Indicates if this is a check for a read or write
        operation

    IoStatus - Receives the status of the operation if our return value is
        FastIoReturnError

Return Value:

    BOOLEAN - TRUE if fast I/O is possible and FALSE if the caller needs
        to take the long route.

--*/

{
    PFCB Fcb = (PFCB)(FileObject->FsContext);
    PFOBX Fobx = (PFOBX)(FileObject->FsContext2);
    PSRV_OPEN pSrvOpen = Fobx->SrvOpen;

    LARGE_INTEGER LargeLength;

    PAGED_CODE();

    if (NodeType(Fcb) != RDBSS_NTC_STORAGE_TYPE_FILE) {
        RxLogAndReturnFalse("notfile");
    }

    if (!FsRtlOplockIsFastIoPossible( &Fcb->Specific.Fcb.Oplock )) {
        RxLogAndReturnFalse("cnd/oplock");
    }

    if (FileObject->DeletePending) {
        RxLogAndReturnFalse("delpend");
    }

    if (Fcb->NonPaged->OutstandingAsyncWrites != 0) {
        RxLogAndReturnFalse("asynW");
    }

    if (FlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_ORPHANED)) {
        RxLogAndReturnFalse("srvopen orphaned");
    }
    
    if (FlagOn(Fcb->FcbState,FCB_STATE_ORPHANED)) {
        RxLogAndReturnFalse("orphaned");
    }

    if (BooleanFlagOn(
            pSrvOpen->Flags,
        SRVOPEN_FLAG_BUFFERING_STATE_CHANGE_PENDING)) {
        RxLogAndReturnFalse("buf state change");
    }

    if (FlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_FILE_RENAMED) ||
        FlagOn(pSrvOpen->Flags,SRVOPEN_FLAG_FILE_DELETED)) {
        RxLogAndReturnFalse("ren/del");
    }

    // Ensure that all pending buffering state change requests are processed
    // before letting the operation through.

    FsRtlEnterFileSystem();

    RxProcessChangeBufferingStateRequestsForSrvOpen(pSrvOpen);

    FsRtlExitFileSystem();

    LargeLength.QuadPart = Length;

    //
    //  Based on whether this is a read or write operation we call
    //  fsrtl check for read/write
    //

    if (CheckForReadOperation) {
        if (!FlagOn(Fcb->FcbState,FCB_STATE_READCACHEING_ENABLED)) {
            RxLogAndReturnFalse("notreadC");
        }

        if (!FsRtlFastCheckLockForRead(
                &Fcb->Specific.Fcb.FileLock,
                FileOffset,
                &LargeLength,
                LockKey,
                FileObject,
                PsGetCurrentProcess() )) {

            RxLogAndReturnFalse("readlock");
        }

    } else {

        if (!FlagOn(Fcb->FcbState,FCB_STATE_WRITECACHEING_ENABLED)) {
            RxLogAndReturnFalse("notwriteC");
        }

        //
        //  Also check for a write-protected volume here.
        //

        if (!FsRtlFastCheckLockForWrite(
                &Fcb->Specific.Fcb.FileLock,
                FileOffset,
                &LargeLength,
                LockKey,
                FileObject,
                PsGetCurrentProcess() )) {

            RxLogAndReturnFalse("writelock");
        }
    }

    // RxLog(("IoPossible %lx",FileObject));
    return TRUE;
}

BOOLEAN
RxFastIoDeviceControl(
    IN struct _FILE_OBJECT   *FileObject,
    IN BOOLEAN               Wait,
    IN PVOID                 InputBuffer OPTIONAL,
    IN ULONG                 InputBufferLength,
    OUT PVOID                OutputBuffer OPTIONAL,
    IN ULONG                 OutputBufferLength,
    IN ULONG                 IoControlCode,
    OUT PIO_STATUS_BLOCK     IoStatus,
    IN struct _DEVICE_OBJECT *DeviceObject
    )
/*++

Routine Description:

    This routine is for the fast device control call.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    InputBuffer - Supplies the input buffer

    InputBufferLength - the length of the input buffer

    OutputBuffer - the output buffer

    OutputBufferLength - the length of the output buffer

    IoControlCode - the IO control code

    IoStatus - Receives the final status of the operation

    DeviceObject - the associated device object

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

Notes:

    The following IO control requests are handled in the first path

    IOCTL_LMR_ARE_FILE_OBJECTS_ON_SAME_SERVER

        InputBuffer - pointer to the other file object

        InputBufferLength - length in bytes of a pointer.

        OutputBuffer - not used

        OutputBufferLength - not used

        IoStatus --

            IoStatus.Status set to STATUS_SUCCESS if both the file objects are
            on the same server, otherwise set to STATUS_NOT_SAME_DEVICE

    This is a kernel mode interface only.

--*/
{
    BOOLEAN FastIoSucceeded;

    switch (IoControlCode) {
    case IOCTL_LMR_ARE_FILE_OBJECTS_ON_SAME_SERVER :
        {
            FastIoSucceeded = TRUE;

            try {
                if (InputBufferLength == sizeof(HANDLE)) {
                    PFCB         pFcb1,pFcb2;
                    HANDLE       hFile;
                    PFILE_OBJECT pFileObject2;
                    NTSTATUS     Status;    

                    pFcb1 = (PFCB)FileObject->FsContext;

                    RtlCopyMemory(
                        &hFile,
                        InputBuffer,
                        sizeof(HANDLE));

                    Status = ObReferenceObjectByHandle(
                                 hFile,
                                 FILE_ANY_ACCESS,
                                 *IoFileObjectType,
                                 UserMode,
                                 &pFileObject2,
                                 NULL);

                    if ((Status == STATUS_SUCCESS)) {

                        if(pFileObject2->DeviceObject == DeviceObject) {

                            pFcb2 = (PFCB)pFileObject2->FsContext;

                            if ((pFcb2 != NULL) &&
                                (NodeTypeIsFcb(pFcb2))) {
                                if (pFcb1->pNetRoot->pSrvCall == pFcb2->pNetRoot->pSrvCall) {
                                    IoStatus->Status = STATUS_SUCCESS;
                                } else {
                                    IoStatus->Status = STATUS_NOT_SAME_DEVICE;
                                }
                            } else {
                                Status = STATUS_INVALID_PARAMETER;
                            }
                        } else {
                            Status = STATUS_INVALID_PARAMETER;
                        }
                        
                        ObDereferenceObject(pFileObject2);
                    
                    } else {
                        IoStatus->Status = STATUS_INVALID_PARAMETER;
                    }
                } else {
                    IoStatus->Status = STATUS_INVALID_PARAMETER;
                }
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                //  The I/O request was not handled successfully, abort the I/O request with
                //  the error status that we get back from the execption code

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                FastIoSucceeded = TRUE;
            }
        }
        break;

    default:
        {
            FastIoSucceeded = FALSE;
        }
    }

    return FastIoSucceeded;
}


BOOLEAN
RxFastQueryBasicInfo (
    IN PFILE_OBJECT                FileObject,
    IN BOOLEAN                     Wait,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK           IoStatus,
    IN PDEVICE_OBJECT              DeviceObject
    )
/*++

Routine Description:

    This routine is for the fast query call for basic file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/
{
    BOOLEAN Results = FALSE;
    PFCB Fcb = (PFCB)(FileObject->FsContext);
    PFOBX Fobx = (PFOBX)(FileObject->FsContext2);
    NODE_TYPE_CODE TypeOfOpen = NodeType(Fcb);

    BOOLEAN FcbAcquired = FALSE;

    PAGED_CODE();

    //
    //  Determine the type of open for the input file object and only accept
    //  the user file or directory open
    //

    if ((TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE) &&
        (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_DIRECTORY)) {

        return Results;
    }

    FsRtlEnterFileSystem();

    //
    //  Get access to the Fcb but only if it is not the paging file
    //

    if (!FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

        if (!ExAcquireResourceSharedLite( Fcb->Header.Resource, Wait )) {

            FsRtlExitFileSystem();
            return Results;
        }

        FcbAcquired = TRUE;
    }

    try {

        //
        //  Set it to indicate that the query is a normal file.
        //  Later we might overwrite the attribute.
        //

        Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;

        //
        //  If the fcb is not the root dcb then we will fill in the
        //  buffer otherwise it is all setup for us.
        //

        if (NodeType(Fcb) != RDBSS_NTC_ROOT_DCB) {

            //
            //  Extract the data and fill in the non zero fields of the output
            //  buffer
            //

            Buffer->LastWriteTime = Fcb->LastWriteTime;
            Buffer->ChangeTime = Fcb->LastChangeTime;
            Buffer->CreationTime = Fcb->CreationTime;
            Buffer->LastAccessTime = Fcb->LastAccessTime;

            //
            //  Zero out the field we don't support.
            //

            Buffer->ChangeTime = RxLargeZero;

            if (Fcb->Attributes != 0) {

                Buffer->FileAttributes = Fcb->Attributes;

            } else {

                Buffer->FileAttributes = FILE_ATTRIBUTE_NORMAL;

            }

        } else {

            Buffer->FileAttributes = FILE_ATTRIBUTE_DIRECTORY;
        }

        //
        //  If the temporary flag is set, then set it in the buffer.
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_TEMPORARY )) {

            SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY );
        }

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = sizeof(FILE_BASIC_INFORMATION);

        Results = TRUE;

    } finally {

        if (FcbAcquired) { ExReleaseResourceLite( Fcb->Header.Resource ); }

        FsRtlExitFileSystem();
    }

    //
    //  And return to our caller
    //

    return Results;
}


BOOLEAN
RxFastQueryStdInfo (
    IN PFILE_OBJECT                   FileObject,
    IN BOOLEAN                        Wait,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK              IoStatus,
    IN PDEVICE_OBJECT                 DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for standard file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;

    PFCB Fcb = (PFCB)(FileObject->FsContext);
    PFOBX Fobx = (PFOBX)(FileObject->FsContext2);
    NODE_TYPE_CODE TypeOfOpen = NodeType(Fcb);

    BOOLEAN FcbAcquired = FALSE;

    PAGED_CODE();

    //
    //  Determine the type of open for the input file object and only accept
    //  the user file or directory open
    //

    if ((TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE) &&
        (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_DIRECTORY)) {

        return Results;
    }

    //
    //  Get access to the Fcb but only if it is not the paging file
    //

    FsRtlEnterFileSystem();

    if (!FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

        if (!ExAcquireResourceSharedLite( Fcb->Header.Resource, Wait )) {

            FsRtlExitFileSystem();
            return Results;
        }

        FcbAcquired = TRUE;
    }

    try {

        Buffer->NumberOfLinks = 1;
        Buffer->DeletePending = BooleanFlagOn( Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE );

        //
        //  Case on whether this is a file or a directory, and extract
        //  the information and fill in the fcb/dcb specific parts
        //  of the output buffer.
        //

        if (NodeType(Fcb) == RDBSS_NTC_FCB) {

            //
            //  If we don't alread know the allocation size, we cannot look
            //  it up in the fast path.
            //

            if (Fcb->Header.AllocationSize.LowPart == 0xffffffff) {

                try_return( Results );
            }

            Buffer->AllocationSize = Fcb->Header.AllocationSize;
            Buffer->EndOfFile = Fcb->Header.FileSize;

            Buffer->Directory = FALSE;

        } else {

            Buffer->AllocationSize = RxLargeZero;
            Buffer->EndOfFile = RxLargeZero;

            Buffer->Directory = TRUE;
        }

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = sizeof(FILE_STANDARD_INFORMATION);

        Results = TRUE;

    try_exit: NOTHING;
    } finally {

        if (FcbAcquired) { ExReleaseResourceLite( Fcb->Header.Resource ); }

        FsRtlExitFileSystem();
    }

    //
    //  And return to our caller
    //

    return Results;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ntexcept.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    NtExcept.c

Abstract:

    This module declares the exception handlers for the NTwrapper.

Author:

    JoeLinn     [JoeLinn]    1-Dec-94

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "prefix.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (RDBSS_BUG_CHECK_NTEXCEPT)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CATCH_EXCEPTIONS)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxProcessException)
#pragma alloc_text(PAGE, RxPopUpFileCorrupt)
#endif

PCONTEXT RxExpCXR;
PEXCEPTION_RECORD RxExpEXR;
PVOID RxExpAddr;
NTSTATUS RxExpCode;


LONG
RxExceptionFilter (
    IN PRX_CONTEXT RxContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    This routine is used to decide if we should or should not handle
    an exception status that is being raised.  It first determines the true exception
    code by examining the exception record. If there is an Irp Context, then it inserts the status
    into the RxContext. Finally, it determines whether to handle the exception or bugcheck
    according to whether the except is one of the expected ones. in actuality, all exceptions are expected
    except for some lowlevel machine errors (see fsrtl\filter.c)

Arguments:

    RxContext    - the irp context of current operation for storing away the code.

    ExceptionPointer - Supplies the exception context.

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER or bugchecks

--*/

{
    NTSTATUS ExceptionCode;

    //save these values in statics so i can see 'em on the debugger............
    ExceptionCode = RxExpCode = ExceptionPointer->ExceptionRecord->ExceptionCode;
    RxExpAddr = ExceptionPointer->ExceptionRecord->ExceptionAddress;
    RxExpEXR  = ExceptionPointer->ExceptionRecord;
    RxExpCXR  = ExceptionPointer->ContextRecord;

    RxLog(("!!! %lx %lx %lx %lx\n", RxExpCode, RxExpAddr, RxExpEXR, RxExpCXR));
    RxWmiLog(LOG,
             RxExceptionFilter_1,
             LOGULONG(RxExpCode)
             LOGPTR(RxExpAddr)
             LOGPTR(RxExpEXR)
             LOGPTR(RxExpCXR));

    RxDbgTrace(0, (DEBUG_TRACE_UNWIND), ("RxExceptionFilter %X at %X\n", RxExpCode, RxExpAddr));
    RxDbgTrace(0, (DEBUG_TRACE_UNWIND), ("RxExceptionFilter EXR=%X, CXR=%X\n", RxExpEXR, RxExpCXR));

    if (RxContext == NULL) {
        //we cannot do anything even moderately sane
        return EXCEPTION_EXECUTE_HANDLER;
    }

    IF_DEBUG {
        if (!FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT)) {
            //DbgBreakPoint();
        }
    }

    //
    // If the exception is RxStatus(IN_PAGE_ERROR), get the I/O error code
    // from the exception record.
    //

    if (ExceptionCode == STATUS_IN_PAGE_ERROR) {
        RxLog(("InPageError...."));
        RxWmiLog(LOG,
                 RxExceptionFilter_2,
                 LOGPTR(RxContext));
        if (ExceptionPointer->ExceptionRecord->NumberParameters >= 3) {
            ExceptionCode = (NTSTATUS)ExceptionPointer->ExceptionRecord->ExceptionInformation[2];
        }
    }

#if 0
this code was used back when we thought we could do something sane w/o a context........as it stands now
we cannot call RxProcessException without a context so we might as well punt right now.......... actually,
the punting code is earlier......
    //
    //  If there is not an irp context, we must have had insufficient resources.
    //

//    if ( !ARGUMENT_PRESENT( RxContext )
//         || ( RxContext->MajorFunction == IRP_MJ_CLOSE )  ) {
    if ( RxContext==NULL ) {

        ASSERT(ExceptionCode==STATUS_INSUFFICIENT_RESOURCES);

        if (!FsRtlIsNtstatusExpected( ExceptionCode )) {

            RxBugCheck( (ULONG)ExceptionPointer->ExceptionRecord,
                         (ULONG)ExceptionPointer->ContextRecord,
                         (ULONG)ExceptionPointer->ExceptionRecord->ExceptionAddress );
        }

        return EXCEPTION_EXECUTE_HANDLER;
    }
#endif

    if ( RxContext->StoredStatus == 0 ) {

        if (FsRtlIsNtstatusExpected( ExceptionCode )) {

            RxContext->StoredStatus = ExceptionCode;

            return EXCEPTION_EXECUTE_HANDLER;

        } else {

            RxBugCheck( (ULONG_PTR)ExceptionPointer->ExceptionRecord,
                         (ULONG_PTR)ExceptionPointer->ContextRecord,
                         (ULONG_PTR)ExceptionPointer->ExceptionRecord->ExceptionAddress );
        }

    } else {

        //
        //  We raised this code explicitly ourselves, so it had better be
        //  expected.
        //

        ASSERT( FsRtlIsNtstatusExpected( ExceptionCode ) );
    }

    return EXCEPTION_EXECUTE_HANDLER;
}

NTSTATUS
RxProcessException (
    IN PRX_CONTEXT RxContext,
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This routine processes an exception.  It either completes the request
    with the saved exception status or it bugchecks


Arguments:

    RxContext - Context of the current operation

    ExceptionCode - Supplies the normalized exception status being handled

Return Value:

    RXSTATUS - Returns the results of either posting the Irp or the
        saved completion status.

--*/

{
    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("RxProcessException\n", 0));

    if ( RxContext == NULL ) {

        // we cannot do anything even moderately sane without a context..........sigh

        //DbgBreakPoint();
        RxBugCheck( 0,0,0 );  //this shouldn't happen.
    }

    //
    //  Get the  exception status from RxContext->StoredStatus as stored there by
    //  the exception filter., and
    //  reset it.  Also copy it to the Irp in case it isn't already there
    //

    ExceptionCode = RxContext->StoredStatus;

    if (!FsRtlIsNtstatusExpected( ExceptionCode )) {

        RxBugCheck( 0,0,0 );  //this shouldn't happen. we should have BC'd in the filter
    }

    if (RxContext->MajorFunction == IRP_MJ_CREATE) {
        RxpPrepareCreateContextForReuse(RxContext);
    }

    {
        RxCaptureFcb;

        PAGED_CODE();

        if (capFcb != NULL) {

            if (RxContext->FcbResourceAcquired) {

                RxDbgTrace( 0, Dbg,("RxCommonWrite     ReleasingFcb\n"));
                __RxReleaseFcb(RxContext, (PMRX_FCB)(capFcb)
#ifdef RDBSS_TRACKER
                          ,__LINE__,__FILE__,0
#endif
                    );
                RxContext->FcbResourceAcquired = FALSE;
            }

            if (RxContext->FcbPagingIoResourceAcquired) {
                RxDbgTrace( 0, Dbg,("RxCommonWrite     ReleasingPaginIo\n"));
                RxReleasePagingIoResource(capFcb,RxContext);
            }
        }
    }

    RxCompleteContextAndReturn( ExceptionCode );
}

VOID
RxPopUpFileCorrupt (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    The Following routine makes an informational popup that the file
    is corrupt.

Arguments:

    Fcb - The file that is corrupt.

Return Value:

    None.

--*/

{
    PKTHREAD Thread;
    RxCaptureRequestPacket;

    PAGED_CODE();

    //if (Fcb->FullFileName.Buffer == NULL) {
    //
    //    RxSetFullFileNameInFcb( RxContext, Fcb );
    //}

    //
    //  We never want to block a system thread waiting for the user to
    //  press OK.
    //

    if (IoIsSystemThread(capReqPacket->Tail.Overlay.Thread)) {

       Thread = NULL;

    } else {

       Thread = capReqPacket->Tail.Overlay.Thread;
    }

    IoRaiseInformationalHardError( STATUS_FILE_CORRUPT_ERROR,
                                   &Fcb->FcbTableEntry.Path,  //&Fcb->FullFileName,
                                   Thread);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ntinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxInit.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for the RDBSS.

    Also, the routines for pagingio resource selection/allocation are here; since
    we have to delete the resources when we unload, having them here simply centralizes
    all the pagingio resource stuff.

    Finally, the routines that are here that implement the wrapper's version of
    network provider order. Basically, the wrapper MUST implement the same concept of
    network provider order as the MUP so that the UI will work as expected. So, we
    read the provider order from the registry at init time and memorize the order. Then,
    we can assign the correct order when minirdrs register. Obviously, provider order is
    not an issue in MONOLITHIC mode.

Author:

    Joe Linn [JoeLinn]    20-jul-1994

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop
#include "ntverp.h"
#include "NtDdNfs2.h"
#include "netevent.h"

//
//  The local debug trace level
//

#define Dbg                              (0)

ULONG RxBuildNumber = VER_PRODUCTBUILD;
#ifdef RX_PRIVATE_BUILD
ULONG RxPrivateBuild = 1;
#else
ULONG RxPrivateBuild = 0;
#endif

#ifdef MONOLITHIC_MINIRDR
RDBSS_DEVICE_OBJECT RxSpaceForTheWrappersDeviceObject;
#endif

#define LANMAN_WORKSTATION_PARAMETERS \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\LanmanWorkStation\\Parameters"

BOOLEAN DisableByteRangeLockingOnReadOnlyFiles = FALSE;

VOID
RxReadRegistryParameters();
      
NPAGED_LOOKASIDE_LIST RxContextLookasideList;

VOID
RxGetRegistryParameters(
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
RxInitializeRegistrationStructures(
    void
    );
VOID
RxUninitializeRegistrationStructures(
    void
    );

VOID
RxAbbreviatedWriteLogEntry__ (
    IN NTSTATUS Status,
    IN ULONG    OneExtraUlong
    );
#define RxAbbreviatedWriteLogEntry(STATUS__) RxAbbreviatedWriteLogEntry__(STATUS__,__LINE__)


NTSTATUS
RxGetStringRegistryParameter(
    HANDLE ParametersHandle,
    PWCHAR ParameterName,
    PUNICODE_STRING ParamString,
    PKEY_VALUE_PARTIAL_INFORMATION Value,
    ULONG ValueSize,
    BOOLEAN LogFailure
    );

NTSTATUS
RxGetUlongRegistryParameter(
    HANDLE ParametersHandle,
    PWCHAR ParameterName,
    PULONG ParamUlong,
    PKEY_VALUE_PARTIAL_INFORMATION Value,
    ULONG ValueSize,
    BOOLEAN LogFailure
    );

//this type and variable are used for unwinding the initialization so that stuff doesn't go thru the cracks
// the way that this works is that stuff is done in the reverse order of the enumeration. that way i can just
// use a switch-no-break to unwind.
typedef enum _RX_INIT_STATES {
    RXINIT_ALL_INITIALIZATION_COMPLETED,
    RXINIT_CONSTRUCTED_PROVIDERORDER,
    RXINIT_CREATED_LOG,
    RXINIT_CREATED_DEVICE_OBJECT,
    RXINIT_CREATED_FIRST_LINK,
    RXINIT_START
} RX_INIT_STATES;

VOID
RxInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN RX_INIT_STATES RxInitState
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, RxDriverEntry)
#pragma alloc_text(INIT, RxGetRegistryParameters)
#pragma alloc_text(INIT, RxGetStringRegistryParameter)
#pragma alloc_text(INIT, RxGetUlongRegistryParameter)
#pragma alloc_text(INIT, RxAbbreviatedWriteLogEntry__)
#pragma alloc_text(PAGE, RxUnload)
#pragma alloc_text(PAGE, RxInitUnwind)
#pragma alloc_text(PAGE, RxGetNetworkProviderPriority)
#pragma alloc_text(PAGE, RxInitializeRegistrationStructures)
#pragma alloc_text(PAGE, RxUninitializeRegistrationStructures)
#pragma alloc_text(PAGE, RxInitializeMinirdrDispatchTable)
#pragma alloc_text(PAGE, __RxFillAndInstallFastIoDispatch)
#pragma alloc_text(PAGE, RxReadRegistryParameters)
#endif

#define RX_SYMLINK_NAME L"\\??\\fsWrap"

BOOLEAN EnableWmiLog = FALSE;

NTSTATUS
RxDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the Rx file system
    device driver.  This routine creates the device object for the FileSystem
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    RXSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS Status;
    RX_INIT_STATES RxInitState = 0;
#ifndef MONOLITHIC_MINIRDR
    UNICODE_STRING UnicodeString,LinkName;
#endif

    //Structure checks
    RxCheckFcbStructuresForAlignment(); //this will bugcheck if things are bad

    //
    //  Initialize the global data structures


    ZeroAndInitializeNodeType( &RxData, RDBSS_NTC_DATA_HEADER, sizeof(RDBSS_DATA));
    RxData.DriverObject = DriverObject;

    ZeroAndInitializeNodeType( &RxDeviceFCB, RDBSS_NTC_DEVICE_FCB, sizeof(FCB));

    KeInitializeSpinLock( &RxStrucSupSpinLock );
    RxExports.pRxStrucSupSpinLock = &RxStrucSupSpinLock;

    RxInitializeDebugSupport();

    try {

        Status = RXINIT_START;

#ifndef MONOLITHIC_MINIRDR
        //
        // Create a symbolic link from \\dosdevices\fswrap to the rdbss device object name

        RtlInitUnicodeString(&LinkName, RX_SYMLINK_NAME);
        RtlInitUnicodeString(&UnicodeString, DD_NFS2_DEVICE_NAME_U);

        IoDeleteSymbolicLink(&LinkName);
        Status = IoCreateSymbolicLink(&LinkName, &UnicodeString);

        if (!NT_SUCCESS( Status )) {
            try_return( Status );
        }
        RxInitState = RXINIT_CREATED_FIRST_LINK;

        //
        // Create the device object.

        Status = IoCreateDevice(DriverObject,
                                sizeof(RDBSS_DEVICE_OBJECT) - sizeof(DEVICE_OBJECT),
                                &UnicodeString,
                                FILE_DEVICE_NETWORK_FILE_SYSTEM,
                                FILE_REMOTE_DEVICE,
                                FALSE,
                                (PDEVICE_OBJECT *)(&RxFileSystemDeviceObject));

        if (!NT_SUCCESS( Status )) {
            try_return( Status );
        }
        RxInitState = RXINIT_CREATED_DEVICE_OBJECT;

#else

// in monolithic mode, the wrapper doesn't really need a device object but
//   we allocate stuff in the wrapper's device object in order to appropriately throttle
//   thread usage per device object.
        RxFileSystemDeviceObject = &RxSpaceForTheWrappersDeviceObject;
        RtlZeroMemory(RxFileSystemDeviceObject,sizeof(RxSpaceForTheWrappersDeviceObject));

#endif
        //
        // Initialize the trace and logging facilities. loginit is a big allocation.

        RxInitializeDebugTrace();

        RxInitializeLog();

        RxInitState = RXINIT_CREATED_LOG;

        RxGetRegistryParameters(RegistryPath);
        RxDbgTrace(0, (DEBUG_TRACE_ALWAYS), ("Constants %08lx %08lx\n",
                   RX_CONTEXT_FLAG_WAIT,
                   RX_CONTEXT_CREATE_FLAG_ADDEDBACKSLASH
                   ));

        RxReadRegistryParameters();

        //
        // Initialize the minirdr registration facilities.

        Status = RxInitializeRegistrationStructures();

        if (!NT_SUCCESS( Status )) {
            try_return( Status );
        }
        RxInitState = RXINIT_CONSTRUCTED_PROVIDERORDER;

  try_exit: NOTHING;
    } finally {
        if (Status != STATUS_SUCCESS) {
            RxLogFailure (
                RxFileSystemDeviceObject,
                NULL,
                EVENT_RDR_UNEXPECTED_ERROR,
                Status);

            RxInitUnwind(DriverObject,RxInitState);
        }
    }

    if (Status != STATUS_SUCCESS) {
        return(Status);
    }

        //
    //
    //
    //
    //       #####     ##    #    #   ####   ######  #####
    //       #    #   #  #   ##   #  #    #  #       #    #
    //       #    #  #    #  # #  #  #       #####   #    #
    //       #    #  ######  #  # #  #  ###  #       #####
    //       #    #  #    #  #   ##  #    #  #       #   #
    //       #####   #    #  #    #   ####   ######  #    #
    //
    //
    //
    //  EVERYTHING FROM HERE DOWN BETTER WORK BECAUSE THERE IS NO MORE UNWINDING!!!
    //
    //


    RxInitializeDispatcher();
    RxInitializeBackoffPackage();

    // Initialize the look aside list for RxContext allocation
    ExInitializeNPagedLookasideList(
        &RxContextLookasideList,
        ExAllocatePoolWithTag,
        ExFreePool,
        0,
        sizeof(RX_CONTEXT),
        RX_IRPC_POOLTAG,
        4);

    // Initialize the list of transport Irps to an empty list
    InitializeListHead(&RxIrpsList);
    KeInitializeSpinLock(&RxIrpsListSpinLock);
    
    // Initialize the list of active contexts to an empty list
    InitializeListHead(&RxActiveContexts);

    // Initialize the list of srv call downs active
    InitializeListHead(&RxSrvCalldownList);

    // a fastmutex is used to serialize access to the Qs that serialize blocking pipe operations
    ExInitializeFastMutex(&RxContextPerFileSerializationMutex);

    // and to serialize access to the Qs that serialize some pagingio operations
    ExInitializeFastMutex(&RxLowIoPagingIoSyncMutex);

    // Initialize the scavenger mutex
    KeInitializeMutex(&RxScavengerMutex,1);

    // Initialize the global serialization Mutex.
    KeInitializeMutex(&RxSerializationMutex,1);

    //
    //  Initialize the wrapper's overflow queue
    //

    {
        PRDBSS_DEVICE_OBJECT MyDo = (PRDBSS_DEVICE_OBJECT)RxFileSystemDeviceObject;
        LONG Index;

        for (Index = 0; Index < MaximumWorkQueue; Index++) {
            MyDo->OverflowQueueCount[Index] = 0;

            InitializeListHead( &MyDo->OverflowQueue[Index] );

            MyDo->PostedRequestCount[Index] = 0;
        }

        KeInitializeSpinLock( &MyDo->OverflowQueueSpinLock );
    }

    //
    //      Initialize dispatch vector for driver object AND ALSO FOR the devicefcb

    RxInitializeDispatchVectors(DriverObject);
    ExInitializeResourceLite( &RxData.Resource );

    //
    //  Set up global pointer to our process.

    RxData.OurProcess = PsGetCurrentProcess();

    //
    //  Put in a bunch of sanity checks about various structures...hey, it's init code!

    IF_DEBUG {
        ULONG FcbStateBufferingMask = FCB_STATE_BUFFERING_STATE_MASK;
        ULONG MinirdrBufStateCommandMask = MINIRDR_BUFSTATE_COMMAND_MASK;
        USHORT EightBitsPerChar = 8;

        //we could put in defines for the ULONG/USHORTS here...but they don't change often
        ASSERT ( MRDRBUFSTCMD_MAXXX == (sizeof(ULONG)*EightBitsPerChar) );

        ASSERT (!(FcbStateBufferingMask&MinirdrBufStateCommandMask));

    }

    //
    //  Setup the timer subsystem

    RxInitializeRxTimer();

#ifndef MONOLITHIC_MINIRDR
    Status = IoWMIRegistrationControl ((PDEVICE_OBJECT)RxFileSystemDeviceObject, WMIREG_ACTION_REGISTER);
    
    if (Status != STATUS_SUCCESS) {
        DbgPrint("Rdbss fails to register WMI %lx\n",Status);
    } else {
        EnableWmiLog = TRUE;
    }
#endif

    return( STATUS_SUCCESS );
}


//
//  Unload routine
//

VOID
RxUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

     This is the unload routine for the RDBSS.

Arguments:

     DriverObject - pointer to the driver object for the RDBSS

Return Value:

     None

--*/

{
    //UNICODE_STRING LinkName;

    PAGED_CODE();

    RxTearDownRxTimer();

//remember this
//    RdrUnloadSecurity();

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("RxUnload: DriverObject =%08lx\n", DriverObject ));

    ExDeleteResourceLite(&RxData.Resource);

    RxUninitializeBackoffPackage();

    RxTearDownDispatcher();

    RxTearDownDebugSupport();

    ExDeleteNPagedLookasideList(
        &RxContextLookasideList);

    RxInitUnwind(DriverObject, RXINIT_ALL_INITIALIZATION_COMPLETED);
    
    if (EnableWmiLog) {
        NTSTATUS Status;

        Status = IoWMIRegistrationControl ((PDEVICE_OBJECT)RxFileSystemDeviceObject, WMIREG_ACTION_DEREGISTER);
        if (Status != STATUS_SUCCESS) {
            DbgPrint("Rdbss fails to deregister WMI %lx\n",Status);
        }
    }
}

#if DBG
PCHAR RxUnwindFollower = NULL;
#define UNWIND_CASE(x) case x: RxUnwindFollower = #x;
#else
#define UNWIND_CASE(x) case x:
#endif



VOID
RxInitUnwind(
    IN PDRIVER_OBJECT DriverObject,
    IN RX_INIT_STATES RxInitState
    )
/*++

Routine Description:

     This routine does the common uninit work for unwinding from a bad driver entry or for unloading.

Arguments:

     RxInitState - tells how far we got into the intialization

Return Value:

     None

--*/

{
#ifndef MONOLITHIC_MINIRDR
    UNICODE_STRING LinkName;
#endif

    PAGED_CODE();

    switch (RxInitState) {
    UNWIND_CASE(RXINIT_ALL_INITIALIZATION_COMPLETED)
        //Nothing extra to do...this is just so that the constant in RxUnload doesn't change.......
        //lack of break intentional

    UNWIND_CASE(RXINIT_CONSTRUCTED_PROVIDERORDER)
        RxUninitializeRegistrationStructures();
        //lack of break intentional

    UNWIND_CASE(RXINIT_CREATED_LOG)
        RxUninitializeLog();
        //lack of break intentional

#ifndef MONOLITHIC_MINIRDR
    UNWIND_CASE(RXINIT_CREATED_DEVICE_OBJECT)
        IoDeleteDevice((PDEVICE_OBJECT)RxFileSystemDeviceObject);
        //lack of break intentional

    UNWIND_CASE(RXINIT_CREATED_FIRST_LINK)
        RtlInitUnicodeString(&LinkName, RX_SYMLINK_NAME);
        IoDeleteSymbolicLink(&LinkName);
        // lack of break intentional
#endif

    UNWIND_CASE(RXINIT_START)
        //RdrUninitializeDiscardableCode();
        //DbgBreakPoint();
        break;
    }

}


VOID
RxAbbreviatedWriteLogEntry__ (
    IN NTSTATUS Status,
    IN ULONG    OneExtraUlong
    )
/*++

Routine Description:

     This routine write a log entry with most of the fields set to fixed values.

Arguments:

     Status - the status to be stored in the log record
     OneExtraUlong - a key for finding out what happened

Return Value:

     none.

--*/
{
    //RxLogFailureWithBuffer (
    //    RxFileSystemDeviceObject,
    //    NULL,
    //    EVENT_RDR_CANT_READ_REGISTRY,
    //    Status,
    //    &OneExtraUlong,
    //    sizeof(ULONG)
    //    );
}


VOID
RxGetRegistryParameters(
    PUNICODE_STRING RegistryPath
    )
{
    ULONG Storage[256];
    UNICODE_STRING UnicodeString;
    HANDLE ConfigHandle;
    HANDLE ParametersHandle;
    NTSTATUS Status;
    //ULONG BytesRead;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_FULL_INFORMATION Value = (PKEY_VALUE_FULL_INFORMATION)Storage;

    PAGED_CODE(); //INIT

    InitializeObjectAttributes(
        &ObjectAttributes,
        RegistryPath,               // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    Status = ZwOpenKey (&ConfigHandle, KEY_READ, &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        //RxLogFailure (
        //    RxFileSystemDeviceObject,
        //    NULL,
        //    EVENT_RDR_CANT_READ_REGISTRY,
        //    Status);
        return;
    }

    RtlInitUnicodeString(&UnicodeString, L"Parameters");

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        ConfigHandle,
        NULL
        );


    Status = ZwOpenKey (&ParametersHandle, KEY_READ, &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        //RxLogFailure (
        //    RxFileSystemDeviceObject,
        //    NULL,
        //    EVENT_RDR_CANT_READ_REGISTRY,
        //    Status);

        ZwClose(ConfigHandle);

        return;
    }

#ifdef RDBSSLOG
    RxGetStringRegistryParameter(ParametersHandle,
                              L"InitialDebugString",
                              &UnicodeString,
                              (PKEY_VALUE_PARTIAL_INFORMATION) Storage,
                              sizeof(Storage),
                              FALSE
                              );


    //DbgPrint("String From Registry %wZ, buffer = %08lx\n",&UnicodeString,UnicodeString.Buffer);
    if (UnicodeString.Length && UnicodeString.Length<320) {
        PWCH u = UnicodeString.Buffer;
        ULONG l;
        PCH p = (PCH)u;

        for (l=0;l<UnicodeString.Length;l++) {
            *p++ = (CHAR)*u++;
            *p = 0;
        }

        DbgPrint("InitialDebugString From Registry as singlebytestring: <%s>\n",UnicodeString.Buffer);
        RxDebugControlCommand((PCH)UnicodeString.Buffer);
    }
#endif //RDBSSLOG

    ZwClose(ParametersHandle);

    ZwClose(ConfigHandle);

}


NTSTATUS
RxGetStringRegistryParameter(
    HANDLE ParametersHandle,
    PWCHAR ParameterName,
    PUNICODE_STRING ParamString,
    PKEY_VALUE_PARTIAL_INFORMATION Value,
    ULONG ValueSize,
    BOOLEAN LogFailure
    )
{
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG BytesRead;

    PAGED_CODE(); //INIT

    RtlInitUnicodeString(&UnicodeString, ParameterName);

    Status = ZwQueryValueKey(ParametersHandle,
                        &UnicodeString,
                        KeyValuePartialInformation,
                        Value,
                        ValueSize,
                        &BytesRead);

    ParamString->Length = 0;
    ParamString->Buffer = NULL;
    if (NT_SUCCESS(Status)) {
        ParamString->Buffer = (PWCH)(&Value->Data[0]);
        //the datalength actually accounts for the trailing null
        ParamString->Length = ((USHORT)Value->DataLength) - sizeof(WCHAR);
        ParamString->MaximumLength = ParamString->Length;
        return STATUS_SUCCESS;
    }

    if (!LogFailure) { return Status; }


    RxLogFailure (
        RxFileSystemDeviceObject,
        NULL,
        EVENT_RDR_CANT_READ_REGISTRY,
        Status);

    return Status;
}


NTSTATUS
RxGetUlongRegistryParameter(
    HANDLE ParametersHandle,
    PWCHAR ParameterName,
    PULONG ParamUlong,
    PKEY_VALUE_PARTIAL_INFORMATION Value,
    ULONG ValueSize,
    BOOLEAN LogFailure
    )
{
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    ULONG BytesRead;

    PAGED_CODE(); //INIT

    RtlInitUnicodeString(&UnicodeString, ParameterName);

    Status = ZwQueryValueKey(ParametersHandle,
                        &UnicodeString,
                        KeyValuePartialInformation,
                        Value,
                        ValueSize,
                        &BytesRead);


    if (NT_SUCCESS(Status)) {
        if (Value->Type == REG_DWORD) {
            PULONG ConfigValue = (PULONG)&Value->Data[0];
            *ParamUlong = *((PULONG)ConfigValue);
            DbgPrint("readRegistryvalue %wZ = %08lx\n",&UnicodeString,*ParamUlong);
            return(STATUS_SUCCESS);
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
     }

     if (!LogFailure) { return Status; }

     RxLogFailureWithBuffer (
         RxFileSystemDeviceObject,
         NULL,
         EVENT_RDR_CANT_READ_REGISTRY,
         Status,
         ParameterName,
         (USHORT)(wcslen(ParameterName)*sizeof(WCHAR))
         );

     return Status;
}


/*-------------------------------

This set of routines implements the network provider order in the wrapper.
The way that this works is somewhat complicated. First, we go to the registry
to get the provider order; it is stored at key=PROVIDERORDER_REGISTRY_KEY and
value=L"ProviderOrder". This is a list of service providers whereas what we need
are the device names. So, for each ServiceProverName, we go to the registry to
get the device name at key=SERVICE_REGISTRY_KEY, subkey=ServiceProverName,
subsubkey=NETWORK_PROVIDER_SUBKEY, and value=L"Devicename".

We build a linked list of these guys. Later when a minirdr registers, we look
on this list for the corresponding device name and that gives us the priority.

simple? i think NOT.


----------------------------------*/

#ifndef MONOLITHIC_MINIRDR

NTSTATUS
RxAccrueProviderFromServiceName (
    HANDLE           ServicesHandle,
    PUNICODE_STRING  ServiceName,
    ULONG            Priority,
    PWCHAR           ProviderInfoNameBuffer,
    ULONG            ProviderInfoNameBufferLength
    );

NTSTATUS
RxConstructProviderOrder (
    void
    );

VOID
RxDestructProviderOrder (
    void
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, RxAccrueProviderFromServiceName)
#pragma alloc_text(INIT, RxConstructProviderOrder)
#pragma alloc_text(PAGE, RxDestructProviderOrder)
#endif


#define PROVIDERORDER_REGISTRY_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\NetworkProvider\\Order"
#define SERVICE_REGISTRY_KEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\"
#define NETWORK_PROVIDER_SUBKEY L"\\networkprovider"


typedef struct _RX_UNC_PROVIDER_HEADER {
        union {
            LIST_ENTRY;
            LIST_ENTRY Links;
        };
        ULONG Priority;
        union {
            UNICODE_STRING;
            UNICODE_STRING DeviceName;
        };
} RX_UNC_PROVIDER_HEADER;

typedef struct _RX_UNC_PROVIDER {
    RX_UNC_PROVIDER_HEADER;
    KEY_VALUE_PARTIAL_INFORMATION Info;
} RX_UNC_PROVIDER, *PRX_UNC_PROVIDER;

LIST_ENTRY RxUncProviders;

ULONG
RxGetNetworkProviderPriority(
    IN PUNICODE_STRING DeviceName
    )
/*++

Routine Description:

     This routine is called at minirdr registration time to find out the priority
     of the provider with the given DeviceName. It simply looks it up on a list.

Arguments:

     DeviceName - name of the device whose priority is to be found

Return Value:

     the network provider priority that the MUP will use.

--*/
{
    PLIST_ENTRY Entry;

    PAGED_CODE();

    RxLog(("FindUncProvider %wZ \n",DeviceName));
    RxWmiLog(LOG,
             RxGetNetworkProviderPriority,
             LOGUSTR(*DeviceName));

    for (Entry = RxUncProviders.Flink;
         Entry != &RxUncProviders;
        ) {

        PRX_UNC_PROVIDER UncProvider = (PRX_UNC_PROVIDER)Entry;
        Entry = Entry->Flink;
        if ( RtlEqualUnicodeString( DeviceName, &UncProvider->DeviceName, TRUE )) {
            return(UncProvider->Priority);
        }

    }

    // no corresponding entry was found

    return(0x7effffff); //got this constant from the MUP........
}


NTSTATUS
RxAccrueProviderFromServiceName (
    HANDLE           ServicesHandle,
    PUNICODE_STRING  ServiceName,
    ULONG            Priority,
    PWCHAR           ProviderInfoNameBuffer,
    ULONG            ProviderInfoNameBufferLength
    )
/*++

Routine Description:

     This routine has the responsibility to look up the device name corresponding
     to a particular provider name; if successful, the device name and the corresponding
     priority are recorded on the UncProvider List.

Arguments:

    HANDLE           ServicesHandle  - a handle to the services root in the registry
    PUNICODE_STRING  ServiceName     - the name of the service relative to the servicehandle
    ULONG            Priority,       - the priority of this provider
    PWCHAR           ProviderInfoNameBuffer,    - a buffer that can be used to accrue the subkey name
    ULONG            ProviderInfoNameBufferLength   - and the length

Return Value:

     STATUS_SUCCESS if everything worked elsewise an error status.

--*/
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING ProviderInfoName,ProviderInfoKey,ParameterDeviceName;
    HANDLE NetworkProviderInfoHandle = INVALID_HANDLE_VALUE;
    KEY_VALUE_PARTIAL_INFORMATION InitialValuePartialInformation;
    ULONG DummyBytesRead,ProviderLength;
    PRX_UNC_PROVIDER UncProvider = NULL;

    PAGED_CODE();

    RxLog(("SvcNm %wZ",ServiceName));
    RxWmiLog(LOG,
             RxAccrueProviderFromServiceName_1,
             LOGUSTR(*ServiceName));
    //
    // Form the correct keyname using the bufferspace provided

    ProviderInfoName.Buffer = ProviderInfoNameBuffer;
    ProviderInfoName.Length = 0;
    ProviderInfoName.MaximumLength = (USHORT)ProviderInfoNameBufferLength;

    Status = RtlAppendUnicodeStringToString(&ProviderInfoName,ServiceName);
    if (Status != STATUS_SUCCESS) {
        DbgPrint("Could append1: %08lx %wZ\n",Status,&ProviderInfoName);
        //RxAbbreviatedWriteLogEntry(Status);
        goto FINALLY;
    }
    RtlInitUnicodeString(&ProviderInfoKey, NETWORK_PROVIDER_SUBKEY);
    Status = RtlAppendUnicodeStringToString(&ProviderInfoName,&ProviderInfoKey);
    if (Status != STATUS_SUCCESS) {
        DbgPrint("Could append2: %08lx %wZ\n",Status,&ProviderInfoName);
        RxAbbreviatedWriteLogEntry(Status);
        goto FINALLY;
    }

    //
    // Open the key in preparation for reeading the devicename value

    //DbgPrint("RxAccrueProviderFromServiceName providerinfoname %wZ\n",&ProviderInfoName);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &ProviderInfoName,      // name
        OBJ_CASE_INSENSITIVE,   // attributes
        ServicesHandle,         // root
        NULL                    // security descriptor
        );

    Status = ZwOpenKey (&NetworkProviderInfoHandle, KEY_READ, &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("NetWorkProviderInfoFailed: %08lx %wZ\n",Status,&ProviderInfoName);
        RxAbbreviatedWriteLogEntry(Status);
        goto FINALLY;
    }

    //
    //  Read the devicename. we do this in two steps. first, we do a partial read to find out
    //  how big the name really is. Then, we allocate a UncProviderEntry of the correctsize and make
    //  a second call to fill it in.


    //DbgPrint("RxAccrueProviderFromServiceName ServiceName %wZ; worked\n",ServiceName);
    RtlInitUnicodeString(&ParameterDeviceName, L"DeviceName");

    Status = ZwQueryValueKey(NetworkProviderInfoHandle,
                        &ParameterDeviceName,
                        KeyValuePartialInformation,
                        &InitialValuePartialInformation,
                        sizeof(InitialValuePartialInformation),
                        &DummyBytesRead);
    if (Status==STATUS_BUFFER_OVERFLOW) {
        Status=STATUS_SUCCESS;
    }
    if (Status!=STATUS_SUCCESS) {
        RxAbbreviatedWriteLogEntry(Status);
        goto FINALLY;
    }
    //DbgPrint("RxAccrueProviderFromServiceName ServiceName %wZ; worked; devicenamesize=%08lx\n",
    //                                    ServiceName,InitialValuePartialInformation.DataLength);

    ProviderLength = sizeof(RX_UNC_PROVIDER)+InitialValuePartialInformation.DataLength;
    UncProvider = RxAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION ,ProviderLength,RX_MRX_POOLTAG);
    if (UncProvider==NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        DbgPrint("UncProviderAllocationFailed: %08lx %wZ\n",Status,&ProviderInfoName);
        RxAbbreviatedWriteLogEntry(Status);
        goto FINALLY;
    }

    Status = ZwQueryValueKey(NetworkProviderInfoHandle,
                        &ParameterDeviceName,
                        KeyValuePartialInformation,
                        &UncProvider->Info,
                        ProviderLength,
                        &DummyBytesRead);
    if (Status!=STATUS_SUCCESS) {
        RxAbbreviatedWriteLogEntry(Status);
        goto FINALLY;
    }

    //
    // Finish filling in the UncProviderEntry and link it in

    UncProvider->Buffer = (PWCHAR)(&UncProvider->Info.Data[0]);
    UncProvider->Length = (USHORT)(UncProvider->Info.DataLength-sizeof(WCHAR)); //dont include trailing NULL
    UncProvider->MaximumLength = UncProvider->Length;
    UncProvider->Priority = Priority;

    InsertTailList(&RxUncProviders,&UncProvider->Links);

    RxLog(("Dvc p=%lx Nm %wZ",UncProvider->Priority,&UncProvider->DeviceName));
    RxWmiLog(LOG,
             RxAccrueProviderFromServiceName_2,
             LOGULONG(UncProvider->Priority)
             LOGUSTR(UncProvider->DeviceName));
    UncProvider = NULL;

FINALLY:

    //
    // if we obtained a handle to ...\\services\<sevicename>\providerinfo then close it

    if (NetworkProviderInfoHandle!=INVALID_HANDLE_VALUE) ZwClose(NetworkProviderInfoHandle);

    if (UncProvider != NULL) {
        RxFreePool(UncProvider);
    }

    return Status;
}

NTSTATUS
RxConstructProviderOrder(
    void
    )
/*++

Routine Description:

     This routine has the responsibility to build the list of network providers
     that is used to look up provider priority at minirdr registration time. It does this
     by first reading the providerorder string fron the registry;  then for each provider
     listed in the string, a helper routine is called to lookup the corresponding device
     name and insert an entry on the provider list.

Arguments:

     none.

Return Value:

     STATUS_SUCCESS if everything worked elsewise an error status.


--*/
{
    KEY_VALUE_PARTIAL_INFORMATION InitialValuePartialInformation;
    UNICODE_STRING ProviderOrderValueName;
    ULONG DummyBytesRead;
    PBYTE ProviderOrderStringBuffer;
    PBYTE ServiceNameStringBuffer = NULL;
    ULONG  ProviderOrderStringLength,ServiceNameStringLength,AllocationLength;

    UNICODE_STRING UnicodeString;
    UNICODE_STRING ProviderOrder;
    PWCHAR ScanPtr,FinalScanPtr;
    HANDLE NPOrderHandle = INVALID_HANDLE_VALUE;
    HANDLE ServiceRootHandle = INVALID_HANDLE_VALUE;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Priority = 0;

    PAGED_CODE();

    RxLog(("RxConstructProviderOrder"));
    RxWmiLog(LOG,
             RxConstructProviderOrder_1,
             LOGULONG(Priority));
    InitializeListHead(&RxUncProviders);

    //
    // Start by opening the service registry key. This is the root key of all services
    // and is used for relative opens by the helper routine so that string manipulation
    // is reduced.

    RtlInitUnicodeString(&UnicodeString, SERVICE_REGISTRY_KEY);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,             // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    Status = ZwOpenKey (&ServiceRootHandle, KEY_READ, &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("ServiceRootOpenFailed: %08lx %wZ\n",Status,&UnicodeString);
        RxAbbreviatedWriteLogEntry(Status);
        goto FINALLY;
    }

    //
    // Now open up the key where we find the provider order string

    RtlInitUnicodeString(&UnicodeString, PROVIDERORDER_REGISTRY_KEY);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,             // name
        OBJ_CASE_INSENSITIVE,       // attributes
        NULL,                       // root
        NULL                        // security descriptor
        );

    Status = ZwOpenKey (&NPOrderHandle, KEY_READ, &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("NetProviderOpenFailed: %08lx %wZ\n",Status,&UnicodeString);
        RxAbbreviatedWriteLogEntry(Status);
        goto FINALLY;
    }

    //
    //Find out how long the provider order string is

    RtlInitUnicodeString(&ProviderOrderValueName, L"ProviderOrder");

    Status = ZwQueryValueKey(NPOrderHandle,
                        &ProviderOrderValueName,
                        KeyValuePartialInformation,
                        &InitialValuePartialInformation,
                        sizeof(InitialValuePartialInformation),
                        &DummyBytesRead);
    if (Status==STATUS_BUFFER_OVERFLOW) {
        Status=STATUS_SUCCESS;
    }
    if (Status!=STATUS_SUCCESS) {
        DbgPrint("ProviderOrderStringPartialInfoFailed: %08lx %wZ\n",Status,&ProviderOrderValueName);
        RxAbbreviatedWriteLogEntry(Status);
        goto FINALLY;
    }

    //
    // allocate two buffers: one buffer will hold the provider string -- ProviderOrderStringBuffer.
    // it has to be as long as the providerorder string plus enough extra for the registry
    // structure used in the call. the second buffer is used to hold the servicename key--it has
    // to be as long as any element of the provider string plus enough extra to hold the suffix
    // NETWORK_PROVIDER_SUBKEY. in order to only parse the string once, we just allocate for a complete
    // additional copy of the provider string. we actually combine these into a single allocation.

    ProviderOrderStringLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + InitialValuePartialInformation.DataLength;
    ProviderOrderStringLength = QuadAlign(ProviderOrderStringLength +2*sizeof(WCHAR));   //chars added below

    ServiceNameStringLength = sizeof(NETWORK_PROVIDER_SUBKEY) + InitialValuePartialInformation.DataLength;
    ServiceNameStringLength = QuadAlign(ServiceNameStringLength);

    AllocationLength = ProviderOrderStringLength + ServiceNameStringLength;
    RxLog(("prov string=%lx,alloc=%lx\n",
                InitialValuePartialInformation.DataLength,
                AllocationLength));
    RxWmiLog(LOG,
             RxConstructProviderOrder_2,
             LOGULONG(InitialValuePartialInformation.DataLength)
             LOGULONG(AllocationLength));

    ServiceNameStringBuffer = RxAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION,AllocationLength,RX_MRX_POOLTAG);
    if (ServiceNameStringBuffer==NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        RxAbbreviatedWriteLogEntry(Status);
        goto FINALLY;
    }
    ProviderOrderStringBuffer = ServiceNameStringBuffer+ServiceNameStringLength;

    //
    // now do the final read to get the providerorder string

    RxGetStringRegistryParameter(NPOrderHandle,
                              L"ProviderOrder",
                              &ProviderOrder,
                              (PKEY_VALUE_PARTIAL_INFORMATION) ProviderOrderStringBuffer,
                              ProviderOrderStringLength,
                              FALSE
                              );
    if (ProviderOrder.Buffer == NULL) {
        Status = STATUS_UNSUCCESSFUL;
        RxAbbreviatedWriteLogEntry(Status);
        goto FINALLY;
    }

    //
    // comma-terminate the string for easier living. then scan down the string
    // looking for comma terminated entries. for each entry found, try to accrue
    // it to the list

    ProviderOrder.Buffer[ProviderOrder.Length/sizeof(WCHAR)] = L',';

    ScanPtr = ProviderOrder.Buffer;
    FinalScanPtr = ScanPtr+(ProviderOrder.Length/sizeof(WCHAR));
    for (;;) {

        UNICODE_STRING ServiceName;

        // check for loop termination

        if (ScanPtr >= FinalScanPtr) { break; }
        if (*ScanPtr==L',') { ScanPtr++; continue; }

        // parse for a servicename

        ServiceName.Buffer = ScanPtr;
        for (;*ScanPtr!=L',';ScanPtr++) {
            //DbgPrint("Considering %c\n",*ScanPtr);
        }
        ASSERT(*ScanPtr==L',');
        ServiceName.Length = (USHORT)(sizeof(WCHAR)*(ScanPtr - ServiceName.Buffer));
        //DbgPrint("Length %08lx\n",ServiceName.Length);
        //DbgPrint("ServiceName %wZ\n",&ServiceName);

        // accrue it to the list

        Priority++;
        Status = RxAccrueProviderFromServiceName(ServiceRootHandle,
                                                 &ServiceName,
                                                 Priority,
                                                 (PWCHAR)ServiceNameStringBuffer,
                                                 ServiceNameStringLength  );
        if (Status == STATUS_INSUFFICIENT_RESOURCES) {
            goto FINALLY; //a log entry has already been generated
        } else {
            Status = STATUS_SUCCESS;
        }
    }

FINALLY:

    //
    // give back anything that we got in this procedure

    if (NPOrderHandle!=INVALID_HANDLE_VALUE) ZwClose(NPOrderHandle);
    if (ServiceRootHandle!=INVALID_HANDLE_VALUE) ZwClose(ServiceRootHandle);
    if (ServiceNameStringBuffer!=NULL) RxFreePool(ServiceNameStringBuffer);

    //
    // if things didn't work, then we won't start....so give back
    // the stuff that we have

    if (!NT_SUCCESS(Status)) {
        RxDestructProviderOrder();
    }
    return Status;
}


VOID
RxDestructProviderOrder(
    void
    )
{
    PLIST_ENTRY Entry;
    PAGED_CODE();

    //DbgPrint("RxDestructProviderOrder \n");
    for (Entry = RxUncProviders.Flink;
         Entry != &RxUncProviders;
        ) {
        PRX_UNC_PROVIDER UncProvider = (PRX_UNC_PROVIDER)Entry;
        Entry = Entry->Flink;
        //DbgPrint("RxDO UncP %wZ p=%x\n",&UncProvider->DeviceName,UncProvider->Priority);
        RxFreePool(UncProvider);
    }
    return;
}

#else
ULONG
RxGetNetworkProviderPriority(
    PUNICODE_STRING DeviceName
    )
{
    PAGED_CODE(); //DUPLICATE

    return(1); //this number is irrelevant for monolithic
}
#endif //#ifndef MONOLITHIC_MINIRDR

NTSTATUS
RxInitializeRegistrationStructures(
    void
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PAGED_CODE();

    ExInitializeFastMutex(&RxData.MinirdrRegistrationMutex);
    RxData.NumberOfMinirdrsRegistered = 0;
    RxData.NumberOfMinirdrsStarted = 0;
    InitializeListHead( &RxData.RegisteredMiniRdrs );
#ifndef MONOLITHIC_MINIRDR
    Status = RxConstructProviderOrder();
#endif
    return(Status);
}

VOID
RxUninitializeRegistrationStructures(
    void
    )
{
    PAGED_CODE();

#ifndef MONOLITHIC_MINIRDR
    RxDestructProviderOrder();
#endif
}


VOID
RxInitializeMinirdrDispatchTable(
    IN PDRIVER_OBJECT DriverObject
    )
{
    PAGED_CODE();

#ifndef MONOLITHIC_MINIRDR
    {ULONG i;
    //finally, fill in the dispatch tables for normal guys.........
    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = RxData.DriverObject->MajorFunction[i];
    }}
    DriverObject->FastIoDispatch = RxData.DriverObject->FastIoDispatch;
#endif
}


VOID
NTAPI
__RxFillAndInstallFastIoDispatch(
    IN     PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN OUT PFAST_IO_DISPATCH FastIoDispatch,
    IN     ULONG             FastIoDispatchSize
    )
/*++

Routine Description:

    This routine fills out a fastiodispatch vector to be identical with
    that normal one and installs it into the driver object associated with
    the device object passed.

Arguments:

    RxDeviceObject - the device object that is to have its driver's fastiodispatch changed
    FastIoDispatch - the fastiodispatch table to fill in and use
    FastIoDispatchSize - the size of the table passed

Return Value:

    NONE

--*/
{
    ULONG TableSize = min(FastIoDispatchSize,
                          RxFastIoDispatch.SizeOfFastIoDispatch);
    PAGED_CODE();

#ifndef MONOLITHIC_MINIRDR
    RtlCopyMemory(FastIoDispatch,&RxFastIoDispatch,TableSize);
    FastIoDispatch->SizeOfFastIoDispatch = TableSize;
    RxDeviceObject->DriverObject->FastIoDispatch = FastIoDispatch;
    return;
#endif
}

VOID
RxReadRegistryParameters( 
    void
    )
{
    ULONG Storage[16];
    UNICODE_STRING UnicodeString;
    HANDLE ParametersHandle;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING WorkStationParametersRegistryKeyName;
    PKEY_VALUE_PARTIAL_INFORMATION Value = (PKEY_VALUE_PARTIAL_INFORMATION)Storage;
    ULONG ValueSize;
    ULONG BytesRead;

    PAGED_CODE(); //INIT

    RtlInitUnicodeString(&WorkStationParametersRegistryKeyName,
        LANMAN_WORKSTATION_PARAMETERS);

    ValueSize = sizeof(Storage);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &WorkStationParametersRegistryKeyName,  // name
        OBJ_CASE_INSENSITIVE,                   // attributes
        NULL,                                   // root
        NULL                                    // security descriptor
        );

    Status = ZwOpenKey (&ParametersHandle, KEY_READ, &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        //RxLogFailure (
        //    RxFileSystemDeviceObject,
        //    NULL,
        //    EVENT_RDR_CANT_READ_REGISTRY,
        //    Status);
        return;
    }

    RtlInitUnicodeString(&UnicodeString, L"DisableByteRangeLockingOnReadOnlyFiles");

    Status = ZwQueryValueKey(ParametersHandle,
                            &UnicodeString,
                            KeyValuePartialInformation,
                            Value,
                            ValueSize,
                            &BytesRead);

    if (NT_SUCCESS(Status)) {
        if (Value->Type == REG_DWORD) {
            PULONG ConfigValue = (PULONG)&Value->Data[0];
            DisableByteRangeLockingOnReadOnlyFiles = 
                    (BOOLEAN) (*((PULONG)ConfigValue) != 0);
        }
    }

    ZwClose(ParametersHandle);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ntfsp.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FspDisp.c

Abstract:

    This module implements the main dispatch procedure/thread for the RDBSS Fsp

Author:

    Joe Linn     [JoeLinn]    1-aug-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "NtDspVec.h"
#include <ntddnfs2.h>
#include <ntddmup.h>

//
//  Define our local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FSP_DISPATCHER)


//
//  Internal support routine, spinlock wrapper.
//

PRX_CONTEXT
RxRemoveOverflowEntry (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN WORK_QUEUE_TYPE      Type);


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxFspDispatch)
//not pageable SPINLOCK #pragma alloc_text(PAGE, RxRemoveOverflowEntry) //!@!@! ntfsp.c
#endif

#ifdef RDBSSLOG
//this stuff must be in nonpaged memory
                     ////       1 2 3 4 5 6 7
char RxFsp_SurrogateFormat[] = "%S%S%N%N%N%N%N";
                             ////   2  3   4         5        6   7
char RxFsp_ActualFormat[]    = "Fsp %s/%lx %08lx irp %lx thrd %lx #%lx";

#endif //ifdef RDBSSLOG

VOID
RxFspDispatch (
    IN PVOID Context
    )
/*++

Routine Description:

    This is the main FSP thread routine that is executed to receive
    and dispatch IRP requests.  Each FSP thread begins its execution here.
    There is one thread created at system initialization time and subsequent
    threads created as needed.

Arguments:


    Context - Supplies the thread id.

Notes:

    This routine never exits

--*/
{
    NTSTATUS Status;

    PRX_CONTEXT             RxContext = (PRX_CONTEXT)Context;
    RX_TOPLEVELIRP_CONTEXT  TopLevelContext;
    PRDBSS_DEVICE_OBJECT    RxDeviceObject;
    WORK_QUEUE_TYPE         WorkQueueType;
    DWORD                   CurrentIrql;

    PAGED_CODE();

    CurrentIrql = KeGetCurrentIrql();

    //
    //  If this request has an associated volume device object, remember it.
    //

    {
        RxCaptureParamBlock;
        RxCaptureFileObject;

        if ( capFileObject != NULL ) {

            RxDeviceObject = CONTAINING_RECORD( capPARAMS->DeviceObject,
                                       RDBSS_DEVICE_OBJECT,
                                       DeviceObject );

            //
            // currently, we use the wrapper's device object for all throttling.....

            RxDeviceObject = RxFileSystemDeviceObject;

        } else {

            RxDeviceObject = NULL;
        }
    }

    if (BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_FSP_DELAYED_OVERFLOW_QUEUE)) {
        WorkQueueType = DelayedWorkQueue;
    } else if (BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_FSP_CRITICAL_OVERFLOW_QUEUE)) {
        WorkQueueType = CriticalWorkQueue;
    } else {
        ASSERT(!"Valid RXCONTEXT Work Queue Type");
    }

    //  We'll do all of the work within an exception handler that
    //  will be invoked if ever some underlying operation gets into
    //  trouble.
    //

    while ( TRUE ) {
        RxDbgTrace(0, Dbg, ("RxFspDispatch: IrpC = 0x%08lx\n", RxContext));
        ASSERT(RxContext->MajorFunction<=IRP_MJ_MAXIMUM_FUNCTION);
        ASSERT(RxContext->PostRequest == FALSE);

        RxContext->LastExecutionThread = PsGetCurrentThread();

        RxLog((RxFsp_SurrogateFormat, RxFsp_ActualFormat,
              RXCONTX_OPERATION_NAME(RxContext->MajorFunction,TRUE),
              RxContext->MinorFunction,
              RxContext, RxContext->CurrentIrp,
              RxContext->LastExecutionThread,
              RxContext->SerialNumber
           ));
        RxWmiLog(LOG,
                 RxFspDispatch,
                 LOGPTR(RxContext)
                 LOGPTR(RxContext->CurrentIrp)
                 LOGPTR(RxContext->LastExecutionThread)
                 LOGULONG(RxContext->SerialNumber)
                 LOGUCHAR(RxContext->MinorFunction)
                 LOGARSTR(RXCONTX_OPERATION_NAME(RxContext->MajorFunction,TRUE)));

        { //introduce another scope so that i can use the standard capture macros

            RxCaptureRequestPacket;
            RxCaptureFcb;
            RxCaptureFobx;
            RxCaptureParamBlock;
            RxCaptureFileObject;

            //
            //  Now because we are the Fsp we will force the RxContext to
            //  indicate true on Wait.
            //

            SetFlag(RxContext->Flags, RX_CONTEXT_FLAG_WAIT | RX_CONTEXT_FLAG_IN_FSP);

            //
            //  If this Irp was top level, note it in our thread local storage.
            //

            FsRtlEnterFileSystem();

            if ( FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_RECURSIVE_CALL) ) {
                //IoSetTopLevelIrp( (PIRP)FSRTL_FSP_TOP_LEVEL_IRP );
                RxTryToBecomeTheTopLevelIrp( &TopLevelContext,
                                             (PIRP)FSRTL_FSP_TOP_LEVEL_IRP,
                                             RxContext->RxDeviceObject,
                                             TRUE ); //force
            } else {
                //IoSetTopLevelIrp( capReqPacket );
                RxTryToBecomeTheTopLevelIrp( &TopLevelContext,
                                             capReqPacket,
                                             RxContext->RxDeviceObject,
                                             TRUE ); //force
            }

            try {

                ASSERT((RxContext->ResumeRoutine) != NULL);

                if ( FlagOn(RxContext->MinorFunction, IRP_MN_DPC) &&
                     (capReqPacket->Tail.Overlay.Thread == NULL) ) {

                    ASSERT((RxContext->MajorFunction == IRP_MJ_WRITE) ||
                           (RxContext->MajorFunction == IRP_MJ_READ));

                    capReqPacket->Tail.Overlay.Thread = PsGetCurrentThread();
                }

                do {
                    BOOLEAN NoCompletion = BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_NO_COMPLETE_FROM_FSP);

                    Status = RxContext->ResumeRoutine(RXCOMMON_ARGUMENTS);

                    if (NoCompletion) {
                        NOTHING;
                    } else {
                        if ((Status != STATUS_PENDING) &&
                            (Status != STATUS_RETRY)) {
                            Status = RxCompleteRequest( RxContext, Status );
                        }
                    }
                } while (Status == STATUS_RETRY);

            } except(RxExceptionFilter( RxContext, GetExceptionInformation() )) {

                //
                //  We had some trouble trying to perform the requested
                //  operation, so we'll abort the I/O request with
                //  the error status that we get back from the
                //  execption code.
                //

                (VOID) RxProcessException( RxContext, GetExceptionCode() );
            }

            //IoSetTopLevelIrp( NULL );
            RxUnwindTopLevelIrp( &TopLevelContext );

            FsRtlExitFileSystem();

            //
            //  If there are any entries on this volume's overflow queue, service
            //  them.
            //

            if ( RxDeviceObject != NULL ) {

                //
                //  We have a volume device object so see if there is any work
                //  left to do in its overflow queue.
                //

                RxContext = RxRemoveOverflowEntry( RxDeviceObject,WorkQueueType );

                //
                //  There wasn't an entry, break out of the loop and return to
                //  the Ex Worker thread.
                //

                if ( RxContext == NULL ) {
                    break;
                }

                continue;
            } else {
                break;
            }
        }  //close extra scope
    }

#ifdef DBG
    if(KeGetCurrentIrql() >= APC_LEVEL)
    {
        DbgPrint("High Irql RxContext=%x Irql On Entry=%x\n", RxContext, CurrentIrql);
        //DbgBreakPoint();
    }
#endif

    return;
}

//
//  Internal support routine, spinlock wrapper.
//

PRX_CONTEXT
RxRemoveOverflowEntry (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN WORK_QUEUE_TYPE      WorkQueueType)
{
    PRX_CONTEXT RxContext;
    KIRQL       SavedIrql;

    KeAcquireSpinLock( &RxDeviceObject->OverflowQueueSpinLock, &SavedIrql );

    if (RxDeviceObject->OverflowQueueCount[WorkQueueType] > 0) {
        PVOID Entry;

        //
        //  There is overflow work to do in this volume so we'll
        //  decrement the Overflow count, dequeue the IRP, and release
        //  the Event
        //

        RxDeviceObject->OverflowQueueCount[WorkQueueType] -= 1;

        Entry = RemoveHeadList( &RxDeviceObject->OverflowQueue[WorkQueueType] );


        //
        //  Extract the RxContext, Irp, and IrpSp, and loop.
        //

        RxContext = CONTAINING_RECORD(
                        Entry,
                        RX_CONTEXT,
                        OverflowListEntry );
        RxContext->OverflowListEntry.Flink = NULL;

        RxContext->Flags &= ~(RX_CONTEXT_FLAG_FSP_CRITICAL_OVERFLOW_QUEUE |
                              RX_CONTEXT_FLAG_FSP_DELAYED_OVERFLOW_QUEUE);
    } else {
        RxContext = NULL;
        InterlockedDecrement(&RxDeviceObject->PostedRequestCount[WorkQueueType]);
    }

    KeReleaseSpinLock( &RxDeviceObject->OverflowQueueSpinLock, SavedIrql );

    return RxContext;
}

BOOLEAN
RxCancelOperationInOverflowQueue(
    PRX_CONTEXT RxContext)
/*++

Routine Description:

    This routine cancels the operation in the overflow queue

Arguments:

    RxContext    The context of the operation being synchronized

--*/
{
    BOOLEAN     CancelledRequest = FALSE;

    PRDBSS_DEVICE_OBJECT RxDeviceObject;

    KIRQL       SavedIrql;

    //
    // currently, we use the wrapper's device object for all throttling.....

    RxDeviceObject = RxFileSystemDeviceObject;

    KeAcquireSpinLock( &RxDeviceObject->OverflowQueueSpinLock, &SavedIrql );

    if (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_FSP_CRITICAL_OVERFLOW_QUEUE) ||
        FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_FSP_DELAYED_OVERFLOW_QUEUE)) {
        if ( RxContext->OverflowListEntry.Flink != NULL ) {
            // Remove the entry from the overflow queue
            RemoveEntryList(&RxContext->OverflowListEntry);
            RxContext->OverflowListEntry.Flink = NULL;

            if (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_FSP_CRITICAL_OVERFLOW_QUEUE)) {
                RxDeviceObject->OverflowQueueCount[CriticalWorkQueue] -= 1;
            } else {
                RxDeviceObject->OverflowQueueCount[DelayedWorkQueue] -= 1;
            }

            RxContext->Flags &= ~(RX_CONTEXT_FLAG_FSP_CRITICAL_OVERFLOW_QUEUE |
                                  RX_CONTEXT_FLAG_FSP_DELAYED_OVERFLOW_QUEUE);

            CancelledRequest = TRUE;
        }
    }

    KeReleaseSpinLock( &RxDeviceObject->OverflowQueueSpinLock, SavedIrql );


    if (CancelledRequest) {
        RxRemoveOperationFromBlockingQueue(RxContext);

        RxCompleteRequest(RxContext,STATUS_CANCELLED);
    }

    return CancelledRequest;
}


//
//  The following constant is the maximum number of ExWorkerThreads that we
//  will allow to be servicing a particular target device at any one time.
//

#define FSP_PER_DEVICE_THRESHOLD         (1)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxOplockComplete)
//#pragma alloc_text(PAGE, RxPrePostIrp)
#endif

VOID
RxOplockComplete (
    IN PVOID Context,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the oplock package when an oplock break has
    completed, allowing an Irp to resume execution.  If the status in
    the Irp is RxStatus(SUCCESS), then we queue the Irp to the Fsp queue.
    Otherwise we complete the Irp with the status in the Irp.

Arguments:

    Context - Pointer to the RxContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    //  Check on the return value in the Irp.

    if (Irp->IoStatus.Status == STATUS_SUCCESS) {

        //
        //  Insert the Irp context in the workqueue.
        //

        RxAddToWorkque( (PRX_CONTEXT) Context, Irp );
    } else {
        //  Otherwise complete the request.

        RxCompleteRequest( (PRX_CONTEXT) Context, Irp->IoStatus.Status );
    }

    return;
}

VOID
RxPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine performs any neccessary work before RxStatus(PENDING) is
    returned with the Fsd thread.  This routine is called within the
    filesystem and by the oplock package. The main issue is that we are about
    to leave the user's process so we need to get a systemwide address for
    anything in his address space that we require.

Arguments:

    Context - Pointer to the RxContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/
{
    PRX_CONTEXT RxContext = (PRX_CONTEXT) Context;
    RxCaptureParamBlock;
    //
    //  If there is no Irp, we are done.
    //

    if (Irp == NULL) {

        return;
    }

    if (!FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_NO_PREPOSTING_NEEDED)) {
        SetFlag(RxContext->Flags,RX_CONTEXT_FLAG_NO_PREPOSTING_NEEDED);

        //
        //  We need to lock the user's buffer, unless this is an MDL-read,
        //  in which case there is no user buffer.
        //
        //  **** we need a better test than non-MDL (read or write)!

        if (RxContext->MajorFunction == IRP_MJ_READ
            || RxContext->MajorFunction == IRP_MJ_WRITE) {

            //
            //  If not an Mdl request, lock the user's buffer.
            //

            if (!FlagOn( RxContext->MinorFunction, IRP_MN_MDL )) {

                RxLockUserBuffer( RxContext,
                                   (RxContext->MajorFunction == IRP_MJ_READ) ?
                                   IoWriteAccess : IoReadAccess,
                                   capPARAMS->Parameters.Write.Length );
            }

        //
        //  We also need to check whether this is a query file operation.
        //

        } else if (RxContext->MajorFunction == IRP_MJ_DIRECTORY_CONTROL
                   && RxContext->MinorFunction == IRP_MN_QUERY_DIRECTORY) {

            RxLockUserBuffer( RxContext,
                               IoWriteAccess,
                               capPARAMS->Parameters.QueryDirectory.Length );

        //
        //  We also need to check whether this is a query ea operation.
        //

        } else if (RxContext->MajorFunction == IRP_MJ_QUERY_EA) {

            RxLockUserBuffer( RxContext,
                               IoWriteAccess,
                               capPARAMS->Parameters.QueryEa.Length );

        //
        //  We also need to check whether this is a set ea operation.
        //

        } else if (RxContext->MajorFunction == IRP_MJ_SET_EA) {

            RxLockUserBuffer( RxContext,
                               IoReadAccess,
                               capPARAMS->Parameters.SetEa.Length );
        }

        //
        //  Mark that we've already returned pending to the user
        //

        IoMarkIrpPending( Irp );
    }

    return;
}

#ifdef RDBSSLOG
//this stuff must be in nonpaged memory
                     ////           1 2 3 4 5 6 7
char RxFsdPost_SurrogateFormat[] = "%S%S%N%N%N%N%N";
                             ////        2  3   4         5        6    7
char RxFsdPost_ActualFormat[]    = "POST %s/%lx %08lx irp %lx thrd %lx #%lx";

#endif //ifdef RDBSSLOG

NTSTATUS
RxFsdPostRequest(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine enqueues the request packet specified by RxContext to the
    Ex Worker threads.  This is a FSD routine.

Arguments:

    RxContext - Pointer to the RxContext to be queued to the Fsp

Return Value:

    RxStatus(PENDING)

--*/
{
    RxCaptureRequestPacket;

    if(!FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_NO_PREPOSTING_NEEDED)) {
        RxPrePostIrp( RxContext, capReqPacket );
    }

    RxLog((RxFsdPost_SurrogateFormat, RxFsdPost_ActualFormat,
          RXCONTX_OPERATION_NAME(RxContext->MajorFunction,TRUE),
          RxContext->MinorFunction,
          RxContext, RxContext->CurrentIrp,
          RxContext->LastExecutionThread,
          RxContext->SerialNumber
       ));
    RxWmiLog(LOG,
             RxFsdPostRequest,
             LOGPTR(RxContext)
             LOGPTR(RxContext->CurrentIrp)
             LOGPTR(RxContext->LastExecutionThread)
             LOGULONG(RxContext->SerialNumber)
             LOGUCHAR(RxContext->MinorFunction)
             LOGARSTR(RXCONTX_OPERATION_NAME(RxContext->MajorFunction,TRUE)));

    RxAddToWorkque( RxContext, capReqPacket );

    return (STATUS_PENDING);
}

VOID
RxAddToWorkque (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called to acually store the posted Irp to the Fsp
    workque.

Arguments:

    RxContext - Pointer to the RxContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/
{
    KIRQL SavedIrql;

    RxCaptureParamBlock;
    RxCaptureFileObject;

    WORK_QUEUE_TYPE WorkQueueType;
    BOOLEAN         PostToWorkerThread = FALSE;

    ULONG IoControlCode = capPARAMS->Parameters.DeviceIoControl.IoControlCode;
    //  Send it off.....

    RxContext->PostRequest = FALSE;

    //
    //  Check if this request has an associated file object, and thus volume
    //  device object.
    //
    if ((RxContext->MajorFunction == IRP_MJ_DEVICE_CONTROL) &&
        (capPARAMS->Parameters.DeviceIoControl.IoControlCode == IOCTL_REDIR_QUERY_PATH)) {
        WorkQueueType = DelayedWorkQueue;
        SetFlag(RxContext->Flags,RX_CONTEXT_FLAG_FSP_DELAYED_OVERFLOW_QUEUE);
    } else {
        WorkQueueType = CriticalWorkQueue;
        SetFlag(RxContext->Flags,RX_CONTEXT_FLAG_FSP_CRITICAL_OVERFLOW_QUEUE);
    }

    if ( capFileObject != NULL ) {
        PRDBSS_DEVICE_OBJECT RxDeviceObject;
        LONG                 RequestCount;

        RxDeviceObject = CONTAINING_RECORD( capPARAMS->DeviceObject,
                                 RDBSS_DEVICE_OBJECT,
                                 DeviceObject );

        //
        // currently, we use the wrapper's device object for all throttling.....

        RxDeviceObject = RxFileSystemDeviceObject;

        //  Check to see if this request should be sent to the overflow
        //  queue.  If not, then send it off to an exworker thread.

        KeAcquireSpinLock( &RxDeviceObject->OverflowQueueSpinLock, &SavedIrql );

        RequestCount = InterlockedIncrement(&RxDeviceObject->PostedRequestCount[WorkQueueType]);
        PostToWorkerThread = (RequestCount > FSP_PER_DEVICE_THRESHOLD);

        if (PostToWorkerThread) {
            //  We cannot currently respond to this IRP so we'll just enqueue it
            //  to the overflow queue on the volume.

            InterlockedDecrement(&RxDeviceObject->PostedRequestCount[WorkQueueType]);

            InsertTailList( &RxDeviceObject->OverflowQueue[WorkQueueType],
                            &RxContext->OverflowListEntry );

            RxDeviceObject->OverflowQueueCount[WorkQueueType] += 1;

            KeReleaseSpinLock( &RxDeviceObject->OverflowQueueSpinLock, SavedIrql );

            return;
        } else {
            KeReleaseSpinLock( &RxDeviceObject->OverflowQueueSpinLock, SavedIrql );
        }
    } else {
        PostToWorkerThread = TRUE;
    }

    ExInitializeWorkItem(
        &RxContext->WorkQueueItem,
        RxFspDispatch,
        RxContext );

    ExQueueWorkItem(
        (PWORK_QUEUE_ITEM)&RxContext->WorkQueueItem,
        WorkQueueType);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\precomp.h ===
#include "rx.h"
#include "ntddnfs2.h"   // NT network file system driver include file
#include "ntdddisk.h"
#include "rxdebug.h"
#include "ntdisp.h"
#include "rxwmi.h"

#pragma warning(error:4101)   // Unreferenced local variable


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\ntfsd.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxInit.c

Abstract:

    This module implements the FSD-level dispatch routine for the RDBSS.

Author:

    Joe Linn [JoeLinn]    2-dec-1994

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop
#include <ntddnfs.h>
#include <dfsfsctl.h>
#include "NtDspVec.h"

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_DISPATCH)

// the difference between dispatch problem and unimplemented is my judgement as to whether
// this represents a likely application error or not. in a free build, there's no difference.

NTSTATUS
RxCommonDispatchProblem ( RXCOMMON_SIGNATURE );

NTSTATUS
RxCommonUnimplemented ( RXCOMMON_SIGNATURE );

NTSTATUS
RxCommonUnsupported ( RXCOMMON_SIGNATURE );


VOID
RxInitializeTopLevelIrpPackage(
    void
    );


RX_FSD_DISPATCH_VECTOR RxFsdDispatchVector[IRP_MJ_MAXIMUM_FUNCTION + 1] = {
           DISPVECENTRY_NEW(CREATE,                    TRUE,    Create, 0x10),                  // 0x00
           DISPVECENTRY_NEW(CREATE_NAMED_PIPE,         TRUE,    Unimplemented, 0x10),           // 0x01
           DISPVECENTRY_NEW(CLOSE,                     TRUE,    Close, 0x10),                   // 0x02
           DISPVECENTRY_NEW(READ,                      TRUE,    Read, 0x10),                    // 0x03
           DISPVECENTRY_NEW(WRITE,                     TRUE,    Write, 0x10),                   // 0x04
           DISPVECENTRY_NEW(QUERY_INFORMATION,         TRUE,    QueryInformation, 0x10),        // 0x05
           DISPVECENTRY_NEW(SET_INFORMATION,           TRUE,    SetInformation, 0x10),          // 0x06
           DISPVECENTRY_NEW(QUERY_EA,                  TRUE,    QueryEa, 0x10),                 // 0x07
           DISPVECENTRY_NEW(SET_EA,                    TRUE,    SetEa, 0x10),                   // 0x08
           DISPVECENTRY_NEW(FLUSH_BUFFERS,             TRUE,    FlushBuffers, 0x10),            // 0x09
           DISPVECENTRY_NEW(QUERY_VOLUME_INFORMATION,  TRUE,    QueryVolumeInformation, 0x10),  // 0x0a
           DISPVECENTRY_NEW(SET_VOLUME_INFORMATION,    TRUE,    SetVolumeInformation, 0x10),           // 0x0b
           DISPVECENTRY_NEW(DIRECTORY_CONTROL,         TRUE,    DirectoryControl, 0x10),        // 0x0c
           DISPVECENTRY_NEW(FILE_SYSTEM_CONTROL,       TRUE,    FileSystemControl, 0x10),       // 0x0d
           DISPVECENTRY_NEW(DEVICE_CONTROL,            TRUE,    DeviceControl, 0x10),           // 0x0e
           DISPVECENTRY_NEW(INTERNAL_DEVICE_CONTROL,   TRUE,    DeviceControl, 0x10),           // 0x0f
           DISPVECENTRY_NEW(SHUTDOWN,                  TRUE,    Unimplemented, 0x10),           // 0x10
           DISPVECENTRY_NEW(LOCK_CONTROL,              TRUE,    LockControl, 0x10),             // 0x11
           DISPVECENTRY_NEW(CLEANUP,                   TRUE,    Cleanup, 0x10),                 // 0x12
           DISPVECENTRY_NEW(CREATE_MAILSLOT,           TRUE,    Unimplemented, 0x10),           // 0x13
           DISPVECENTRY_NEW(QUERY_SECURITY,            TRUE,    QuerySecurity, 0x10),           // 0x14
           DISPVECENTRY_NEW(SET_SECURITY,              TRUE,    SetSecurity, 0x10),             // 0x15
           DISPVECENTRY_NEW(POWER,                     TRUE,    Unimplemented, 0x10),           // 0x16
           DISPVECENTRY_NEW(WMI,                       TRUE,    Unimplemented, 0x10),           // 0x17
           DISPVECENTRY_NEW(DEVICE_CHANGE,             TRUE,    Unimplemented, 0x10),           // 0x18
           DISPVECENTRY_NEW(QUERY_QUOTA,               TRUE,    QueryQuotaInformation, 0x10),   // 0x19
           DISPVECENTRY_NEW(SET_QUOTA,                 TRUE,    SetQuotaInformation, 0x10),     // 0x1a
           DISPVECENTRY_NEW(PNP,                       TRUE,    Unimplemented, 0x10)            // 0x1b
           };

RX_FSD_DISPATCH_VECTOR RxDeviceFCBVector[IRP_MJ_MAXIMUM_FUNCTION + 1] = {
           DISPVECENTRY_NEW(CREATE,                   TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(CREATE_NAMED_PIPE,        TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(CLOSE,                    TRUE, DevFCBClose, 0x10),
           DISPVECENTRY_NEW(READ,                     TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(WRITE,                    TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(QUERY_INFORMATION,        TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(SET_INFORMATION,          TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(QUERY_EA,                 TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(SET_EA,                   TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(FLUSH_BUFFERS,            TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(QUERY_VOLUME_INFORMATION, TRUE, DevFCBQueryVolInfo, 0x10),
           DISPVECENTRY_NEW(SET_VOLUME_INFORMATION,   TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(DIRECTORY_CONTROL,        TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(FILE_SYSTEM_CONTROL,      TRUE, DevFCBFsCtl, 0x10),
           DISPVECENTRY_NEW(DEVICE_CONTROL,           TRUE, DevFCBIoCtl, 0x10),
           DISPVECENTRY_NEW(INTERNAL_DEVICE_CONTROL,  TRUE, DevFCBIoCtl, 0x10),
           DISPVECENTRY_NEW(SHUTDOWN,                 TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(LOCK_CONTROL,             TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(CLEANUP,                  TRUE, DevFCBCleanup, 0x10),
           DISPVECENTRY_NEW(CREATE_MAILSLOT,          TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(QUERY_SECURITY,           TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(SET_SECURITY,             TRUE, DispatchProblem, 0x10),
           DISPVECENTRY_NEW(POWER,                    TRUE, Unimplemented, 0x10),           // 0x16
           DISPVECENTRY_NEW(WMI,                      TRUE, Unimplemented, 0x10),           // 0x17
           DISPVECENTRY_NEW(DEVICE_CHANGE,            TRUE, Unimplemented, 0x10),           // 0x18
           DISPVECENTRY_NEW(QUERY_QUOTA,              TRUE, Unimplemented, 0x10),           // 0x19
           DISPVECENTRY_NEW(SET_QUOTA,                TRUE, Unimplemented, 0x10),           // 0x1a
           DISPVECENTRY_NEW(PNP,                      TRUE, Unimplemented, 0x10)            // 0x1b
           };

FAST_IO_DISPATCH RxFastIoDispatch;


NTSTATUS
RxFsdCommonDispatch (
    PRX_FSD_DISPATCH_VECTOR DispatchVector,
    IN UCHAR MajorFunctionCode,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxObject
    );

VOID
RxInitializeDispatchVectors(
    OUT PDRIVER_OBJECT DriverObject
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, RxInitializeDispatchVectors)
//not pageable SPINLOCK #pragma alloc_text(PAGE, RxFsdCommonDispatch)
#pragma alloc_text(PAGE, RxCommonDispatchProblem)
#pragma alloc_text(PAGE, RxCommonUnimplemented)
#pragma alloc_text(PAGE, RxCommonUnsupported)
#pragma alloc_text(PAGE, RxFsdDispatch)
#pragma alloc_text(PAGE, RxTryToBecomeTheTopLevelIrp)
#endif


VOID
RxInitializeDispatchVectors(
    OUT PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This routine initializes the dispatch table for the driver object

Arguments:

    DriverObject - Supplies the driver object

--*/
{
    ULONG i;
    PAGED_CODE();

    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = (PDRIVER_DISPATCH)RxFsdDispatch;
    }

    //      Set Dispatch Vector for the DevFCB

    RxDeviceFCB.PrivateDispatchVector = &RxDeviceFCBVector[0];

    ASSERT (RxFsdDispatchVector[IRP_MJ_MAXIMUM_FUNCTION].CommonRoutine != NULL);
    ASSERT (RxDeviceFCBVector[IRP_MJ_MAXIMUM_FUNCTION].CommonRoutine != NULL);

    DriverObject->FastIoDispatch = &RxFastIoDispatch;  //this is dangerous!!!

    RxFastIoDispatch.SizeOfFastIoDispatch =    sizeof(FAST_IO_DISPATCH);
    RxFastIoDispatch.FastIoCheckIfPossible =   RxFastIoCheckIfPossible;  //  CheckForFastIo
    RxFastIoDispatch.FastIoRead =              RxFastIoRead;              //  Read
    RxFastIoDispatch.FastIoWrite =             RxFastIoWrite;             //  Write
    RxFastIoDispatch.FastIoQueryBasicInfo =    NULL; //RxFastQueryBasicInfo;     //  QueryBasicInfo
    RxFastIoDispatch.FastIoQueryStandardInfo = NULL; //RxFastQueryStdInfo;       //  QueryStandardInfo
    RxFastIoDispatch.FastIoLock =              NULL; //RxFastLock;               //  Lock
    RxFastIoDispatch.FastIoUnlockSingle =      NULL; //RxFastUnlockSingle;       //  UnlockSingle
    RxFastIoDispatch.FastIoUnlockAll =         NULL; //RxFastUnlockAll;          //  UnlockAll
    RxFastIoDispatch.FastIoUnlockAllByKey =    NULL; //RxFastUnlockAllByKey;     //  UnlockAllByKey
    RxFastIoDispatch.FastIoDeviceControl =     RxFastIoDeviceControl;                      //  IoDeviceControl

    RxFastIoDispatch.AcquireForCcFlush = RxAcquireForCcFlush;
    RxFastIoDispatch.ReleaseForCcFlush = RxReleaseForCcFlush;
    RxFastIoDispatch.AcquireFileForNtCreateSection = RxAcquireFileForNtCreateSection;
    RxFastIoDispatch.ReleaseFileForNtCreateSection = RxReleaseFileForNtCreateSection;

    //  Initialize stuff for the toplevelirp package

    RxInitializeTopLevelIrpPackage();

    //  Initialize the cache manager callback routines

    RxData.CacheManagerCallbacks.AcquireForLazyWrite  = &RxAcquireFcbForLazyWrite;
    RxData.CacheManagerCallbacks.ReleaseFromLazyWrite = &RxReleaseFcbFromLazyWrite;
    RxData.CacheManagerCallbacks.AcquireForReadAhead  = &RxAcquireFcbForReadAhead;
    RxData.CacheManagerCallbacks.ReleaseFromReadAhead = &RxReleaseFcbFromReadAhead;

    RxData.CacheManagerNoOpCallbacks.AcquireForLazyWrite  = &RxNoOpAcquire;
    RxData.CacheManagerNoOpCallbacks.ReleaseFromLazyWrite = &RxNoOpRelease;
    RxData.CacheManagerNoOpCallbacks.AcquireForReadAhead  = &RxNoOpAcquire;
    RxData.CacheManagerNoOpCallbacks.ReleaseFromReadAhead = &RxNoOpRelease;
}


NTSTATUS
RxCommonDispatchProblem ( RXCOMMON_SIGNATURE )
{
   // if we get here then something is awry. this is used to initialize fields that SHOULD
   // not be accessed....like the create field in any vector but the highest level

    PAGED_CODE();

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("RxFsdDispatchPROBLEM: IrpC =%08lx,Code=", RxContext, RxContext->MajorFunction ));
    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("---------------------PROBLEM-----%s\n", "" ));
    RxLog(("%s %lx %ld\n","pDX", RxContext, RxContext->MajorFunction));
    RxWmiLog(LOG,
             RxCommonDispatchProblem,
             LOGPTR(RxContext)
             LOGUCHAR(RxContext->MajorFunction));

    // RxCompleteContextAndReturn( RxStatus(NOT_IMPLEMENTED) );
    return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS
RxCommonUnimplemented ( RXCOMMON_SIGNATURE )
{
    PAGED_CODE();

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("RxFsdDispatRxFsdUnImplementedchPROBLEM: IrpC =%08lx,Code=",
                        RxContext, RxContext->MajorFunction ));
    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("---------------------UNIMLEMENTED-----%s\n", "" ));

    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
RxCommonUnsupported ( RXCOMMON_SIGNATURE )
{
    PAGED_CODE();

    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("RxFsdDispatRxFsdUnSupportedchPROBLEM: IrpC =%08lx,Code=",
                        RxContext, RxContext->MajorFunction ));
    RxDbgTrace( 0, (DEBUG_TRACE_ALWAYS), ("---------------------UNSUPPORTED-----%s\n", "" ));

    return STATUS_NOT_SUPPORTED;
}


RxDbgTraceDoit(ULONG RxDbgTraceEnableCommand = 0xffff;)


WML_CONTROL_GUID_REG Rdbss_ControlGuids[] = {
   { // cddc01e2-fdce-479a-b8ee-3c87053fb55e Rdbss
     0xcddc01e2,0xfdce,0x479a,{0xb8,0xee,0x3c,0x87,0x05,0x3f,0xb5,0x5e},
     { // 529ae497-0a1f-43a5-8cb5-2aa60b497831
       {0x529ae497,0x0a1f,0x43a5,{0x8c,0xb5,0x2a,0xa6,0x0b,0x49,0x78,0x31},},
       // b7e3da1d-67f4-49bd-b9c0-1e61ce7417a8
       {0xb7e3da1d,0x67f4,0x49bd,{0xb9,0xc0,0x1e,0x61,0xce,0x74,0x17,0xa8},},
       // c966bef5-21c5-4630-84a0-4334875f41b8
       {0xc966bef5,0x21c5,0x4630,{0x84,0xa0,0x43,0x34,0x87,0x5f,0x41,0xb8},}
     },
   },  
};

#define Rdbss_ControlGuids_len  1

extern BOOLEAN EnableWmiLog;

NTSTATUS
RxSystemControl(
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN PIRP Irp)

/*++

Routine Description:

    This is the common routine for doing System control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

    InFsp - Indicates if this is the fsp thread or someother thread

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    WML_TINY_INFO Info;
    UNICODE_STRING RegPath;

    PAGED_CODE();

    if (EnableWmiLog) {
        RtlInitUnicodeString (&RegPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Rdbss");

        RtlZeroMemory (&Info, sizeof(Info));

        Info.ControlGuids = Rdbss_ControlGuids;
        Info.GuidCount = Rdbss_ControlGuids_len;
        Info.DriverRegPath = &RegPath;

        Status = WmlTinySystemControl(&Info,
                                      (PDEVICE_OBJECT)RxDeviceObject,
                                      Irp);
        
        if (Status != STATUS_SUCCESS) {
            //DbgPrint("Rdbss WMI control return %lx\n", Status);
        }
    } else {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return Status;
}

NTSTATUS
RxFsdDispatch (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine implements the FSD dispatch for the RDBSS.
Arguments:

    RxDeviceObject - Supplies the device object for the packet being processed.

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The Fsd status for the Irp

--*/
{
    NTSTATUS status;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );  //ok4ioget

    UCHAR MajorFunctionCode  = IrpSp->MajorFunction;
    PFILE_OBJECT FileObject  = IrpSp->FileObject;  //ok4->fileobj

    PRX_FSD_DISPATCH_VECTOR DispatchVector;

    PAGED_CODE();

    RxDbgTraceDoit(
        if (MajorFunctionCode == RxDbgTraceEnableCommand) {
            RxNextGlobalTraceSuppress =  RxGlobalTraceSuppress =  FALSE;
        }
        if (0) {
            RxNextGlobalTraceSuppress =  RxGlobalTraceSuppress =  FALSE;
        }
    );

    RxDbgTrace( 0, Dbg, ("RxFsdDispatch: Code =%02lx (%lu)  ----------%s-----------\n",
                                    MajorFunctionCode,
                                    ++RxIrpCodeCount[IrpSp->MajorFunction],
                                    RxIrpCodeToName[MajorFunctionCode] ));

    if (IrpSp->MajorFunction == IRP_MJ_SYSTEM_CONTROL) {
        return RxSystemControl(RxDeviceObject,Irp);
    }

    if ((MajorFunctionCode == IRP_MJ_CREATE_MAILSLOT) ||
        (MajorFunctionCode == IRP_MJ_CREATE_NAMED_PIPE)) {
        DispatchVector = NULL;
        status = STATUS_OBJECT_NAME_INVALID;
    } else {
        //  get a private dispatch table if there is one
        if (MajorFunctionCode == IRP_MJ_CREATE) {
            DispatchVector = RxFsdDispatchVector;
        } else if (FileObject != NULL && FileObject->FsContext != NULL) {
            if ((NodeTypeIsFcb((PFCB)(FileObject->FsContext))) &&
                (((PFCB)(FileObject->FsContext))->PrivateDispatchVector != NULL)) {  //ok4fscontext
                RxDbgTraceLV( 0, Dbg, 2500, ("Using Private Dispatch Vector\n"));
                DispatchVector = ((PFCB)(FileObject->FsContext))->PrivateDispatchVector;
            } else {
               DispatchVector = RxFsdDispatchVector;
            }

            if ((RxDeviceObject == RxFileSystemDeviceObject) &&
                ((MajorFunctionCode != IRP_MJ_CLOSE) ||
                 (MajorFunctionCode != IRP_MJ_DEVICE_CONTROL))
               ) {
                DispatchVector = NULL;
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
        } else {
            DispatchVector = NULL;
            status = STATUS_INVALID_DEVICE_REQUEST;
            RxDbgTrace(
                0,
                Dbg,
                ("RxFsdDispatch: Code =%02lx (%lu)  ----------%s-----------\n",
                 MajorFunctionCode,
                 ++RxIrpCodeCount[IrpSp->MajorFunction],
                 RxIrpCodeToName[MajorFunctionCode]));
        }
    }

    if (DispatchVector != NULL) {

        status = RxFsdCommonDispatch( DispatchVector,
                                     MajorFunctionCode,
                                     IrpSp,
                                     FileObject,
                                     Irp,
                                     RxDeviceObject );

        RxDbgTrace( 0, Dbg, ("RxFsdDispatch: Status =%02lx  %s....\n",
                             status,
                             RxIrpCodeToName[MajorFunctionCode] ));

        RxDbgTraceDoit(
            if (RxGlobalTraceIrpCount > 0) {
                RxGlobalTraceIrpCount -= 1;
                RxGlobalTraceSuppress = FALSE;
            } else {
                RxGlobalTraceSuppress = RxNextGlobalTraceSuppress;
            }
       );

    } else {
        IoMarkIrpPending(Irp);

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        status = STATUS_PENDING;
    }

    return status;
}


NTSTATUS
RxFsdCommonDispatch (
    PRX_FSD_DISPATCH_VECTOR DispatchVector,
    IN UCHAR MajorFunctionCode,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFILE_OBJECT FileObject,
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
/*++

Routine Description:

    This routine implements the FSD part of dispatch for IRP's

Arguments:

    DispatchVector    - the dispatch vector

    MajorFunctionCode - the IRP major function

    IrpSp             - the IRP stack

    FileObject        - the file object

    Irp               - the IRP

Return Value:

    RXSTATUS - The FSD status for the IRP

Notes:


--*/
{  //not currently pageable.......
    NTSTATUS    Status = STATUS_SUCCESS;

    PRX_CONTEXT RxContext = NULL;
    RX_TOPLEVELIRP_CONTEXT TopLevelContext;
    UCHAR       MinorFunctionCode  = IrpSp->MinorFunction;

    BOOLEAN TopLevel = FALSE;
    ULONG ContextFlags = 0;
    BOOLEAN Wait;
    BOOLEAN Cancellable;
    BOOLEAN ModWriter          = FALSE;
    BOOLEAN fCleanupOrClose    = FALSE;
    BOOLEAN fContinueOperation = TRUE;

    KIRQL          SavedIrql;
    BOOLEAN        PostRequest = FALSE;
    PRX_DISPATCH   DispatchRoutine = NULL;
    PDRIVER_CANCEL CancelRoutine = NULL;

    //RxDbgTraceLV(+1, Dbg, 1500, ("RxFsd[%s]\n", RxIrpCodeToName[MajorFunctionCode]));

    //TimerStart(Dbg);

    FsRtlEnterFileSystem();

    TopLevel = RxTryToBecomeTheTopLevelIrp( &TopLevelContext, Irp, RxDeviceObject, FALSE ); //dont force

    try {
        // Treat all operations as being cancellable and waitable.
        Wait          = RX_CONTEXT_FLAG_WAIT;
        Cancellable   = TRUE;
        CancelRoutine = RxCancelRoutine;

        // Retract the capability based upon the operation
        switch (MajorFunctionCode) {
        case IRP_MJ_FILE_SYSTEM_CONTROL:
            //  Call the common FileSystem Control routine, with blocking allowed if
            //  synchronous.  This opeation needs to special case the mount
            //  and verify suboperations because we know they are allowed to block.
            //  We identify these suboperations by looking at the file object field
            //  and seeing if its null.

            Wait = (FileObject == NULL) ? TRUE : CanFsdWait( Irp );
            break;

        case IRP_MJ_READ:
        case IRP_MJ_LOCK_CONTROL:
        case IRP_MJ_DIRECTORY_CONTROL:
        case IRP_MJ_QUERY_VOLUME_INFORMATION:
        case IRP_MJ_WRITE:
        case IRP_MJ_QUERY_INFORMATION:
        case IRP_MJ_SET_INFORMATION:
        case IRP_MJ_QUERY_EA:
        case IRP_MJ_SET_EA:
        case IRP_MJ_QUERY_SECURITY:
        case IRP_MJ_SET_SECURITY:
        case IRP_MJ_FLUSH_BUFFERS:
        case IRP_MJ_DEVICE_CONTROL:
        case IRP_MJ_SET_VOLUME_INFORMATION:

            Wait = CanFsdWait( Irp );
            break;

        case IRP_MJ_CLEANUP:
        case IRP_MJ_CLOSE:
            Cancellable     = FALSE;
            fCleanupOrClose = TRUE;
            break;
        default:
            break;
        }

        KeAcquireSpinLock(&RxStrucSupSpinLock,&SavedIrql);
        fContinueOperation = TRUE;

        switch (RxDeviceObject->StartStopContext.State) {
        case RDBSS_STARTABLE: //here only device creates and device operations can go thru
           {
              if ((DispatchVector == RxDeviceFCBVector) ||
                  ((FileObject->FileName.Length == 0) &&
                  (FileObject->RelatedFileObject == NULL))) {
                 NOTHING;
              } else {
                 fContinueOperation = FALSE;
                 Status = STATUS_REDIRECTOR_NOT_STARTED;
              }
           }
           break;
        case RDBSS_STOP_IN_PROGRESS:
           if (!fCleanupOrClose) {
              fContinueOperation = FALSE;
              Status = STATUS_REDIRECTOR_NOT_STARTED;
           }
           break;
        //case RDBSS_STOPPED:
        //   {
        //      if ((MajorFunctionCode == IRP_MJ_FILE_SYSTEM_CONTROL) &&
        //          (MinorFunctionCode == IRP_MN_USER_FS_REQUEST) &&
        //          (IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_LMR_START)) {
        //         RxDeviceObject->StartStopContext.State = RDBSS_START_IN_PROGRESS;
        //         RxDeviceObject->StartStopContext.Version++;
        //         fContinueOperation = TRUE;
        //      } else {
        //         fContinueOperation = FALSE;
        //         Status = STATUS_REDIRECTOR_NOT_STARTED);
        //      }
        //   }
        case RDBSS_STARTED:
           // intentional break;
        default:
           break;
        }

        KeReleaseSpinLock(&RxStrucSupSpinLock,SavedIrql);

        if ((IrpSp->FileObject != NULL) &&
            (IrpSp->FileObject->FsContext != NULL)) {
            
            PFCB pFcb = (PFCB)IrpSp->FileObject->FsContext;
            BOOLEAN fOrphaned = FALSE;

            if ((IrpSp->FileObject->FsContext2 != UIntToPtr(DFS_OPEN_CONTEXT)) &&
                (IrpSp->FileObject->FsContext2 != UIntToPtr(DFS_DOWNLEVEL_OPEN_CONTEXT)))

            {
                fOrphaned = (FlagOn(pFcb->FcbState,FCB_STATE_ORPHANED) != 0);

                if (!fOrphaned && IrpSp->FileObject->FsContext2)
                {
                    PFOBX pFobx = (PFOBX)IrpSp->FileObject->FsContext2;
                    fOrphaned = (FlagOn(pFobx->SrvOpen->Flags, SRVOPEN_FLAG_ORPHANED) != 0);
                }

            }
            
            if (fOrphaned) {
                if (!fCleanupOrClose) {

                    RxDbgTrace(
                        0,
                        Dbg,
                        ("Ignoring operation on ORPHANED FCB %lx %lx %lx\n",
                         pFcb,MajorFunctionCode,MinorFunctionCode));

                    fContinueOperation = FALSE;
                    Status = STATUS_UNEXPECTED_NETWORK_ERROR;
                    RxLog(("#### Orphaned FCB op %lx\n",pFcb));
                    RxWmiLog(LOG,
                             RxFsdCommonDispatch_OF,
                             LOGPTR(pFcb));
                } else {
                    RxDbgTrace(
                        0,
                        Dbg,
                        ("Delayed Close/Cleanup on ORPHANED FCB %lx\n",pFcb));

                    fContinueOperation = TRUE;
                }
            }
        }

        if (RxDeviceObject->StartStopContext.State == RDBSS_STOP_IN_PROGRESS) {
            if (fCleanupOrClose) {
                PFILE_OBJECT pFileObject = IrpSp->FileObject;
                PFCB         pFcb        = (PFCB)pFileObject->FsContext;

                RxDbgPrint(("RDBSS -- Close after Stop"));
                RxDbgPrint(("RDBSS: Irp(%lx) MJ %ld MN %ld FileObject(%lx) FCB(%lx) \n",
                       Irp,IrpSp->MajorFunction,IrpSp->MinorFunction,pFileObject,pFcb));

                if ((pFileObject != NULL)
                       && (pFcb != NULL)
                       && (pFcb != &RxDeviceFCB)
                       && NodeTypeIsFcb(pFcb)) {
                    RxDbgPrint((
                        "RDBSS: OpenCount(%ld) UncleanCount(%ld) Name(%wZ)\n",
                         pFcb->OpenCount,
                         pFcb->UncleanCount,
                         &pFcb->FcbTableEntry.Path));
                }
             }
        }

        if (!fContinueOperation) {
            if ((MajorFunctionCode != IRP_MJ_DIRECTORY_CONTROL)||
                (MinorFunctionCode !=IRP_MN_NOTIFY_CHANGE_DIRECTORY))
            {
                IoMarkIrpPending(Irp);

                Irp->IoStatus.Status = Status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);

                Status = STATUS_PENDING;
            }
            else
            {
                // this is a changenotify directory control
                // Fail the operation
                // The usermode API cannot get the error in the IO status block
                // correctly, due to the way FindFirstChangeNotify/FindNextChangeNotify
                // APIs are designed

                Irp->IoStatus.Status = Status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }
            try_return(Status);
        }

        if (Wait) {
            SetFlag(ContextFlags,RX_CONTEXT_FLAG_WAIT);
        }
        RxContext = RxCreateRxContext( Irp, RxDeviceObject, ContextFlags );
        if (RxContext == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            RxCompleteRequest_OLD( RxNull, Irp, Status );
            try_return( Status );
        }

        // Assume ownership of the Irp by setting the cancelling routine.
        if (Cancellable) {
           RxSetCancelRoutine(Irp,CancelRoutine);
        } else {
           // Ensure that those operations regarded as non cancellable will
           // not be cancelled.
           RxSetCancelRoutine(Irp,NULL);
        }

        ASSERT(MajorFunctionCode <= IRP_MJ_MAXIMUM_FUNCTION);

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status      = STATUS_SUCCESS;

        DispatchRoutine = DispatchVector[MajorFunctionCode].CommonRoutine;

        switch (MajorFunctionCode) {
        case IRP_MJ_READ:
        case IRP_MJ_WRITE:
            //  If this is an Mdl complete request, don't go through
            //  common read.
            if ( FlagOn(MinorFunctionCode, IRP_MN_COMPLETE) ) {
                DispatchRoutine = RxCompleteMdl;
            } else if ( FlagOn(MinorFunctionCode, IRP_MN_DPC) ) {
               //  Post all DPC calls.
                RxDbgTrace(0, Dbg, ("Passing DPC call to Fsp\n", 0 ));
                PostRequest = TRUE;
            } else if ((MajorFunctionCode == IRP_MJ_READ) &&
                       (IoGetRemainingStackSize() < 0xe00)) {
               //
               //  Check if we have enough stack space to process this request.  If there
               //  isn't enough then we will pass the request off to the stack overflow thread.
               //
               // NTBUG 61951 Shishirp 2/23/2000 where did the number come from......
               // this number should come from the minirdr....only he knows how much he needs
               // and in my configuration it should definitely be bigger than for FAT!
               // plus......i can't go to the net on the hypercrtical thread!!! this will have to be
               // reworked! maybe we should have our own hypercritical thread............
               
               RxDbgTrace(0, Dbg, ("Passing StackOverflowRead off\n", 0 ));

               RxContext->PendingReturned = TRUE;

               Status = RxPostStackOverflowRead( RxContext);

               if (Status != STATUS_PENDING) {
                   RxContext->PendingReturned = FALSE;
                   RxCompleteRequest(RxContext,Status);
               }

               try_return(Status);
            }
            break;
        default:
            NOTHING;
        }

        //
        // set the resume routine for the fsp to be the dispatch routine and then either post immediately
        // or calldow to the common dispatch as appropriate

        RxContext->ResumeRoutine = DispatchRoutine;

        if( DispatchRoutine != NULL ) {
            RxContext->PendingReturned = TRUE;

            if (PostRequest) {
               Status = RxFsdPostRequest(RxContext);
            } else {
                do {

                     Status = DispatchRoutine( RXCOMMON_ARGUMENTS );

                } while (Status == STATUS_RETRY);

                if (Status != STATUS_PENDING) {
                    if (! ((RxContext->CurrentIrp    == Irp)               &&
                           (RxContext->CurrentIrpSp  == IrpSp)             &&
                           (RxContext->MajorFunction == MajorFunctionCode) &&
                           (RxContext->MinorFunction == MinorFunctionCode) )
                           ) {
                        DbgPrint("RXCONTEXT CONTAMINATED!!!! rxc=%08lx\n", RxContext);
                        DbgPrint("-irp> %08lx %08lx\n",RxContext->CurrentIrp,Irp);
                        DbgPrint("--sp> %08lx %08lx\n",RxContext->CurrentIrpSp,IrpSp);
                        DbgPrint("--mj> %08lx %08lx\n",RxContext->MajorFunction,MajorFunctionCode);
                        DbgPrint("--mn> %08lx %08lx\n",RxContext->MinorFunction,MinorFunctionCode);
                        //DbgBreakPoint();
                    }

                    RxContext->PendingReturned = FALSE;

                    Status = RxCompleteRequest( RxContext, Status );
                }
            }
        } else {
            Status = STATUS_NOT_IMPLEMENTED;
        }

    try_exit: NOTHING;
    } except(RxExceptionFilter( RxContext, GetExceptionInformation() )) {

        //  The I/O request was not handled successfully, abort the I/O request with
        //  the error status that we get back from the execption code
        if (RxContext != NULL) {
            RxContext->PendingReturned = FALSE;
        }

        Status = RxProcessException( RxContext, GetExceptionCode() );
    }

    if (TopLevel) {
       RxUnwindTopLevelIrp( &TopLevelContext );
    }

    FsRtlExitFileSystem();

    //RxDbgTraceLV(-1, Dbg, 1500, ("RxFsd[%s] Status-> %08lx\n", RxIrpCodeToName[MajorFunctionCode],Status));

    //TimerStop(Dbg,"RxFsdCreate");

    return Status;

#if DBG
    NOTHING;
#else
    UNREFERENCED_PARAMETER( IrpSp );
#endif
}

#ifdef RX_PRIVATE_BUILD
#undef IoGetTopLevelIrp
#undef IoSetTopLevelIrp
#endif //ifdef RX_PRIVATE_BUILD
#define RX_TOPLEVELCTX_FLAG_FROM_POOL (0x00000001)

KSPIN_LOCK TopLevelIrpSpinLock;
LIST_ENTRY TopLevelIrpAllocatedContextsList;

VOID
RxInitializeTopLevelIrpPackage(
    void
    )
{
    KeInitializeSpinLock( &TopLevelIrpSpinLock );
    InitializeListHead(&TopLevelIrpAllocatedContextsList);
}

VOID
RxAddToTopLevelIrpAllocatedContextsList(
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext
    )
/*++

Routine Description:

    This the passed context is added to the allocatedcontexts list. THIS
    ROUTINE TAKES A SPINLOCK...CANNOT BE PAGED.

Arguments:

    TopLevelContext - the context to be removed

Return Value:


--*/
{
    KIRQL SavedIrql;
    ASSERT(TopLevelContext->Signature == RX_TOPLEVELIRP_CONTEXT_SIGNATURE);
    ASSERT(FlagOn(TopLevelContext->Flags,RX_TOPLEVELCTX_FLAG_FROM_POOL));
    KeAcquireSpinLock(&TopLevelIrpSpinLock,&SavedIrql);
    InsertHeadList(&TopLevelIrpAllocatedContextsList,
                   &TopLevelContext->ListEntry);
    KeReleaseSpinLock(&TopLevelIrpSpinLock,SavedIrql);
}

VOID
RxRemoveFromTopLevelIrpAllocatedContextsList(
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext
    )
/*++

Routine Description:

    This the passed context is removed from the allocatedcontexts list. THIS
    ROUTINE TAKES A SPINLOCK...CANNOT BE PAGED.

Arguments:

    TopLevelContext - the context to be removed

Return Value:


--*/
{
    KIRQL SavedIrql;
    ASSERT(TopLevelContext->Signature == RX_TOPLEVELIRP_CONTEXT_SIGNATURE);
    ASSERT(FlagOn(TopLevelContext->Flags,RX_TOPLEVELCTX_FLAG_FROM_POOL));
    KeAcquireSpinLock(&TopLevelIrpSpinLock,&SavedIrql);
    RemoveEntryList(&TopLevelContext->ListEntry);
    KeReleaseSpinLock(&TopLevelIrpSpinLock,SavedIrql);
}

BOOLEAN
RxIsMemberOfTopLevelIrpAllocatedContextsList(
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext
    )
/*++

Routine Description:

    This looks to see if the passed context is on the allocatedcontexts list.
    THIS ROUTINE TAKES A SPINLOCK...CANNOT BE PAGED.

Arguments:

    TopLevelContext - the context to be looked up

Return Value:

    TRUE if TopLevelContext is on the list, FALSE otherwise

--*/
{
    KIRQL         SavedIrql;
    PLIST_ENTRY   pListEntry;
    BOOLEAN Found = FALSE;

    KeAcquireSpinLock(&TopLevelIrpSpinLock,&SavedIrql);

    pListEntry = TopLevelIrpAllocatedContextsList.Flink;

    while (pListEntry != &TopLevelIrpAllocatedContextsList) {
        PRX_TOPLEVELIRP_CONTEXT ListTopLevelContext
               = CONTAINING_RECORD(pListEntry,RX_TOPLEVELIRP_CONTEXT,ListEntry);

        ASSERT(ListTopLevelContext->Signature == RX_TOPLEVELIRP_CONTEXT_SIGNATURE);
        ASSERT(FlagOn(ListTopLevelContext->Flags,RX_TOPLEVELCTX_FLAG_FROM_POOL));

        if (ListTopLevelContext == TopLevelContext) {
            Found = TRUE;
            break;
        } else {
            pListEntry = pListEntry->Flink;
        }
    }

    KeReleaseSpinLock(&TopLevelIrpSpinLock,SavedIrql);
    return(Found);

}

BOOLEAN
RxIsThisAnRdbssTopLevelContext (
    IN PRX_TOPLEVELIRP_CONTEXT TopLevelContext
    )
{
    ULONG_PTR StackBottom;
    ULONG_PTR StackTop;
    // if it's a magic value....then no
    if ((ULONG_PTR)TopLevelContext <= FSRTL_MAX_TOP_LEVEL_IRP_FLAG) {
        return(FALSE);
    }

    //if it's on the stack...check the signature
    IoGetStackLimits( &StackTop, &StackBottom);
    if (((ULONG_PTR) TopLevelContext <= StackBottom - sizeof( RX_TOPLEVELIRP_CONTEXT )) &&
        ((ULONG_PTR) TopLevelContext >= StackTop)) {

        //it's on the stack check it

        if (!FlagOn( (ULONG_PTR) TopLevelContext, 0x3 ) &&
            (TopLevelContext->Signature == RX_TOPLEVELIRP_CONTEXT_SIGNATURE) ) {
            return TRUE;
        } else {
            return(FALSE);
        }
    }

    return RxIsMemberOfTopLevelIrpAllocatedContextsList(TopLevelContext);
}


BOOLEAN
RxTryToBecomeTheTopLevelIrp (
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext,
    IN      PIRP Irp,
    IN      PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN      BOOLEAN ForceTopLevel
    )
/*++

Routine Description:

    This routine detects if an Irp is the Top level requestor, ie. if it os OK
    to do a verify or pop-up now.  If TRUE is returned, then no file system
    resources are held above us. Also, we have left a context in TLS that will
    allow us to tell if we are the top level...even if we are entered recursively.

Arguments:

    TopLevelContext -  the toplevelirp context to use. if NULL, allocate one
    Irp             -  the irp. could be a magic value
    RxDeviceObject  -  the associated deviceobject
    ForceTopLevel   -  if true, we force ourselves onto the TLS

Return Value:

    BOOLEAN tells whether we became the toplevel.

--*/
{
    ULONG ContextFlags = 0;
    PAGED_CODE();

    if ( (IoGetTopLevelIrp() != NULL ) && !ForceTopLevel ) {
        return(FALSE);
    }

    // i hate doing this allocate....toplevelirp is the world's biggest kludge
    if (TopLevelContext == NULL) {
        TopLevelContext = RxAllocatePool( NonPagedPool, sizeof(RX_TOPLEVELIRP_CONTEXT) );
        if (TopLevelContext == NULL) {
            return(FALSE);
        }
        ContextFlags = RX_TOPLEVELCTX_FLAG_FROM_POOL;
    }

    __RxInitializeTopLevelIrpContext(TopLevelContext,
                                     Irp,
                                     RxDeviceObject,
                                     ContextFlags);

    ASSERT(TopLevelContext->Signature == RX_TOPLEVELIRP_CONTEXT_SIGNATURE);
    if (ContextFlags!=0) {
        ASSERT(FlagOn(TopLevelContext->Flags,RX_TOPLEVELCTX_FLAG_FROM_POOL));
    }
    IoSetTopLevelIrp( (PIRP)TopLevelContext );
    return TRUE;
}

VOID
__RxInitializeTopLevelIrpContext (
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext,
    IN      PIRP Irp,
    IN      PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN      ULONG Flags
    )
/*++

Routine Description:

    This routine initalizes a toplevelirp context.

Arguments:

    TopLevelContext -  the toplevelirp context to use.
    Irp             -  the irp. could be a magic value
    RxDeviceObject  -  the associated deviceobject
    Flags           -  could be various...currently just tells if context is allocated or not

Return Value:

    None.

--*/
{
    RtlZeroMemory(TopLevelContext,sizeof(RX_TOPLEVELIRP_CONTEXT));
    TopLevelContext->Signature = RX_TOPLEVELIRP_CONTEXT_SIGNATURE;
    TopLevelContext->Irp = Irp;
    TopLevelContext->Flags = Flags;
    TopLevelContext->RxDeviceObject = RxDeviceObject;
    TopLevelContext->Previous = IoGetTopLevelIrp();
    TopLevelContext->Thread = PsGetCurrentThread();

    //if this is an allocated context, add it to the allocatedcontextslist

    if (FlagOn(TopLevelContext->Flags,RX_TOPLEVELCTX_FLAG_FROM_POOL)) {
        RxAddToTopLevelIrpAllocatedContextsList(TopLevelContext);
    }
}



VOID
RxUnwindTopLevelIrp (
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext
    )
/*++

Routine Description:

    This routine removes us from the TLC....replacing by the previous.

Arguments:

    TopLevelContext -  the toplevelirp context to use. if NULL, use the one from TLS

Return Value:

    None.

--*/
{
    if (TopLevelContext==NULL) {
        //get the one off the thread and do some asserts to make sure it's me
        TopLevelContext = (PRX_TOPLEVELIRP_CONTEXT)(IoGetTopLevelIrp());

        // depending on a race condition, this context could be NULL.
        // we chkec it before hand and bail if so.
        // In this case the Irp was completed by another thread.
        if (!TopLevelContext)
        {
            return;
        }
        
        ASSERT(RxIsThisAnRdbssTopLevelContext(TopLevelContext));
        ASSERT(FlagOn(TopLevelContext->Flags,RX_TOPLEVELCTX_FLAG_FROM_POOL));
    }

    ASSERT(TopLevelContext->Signature == RX_TOPLEVELIRP_CONTEXT_SIGNATURE);
    ASSERT(TopLevelContext->Thread == PsGetCurrentThread());
    IoSetTopLevelIrp( TopLevelContext->Previous );
    if (FlagOn(TopLevelContext->Flags,RX_TOPLEVELCTX_FLAG_FROM_POOL)) {
        RxRemoveFromTopLevelIrpAllocatedContextsList(TopLevelContext);
        RxFreePool(TopLevelContext);
    }
}

BOOLEAN
RxIsThisTheTopLevelIrp (
    IN      PIRP Irp
    )
/*++

Routine Description:

    This determines if the irp at hand is the toplevel irp.

Arguments:

    Irp - the one to find out if it's toplevel...btw, it works for NULL.

Return Value:

    TRUE if irp is the toplevelirp.

--*/
{
    PIRP TopIrp = IoGetTopLevelIrp();
    PRX_TOPLEVELIRP_CONTEXT TopLevelContext;

    TopLevelContext = (PRX_TOPLEVELIRP_CONTEXT)TopIrp;

    if (RxIsThisAnRdbssTopLevelContext(TopLevelContext)) {
        TopIrp = TopLevelContext->Irp;
    }

    return ( TopIrp == Irp );
}

PIRP
RxGetTopIrpIfRdbssIrp (
    void
    )
/*++

Routine Description:

    This gets the toplevelirp if it belongs to the rdbss.

Arguments:



Return Value:

    topirp if topirp is rdbss-irp and NULL otherwise.

--*/
{
    PRX_TOPLEVELIRP_CONTEXT TopLevelContext;

    TopLevelContext = (PRX_TOPLEVELIRP_CONTEXT)(IoGetTopLevelIrp());

    if (RxIsThisAnRdbssTopLevelContext(TopLevelContext)) {
        return TopLevelContext->Irp;
    } else {
        return NULL;
    }
}


PRDBSS_DEVICE_OBJECT
RxGetTopDeviceObjectIfRdbssIrp (
    void
    )
/*++

Routine Description:

    This gets the deviceobject assoc'd w/ toplevelirp if topirp belongs to the rdbss.

Arguments:



Return Value:

    deviceobject for topirp if topirp is rdbss-irp and NULL otherwise.

--*/
{
    PRX_TOPLEVELIRP_CONTEXT TopLevelContext;

    TopLevelContext = (PRX_TOPLEVELIRP_CONTEXT)(IoGetTopLevelIrp());

    if (RxIsThisAnRdbssTopLevelContext(TopLevelContext)) {
        return TopLevelContext->RxDeviceObject;
    } else {
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\read.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Read.c

Abstract:

    This module implements the File Read routine for Read called by the
    dispatch driver.

Author:

    Joe Linn      [JoeLinn]      11-Oct-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_READ)

//
//  The following procedures handles read stack overflow operations.

VOID
RxStackOverflowRead (
    IN PVOID Context,
    IN PKEVENT Event
    );

NTSTATUS
RxPostStackOverflowRead (
    IN PRX_CONTEXT RxContext
    );

//
//  The following procedures are the handle the procedureal interface with lowio.


NTSTATUS
RxLowIoReadShell (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxLowIoReadShellCompletion (
    IN PRX_CONTEXT RxContext
    );

#if DBG
VOID CheckForLoudOperations(
    PRX_CONTEXT RxContext
    );
#else
#define CheckForLoudOperations(___r)
#endif

//
//  This macro just puts a nice little try-except around RtlZeroMemory
//

#define SafeZeroMemory(AT,BYTE_COUNT) {                            \
    try {                                                          \
        RtlZeroMemory((AT), (BYTE_COUNT));                         \
    } except(EXCEPTION_EXECUTE_HANDLER) {                          \
         RxRaiseStatus( RxContext, STATUS_INVALID_USER_BUFFER );   \
    }                                                              \
}

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxStackOverflowRead)
#pragma alloc_text(PAGE, RxPostStackOverflowRead)
#pragma alloc_text(PAGE, RxCommonRead)
#pragma alloc_text(PAGE, RxLowIoReadShellCompletion)
#pragma alloc_text(PAGE, RxLowIoReadShell)
#if DBG
#pragma alloc_text(PAGE, CheckForLoudOperations)
#endif //DBG
#endif


//
//  Internal support routine
//

NTSTATUS
RxPostStackOverflowRead (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    This routine posts a read request that could not be processed by
    the fsp thread because of stack overflow potential.

Arguments:

    RxContext - the usual

Return Value:

    RxStatus(PENDING).

--*/

{
    NTSTATUS  Status;

    RxCaptureRequestPacket;
    RxCaptureFcb;

    PKEVENT Event;
    PERESOURCE Resource;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("Getting too close to stack limit pass request to Fsp\n", 0 ));

    //
    //  Allocate an event and get shared on the resource we will
    //  be later using the common read.

    Event = RxAllocatePool( NonPagedPool, sizeof(KEVENT) );

    if (Event != NULL) {
        KeInitializeEvent( Event, NotificationEvent, FALSE );

        if (FlagOn(capReqPacket->Flags, IRP_PAGING_IO) && (capFcb->Header.PagingIoResource != NULL)) {

            Resource = capFcb->Header.PagingIoResource;

        } else {

            Resource = capFcb->Header.Resource;
        }

        ExAcquireResourceSharedLite( Resource, TRUE );

        try {

            //
            //  Make the Irp just like a regular post request and
            //  then send the Irp to the special overflow thread.
            //  After the post we will wait for the stack overflow
            //  read routine to set the event so that we can
            //  then release the fcb resource and return.

            RxPrePostIrp( RxContext, capReqPacket );

            FsRtlPostStackOverflow( RxContext, Event, RxStackOverflowRead );

            //
            //  And wait for the worker thread to complete the item

            (VOID) KeWaitForSingleObject( Event, Executive, KernelMode, FALSE, NULL );

        } finally {

            ExReleaseResourceLite( Resource );

            RxFreePool( Event );
        }

        Status = STATUS_PENDING;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}


//
//  Internal support routine
//

VOID
RxStackOverflowRead (
    IN PVOID Context,
    IN PKEVENT Event
    )
/*++

Routine Description:

    This routine processes a read request that could not be processed by
    the fsp thread because of stack overflow potential.

Arguments:

    Context - the RxContext being processed

    Event - the event to be signaled when we've finished this request.

Return Value:

    None.

--*/

{
    PRX_CONTEXT RxContext = Context;
    RxCaptureRequestPacket;

    PAGED_CODE();

    //
    //  Make it now look like we can wait for I/O to complete

    SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_WAIT );

    //
    //  Do the read operation protected by a try-except clause

    try {

        (VOID) RxCommonRead( RxContext );

    } except(RxExceptionFilter( RxContext, GetExceptionInformation() )) {

        NTSTATUS ExceptionCode;

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with the
        //  error status that we get back from the execption code

        ExceptionCode = GetExceptionCode();

        if (ExceptionCode == STATUS_FILE_DELETED) {

            RxContext->StoredStatus = ExceptionCode = STATUS_END_OF_FILE;
            capReqPacket->IoStatus.Information = 0;
        }

        (VOID) RxProcessException( RxContext, ExceptionCode );
    }

    //
    //  Signal the original thread that we're done.

    KeSetEvent( Event, 0, FALSE );
}


NTSTATUS
RxCommonRead ( RXCOMMON_SIGNATURE )

/*++

Routine Description:

    This is the common read routine for NtReadFile, called from both
    the Fsd, or from the Fsp if a request could not be completed without
    blocking in the Fsd.  This routine has no code where it determines
    whether it is running in the Fsd or Fsp.  Instead, its actions are
    conditionalized by the Wait input parameter, which determines whether
    it is allowed to block or not.  If a blocking condition is encountered
    with Wait == FALSE, however, the request is posted to the Fsp, who
    always calls with WAIT == TRUE.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/

{

    NTSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureFobx; RxCaptureParamBlock; RxCaptureFileObject;
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);
    PRDBSS_DEVICE_OBJECT RxDeviceObject = RxContext->RxDeviceObject;

    LARGE_INTEGER StartingByte;
    RXVBO StartingVbo;
    ULONG ByteCount;

    ULONG CapturedRxContextSerialNumber = RxContext->SerialNumber;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    BOOLEAN PostIrp = FALSE;
    BOOLEAN OplockPostIrp = FALSE;

    BOOLEAN FcbAcquired = FALSE;
    BOOLEAN RefdContextForTracker = FALSE;

    BOOLEAN Wait;
    BOOLEAN PagingIo;
    BOOLEAN NonCachedIo;
    BOOLEAN SynchronousIo;

    PNET_ROOT NetRoot = (PNET_ROOT)(capFcb->pNetRoot);
    BOOLEAN ThisIsAPipeRead = (BOOLEAN)(NetRoot->Type == NET_ROOT_PIPE);
    BOOLEAN ThisIsABlockingResume = BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_BLOCKED_PIPE_RESUME);

    PAGED_CODE();

    //
    // Initialize the local decision variables.
    //

    Wait          = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    PagingIo      = BooleanFlagOn(capReqPacket->Flags, IRP_PAGING_IO);
    NonCachedIo   = BooleanFlagOn(capReqPacket->Flags,IRP_NOCACHE);
    SynchronousIo = !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);

    RxDbgTrace(+1, Dbg, ("RxCommonRead...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, capFobx, capFcb));
    RxDbgTrace( 0, Dbg, ("  ->ByteCount = %08lx, ByteOffset = %08lx %lx\n",
                         capPARAMS->Parameters.Read.Length,
                         capPARAMS->Parameters.Read.ByteOffset.LowPart,
                         capPARAMS->Parameters.Read.ByteOffset.HighPart));
    RxDbgTrace( 0, Dbg,("  ->%s%s%s%s\n",
                    Wait          ?"Wait ":"",
                    PagingIo      ?"PagingIo ":"",
                    NonCachedIo   ?"NonCachedIo ":"",
                    SynchronousIo ?"SynchronousIo ":""
               ));

    RxLog(("CommonRead %lx %lx %lx\n", RxContext, capFobx, capFcb));
    RxWmiLog(LOG,
             RxCommonRead_1,
             LOGPTR(RxContext)
             LOGPTR(capFobx)
             LOGPTR(capFcb));
    RxLog(("   read %lx@%lx %lx %s%s%s%s\n",
             capPARAMS->Parameters.Read.Length,
             capPARAMS->Parameters.Read.ByteOffset.LowPart,
             capPARAMS->Parameters.Read.ByteOffset.HighPart,
             Wait?"Wt":"",
             PagingIo?"Pg":"",
             NonCachedIo?"Nc":"",
             SynchronousIo?"Sync":""
          ));
    RxWmiLog(LOG,
             RxCommonRead_2,
             LOGULONG(capPARAMS->Parameters.Read.Length)
             LOGULONG(capPARAMS->Parameters.Read.ByteOffset.LowPart)
             LOGULONG(capPARAMS->Parameters.Read.ByteOffset.HighPart)
             LOGUCHAR(Wait)
             LOGUCHAR(PagingIo)
             LOGUCHAR(NonCachedIo)
             LOGUCHAR(SynchronousIo));

    RxItsTheSameContext();
    capReqPacket->IoStatus.Information = 0;

    //
    //  Extract starting Vbo and offset.
    //

    StartingByte = capPARAMS->Parameters.Read.ByteOffset;
    StartingVbo = StartingByte.QuadPart;

    ByteCount = capPARAMS->Parameters.Read.Length;

    DbgDoit(CheckForLoudOperations(RxContext););

    IF_DEBUG{
        if (FlagOn(LowIoContext->Flags,LOWIO_CONTEXT_FLAG_LOUDOPS)){
            DbgPrint("LoudRead %lx/%lx on %lx vdl/size/alloc %lx/%lx/%lx\n",
                StartingByte.LowPart,ByteCount,capFcb,
                capFcb->Header.ValidDataLength.LowPart,
                capFcb->Header.FileSize.LowPart,
                capFcb->Header.AllocationSize.LowPart);
        }
    }

    //Statistics............
    if (!FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP) &&
        (capFcb->CachedNetRootType == NET_ROOT_DISK)) {

        InterlockedIncrement(&RxDeviceObject->ReadOperations);

        if (StartingVbo != capFobx->Specific.DiskFile.PredictedReadOffset) {
            InterlockedIncrement(&RxDeviceObject->RandomReadOperations);
        }

        capFobx->Specific.DiskFile.PredictedReadOffset = StartingVbo + ByteCount;

        if (PagingIo) {
            ExInterlockedAddLargeStatistic(&RxDeviceObject->PagingReadBytesRequested,ByteCount);
        } else if (NonCachedIo) {
            ExInterlockedAddLargeStatistic(&RxDeviceObject->NonPagingReadBytesRequested,ByteCount);
        } else {
            ExInterlockedAddLargeStatistic(&RxDeviceObject->CacheReadBytesRequested,ByteCount);
        }
    }

    //
    //  Check for a null, invalid  request, and return immediately
    //

    if (ThisIsAPipeRead && PagingIo) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (ByteCount == 0) {
        return STATUS_SUCCESS;
    }

    //
    //  Get rid of invalid read requests right now.

    if ((TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE) &&
        (TypeOfOpen != RDBSS_NTC_VOLUME_FCB)) {

        RxDbgTrace( 0, Dbg, ("Invalid file object for read, type=%08lx\n", TypeOfOpen ));
        RxDbgTrace( -1, Dbg, ("RxCommonRead:  Exit -> %08lx\n", STATUS_INVALID_DEVICE_REQUEST ));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  Initialize LowIO_CONTEXT block in the RxContext

    RxInitializeLowIoContext(LowIoContext,LOWIO_OP_READ);

    //
    //  Use a try-finally to release Fcb and free buffers on the way out.

    try {

        //
        // This case corresponds to a normal user read file.
        //

        LONGLONG FileSize;
        LONGLONG ValidDataLength;

        RxDbgTrace(0, Dbg, ("Type of read is user file open, fcbstate is %08lx\n", capFcb->FcbState));

        //
        //for stackoverflowreads, we will already have the pagingio resource shared as it's
        // paging io. this doesn't cause a problem here....the resource is just acquired twice.

        if (NonCachedIo &&
            !PagingIo   &&
            (capFileObject->SectionObjectPointer->DataSectionObject != NULL)) {

            //  We hold the main resource exclusive here because the flush
            //  may generate a recursive write in this thread

            Status = RxAcquireExclusiveFcb(RxContext, capFcb);

            if (Status == STATUS_LOCK_NOT_GRANTED) {
                RxDbgTrace( 0,Dbg,("Cannot acquire Fcb for flush = %08lx excl without waiting - lock not granted\n",capFcb ));
                try_return( PostIrp = TRUE );
            } else if (Status != STATUS_SUCCESS) {
                RxDbgTrace( 0,Dbg,("Cannot acquire Fcb = %08lx shared without waiting - other\n",capFcb ));
                try_return(PostIrp = FALSE);
            }

            ExAcquireResourceSharedLite(
                capFcb->Header.PagingIoResource,
                TRUE );

            CcFlushCache(
                capFileObject->SectionObjectPointer,
                &StartingByte,
                ByteCount,
                &capReqPacket->IoStatus );

            RxReleasePagingIoResource(capFcb,RxContext);

            RxReleaseFcb( RxContext, capFcb );

            if (!NT_SUCCESS( capReqPacket->IoStatus.Status)) {
                Status = capReqPacket->IoStatus.Status;
                try_return( capReqPacket->IoStatus.Status );
            }

            RxAcquirePagingIoResource(capFcb,RxContext);
            RxReleasePagingIoResource(capFcb,RxContext);
        }

        // We need shared access to the Fcb before proceeding.

        if ( PagingIo ) {

            ASSERT( !ThisIsAPipeRead );

            if (!ExAcquireResourceSharedLite(
                    capFcb->Header.PagingIoResource,
                    Wait )) {

                RxDbgTrace( 0, Dbg, ("Cannot acquire Fcb = %08lx shared without waiting\n", capFcb ));

                try_return( PostIrp = TRUE );
            }

            if (!Wait) {
                LowIoContext->Resource = capFcb->Header.PagingIoResource;
            }

        } else if (!ThisIsABlockingResume) {

            //
            //  If this is async I/O directly to the disk we need to check that
            //  we don't exhaust the number of times a single thread can
            //  acquire the resource.  Also, we will wait if there is an
            //  exclusive waiter.

            if (!Wait && NonCachedIo) {

                Status = RxAcquireSharedFcbWaitForEx( RxContext, capFcb );

                if (Status == STATUS_LOCK_NOT_GRANTED) {
                    RxDbgTrace( 0,Dbg,("Cannot acquire Fcb = %08lx shared without waiting - lock not granted\n",capFcb ));
                    RxLog(("RdAsyLNG %x\n",RxContext));
                    RxWmiLog(LOG,
                             RxCommonRead_3,
                             LOGPTR(RxContext));
                    try_return( PostIrp = TRUE );
                } else if (Status != STATUS_SUCCESS) {
                    RxDbgTrace( 0,Dbg,("Cannot acquire Fcb = %08lx shared without waiting - other\n",capFcb ));
                    RxLog(("RdAsyOthr %x\n",RxContext));
                    RxWmiLog(LOG,
                             RxCommonRead_4,
                             LOGPTR(RxContext));
                    try_return( PostIrp = FALSE );
                }

                if (ExIsResourceAcquiredSharedLite( capFcb->Header.Resource )
                    > MAX_FCB_ASYNC_ACQUIRE) {

                    FcbAcquired = TRUE;
                    try_return( PostIrp = TRUE );
                }

                LowIoContext->Resource = capFcb->Header.Resource;

            } else {

                Status = RxAcquireSharedFcb(RxContext, capFcb);

                if (Status == STATUS_LOCK_NOT_GRANTED) {
                    RxDbgTrace( 0,Dbg,("Cannot acquire Fcb = %08lx shared without waiting - lock not granted\n",capFcb ));
                    try_return( PostIrp = TRUE );
                } else if (Status != STATUS_SUCCESS) {
                    RxDbgTrace( 0,Dbg,("Cannot acquire Fcb = %08lx shared without waiting - other\n",capFcb ));
                    try_return(PostIrp = FALSE);
                }
            }
        }

        RxItsTheSameContext();

        FcbAcquired = !ThisIsABlockingResume;

        //  for pipe reads, bail out now. we avoid a goto by duplicating the calldown
        if (ThisIsAPipeRead) {
            //
            //  In order to prevent corruption on multi-threaded multi-block
            //  message mode pipe reads, we do this little dance with the fcb resource
            //

            if (!ThisIsABlockingResume) {

                if ((capFobx->Specific.NamedPipe.TypeOfPipe == FILE_PIPE_MESSAGE_TYPE) ||
                    ((capFobx->Specific.NamedPipe.TypeOfPipe == FILE_PIPE_BYTE_STREAM_TYPE) &&
                     !(capFobx->Specific.NamedPipe.CompletionMode & FILE_PIPE_COMPLETE_OPERATION))  ) {

                    //
                    //  Synchronization is effected here that will prevent other
                    //  threads from coming in and reading from this file while the
                    //  message pipe read is continuing.
                    //
                    //  This is necessary because we will release the FCB lock while
                    //  actually performing the I/O to allow open (and other) requests
                    //  to continue on this file while the I/O is in progress.
                    //

                    RxDbgTrace( 0,Dbg,("Message pipe read: Fobx: %lx, Fcb: %lx, Enqueuing...\n", capFobx, capFcb ));

                    Status = RxSynchronizeBlockingOperationsAndDropFcbLock(
                                RxContext,
                                &capFobx->Specific.NamedPipe.ReadSerializationQueue);

                    RxItsTheSameContext();

                    FcbAcquired = FALSE;

                    if (!NT_SUCCESS(Status) ||
                        (Status == STATUS_PENDING)) {
                        try_return(Status);
                    }

                    RxDbgTrace( 0,Dbg,("Succeeded: Fobx: %lx\n", capFobx ));
                }
            }

            LowIoContext->ParamsFor.ReadWrite.ByteCount = ByteCount;
            LowIoContext->ParamsFor.ReadWrite.ByteOffset = StartingVbo;
            SetFlag(RxContext->FlagsForLowIo,RXCONTEXT_FLAG4LOWIO_PIPE_OPERATION);

            Status = RxLowIoReadShell(RxContext);

            try_return( Status );
        }

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        Status = FsRtlCheckOplock(
                     &capFcb->Specific.Fcb.Oplock,
                     capReqPacket,
                     RxContext,
                     RxOplockComplete,
                     RxPrePostIrp );

        if (Status != STATUS_SUCCESS) {

            OplockPostIrp = TRUE;
            PostIrp = TRUE;

            try_return( NOTHING );
        }

        RxGetFileSizeWithLock(capFcb,&FileSize);
        ValidDataLength = capFcb->Header.ValidDataLength.QuadPart;


        //  Set the flag indicating if Fast I/O is possible
        //we no longer do this here....rather we set the state to questionable
        //at initialization time and answer the question in realtime
        //this should be a policy so that local minis can do it this way

        //capFcb->Header.IsFastIoPossible = RxIsFastIoPossible( capFcb );

        //
        // We have to check for read access according to the current
        // state of the file locks, and set FileSize from the Fcb.

        if (!PagingIo &&
            !FsRtlCheckLockForReadAccess(
                &capFcb->Specific.Fcb.FileLock,
                capReqPacket )) {

            try_return( Status = STATUS_FILE_LOCK_CONFLICT );
        }


        //  adjust the length if we know the eof...also, don't issue reads past the EOF
        //  if we know the eof

        if (FlagOn(capFcb->FcbState,FCB_STATE_READCACHEING_ENABLED)) {

            //
            // If the read starts beyond End of File, return EOF.
            //

            if (StartingVbo >= FileSize) {
                RxDbgTrace( 0, Dbg, ("End of File\n", 0 ));

                try_return ( Status = STATUS_END_OF_FILE );
            }

            //
            //  If the read extends beyond EOF, truncate the read
            //

            if (ByteCount > FileSize - StartingVbo) {
                ByteCount = (ULONG)(FileSize - StartingVbo);
            }
        }

        if (!PagingIo &&
            !NonCachedIo &&               //this part is not discretionary
            FlagOn(capFcb->FcbState,FCB_STATE_READCACHEING_ENABLED) &&
            !FlagOn(capFobx->SrvOpen->Flags,SRVOPEN_FLAG_DONTUSE_READ_CACHEING)  ) {

            //
            // HANDLE CACHED CASE
            //
            // We delay setting up the file cache until now, in case the
            // caller never does any I/O to the file, and thus
            // FileObject->PrivateCacheMap == NULL.
            //

            if (capFileObject->PrivateCacheMap == NULL) {

                RxDbgTrace(0, Dbg, ("Initialize cache mapping.\n", 0));

                RxAdjustAllocationSizeforCC(capFcb);

                //
                //  Now initialize the cache map.
                try {
                    Status = STATUS_SUCCESS;

                    CcInitializeCacheMap(
                        capFileObject,
                        (PCC_FILE_SIZES)&capFcb->Header.AllocationSize,
                        FALSE,
                        &RxData.CacheManagerCallbacks,
                        capFcb );

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = GetExceptionCode();
                }

                if (Status != STATUS_SUCCESS) {
                    try_return(Status);
                }

                if (!FlagOn(capFcb->MRxDispatch->MRxFlags,
                            RDBSS_NO_DEFERRED_CACHE_READAHEAD)) {

                    // Start out with read ahead disabled
                    //

                    CcSetAdditionalCacheAttributes( capFileObject, TRUE, FALSE );

                    SetFlag(capFcb->FcbState,FCB_STATE_READAHEAD_DEFERRED);

                } else {

                    //this mini doesn't want deferred readahead

                    CcSetAdditionalCacheAttributes( capFileObject, FALSE, FALSE );
                    //DbgPrint("Nodeferred readahead\n");

                }

                CcSetReadAheadGranularity(
                    capFileObject,
                    NetRoot->DiskParameters.ReadAheadGranularity );

            } else {

                // if we have wandered off the first page and haven't started reading ahead
                // then start now

                if (FlagOn(capFcb->FcbState,FCB_STATE_READAHEAD_DEFERRED) &&
                    (StartingVbo >= PAGE_SIZE) ) {

                    CcSetAdditionalCacheAttributes( capFileObject, FALSE, FALSE );

                    ClearFlag(capFcb->FcbState,FCB_STATE_READAHEAD_DEFERRED);
                }
            }

            //
            // DO A NORMAL CACHED READ, if the MDL bit is not set,
            //

            RxDbgTrace(0, Dbg, ("Cached read.\n", 0));

            if (!FlagOn(RxContext->MinorFunction, IRP_MN_MDL)) {

                PVOID SystemBuffer;
                DEBUG_ONLY_DECL(ULONG SaveExceptionFlag;)

                //
                //  Get hold of the user's buffer.

                SystemBuffer = RxNewMapUserBuffer( RxContext );
                if (SystemBuffer == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    try_return(Status);
                }

                //
                //  Make sure that a returned exception clears the breakpoint in the filter

                RxSaveAndSetExceptionNoBreakpointFlag(RxContext,SaveExceptionFlag);
                RxItsTheSameContext();

                //
                // Now try to do the copy.

                if (!CcCopyRead(
                        capFileObject,
                        &StartingByte,
                        ByteCount,
                        Wait,
                        SystemBuffer,
                        &capReqPacket->IoStatus )) {

                    RxDbgTrace( 0, Dbg, ("Cached Read could not wait\n", 0 ));
                    RxRestoreExceptionNoBreakpointFlag(RxContext,SaveExceptionFlag);

                    RxItsTheSameContext();

                    try_return( PostIrp = TRUE );
                }

                Status = capReqPacket->IoStatus.Status;

                RxRestoreExceptionNoBreakpointFlag(RxContext,SaveExceptionFlag);
                RxItsTheSameContext();

                ASSERT( NT_SUCCESS( Status ));

                try_return( Status );
            } else {
                //
                //  HANDLE A MDL READ
                //

                RxDbgTrace(0, Dbg, ("MDL read.\n", 0));

                ASSERT(FALSE); //not yet ready for MDL reads
                ASSERT( Wait );

                CcMdlRead(
                    capFileObject,
                    &StartingByte,
                    ByteCount,
                    &capReqPacket->MdlAddress,
                    &capReqPacket->IoStatus );

                Status = capReqPacket->IoStatus.Status;

                ASSERT( NT_SUCCESS( Status ));

                try_return( Status );
            }
        }

        //
        // HANDLE THE NON-CACHED CASE
        //
        //  Bt first, a ValidDataLength check.
        //
        //  If the file in question is a disk file, and it is currently cached,
        //  and the read offset is greater than valid data length, then
        //  return 0s to the application.
        //

        if ((capFcb->CachedNetRootType == NET_ROOT_DISK) &&
            FlagOn(capFcb->FcbState,FCB_STATE_READCACHEING_ENABLED) &&
            (StartingVbo >= ValidDataLength)) {

            // check if zeroing is really needed.
            if (StartingVbo >= FileSize) {
                ByteCount = 0;
            } else {

                PBYTE SystemBuffer;

                //
                // There is at least one byte available.  Truncate
                // the transfer length if it goes beyond EOF.

                if (StartingVbo + ByteCount > FileSize) {
                    ByteCount = (ULONG)(FileSize - StartingVbo);
                }

                SystemBuffer = RxNewMapUserBuffer( RxContext );
                SafeZeroMemory(SystemBuffer, ByteCount);   //this could raise!!
            }

            capReqPacket->IoStatus.Information = ByteCount;

            try_return(Status = STATUS_SUCCESS);
        }


        LowIoContext->ParamsFor.ReadWrite.ByteCount = ByteCount;
        LowIoContext->ParamsFor.ReadWrite.ByteOffset = StartingVbo;

        RxItsTheSameContext();

        Status = RxLowIoReadShell(RxContext);

        RxItsTheSameContext();
        try_return( Status );

  try_exit: NOTHING;

        //
        //  If the request was not posted, deal with it.
        //

        RxItsTheSameContext();

        if ( !PostIrp ) {
            if (!ThisIsAPipeRead) {

                RxDbgTrace( 0, Dbg, ("CommonRead InnerFinally-> %08lx %08lx\n",
                                Status, capReqPacket->IoStatus.Information));

                //
                //  If the file was opened for Synchronous IO, update the current
                //  file position. this works becuase info==0 for errors
                //

                if (!PagingIo &&
                    BooleanFlagOn(capFileObject->Flags, FO_SYNCHRONOUS_IO)) {
                    capFileObject->CurrentByteOffset.QuadPart =
                                StartingVbo + capReqPacket->IoStatus.Information;
                }
            }
        } else {

            RxDbgTrace( 0, Dbg, ("Passing request to Fsp\n", 0 ));

            if (!OplockPostIrp) {
                InterlockedIncrement(&RxContext->ReferenceCount);
                RefdContextForTracker = TRUE;

                Status = RxFsdPostRequest( RxContext );
            }
        }
    } finally {

        DebugUnwind( RxCommonRead );

        //
        //  If this was not PagingIo, mark that the last access
        //  time on the dirent needs to be updated on close.
        //

        if (NT_SUCCESS(Status)&& (Status!=STATUS_PENDING) && !PagingIo && !ThisIsAPipeRead) {
            SetFlag( capFileObject->Flags, FO_FILE_FAST_IO_READ );
        }

        //  If resources have been acquired, release them under the right conditions.
        //  the right conditions are these:
        //     1) if we have abnormal termination. here we obviously release the since no one else will.
        //     2) if the underlying call did not succeed: Status==Pending.
        //     3) if we posted the request
        //
        // Completion for this case is not handled in the common dispatch routine

        if (AbnormalTermination() || (Status!=STATUS_PENDING) || PostIrp) {
            if (FcbAcquired) {

                if ( PagingIo ) {

                    RxReleasePagingIoResource(capFcb,RxContext);

                } else {

                    RxReleaseFcb( RxContext, capFcb );
                }
            }

            if (RefdContextForTracker) {
                RxDereferenceAndDeleteRxContext(RxContext);
            }

            if (!PostIrp) {
               if (FlagOn(RxContext->FlagsForLowIo,RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION)) {

                   RxResumeBlockedOperations_Serially(
                       RxContext,
                       &capFobx->Specific.NamedPipe.ReadSerializationQueue);
               }
            }

            if (Status == STATUS_SUCCESS) {
                ASSERT ( capReqPacket->IoStatus.Information
                         <=  capPARAMS->Parameters.Read.Length );
            }

        } else {
            //here the guy below is going to handle the completion....but, we don't know the finish
            //order....in all likelihood the deletecontext call below just reduces the refcount
            // but the guy may already have finished in which case this will really delete the context.
            ASSERT(!SynchronousIo);

            RxDereferenceAndDeleteRxContext(RxContext);
        }

        RxDbgTrace(-1, Dbg, ("CommonRead -> %08lx\n", Status ));
    } //finally

    IF_DEBUG {
        if ((Status==STATUS_END_OF_FILE)
              && FlagOn(LowIoContext->Flags,LOWIO_CONTEXT_FLAG_LOUDOPS)){
            DbgPrint("Returning end of file on %wZ\n",&(capFcb->PrivateAlreadyPrefixedName));
        }
    }

    return Status;
}

NTSTATUS
RxLowIoReadShellCompletion (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    This routine postprocesses a read request after it comes back from the
    minirdr.  It does callouts to handle compression, buffering and
    shadowing.  It is the opposite number of LowIoReadShell.

    This will be called from LowIo; for async, originally in the
    completion routine.  If RxStatus(MORE_PROCESSING_REQUIRED) is returned,
    LowIo will call again in a thread.  If this was syncIo, you'll be back
    in the user's thread; if async, lowIo will requeue to a thread.
    Currrently, we always get to a thread before anything; this is a bit slower
    than completing at DPC time,
    but it's aheckuva lot safer and we may often have stuff to do
    (like decompressing, shadowing, etc) that we don't want to do at DPC
    time.

Arguments:

    RxContext - the usual

Return Value:

    whatever value supplied by the caller or RxStatus(MORE_PROCESSING_REQUIRED).

--*/

{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureFcb; RxCaptureParamBlock; RxCaptureFileObject;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    BOOLEAN  SynchronousIo = !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);

    BOOLEAN  PagingIo      = BooleanFlagOn(capReqPacket->Flags, IRP_PAGING_IO);

    BOOLEAN  ThisIsAPipeOperation =
            BooleanFlagOn(RxContext->FlagsForLowIo,RXCONTEXT_FLAG4LOWIO_PIPE_OPERATION);

    BOOLEAN  ThisIsASynchronizedPipeOperation =
            BooleanFlagOn(RxContext->FlagsForLowIo,RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION);

    PAGED_CODE();  //we will want to revisit this....not taking this at dpc time would cause
                   //two extra context swaps IF MINIRDRS MADE THE CALL FROM THE INDICATION
                   //CRRRENTLY, THEY DO NOT.

    Status = RxContext->StoredStatus;
    capReqPacket->IoStatus.Information = RxContext->InformationToReturn;

    RxDbgTrace(+1, Dbg, ("RxLowIoReadShellCompletion  entry  Status = %08lx\n", Status));
    RxLog(("RdShlComp %lx %lx %lx\n",RxContext,Status,capReqPacket->IoStatus.Information));
    RxWmiLog(LOG,
             RxLowIoReadShellCompletion_1,
             LOGPTR(RxContext)
             LOGULONG(Status)
             LOGPTR(capReqPacket->IoStatus.Information));

    if ( PagingIo ) {
        //for paging io, it's nonsense to have 0bytes and success...map it!
        if (NT_SUCCESS(Status) &&
            (capReqPacket->IoStatus.Information == 0 )) {
            Status = STATUS_END_OF_FILE;
        }
    }


    ASSERT (RxLowIoIsBufferLocked(LowIoContext));
    switch (Status) {
    case STATUS_SUCCESS:
        if(FlagOn(RxContext->Flags, RXCONTEXT_FLAG4LOWIO_THIS_IO_BUFFERED)){
            if (FlagOn(capFcb->FcbState, FCB_STATE_FILE_IS_DISK_COMPRESSED)){
               ASSERT(FALSE); // NOT YET IMPLEMENTED should decompress and put away
            } else if  (FlagOn(capFcb->FcbState, FCB_STATE_FILE_IS_BUF_COMPRESSED)){
               ASSERT(FALSE); // NOT YET IMPLEMENTED should decompress and put away
            }
        }
        if (FlagOn(capFcb->FcbState, FCB_STATE_FILE_IS_SHADOWED)) {
           ASSERT(FALSE); //RxSdwAddData(RxContext);
        }
        break;

    case STATUS_FILE_LOCK_CONFLICT:
        if(FlagOn(RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_THIS_READ_ENLARGED)){
            ASSERT(FALSE); //disenlarge the read
            return(STATUS_RETRY);
        }
        break;

    case STATUS_CONNECTION_INVALID:
        //NOT YET IMPLEMENTED here is where the failover will happen
        //first we give the local guy current minirdr another chance...then we go
        //to fullscale retry
        //return(RxStatus(DISCONNECTED));   //special....let LowIo get us back
        break;
    }

    if (FlagOn(RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_READAHEAD)) {
       ASSERT(FALSE); //RxUnwaitReadAheadWaiters(RxContext);
    }

    if (FlagOn(LowIoContext->Flags,LOWIO_CONTEXT_FLAG_SYNCCALL)){
        //if we're being called from lowioubmit then just get out
        RxDbgTrace(-1, Dbg, ("RxLowIoReadShellCompletion  syncexit  Status = %08lx\n", Status));
        return(Status);
    }

    //
    //otherwise we have to do the end of the read from here

    //
    //mark that the file has been read accessed

    if (NT_SUCCESS(Status) && !PagingIo && !ThisIsAPipeOperation) {
        SetFlag( capFileObject->Flags, FO_FILE_FAST_IO_READ );
    }

    if ( PagingIo ) {

        RxReleasePagingIoResourceForThread(capFcb,LowIoContext->ResourceThreadId,RxContext);

    } else if (!ThisIsASynchronizedPipeOperation) {

        RxReleaseFcbForThread( RxContext, capFcb, LowIoContext->ResourceThreadId );

    } else {
        RxCaptureFobx;

        RxResumeBlockedOperations_Serially(
            RxContext,
            &capFobx->Specific.NamedPipe.ReadSerializationQueue);
    }

    if (ThisIsAPipeOperation) {
        RxCaptureFobx;

        if (capReqPacket->IoStatus.Information == 0) {

            //if this is a nowait pipe, initiate throttling to keep from flooding the net

            if (capFobx->Specific.NamedPipe.CompletionMode == FILE_PIPE_COMPLETE_OPERATION) {

                RxInitiateOrContinueThrottling(
                    &capFobx->Specific.NamedPipe.ThrottlingState);

                RxLog(("RThrottlYes %lx %lx %lx %ld\n",
                       RxContext,capFobx,&capFobx->Specific.NamedPipe.ThrottlingState,
                       capFobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries));
                RxWmiLog(LOG,
                         RxLowIoReadShellCompletion_2,
                         LOGPTR(RxContext)
                         LOGPTR(capFobx)
                         LOGULONG(capFobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries));
            }

            //translate the status if this is a msgmode pipe

            if ((capFobx->Specific.NamedPipe.TypeOfPipe == FILE_PIPE_MESSAGE_TYPE) &&
                (Status == STATUS_SUCCESS)) {
                Status = STATUS_PIPE_EMPTY;
            }

        } else {

            //
            // if we have been throttling on this pipe, stop because we got some data.....

            RxTerminateThrottling(&capFobx->Specific.NamedPipe.ThrottlingState);

            RxLog(("RThrottlNo %lx %lx %lx %ld\n",
                   RxContext,capFobx,&capFobx->Specific.NamedPipe.ThrottlingState,
                   capFobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries));
            RxWmiLog(LOG,
                     RxLowIoReadShellCompletion_3,
                     LOGPTR(RxContext)
                     LOGPTR(capFobx)
                     LOGULONG(capFobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries));
        }
    }

    ASSERT(Status != STATUS_RETRY);

    if ( Status != STATUS_RETRY){
        ASSERT ( capReqPacket->IoStatus.Information
                      <=  capPARAMS->Parameters.Read.Length );
        ASSERT (RxContext->MajorFunction == IRP_MJ_READ);
    }

    RxDbgTrace(-1, Dbg, ("RxLowIoReadShellCompletion  asyncexit  Status = %08lx\n", Status));
    return(Status);
}

#define RxSdwRead(RXCONTEXT)  STATUS_MORE_PROCESSING_REQUIRED

NTSTATUS
RxLowIoReadShell (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine preprocesses a read request before it goes down to the minirdr. It does callouts
    to handle compression, buffering and shadowing. It is the opposite number of LowIoReadShellCompletion.
    By the time we get here, either the shadowing system will handle the read OR we are going to the wire.
    Read buffering was already tried in the UncachedRead strategy

Arguments:

    RxContext - the usual

Return Value:

    whatever value is returned by a callout....or by LowIo.

--*/

{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureParamBlock;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxLowIoReadShell  entry             %08lx\n"));
    RxLog(("RdShl in %lx\n",RxContext));
    RxWmiLog(LOG,
             RxLowIoReadShell_1,
             LOGPTR(RxContext));

    if (FlagOn(capFcb->FcbState, FCB_STATE_FILE_IS_SHADOWED)) {
        Status = RxSdwRead(RxContext);

        if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
            return(Status);
        }
    }

    if (capFcb->CachedNetRootType == NET_ROOT_DISK) {
        ExInterlockedAddLargeStatistic(
            &RxContext->RxDeviceObject->NetworkReadBytesRequested,
            LowIoContext->ParamsFor.ReadWrite.ByteCount);
    }

    Status = RxLowIoSubmit(RxContext,RxLowIoReadShellCompletion);

    RxDbgTrace(-1, Dbg, ("RxLowIoReadShell  exit  Status = %08lx\n", Status));
    RxLog(("RdShl out %x %x\n",RxContext,Status));
    RxWmiLog(LOG,
             RxLowIoReadShell_2,
             LOGPTR(RxContext)
             LOGULONG(Status));

    return(Status);
}

#if DBG
ULONG RxLoudLowIoOpsEnabled = 0;
VOID CheckForLoudOperations(
    PRX_CONTEXT RxContext
    )
{
    PAGED_CODE();

    if (RxLoudLowIoOpsEnabled) {
        RxCaptureFcb;
        PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
        PCHAR Buffer;
        PWCHAR FileOfConcern = L"all.scr";
        ULONG Length = 7*sizeof(WCHAR); //7 is the length of all.scr;

        Buffer = (PCHAR)(capFcb->PrivateAlreadyPrefixedName.Buffer)
                           + capFcb->PrivateAlreadyPrefixedName.Length - Length;

        if (RtlCompareMemory(Buffer,FileOfConcern,Length)==Length) {
            SetFlag(LowIoContext->Flags,LOWIO_CONTEXT_FLAG_LOUDOPS);
        }
    }
    return;
}
#endif //if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\strtstop.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    strtstop.c

Abstract:

    This module implements the Start and Stop routines for the wrapper.

Author:

    Balan Sethu Raman     [SethuR]    27-Jan-1996

Revision History:

Notes:


--*/

#include "precomp.h"
#pragma hdrstop
#include <ntddnfs2.h>
#include <ntddmup.h>
#include "fsctlbuf.h"
#include "prefix.h"
#include "rxce.h"

//
//  The local trace mask for this part of the module
//

#define Dbg (DEBUG_TRACE_DEVFCB)

//
// Forward declarations
//


VOID
RxDeregisterUNCProvider(
   PRDBSS_DEVICE_OBJECT RxDeviceObject
   );

VOID
RxUnstart(
    PRX_CONTEXT         RxContext,
    PRDBSS_DEVICE_OBJECT RxDeviceObject
   );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxDeregisterUNCProvider)
#pragma alloc_text(PAGE, RxUnstart)
#pragma alloc_text(PAGE, RxSetDomainForMailslotBroadcast)
#endif

//
// There are three states associated with each minirdr w.r.t the Start/Stop sequence.
// These are
//    RDBSS_STARTABLE
//       - This is the initial state and also the one intowhich a minirdr transitions
//           after a successful stop.
//
//    RDBSS_STARTED
//       - A transition to this state occurs after the startup sequence has been
//         successfully completed. This is the state in which the minirdr is active.
//
//    RDBSS_STOP_IN_PROGRESS
//       - A transition to this state occurs when a shutdown sequence has been initiated.
//
//
// A minirdr can be started and stopped independent of the system by invoking
// the appropriate command through the workstation service. The
// Start/Stop functionality is different from the Load/UnLoad functionality, i.e., it
// is possible to stop a mini redirectors without unloading it.
//
// The data structures associated with the RDBSS can be classified into two categories
// 1) those maintained by the RDBSS and visible to all the mini redirectors or private
// and 2) those that are mainitained by the RDBSS and visible to the I/O subsystem.
// The NET_ROOT,VNET_ROOT, SRV_CALL etc. are examples of the first category while
// FCB's,FOBX's(File Object extensions ) are examples of the second category.
// None of these data structures can be unilaterally destroyed by the RDBSS -- those
// in category 1 must be destroyed in coordination with the mini redirectors while
// those in category 2 must be done in coordination with the I/O subsystem.
//
// The destruction of the data structures can be initiated by the RDBSS while those
// in the  second category cannot be initiated by the RDBSS. Hence the shutdown
// sequence has to make provisions for handling them differently.
//
// A shutdown sequence can be successfully completed ( so that the driver can be
// unloaded ) if there are no residual instances in category 2, i.e., there are no
// open file handles or references to file objects from the other system components.
//
// If there are any residual references, the corresponding instances are marked as
// having been orphaned. The only permissible operations on orphaned instances are
// close and cleanup. The mini redirector close/cleanup operations must make special
// provisions for dealing with orphaned instances. All other operations are short
// circuited with an error status by the wrapper.
//

VOID
RxUnstart(
    PRX_CONTEXT RxContext,
    PRDBSS_DEVICE_OBJECT RxDeviceObject
   )
{
    PAGED_CODE();

    ASSERT(BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP));

    if (RxDeviceObject->MupHandle != (HANDLE)0) {
        RxDbgTrace(0, Dbg, ("RxDeregisterUNCProvider derigistering from MUP %wZ\n", &RxDeviceObject->DeviceName));
        FsRtlDeregisterUncProvider(RxDeviceObject->MupHandle);
        RxDeviceObject->MupHandle = (HANDLE)0;
    }

    if (RxDeviceObject->RegisteredAsFileSystem) {
        IoUnregisterFileSystem((PDEVICE_OBJECT)RxDeviceObject);
    }

    if (RxData.NumberOfMinirdrsStarted==1) {

        RxForceNetTableFinalization(RxDeviceObject);
        RxData.NumberOfMinirdrsStarted = 0;

        // Get rid of buffers that have been allocated.
        if (s_PrimaryDomainName.Buffer != NULL) {
            RxFreePool(s_PrimaryDomainName.Buffer);
            s_PrimaryDomainName.Length = 0;
            s_PrimaryDomainName.Buffer = NULL;
        }

    } else {
       InterlockedDecrement(&RxData.NumberOfMinirdrsStarted);
    }
}

NTSTATUS
RxSetDomainForMailslotBroadcast (
    IN PUNICODE_STRING DomainName
    )
{
    PAGED_CODE();

    if (s_PrimaryDomainName.Buffer!=NULL) {
        RxFreePool(s_PrimaryDomainName.Buffer);
    }

    RxLog(("DomainName=%wZ",DomainName));
    RxWmiLog(LOG,
             RxSetDomainForMailslotBroadcast_1,
             LOGUSTR(*DomainName));
    s_PrimaryDomainName.Length = (USHORT)DomainName->Length;
    s_PrimaryDomainName.MaximumLength = s_PrimaryDomainName.Length;

    if (s_PrimaryDomainName.Length > 0) {
        s_PrimaryDomainName.Buffer = RxAllocatePoolWithTag(
                                           PagedPool | POOL_COLD_ALLOCATION,
                                           s_PrimaryDomainName.Length,
                                           RX_MISC_POOLTAG);

        if (s_PrimaryDomainName.Buffer == NULL) {
           return(STATUS_INSUFFICIENT_RESOURCES);
        } else {
            RtlCopyMemory(
                  s_PrimaryDomainName.Buffer,
                  DomainName->Buffer,
                  s_PrimaryDomainName.Length);

            RxLog(("CapturedDomainName=%wZ",&s_PrimaryDomainName));
            RxWmiLog(LOG,
                     RxSetDomainForMailslotBroadcast_2,
                     LOGUSTR(s_PrimaryDomainName));
        }
    } else {
        s_PrimaryDomainName.Buffer = NULL;
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
RxStartMinirdr (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:

    This routine starts up the calling minirdr by registering as an UNC
    provider with the MUP.

Arguments:

    RxContext - Describes the Context. the context is used to get the device object and to tell if we're in the fsp.

    PostToFsp - set to TRUE if the request has to be posted

Return Value:

    RxStatus(SUCCESS) -- the Startup sequence was successfully completed.

    any other value indicates the appropriate error in the startup sequence.

--*/
{
    NTSTATUS Status;

    PRDBSS_DEVICE_OBJECT RxDeviceObject = RxContext->RxDeviceObject;

    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    BOOLEAN SuppressUnstart = FALSE;

    RxDbgTrace(0, Dbg, ("RxStartMinirdr [Start] -> %08lx\n", 0));

    // The startup sequence cannot be completed because there are certain aspects of
    // security and transport initialization that require handles. Since handles are
    // tied to a process the RDBSS needs to present an anchoring point to all the mini
    // redirectors. So the initialization will be completed in the context of the
    // FSP ( system process since RDBSS does not have its own FSP)

    if (InFSD) {
        SECURITY_SUBJECT_CONTEXT SubjectContext;

        SeCaptureSubjectContext(&SubjectContext);
        RxContext->FsdUid = RxGetUid( &SubjectContext );
        SeReleaseSubjectContext(&SubjectContext);

        *PostToFsp = TRUE;
        return STATUS_PENDING;
    }

    if (!ExAcquireResourceExclusiveLite(&RxData.Resource, Wait)) {
        *PostToFsp = TRUE;
        return STATUS_PENDING;
    }

    if (!RxAcquirePrefixTableLockExclusive( RxContext->RxDeviceObject->pRxNetNameTable, Wait)) {
        ASSERT(!"How can the wait fail?????");
        ExReleaseResourceLite(&RxData.Resource);
        *PostToFsp = TRUE;
        return STATUS_PENDING;
    }

    try {

        if (RxDeviceObject->MupHandle != NULL) {
           RxDbgTrace(0, Dbg, ("RxStartMinirdr [Already] -> %08lx\n", 0));
           SuppressUnstart = TRUE;
           try_return(Status = STATUS_REDIRECTOR_STARTED);
        }

        if (RxDeviceObject->RegisterUncProvider) {
            Status = FsRtlRegisterUncProvider(
                         &RxDeviceObject->MupHandle,
                         &RxDeviceObject->DeviceName,
                         RxDeviceObject->RegisterMailSlotProvider
                     );

            if (Status!=STATUS_SUCCESS) {
                RxDeviceObject->MupHandle = (HANDLE)0;
                try_return(Status);
            }
        } else {
            Status = STATUS_SUCCESS;
        }

        IoRegisterFileSystem((PDEVICE_OBJECT)RxDeviceObject);

        RxDeviceObject->RegisteredAsFileSystem = TRUE;

        MINIRDR_CALL(Status,
                     RxContext,
                     RxDeviceObject->Dispatch,
                     MRxStart,
                     (RxContext,RxDeviceObject));

        if (Status == STATUS_SUCCESS) {
            RxDeviceObject->StartStopContext.Version++;
            RxSetRdbssState(RxDeviceObject,RDBSS_STARTED);
            InterlockedIncrement(&RxData.NumberOfMinirdrsStarted);
            Status = RxInitializeMRxDispatcher(RxDeviceObject);
        }

        try_return(Status);
try_exit:NOTHING;
    } finally {

        if (AbnormalTermination() || !NT_SUCCESS(Status)){
            if (!SuppressUnstart) {
                RxUnstart(RxContext,RxDeviceObject);
            }
        }

        RxReleasePrefixTableLock( RxContext->RxDeviceObject->pRxNetNameTable );
        ExReleaseResourceLite(&RxData.Resource);
    }

    return Status;
}

NTSTATUS
RxStopMinirdr (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:

    This routine stops a minirdr....a stopped minirdr will no longer accept new commands.

Arguments:

    RxContext - the context

    PostToFsp - the flag when set delays processing to the FSP.

Return Value:

    the Status of the STOP operaion ...

      STATUS_PENDING -- processing delayed to FSP

      STATUS_REDIRECTOR_HAS_OPEN_HANDLES -- cannot be stopped at this time

Notes:

    When a STOP request is issued to RDBSS there are ongoing requests in the
    RDBSS. Some of the requests can be cancelled while the remaining requests
    need to be processed to completion.

    There are a number of strategies that can be employed to close down the
    RDBSS. Currently, the most conservative approach is employed. The
    cancellation of those operations that can be cancelled and the STOP
    operation is held back till the remaining requests run through to completion.

    Subsequently, this will be revised so that the response times to STOP requests
    are smaller.

--*/
{
    NTSTATUS Status;
    BOOLEAN  Wait  = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN  InFSD = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PRDBSS_DEVICE_OBJECT RxDeviceObject = RxContext->RxDeviceObject;

    RxDbgTrace(0, Dbg, ("RxStopMinirdr [Stop] -> %08lx\n", 0));

    if (InFSD) {
        *PostToFsp = TRUE;
        return STATUS_PENDING;
    }

    if (!ExAcquireResourceExclusiveLite(&RxData.Resource, Wait)) {
        *PostToFsp = TRUE;
        return STATUS_PENDING;
    }

    try {

        KIRQL   SavedIrql;
        BOOLEAN fWait;

        ASSERT(BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP));


        if (RxDeviceObject->StartStopContext.State!=RDBSS_STARTED){
            RxDbgTrace(0, Dbg, ("RxStopMinirdr [Notstarted] -> %08lx\n", 0));
            try_return ( Status = STATUS_REDIRECTOR_NOT_STARTED );
        }
        // Wait for all the ongoing requests to be completed. When the RDBSS is
        // transitioned to the STOPPED state the last context to be completed
        // will complete the wait.

        // Terminate all the scavenging operations.
        RxTerminateScavenging(RxContext);

        RxDbgPrint(("Waiting for all contexts to be flushed\n"));
        KeAcquireSpinLock( &RxStrucSupSpinLock, &SavedIrql );
        RemoveEntryList(&RxContext->ContextListEntry);
        RxDeviceObject->StartStopContext.State = RDBSS_STOP_IN_PROGRESS;
        RxDeviceObject->StartStopContext.pStopContext = RxContext;
        KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );

        fWait = (InterlockedDecrement(&RxDeviceObject->NumberOfActiveContexts) != 0);

        if (fWait) {
           RxWaitSync(RxContext);
        }

        ASSERT(RxDeviceObject->NumberOfActiveContexts == 0);

        RxUnstart(RxContext,RxDeviceObject);

        RxSpinDownMRxDispatcher(RxDeviceObject);

        MINIRDR_CALL(
                  Status,
                  RxContext,
                  RxDeviceObject->Dispatch,
                  MRxStop,
                  (RxContext,RxDeviceObject),
                  );


        // If there are no residual FCB's the driver can be unloaded. If not the
        // driver must remain loaded so that close/cleanup operations on ORPHANED
        // FCB's can be completed.
        if (RxDeviceObject->NumberOfActiveFcbs == 0) {
            Status = STATUS_SUCCESS;
        } else {
            //ASSERT(!"OPENHANDLES!");
            Status = STATUS_REDIRECTOR_HAS_OPEN_HANDLES;
        }

        RxSpinDownMRxDispatcher(RxDeviceObject);

        // All set to startup again.
        RxSetRdbssState(RxDeviceObject,RDBSS_STARTABLE);

try_exit: NOTHING;
    } finally {

        ExReleaseResourceLite( &RxData.Resource );
    }

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\copysup.nt\fastio2.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    FastIo2.c

Abstract:

    This module REimplements the fsrtl copy read/write routines.

Author:

    Joe Linn     [JoeLinn]    9-Nov-1994

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#ifndef FlagOn
//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))
#endif

BOOLEAN
FsRtlCopyRead2 (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG_PTR TopLevelIrpValue
    );
BOOLEAN
FsRtlCopyWrite2 (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG_PTR TopLevelIrpValue
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FsRtlCopyRead2)
#pragma alloc_text(PAGE, FsRtlCopyWrite2)
#endif

BOOLEAN
FsRtlCopyRead2 (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG_PTR TopLevelIrpValue
    )

/*++

Routine Description:

    This routine does a fast cached read bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy read
    of a cached file object.  For a complete description of the arguments
    see CcCopyRead.

Arguments:

    FileObject - Pointer to the file object being read.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not delivered, or
        if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    PFSRTL_COMMON_FCB_HEADER Header;
    BOOLEAN Status = TRUE;
    ULONG PageCount = ADDRESS_AND_SIZE_TO_SPAN_PAGES((ULongToPtr(FileOffset->LowPart)), Length);
    LARGE_INTEGER BeyondLastByte;
    PDEVICE_OBJECT targetVdo;

    PAGED_CODE();

    //
    //  Special case a read of zero length
    //

    if (Length != 0) {

        //
        //  Get a real pointer to the common fcb header
        //

        BeyondLastByte.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;
        Header = (PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext;

        //
        //  Enter the file system
        //

        FsRtlEnterFileSystem();

        //
        //  Increment performance counters and get the resource
        //

        if (Wait) {


            //
            //  Acquired shared on the common fcb header
            //

            (VOID)ExAcquireResourceSharedLite( Header->Resource, TRUE );

        } else {


            //
            //  Acquired shared on the common fcb header, and return if we
            //  don't get it
            //

            if (!ExAcquireResourceSharedLite( Header->Resource, FALSE )) {

                FsRtlExitFileSystem();

                //the ntfs guys dont do this AND it causes a compile error for me so
                //comment it out
                //CcFastReadResourceMiss += 1;

                return FALSE;
            }
        }

        //
        //  Now that the File is acquired shared, we can safely test if it
        //  is really cached and if we can do fast i/o and if not, then
        //  release the fcb and return.
        //

        if ((FileObject->PrivateCacheMap == NULL) ||
            (Header->IsFastIoPossible == FastIoIsNotPossible)) {

            ExReleaseResourceLite( Header->Resource );
            FsRtlExitFileSystem();


            return FALSE;
        }

        //
        //  Check if fast I/O is questionable and if so then go ask the
        //  file system the answer
        //

        if (Header->IsFastIoPossible == FastIoIsQuestionable) {

            PFAST_IO_DISPATCH FastIoDispatch;

            ASSERT(!KeIsExecutingDpc());

            targetVdo = IoGetRelatedDeviceObject( FileObject );
            FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;


            //
            //  All file systems that set "Is Questionable" had better support
            // fast I/O
            //

            ASSERT(FastIoDispatch != NULL);
            ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

            //
            //  Call the file system to check for fast I/O.  If the answer is
            //  anything other than GoForIt then we cannot take the fast I/O
            //  path.
            //

            if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        Wait,
                                                        LockKey,
                                                        TRUE, // read operation
                                                        IoStatus,
                                                        targetVdo )) {

                //
                //  Fast I/O is not possible so release the Fcb and return.
                //

                ExReleaseResourceLite( Header->Resource );
                FsRtlExitFileSystem();


                return FALSE;
            }
        }

        //
        //  Check for read past file size.
        //

        if ( BeyondLastByte.QuadPart > Header->FileSize.QuadPart ) {

            if ( FileOffset->QuadPart >= Header->FileSize.QuadPart ) {
                IoStatus->Status = STATUS_END_OF_FILE;
                IoStatus->Information = 0;

                ExReleaseResourceLite( Header->Resource );
                FsRtlExitFileSystem();

                return TRUE;
            }

            Length = (ULONG)( Header->FileSize.QuadPart - FileOffset->QuadPart );
        }

        //
        //  We can do fast i/o so call the cc routine to do the work and then
        //  release the fcb when we've done.  If for whatever reason the
        //  copy read fails, then return FALSE to our caller.
        //
        //  Also mark this as the top level "Irp" so that lower file system
        //  levels will not attempt a pop-up
        //

        //PsGetCurrentThread()->TopLevelIrp = FSRTL_FAST_IO_TOP_LEVEL_IRP;
        PsGetCurrentThread()->TopLevelIrp = TopLevelIrpValue;

        try {

            if (Wait && ((BeyondLastByte.HighPart | Header->FileSize.HighPart) == 0)) {

                CcFastCopyRead( FileObject,
                                FileOffset->LowPart,
                                Length,
                                PageCount,
                                Buffer,
                                IoStatus );

                FileObject->Flags |= FO_FILE_FAST_IO_READ;

                ASSERT( (IoStatus->Status == STATUS_END_OF_FILE) ||
                        ((FileOffset->LowPart + IoStatus->Information) <= Header->FileSize.LowPart));

            } else {

                Status = CcCopyRead( FileObject,
                                     FileOffset,
                                     Length,
                                     Wait,
                                     Buffer,
                                     IoStatus );

                FileObject->Flags |= FO_FILE_FAST_IO_READ;

                ASSERT( !Status || (IoStatus->Status == STATUS_END_OF_FILE) ||
                        (((ULONGLONG)FileOffset->QuadPart + IoStatus->Information) <= (ULONGLONG)Header->FileSize.QuadPart));
            }

            if (Status) {

                FileObject->CurrentByteOffset.QuadPart = FileOffset->QuadPart + IoStatus->Information;
            }

        } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                        ? EXCEPTION_EXECUTE_HANDLER
                                        : EXCEPTION_CONTINUE_SEARCH ) {

            Status = FALSE;
        }

        PsGetCurrentThread()->TopLevelIrp = 0;

        ExReleaseResourceLite( Header->Resource );
        FsRtlExitFileSystem();
        return Status;

    } else {

        //
        //  A zero length transfer was requested.
        //

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = 0;

        return TRUE;
    }
}

BOOLEAN
FsRtlCopyWrite2 (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG_PTR TopLevelIrpValue
    )

/*++

Routine Description:

    This routine does a fast cached write bypassing the usual file system
    entry routine (i.e., without the Irp).  It is used to do a copy write
    of a cached file object.  For a complete description of the arguments
    see CcCopyWrite.

Arguments:

    FileObject - Pointer to the file object being write.

    FileOffset - Byte offset in file for desired data.

    Length - Length of desired data in bytes.

    Wait - FALSE if caller may not block, TRUE otherwise

    Buffer - Pointer to output buffer to which data should be copied.

    IoStatus - Pointer to standard I/O status block to receive the status
               for the transfer.

Return Value:

    FALSE - if Wait was supplied as FALSE and the data was not delivered, or
        if there is an I/O error.

    TRUE - if the data is being delivered

--*/

{
    PFSRTL_COMMON_FCB_HEADER Header;
    BOOLEAN AcquiredShared = FALSE;
    BOOLEAN Status = TRUE;
    BOOLEAN FileSizeChanged = FALSE;
    BOOLEAN WriteToEndOfFile = (BOOLEAN)((FileOffset->LowPart == FILE_WRITE_TO_END_OF_FILE) &&
                                         (FileOffset->HighPart == -1));

    PAGED_CODE();

    //
    //  Get a real pointer to the common fcb header
    //

    Header = (PFSRTL_COMMON_FCB_HEADER)FileObject->FsContext;

    //
    //  Do we need to verify the volume?  If so, we must go to the file
    //  system.  Also return FALSE if FileObject is write through, the
    //  File System must do that.
    //

    if (CcCanIWrite( FileObject, Length, Wait, FALSE ) &&
        !FlagOn(FileObject->Flags, FO_WRITE_THROUGH) &&
        CcCopyWriteWontFlush(FileObject, FileOffset, Length)) {

        //
        //  Assume our transfer will work
        //

        IoStatus->Status = STATUS_SUCCESS;
        IoStatus->Information = Length;

        //
        //  Special case the zero byte length
        //

        if (Length != 0) {

            //
            //  Enter the file system
            //

            FsRtlEnterFileSystem();

            //
            //  Split into separate paths for increased performance.  First
            //  we have the faster path which only supports Wait == TRUE and
            //  32 bits.  We will make an unsafe test on whether the fast path
            //  is ok, then just return FALSE later if we were wrong.  This
            //  should virtually never happen.
            //
            //  IMPORTANT NOTE: It is very important that any changes mad to
            //                  this path also be applied to the 64-bit path
            //                  which is the else of this test!
            //

            if (Wait && (Header->AllocationSize.HighPart == 0)) {

                ULONG Offset, NewFileSize;
                ULONG OldFileSize;
                ULONG OldValidDataLength;
                BOOLEAN Wrapped;

                //
                //  Make our best guess on whether we need the file exclusive
                //  or shared.  Note that we do not check FileOffset->HighPart
                //  until below.
                //

                NewFileSize = FileOffset->LowPart + Length;

                if (WriteToEndOfFile || (NewFileSize > Header->ValidDataLength.LowPart)) {

                    //
                    //  Acquired shared on the common fcb header
                    //

                    ExAcquireResourceExclusiveLite( Header->Resource, TRUE );

                } else {

                    //
                    //  Acquired shared on the common fcb header
                    //

                    ExAcquireResourceSharedLite( Header->Resource, TRUE );

                    AcquiredShared = TRUE;
                }

                //
                //  We have the fcb shared now check if we can do fast i/o
                //  and if the file space is allocated, and if not then
                //  release the fcb and return.
                //

                if (WriteToEndOfFile) {

                    Offset = Header->FileSize.LowPart;
                    NewFileSize = Header->FileSize.LowPart + Length;
                    Wrapped = NewFileSize < Header->FileSize.LowPart;

                } else {

                    Offset = FileOffset->LowPart;
                    NewFileSize = FileOffset->LowPart + Length;
                    Wrapped = (NewFileSize < FileOffset->LowPart) || (FileOffset->HighPart != 0);
                }

                //
                //  Now that the File is acquired shared, we can safely test
                //  if it is really cached and if we can do fast i/o and we
                //  do not have to extend. If not then release the fcb and
                //  return.
                //
                //  Get out if we have too much to zero.  This case is not important
                //  for performance, and a file system supporting sparseness may have
                //  a way to do this more efficiently.
                //

                if ((FileObject->PrivateCacheMap == NULL) ||
                    (Header->IsFastIoPossible == FastIoIsNotPossible) ||
                    (NewFileSize > Header->AllocationSize.LowPart) ||
                    (Offset >= (Header->ValidDataLength.LowPart + 0x2000)) ||
                    (Header->AllocationSize.HighPart != 0) || Wrapped) {

                    ExReleaseResourceLite( Header->Resource );
                    FsRtlExitFileSystem();

                    return FALSE;
                }

                //
                //  If we will be extending ValidDataLength, we will have to
                //  get the Fcb exclusive, and make sure that FastIo is still
                //  possible.  We should only execute this block of code very
                //  rarely, when the unsafe test for ValidDataLength failed
                //  above.
                //

                if (AcquiredShared && (NewFileSize > Header->ValidDataLength.LowPart)) {

                    ExReleaseResourceLite( Header->Resource );

                    ExAcquireResourceExclusiveLite( Header->Resource, TRUE );

                    //
                    // If writing to end of file, we must recalculate new size.
                    //

                    if (WriteToEndOfFile) {

                        Offset = Header->FileSize.LowPart;
                        NewFileSize = Header->FileSize.LowPart + Length;
                        Wrapped = NewFileSize < Header->FileSize.LowPart;
                    }

                    if ((FileObject->PrivateCacheMap == NULL) ||
                        (Header->IsFastIoPossible == FastIoIsNotPossible) ||
                        (NewFileSize > Header->AllocationSize.LowPart) ||
                        (Header->AllocationSize.HighPart != 0) || Wrapped) {

                        ExReleaseResourceLite( Header->Resource );
                        FsRtlExitFileSystem();

                        return FALSE;
                    }
                }

                //
                //  Check if fast I/O is questionable and if so then go ask
                //  the file system the answer
                //

                if (Header->IsFastIoPossible == FastIoIsQuestionable) {

                    PDEVICE_OBJECT targetVdo = IoGetRelatedDeviceObject( FileObject );
                    PFAST_IO_DISPATCH FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;
                    IO_STATUS_BLOCK IoStatus;

                    //
                    //  All file system then set "Is Questionable" had better
                    //  support fast I/O
                    //

                    ASSERT(FastIoDispatch != NULL);
                    ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

                    //
                    //  Call the file system to check for fast I/O.  If the
                    //  answer is anything other than GoForIt then we cannot
                    //  take the fast I/O path.
                    //

                    ASSERT(FILE_WRITE_TO_END_OF_FILE == 0xffffffff);

                    if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                                FileOffset->QuadPart != (LONGLONG)-1 ?
                                                                  FileOffset : &Header->FileSize,
                                                                Length,
                                                                TRUE,
                                                                LockKey,
                                                                FALSE, // write operation
                                                                &IoStatus,
                                                                targetVdo )) {

                        //
                        //  Fast I/O is not possible so release the Fcb and
                        //  return.
                        //

                        ExReleaseResourceLite( Header->Resource );
                        FsRtlExitFileSystem();

                        return FALSE;
                    }
                }

                //
                //  Now see if we will change FileSize.  We have to do it now
                //  so that our reads are not nooped.
                //

                if (NewFileSize > Header->FileSize.LowPart) {

                    FileSizeChanged = TRUE;
                    OldFileSize = Header->FileSize.LowPart;
                    OldValidDataLength = Header->ValidDataLength.LowPart;
                    Header->FileSize.LowPart = NewFileSize;
                }

                //
                //  We can do fast i/o so call the cc routine to do the work
                //  and then release the fcb when we've done.  If for whatever
                //  reason the copy write fails, then return FALSE to our
                //  caller.
                //
                //  Also mark this as the top level "Irp" so that lower file
                //  system levels will not attempt a pop-up
                //

                PsGetCurrentThread()->TopLevelIrp = TopLevelIrpValue;

                try {

                    //
                    //  See if we have to do some zeroing
                    //

                    if (Offset > Header->ValidDataLength.LowPart) {

                        LARGE_INTEGER ZeroEnd;

                        ZeroEnd.LowPart = Offset;
                        ZeroEnd.HighPart = 0;

                        CcZeroData( FileObject,
                                    &Header->ValidDataLength,
                                    &ZeroEnd,
                                    TRUE );
                    }

                    CcFastCopyWrite( FileObject,
                                     Offset,
                                     Length,
                                     Buffer );

                } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                                ? EXCEPTION_EXECUTE_HANDLER
                                                : EXCEPTION_CONTINUE_SEARCH ) {

                    Status = FALSE;
                }

                PsGetCurrentThread()->TopLevelIrp = 0;

                //
                //  If we succeeded, see if we have to update FileSize or
                //  ValidDataLength.
                //

                if (Status) {

                    //
                    //  In the case of ValidDataLength, we really have to
                    //  check again since we did not do this when we acquired
                    //  the resource exclusive.
                    //

                    if (NewFileSize > Header->ValidDataLength.LowPart) {

                        Header->ValidDataLength.LowPart = NewFileSize;
                    }

                    //
                    //  Set this handle as having modified the file
                    //

                    FileObject->Flags |= FO_FILE_MODIFIED;

                    if (FileSizeChanged) {

                        CcGetFileSizePointer(FileObject)->LowPart = NewFileSize;

                        FileObject->Flags |= FO_FILE_SIZE_CHANGED;
                    }

                    //
                    //  Also update the file position pointer
                    //

                    FileObject->CurrentByteOffset.LowPart = Offset + Length;
                    FileObject->CurrentByteOffset.HighPart = 0;

                //
                //  If we did not succeed, then we must restore the original
                //  FileSize while holding the PagingIoResource exclusive if
                //  it exists.
                //

                } else if (FileSizeChanged) {

                    if ( Header->PagingIoResource != NULL ) {

                        (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                        Header->FileSize.LowPart = OldFileSize;
                        Header->ValidDataLength.LowPart = OldValidDataLength;
                        ExReleaseResourceLite( Header->PagingIoResource );

                    } else {

                        Header->FileSize.LowPart = OldFileSize;
                        Header->ValidDataLength.LowPart = OldValidDataLength;
                    }
                }

            //
            //  Here is the 64-bit or no-wait path.
            //

            } else {

                LARGE_INTEGER Offset, NewFileSize;
                LARGE_INTEGER OldFileSize;
                LARGE_INTEGER OldValidDataLength;

                ASSERT(!KeIsExecutingDpc());

                //
                //  Make our best guess on whether we need the file exclusive
                //  or shared.
                //

                NewFileSize.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;

                if (WriteToEndOfFile || (NewFileSize.QuadPart > Header->ValidDataLength.QuadPart)) {

                    //
                    //  Acquired shared on the common fcb header, and return
                    //  if we don't get it.
                    //

                    if (!ExAcquireResourceExclusiveLite( Header->Resource, Wait )) {

                        FsRtlExitFileSystem();

                        return FALSE;
                    }

                } else {

                    //
                    //  Acquired shared on the common fcb header, and return
                    //  if we don't get it.
                    //

                    if (!ExAcquireResourceSharedLite( Header->Resource, Wait )) {

                        FsRtlExitFileSystem();

                        return FALSE;
                    }

                    AcquiredShared = TRUE;
                }


                //
                //  We have the fcb shared now check if we can do fast i/o
                //  and if the file space is allocated, and if not then
                //  release the fcb and return.
                //

                if (WriteToEndOfFile) {

                    Offset = Header->FileSize;
                    NewFileSize.QuadPart = Header->FileSize.QuadPart + (LONGLONG)Length;

                } else {

                    Offset = *FileOffset;
                    NewFileSize.QuadPart = FileOffset->QuadPart + (LONGLONG)Length;
                }

                //
                //  Now that the File is acquired shared, we can safely test
                //  if it is really cached and if we can do fast i/o and we
                //  do not have to extend. If not then release the fcb and
                //  return.
                //
                //  Get out if we are about to zero too much as well, as commented above.
                //

                if ((FileObject->PrivateCacheMap == NULL) ||
                    (Header->IsFastIoPossible == FastIoIsNotPossible) ||
                      (Offset.QuadPart >= (Header->ValidDataLength.QuadPart + 0x2000)) ||
                      ( NewFileSize.QuadPart > Header->AllocationSize.QuadPart ) ) {

                    ExReleaseResourceLite( Header->Resource );
                    FsRtlExitFileSystem();

                    return FALSE;
                }

                //
                //  If we will be extending ValidDataLength, we will have to
                //  get the Fcb exclusive, and make sure that FastIo is still
                //  possible.  We should only execute this block of code very
                //  rarely, when the unsafe test for ValidDataLength failed
                //  above.
                //

                if (AcquiredShared && ( NewFileSize.QuadPart > Header->ValidDataLength.QuadPart )) {

                    ExReleaseResourceLite( Header->Resource );

                    if (!ExAcquireResourceExclusiveLite( Header->Resource, Wait )) {

                        FsRtlExitFileSystem();

                        return FALSE;
                    }

                    //
                    // If writing to end of file, we must recalculate new size.
                    //

                    if (WriteToEndOfFile) {

                        Offset = Header->FileSize;
                        NewFileSize.QuadPart = Header->FileSize.QuadPart + (LONGLONG)Length;
                    }

                    if ((FileObject->PrivateCacheMap == NULL) ||
                        (Header->IsFastIoPossible == FastIoIsNotPossible) ||
                        ( NewFileSize.QuadPart > Header->AllocationSize.QuadPart ) ) {

                        ExReleaseResourceLite( Header->Resource );
                        FsRtlExitFileSystem();

                        return FALSE;
                    }
                }

                //
                //  Check if fast I/O is questionable and if so then go ask
                //  the file system the answer
                //

                if (Header->IsFastIoPossible == FastIoIsQuestionable) {

                    PDEVICE_OBJECT targetVdo = IoGetRelatedDeviceObject( FileObject );
                    PFAST_IO_DISPATCH FastIoDispatch = targetVdo->DriverObject->FastIoDispatch;
                    IO_STATUS_BLOCK IoStatus;

                    //
                    //  All file system then set "Is Questionable" had better
                    //  support fast I/O
                    //

                    ASSERT(FastIoDispatch != NULL);
                    ASSERT(FastIoDispatch->FastIoCheckIfPossible != NULL);

                    //
                    //  Call the file system to check for fast I/O.  If the
                    //  answer is anything other than GoForIt then we cannot
                    //  take the fast I/O path.
                    //

                    ASSERT(FILE_WRITE_TO_END_OF_FILE == 0xffffffff);

                    if (!FastIoDispatch->FastIoCheckIfPossible( FileObject,
                                                                FileOffset->QuadPart != (LONGLONG)-1 ?
                                                                  FileOffset : &Header->FileSize,
                                                                Length,
                                                                Wait,
                                                                LockKey,
                                                                FALSE, // write operation
                                                                &IoStatus,
                                                                targetVdo )) {

                        //
                        //  Fast I/O is not possible so release the Fcb and
                        //  return.
                        //

                        ExReleaseResourceLite( Header->Resource );
                        FsRtlExitFileSystem();

                        return FALSE;
                    }
                }

                //
                //  Now see if we will change FileSize.  We have to do it now
                //  so that our reads are not nooped.
                //

                if ( NewFileSize.QuadPart > Header->FileSize.QuadPart ) {

                    FileSizeChanged = TRUE;
                    OldFileSize = Header->FileSize;
                    OldValidDataLength = Header->ValidDataLength;

                    //
                    //  Deal with an extremely rare pathalogical case here the
                    //  file size wraps.
                    //

                    if ( (Header->FileSize.HighPart != NewFileSize.HighPart) &&
                         (Header->PagingIoResource != NULL) ) {

                        (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                        Header->FileSize = NewFileSize;
                        ExReleaseResourceLite( Header->PagingIoResource );

                    } else {

                        Header->FileSize = NewFileSize;
                    }
                }

                //
                //  We can do fast i/o so call the cc routine to do the work
                //  and then release the fcb when we've done.  If for whatever
                //  reason the copy write fails, then return FALSE to our
                //  caller.
                //
                //  Also mark this as the top level "Irp" so that lower file
                //  system levels will not attempt a pop-up
                //

                PsGetCurrentThread()->TopLevelIrp = TopLevelIrpValue;

                try {

                    //
                    //  See if we have to do some zeroing
                    //

                    if ( Offset.QuadPart > Header->ValidDataLength.QuadPart ) {

                        Status = CcZeroData( FileObject,
                                             &Header->ValidDataLength,
                                             &Offset,
                                             Wait );
                    }

                    if (Status) {

                        Status = CcCopyWrite( FileObject,
                                              &Offset,
                                              Length,
                                              Wait,
                                              Buffer );
                    }

                } except( FsRtlIsNtstatusExpected(GetExceptionCode())
                                                ? EXCEPTION_EXECUTE_HANDLER
                                                : EXCEPTION_CONTINUE_SEARCH ) {

                    Status = FALSE;
                }

                PsGetCurrentThread()->TopLevelIrp = 0;

                //
                //  If we succeeded, see if we have to update FileSize or
                //  ValidDataLength.
                //

                if (Status) {

                    //
                    //  In the case of ValidDataLength, we really have to
                    //  check again since we did not do this when we acquired
                    //  the resource exclusive.
                    //

                    if ( NewFileSize.QuadPart > Header->ValidDataLength.QuadPart ) {

                        //
                        //  Deal with an extremely rare pathalogical case here
                        //  the ValidDataLength wraps.
                        //

                        if ( (Header->ValidDataLength.HighPart != NewFileSize.HighPart) &&
                             (Header->PagingIoResource != NULL) ) {

                            (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                            Header->ValidDataLength = NewFileSize;
                            ExReleaseResourceLite( Header->PagingIoResource );

                        } else {

                            Header->ValidDataLength = NewFileSize;
                        }
                    }

                    //
                    //  Set this handle as having modified the file
                    //

                    FileObject->Flags |= FO_FILE_MODIFIED;

                    if (FileSizeChanged) {

                        *CcGetFileSizePointer(FileObject) = NewFileSize;

                        FileObject->Flags |= FO_FILE_SIZE_CHANGED;
                    }

                    //
                    //  Also update the current file position pointer
                    //

                    FileObject->CurrentByteOffset.QuadPart = Offset.QuadPart + Length;

                //
                // If we did not succeed, then we must restore the original
                // FileSize while holding the PagingIoResource exclusive if
                // it exists.
                //

                } else if (FileSizeChanged) {

                    if ( Header->PagingIoResource != NULL ) {

                        (VOID)ExAcquireResourceExclusiveLite( Header->PagingIoResource, TRUE );
                        Header->FileSize = OldFileSize;
                        Header->ValidDataLength = OldValidDataLength;
                        ExReleaseResourceLite( Header->PagingIoResource );

                    } else {

                        Header->FileSize = OldFileSize;
                        Header->ValidDataLength = OldValidDataLength;
                    }
                }

            }

            ExReleaseResourceLite( Header->Resource );
            FsRtlExitFileSystem();

            return Status;

        } else {

            //
            //  A zero length transfer was requested.
            //

            return TRUE;
        }

    } else {

        //
        // The volume must be verified or the file is write through.
        //

        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\copysup.nt\precomp.h ===
//precomp include file for copysup.nt directory

#include <ntos.h>
#include <string.h>
//#include <zwapi.h>
#include <FsRtl.h>
#include <ntrtl.h>


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\copysup.nt\daytona\makefile.inc ===
copyforifskit:
# This is bogus.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\volinfo.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    VolInfo.c

Abstract:

    This module implements the volume information routines for Rx called by
    the dispatch driver.

Author:

    Joe Linn     [JoeLinn]    5-oct-94

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_VOLINFO)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonQueryVolumeInformation)
#pragma alloc_text(PAGE, RxCommonSetVolumeInformation)
#endif

NTSTATUS
RxCommonQueryVolumeInformation ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This is the common routine for querying volume information called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    RxCaptureRequestPacket;

    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;

    ULONG                OriginalLength = capPARAMS->Parameters.QueryVolume.Length;
    FS_INFORMATION_CLASS FsInformationClass = capPARAMS->Parameters.QueryVolume.FsInformationClass;
    PVOID                OriginalBuffer = capReqPacket->AssociatedIrp.SystemBuffer;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonQueryVolumeInformation...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, capFobx, capFcb));
    RxDbgTrace( 0, Dbg, ("->Length             = %08lx\n", OriginalLength));
    RxDbgTrace( 0, Dbg, ("->FsInformationClass = %08lx\n", FsInformationClass));
    RxDbgTrace( 0, Dbg, ("->Buffer             = %08lx\n", OriginalBuffer));

    RxLog(("QueryVolInfo %lx %lx %lx\n",RxContext,capFcb,capFobx));
    RxWmiLog(LOG,
             RxCommonQueryVolumeInformation_1,
             LOGPTR(RxContext)
             LOGPTR(capFcb)
             LOGPTR(capFobx));
    RxLog(("  alsoqvi %lx %lx %lx\n",
                 OriginalLength,FsInformationClass,OriginalBuffer));
    RxWmiLog(LOG,
             RxCommonQueryVolumeInformation_2,
             LOGULONG(OriginalLength)
             LOGULONG(FsInformationClass)
             LOGPTR(OriginalBuffer));

    try {
        RxContext->Info.FsInformationClass = FsInformationClass;
        RxContext->Info.Buffer = OriginalBuffer;
        RxContext->Info.LengthRemaining = OriginalLength;

        MINIRDR_CALL(
            Status,
            RxContext,
            capFcb->MRxDispatch,
            MRxQueryVolumeInfo,
            (RxContext));

        if (RxContext->PostRequest) {
            try_return(Status = RxFsdPostRequest(RxContext));
        }

        capReqPacket->IoStatus.Information = OriginalLength - RxContext->Info.LengthRemaining;

    try_exit:
        NOTHING;

    } finally {
        DebugUnwind( RxCommonQueryVolumeInformation );
    }

    RxDbgTrace(-1, Dbg, ("RxCommonQueryVolumeInformation -> %08lx,%08lx\n", Status, capReqPacket->IoStatus.Information));

    return Status;
}


NTSTATUS
RxCommonSetVolumeInformation ( RXCOMMON_SIGNATURE )
/*++

Routine Description:

    This is the common routine for setting Volume Information called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    RxCaptureRequestPacket;

    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;

    TYPE_OF_OPEN TypeOfOpen = NodeType(capFcb);

    ULONG Length;

    FS_INFORMATION_CLASS FsInformationClass;
    PVOID Buffer;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxCommonSetVolumeInformation...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, capFobx, capFcb));

    Length             = capPARAMS->Parameters.SetVolume.Length;
    FsInformationClass = capPARAMS->Parameters.SetVolume.FsInformationClass;
    Buffer             = capReqPacket->AssociatedIrp.SystemBuffer;

    RxDbgTrace( 0, Dbg, ("->Length             = %08lx\n", Length));
    RxDbgTrace( 0, Dbg, ("->FsInformationClass = %08lx\n", FsInformationClass));
    RxDbgTrace( 0, Dbg, ("->Buffer             = %08lx\n", Buffer));

    RxLog(("SetVolInfo %lx %lx %lx\n",RxContext,capFcb,capFobx));
    RxWmiLog(LOG,
             RxCommonSetVolumeInformation_1,
             LOGPTR(RxContext)
             LOGPTR(capFcb)
             LOGPTR(capFobx));
    RxLog(("  alsosvi %lx %lx %lx\n",
           Length,FsInformationClass,Buffer));
    RxWmiLog(LOG,
             RxCommonSetVolumeInformation_2,
             LOGULONG(Length)
             LOGULONG(FsInformationClass)
             LOGPTR(Buffer));

    try {

        //
        //  Based on the information class we'll do different actions.  Each
        //  of the procedures that we're calling performs the action if
        //  possible and returns true if it successful and false if it couldn't
        //  wait for any I/O to complete.
        //
        RxContext->Info.FsInformationClass = FsInformationClass;
        RxContext->Info.Buffer = Buffer;
        RxContext->Info.LengthRemaining = Length;

        MINIRDR_CALL(
            Status,
            RxContext,
            capFcb->MRxDispatch,
            MRxSetVolumeInfo,
            (RxContext));

    } finally {

        DebugUnwind( RxCommonSetVolumeInformation );

        RxDbgTrace(-1, Dbg, ("RxCommonSetVolumeInformation -> %08lx\n", Status));
    }

    return Status;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\write.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Write.c

Abstract:

    This module implements the File Write routine for Write called by the
    dispatch driver.

Author:

    Joe Linn      [JoeLinn]      2-Nov-94

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

BOOLEAN RxNoAsync = FALSE;

NTSTATUS
RxLowIoWriteShell (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxLowIoWriteShellCompletion (
    IN PRX_CONTEXT RxContext
    );

//defined in read.c
VOID CheckForLoudOperations(
    PRX_CONTEXT RxContext
    );

VOID
__RxWriteReleaseResources(
    PRX_CONTEXT RxContext
    RX_FCBTRACKER_PARAMS
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, RxCommonWrite)
#pragma alloc_text(PAGE, __RxWriteReleaseResources)
#pragma alloc_text(PAGE, RxLowIoWriteShellCompletion)
#pragma alloc_text(PAGE, RxLowIoWriteShell)
#endif

#if DBG
#define DECLARE_POSTIRP() PCHAR PostIrp = NULL
#define SET_POSTIRP(__XXX__) (PostIrp = (__XXX__))
#define RESET_POSTIRP() (PostIrp = NULL)
#else
#define DECLARE_POSTIRP() BOOLEAN PostIrp = FALSE
#define SET_POSTIRP(__XXX__) (PostIrp = TRUE)
#define RESET_POSTIRP() (PostIrp = FALSE)
#endif

#ifdef RDBSS_TRACKER
#define RxWriteReleaseResources(__a__) __RxWriteReleaseResources(__a__,__LINE__,__FILE__,0)
#else
#define RxWriteReleaseResources(__a__) __RxWriteReleaseResources(__a__)
#endif

VOID
__RxWriteReleaseResources(
    PRX_CONTEXT RxContext
    RX_FCBTRACKER_PARAMS
    )
/* this module frees resources and tracks the state */
{
    RxCaptureFcb;

    PAGED_CODE();

    ASSERT((RxContext!=NULL) && (capFcb!=NULL));

    if (RxContext->FcbResourceAcquired) {

        RxDbgTrace( 0, Dbg,("RxCommonWrite     ReleasingFcb\n"));
        __RxReleaseFcb(RxContext, (PMRX_FCB)(capFcb)
#ifdef RDBSS_TRACKER
                      ,LineNumber,FileName,SerialNumber
#endif
                    );
        RxContext->FcbResourceAcquired = FALSE;
    }

    if (RxContext->FcbPagingIoResourceAcquired) {
        RxDbgTrace( 0, Dbg,("RxCommonWrite     ReleasingPaginIo\n"));
        RxReleasePagingIoResource(capFcb,RxContext);
    }
}

NTSTATUS
RxCommonWrite ( RXCOMMON_SIGNATURE )

/*++

Routine Description:

    This is the common write routine for NtWriteFile, called from both
    the Fsd, or from the Fsp if a request could not be completed without
    blocking in the Fsd.  This routine's actions are
    conditionalized by the Wait input parameter, which determines whether
    it is allowed to block or not.  If a blocking condition is encountered
    with Wait == FALSE, however, the request is posted to the Fsp, who
    always calls with WAIT == TRUE.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    RXSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);
    PSRV_OPEN SrvOpen= (capFobx != NULL) ? capFobx->SrvOpen : NULL;
    PRDBSS_DEVICE_OBJECT RxDeviceObject = RxContext->RxDeviceObject;

    LARGE_INTEGER StartingByte;
    RXVBO StartingVbo;
    ULONG ByteCount;
    LONGLONG FileSize;
    LONGLONG ValidDataLength;
    LONGLONG InitialFileSize;
    LONGLONG InitialValidDataLength;

    ULONG CapturedRxContextSerialNumber = RxContext->SerialNumber;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    DECLARE_POSTIRP();

    BOOLEAN OplockPostIrp = FALSE;
    BOOLEAN ExtendingFile = FALSE;
    BOOLEAN SwitchBackToAsync = FALSE;
    BOOLEAN CalledByLazyWriter = FALSE;
    BOOLEAN ExtendingValidData = FALSE;
    BOOLEAN WriteFileSizeToDirent = FALSE;
    BOOLEAN RecursiveWriteThrough = FALSE;
    BOOLEAN UnwindOutstandingAsync = FALSE;

    BOOLEAN RefdContextForTracker = FALSE;

    BOOLEAN SynchronousIo;
    BOOLEAN WriteToEof;
    BOOLEAN PagingIo;
    BOOLEAN NonCachedIo;
    BOOLEAN Wait;

    PNET_ROOT NetRoot = (PNET_ROOT)(capFcb->pNetRoot);
    BOOLEAN ThisIsADiskWrite = (BOOLEAN)((NetRoot->Type == NET_ROOT_DISK)||(NetRoot->Type == NET_ROOT_WILD));
    BOOLEAN ThisIsAPipeWrite = (BOOLEAN)(NetRoot->Type == NET_ROOT_PIPE);
    BOOLEAN ThisIsABlockingResume = BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_BLOCKED_PIPE_RESUME);

    PAGED_CODE();

    //  Get rid of invalid write requests right away.
    if (TypeOfOpen != RDBSS_NTC_STORAGE_TYPE_FILE
        && TypeOfOpen != RDBSS_NTC_VOLUME_FCB
        && TypeOfOpen != RDBSS_NTC_SPOOLFILE
        && TypeOfOpen != RDBSS_NTC_MAILSLOT) {

        RxDbgTrace( 0, Dbg, ("Invalid file object for write\n", 0 ));
        RxDbgTrace( -1, Dbg, ("RxCommonWrite:  Exit -> %08lx\n", STATUS_INVALID_DEVICE_REQUEST ));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

#ifdef RX_WJ_DBG_SUPPORT
    RxdUpdateJournalOnWriteInitiation(
        capFcb,
        capPARAMS->Parameters.Write.ByteOffset,
        capPARAMS->Parameters.Write.Length);
#endif

    // Initialize the appropriate local variables.
    Wait          = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    PagingIo      = BooleanFlagOn(capReqPacket->Flags, IRP_PAGING_IO);
    NonCachedIo   = BooleanFlagOn(capReqPacket->Flags,IRP_NOCACHE);
    SynchronousIo = !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);

    //pick up a write-through specified only for this irp
    if (FlagOn(capPARAMS->Flags,SL_WRITE_THROUGH)) {
        SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_WRITE_THROUGH );
    }

    RxDbgTrace(+1, Dbg, ("RxCommonWrite...IrpC %08lx, Fobx %08lx, Fcb %08lx\n",
                                       RxContext, capFobx, capFcb));
    RxDbgTrace( 0, Dbg, ("  ->ByteCount = %08lx, ByteOffset = %08lx %lx\n",
                         capPARAMS->Parameters.Write.Length,
                         capPARAMS->Parameters.Write.ByteOffset.LowPart,
                         capPARAMS->Parameters.Write.ByteOffset.HighPart));
    RxDbgTrace( 0, Dbg,("  ->%s%s%s%s\n",
                    Wait          ?"Wait ":"",
                    PagingIo      ?"PagingIo ":"",
                    NonCachedIo   ?"NonCachedIo ":"",
                    SynchronousIo ?"SynchronousIo ":""
               ));

    RxLog(("CommonWrite %lx %lx %lx\n", RxContext, capFobx, capFcb));
    RxWmiLog(LOG,
             RxCommonWrite_1,
             LOGPTR(RxContext)
             LOGPTR(capFobx)
             LOGPTR(capFcb));
    RxLog((
        "   write %lx@%lx %lx %s%s%s%s\n",
        capPARAMS->Parameters.Write.Length,
        capPARAMS->Parameters.Write.ByteOffset.LowPart,
        capPARAMS->Parameters.Write.ByteOffset.HighPart,
        Wait?"Wt":"",
        PagingIo?"Pg":"",
        NonCachedIo?"Nc":"",
        SynchronousIo?"Sy":""));
    RxWmiLog(LOG,
             RxCommonWrite_2,
             LOGULONG(capPARAMS->Parameters.Write.Length)
             LOGULONG(capPARAMS->Parameters.Write.ByteOffset.LowPart)
             LOGULONG(capPARAMS->Parameters.Write.ByteOffset.HighPart)
             LOGUCHAR(Wait)
             LOGUCHAR(PagingIo)
             LOGUCHAR(NonCachedIo)
             LOGUCHAR(SynchronousIo));

    RxItsTheSameContext();

    RxContext->FcbResourceAcquired = FALSE;
    RxContext->FcbPagingIoResourceAcquired = FALSE;

    //  Extract starting Vbo and offset.
    StartingByte = capPARAMS->Parameters.Write.ByteOffset;
    StartingVbo  = StartingByte.QuadPart;
    ByteCount    = capPARAMS->Parameters.Write.Length;
    WriteToEof = (StartingVbo < 0);

    DbgDoit(CheckForLoudOperations(RxContext););

    IF_DEBUG{
        if (FlagOn(LowIoContext->Flags,LOWIO_CONTEXT_FLAG_LOUDOPS)){
            DbgPrint("LoudWrite %lx/%lx on %lx vdl/size/alloc %lx/%lx/%lx\n",
                StartingByte.LowPart,ByteCount,capFcb,
                capFcb->Header.ValidDataLength.LowPart,
                capFcb->Header.FileSize.LowPart,
                capFcb->Header.AllocationSize.LowPart);
        }
    }

    //Statistics............
    if (!FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP)
           && capFcb->CachedNetRootType == NET_ROOT_DISK) {
        InterlockedIncrement(&RxDeviceObject->WriteOperations);

        if (StartingVbo != capFobx->Specific.DiskFile.PredictedWriteOffset) {
            InterlockedIncrement(&RxDeviceObject->RandomWriteOperations);
        }

        capFobx->Specific.DiskFile.PredictedWriteOffset = StartingVbo + ByteCount;

        if (PagingIo) {
            ExInterlockedAddLargeStatistic(&RxDeviceObject->PagingWriteBytesRequested,ByteCount);
        } else if (NonCachedIo) {
            ExInterlockedAddLargeStatistic(&RxDeviceObject->NonPagingWriteBytesRequested,ByteCount);
        } else {
            ExInterlockedAddLargeStatistic(&RxDeviceObject->CacheWriteBytesRequested,ByteCount);
        }
    }

    //  If there is nothing to write, return immediately or if the buffers are invalid
    // return the appropriate status

    if (ThisIsADiskWrite && (ByteCount == 0)) {
        return STATUS_SUCCESS;
    } else if ((capReqPacket->UserBuffer == NULL) && (capReqPacket->MdlAddress == NULL)) {
        return STATUS_INVALID_PARAMETER;
    } else if ((MAXLONGLONG - StartingVbo < ByteCount) && (!WriteToEof)) {
        return STATUS_INVALID_PARAMETER;
    }

    //  See if we have to defer the write. note that if writecacheing is disabled then we don't have
    //  to check.

    if (!NonCachedIo &&
        !CcCanIWrite(
            capFileObject,
            ByteCount,
            (BOOLEAN)(Wait && !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP)),
            BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_DEFERRED_WRITE))) {

        BOOLEAN Retrying = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_DEFERRED_WRITE);

        RxPrePostIrp( RxContext, capReqPacket );

        SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_DEFERRED_WRITE );

        CcDeferWrite( capFileObject,
                      (PCC_POST_DEFERRED_WRITE)RxAddToWorkque,
                      RxContext,
                      capReqPacket,
                      ByteCount,
                      Retrying );

        return STATUS_PENDING;
    }

    //  Initialize LowIO_CONTEXT block in the RxContext

    RxInitializeLowIoContext(LowIoContext,LOWIO_OP_WRITE);

    //  Use a try-finally to free Fcb and buffers on the way out.

    try {

        BOOLEAN DoLowIoWrite = TRUE;
        //
        // This case corresponds to a normal user write file.
        //

        ASSERT ((TypeOfOpen == RDBSS_NTC_STORAGE_TYPE_FILE )
                  || (TypeOfOpen == RDBSS_NTC_SPOOLFILE)
                  || (TypeOfOpen == RDBSS_NTC_MAILSLOT));

        RxDbgTrace(0, Dbg, ("Type of write is user file open\n", 0));

        //
        //  If this is a noncached transfer and is not a paging I/O, and
        //  the file has been opened cached, then we will do a flush here
        //  to avoid stale data problems.
        //
        //  The Purge following the flush will guarantee cache coherency.
        //

        if ((NonCachedIo || !RxWriteCacheingAllowed(capFcb,SrvOpen)) &&
            !PagingIo &&
            (capFileObject->SectionObjectPointer->DataSectionObject != NULL)) {

            LARGE_INTEGER FlushBase;

            //
            //  We need the Fcb exclusive to do the CcPurgeCache
            //

            Status = RxAcquireExclusiveFcb( RxContext, capFcb );
            if (Status == STATUS_LOCK_NOT_GRANTED) {
                RxDbgTrace( 0, Dbg, ("Cannot acquire Fcb = %08lx shared without waiting\n", capFcb ));
                try_return( SET_POSTIRP("Couldn't acquireex for flush") );
            } else if (Status != STATUS_SUCCESS) {
                RxDbgTrace( 0, Dbg, ("Cannot acquire Fcb = %08lx shared without waiting\n", capFcb ));
                try_return( PostIrp = FALSE );
           }

            RxContext->FcbResourceAcquired = TRUE;
            //we don't set fcbacquiredexclusive here since we either return or release


            if (WriteToEof) {
                RxGetFileSizeWithLock(capFcb,&FlushBase.QuadPart);
            } else {
                FlushBase = StartingByte;
            }

            RxAcquirePagingIoResource(capFcb,RxContext);

            CcFlushCache(
                capFileObject->SectionObjectPointer, //ok4flush
                &FlushBase,
                ByteCount,
                &capReqPacket->IoStatus );

            RxReleasePagingIoResource(capFcb,RxContext);

            if (!NT_SUCCESS( capReqPacket->IoStatus.Status)) {
                try_return(  Status = capReqPacket->IoStatus.Status );
            }

            RxAcquirePagingIoResource(capFcb,RxContext);
            RxReleasePagingIoResource(capFcb,RxContext);

            CcPurgeCacheSection(
                capFileObject->SectionObjectPointer,
                &FlushBase,
                ByteCount,
                FALSE);
        }

        //  We assert that Paging Io writes will never WriteToEof.

        ASSERT( !(WriteToEof && PagingIo) );

        //
        //  First let's acquire the Fcb shared.  Shared is enough if we
        //  are not writing beyond EOF.
        //

        RxItsTheSameContext();

        if ( PagingIo ) {
            BOOLEAN AcquiredFile;

            ASSERT( !ThisIsAPipeWrite );

            AcquiredFile = RxAcquirePagingIoResourceShared(capFcb,TRUE,RxContext);

            LowIoContext->Resource = capFcb->Header.PagingIoResource;

        } else if (!ThisIsABlockingResume) {
            //
            // If this could be async, noncached IO we need to check that
            // we don't exhaust the number of times a single thread can
            // acquire the resource.
            //
            // The writes which extend the valid data length result in the the
            // capability of collapsing opens being renounced. This is required to
            // ensure that directory control can see the updated state of the file
            // on close. If this is not done the extended file length is not visible
            // on directory control immediately after a close. In such cases the FCB
            // is accquired exclusive, the changes are made to the buffering state
            // and then downgraded to a shared accquisition.

            if (!RxContext->FcbResourceAcquired) {
                if (!ThisIsAPipeWrite) {
                    if (!Wait &&
                        (NonCachedIo || !RxWriteCacheingAllowed(capFcb,SrvOpen))) {
                        Status = RxAcquireSharedFcbWaitForEx( RxContext, capFcb );
                    } else {
                        Status = RxAcquireSharedFcb( RxContext, capFcb );
                    }
                } else {
                    Status = RxAcquireExclusiveFcb( RxContext, capFcb );
                }

                if (Status == STATUS_LOCK_NOT_GRANTED) {
                    RxDbgTrace( 0, Dbg, ("Cannot acquire Fcb = %08lx shared without waiting\n", capFcb ));
                    try_return( SET_POSTIRP("couldn't get mainr w/o waiting sh") );
                } else if (Status != STATUS_SUCCESS) {
                    RxDbgTrace( 0, Dbg, ("RxCommonWrite : Cannot acquire Fcb(%lx) %lx\n", capFcb, Status ));
                    try_return( PostIrp = FALSE );
                }

                RxContext->FcbResourceAcquired = TRUE;
            } else {
                ASSERT(!ThisIsAPipeWrite);
            }

            if (!ThisIsAPipeWrite) {
                if (ExIsResourceAcquiredSharedLite(capFcb->Header.Resource) &&
                    (StartingVbo + ByteCount > capFcb->Header.ValidDataLength.QuadPart) &&
                    BooleanFlagOn(capFcb->FcbState,FCB_STATE_COLLAPSING_ENABLED)) {

                    RxReleaseFcb(RxContext,capFcb);
                    RxContext->FcbResourceAcquired = FALSE;

                    Status = RxAcquireExclusiveFcb( RxContext, capFcb );

                    if (Status == STATUS_LOCK_NOT_GRANTED) {
                        RxDbgTrace( 0, Dbg, ("Cannot acquire Fcb = %08lx shared without waiting\n", capFcb ));
                        try_return( SET_POSTIRP("couldn't get mainr w/o waiting sh") );
                    } else if (Status != STATUS_SUCCESS) {
                        RxDbgTrace( 0, Dbg, ("RxCommonWrite : Cannot acquire Fcb(%lx) %lx\n", capFcb, Status ));
                        try_return( PostIrp = FALSE );
                    } else {
                        RxContext->FcbResourceAcquired = TRUE;
                    }
                }

                if ((StartingVbo + ByteCount > capFcb->Header.ValidDataLength.QuadPart) &&
                    (BooleanFlagOn(capFcb->FcbState,FCB_STATE_COLLAPSING_ENABLED))) {
                    ASSERT  ( RxIsFcbAcquiredExclusive ( capFcb )  );

                    RxLog(("RxCommonWrite Disable Collapsing %lx\n",capFcb));
                    RxWmiLog(LOG,
                             RxCommonWrite_3,
                             LOGPTR(capFcb));

                    // If we are extending the file disable collapsing to ensure that
                    // once the file is closed directory control will reflect the sizes
                    // correctly.
                    ClearFlag(capFcb->FcbState,FCB_STATE_COLLAPSING_ENABLED);
                } else {
                    // If the resource has been acquired exclusive we downgrade it
                    // to shared. This enables a combination of buffered and
                    // unbuffered writes to be synchronized correctly.

                    if (ExIsResourceAcquiredExclusiveLite(capFcb->Header.Resource)) {
                        ExConvertExclusiveToSharedLite( capFcb->Header.Resource );
                    }
                }
            }

            ASSERT(RxContext->FcbResourceAcquired);
            LowIoContext->Resource =  capFcb->Header.Resource;
        }

        //  for pipe writes, bail out now. we avoid a goto by duplicating the calldown
        //  indeed, pipe writes should be removed from the main path.

        if (ThisIsAPipeWrite) {
            //
            //  In order to prevent corruption on multi-threaded multi-block
            //  message mode pipe reads, we do this little dance with the fcb resource
            //

            if (!ThisIsABlockingResume) {

                if ((capFobx != NULL) &&
                    ((capFobx->Specific.NamedPipe.TypeOfPipe == FILE_PIPE_MESSAGE_TYPE) ||
                     ((capFobx->Specific.NamedPipe.TypeOfPipe == FILE_PIPE_BYTE_STREAM_TYPE) &&
                      !(capFobx->Specific.NamedPipe.CompletionMode & FILE_PIPE_COMPLETE_OPERATION)))  ) {

                    //
                    //  Synchronization is effected here that will prevent other
                    //  threads from coming in and reading from this file while the
                    //  message pipe read is continuing.
                    //
                    //  This is necessary because we will release the FCB lock while
                    //  actually performing the I/O to allow open (and other) requests
                    //  to continue on this file while the I/O is in progress.
                    //

                    RxDbgTrace( 0,Dbg,("Message pipe write: Fobx: %lx, Fcb: %lx, Enqueuing...\n", capFobx, capFcb ));

                    Status = RxSynchronizeBlockingOperationsAndDropFcbLock(
                                RxContext,
                                &capFobx->Specific.NamedPipe.WriteSerializationQueue);

                    RxContext->FcbResourceAcquired = FALSE;   //this happens in the above routine
                    RxItsTheSameContext();

                    if (!NT_SUCCESS(Status) ||
                        (Status == STATUS_PENDING)) {
                        try_return(Status);
                    }

                    RxDbgTrace( 0,Dbg,("Succeeded: Fobx: %lx\n", capFobx ));
                }
            }

            LowIoContext->ParamsFor.ReadWrite.ByteCount = ByteCount;
            LowIoContext->ParamsFor.ReadWrite.ByteOffset = StartingVbo;

            SetFlag(
                RxContext->FlagsForLowIo,
                RXCONTEXT_FLAG4LOWIO_PIPE_OPERATION);

            Status = RxLowIoWriteShell(RxContext);

            RxItsTheSameContext();
            try_return( Status );
        }

        //  We check whether we can proceed based on the state of the file oplocks.

        Status = FsRtlCheckOplock(
                     &capFcb->Specific.Fcb.Oplock,
                     capReqPacket,
                     RxContext,
                     RxOplockComplete,
                     RxPrePostIrp );

        if (Status != STATUS_SUCCESS) {
            OplockPostIrp = TRUE;
            SET_POSTIRP("couldn't get mainr w/o waiting shstarveex");
            try_return( NOTHING );
        }

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        //capFcb->Header.IsFastIoPossible = RxIsFastIoPossible( capFcb );

        //
        // If this is the normal data stream object we have to check for
        // write access according to the current state of the file locks.

        if (!PagingIo &&
            !FsRtlCheckLockForWriteAccess( &capFcb->Specific.Fcb.FileLock,
                                               capReqPacket )) {

                try_return( Status = STATUS_FILE_LOCK_CONFLICT );
        }

        //  we never write these without protextion...so the following comment is bogus.
        //  also, we manipulate the vdl and filesize as if we owned them.....in fact, we don't unless
        //  the file is cached for writing! i'm leaving the comment in case i understand it later

        //  HERE IS THE BOGUS COMMENT!!! (the part about not being protected.......)
        //  Get a first tentative file size and valid data length.
        //  We must get ValidDataLength first since it is always
        //  increased second (the case we are unprotected) and
        //  we don't want to capture ValidDataLength > FileSize.

        ValidDataLength = capFcb->Header.ValidDataLength.QuadPart;
        RxGetFileSizeWithLock(capFcb,&FileSize);

        ASSERT( ValidDataLength <= FileSize );

        //
        //  If this is paging io, then we do not want
        //  to write beyond end of file.  If the base is beyond Eof, we will just
        //  Noop the call.  If the transfer starts before Eof, but extends
        //  beyond, we will limit write to file size.
        //  Otherwise, in case of write through, since Mm rounds up
        //  to a page, we might try to acquire the resource exclusive
        //  when our top level guy only acquired it shared. Thus, =><=.

        // finally, if this is for a minirdr (as opposed to a local miniFS) AND
        // if cacheing is not enabled then i have no idea what VDL is! so, i have to just pass
        // it thru. Currently we do not provide for this case and let the RDBSS
        // throw the write on the floor. A better fix would be to let the mini
        // redirectors deal with it.

        if (PagingIo) {
            if (StartingVbo >= FileSize) {

                RxDbgTrace( 0, Dbg, ("PagingIo started beyond EOF.\n", 0 ));
                try_return( Status = STATUS_SUCCESS );
            }

            if (ByteCount > FileSize - StartingVbo) {

                RxDbgTrace( 0, Dbg, ("PagingIo extending beyond EOF.\n", 0 ));
                ByteCount = (ULONG)(FileSize - StartingVbo);
            }
        }

        //
        //  Determine if we were called by the lazywriter.
        //  see resrcsup.c for where we captured the lazywriter's thread
        //

        if (capFcb->Specific.Fcb.LazyWriteThread == PsGetCurrentThread()) {

            RxDbgTrace( 0, Dbg,("RxCommonWrite     ThisIsCalledByLazyWriter%c\n",'!'));
            CalledByLazyWriter = TRUE;

            if (FlagOn( capFcb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE )) {

                //
                //  Fail if the start of this request is beyond valid data length.
                //  Don't worry if this is an unsafe test.  MM and CC won't
                //  throw this page away if it is really dirty.
                //

                if ((StartingVbo + ByteCount > ValidDataLength) &&
                    (StartingVbo < FileSize)) {

                    //
                    //  It's OK if byte range is within the page containing valid data length,
                    //  since we will use ValidDataToDisk as the start point.
                    //

                    if (StartingVbo + ByteCount > ((ValidDataLength + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))) {

                        //
                        //  Don't flush this now.
                        //

                        try_return( Status = STATUS_FILE_LOCK_CONFLICT );
                    }
                }
            }
        }

        //
        //  This code detects if we are a recursive synchronous page write
        //  on a write through file object.
        //

        if (FlagOn(capReqPacket->Flags, IRP_SYNCHRONOUS_PAGING_IO) &&
            FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_RECURSIVE_CALL)) {

            PIRP TopIrp;

            TopIrp = RxGetTopIrpIfRdbssIrp();

            //
            //  This clause determines if the top level request was
            //  in the FastIo path.
            //

            if ( (TopIrp != NULL) &&
                    ((ULONG_PTR)TopIrp > FSRTL_MAX_TOP_LEVEL_IRP_FLAG) ) {

                PIO_STACK_LOCATION IrpStack;

                ASSERT( NodeType(TopIrp) == IO_TYPE_IRP );

                IrpStack = IoGetCurrentIrpStackLocation(TopIrp);

                //
                //  Finally this routine detects if the Top irp was a
                //  write to this file and thus we are the writethrough.
                //

                if ((IrpStack->MajorFunction == IRP_MJ_WRITE) &&
                    (IrpStack->FileObject->FsContext == capFileObject->FsContext)) {   //ok4->FileObj butmove

                    RecursiveWriteThrough = TRUE;
                    RxDbgTrace( 0, Dbg,("RxCommonWrite     ThisIsRecursiveWriteThru%c\n",'!'));
                    SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_WRITE_THROUGH );
                }
            }
        }

        //
        //  Here is the deal with ValidDataLength and FileSize:
        //
        //  Rule 1: PagingIo is never allowed to extend file size.
        //
        //  Rule 2: Only the top level requestor may extend Valid
        //          Data Length.  This may be paging IO, as when a
        //          a user maps a file, but will never be as a result
        //          of cache lazy writer writes since they are not the
        //          top level request.
        //
        //  Rule 3: If, using Rules 1 and 2, we decide we must extend
        //          file size or valid data, we take the Fcb exclusive.
        //

        //
        // Now see if we are writing beyond valid data length, and thus
        // maybe beyond the file size.  If so, then we must
        // release the Fcb and reacquire it exclusive.  Note that it is
        // important that when not writing beyond EOF that we check it
        // while acquired shared and keep the FCB acquired, in case some
        // turkey truncates the file.
        //

        //
        //  Note that the lazy writer must not be allowed to try and
        //  acquire the resource exclusive.  This is not a problem since
        //  the lazy writer is paging IO and thus not allowed to extend
        //  file size, and is never the top level guy, thus not able to
        //  extend valid data length.

        //
        // finally, all the discussion of VDL and filesize is conditioned on the fact
        // that cacheing is enabled. if not, we don't know the VDL OR the filesize and
        // we have to just send out the IOs

        if ( !CalledByLazyWriter      &&
             !RecursiveWriteThrough   &&
             ( WriteToEof  ||   (StartingVbo + ByteCount > ValidDataLength))) {

            //
            //  If this was an asynchronous write, we are going to make
            //  the request synchronous at this point, but only temporarily.
            //  At the last moment, before sending the write off to the
            //  driver, we may shift back to async.
            //
            //  The modified page writer already has the resources
            //  he requires, so this will complete in small finite
            //  time.
            //

            if (!SynchronousIo) {
                Wait = TRUE;
                SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_WAIT );
                ClearFlag( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );
                SynchronousIo = TRUE;

                if (NonCachedIo) {

                    SwitchBackToAsync = TRUE;
                }
            }

            //
            // We need Exclusive access to the Fcb since we will
            // probably have to extend valid data and/or file.  Drop
            // whatever we have and grab the normal resource exclusive.
            //

            RxWriteReleaseResources(RxContext); //release whatever resources we may have

            Status = RxAcquireExclusiveFcb(RxContext, capFcb);

            if (Status == STATUS_LOCK_NOT_GRANTED) {
                RxDbgTrace( 0, Dbg, ("Cannot acquire Fcb = %08lx shared without waiting\n", capFcb ));
                try_return( SET_POSTIRP("could get excl for extend") );
            } else if (Status != STATUS_SUCCESS) {
                RxDbgTrace( 0, Dbg, ("RxCommonWrite : Cannot acquire Fcb(%lx) : %lx\n", capFcb,Status ));
                try_return( RESET_POSTIRP() );
            }

            RxItsTheSameContext();

            RxContext->FcbResourceAcquired = TRUE;

            //
            //  Set the flag indicating if Fast I/O is possible
            //

            //capFcb->Header.IsFastIoPossible = RxIsFastIoPossible( capFcb );

            //
            //  Now that we have the Fcb exclusive, get a new batch of
            //  filesize and ValidDataLength.
            //

            ValidDataLength = capFcb->Header.ValidDataLength.QuadPart;
            RxGetFileSizeWithLock(capFcb,&FileSize);

            ASSERT( ValidDataLength <= FileSize );

            //
            //  Now that we have the Fcb exclusive, see if this write
            //  qualifies for being made async again.  The key point
            //  here is that we are going to update ValidDataLength in
            //  the Fcb before returning.  We must make sure this will
            //  not cause a problem. So, if we are extending the file OR if we have
            //  a section on the file, we can't go async.

            //  Another thing we must do is keep out
            //  the FastIo path.....this is done since we have the resource exclusive
            //

            if (SwitchBackToAsync) {

                if ((capFcb->NonPaged->SectionObjectPointers.DataSectionObject != NULL)
                     || ((StartingVbo + ByteCount) > FileSize)
                     ||  RxNoAsync) {

                    SwitchBackToAsync = FALSE;

                } else {

                    NOTHING;

                }
            }


            //
            //  We check whether we can proceed
            //  based on the state of the file oplocks.
            //

            Status = FsRtlCheckOplock(
                         &capFcb->Specific.Fcb.Oplock,
                         capReqPacket,
                         RxContext,
                         RxOplockComplete,
                         RxPrePostIrp );

            if (Status != STATUS_SUCCESS) {

                OplockPostIrp = TRUE;
                SET_POSTIRP("SecondOplockChk");
                try_return( NOTHING );
            }

            //
            //  If this is PagingIo check again if any pruning is
            //  required.
            //

            if ( PagingIo ) {

                if (StartingVbo >= FileSize) {
                    try_return( Status = STATUS_SUCCESS );
                }
                if (ByteCount > FileSize - StartingVbo) {
                    ByteCount = (ULONG)(FileSize - StartingVbo);
                }
            }
        }

        //
        //  Remember the initial file size and valid data length,
        //  just in case .....

        InitialFileSize = FileSize;
        InitialValidDataLength = ValidDataLength;

        //
        //  Check for writing to end of File.  If we are, then we have to
        //  recalculate a number of fields. These may have changed if we dropped
        //  and regained the resource.
        //

        if ( WriteToEof ) { //&& RxWriteCacheingAllowed(capFcb,SrvOpen)) {
            StartingVbo = FileSize;
            StartingByte.QuadPart = FileSize;
        }

        //
        // If this is the normal data stream object we have to check for
        // write access according to the current state of the file locks.

        if (!PagingIo &&
            !FsRtlCheckLockForWriteAccess( &capFcb->Specific.Fcb.FileLock,
                                               capReqPacket )) {

                try_return( Status = STATUS_FILE_LOCK_CONFLICT );
        }

        //
        //  Determine if we will deal with extending the file.
        //

        if (!PagingIo &&
            ThisIsADiskWrite &&
            (StartingVbo >= 0) &&
            (StartingVbo + ByteCount > FileSize)) {
            RxLog(("NeedToExtending %lx", RxContext));
            RxWmiLog(LOG,
                     RxCommonWrite_4,
                     LOGPTR(RxContext));
            ExtendingFile = TRUE;

            SetFlag(LowIoContext->ParamsFor.ReadWrite.Flags,LOWIO_READWRITEFLAG_EXTENDING_FILESIZE);
        }

        if ( ExtendingFile ) {
            LARGE_INTEGER OriginalFileSize;
            LARGE_INTEGER OriginalAllocationSize;
            LARGE_INTEGER OriginalValidDataLength;

            //
            //  EXTENDING THE FILE
            //
            //  Update our local copy of FileSize
            //

            OriginalFileSize.QuadPart = capFcb->Header.FileSize.QuadPart;
            OriginalAllocationSize.QuadPart = capFcb->Header.AllocationSize.QuadPart;
            OriginalValidDataLength.QuadPart = capFcb->Header.ValidDataLength.QuadPart;

            FileSize = StartingVbo + ByteCount;

            if (FileSize > capFcb->Header.AllocationSize.QuadPart) {

                LARGE_INTEGER AllocationSize;

                RxLog(("Extending %lx", RxContext));
                RxWmiLog(LOG,
                         RxCommonWrite_5,
                         LOGPTR(RxContext));
                if (NonCachedIo) {
                    MINIRDR_CALL(
                        Status,
                        RxContext,
                        capFcb->MRxDispatch,
                        MRxExtendForNonCache,
                        (RxContext,(PLARGE_INTEGER)&FileSize,&AllocationSize));
                } else {
                    MINIRDR_CALL(
                        Status,
                        RxContext,
                        capFcb->MRxDispatch,
                        MRxExtendForCache,
                        (RxContext,(PLARGE_INTEGER)&FileSize,&AllocationSize));
                }

                if (!NT_SUCCESS(Status)) {
                    RxDbgTrace(0, Dbg, ("Couldn't extend for cacheing.\n", 0));
                    try_return(Status);
                }

                if ( FileSize > AllocationSize.QuadPart ) {
                    // When the file is sparse this test is not valid. exclude
                    // this case by resetting the allocation size to file size.
                    // This effectively implies that we will go to the server
                    // for sparse I/O.
                    //
                    // This test is also not valid for compressed files. NTFS
                    // keeps track of the compressed file size and the uncompressed
                    // file size. It however returns the compressed file size for
                    // directory queries and information queries.
                    //
                    // For now we rely on the servers return code. If it returned
                    // success and the allocation size is less we believe that
                    // it is one of the two cases above and set allocation size
                    // to the desired file size.

                    AllocationSize.QuadPart = FileSize;
                }

                //
                //  Set the new file allocation in the Fcb.
                //
                capFcb->Header.AllocationSize  = AllocationSize;
            }

            //
            //  Set the new file size in the Fcb.
            //

            RxSetFileSizeWithLock(capFcb,&FileSize);
            RxAdjustAllocationSizeforCC(capFcb);

            //
            //  Extend the cache map, letting mm knows the new file size.
            //  We only have to do this if the file is cached.
            //

            if (CcIsFileCached(capFileObject)) {
                NTSTATUS SetFileSizeStatus = STATUS_SUCCESS;

                try {
                    CcSetFileSizes(
                        capFileObject,
                        (PCC_FILE_SIZES)&capFcb->Header.AllocationSize );
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    SetFileSizeStatus = GetExceptionCode();
                }

                if (SetFileSizeStatus != STATUS_SUCCESS) {
                    // Restore the original file sizes in the FCB and File object
                    capFcb->Header.FileSize.QuadPart = OriginalFileSize.QuadPart;
                    capFcb->Header.AllocationSize.QuadPart = OriginalAllocationSize.QuadPart;
                    capFcb->Header.ValidDataLength.QuadPart = OriginalValidDataLength.QuadPart;

                    if (capFileObject->SectionObjectPointer->SharedCacheMap != NULL) {
                        *CcGetFileSizePointer(capFileObject) = capFcb->Header.FileSize;
                    }

                    Status = SetFileSizeStatus;
                    try_return(Status);
                }
            }

        }

        //
        //  Determine if we will deal with extending valid data.
        //

        if ( !CalledByLazyWriter &&
             !RecursiveWriteThrough &&
             (WriteToEof ||
              (StartingVbo + ByteCount > ValidDataLength))) {
            ExtendingValidData = TRUE;
            SetFlag(LowIoContext->ParamsFor.ReadWrite.Flags,LOWIO_READWRITEFLAG_EXTENDING_VDL);
        }

        //
        // HANDLE CACHED CASE
        //

        if (!PagingIo     &&
            !NonCachedIo  &&             //this part is not discretionary
            RxWriteCacheingAllowed(capFcb,SrvOpen) ) {

            ASSERT( !PagingIo );

            //
            // We delay setting up the file cache until now, in case the
            // caller never does any I/O to the file, and thus
            // FileObject->PrivateCacheMap == NULL.
            //

            if ( capFileObject->PrivateCacheMap == NULL ) {

                RxDbgTrace(0, Dbg, ("Initialize cache mapping.\n", 0));

                RxAdjustAllocationSizeforCC(capFcb);

                //
                //  Now initialize the cache map.
                //

                try {
                    Status = STATUS_SUCCESS;

                    CcInitializeCacheMap(
                        capFileObject,
                        (PCC_FILE_SIZES)&capFcb->Header.AllocationSize,
                        FALSE,
                        &RxData.CacheManagerCallbacks,
                        capFcb );

                } except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = GetExceptionCode();
                }

                if (Status != STATUS_SUCCESS) {
                    try_return(Status);
                }

                CcSetReadAheadGranularity(
                    capFileObject,
                    NetRoot->DiskParameters.ReadAheadGranularity );
            }


            // For local file systems, there's a call here to zero data from VDL
            // to starting VBO....for remote FSs, that happens on the other end.

            //
            // DO A NORMAL CACHED WRITE, if the MDL bit is not set,
            //

            if (!FlagOn(RxContext->MinorFunction, IRP_MN_MDL)) {

                PVOID SystemBuffer;
                DEBUG_ONLY_DECL(ULONG SaveExceptionFlag;)

                RxDbgTrace(0, Dbg, ("Cached write.\n", 0));

                //
                //  Get hold of the user's buffer.

                SystemBuffer = RxNewMapUserBuffer( RxContext );
                if (SystemBuffer == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    try_return(Status);
                }

                //
                //  Make sure that a returned exception clears the breakpoint in the filter

                RxSaveAndSetExceptionNoBreakpointFlag(RxContext,SaveExceptionFlag);

                //
                // Do the write, possibly writing through

                RxItsTheSameContext();
                if (!CcCopyWrite(
                        capFileObject,
                        &StartingByte,
                        ByteCount,
                        Wait,
                        SystemBuffer )) {

                    RxDbgTrace( 0, Dbg, ("Cached Write could not wait\n", 0 ));
                    RxRestoreExceptionNoBreakpointFlag(RxContext,SaveExceptionFlag);

                    RxItsTheSameContext();

                    RxLog(
                        ("CcCW2 FO %lx Of %lx Si %lx St %lx\n",
                        capFileObject,
                        capFcb->Header.FileSize.LowPart,
                        ByteCount,
                        Status));
                    RxWmiLog(LOG,
                             RxCommonWrite_6,
                             LOGPTR(capFileObject)
                             LOGULONG(capFcb->Header.FileSize.LowPart)
                             LOGULONG(ByteCount)
                             LOGULONG(Status));

                    try_return( SET_POSTIRP("cccopywritefailed") );
                }

                capReqPacket->IoStatus.Status = STATUS_SUCCESS;
                capReqPacket->IoStatus.Information = ByteCount;
                RxRestoreExceptionNoBreakpointFlag(RxContext,SaveExceptionFlag);
                RxItsTheSameContext();

                RxLog(
                    ("CcCW3 FO %lx Of %lx Si %lx St %lx\n",
                    capFileObject,
                    capFcb->Header.FileSize.LowPart,
                    ByteCount,
                    Status));
                RxWmiLog(LOG,
                         RxCommonWrite_7,
                         LOGPTR(capFileObject)
                         LOGULONG(capFcb->Header.FileSize.LowPart)
                         LOGULONG(ByteCount)
                         LOGULONG(Status));

                try_return( Status = STATUS_SUCCESS );
            } else {

                //
                //  DO AN MDL WRITE
                //

                RxDbgTrace(0, Dbg, ("MDL write.\n", 0));

                ASSERT(FALSE);  //NOT YET IMPLEMENTED
                ASSERT( Wait );

                CcPrepareMdlWrite(
                    capFileObject,
                    &StartingByte,
                    ByteCount,
                    &capReqPacket->MdlAddress,
                    &capReqPacket->IoStatus );

                Status = capReqPacket->IoStatus.Status;

                try_return( Status );
            }
        }


        //
        // HANDLE THE NON-CACHED CASE

        if (SwitchBackToAsync) {

            Wait = FALSE;
            SynchronousIo = FALSE;
            ClearFlag( RxContext->Flags, RX_CONTEXT_FLAG_WAIT );
            SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION );
        }

        if (!SynchronousIo) {
            //here we have to setup for async writes. there is a special dance in acquiring
            //the fcb that looks at these variables..........

            //only init on the first usage
            if (!capFcb->NonPaged->OutstandingAsyncEvent) {

                capFcb->NonPaged->OutstandingAsyncEvent =
                    &capFcb->NonPaged->TheActualEvent;

                KeInitializeEvent(
                    capFcb->NonPaged->OutstandingAsyncEvent,
                    NotificationEvent,
                    FALSE );
            }

            //
            //  If we are transitioning from 0 to 1, reset the event.

            if (ExInterlockedAddUlong(
                    &capFcb->NonPaged->OutstandingAsyncWrites,
                    1,
                    &RxStrucSupSpinLock ) == 0) {

                KeResetEvent( capFcb->NonPaged->OutstandingAsyncEvent );
            }

            UnwindOutstandingAsync = TRUE;    // this says that we counted an async write
            LowIoContext->ParamsFor.ReadWrite.NonPagedFcb = capFcb->NonPaged;
        }


        LowIoContext->ParamsFor.ReadWrite.ByteCount = ByteCount;
        LowIoContext->ParamsFor.ReadWrite.ByteOffset = StartingVbo;

        RxDbgTrace( 0, Dbg,("RxCommonWriteJustBeforeCalldown     %s%s%s lowiononpaged is \n",
                        RxContext->FcbResourceAcquired          ?"FcbAcquired ":"",
                        RxContext->FcbPagingIoResourceAcquired   ?"PagingIoResourceAcquired ":"",
                        (LowIoContext->ParamsFor.ReadWrite.NonPagedFcb)?"NonNull":"Null"
                   ));

        RxItsTheSameContext();
        ASSERT ( RxContext->FcbResourceAcquired || RxContext->FcbPagingIoResourceAcquired );

        Status = RxLowIoWriteShell(RxContext);

        RxItsTheSameContext();
        if (UnwindOutstandingAsync && Status==STATUS_PENDING) {
            UnwindOutstandingAsync = FALSE;
        }

        try_return( Status );

    try_exit: NOTHING;

        ASSERT(capReqPacket);

        RxItsTheSameContext();
        if ( !PostIrp ) {

            RxDbgTrace( 0, Dbg, ("CommonWrite InnerFinally->  %08lx,%08lx\n",
                                     Status, capReqPacket->IoStatus.Information));

            if (!ThisIsAPipeWrite) {

                //
                //  Record the total number of bytes actually written
                //

                if (!PagingIo && NT_SUCCESS(Status) &&
                    BooleanFlagOn(capFileObject->Flags, FO_SYNCHRONOUS_IO)) {
                    capFileObject->CurrentByteOffset.QuadPart =
                        StartingVbo + capReqPacket->IoStatus.Information;
                }

                //
                //  The following are things we only do if we were successful
                //

                if ( NT_SUCCESS( Status ) && (Status!=STATUS_PENDING) ) {

                    //
                    //  If this was not PagingIo, mark that the modify
                    //  time on the dirent needs to be updated on close.
                    //

                    if ( !PagingIo ) {

                        SetFlag( capFileObject->Flags, FO_FILE_MODIFIED );
                    }

                    if ( ExtendingFile ) {

                        SetFlag( capFileObject->Flags, FO_FILE_SIZE_CHANGED );
                    }

                    if ( ExtendingValidData ) {

                        LONGLONG EndingVboWritten = StartingVbo + capReqPacket->IoStatus.Information;

                        //
                        //  Never set a ValidDataLength greater than FileSize.

                        capFcb->Header.ValidDataLength.QuadPart =
                              ( FileSize < EndingVboWritten ) ? FileSize : EndingVboWritten;

                        //
                        //  Now, if we are noncached and the file is cached, we must
                        //  tell the cache manager about the VDL extension so that
                        //  async cached IO will not be optimized into zero-page faults
                        //  beyond where it believes VDL is.
                        //
                        //  In the cached case, since Cc did the work, it has updated
                        //  itself already.
                        //

                        if (NonCachedIo && CcIsFileCached(capFileObject)) {
                            CcSetFileSizes( capFileObject, (PCC_FILE_SIZES)&capFcb->Header.AllocationSize );
                        }
                    }
                }
            }
        } else {

            //
            //  Take action if the Oplock package is not going to post the Irp.
            //

            if (!OplockPostIrp) {

                if ( ExtendingFile && !ThisIsAPipeWrite ) {

                    ASSERT ( RxWriteCacheingAllowed(capFcb,SrvOpen)  );

                    //
                    //  We need the PagingIo resource exclusive whenever we
                    //  pull back either file size or valid data length.
                    //

                    ASSERT ( capFcb->Header.PagingIoResource != NULL );

                    RxAcquirePagingIoResource(capFcb,RxContext);

                    RxSetFileSizeWithLock(capFcb,&InitialFileSize);
                    RxReleasePagingIoResource(capFcb,RxContext);

                    //
                    //  Pull back the cache map as well
                    //

                    if (capFileObject->SectionObjectPointer->SharedCacheMap != NULL) {
                        *CcGetFileSizePointer(capFileObject) = capFcb->Header.FileSize;
                    }
                }

                RxDbgTrace( 0, Dbg, ("Passing request to Fsp\n", 0 ));

                InterlockedIncrement(&RxContext->ReferenceCount);
                RefdContextForTracker = TRUE;

                // we only do this here because we're having a problem finding out why resources
                // are not released.
                RxWriteReleaseResources(RxContext); //release whatever resources we may have

#ifdef RDBSS_TRACKER
                if (RxContext->AcquireReleaseFcbTrackerX != 0) {
                    DbgPrint("TrackerNBadBeforePost %08lx %08lx\n",RxContext,&PostIrp);
                    ASSERT(!"BadTrackerBeforePost");
                }
#endif //ifdef RDBSS_TRACKER
                Status = RxFsdPostRequest(RxContext);
            }
        }

    } finally {

        DebugUnwind( RxCommonWrite );

        if (AbnormalTermination()) {
            //
            //  Restore initial file size and valid data length
            //

            if ((ExtendingFile || ExtendingValidData) && !ThisIsAPipeWrite) {

                //
                //  We got an error, pull back the file size if we extended it.
                //
                //  We need the PagingIo resource exclusive whenever we
                //  pull back either file size or valid data length.
                //

                ASSERT (capFcb->Header.PagingIoResource != NULL);

                (VOID)RxAcquirePagingIoResource(capFcb,RxContext);

                RxSetFileSizeWithLock(capFcb,&InitialFileSize);

                capFcb->Header.ValidDataLength.QuadPart = InitialValidDataLength;

                RxReleasePagingIoResource(capFcb,RxContext);

                //
                //  Pull back the cache map as well
                //
                if (capFileObject->SectionObjectPointer->SharedCacheMap != NULL) {
                    *CcGetFileSizePointer(capFileObject) = capFcb->Header.FileSize;
                }
            }
        }

        //
        //  Check if this needs to be backed out.
        //

        if (UnwindOutstandingAsync) {

            ASSERT (!ThisIsAPipeWrite);
            ExInterlockedAddUlong( &capFcb->NonPaged->OutstandingAsyncWrites,
                                   0xffffffff,
                                   &RxStrucSupSpinLock );

            KeSetEvent( LowIoContext->ParamsFor.ReadWrite.NonPagedFcb->OutstandingAsyncEvent, 0, FALSE );
        }
#if 0
        //
        //  If we did an MDL write, and we are going to complete the request
        //  successfully, keep the resource acquired, reducing to shared
        //  if it was acquired exclusive.
        //

        if (FlagOn(RxContext->MinorFunction, IRP_MN_MDL) &&
            !PostIrp &&
            !AbnormalTermination() &&
            NT_SUCCESS(Status)) {

            ASSERT( FcbAcquired && !PagingIoResourceAcquired );

            FcbAcquired = FALSE;

            if (FcbAcquiredExclusive) {

                ExConvertExclusiveToSharedLite( Fcb->Header.Resource );
            }
        }
#endif
        //
        //  If resources have been acquired, release them under the right conditions.
        //  the right conditions are these:
        //     1) if we have abnormal termination. here we obviously release the since no one else will.
        //     2) if the underlying call did not succeed: Status==Pending.
        //     3) if we posted the request

        if (AbnormalTermination() || (Status!=STATUS_PENDING) || PostIrp) {
            if (!PostIrp) {
                RxWriteReleaseResources(RxContext); //release whatever resources we may have
            }

            if (RefdContextForTracker) {
                RxDereferenceAndDeleteRxContext(RxContext);
            }

            if (!PostIrp) {
                if (FlagOn(RxContext->FlagsForLowIo,RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION)) {
                    RxResumeBlockedOperations_Serially(
                        RxContext,
                        &capFobx->Specific.NamedPipe.WriteSerializationQueue);
                }
            }

            if (Status == STATUS_SUCCESS) {
                ASSERT ( capReqPacket->IoStatus.Information
                              <=  capPARAMS->Parameters.Write.Length );
            }
        } else {
            //here the guy below is going to handle the completion....but, we don't know the finish
            //order....in all likelihood the deletecontext call below just reduces the refcount
            // but the guy may already have finished in which case this will really delete the context.
            ASSERT(!SynchronousIo);
            RxDereferenceAndDeleteRxContext(RxContext);
        }

        RxDbgTrace(-1, Dbg, ("CommonWrite -> %08lx\n", Status ));

        if( (Status!=STATUS_PENDING) && (Status!=STATUS_SUCCESS) )
        {
            if( PagingIo )
            {
                RxLogRetail(( "PgWrtFail %x %x %x\n", capFcb, NetRoot, Status ));
            }
        }

    } //finally

    return Status;
}

//
//  Internal support routine
//

NTSTATUS
RxLowIoWriteShellCompletion (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine postprocesses a write request after it comes back from the
    minirdr.  It does callouts to handle compression, buffering and
    shadowing.  It is the opposite number of LowIoWriteShell.

    This will be called from LowIo; for async, originally in the
    completion routine.  If RxStatus(MORE_PROCESSING_REQUIRED) is returned,
    LowIo will call again in a thread.  If this was syncIo, you'll be back
    in the user's thread; if async, lowIo will requeue to a thread.
    Currrently, we always get to a thread before anything; this is a bit slower
    than completing at DPC time,
    but it's aheckuva lot safer and we may often have stuff to do
    (like decompressing, shadowing, etc) that we don't want to do at DPC
    time.

Arguments:

    RxContext - the usual

Return Value:

    whatever value supplied by the caller or RxStatus(MORE_PROCESSING_REQUIRED).

--*/
{
    NTSTATUS Status;

    RxCaptureRequestPacket;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;
    RxCaptureFileObject;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    BOOLEAN  SynchronousIo = !BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION);
    BOOLEAN  PagingIo      = BooleanFlagOn(capReqPacket->Flags, IRP_PAGING_IO);
    BOOLEAN  ThisIsAPipeOperation =
            BooleanFlagOn(RxContext->FlagsForLowIo,RXCONTEXT_FLAG4LOWIO_PIPE_OPERATION);
    BOOLEAN  ThisIsASynchronizedPipeOperation =
            BooleanFlagOn(RxContext->FlagsForLowIo,RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION);

    PAGED_CODE();

    Status = RxContext->StoredStatus;
    capReqPacket->IoStatus.Information = RxContext->InformationToReturn;

    RxDbgTrace(+1, Dbg, ("RxLowIoWriteShellCompletion  entry  Status = %08lx\n", Status));
    RxLog(("WtShlComp %lx %lx %lx\n",RxContext,Status,capReqPacket->IoStatus.Information));
    RxWmiLog(LOG,
             RxLowIoWriteShellCompletion_1,
             LOGPTR(RxContext)
             LOGULONG(Status)
             LOGPTR(capReqPacket->IoStatus.Information));

    ASSERT (RxLowIoIsBufferLocked(LowIoContext));

    switch (Status) {
    case STATUS_SUCCESS:
        {
            if(FlagOn(RxContext->FlagsForLowIo, RXCONTEXT_FLAG4LOWIO_THIS_IO_BUFFERED)){
                if (FlagOn(capFcb->FcbState, FCB_STATE_FILE_IS_DISK_COMPRESSED)){
                   ASSERT(FALSE); // NOT YET IMPLEMENTED should decompress and put away
                } else if  (FlagOn(capFcb->FcbState, FCB_STATE_FILE_IS_BUF_COMPRESSED)){
                   ASSERT(FALSE); // NOT YET IMPLEMENTED should decompress and put away
                }
            }
            if (FlagOn(capFcb->FcbState, FCB_STATE_FILE_IS_SHADOWED)) {
               ASSERT(FALSE); //RxSdwAddData(RxContext);
            }

#ifdef RX_WJ_DBG_SUPPORT
            RxdUpdateJournalOnLowIoWriteCompletion(
                capFcb,
                capPARAMS->Parameters.Write.ByteOffset,
                capPARAMS->Parameters.Write.Length);
#endif
        }
        break;

    case STATUS_FILE_LOCK_CONFLICT:
        break;

    case STATUS_CONNECTION_INVALID:
        //NOT YET IMPLEMENTED here is where the failover will happen
        //first we give the local guy current minirdr another chance...then we go
        //to fullscale retry
        //return(RxStatus(DISCONNECTED));   //special....let LowIo get us back
        break;
    }

    if( Status!=STATUS_SUCCESS )
    {
        if( PagingIo )
        {
            RxLogRetail(( "PgWrtFail %x %x %x\n", capFcb, capFcb->pNetRoot, Status ));
        }
    }

    if (FlagOn(LowIoContext->Flags,LOWIO_CONTEXT_FLAG_SYNCCALL)){
        //if we're being called from lowioubmit then just get out
        RxDbgTrace(-1, Dbg, ("RxLowIoWriteShellCompletion  syncexit  Status = %08lx\n", Status));
        return(Status);
    }

    //otherwise we have to do the end of the write from here
    if ( NT_SUCCESS( Status ) && !ThisIsAPipeOperation ) {

        ASSERT( capReqPacket->IoStatus.Information == LowIoContext->ParamsFor.ReadWrite.ByteCount );

        //  If this was not PagingIo, mark that the modify
        //  time on the dirent needs to be updated on close.
        if ( !PagingIo ) {

            SetFlag( capFileObject->Flags, FO_FILE_MODIFIED );
        }

        if ( FlagOn(LowIoContext->ParamsFor.ReadWrite.Flags,LOWIO_READWRITEFLAG_EXTENDING_FILESIZE) ) {

            SetFlag( capFileObject->Flags, FO_FILE_SIZE_CHANGED );
        }

        if ( FlagOn(LowIoContext->ParamsFor.ReadWrite.Flags,LOWIO_READWRITEFLAG_EXTENDING_VDL) ) {

            //this flag will not be set unless we have a valid filesize and therefore the starting
            //vbo will not be write-to-end-of-file
            LONGLONG StartingVbo = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
            LONGLONG EndingVboWritten = StartingVbo + capReqPacket->IoStatus.Information;
            LONGLONG FileSize;//         = capFcb->Header.FileSize.QuadPart;

            //
            //  Never set a ValidDataLength greater than FileSize.
            //
            RxGetFileSizeWithLock(capFcb,&FileSize);
            capFcb->Header.ValidDataLength.QuadPart =
                  ( FileSize < EndingVboWritten ) ? FileSize : EndingVboWritten;

        }
    }

    if ((!ThisIsASynchronizedPipeOperation) &&
        (LowIoContext->ParamsFor.ReadWrite.NonPagedFcb != NULL) &&
        (ExInterlockedAddUlong( &LowIoContext->ParamsFor.ReadWrite.NonPagedFcb->OutstandingAsyncWrites,
                                     0xffffffff,
                                     &RxStrucSupSpinLock ) == 1) ) {

        KeSetEvent( LowIoContext->ParamsFor.ReadWrite.NonPagedFcb->OutstandingAsyncEvent, 0, FALSE );
    }

    if ( RxContext->FcbPagingIoResourceAcquired ) {
        RxReleasePagingIoResourceForThread(capFcb,LowIoContext->ResourceThreadId,RxContext);
    }

    if ((!ThisIsASynchronizedPipeOperation) &&
        (RxContext->FcbResourceAcquired)) {
        RxReleaseFcbForThread(
            RxContext,
            capFcb,
            LowIoContext->ResourceThreadId );
    }

    if (ThisIsASynchronizedPipeOperation) {
        RxCaptureFobx;

        RxResumeBlockedOperations_Serially(
            RxContext,
            &capFobx->Specific.NamedPipe.WriteSerializationQueue);
    }

    ASSERT(Status != STATUS_RETRY);
    if ( Status != STATUS_RETRY){
        ASSERT( (Status != STATUS_SUCCESS) ||
               (capReqPacket->IoStatus.Information <=  capPARAMS->Parameters.Write.Length ));
        ASSERT (RxContext->MajorFunction == IRP_MJ_WRITE);
    }

    if (ThisIsAPipeOperation) {
        RxCaptureFobx;

        if (capReqPacket->IoStatus.Information != 0) {

            // if we have been throttling on this pipe, stop because our writing to the pipe may
            // cause the pipeserver (not smbserver) on the other end to unblock so we should go back
            // and see

            RxTerminateThrottling(&capFobx->Specific.NamedPipe.ThrottlingState);

            RxLog((
                "WThrottlNo %lx %lx %lx %ld\n",
                RxContext,capFobx,&capFobx->Specific.NamedPipe.ThrottlingState,
                capFobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries));
            RxWmiLog(LOG,
                     RxLowIoWriteShellCompletion_2,
                     LOGPTR(RxContext)
                     LOGPTR(capFobx)
                     LOGULONG(capFobx->Specific.NamedPipe.ThrottlingState.NumberOfQueries));
        }
    }

    RxDbgTrace(-1, Dbg, ("RxLowIoWriteShellCompletion  exit  Status = %08lx\n", Status));
    return(Status);
}

#define RxSdwWrite(RXCONTEXT)  STATUS_MORE_PROCESSING_REQUIRED
NTSTATUS
RxLowIoWriteShell (
    IN PRX_CONTEXT RxContext
    )

/*++

Routine Description:

    This routine preprocesses a write request before it goes down to the minirdr.
    It does callouts to handle compression, buffering and shadowing. It is the
    opposite number of LowIoWriteShellCompletion. By the time we get here, we are
    going to the wire. Write buffering was already tried in the UncachedWrite strategy

Arguments:

    RxContext - the usual

Return Value:

    whatever value is returned by a callout....or by LowIo.

--*/

{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureParamBlock;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("RxLowIoWriteShell  entry             %08lx\n", 0));
    RxLog(("WrtShl in %lx\n",RxContext));
    RxWmiLog(LOG,
             RxLowIoWriteShell_1,
             LOGPTR(RxContext));

    if (FlagOn(capFcb->FcbState, FCB_STATE_FILE_IS_SHADOWED)) {
        RxSdwWrite(RxContext);
    }

    if (FlagOn(capFcb->FcbState, FCB_STATE_FILE_IS_DISK_COMPRESSED)){
        // NOT YET IMPLEMENTED should translated to a buffered but not held diskcompressed write
        ASSERT(FALSE);
    } else if  (FlagOn(capFcb->FcbState, FCB_STATE_FILE_IS_BUF_COMPRESSED)){
        // NOT YET IMPLEMENTED should translated to a buffered and bufcompressed write
        ASSERT(FALSE);
    }

    if (capFcb->CachedNetRootType == NET_ROOT_DISK) {
        ExInterlockedAddLargeStatistic(
            &RxContext->RxDeviceObject->NetworkReadBytesRequested,
            LowIoContext->ParamsFor.ReadWrite.ByteCount);
    }

#ifdef RX_WJ_DBG_SUPPORT
    RxdUpdateJournalOnLowIoWriteInitiation(
        capFcb,
        capPARAMS->Parameters.Write.ByteOffset,
        capPARAMS->Parameters.Write.Length);
#endif

    Status = RxLowIoSubmit(
                 RxContext,
                 RxLowIoWriteShellCompletion);

    RxDbgTrace(-1, Dbg, ("RxLowIoWriteShell  exit  Status = %08lx\n", Status));
    RxLog(("WrtShl out %lx %lx\n",RxContext,Status));
    RxWmiLog(LOG,
             RxLowIoWriteShell_2,
             LOGPTR(RxContext)
             LOGULONG(Status));

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\dav2kd\dav2kd.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    dav2kd.h

Abstract:

    Redirector Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#ifndef _DAV2KD_H_
#define _DAV2KD_H_

typedef enum _FOLLOWON_HELPER_RETURNS {
    FOLLOWONHELPER_CALLTHRU,
    FOLLOWONHELPER_DUMP,
    FOLLOWONHELPER_ERROR,
    FOLLOWONHELPER_DONE
} FOLLOWON_HELPER_RETURNS;

typedef struct _PERSISTENT_RDR2KD_INFO {
    DWORD OpenCount;
    ULONG_PTR LastAddressDumped[100];
    ULONG IdOfLastDump;
    ULONG IndexOfLastDump;
    BYTE StructDumpBuffer[2048];
} PERSISTENT_RDR2KD_INFO, *PPERSISTENT_RDR2KD_INFO;

PPERSISTENT_RDR2KD_INFO LocatePersistentInfoFromView ();
VOID
FreePersistentInfoView (
    PPERSISTENT_RDR2KD_INFO p
    );


typedef
FOLLOWON_HELPER_RETURNS
(NTAPI *PFOLLOWON_HELPER_ROUTINE) (
    IN OUT PPERSISTENT_RDR2KD_INFO p,
    OUT    PBYTE Name,
    OUT    PBYTE Buffer2
    );

#define DECLARE_FOLLOWON_HELPER_CALLEE(s) \
    FOLLOWON_HELPER_RETURNS s (           \
    IN OUT PPERSISTENT_RDR2KD_INFO p,     \
    OUT    PBYTE Name,                    \
    OUT    PBYTE Buffer2       \
    )

#endif // _DAV2KD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\dav2kd\kdextlib.c ===
/*++

Copyright (c) 1990 Microsoft Corporation











------------------------------
T H I S   F I L E   I S   O B S O L E T E .    I T   I S   B E I N G   K E P T
F O R   A   W H I L E   J U S T   T O   M A K E   S U R E
----------------------------
















Module Name:

    kdextlib.c

Abstract:

    Library routines for dumping data structures given a meta level descrioption

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:
    The implementation tends to avoid memory allocation and deallocation as much as possible.
    Therefore We have choosen an arbitrary length as the default buffer size. A mechanism will
    be provided to modify this buffer length through the debugger extension commands.

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#include "rxovride.h" //common compile flags
#include "ntifs.h"
#include <nt.h>
//#include <ntrtl.h>
#include "ntverp.h"

#define KDEXTMODE

#include <windef.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <ntrxdef.h>
#include <rxtypes.h>
#include <rxlog.h>

PWINDBG_OUTPUT_ROUTINE                lpOutputRoutine;
PWINDBG_GET_EXPRESSION32              lpGetExpressionRoutine;
PWINDBG_GET_SYMBOL32                  lpGetSymbolRoutine;
PWINDBG_READ_PROCESS_MEMORY_ROUTINE   lpReadMemoryRoutine;

#define    PRINTF    lpOutputRoutine
#define    ERROR     lpOutputRoutine

#define    NL      1
#define    NONL    0

#define    SETCALLBACKS() \
    lpOutputRoutine = lpExtensionApis->lpOutputRoutine; \
    lpGetExpressionRoutine = lpExtensionApis->lpGetExpressionRoutine; \
    lpGetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine; \
    lpReadMemoryRoutine = lpExtensionApis->lpReadVirtualMemRoutine;

#define DEFAULT_UNICODE_DATA_LENGTH 512
USHORT s_UnicodeStringDataLength = DEFAULT_UNICODE_DATA_LENGTH;
WCHAR  s_UnicodeStringData[DEFAULT_UNICODE_DATA_LENGTH];
WCHAR *s_pUnicodeStringData = s_UnicodeStringData;

#define DEFAULT_ANSI_DATA_LENGTH 512
USHORT s_AnsiStringDataLength = DEFAULT_ANSI_DATA_LENGTH;
CHAR  s_AnsiStringData[DEFAULT_ANSI_DATA_LENGTH];
CHAR *s_pAnsiStringData = s_AnsiStringData;

/*
 * Fetches the data at the given address
 */
BOOLEAN
GetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, PSZ type)
{
    BOOL b;
    ULONG BytesRead;

    b = (lpReadMemoryRoutine)(dwAddress, ptr, size, &BytesRead );


    if (!b || BytesRead != size ) {
        PRINTF( "Unable to read %u bytes at %p, for %s\n", size, dwAddress, type );
        return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the null terminated ASCII string at dwAddress into buf
 */
BOOL
GetString( ULONG_PTR dwAddress, PSZ buf )
{
    do {
        if( !GetData( dwAddress,buf, 1, "..stringfetch") )
            return FALSE;

        dwAddress++;
        buf++;

    } while( *buf != '\0' );

    return TRUE;
}

/*
 * Displays a byte in hexadecimal
 */
VOID
PrintHexChar( UCHAR c )
{
    PRINTF( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Displays a buffer of data in hexadecimal
 */
VOID
PrintHexBuf( PUCHAR buf, ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        PRINTF( " " );
    }
}

/*
 * Displays a unicode string
 */
BOOL
PrintStringW(LPSTR msg, PUNICODE_STRING puStr, BOOL nl )
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING    AnsiString;
    BOOL           b;

    if( msg )
        PRINTF( msg );

    if( puStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    UnicodeString.Buffer        = s_pUnicodeStringData;
    UnicodeString.MaximumLength = s_UnicodeStringDataLength;
    UnicodeString.Length = (puStr->Length > s_UnicodeStringDataLength)
                            ? s_UnicodeStringDataLength
                            : puStr->Length;

    b = (lpReadMemoryRoutine)(
                (ULONG_PTR) puStr->Buffer,
                UnicodeString.Buffer,
                UnicodeString.Length,
                NULL);

    if (b)    {
        RtlUnicodeStringToAnsiString(&AnsiString, puStr, TRUE);
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
        RtlFreeAnsiString(&AnsiString);
    }

    return b;
}

/*
 * Displays a ANSI string
 */
BOOL
PrintStringA(LPSTR msg, PANSI_STRING pStr, BOOL nl )
{
    ANSI_STRING AnsiString;
    BOOL        b;

    if( msg )
        PRINTF( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    AnsiString.Buffer        = s_pAnsiStringData;
    AnsiString.MaximumLength = s_AnsiStringDataLength;
    AnsiString.Length = (pStr->Length > (s_AnsiStringDataLength - 1))
                        ? (s_AnsiStringDataLength - 1)
                        : pStr->Length;

    b = (lpReadMemoryRoutine)(
                (ULONG_PTR) pStr->Buffer,
                AnsiString.Buffer,
                AnsiString.Length,
                NULL);

    if (b)    {
        AnsiString.Buffer[ AnsiString.Length ] = '\0';
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\dav2kd\dav2kd.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    dav2kd.c

Abstract:

    Redirector Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#include "rx.h"       // NT network file system driver include file
#include "ntddnfs2.h" // new stuff device driver definitions
#include "smbmrx.h"   // smbmini rdr global include file

#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <dav2kd.h>



/*
 * RDR2 global variables.
 *
 */

LPSTR GlobalBool[]  = {
            "mrxsmb!MRxSmbDeferredOpensEnabled",
            "mrxsmb!MRxSmbOplocksDisabled",
             0};

LPSTR GlobalShort[] = {0};
LPSTR GlobalLong[]  = {
            0};

LPSTR GlobalPtrs[]  = {
            "mrxdav!RxExpCXR",
            "mrxdav!RxExpEXR",
            "mrxdav!RxExpAddr",
            "mrxdav!RxExpCode",
            "mrxdav!RxActiveContexts",
            "mrxdav!RxNetNameTable",
            "mrxdav!RxProcessorArchitecture",
            "mrxdav!RxBuildNumber",
            "mrxdav!RxPrivateBuild",
            "mrxsmb!SmbMmExchangesInUse",
            "mrxsmb!MRxSmbBuildNumber",
            "mrxsmb!MRxSmbPrivateBuild",
            0};


/*
 * IRP_CONTEXT debugging.
 *
 */

FIELD_DESCRIPTOR RxContextFields[] =
   {
      FIELD3(FieldTypeUShort,RX_CONTEXT,NodeTypeCode),
      FIELD3(FieldTypeShort,RX_CONTEXT,NodeByteSize),
      FIELD3(FieldTypeULong,RX_CONTEXT,ReferenceCount),
      FIELD3(FieldTypeULong,RX_CONTEXT,SerialNumber),
      FIELD3(FieldTypeStruct,RX_CONTEXT,WorkQueueItem),
      FIELD3(FieldTypePointer,RX_CONTEXT,CurrentIrp),
      FIELD3(FieldTypePointer,RX_CONTEXT,CurrentIrpSp),
      FIELD3(FieldTypePointer,RX_CONTEXT,pFcb),
      FIELD3(FieldTypePointer,RX_CONTEXT,pFobx),
      //FIELD3(FieldTypePointer,RX_CONTEXT,pRelevantSrvOpen),
      FIELD3(FieldTypePointer,RX_CONTEXT,LastExecutionThread),
#ifdef RDBSS_TRACKER
      FIELD3(FieldTypePointer,RX_CONTEXT,AcquireReleaseFcbTrackerX),
#endif
      FIELD3(FieldTypePointer,RX_CONTEXT,MRxContext[2]),
      FIELD3(FieldTypeSymbol,RX_CONTEXT,ResumeRoutine),
      FIELD3(FieldTypePointer,RX_CONTEXT,RealDevice),
      FIELD3(FieldTypeULongFlags,RX_CONTEXT,Flags),
      FIELD3(FieldTypeChar,RX_CONTEXT,MajorFunction),
      FIELD3(FieldTypeChar,RX_CONTEXT,MinorFunction),
      FIELD3(FieldTypeULong,RX_CONTEXT,StoredStatus),
      FIELD3(FieldTypeStruct,RX_CONTEXT,SyncEvent),
      FIELD3(FieldTypeStruct,RX_CONTEXT,RxContextSerializationQLinks),
      FIELD3(FieldTypeStruct,RX_CONTEXT,Create),
      FIELD3(FieldTypeStruct,RX_CONTEXT,LowIoContext),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.NetNamePrefixEntry),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.pSrvCall),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.pNetRoot),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.pVNetRoot),
      //FIELD3(FieldTypePointer,RX_CONTEXT,Create.pSrvOpen),
      0
   };

/*
 * SRV_CALL debugging.
 *
 */

//CODE.IMPROVEMENT we should have a fieldtype for prefixentry that
//                 will print out the names

FIELD_DESCRIPTOR SrvCallFields[] =
   {
      FIELD3(FieldTypeUShort,SRV_CALL,NodeTypeCode),
      FIELD3(FieldTypeShort,SRV_CALL,NodeByteSize),
      FIELD3(FieldTypeStruct,SRV_CALL,PrefixEntry),
      FIELD3(FieldTypeUnicodeString,SRV_CALL,PrefixEntry.Prefix),
      FIELD3(FieldTypePointer,SRV_CALL,Context),
      FIELD3(FieldTypePointer,SRV_CALL,Context2),
      FIELD3(FieldTypeULong,SRV_CALL,Flags),
      0
   };

/*
 * NET_ROOT debugging.
 *
 */

FIELD_DESCRIPTOR NetRootFields[] =
   {
      FIELD3(FieldTypeUShort,NET_ROOT,NodeTypeCode),
      FIELD3(FieldTypeShort,NET_ROOT,NodeByteSize),
      FIELD3(FieldTypeULong,NET_ROOT,NodeReferenceCount),
      FIELD3(FieldTypeStruct,NET_ROOT,PrefixEntry),
      FIELD3(FieldTypeUnicodeString,NET_ROOT,PrefixEntry.Prefix),
      FIELD3(FieldTypeStruct,NET_ROOT,FcbTable),
      //FIELD3(FieldTypePointer,NET_ROOT,Dispatch),
      FIELD3(FieldTypePointer,NET_ROOT,Context),
      FIELD3(FieldTypePointer,NET_ROOT,Context2),
      FIELD3(FieldTypePointer,NET_ROOT,SrvCall),
      FIELD3(FieldTypeULong,NET_ROOT,Flags),
      0
   };


/*
 * V_NET_ROOT debugging.
 *
 */

FIELD_DESCRIPTOR VNetRootFields[] =
   {
      FIELD3(FieldTypeUShort,V_NET_ROOT,NodeTypeCode),
      FIELD3(FieldTypeShort,V_NET_ROOT,NodeByteSize),
      FIELD3(FieldTypeULong,V_NET_ROOT,NodeReferenceCount),
      FIELD3(FieldTypeStruct,V_NET_ROOT,PrefixEntry),
      FIELD3(FieldTypeUnicodeString,V_NET_ROOT,PrefixEntry.Prefix),
      FIELD3(FieldTypeUnicodeString,V_NET_ROOT,NamePrefix),
      FIELD3(FieldTypePointer,V_NET_ROOT,Context),
      FIELD3(FieldTypePointer,V_NET_ROOT,Context2),
      FIELD3(FieldTypePointer,V_NET_ROOT,NetRoot),
      0
   };


/*
 * FCB debugging.
 *
 */

FIELD_DESCRIPTOR FcbFields[] =
   {
      FIELD3(FieldTypeUShort,FCB,Header.NodeTypeCode),
      FIELD3(FieldTypeShort,FCB,Header.NodeByteSize),
      FIELD3(FieldTypeULong,FCB,NodeReferenceCount),
      FIELD3(FieldTypeULong,FCB,FcbState),
      FIELD3(FieldTypeULong,FCB,OpenCount),
      FIELD3(FieldTypeULong,FCB,UncleanCount),
      FIELD3(FieldTypePointer,FCB,Header.Resource),
      FIELD3(FieldTypePointer,FCB,Header.PagingIoResource),
      FIELD3(FieldTypeStruct,FCB,FcbTableEntry),
      FIELD3(FieldTypeUnicodeString,FCB,PrivateAlreadyPrefixedName),
      FIELD3(FieldTypePointer,FCB,VNetRoot),
      FIELD3(FieldTypePointer,FCB,NetRoot),
      FIELD3(FieldTypePointer,FCB,Context),
      FIELD3(FieldTypePointer,FCB,Context2),
      FIELD3(FieldTypeStruct,FCB,SrvOpenList),
      0
   };

FIELD_DESCRIPTOR FcbTableEntry[]=
   {

    FIELD3(FieldTypeUShort,RX_FCB_TABLE_ENTRY,NodeTypeCode),
    FIELD3(FieldTypeUShort,RX_FCB_TABLE_ENTRY,NodeByteSize),
    FIELD3(FieldTypeULong, RX_FCB_TABLE_ENTRY,HashValue),
    FIELD3(FieldTypeUnicodeString,RX_FCB_TABLE_ENTRY,Path),
    FIELD3(FieldTypeULong,RX_FCB_TABLE_ENTRY,HashLinks),
    FIELD3(FieldTypeLong,RX_FCB_TABLE_ENTRY,Lookups),
    0
   };

FIELD_DESCRIPTOR FcbTable[] =
   {

    FIELD3(FieldTypeUShort,RX_FCB_TABLE,NodeTypeCode),
    FIELD3(FieldTypeUShort,RX_FCB_TABLE,NodeByteSize),
    FIELD3(FieldTypeULong,RX_FCB_TABLE,Version),
    FIELD3(FieldTypeBoolean,RX_FCB_TABLE,CaseInsensitiveMatch),
    FIELD3(FieldTypeUShort,RX_FCB_TABLE,NumberOfBuckets),
    FIELD3(FieldTypeLong,RX_FCB_TABLE,Lookups),
    FIELD3(FieldTypeLong,RX_FCB_TABLE,FailedLookups),
    FIELD3(FieldTypeLong,RX_FCB_TABLE,Compares),
    FIELD3(FieldTypePointer,RX_FCB_TABLE,pTableEntryForNull),
    FIELD3(FieldTypePointer,RX_FCB_TABLE,HashBuckets),
    0
   };

/*
 * SRV_OPEN debugging.
 *
 */

FIELD_DESCRIPTOR SrvOpenFields[] =
   {
      FIELD3(FieldTypeShort,SRV_OPEN,NodeTypeCode),
      FIELD3(FieldTypeShort,SRV_OPEN,NodeByteSize),
      FIELD3(FieldTypeULong,SRV_OPEN,NodeReferenceCount),
      FIELD3(FieldTypePointer,SRV_OPEN,Fcb),
      FIELD3(FieldTypeULong,SRV_OPEN,Flags),
      0
   };


/*
 * FOBX debugging.
 *
 */

FIELD_DESCRIPTOR FobxFields[] =
   {
      FIELD3(FieldTypeShort,FOBX,NodeTypeCode),
      FIELD3(FieldTypeShort,FOBX,NodeByteSize),
      FIELD3(FieldTypeULong,FOBX,NodeReferenceCount),
      FIELD3(FieldTypePointer,FOBX,SrvOpen),
      0
   };



#define SMBCE_ENTRY_FIELDS(__TYPE__) \
      FIELD3(FieldTypeULong,__TYPE__,Header.SwizzleCount),    \
      FIELD3(FieldTypeChar,__TYPE__,Header.Flags),    \
      FIELD3(FieldTypeLong,__TYPE__,Header.State),



FIELD_DESCRIPTOR ServerEntryFields[] =
    {
        SMBCE_ENTRY_FIELDS(SMBCEDB_SERVER_ENTRY)
        FIELD3(FieldTypeUnicodeString,SMBCEDB_SERVER_ENTRY,Name),
        FIELD3(FieldTypeStruct,SMBCEDB_SERVER_ENTRY,Sessions),
        FIELD3(FieldTypeStruct,SMBCEDB_SERVER_ENTRY,NetRoots),
        FIELD3(FieldTypePointer,SMBCEDB_SERVER_ENTRY,pTransport),
        FIELD3(FieldTypeULong,SMBCEDB_SERVER_ENTRY,ServerStatus),
        FIELD3(FieldTypePointer,SMBCEDB_SERVER_ENTRY,pMidAtlas),
        FIELD3(FieldTypeStruct,SMBCEDB_SERVER_ENTRY,Server),
        FIELD3(FieldTypeUnicodeString,SMBCEDB_SERVER_ENTRY,DfsRootName),
        0
    };

FIELD_DESCRIPTOR SessionEntryFields[] =
    {
        SMBCE_ENTRY_FIELDS(SMBCEDB_SESSION_ENTRY)
        FIELD3(FieldTypePointer,SMBCEDB_SESSION_ENTRY,pServerEntry),
        FIELD3(FieldTypePointer,SMBCEDB_SESSION_ENTRY,pServerEntry),
        FIELD3(FieldTypeStruct,SMBCEDB_SESSION_ENTRY,Session),
        0
    };

FIELD_DESCRIPTOR NetRootEntryFields[] =
    {
        SMBCE_ENTRY_FIELDS(SMBCEDB_NET_ROOT_ENTRY)
        FIELD3(FieldTypeUnicodeString,SMBCEDB_NET_ROOT_ENTRY,Name),
        FIELD3(FieldTypePointer,SMBCEDB_NET_ROOT_ENTRY,pServerEntry),
        FIELD3(FieldTypePointer,SMBCEDB_NET_ROOT_ENTRY,pRdbssNetRoot),
        FIELD3(FieldTypeStruct,SMBCEDB_NET_ROOT_ENTRY,NetRoot),
        FIELD3(FieldTypeULong,SMBCEDB_NET_ROOT_ENTRY,NetRoot.sCscRootInfo.hShare),
        FIELD3(FieldTypeULong,SMBCEDB_NET_ROOT_ENTRY,NetRoot.sCscRootInfo.hRootDir),
        FIELD3(FieldTypeChar,SMBCEDB_NET_ROOT_ENTRY,NetRoot.CscEnabled),
        FIELD3(FieldTypeChar,SMBCEDB_NET_ROOT_ENTRY,NetRoot.CscShadowable),
        FIELD3(FieldTypeChar,SMBCEDB_NET_ROOT_ENTRY,NetRoot.Disconnected),
        0
    };

FIELD_DESCRIPTOR VNetRootContextFields[] =
    {
        SMBCE_ENTRY_FIELDS(SMBCE_V_NET_ROOT_CONTEXT)
        FIELD3(FieldTypePointer,SMBCE_V_NET_ROOT_CONTEXT,pRdbssVNetRoot),
        FIELD3(FieldTypePointer,SMBCE_V_NET_ROOT_CONTEXT,pServerEntry),
        FIELD3(FieldTypePointer,SMBCE_V_NET_ROOT_CONTEXT,pSessionEntry),
        FIELD3(FieldTypePointer,SMBCE_V_NET_ROOT_CONTEXT,pNetRootEntry),
        FIELD3(FieldTypeUShort,SMBCE_V_NET_ROOT_CONTEXT,Flags),
        FIELD3(FieldTypeULong,SMBCE_V_NET_ROOT_CONTEXT,TreeId),
        0
    };

FIELD_DESCRIPTOR ServerTransportFields[] =
    {
        FIELD3(FieldTypePointer,SMBCE_SERVER_TRANSPORT,pDispatchVector),
        FIELD3(FieldTypePointer,SMBCE_SERVER_TRANSPORT,pTransport),
        FIELD3(FieldTypeULong,SMBCE_SERVER_TRANSPORT,MaximumSendSize),
        0
    };

FIELD_DESCRIPTOR TransportFields[] =
    {
        FIELD3(FieldTypeStruct,SMBCE_TRANSPORT,RxCeTransport),
        FIELD3(FieldTypeStruct,SMBCE_TRANSPORT,RxCeAddress),
        FIELD3(FieldTypeULong,SMBCE_TRANSPORT,Priority),
        0
    };

#define EXCHANGE_FIELDS(__TYPE__) \
      FIELD3(FieldTypePointer,__TYPE__,RxContext),  \
      FIELD3(FieldTypePointer,__TYPE__,SmbCeContext.pServerEntry),  \
      FIELD3(FieldTypeULong,__TYPE__,Status),       \
      FIELD3(FieldTypeULong,__TYPE__,SmbStatus),    \
      FIELD3(FieldTypeUShort,__TYPE__,SmbCeState),    \
      FIELD3(FieldTypeULong,__TYPE__,SmbCeFlags),   \
      FIELD3(FieldTypeStruct,__TYPE__,WorkQueueItem),



FIELD_DESCRIPTOR OrdinaryExchangeFields[] =
   {
      EXCHANGE_FIELDS(SMB_PSE_ORDINARY_EXCHANGE)
      FIELD3(FieldTypePointer,SMB_PSE_ORDINARY_EXCHANGE,StufferStateDbgPtr),
      FIELD3(FieldTypePointer,SMB_PSE_ORDINARY_EXCHANGE,DataPartialMdl),
      FIELD3(FieldTypeChar,SMB_PSE_ORDINARY_EXCHANGE,OpSpecificFlags),
      FIELD3(FieldTypeChar,SMB_PSE_ORDINARY_EXCHANGE,OpSpecificState),
      FIELD3(FieldTypeStruct,SMB_PSE_ORDINARY_EXCHANGE,ParseResumeState),
      FIELD3(FieldTypeUShortFlags,SMB_PSE_ORDINARY_EXCHANGE,Flags),
      FIELD3(FieldTypeULong,SMB_PSE_ORDINARY_EXCHANGE,MessageLength),
      FIELD3(FieldTypeSymbol,SMB_PSE_ORDINARY_EXCHANGE,ContinuationRoutine),
      FIELD3(FieldTypeULong,SMB_PSE_ORDINARY_EXCHANGE,StartEntryCount),
      FIELD3(FieldTypePointer,SMB_PSE_ORDINARY_EXCHANGE,AsyncResumptionRoutine),
      FIELD3(FieldTypeStruct,SMB_PSE_ORDINARY_EXCHANGE,ReadWrite),
      FIELD3(FieldTypeStruct,SMB_PSE_ORDINARY_EXCHANGE,AssociatedStufferState),
      0
   };

FIELD_DESCRIPTOR TransactExchangeFields[] =
   {
      EXCHANGE_FIELDS(SMB_TRANSACT_EXCHANGE)
      0
   };

typedef struct _ZZEXCHANGE {
    SMB_EXCHANGE;
} ZZEXCHANGE, *PZZEXCHANGE;

FIELD_DESCRIPTOR GeneralExchangeFields[] =
   {
      EXCHANGE_FIELDS(ZZEXCHANGE)
      0
   };


typedef struct _ZZSMB_HEADER {
    union {
        SMB_HEADER;
        NT_SMB_HEADER Nt;
    };
} ZZSMB_HEADER, *PZZSMB_HEADER;

FIELD_DESCRIPTOR SmbHeaderFields[] =
   {
      FIELD3(FieldTypeByte,ZZSMB_HEADER,Command),
      FIELD3(FieldTypeByte,ZZSMB_HEADER,ErrorClass),
      FIELD3(FieldTypeUShortUnaligned,ZZSMB_HEADER,Error),
      FIELD3(FieldTypeULongUnaligned,ZZSMB_HEADER,Nt.Status.NtStatus),
      FIELD3(FieldTypeByte,ZZSMB_HEADER,Flags),
      FIELD3(FieldTypeUShortUnaligned,ZZSMB_HEADER,Flags2),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,PidHigh),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,Pid),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,Tid),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,Uid),
      FIELD3(FieldTypeUShort,ZZSMB_HEADER,Mid),
      0
   };




FIELD_DESCRIPTOR StufferStateFields[] =
   {
      FIELD3(FieldTypeChar,SMBSTUFFER_BUFFER_STATE,SpecificProblem),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,RxContext),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,Exchange),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,HeaderMdl),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,HeaderPartialMdl),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,ActualBufferBase),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,BufferBase),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,BufferLimit),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,DataMdl),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,CurrentPosition),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,CurrentWct),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,CurrentBcc),
      FIELD3(FieldTypePointer,SMBSTUFFER_BUFFER_STATE,CurrentDataOffset),
      FIELD3(FieldTypeChar,SMBSTUFFER_BUFFER_STATE,PreviousCommand),
      FIELD3(FieldTypeChar,SMBSTUFFER_BUFFER_STATE,CurrentCommand),
      FIELD3(FieldTypeULong,SMBSTUFFER_BUFFER_STATE,FlagsCopy),
      FIELD3(FieldTypeULong,SMBSTUFFER_BUFFER_STATE,Flags2Copy),
      FIELD3(FieldTypeULong,SMBSTUFFER_BUFFER_STATE,DataSize),
      FIELD3(FieldTypeChar,SMBSTUFFER_BUFFER_STATE,Started),
      0
   };

//this enum is used in the definition of the structures that can be dumped....the order here
//is not important, only that there is a definition for each dumpee structure.....

typedef enum _STRUCTURE_IDS {
    StrEnum_RX_CONTEXT = 1,
    StrEnum_FCB,
    StrEnum_SRV_OPEN,
    StrEnum_FOBX,
    StrEnum_SRV_CALL,
    StrEnum_NET_ROOT,
    StrEnum_V_NET_ROOT,
    StrEnum_SMBCEDB_SERVER_ENTRY,
    StrEnum_SMBCEDB_SESSION_ENTRY,
    StrEnum_SMBCEDB_NET_ROOT_ENTRY,
    StrEnum_SMB_PSE_ORDINARY_EXCHANGE,
    StrEnum_SMB_TRANSACT_EXCHANGE,
    StrEnum_ZZEXCHANGE,
    StrEnum_SMBSTUFFER_BUFFER_STATE,
    StrEnum_SMBCE_TRANSPORT,
    StrEnum_SMBCE_SERVER_TRANSPORT,
    StrEnum_ZZSMB_HEADER,
    StrEnum_RX_FCB_TABLE_ENTRY,
    StrEnum_RX_FCB_TABLE,
    StrEnum_last
};


//
// List of structs currently handled by the debugger extensions
//

STRUCT_DESCRIPTOR Structs[] =
   {
       STRUCT(RX_CONTEXT,RxContextFields,0xffff,RDBSS_NTC_RX_CONTEXT),
       STRUCT(FCB,FcbFields,0xeff0,RDBSS_STORAGE_NTC(0)),
       STRUCT(FCB,FcbFields,0xeff0,RDBSS_STORAGE_NTC(0xf0)),
       STRUCT(SRV_OPEN,SrvOpenFields,0xffff,RDBSS_NTC_SRVOPEN),
       STRUCT(FOBX,FobxFields,0xffff,RDBSS_NTC_FOBX),
       STRUCT(SRV_CALL,SrvCallFields,0xffff,RDBSS_NTC_SRVCALL),
       STRUCT(NET_ROOT,NetRootFields,0xffff,RDBSS_NTC_NETROOT),
       STRUCT(V_NET_ROOT,VNetRootFields,0xffff,RDBSS_NTC_V_NETROOT),
       STRUCT(SMBCEDB_SERVER_ENTRY,ServerEntryFields,0xffff,SMB_CONNECTION_ENGINE_NTC(SMBCEDB_OT_SERVER)),
       STRUCT(SMBCEDB_SESSION_ENTRY,SessionEntryFields,0xffff,SMB_CONNECTION_ENGINE_NTC(SMBCEDB_OT_SESSION)),
       STRUCT(SMBCEDB_NET_ROOT_ENTRY,NetRootEntryFields,0xffff,SMB_CONNECTION_ENGINE_NTC(SMBCEDB_OT_NETROOT)),
       STRUCT(SMB_PSE_ORDINARY_EXCHANGE,OrdinaryExchangeFields,0xffff,SMB_EXCHANGE_NTC(ORDINARY_EXCHANGE)),
       STRUCT(SMB_TRANSACT_EXCHANGE,TransactExchangeFields,0xffff,SMB_EXCHANGE_NTC(TRANSACT_EXCHANGE)),
       STRUCT(ZZEXCHANGE,GeneralExchangeFields,0xfff0,SMB_EXCHANGE_NTC(0)),
       STRUCT(SMBSTUFFER_BUFFER_STATE,StufferStateFields,0xffff,SMB_NTC_STUFFERSTATE),
       STRUCT(SMBCE_TRANSPORT,TransportFields,0x0,0xffff),
       STRUCT(SMBCE_SERVER_TRANSPORT,ServerTransportFields,0x0,0xffff),
       STRUCT(ZZSMB_HEADER,SmbHeaderFields,0x0,0xffff),
       STRUCT(RX_FCB_TABLE_ENTRY,FcbTableEntry,0xffff,RDBSS_NTC_FCB_TABLE_ENTRY),
       STRUCT(RX_FCB_TABLE,FcbTable,0xffff,RDBSS_NTC_FCB_TABLE),
       0
   };


ULONG_PTR FieldOffsetOfContextListEntryInRxC(){ return FIELD_OFFSET(RX_CONTEXT,ContextListEntry);}


PCWSTR   GetExtensionLibPerDebugeeArchitecture(ULONG DebugeeArchitecture){
    switch (DebugeeArchitecture) {
    case RX_PROCESSOR_ARCHITECTURE_INTEL:
        return L"kdextx86.dll";
    case RX_PROCESSOR_ARCHITECTURE_MIPS:
        return L"kdextmip.dll";
    case RX_PROCESSOR_ARCHITECTURE_ALPHA:
        return L"kdextalp.dll";
    case RX_PROCESSOR_ARCHITECTURE_PPC:
        return L"kdextppc.dll";
    default:
        return(NULL);
    }
}

//CODE.IMPROVEMENT it is ineficient to try to structure along the lines of "this routine knows
//                 rxstructures" versus "this routine knows debugger extensions". also we
//                 need a precomp.h

BOOLEAN wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, IN PSZ type);
VOID  ReadRxContextFields(ULONG_PTR RxContext,PULONG_PTR pFcb,PULONG_PTR pThread, PULONG_PTR pMiniCtx2)
{
    RX_CONTEXT RxContextBuffer;
    if (!wGetData(RxContext,&RxContextBuffer,sizeof(RxContextBuffer),"RxContextFieldss")) return;
    *pFcb = (ULONG_PTR)(RxContextBuffer.pFcb);
    *pThread = (ULONG_PTR)(RxContextBuffer.LastExecutionThread);
    *pMiniCtx2 = (ULONG_PTR)(RxContextBuffer.MRxContext[2]);
}


FOLLOWON_HELPER_RETURNS
__FollowOnError (
    OUT    PBYTE Buffer2,
    IN     PBYTE followontext,
    ULONG LastId,
    ULONG Index)
{
    if (LastId==0) {
        sprintf(Buffer2,"Cant dump a %s. no previous dump.\n",
                 followontext,Index);
    } else {
        sprintf(Buffer2,"Cant dump a %s from a %s\n",
                 followontext,Structs[Index].StructName);
    }
    return(FOLLOWONHELPER_ERROR);
}
#define FollowOnError(A) (__FollowOnError(Buffer2,A,p->IdOfLastDump,p->IndexOfLastDump))

VOID dprintfsprintfbuffer(BYTE *Buffer);


DECLARE_FOLLOWON_HELPER_CALLEE(FcbFollowOn)
{
    //BYTE DbgBuf[200];
    //sprintf(DbgBuf,"top p,id=%08lx,%d",p,p->IdOfLastDump);
    //dprintfsprintfbuffer(DbgBuf);

    switch (p->IdOfLastDump) {
    case StrEnum_RX_CONTEXT:{
        PRX_CONTEXT RxContext = (PRX_CONTEXT)(&p->StructDumpBuffer[0]);
        sprintf(Buffer2," %08p\n",RxContext->pFcb);
        return(FOLLOWONHELPER_DUMP);
        }
        break;
    default:
        return FollowOnError("irp");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\inc\ntumrefl.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ntumrefl.h

Abstract:

    This module defines the types and functions which make up the reflector
    library. These functions are used by the miniredirs to reflect calls upto
    the user mode.

Author:

    Andy Herron (andyhe)

--*/

#ifndef _NTUMREFL_H
#define _NTUMREFL_H

//
//  These two structures are opaque to callers of the reflector library but
//  we'll define them here to make the compiler validate the types sent in.
//

typedef struct _UMRX_USERMODE_REFLECT_BLOCK *PUMRX_USERMODE_REFLECT_BLOCK;
typedef struct _UMRX_USERMODE_WORKER_INSTANCE *PUMRX_USERMODE_WORKER_INSTANCE;

//
//  These structures and function prototypes are for the user mode reflector.
//

#define UMREFLECTOR_CURRENT_VERSION 1

//
// This structure will be exposed to both user and kernel mode components.
//
#define UMRX_WORKITEM_IMPERSONATING 0X00000001
typedef struct _UMRX_USERMODE_WORKITEM_HEADER {

    //
    // The kernel mode component stores the context in here.
    //
    PVOID Context;

    //
    // The kernel mode context uses the serial number to keep track of the
    // number of requests.
    //
    ULONG SerialNumber;

    //
    // This allows the kernel mode component of the reflector library to track
    // request to response. If this is zero, then no response is present in the
    // workitem.
    //
    USHORT WorkItemMID;

    //
    // Length of the workitem.
    //
    ULONG WorkItemLength;

    //
    // Flags describing the state of the request.
    //
    ULONG Flags;

    BOOL callWorkItemCleanup;

    union {
        IO_STATUS_BLOCK IoStatus;
        IO_STATUS_BLOCK;
    };

} UMRX_USERMODE_WORKITEM_HEADER, *PUMRX_USERMODE_WORKITEM_HEADER;

//
// The structure that is sent down to the usermode when starting the 
// DAV MiniRedir.
//
typedef struct _DAV_USERMODE_DATA {

    //
    // The ProcessId of the svchost.exe process that is loading the webclnt.dll
    //
    ULONG ProcessId;

    //
    // The WinInet's Cache Path.
    //
    WCHAR WinInetCachePath[MAX_PATH];

} DAV_USERMODE_DATA, *PDAV_USERMODE_DATA;

//
// This routine registers the user mode process with the kernel mode component.
// The DriverDeviceName must be a valid name of the form L"\\Device\\foobar"
// where foobar is the device name registered with RxRegisterMinirdr. The 
// Reflector is returned by the call and points to an opaque structure that
// should be passed to subsequent calls. This structure gets initialized during
// this call. The return value is a Win32 error code. STATUS_SUCCESS is 
// returned on success.
//
ULONG
UMReflectorRegister (
    PWCHAR DriverDeviceName,
    ULONG ReflectorVersion,
    PUMRX_USERMODE_REFLECT_BLOCK *Reflector
    );

//
// This will close down the associated user mode reflector instance. If any user
// mode threads are waiting for requests, they'll return immediately.  This call
// will not return until all threads are closed down and all associated
// structures are freed.  A user application should not use the Reflector after
// this call has been started except to complete work on a request that is
// pending.
//
ULONG
UMReflectorUnregister(
    PUMRX_USERMODE_REFLECT_BLOCK Reflector
    );

//
// We have instance handles for those apps with multiple threads pending in
// the library at once. You should open an instance thread for each worker
// thread you'll have sending down an IOCTL waiting for work.
//
ULONG
UMReflectorOpenWorker(
    PUMRX_USERMODE_REFLECT_BLOCK ReflectorHandle,
    PUMRX_USERMODE_WORKER_INSTANCE *WorkerHandle
    );

//
// Even after calling UMReflectorUnregister, you should still call
// UMReflectorCloseWorker on each worker handle instance you have open.
//
VOID
UMReflectorCloseWorker(
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle
    );

//
// This starts the Mini-Redir.
//
ULONG
UMReflectorStart(
    ULONG ReflectorVersion,
    PUMRX_USERMODE_REFLECT_BLOCK ReflectorHandle
    );

//
// This stops the Mini-Redir.
//
ULONG
UMReflectorStop(
    PUMRX_USERMODE_REFLECT_BLOCK ReflectorHandle
    );

//
// If any user mode threads are waiting for requests, they'll return
// immediately.
//
ULONG
UMReflectorReleaseThreads(
    PUMRX_USERMODE_REFLECT_BLOCK ReflectorHandle
    );

//
// This allocates a work item that may have additional space below it for
// Mini-Redir specific information. It should be freed using
// ReflectorCompleteWorkItem below.
//
PUMRX_USERMODE_WORKITEM_HEADER
UMReflectorAllocateWorkItem(
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    ULONG AdditionalBytes
    );

//
// This may free the work item.  It may unmap and possibly free both the user
// and kernel mode associated buffers.  If a kernel mode associated buffer is
// stored in this WorkItem, the WorkItem will be posted back to the kernel mode
// process for freeing.  Once the call to ReflectorCompleteWorkItem is called,
// the WorkItem should not be touched by the calling application.
//
ULONG
UMReflectorCompleteWorkItem(
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItem
    );

//
// This user mode thread is requesting a client request to work on. It will not
// return until the kernel portion of the library has a request to send up to
// user mode. If the PreviousWorkItem is not NULL, then this work item contains
// a response that will be sent down to the kernel. This eliminates a transition
// for the typical case of a worker thread returning a result and then asking
// for another work item.
//
ULONG
UMReflectorGetRequest (
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    PUMRX_USERMODE_WORKITEM_HEADER ResponseWorkItem OPTIONAL,
    PUMRX_USERMODE_WORKITEM_HEADER ReceiveWorkItem,
    BOOL revertAlreadyDone
    );

//
// A response is sent down to kernel mode due to an action in user mode being
// completed. The kernel mode library does not get another request for this
// thread. Both the request and response buffers associated with the WorkItem
// will be unmapped/unlocked/freed (when the library has done the
// allocating/locking/mapping).
//
ULONG
UMReflectorSendResponse(
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItem
    );

ULONG
UMReflectorImpersonate(
    PUMRX_USERMODE_WORKITEM_HEADER IncomingWorkItem,
    HANDLE ImpersonationToken
    );

ULONG
UMReflectorRevert (
    PUMRX_USERMODE_WORKITEM_HEADER IncomingWorkItem
    );

//
//  If the user mode side needs to allocate memory in the shared memory
//  area, it can do so using these calls.  Note that if the memory isn't
//  freed up by the caller, it will be freed when the kernel mode async work
//  context is freed.
//
ULONG
UMReflectorAllocateSharedMemory(
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItem,
    SIZE_T  SizeRequired,
    PVOID *SharedBuffer
    );

ULONG
UMReflectorFreeSharedMemory(
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItem,
    PVOID SharedBuffer
    );

VOID
UMReflectorCompleteRequest(
    PUMRX_USERMODE_REFLECT_BLOCK ReflectorHandle,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader
    );

VOID
DavCleanupWorkItem(
    PUMRX_USERMODE_WORKITEM_HEADER UserWorkItem
    );

//
// The control codes specific to the reflector library.
//
#define IOCTL_UMRX_RELEASE_THREADS           \
                     _RDR_CONTROL_CODE(222, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_UMRX_GET_REQUEST               \
                     _RDR_CONTROL_CODE(223, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define IOCTL_UMRX_RESPONSE_AND_REQUEST      \
                     _RDR_CONTROL_CODE(224, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define IOCTL_UMRX_RESPONSE                  \
                     _RDR_CONTROL_CODE(225, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define FSCTL_UMRX_START                     \
                    _RDR_CONTROL_CODE(226, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_UMRX_STOP                      \
                    _RDR_CONTROL_CODE(227, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif // _NTUMREFL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\dav2kd\kdextlib.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    kdextlib.h

Abstract:

    Redirector Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#ifndef _KDEXTLIB_H_
#define _KDEXTLIB_H_

//#include <windef.h>

//
// The FIELD_DESCRIPTOR data structure is used to describe the field in a structure sufficiently
// for displaying information during debugging. The three pieces of information that are required
// are 1) the name of the field, 2) the offset in the corresponding structure and 3) a type descriptor.
// The type descriptor covers most primitive types.
//
// The task of generating these descriptors by augmenting the front end, but that will have to
// wait till we play around with these extensions and modify the data structures to meet most
// of the requirements.
//
// There are some types that can benefit from some auxillary information in the descriptors. A
// case in point is the "enum" defeinition. Merely printing out a numerical value for an enum
// type will invariably force the person using these extensions to refer to the corresponding
// include file. In order to avoid this we will accept an additional array for enum types that
// contains a textual description of the numerical value.
//
// There are certain conventions that have been adopted to ease the definition of the macros
// as well as facilitate the automation of the generation of these descriptors.
// These are as follows ....
//
// 1) All ENUM_VALUE_DESCRIPTOR definitions are named EnumValueDescrsOf_ENUMTYPENAME, where
// ENUMTYPENAME defines the corresponding enumerated type.
//

typedef struct _ENUM_VALUE_DESCRIPTOR {
    ULONG   EnumValue;
    LPSTR   EnumName;
} ENUM_VALUE_DESCRIPTOR;

typedef enum _FIELD_TYPE_CLASS {
    FieldTypeByte,
    FieldTypeChar,
    FieldTypeBoolean,
    FieldTypeBool,
    FieldTypeULong,
    FieldTypeULongUnaligned,
    FieldTypeULongFlags,
    FieldTypeLong,
    FieldTypeLongUnaligned,
    FieldTypeUShort,
    FieldTypeUShortUnaligned,
    FieldTypeUShortFlags,
    FieldTypeShort,
    FieldTypePointer,
    FieldTypeUnicodeString,
    FieldTypeAnsiString,
    FieldTypeSymbol,
    FieldTypeEnum,
    FieldTypeByteBitMask,
    FieldTypeWordBitMask,
    FieldTypeDWordBitMask,
    FieldTypeFloat,
    FieldTypeDouble,
    FieldTypeStruct,
    FieldTypeLargeInteger,
    FieldTypeFileTime
} FIELD_TYPE_CLASS, *PFIELD_TYPE_CLASS;

typedef struct _FIELD_DESCRIPTOR_ {
    FIELD_TYPE_CLASS FieldType;   // The type of variable to be printed
    LPSTR            Name;        // The name of the field
    //USHORT           Offset;      // The offset of the field in the structure
    LONG             Offset;      // The offset of the field in the structure
    union {
        ENUM_VALUE_DESCRIPTOR  *pEnumValueDescriptor; // Auxillary information for enumerated types.
    } AuxillaryInfo;
} FIELD_DESCRIPTOR;

#define FIELD3(FieldType,StructureName, FieldName) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,NULL}

#define FIELD4(FieldType, StructureName, FieldName, AuxInfo) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,AuxInfo}

//
// The structs that are displayed by the debugger extensions are further
// described in another array. Each entry in the array contains the name of
// the structure and the associated Field descriptor list.
//

typedef struct _STRUCT_DESCRIPTOR_ {
    LPSTR 	          StructName;
    ULONG             StructSize;
    ULONG             EnumManifest;
    FIELD_DESCRIPTOR  *FieldDescriptors;
    USHORT            MatchMask;
    USHORT            MatchValue;
} STRUCT_DESCRIPTOR;

#define STRUCT(StructTypeName,FieldDescriptors,MatchMask,MatchValue) \
        { #StructTypeName,sizeof(StructTypeName), \
          StrEnum_##StructTypeName,               \
          FieldDescriptors,MatchMask,MatchValue}

//
//  The array of structs handled by the debugger extension.
//

extern STRUCT_DESCRIPTOR Structs[];

//
// Support for displaying global variables
//

extern LPSTR GlobalBool[];
extern LPSTR GlobalShort[];
extern LPSTR GlobalLong[];
extern LPSTR GlobalPtrs[];

#endif // _KDEXTLIB_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\dav2kd\strucsup.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    strucsup.c

Abstract:

    Library routines for dumping data structures given a meta level descrioption

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#include "rxovride.h" //common compile flags
#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <dav2kd.h>

#include <ntrxdef.h>
#include <rxtypes.h>
#include <rxlog.h>

//need this for unaligned smbget macros
#include <smbgtpt.h>

extern WINDBG_EXTENSION_APIS ExtensionApis;
//EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf
#define    PRINTF     dprintf

#define    NL      1
#define    NONL    0

BOOLEAN
wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, IN PSZ type);

//
// No. of columns used to display struct fields;
//

ULONG s_MaxNoOfColumns = 3;
#ifndef RXKD_2col
ULONG s_NoOfColumns = 1;
#else
ULONG s_NoOfColumns = 2;
#endif

/*
 * Displays all the fields of a given struct. This is the driver routine that is called
 * with the appropriate descriptor array to display all the fields in a given struct.
 */

char *NewLine  = "\n";
char *FieldSeparator = " ";
#define NewLineForFields(FieldNo) \
        ((((FieldNo) % s_NoOfColumns) == 0) ? NewLine : FieldSeparator)
#define FIELD_NAME_LENGTH 30

/*
 * Print out an optional message, a UNICODE_STRING, and maybe a new-line
 */
BOOL
wPrintStringU( IN LPSTR PrefixMsg OPTIONAL, IN PUNICODE_STRING puStr, IN LPSTR SuffixMsg OPTIONAL )
{
    PWCHAR    StringData;
    UNICODE_STRING UnicodeString;
    ULONG BytesRead;

    if (PrefixMsg == NULL) {
        PrefixMsg = "";
    }
    if (SuffixMsg == NULL) {
        SuffixMsg = "";
    }

    StringData = (PWCHAR)LocalAlloc( LPTR, puStr->Length + sizeof(UNICODE_NULL));
    if( StringData == NULL ) {
        dprintf( "Out of memory!\n" );
        return FALSE;
    }
    UnicodeString.Buffer =  StringData; //puStr->Buffer;
    UnicodeString.Length =  puStr->Length;
    UnicodeString.MaximumLength =  puStr->MaximumLength;

    ReadMemory( (ULONG_PTR)puStr->Buffer,
               StringData,
               puStr->Length,
               &BytesRead);

    if (BytesRead)  {
        dprintf("%s%wZ%s", PrefixMsg, &UnicodeString, SuffixMsg );
    } else {
        dprintf("MEMORYREAD FAILED %s%s",PrefixMsg,SuffixMsg);
    }

    LocalFree( (HLOCAL)StringData );

    return BytesRead;
}

VOID
SetFlagString(
    ULONG Value,
    PCHAR FlagString
    )
{
    ULONG i,t,mask;
    *FlagString = '('; FlagString++;
    for (i=t=0,mask=1;i<32;i++,mask<<=1) {
        //PRINTF("hithere %08lx %08lx %08lx\n",Value,mask,i);
        if (i==t+10) {
            *FlagString = ':'; FlagString++;
            t=t+10;
        }
        if (Value&mask) {
            *FlagString = '0'+(UCHAR)(i-t); FlagString++;
        }
    }

    *FlagString = ')'; FlagString++;
    *FlagString = 0;
}

VOID
PrintStructFields( ULONG_PTR dwAddress, VOID *ptr, FIELD_DESCRIPTOR *pFieldDescriptors )
{
    int i;

    // Display the fields in the struct.
    for( i=0; pFieldDescriptors->Name; i++, pFieldDescriptors++ ) {

        // Indentation to begin the struct display.
        PRINTF( "    " );

        if( strlen( pFieldDescriptors->Name ) > FIELD_NAME_LENGTH ) {
            PRINTF( "%-17s...%s ", pFieldDescriptors->Name, pFieldDescriptors->Name+strlen(pFieldDescriptors->Name)-10 );
        } else {
            PRINTF( "%-30s ", pFieldDescriptors->Name );
        }

        switch( pFieldDescriptors->FieldType ) {
        case FieldTypeByte:
        case FieldTypeChar:
           PRINTF( "%-16X%s",
               *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ),
               NewLineForFields(i) );
           break;
        case FieldTypeBoolean:
           PRINTF( "%-16s%s",
               *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
               NewLineForFields(i));
           break;
        case FieldTypeBool:
            PRINTF( "%-16s%s",
                *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
                NewLineForFields(i));
            break;
        case FieldTypePointer:
            PRINTF( "%-16X%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeULong:
        case FieldTypeLong:
            PRINTF( "%-16X%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeULongUnaligned:
        case FieldTypeLongUnaligned:
            PRINTF( "%-16X%s",
                SmbGetUlong( (BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ) ),
                NewLineForFields(i) );
            break;
        case FieldTypeShort:
            PRINTF( "%-16X%s",
                *(SHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeUShort:
            PRINTF( "%-16X%s",
                *(USHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeUShortUnaligned:
            PRINTF( "%-16X%s",
                SmbGetUshort( (BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ) ),
                NewLineForFields(i) );
            break;
        case FieldTypeULongFlags:{ULONG Value; char FlagString[60];
            Value = *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset );
            SetFlagString(Value,FlagString);
            PRINTF( "%-16X%s%s", Value, FlagString,
                NewLineForFields(i) );
            break;}
        case FieldTypeUShortFlags:{USHORT Value; char FlagString[60];
            Value = *(USHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
            SetFlagString(Value,FlagString);
            PRINTF( "%-16X%s%s", Value, FlagString,
                NewLineForFields(i) );
            break;}
        case FieldTypeUnicodeString:
            wPrintStringU( NULL, (UNICODE_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), NULL );
            PRINTF( NewLine );
            break;
        //case FieldTypeAnsiString:
        //    //PrintStringA( NULL, (ANSI_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), NONL );
        //    //PRINTF( NewLine );
        //    PRINTF( NewLine );
        //    break;
        case FieldTypeSymbol:
            {
                UCHAR SymbolName[ 200 ];
                ULONG_PTR Displacement;
                PVOID sym = (PVOID)(*(ULONG_PTR *)(((char *)ptr) + pFieldDescriptors->Offset ));

                GetSymbol( sym, SymbolName, &Displacement );
                PRINTF( "%-16s%s",
                        SymbolName,
                        NewLineForFields(i) );
            }
            break;
        case FieldTypeEnum:
            {
               ULONG EnumValue;
               ENUM_VALUE_DESCRIPTOR *pEnumValueDescr;
               // Get the associated numericla value.

               EnumValue = *((ULONG *)((BYTE *)ptr + pFieldDescriptors->Offset));

               if ((pEnumValueDescr = pFieldDescriptors->AuxillaryInfo.pEnumValueDescriptor)
                    != NULL) {
                   //
                   // An auxilary textual description of the value is
                   // available. Display it instead of the numerical value.
                   //

                   LPSTR pEnumName = NULL;

                   while (pEnumValueDescr->EnumName != NULL) {
                       if (EnumValue == pEnumValueDescr->EnumValue) {
                           pEnumName = pEnumValueDescr->EnumName;
                           break;
                       }
                   }

                   if (pEnumName != NULL) {
                       PRINTF( "%-16s ", pEnumName );
                   } else {
                       PRINTF( "%-4d (%-10s) ", EnumValue,"@$#%^&*");
                   }

               } else {
                   //
                   // No auxilary information is associated with the ehumerated type
                   // print the numerical value.
                   //
                   PRINTF( "%-16d",EnumValue);
               }
            }
            break;
        case FieldTypeStruct:
            PRINTF( "@%-15X%s",
                (dwAddress + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeLargeInteger:
        case FieldTypeFileTime:
        default:
            ERRPRT( "Unrecognized field type %c for %s\n", pFieldDescriptors->FieldType, pFieldDescriptors->Name );
            break;
        }
    }
}

DECLARE_API( columns )
{
    ULONG NoOfColumns;
    int   i;

    //SETCALLBACKS();

    //sscanf(lpArgumentString,"%ld",&NoOfColumns);
    sscanf(args,"%ld",&NoOfColumns);

    if (NoOfColumns > s_MaxNoOfColumns) {
        // PRINTF( "No. Of Columns exceeds maximum(%ld) -- directive Ignored\n", s_MaxNoOfColumns );
    } else {
        s_NoOfColumns = NoOfColumns;
    }

    PRINTF("Not Yet Implemented\n");

    return;
}

#define NAME_DELIMITER '@'
#define NAME_DELIMITERS "@"
#define INVALID_INDEX 0xffffffff
#define MIN(x,y)  ((x) < (y) ? (x) : (y))

ULONG SearchStructs(LPSTR lpArgument)
{
    ULONG             i = 0;
    STRUCT_DESCRIPTOR *pStructs = Structs;
    ULONG             NameIndex = INVALID_INDEX;
    ULONG             ArgumentLength = strlen(lpArgument);
    BOOLEAN           fAmbigous = FALSE;


    while ((pStructs->StructName != 0)) {
        int Result = _strnicmp(lpArgument,
                              pStructs->StructName,
                              MIN(strlen(pStructs->StructName),ArgumentLength));

        if (Result == 0) {
            if (NameIndex != INVALID_INDEX) {
                // We have encountered duplicate matches. Print out the
                // matching strings and let the user disambiguate.
               fAmbigous = TRUE;
               break;
            } else {
               NameIndex = i;
            }

        }
        pStructs++;i++;
    }

    if (fAmbigous) {
       PRINTF("Ambigous Name Specification -- The following structs match\n");
       PRINTF("%s\n",Structs[NameIndex].StructName);
       PRINTF("%s\n",Structs[i].StructName);
       while (pStructs->StructName != 0) {
           if (_strnicmp(lpArgument,
                        pStructs->StructName,
                        MIN(strlen(pStructs->StructName),ArgumentLength)) == 0) {
               PRINTF("%s\n",pStructs->StructName);
           }
           pStructs++;
       }
       PRINTF("Dumping Information for %s\n",Structs[NameIndex].StructName);
    }

    return(NameIndex);
}

VOID DisplayStructs()
{
    STRUCT_DESCRIPTOR *pStructs = Structs;

    PRINTF("The following structs are handled .... \n");
    while (pStructs->StructName != 0) {
        PRINTF("\t%s\n",pStructs->StructName);
        pStructs++;
    }
}

PPERSISTENT_RDR2KD_INFO
LocatePersistentInfoFromView()
/*
    the purpose of this routine is to allocate or find the named section that holds the
    data we expect to find across calls. the way that we make this persitent is that we
    do not close the handle used to create the view. it will go away when the process does.
*/
{
    BYTE SectionName[128];
    DWORD SectionSize;
    DWORD ProcessId;
    HANDLE h;
    BOOLEAN CreatedSection = FALSE;
    PPERSISTENT_RDR2KD_INFO p;

    ProcessId = GetCurrentProcessId();
    SectionSize = sizeof(PERSISTENT_RDR2KD_INFO);
    sprintf(SectionName,"Rdr2KdSection_%08lx",ProcessId);
    //PRINTF("sectionname=%s, size=%x\n",SectionName,SectionSize);

    h = OpenFileMappingA(
           FILE_MAP_WRITE, //DWORD  dwDesiredAccess,	// access mode
           FALSE,           //BOOL  bInheritHandle,	// inherit flag
           SectionName     //LPCTSTR  lpName 	// address of name of file-mapping object
           );

    if (h==NULL) {
        h = CreateFileMappingA(
                   (HANDLE)IntToPtr(0xFFFFFFFF), // HANDLE  hFile,	// handle of file to map
                    NULL,              //LPSECURITY_ATTRIBUTES  lpFileMappingAttributes,	// optional security attributes
                    PAGE_READWRITE,    //DWORD  flProtect,	// protection for mapping object
                    0,                 //DWORD  dwMaximumSizeHigh,	// high-order 32 bits of object size
                    SectionSize,       //DWORD  dwMaximumSizeLow,	// low-order 32 bits of object size
                    SectionName        //LPCTSTR  lpName 	// name of file-mapping object
                    );
        if (h==NULL) {
            return(FALSE);
        }
        CreatedSection = TRUE;
    }

    //now we have a filemapping....get a view.....
    p = MapViewOfFile(h,FILE_MAP_WRITE,0,0,0);
    if (p==NULL) {
        CloseHandle(h);
        return(NULL);
    }

    if (CreatedSection) {
        //zero the stuff that needs to be zeroed....
        ULONG i;
        p->IdOfLastDump = 0;
        for (i=0;i<100;i++) {
            p->LastAddressDumped[i] = 0;
        }
        p->OpenCount = 100;
    } else {
        CloseHandle(h);
        p->OpenCount++;
    }

    //PRINTF("Opencount for persistent section = %08lx\n",p->OpenCount);
    return(p);
}

VOID
FreePersistentInfoView (
    PPERSISTENT_RDR2KD_INFO p
    )
{
    UnmapViewOfFile(p);
}

VOID
DumpAStruct (
    ULONG_PTR dwAddress,
    STRUCT_DESCRIPTOR *pStruct
    )
{
    DWORD Index = (DWORD)(pStruct - Structs);
    DWORD SizeToRead = min(pStruct->StructSize,2048);
    PPERSISTENT_RDR2KD_INFO p;

    p = LocatePersistentInfoFromView();

    PRINTF("top @ %lx and %lx for %s(%d,%d)\n",dwAddress,p,pStruct->StructName,Index,p->IdOfLastDump);
    if (!p) {
        PRINTF("Couldn't allocate perstistent info buffer...sorry...\n");
        return;
    }

    if ((dwAddress==0) &&(Index<100)) {
        dwAddress = p->LastAddressDumped[Index];
        PRINTF("setting @ %lx and %lx for %s\n",dwAddress,p->LastAddressDumped[Index],pStruct->StructName);
    }

    if (wGetData(dwAddress,&p->StructDumpBuffer[0],SizeToRead,pStruct->StructName)) {

        p->LastAddressDumped[Index] = dwAddress;
        p->IdOfLastDump = pStruct->EnumManifest;
        p->IndexOfLastDump = Index;

        PRINTF("++++++++++++++++ %s(%d/%d)@%lx ---+++++++++++++\n",
            pStruct->StructName,
            p->IdOfLastDump,p->IndexOfLastDump,
            dwAddress);
        PrintStructFields(
            dwAddress,
            &p->StructDumpBuffer[0],
            pStruct->FieldDescriptors);
        PRINTF("---------------- %s@%lx ----------------\n",
            pStruct->StructName,
            dwAddress);
    }

    if (p!= NULL) FreePersistentInfoView(p);
    return;
}


DECLARE_API( dump )
{
    ULONG_PTR dwAddress;

    //SETCALLBACKS();

    if( args && *args ) {
        // Parse the argument string to determine the structure to be displayed.
        // Scan for the NAME_DELIMITER ( '@' ).

        LPSTR lpName = (PSTR)args;
        LPSTR lpArgs = strpbrk(args, NAME_DELIMITERS);
        ULONG Index;

        if (lpArgs) {
            //
            // The specified command is of the form
            // dump <name>@<address expr.>
            //
            // Locate the matching struct for the given name. In the case
            // of ambiguity we seek user intervention for disambiguation.
            //
            // We do an inplace modification of the argument string to
            // facilitate matching.
            //
            *lpArgs = '\0';

            for (;*lpName==' ';) { lpName++; } //skip leading blanks

            Index = SearchStructs(lpName);

            //
            // Let us restore the original value back.
            //

            *lpArgs = NAME_DELIMITER;

            if (INVALID_INDEX != Index) {
                BYTE DataBuffer[512];

                dwAddress = GetExpression( ++lpArgs );
                DumpAStruct(dwAddress,&Structs[Index]);
                //if (wGetData(dwAddress,DataBuffer,Structs[Index].StructSize,"..structure")) {
                //
                //    PRINTF(
                //        "++++++++++++++++ %s@%lx ++++++++++++++++\n",
                //        Structs[Index].StructName,
                //        dwAddress);
                //    PrintStructFields(
                //        dwAddress,
                //        &DataBuffer,
                //        Structs[Index].FieldDescriptors);
                //    PRINTF(
                //        "---------------- %s@%lx ----------------\n",
                //        Structs[Index].StructName,
                //        dwAddress);
                //} else {
                //    PRINTF("Error reading Memory @ %lx\n",dwAddress);
                //}
            } else {
                // No matching struct was found. Display the list of
                // structs currently handled.

                DisplayStructs();
            }
        } else {
#if 0
            //
            // The command is of the form
            // dump <name>
            //
            // Currently we do not handle this. In future we will map it to
            // the name of a global variable and display it if required.
            //

            DisplayStructs();
#endif
            //
            // here we try to figure out what to display based on the context....whoa, nellie!
            //
            USHORT Tag;
            STRUCT_DESCRIPTOR *pStructs = Structs;
            ULONG             NameIndex = INVALID_INDEX;
            BYTE DataBuffer[512];
            //ULONG             ArgumentLength = strlen(lpArgument);
            //BOOLEAN           fAmbigous = FALSE;



            dwAddress = GetExpression( args );
            if (!wGetData(dwAddress,&Tag,sizeof(Tag),"..structure TAG")) return;

            PRINTF("here's the tag: %04lx\n",Tag);

            //look thru the table for matching structs

            while ((pStructs->StructName != 0)) {
                int Result = (Tag&pStructs->MatchMask)==pStructs->MatchValue;

                if (Result != 0) {

                    DumpAStruct(dwAddress,pStructs);
                    break;
                }


                pStructs++;
            }

        }
    } else {
            DisplayStructs();
    }

    return;
}


DECLARE_API( ddd )
{
    dump( hCurrentProcess,
          hCurrentThread,
          dwCurrentPc,
          dwProcessor,
          args
          );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\dav2kd\wdbgxlib.c ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    wdbgxlib.c

Abstract:

    This module realizes most of the routines needed for the rdbss/smbmini debugger extension.

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:

Revision History:

    11-Nov-1994 SethuR  Created
    11-Nov-1995         Changed to newer windbg apis

--*/

#include "rxovride.h" //common compile flags
#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <dav2kd.h>

#include <ntrxdef.h>
#include <rxtypes.h>
#include <rxlog.h>


WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf

#define    NL      1
#define    NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?


/*
 * Print out an optional message, an ANSI_STRING, and maybe a new-line
 */
BOOL
wPrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl )
{
    PCHAR    StringData;
    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PCHAR)LocalAlloc( LPTR, pStr->Length + 1 );

    if( StringData == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory( (ULONG_PTR)pStr->Buffer,
               StringData,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        StringData[ pStr->Length ] = '\0';
        dprintf("%s%s", StringData, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)StringData);

    return BytesRead;
}

/*
 * Fetches the data at the given address
 */
BOOLEAN
wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, IN PSZ type)
{
    BOOL b;
    ULONG BytesRead;

    b = ReadMemory( dwAddress, ptr, size, &BytesRead );


    if (!b || BytesRead != size ) {
        dprintf( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
        return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the null terminated ASCII string at dwAddress into buf
 */
BOOL
wGetString( ULONG_PTR dwAddress, PSZ buf )
{
    for(;;) {
        if( !wGetData( dwAddress,buf, 1, "..stringfetch") ){
            //dprintf("readfailure at %08lx\n",dwAddress);
            return FALSE;
        }

        //dprintf ("stringing %08lx %08lx %c\n", dwAddress, buf,
        //                                     ((*buf==0)?'.':*buf) );

        if ( *buf == '\0' ) { break; }

        dwAddress++;
        buf++;

    };

    return TRUE;
}

#if 0
/*
 * Get 'size' bytes from the debuggee program at 'dwAddress' and place it
 * in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 */
BOOL
wGetData_srv( IN LPVOID ptr, IN ULONG_PTR dwAddress, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count;

    while( size > 0 ) {

        count = min( size, 3000 );

        b = ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count ) {
            ERRPRT( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG)ptr + count);
    }

    return TRUE;
}

/*
 * Follow a LIST_ENTRY list beginning with a head at dwListHeadAddr in the debugee's
 * address space.  For each element in the list, print out the pointer value at 'offset'
 */
BOOL
PrintListEntryList( IN ULONG_PTR dwListHeadAddr, IN LONG offset )
{
    LIST_ENTRY    ListEntry;
    ULONG i=0;
    BOOL retval = TRUE;
    ULONG count = 20;

    if( !wGetData_srv( &ListEntry, dwListHeadAddr, sizeof( ListEntry ), "LIST_ENTRY" ) )
        return FALSE;

    while( count-- ) {

        if( (ULONG_PTR)ListEntry.Flink == dwListHeadAddr || (ULONG_PTR)ListEntry.Flink == 0 )
            break;

        if( !wGetData_srv( &ListEntry, (ULONG_PTR)ListEntry.Flink, sizeof( ListEntry ), "ListEntry" ) ) {
            retval = FALSE;
            break;
        }

        dprintf( "%16X%s", (LONG)ListEntry.Flink + offset, (i && !(i&3)) ? "\n" : "" );
        i++;
    }


    if( count == 0 && (ULONG_PTR)ListEntry.Flink != dwListHeadAddr && ListEntry.Flink ) {
        dprintf( "\nTruncated list dump\n" );

    } else if( ! ( i && !(i&3) ) ) {
        dprintf( "\n" );
    }

    return retval;
}
#endif

/*
 * Print out a single HEX character
 */
VOID
wPrintHexChar( IN UCHAR c )
{
    dprintf( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Print out 'buf' of 'cbuf' bytes as HEX characters
 */
VOID
wPrintHexBuf( IN PUCHAR buf, IN ULONG cbuf )
{
    while( cbuf-- ) {
        wPrintHexChar( *buf++ );
        dprintf( " " );
    }
}

#if 0
/*
 * Fetch the null terminated UNICODE string at dwAddress into buf
 */
BOOL
GetString( IN ULONG_PTR dwAddress, IN LPWSTR buf, IN ULONG MaxChars )
{
    do {
        if( !wGetData_srv( buf, dwAddress, sizeof( *buf ), "UNICODE Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( --MaxChars && *buf++ != '\0' );

    return TRUE;
}
#endif

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s RDBSS+SMBmini Extension dll for Build %d debugging %s kernel for Build %d\n",
                    kind,
                    VER_PRODUCTBUILD,
                    SavedMajorVersion == 0x0c ? "Checked" : "Free",
                    SavedMinorVersion
    );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

LPSTR LibCommands[] = {
    "dump <Struct Type Name>@<address expr> ",
    "ddd <address expr> -- dump using context"
    "columns <d> -- controls the number of columns in the display ",
    "lg [<logentries>][@filename] -- dump the log",
    "gv -- dump out important variables",
    "activerx [fcbtomatch]-- dump the list of active contexts",
    "flags <value>-- print which flags are actually set (no text yet)",
    "cxr -- looks up cxr value from memory and does !cxr/!kb",
    "irp,thread,fcb,fobx,srvopen,exchange,stuff,smbbuf -- dumps the named item from the last dumpee",
    "version",
    0
};

DECLARE_API( help )
{
    int i;

    dprintf( "\nRDBSS debugger extensions:\n");

    for( i=0; LibCommands[i]; i++ )
        dprintf( "   %s\n", LibCommands[i] );
}


ULONG FieldOffsetOfContextListEntryInRxC();
VOID  ReadRxContextFields(ULONG_PTR RxContext,PULONG_PTR pFcb,PULONG_PTR pThread, PULONG_PTR pMiniCtx2);
DECLARE_API( dump );
DECLARE_API( activerx )
{
    //ULONG dwAddress;
    LIST_ENTRY LEbuffer;
    PLIST_ENTRY pRxActiveContexts,pListEntry;
    ULONG_PTR RxContext,CapturedFcb,LastThread,MinirdrCtx2;
    ULONG_PTR MatchFcb = 0x1badf00d;

    pRxActiveContexts = pListEntry = (PLIST_ENTRY)GetExpression("mrxdav!RxActiveContexts");

    if( args && *args ) {
        MatchFcb = GetExpression( args );
    }

    dprintf("\n Firstplentry: %08lx\n", pListEntry);

    for (;;) {
        if (!wGetData((ULONG_PTR)pListEntry,&LEbuffer,sizeof(LEbuffer),"RxActiveContexts")) return;
        if (LEbuffer.Flink == pRxActiveContexts) {
            if (pRxActiveContexts == pListEntry){
                dprintf("Active RxContext List Empty!\n");
            }
            return;
        }
        RxContext = ((ULONG_PTR)LEbuffer.Flink)-FieldOffsetOfContextListEntryInRxC();
        CapturedFcb = LastThread = 0x0badf00d;
        ReadRxContextFields(RxContext,&CapturedFcb,&LastThread,&MinirdrCtx2);
        if (MatchFcb == 0x1badf00d) {
            dprintf("%08lx: %08lx %08lx:  %08lx %08lx %08lx %08lx\n", pListEntry,
                           LEbuffer.Flink,LEbuffer.Blink,RxContext,CapturedFcb,LastThread,MinirdrCtx2);
        } else if ((MatchFcb == CapturedFcb)
                         || (MatchFcb == LastThread) ) {
            // if a matchfcb is specified and we have a match, the print and dump
            char Bufferqq[100];
            dprintf("%08lx: %08lx %08lx:  %08lx %08lx %08lx %08lx\n", pListEntry,
                           LEbuffer.Flink,LEbuffer.Blink,RxContext,CapturedFcb,LastThread,MinirdrCtx2);
            sprintf(Bufferqq," %08lx ",RxContext);
            dump( hCurrentProcess,
                  hCurrentThread,
                  dwCurrentPc,
                  dwProcessor,
                  Bufferqq
                  );

        }
        pListEntry = LEbuffer.Flink;
    }
}


#define GV_dprintf(__FORMAT__,__NAME__,__VALUE__) { \
        dprintf( "%s%-30s %08lx " __FORMAT__ "%s",  \
            c&1 ? "    " : "",                      \
            __NAME__,                               \
            dwAddress,                              \
            __VALUE__,                              \
            c&1 ? "\n" : "" );                      \
}
DECLARE_API( gv )
{
    ULONG_PTR dwAddress;
    CHAR buf[ 100 ];
    int i;
    int c=0;

    //CODE.IMPROVEMENT maybe we should hallucinate the moduleprefix instead
    // of having to specify it
    //CODE.IMPROVEMENT if we're not doing that, we shouldn't copy the name!

    //cause stuff to be loaded before we start printing
    dwAddress = GetExpression( "mrxdav!RxExpCXR" );
    dwAddress = GetExpression( "mrxsmb!SmbMmExchangesInUse" );

    for( i=0; GlobalBool[i]; i++, c++ ) {
        BOOL b;

        strcpy( &buf[0], GlobalBool[i] );
        dwAddress = GetExpression( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalBool[i] );
            continue;
        }
        if( !wGetData( dwAddress,&b, sizeof(b), "global BOOL") ) continue;

        GV_dprintf("%10s",GlobalBool[i],(b ? " TRUE" : "FALSE"));
    }

    for( i=0; GlobalShort[i]; i++, c++ ) {
        SHORT s;

        strcpy( &buf[0], GlobalShort[i] );
        dwAddress = GetExpression( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalShort[i] );
            continue;
        }
        if( !wGetData( dwAddress,&s,sizeof(s), "global SHORT") )  continue;

        GV_dprintf("%10d",GlobalShort[i],s);
    }

    for( i=0; GlobalLong[i]; i++, c++ ) {
        LONG l;

        strcpy( &buf[0], GlobalLong[i] );
        dwAddress = GetExpression( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalLong[i] );
            continue;
        }
        if( !wGetData( dwAddress,&l, sizeof(l), "global LONG") )  continue;

        GV_dprintf("%10d",GlobalLong[i],l);
    }

    for( i=0; GlobalPtrs[i]; i++, c++ ) {
        LONG l;

        //ERRPRT( "zaaaaa %s\n", GlobalPtrs[i] );
        strcpy( &buf[0], GlobalPtrs[i] );
        dwAddress = GetExpression( buf );
        //ERRPRT( "zbbbbb %s %08lx\n", GlobalPtrs[i], dwAddress );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalPtrs[i] );
            continue;
        }
        if( !wGetData( dwAddress,&l, sizeof(l), "global PTR") )  continue;
        //ERRPRT( "zccccc %s %08lx\n", GlobalPtrs[i], dwAddress );

        GV_dprintf("  %08lx",GlobalPtrs[i],l);
    }

    dprintf( "\n" );
}



HANDLE DumpFile;
CHAR wwDumpFormat[] = "-%06d:  %s\n";
VOID DumpRoutine(
    ULONG EntryNumber,
    PSZ   OriginalStringToPrint
    )
{
    UCHAR Buffer[200];
    UCHAR StringToPrint[160];
    PUCHAR p,q,r; LONG i;
    ULONG n,l3,l2,l1,l0; UCHAR Numbuf[32];
    ULONG ReturnedSize;

    //dprintf("before %d\n",EntryNumber);
    for (p=OriginalStringToPrint,q=StringToPrint,i=160;;) {
        PSZ format=NULL;

        if (*p==0) break;

        if (*p==0x4) {
            format = "%lx";
        } else if (*p==0x5) {
            format = "%ld";
        } else if (*p < ' ') {
            p++;i--;continue;
        }

        if (format!=NULL) {
            LONG Length;
            //translate the number
            p++;
            l0=*p++;
            l1=(*p++)<<8;
            l2=(*p++)<<16;
            l3=(*p++)<<24;
            n = l0 + l1 + l2 + l3;
            //dprintf("yaya %d %08lx %08lx %08lx %08lx %08lx\n",n,n,l0,l1,l2,l3);
            Length = sprintf(Numbuf,format,n);
            if (Length <= i) {
                for (r=Numbuf;*r;) { *q++ = *r++; }
                i -= Length;
            } else {
                i = 0;
            }
            if (i>0) continue;
        }
        if (i<=0) break;
        *q++ = *p++; i--;
    }
    *q = 0;

    //dprintf("after %d\n",EntryNumber);
    if (DumpFile == INVALID_HANDLE_VALUE) {
        dprintf(wwDumpFormat,EntryNumber,StringToPrint);
        return;
    }
    sprintf(Buffer,wwDumpFormat,EntryNumber,StringToPrint);
    WriteFile(DumpFile,Buffer,strlen(Buffer),&ReturnedSize,NULL);
    //should i check??
    return;
}


DECLARE_API( lg )
{
    ULONG_PTR dwAddress;
    BYTE DataBuffer[MAX_RX_LOG_ENTRY_SIZE];
    BYTE AlternateLine[110];
    RX_LOG RxLog;
    ULONG LogEntries = 30;
    BOOLEAN LogEntriesSpecified = FALSE;
    PRX_LOG_ENTRY_HEADER CurrentEntry;

    //SETCALLBACKS();
    dwAddress = GetExpression("mrxdav!s_RxLog");
    if (!wGetData(dwAddress,&RxLog,sizeof(RX_LOG),"RxLog")) return;


    DumpFile = INVALID_HANDLE_VALUE;
    if( args && *args ) {
        LPSTR lpArgs;
        for (;*args;) {
            if (*args=='@') { break;}
            if ((*args>='0') && (*args<='9')) {
                sscanf(args,"%ld",&LogEntries);
                LogEntriesSpecified = TRUE;
                break;
            }
            args++;
        }
        lpArgs = strpbrk(args, "@");
        if (lpArgs) {
            DumpFile = CreateFileA(lpArgs+1,
                       GENERIC_READ|GENERIC_WRITE,0,
                       NULL,
                       CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,
                       INVALID_HANDLE_VALUE);
            if (DumpFile == INVALID_HANDLE_VALUE){
                ULONG rc = LOWORD(GetLastError());
                dprintf("Error Opening <%s> is %d.",lpArgs+1,rc);
                return;
            }
            if (!LogEntriesSpecified) {
                LogEntries = 99999999; //this will be reset to the right size
            }
        }
    }


    // Dump the log header followed by the log entries ...

    dprintf("s_RxLog.State                    %lx\n",RxLog.State);
    dprintf("s_RxLog.CurrentEntry             %lx\n",RxLog.CurrentEntry);
    dprintf("s_RxLog.BaseEntry                %lx\n",RxLog.BaseEntry);
    dprintf("s_RxLog.EntryLimit               %lx\n",RxLog.EntryLimit);
    dprintf("s_RxLog.LogBufferSizeInEntries   %ld\n",RxLog.LogBufferSizeInEntries);
    dprintf("s_RxLog.NumberOfEntriesIgnored   %ld\n",RxLog.NumberOfEntriesIgnored);
    dprintf("s_RxLog.NumberOfLogWriteAttempts %ld\n",RxLog.NumberOfLogWriteAttempts);
    dprintf("s_RxLog.NumberOfLogWraps         %ld\n",RxLog.NumberOfLogWraps);

    if (LogEntries > RxLog.LogBufferSizeInEntries) {
        LogEntries = RxLog.LogBufferSizeInEntries;
    }
    if (LogEntries < 1) {
        LogEntries = 1;
    }

    CurrentEntry = RxLog.CurrentEntry;
    CurrentEntry -= (LogEntries-1);
    if (CurrentEntry < RxLog.BaseEntry) {
        CurrentEntry += (RxLog.EntryLimit - RxLog.BaseEntry);
    }

    for (;;) {
        ULONG TextPtr;
        BOOLEAN ExtraOrdinaryLogEntry;
        LogEntries--;
        if ( CheckControlC() ) {
            return;
        }
        if (!wGetData((ULONG_PTR)CurrentEntry,&TextPtr,sizeof(TextPtr),"TextPtr")) return;
        if (!wGetData(TextPtr,&DataBuffer[0],sizeof(DataBuffer),"LogEntryBuffer")) return;

        ExtraOrdinaryLogEntry = (DataBuffer[0] == '#')&&(DataBuffer[1] == '>')&&(DataBuffer[3] == 0);

        if (!ExtraOrdinaryLogEntry) {
            //dprintf("-%06d:  %s\n",LogEntries,DataBuffer);
            DumpRoutine(LogEntries,DataBuffer);
        } else {
            ULONG BinaryArgs = DataBuffer[2]-'0';
            PULONG_PTR x = (PULONG_PTR)&DataBuffer[sizeof(ULONG_PTR)];
            char Buffers[12*100]; //CODE.IMPROVEMENT this is poor but effective
            ULONG i;
            ULONG_PTR BinaryStringMask;
            PSZ ffFormat;

            //dprintf("textptr = %08lx, binaryString = %08lx\n", TextPtr, x[0]);
            for (i=1,BinaryStringMask=x[0];i<=BinaryArgs;i++) {
                if (BinaryStringMask & (1<<(i-1))) {
                    //dprintf("Stringing %d\n",i);
                    wGetString(x[i],&Buffers[i*100]); //this could fail!!!!
                    x[i] = ((ULONG_PTR)&Buffers[i*100]);
                    //dprintf("    string is %s\n",x[i]);
                }
            }

            ffFormat = (PSZ)(x[1]);

            switch (BinaryArgs) {
            case 9:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9]);
                break;
            case 8:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6],x[7],x[8]);
                break;
            case 7:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6],x[7]);
                break;
            case 6:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6]);
                break;
            case 5:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4],x[5]);
                break;
            case 4:
                sprintf(AlternateLine,ffFormat,x[2],x[3],x[4]);
                break;
            case 3:
                sprintf(AlternateLine,ffFormat,x[2],x[3]);
                break;
            case 2:
                sprintf(AlternateLine,ffFormat,x[2]);
                break;
            case 1:
                sprintf(AlternateLine,ffFormat);
                break;
            }
            DumpRoutine(LogEntries,AlternateLine);
        }
        if (LogEntries==0) break;
        CurrentEntry++;
        if (CurrentEntry==RxLog.EntryLimit) {
            CurrentEntry = RxLog.BaseEntry;
        }
    }

    if (DumpFile != INVALID_HANDLE_VALUE) {
        CloseHandle(DumpFile);
        DumpFile = INVALID_HANDLE_VALUE;
    }
}


PCWSTR   ExtensionLib   = NULL;
HANDLE   hExtensionMod  = NULL;
ULONG    DebugeeArchitecture = 0;

PCWSTR   GetExtensionLibPerDebugeeArchitecture(ULONG DebugeeArchitecture);

PWINDBG_EXTENSION_ROUTINE
GetKdExtProcAddress(
    IN PCSTR FuncName
    )
{
    PWINDBG_EXTENSION_ROUTINE       WindbgExtRoutine     = NULL;
    //dprintf( "yaya\n");
    if (hExtensionMod == NULL) {
        if (DebugeeArchitecture == 0) {
            ULONG_PTR pArchitecture;
            ReloadSymbols(" rdbss.sys");
            pArchitecture = GetExpression("mrxdav!RxProcessorArchitecture");
            if (pArchitecture==0) {
                dprintf("couldn't get architecture value...\n");
                return NULL;
            }
            if (!wGetData(pArchitecture,&DebugeeArchitecture,sizeof(DebugeeArchitecture),"RxArch")) return NULL;
            if ((DebugeeArchitecture&0x0fff0000) != 0xabc0000) {
                dprintf("\n Bad DebugeeArchitecture %08lx\n", DebugeeArchitecture);
                return(NULL);
            }
            DebugeeArchitecture &= 0xffff;
        }

        ExtensionLib = GetExtensionLibPerDebugeeArchitecture(DebugeeArchitecture);
        if (ExtensionLib == NULL) {
            dprintf( "bad debuggee arch\n");
            return(NULL);
        }

        hExtensionMod = LoadLibrary( ExtensionLib );
        if (hExtensionMod == NULL) {
            dprintf( "couldn't load %ws\n", ExtensionLib );
            return(NULL);
        }

    }

    WindbgExtRoutine = (PWINDBG_EXTENSION_ROUTINE)GetProcAddress( hExtensionMod, FuncName );
    if (WindbgExtRoutine == NULL) {
        dprintf( "couldn't find %ws%s\n", ExtensionLib, FuncName );
    }
    return WindbgExtRoutine;
}

#define CALL_THRU(NAME,ARGS) { \
    PWINDBG_EXTENSION_ROUTINE       WindbgExtRoutine     = GetKdExtProcAddress(NAME); \
    if (WindbgExtRoutine != NULL) {                                                   \
        (WindbgExtRoutine)( hCurrentProcess,                                          \
                            hCurrentThread,                                           \
                            dwCurrentPc,                                              \
                            dwProcessor,                                              \
                            ARGS                                                      \
                            );                                                        \
    }                                                                                 \
}

DECLARE_API( testr )
{

    CALL_THRU ( "threadfields", "");
}

DECLARE_API( dump );
VOID
__FollowOnHelper (
     PFOLLOWON_HELPER_ROUTINE Callee,
     HANDLE                 hCurrentProcess,
     HANDLE                 hCurrentThread,
     ULONG                  dwCurrentPc,
     ULONG                  dwProcessor,
     PCSTR                  args
     )
{
    BYTE Name[100], Buffer2[200];
    FOLLOWON_HELPER_RETURNS ret;
    PPERSISTENT_RDR2KD_INFO p;

    p = LocatePersistentInfoFromView();

    if (!p) {
        dprintf("Couldn't allocate perstistent info buffer...sorry...\n");
        return;
    }

    ret = Callee(p,Name,Buffer2);
    if (p!= NULL) FreePersistentInfoView(p);
    p = NULL;

    switch (ret) {

    case FOLLOWONHELPER_DUMP:
        dump(hCurrentProcess,
             hCurrentThread,
             dwCurrentPc,
             dwProcessor,
             Buffer2
             );
        break;

    case FOLLOWONHELPER_CALLTHRU:
        CALL_THRU ( Name, Buffer2);
        break;

    case FOLLOWONHELPER_ERROR:
        dprintf("%s",Buffer2);
        break;

    case FOLLOWONHELPER_DONE:
        break;
    }

    return;
}
#define FollowOnHelper(a) {            \
    __FollowOnHelper(a,                \
                     hCurrentProcess,  \
                     hCurrentThread,   \
                     dwCurrentPc,      \
                     dwProcessor,      \
                     args);            \
}

DECLARE_FOLLOWON_HELPER_CALLEE(FcbFollowOn);
DECLARE_API( fcb )
{
    FollowOnHelper(FcbFollowOn);
}


DECLARE_API( flags )
{
    ULONG i,mask,newline,value;

    if( args && *args ) {
        sscanf(args,"%lx",&value);
        dprintf("Flags for %08lx\n",value);
    } else {
        dprintf("error in flags: no value presented\n");
        return;
    }

    for (i=newline=0,mask=1;i<32;i++,mask<<=1) {
        if (value&mask) {
            dprintf("    %02d 0x%08lx%c",i,mask,(newline==0)?' ':'\n');
            newline ^= 1;
        }
    }
    if (newline) {
        dprintf("\n");
    }
}

DECLARE_API( cxr )
{
    ULONG_PTR dwAddress,cxr;
    BYTE NumBuffer[16];
    RX_LOG RxLog;
    ULONG LogEntries = 30;
    PRX_LOG_ENTRY_HEADER CurrentEntry;

    //SETCALLBACKS();


    dwAddress = GetExpression("mrxdav!RxExpCXR");
    if (!wGetData(dwAddress,&cxr,sizeof(cxr),"cxr")) return;

    dprintf("\nRxExpCXR=%08lx\n",cxr);
    sprintf(NumBuffer,"%08lx \n",cxr);

    CALL_THRU ( "cxr", NumBuffer);
    if (DebugeeArchitecture==0) {
        CALL_THRU ( "kb", "");
    }

}

VOID dprintfsprintfbuffer(BYTE *Buffer)
{
    dprintf("%s\n",Buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\reflector\kernel\precomp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This includes the header files needed by everyone in this directory.

Revision History:

--*/

//
// Get the minirdr environment.
//
#include "rx.h"

//
// NT network file system driver include files.
//
#include "ntddnfs2.h"

//
// Reflector library's user mode header file.
//
#include "ntumrefl.h"

#include "netevent.h"

//
// Reflector library's kernel mode header file.
//
#include "umrx.h"

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\inc\umrx.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    umrx.h

Abstract:

    This module defines the types and functions which make up the reflector
    library. These functions are used by the miniredirs to reflect calls upto
    the user mode.

Author:

    Rohan Kumar    [rohank]    14-March-1999

Revision History:

--*/

#ifndef _UMRX_H_
#define _UMRX_H_

#include "align.h"
#include "status.h"

//
// Unreferenced local variable.
//
#pragma warning(error:4101)

IMPORTANT_STRUCTURE(UMRX_ASYNCENGINE_CONTEXT);
IMPORTANT_STRUCTURE(UMRX_DEVICE_OBJECT);

//
// The BUGBUG macro expands to NOTHING. Its basically used to describe problems
// associated with the current code.
//
#define BUGBUG(_x_)

//
// The argument signatures that are used in a lot of the reflector and miniredir
// functions.
//
#define UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE \
                            PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext, \
                            PRX_CONTEXT RxContext

//
// The arguments that are passed to a lof of the reflector and miniredir
// functions.
//
#define UMRX_ASYNCENGINE_ARGUMENTS AsyncEngineContext,RxContext

//
// The global list of all the currently active AsyncEngineContexts and the
// resource that is used to synchronize access to it.
//
extern LIST_ENTRY UMRxAsyncEngineContextList;
extern ERESOURCE UMRxAsyncEngineContextListLock;

//
// The ASYNCENG_HISTORY structure which is used to keep track of the history
// of AsyncEngineContext structure.
//
#define UMRX_ASYNCENG_HISTORY_SIZE 32
typedef struct _ASYNCENG_HISTORY {
    ULONG Next;
    ULONG Submits;
    struct {
        ULONG Longs[2];
    } Markers[UMRX_ASYNCENG_HISTORY_SIZE];
} ASYNCENG_HISTORY, *PASYNCENG_HISTORY;

//
// This macro defines the flags of the AsyncEngineContext strucutre.
//
#define UMRX_ASYNCENG_DEFINE_CTX_FLAG(a, c) \
                RX_DEFINE_FLAG(UMRX_ASYNCENG_CTX_FLAG_##a, c, 0xffff)
typedef enum {
    UMRX_ASYNCENG_DEFINE_CTX_FLAG(ASYNC_OPERATION, 0)
} UMRX_ASYNCENG_CONTEXT_FLAGS;

//
// The prototype of the ContextFormatRoutine specified by the Miniredir.
//
typedef
NTSTATUS
(*PUMRX_ASYNCENG_CONTEXT_FORMAT_ROUTINE) (
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    USHORT FormatContext
    );

//
// The prototype of the continuation routine specified by the Miniredir.
//
typedef
NTSTATUS
(*PUMRX_ASYNCENG_CONTINUE_ROUTINE) (
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

//
// The prototype of the format routine specified by the Miniredir.
//
typedef
NTSTATUS
(*PUMRX_ASYNCENG_USERMODE_FORMAT_ROUTINE) (
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItem,
    ULONG WorkItemLength,
    PULONG_PTR ReturnedLength
    );

//
// The prototype of the precompletion routine specified by the Miniredir.
//
typedef
BOOL
(*PUMRX_ASYNCENG_USERMODE_PRECOMPLETION_ROUTINE) (
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItem,
    ULONG WorkItemLength,
    BOOL OperationCancelled
    );

//
// The various states of an AsyncEngineContext.
//
typedef enum _UMRX_ASYNCENGINE_CONTEXT_STATE {
    UMRxAsyncEngineContextAllocated = 0,
    UMRxAsyncEngineContextInUserMode,
    UMRxAsyncEngineContextBackFromUserMode,
    UMRxAsyncEngineContextCancelled
} UMRX_ASYNCENGINE_CONTEXT_STATE;

//
// The AsyncEngineContext strucutre that is shared across all the miniredirs.
// It contains information common to all the miniredirs.
//
typedef struct _UMRX_ASYNCENGINE_CONTEXT {

    //
    // The header below is a common header which is present at the start of all
    // the data strucutres manipulated by the RDBSS and the MiniRedirs. It is
    // used for debugging purposes and for keeping track of the number of times
    // a node (data structure) has been referenced.
    //
    MRX_NORMAL_NODE_HEADER;

    //
    // This listEntry is used to insert the AsyncEngineContext into the global
    // UMRxAsyncEngineContextList list.
    //
    LIST_ENTRY ActiveContextsListEntry;

    UMRX_ASYNCENGINE_CONTEXT_STATE AsyncEngineContextState;

    //
    // Is this context handling a synchronous or an asynchronous operation?
    //
    BOOL AsyncOperation;

    //
    // If this is an AsyncOperation, then RxLowIoCompletion is called only if
    // this is set to TRUE. Some operations like CreateSrvCall are Async but
    // do not need LowIoCompletion to be called.
    //
    BOOL ShouldCallLowIoCompletion;

    //
    // Was IoMarkIrpPending called on the Irp that is being handled by this
    // AsyncEngineContext?
    //
    BOOL ContextMarkedPending;

    //
    // The system tick count when this context was created. This value is used
    // in timing out requests that take more than a specified time.
    //
    LARGE_INTEGER CreationTimeInTickCount;

    //
    // The RxContext data structure that is passed in by the RDBSS. It describes
    // an Irp while it is being processed and contains state information that
    // allows global resources to be released as the Irp is completed.
    //
    PRX_CONTEXT RxContext;

    //
    // The context ptr that saves the incoming (from RDBSS) state of
    // MRxContext[0] (which is a field  of the RxContext data structure).
    //
    PVOID SavedMinirdrContextPtr;

    //
    // Pointer to IRP used to call down to the underlying file system.
    //
    PIRP CalldownIrp;

    //
    // The I/O status block is set to indicate the status of a given I/O
    // request.
    //
    union {
        IO_STATUS_BLOCK;
        IO_STATUS_BLOCK IoStatusBlock;
    };

    //
    // The work item which is queued to be completed.
    //
    RX_WORK_QUEUE_ITEM  WorkQueueItem;

    //
    // Flags that set and indicate the state of the AsyncEngineContext.
    //
    USHORT Flags;

    BOOLEAN FileInformationCached;
    BOOLEAN FileNotExists;

    BOOLEAN ParentDirInfomationCached;
    BOOLEAN ParentDirIsEncrypted;

    //
    // The continuation routine which is to be called for this I/O request.
    //
    PUMRX_ASYNCENG_CONTINUE_ROUTINE Continuation;

    //
    //  List of shared memory allocations for this context.  All are freed when
    //  this context is freed.
    //
    LIST_ENTRY AllocationList;

    //
    // The UserMode structure.
    //
    struct {
        //
        // The work entry thats inserted into the Queue of the
        // UMRdrDeviceObject.
        //
        LIST_ENTRY WorkQueueLinks;

        //
        // The routine that formats the arguments of the I/O request which is
        // reflected to the usermode.
        //
        PUMRX_ASYNCENG_USERMODE_FORMAT_ROUTINE FormatRoutine;

        //
        // The routine that is called (to do some final cleanup etc.)just before
        // an I/O operation that was sent to the usermode gets completed. 
        // 
        //
        PUMRX_ASYNCENG_USERMODE_PRECOMPLETION_ROUTINE PrecompletionRoutine;

        //
        // The event used to signal a thread waiting for a MID to be freed up. 
        //
        KEVENT WaitForMidEvent;

        //
        // The serial number set before sending this conttext to the user mode.
        //
        ULONG CallUpSerialNumber;

        //
        // The MID value of the context.
        //
        USHORT CallUpMid;

        union {
            struct {
                //
                //
                //
                PBYTE CapturedOutputBuffer;
            };
            //
            //
            //
            ULONG SetInfoBufferLength;
        };
    } UserMode;

    //
    // The context passed to the function called in the context of a worker 
    // thread.
    //
    PVOID     PostedOpContext;

    //
    // The completion status of a posted operation. Operations get posted to 
    // worker threads created by RDBSS.
    //
    NTSTATUS  PostedOpStatus;

    //
    // This is set to the global serialnumber (for this operation) of RxContext.
    //
    ULONG SerialNumber;

    //
    // Used to keep track of the history of the operations on the AsynEngCtx.
    //
    ASYNCENG_HISTORY History;

    //
    // This is set to the CurrentIrp in RxContext which points to the
    // origination irp.
    //
    PIRP RxContextCapturedRequestPacket;

} UMRX_ASYNCENGINE_CONTEXT, *PUMRX_ASYNCENGINE_CONTEXT;

#define SIZEOF_UMRX_ASYNCENGINE_CONTEXT   sizeof(UMRX_ASYNCENGINE_CONTEXT)

//
// The API of the reflector library exposed to the miniredirs. These are the
// only functions of the library that the miniredirs should use to reflect
// the requests to the user mode.
//

NTSTATUS
UMRxInitializeDeviceObject(
    OUT PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN USHORT MaxNumberMids,
    IN USHORT InitialMids,
    IN SIZE_T HeapSize
    );

NTSTATUS
UMRxCleanUpDeviceObject(
    PUMRX_DEVICE_OBJECT DeviceObject
    );

NTSTATUS
UMRxAsyncEngOuterWrapper(
    IN PRX_CONTEXT RxContext,
    IN ULONG AdditionalBytes,
    IN PUMRX_ASYNCENG_CONTEXT_FORMAT_ROUTINE ContextFormatRoutine,
    USHORT FormatContext,
    IN PUMRX_ASYNCENG_CONTINUE_ROUTINE Continuation,
    IN PSZ RoutineName
    );

NTSTATUS
UMRxSubmitAsyncEngUserModeRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    PUMRX_ASYNCENG_USERMODE_FORMAT_ROUTINE FormatRoutine,
    PUMRX_ASYNCENG_USERMODE_PRECOMPLETION_ROUTINE PrecompletionRoutine
    );

BOOLEAN
UMRxFinalizeAsyncEngineContext(
    IN OUT PUMRX_ASYNCENGINE_CONTEXT *AEContext
    );

NTSTATUS
UMRxAsyncEngineCalldownIrpCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp,
    IN OUT PVOID Context
    );

typedef
NTSTATUS
(*PUMRX_POSTABLE_OPERATION) (
    IN OUT PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext
    );
NTSTATUS
UMRxPostOperation (
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PVOID PostedOpContext,
    IN PUMRX_POSTABLE_OPERATION Operation
    );

PBYTE
UMRxAllocateSecondaryBuffer (
    IN OUT PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    SIZE_T Length
    );

NTSTATUS
UMRxFreeSecondaryBuffer (
    IN OUT PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    PBYTE  Buffer
    );

VOID
UMRxReleaseCapturedThreads (
    IN OUT PUMRX_DEVICE_OBJECT UMRdrDeviceObject
    );

VOID
UMRxAssignWork (
    IN PUMRX_DEVICE_OBJECT UMRdrDeviceObject,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER InputWorkItem,
    IN ULONG InputWorkItemLength,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER OutputWorkItem,
    IN ULONG OutputWorkItemLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
UMRxResumeAsyncEngineContext(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
UMRxImpersonateClient(
    IN PSECURITY_CLIENT_CONTEXT SecurityClientContext,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader
    );

NTSTATUS
UMRxReadDWORDFromTheRegistry(
    IN PWCHAR RegKey,
    IN PWCHAR ValueToRead,
    OUT LPDWORD DataRead
    );

//
// The function used to revert back to the original client thread.
//
NTKERNELAPI
VOID
PsRevertToSelf(
    VOID
    );

#define UMRxRevertClient() PsRevertToSelf()

//
// Macro definitions used by the reflector and the miniredirs.
//

//
// Check to see if we have a correct AsyncEngineContext node.
//
#define ASSERT_ASYNCENG_CONTEXT(__p)  \
                        ASSERT(NodeType(__p) == UMRX_NTC_ASYNCENGINE_CONTEXT)

//
// This macro is used to do the async completion for read/write/locks. Note
// that the call to lowiocompletion will try to complete the irp thereby
// freeing the user's mdl. We use this macro so that there will be only one
// version of this code. When we combine the start routines, this will be
// unmacroed.
//
#define UMRxAsyncEngAsyncCompletionIfNecessary(AECTX, RXCONTEXT) {       \
    if (ContinueEntryCount > 1) {                                        \
        BOOLEAN FinalizationComplete;                                    \
        if (FALSE) { DbgBreakPoint(); }                                  \
        (RXCONTEXT)->StoredStatus = NtStatus;                            \
        RxLowIoCompletion((RXCONTEXT));                                  \
        FinalizationComplete = UMRxFinalizeAsyncEngineContext(&(AECTX));  \
        ASSERT(!FinalizationComplete);                                   \
    }                                                                    \
}

//
// This macro allows one to execute conditional debugging code.
//
#if DBG
#define DEBUG_ONLY_CODE(x) x
#else
#define DEBUG_ONLY_CODE(x)
#endif

//
// The heap is shared between kernel and user but only the kernel component 
// allocates and frees into the heap.
//
typedef struct _UMRX_SHARED_HEAP {
    LIST_ENTRY  HeapListEntry;
    PBYTE       VirtualMemoryBuffer;
    SIZE_T      VirtualMemoryLength;
    PVOID       Heap;
    ULONG       HeapAllocationCount;
    BOOLEAN     HeapFull;
} UMRX_SHARED_HEAP, * PUMRX_SHARED_HEAP;

//
// NodeType Codes.
//
#define UMRX_NTC_ASYNCENGINE_CONTEXT  ((USHORT)0xedd0)

//
// This strucutre defines the fields which the reflector and the miniredir can
// share and is encapsulated in the miniredirs device object. The miniredirs
// device object may contain some other fields which are specific to its
// operation.
//
typedef struct _UMRX_DEVICE_OBJECT {

    //
    // The RDBSS's device object structure.
    //
    union {
        RDBSS_DEVICE_OBJECT;
        RDBSS_DEVICE_OBJECT RxDeviceObject;
    };

    //
    // The max size of the heap that can be allocated.
    //
    SIZE_T NewHeapSize;

    //
    // List of shared heaps created by worker threads.
    //
    LIST_ENTRY SharedHeapList;

    //
    // Used to synchronize the heap allocation/deletion, creation/destruction.
    //
    ERESOURCE HeapLock;

    //
    // Mid atlas and its management and synchronization.
    //
    struct {
        PRX_MID_ATLAS MidAtlas;
        FAST_MUTEX MidManagementMutex;
        LIST_ENTRY WaitingForMidListhead;
    };

    struct {

        //
        // The Queue of the device object where the requests which need reflection
        // wait.
        //
        KQUEUE Queue;
        
        //
        // Used to synchronize the KQUEUE insertions.
        //
        ERESOURCE QueueLock;
        
        //
        // The timeout value used by the worker threads when waiting on the 
        // KQUEUE for requests to be taken to user mode.
        //
        LARGE_INTEGER TimeOut;
        
        //
        // Used to release the worker threads which are waiting on the KQUEUE.
        // Once the worker threads are released, no requests can be reflected.
        //
        LIST_ENTRY PoisonEntry;
        
        //
        // Used to signal the thread (which comes down with an IOCTL to release
        // the worker threads) waiting for all the worker threads to be
        // released.
        //
        KEVENT RunDownEvent;
        
        //
        // Number of worker threads waiting on the KQUEUE.
        //
        ULONG NumberOfWorkerThreads;
        
        //
        // Number of workitems (requests to be reflected) in the queue.
        //
        ULONG NumberOfWorkItems;
        
        //
        // Are the worker threads still willing to take the requests.
        //
        BOOLEAN WorkersAccepted;

    } Q;

    //
    // Always incremented and assigned to the AsyncEngineContext's serial
    // number.
    //
    ULONG NextSerialNumber;

} UMRX_DEVICE_OBJECT, *PUMRX_DEVICE_OBJECT;

#endif   //_UMRX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\reflector\kernel\reflctor.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    reflctor.h

Abstract:

    The global include file for the reflector.

Author:

    Rohan Kumar   [rohank]  (21-Mar-99)

Revision History:

--*/

#ifndef _REFLCTOR_H_
#define _REFLCTOR_H_

//
// This structure is used for secondary buffer allocations.
//
#define UMRX_SECONDARY_BUFFER_SIGNATURE 0x42534d55   // "UMSB"

typedef struct _UMRX_SECONDARY_BUFFER {
    ULONG               Signature;
    SIZE_T              AllocationSize;
    PUMRX_SHARED_HEAP   SourceSharedHeap;
    LIST_ENTRY          ListEntry;
    WCHAR               Buffer[1];
} UMRX_SECONDARY_BUFFER, *PUMRX_SECONDARY_BUFFER;


//
// Pool tags used by the reflector library. All the DAV MiniRedir pool tags 
// have "DV" as the first two characters.
//
#define UMRX_ASYNCENGINECONTEXT_POOLTAG ('DVCx')
#define UMRX_SHAREDHEAP_POOLTAG ('DVSh')

//
// Use the UMRxDbgTrace macro for logging reflector stuff in the 
// kernel debugger.
//
#if DBG
ULONG UMRxDebugVector = 0;
#define UMRX_TRACE_ERROR      0x00000001
#define UMRX_TRACE_DEBUG      0x00000002
#define UMRX_TRACE_CONTEXT    0x00000004
#define UMRX_TRACE_DETAIL     0x00000008
#define UMRX_TRACE_ENTRYEXIT  0x00000010
#define UMRX_TRACE_ALL        0xffffffff
#define UMRxDbgTrace(_x_, _y_) {         \
        if (_x_ & UMRxDebugVector) {     \
            DbgPrint _y_;                \
        }                                \
}
#else
#define UMRxDbgTrace(_x_, _y_)
#endif

//
// Usermode callout stuff.
//
typedef struct _UMRX_WORKITEM_HEADER_PRIVATE {
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext;
    ULONG SerialNumber;
    USHORT Mid;
} UMRX_WORKITEM_HEADER_PRIVATE, *PUMRX_WORKITEM_HEADER_PRIVATE;

#define MIN(x,y) ((x) < (y) ? (x) : (y))

#if DBG
#define P__ASSERT(exp) {                                   \
        if (!(exp)) {                                      \
            UMRxDbgTrace(UMRX_TRACE_DEBUG,                 \
                         ("%ld: %s is not TRUE.\n",        \
                          PsGetCurrentThreadId(), #exp));  \
            errors++;                                      \
        }                                                  \
}
#endif

#if DBG
#define FINALIZE_TRACKING_SETUP() \
    struct {                      \
        ULONG marker1;            \
        ULONG finalstate;         \
        ULONG marker2;            \
    } Tracking = {'ereh',0,'ereh'};

#define FINALIZE_TRACKING(x) {    \
        Tracking.finalstate |= x; \
}
#define FINALIZE_TRACE(x)  {                                                 \
        UMRxDbgTrace(UMRX_TRACE_DETAIL,                                      \
                     ("%ld: UMRxFinalizeAsyncEngineContext: %s (%08lx).\n",  \
                      PsGetCurrentThreadId(), x, Tracking.finalstate));      \
}
#else
#define FINALIZE_TRACKING_SETUP()
#define FINALIZE_TRACKING(x)
#define FINALIZE_TRACE(x)
#endif

#define REASSIGN_MID      1
#define DONT_REASSIGN_MID 0

#if DBG
ULONG
UMRxAsyncEngShortStatus(
    IN ULONG Status
    );

VOID UMRxAsyncEngUpdateHistory(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    ULONG Tag1,
    ULONG Tag2
    );

#define UPDATE_HISTORY_LONG(a) {                             \
        UMRxAsyncEngUpdateHistory(AsyncEngineContext, a, 0); \
}
#define UPDATE_HISTORY_2SHORTS(a,b) {                        \
        UMRxAsyncEngUpdateHistory(AsyncEngineContext, a, b); \
}
#define UPDATE_HISTORY_WITH_STATUS(a) \
  UPDATE_HISTORY_2SHORTS(a, UMRxAsyncEngShortStatus(AsyncEngineContext->Status))
#else
#define UPDATE_HISTORY_LONG(a)
#define UPDATE_HISTORY_2SHORTS(a,b)
#define UPDATE_HISTORY_WITH_STATUS(a)
#endif

#if DBG
#define AECTX_CHKLINKAGE_FLAG_NO_REQPCKT_CHECK 0x00000001

VOID
__UMRxAsyncEngAssertConsistentLinkage(
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line,
    PRX_CONTEXT RxContext,
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    ULONG Flags
    );

#define UMRxAsyncEngAssertConsistentLinkage(a, flags) {              \
        __UMRxAsyncEngAssertConsistentLinkage(a,                     \
                                              __FILE__,              \
                                              __LINE__,              \
                                              RxContext,             \
                                              AsyncEngineContext,    \
                                              flags);                \
}
#else
#define UMRxAsyncEngAssertConsistentLinkage(a, flags) {NOTHING;}
#endif // DBG

#endif // _REFLCTOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\reflector\user\precomp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This includes the header files needed by everyone in this directory.

Revision History:

--*/

#pragma once

#define UNICODE 1
#define _UNICODE 1

//
// Private nt headers.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddnfs.h>

//
// Public windows headers.
//
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <rpc.h>
#include <ntumrefl.h>
#include "global.h"

// eof. precomp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\reflector\user\getreq.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    getreq.c

Abstract:

    This code handles getting requests and sending responses to the kernel for
    the user mode reflector library.  This implements UMReflectorGetRequest
    and UMReflectorSendResponse.

Author:

    Andy Herron (andyhe) 19-Apr-1999

Environment:

    User Mode - Win32

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop

ULONG
UMReflectorGetRequest (
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    PUMRX_USERMODE_WORKITEM_HEADER ResponseWorkItem,
    PUMRX_USERMODE_WORKITEM_HEADER ReceiveWorkItem,
    BOOL revertAlreadyDone
    )
/*++

Routine Description:

    This routine sends down an IOCTL to get a request and in some cases
    send a response.

Arguments:

    Handle - The reflector's handle.

    ResponseWorkItem - Response to an earlier request.

    ReceiveWorkItem - Buffer to receive another request.
    
    revertAlreadyDone - If this is TRUE, it means that the thread that is 
                        executing this function has been reverted back to its
                        original state. When the request is picked up from the 
                        kernel, in some cases the thread impersonates the client
                        that issued the request. If we revert back in the 
                        usermode for some reason, then we don't need to revert
                        back in the kernel.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    PUMRX_USERMODE_WORKITEM_ADDON workItem = NULL;
    PUMRX_USERMODE_WORKITEM_ADDON previousWorkItem = NULL;
    BOOL SuccessfulOperation;
    ULONG NumberOfBytesTransferred;
    ULONG rc;

    if (WorkerHandle == NULL || ReceiveWorkItem == NULL) {
        RlDavDbgPrint(("%ld: ERROR: UMReflectorGetRequest. Invalid Parameter.\n",
                       GetCurrentThreadId()));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // We get back to our item by subtracting off of the item passed to us.
    // this is safe because we fully control allocation.
    //
    workItem = (PUMRX_USERMODE_WORKITEM_ADDON) (PCHAR)((PCHAR)ReceiveWorkItem -
                FIELD_OFFSET(UMRX_USERMODE_WORKITEM_ADDON, Header));

    ASSERT(workItem->WorkItemState == WorkItemStateNotYetSentToKernel);
    workItem->WorkItemState = WorkItemStateInKernel;

    if (ResponseWorkItem != NULL) {
        //
        // If we have a response to send, then we don't have to go check the
        // free pending list. Just do it now.
        //
        previousWorkItem = (PUMRX_USERMODE_WORKITEM_ADDON)
                           (PCHAR)((PCHAR)ResponseWorkItem -
                           FIELD_OFFSET(UMRX_USERMODE_WORKITEM_ADDON, Header));

        ASSERT(previousWorkItem->WorkItemState != WorkItemStateFree);
        ASSERT(previousWorkItem->WorkItemState != WorkItemStateAvailable);

        previousWorkItem->WorkItemState = WorkItemStateResponseNotYetToKernel;
        
        if (WorkerHandle->IsImpersonating) {
            ASSERT( (ResponseWorkItem->Flags & UMRX_WORKITEM_IMPERSONATING) );
            WorkerHandle->IsImpersonating = FALSE;
            //
            // If we have already reverted back to the threads original context,
            // then we clear this flag as we don't need to revert back in the
            // kernel.
            //
            if (revertAlreadyDone) {
                ResponseWorkItem->Flags &= ~UMRX_WORKITEM_IMPERSONATING;
            }
        }

        SuccessfulOperation = DeviceIoControl(WorkerHandle->ReflectorHandle,
                                              IOCTL_UMRX_RESPONSE_AND_REQUEST,
                                              ResponseWorkItem,
                                              ResponseWorkItem->WorkItemLength,
                                              ReceiveWorkItem,
                                              ReceiveWorkItem->WorkItemLength,
                                              &NumberOfBytesTransferred,
                                              NULL);

        previousWorkItem->WorkItemState = WorkItemStateResponseFromKernel;
    } else {
        //
        // If this thread was impersonating a client when it came up, store that
        // info in the workitem that is being sent down to get the request. In the
        // kernel, the reflector will look at this flag and revert back. After 
        // setting the flag, we set the IsImpersonating value to FALSE.
        //
        if (WorkerHandle->IsImpersonating) {
            
            //
            // If we have already reverted back to the threads original context,
            // then we do not set this flag as we don't need to revert back in 
            // the kernel.
            //
            if (!revertAlreadyDone) {
                ReceiveWorkItem->Flags |= UMRX_WORKITEM_IMPERSONATING;
            }
            WorkerHandle->IsImpersonating = FALSE;
        }
        SuccessfulOperation = DeviceIoControl(WorkerHandle->ReflectorHandle,
                                              IOCTL_UMRX_GET_REQUEST,
                                              NULL,
                                              0,
                                              ReceiveWorkItem,
                                              ReceiveWorkItem->WorkItemLength,
                                              &NumberOfBytesTransferred,
                                              NULL);
    }
    
    if (!SuccessfulOperation) {
        rc = GetLastError();
        RlDavDbgPrint(("%ld: ERROR: UMReflectorGetRequest/DeviceIoControl: Error Val = "
                       "%08lx.\n", GetCurrentThreadId(), rc));
        workItem->WorkItemState = WorkItemStateNotYetSentToKernel;
    } else {
        rc = STATUS_SUCCESS;
        workItem->WorkItemState = WorkItemStateReceivedFromKernel;
        //
        // If the thread is Impersonating a client, store that info. This is 
        // needed to tell the kernel to revert the thread back when it goes to
        // collect another request.
        //
        if( (ReceiveWorkItem->Flags & UMRX_WORKITEM_IMPERSONATING) ) {
            WorkerHandle->IsImpersonating = TRUE;
        }
    }

    return rc;
}


ULONG
UMReflectorSendResponse (
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle,
    PUMRX_USERMODE_WORKITEM_HEADER ResponseWorkItem
    )
/*++

Routine Description:

    This routine sends down an IOCTL to get send a response for an asynchronous
    request.

Arguments:

    Handle - The reflector's handle.

    ResponseWorkItem - Response to an earlier request.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    PUMRX_USERMODE_WORKITEM_ADDON   workItem = NULL;
    BOOL                            SuccessfulOperation;
    ULONG                           NumberOfBytesTransferred;
    ULONG                           rc;

    if (WorkerHandle == NULL || ResponseWorkItem == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // We get back to our item by subtracting off of the item passed to us.
    // This is safe because we fully control allocation.
    //
    workItem = (PUMRX_USERMODE_WORKITEM_ADDON)(PCHAR)((PCHAR)ResponseWorkItem -
                FIELD_OFFSET(UMRX_USERMODE_WORKITEM_ADDON, Header));

    ASSERT(workItem->WorkItemState == WorkItemStateReceivedFromKernel);
    workItem->WorkItemState = WorkItemStateResponseNotYetToKernel;

    if( (ResponseWorkItem->Flags & UMRX_WORKITEM_IMPERSONATING) ) {
        ResponseWorkItem->Flags &= ~UMRX_WORKITEM_IMPERSONATING;
    }

    SuccessfulOperation = DeviceIoControl(WorkerHandle->ReflectorHandle,
                                          IOCTL_UMRX_RESPONSE,
                                          ResponseWorkItem,
                                          ResponseWorkItem->WorkItemLength,
                                          NULL,
                                          0,
                                          &NumberOfBytesTransferred,
                                          NULL);
    if (!SuccessfulOperation) {
        rc = GetLastError();
    } else {
        rc = ERROR_SUCCESS;
    }

    workItem->WorkItemState = WorkItemStateResponseFromKernel;

    return rc;
}

// getreq.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\reflector\user\global.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    global.h

Abstract:

   This module contains data declarations necessary for the user mode
   reflector user mode library.

Author:

    Andy Herron    (andyhe)        19-Apr-1999

Revision History:

--*/

//
// This structure is maintained one per reflector instance. We pass it back to
// the calling app and he always passes it in to us. If we loose it, we're lost.
//
typedef struct _UMRX_USERMODE_REFLECT_BLOCK {

    //
    // Reference count of this reflector block.
    //
    ULONG               ReferenceCount;
    
    //
    // Handle to the Mini-Redirs device object.
    //
    HANDLE              DeviceHandle;      
    
    //
    // Lock used to synchronize access to the fields of this reflect block.
    //
    CRITICAL_SECTION    Lock;
    
    //
    // Name of the Device object.
    //
    PWCHAR              DriverDeviceName;
    
    //
    // Is this reflector block active ? Closing = FALSE : Closing = TRUE;
    //
    BOOL                Closing;

    //
    // List of user mode worker thread(s) instance blocks.
    //
    LIST_ENTRY          WorkerList;         
    
    //
    // List of work items currently in use to satisfy requests getting 
    // reflected from the kernel.
    //
    LIST_ENTRY          WorkItemList;

    //
    // For efficiency, we hold a few workitems around in a small cache. Note
    // that if the entry size changes, the cache will not be as effective.
    //

    //
    // List of work items which are available for use. After a workitem gets
    // finalized, it moves from the WorkItemList (see above) to the 
    // AvailableList.
    //
    LIST_ENTRY          AvailableList;      
    
    //
    // Number of work items present on the AvailableList.
    //
    ULONG               NumberAvailable;
    
    //
    // The maximum number of workitems that can be cached on the AvailableList.
    // When NumberAvailable exceeds the CacheLimit, one of the work items on the
    // list (specifically the last entry) is freed up.
    //
    ULONG               CacheLimit;

    //
    // Must be last element.
    //
    WCHAR               DeviceNameBuffers[1];   

} UMRX_USERMODE_REFLECT_BLOCK, *PUMRX_USERMODE_REFLECT_BLOCK;


//
// This structure is maintained one per worker thread.  It holds the handle
// on which we do our IOCTLs down to kernel.
//
typedef struct _UMRX_USERMODE_WORKER_INSTANCE {

    //
    // Used to add it to the reflect block list of worker instances.
    //
    LIST_ENTRY                      WorkerListEntry;
    
    //
    // The instance (user mode process) being served.
    //
    PUMRX_USERMODE_REFLECT_BLOCK    ReflectorInstance;

    //
    // Is this thread impersonating a client ?
    //
    BOOL IsImpersonating;
    
    //
    // Handle of kernel device for this registered instance.
    //
    HANDLE                          ReflectorHandle;    

} UMRX_USERMODE_WORKER_INSTANCE, *PUMRX_USERMODE_WORKER_INSTANCE;

//
//  User mode Work Item States :  Mostly for debugging/support purposes.
//
typedef enum _USERMODE_WORKITEM_STATE {

    //
    // It's about to be freed back to the heap.
    //
    WorkItemStateFree = 0,

    //
    // It's on the list of freed and available for reallocation.
    //
    WorkItemStateAvailable,     

    //
    // Has been sent to kernel to get a request.
    //
    WorkItemStateInKernel,

    //
    // Allocated by UMReflectorAllocateWorkItem but UMReflectorGetRequest 
    // has not yet been called.
    //
    WorkItemStateNotYetSentToKernel,

    //
    // UMReflectorGetRequest is back from kernel but a response has not yet 
    // been sent for this work item.
    //
    WorkItemStateReceivedFromKernel,

    //
    // During UMReflectorGetRequest, responses that are in flight to the kernel 
    // are set with this state.
    //
    WorkItemStateResponseNotYetToKernel,

    //
    // After UMReflectorGetRequest, response workitem is set to this state on 
    // the way to free or available.
    //
    WorkItemStateResponseFromKernel

} USERMODE_WORKITEM_STATE;

//
// This structure is maintained one per reflection down to kernel mode. We give
// it to the calling app, he fills it in and gives it back to us to give to 
// kernel and then we return it when kernel has a request. This structure is 
// just for housekeeping and is not passed between user and kernel mode. It sits
// directly in front of the UMRX_USERMODE_WORKITEM_HEADER structure.
//
typedef struct _UMRX_USERMODE_WORKITEM_ADDON {

    //
    // Size of this entry.
    //
    ULONG                          EntrySize; 

    //
    // The user mode instance with which this work item is associated.
    //
    PUMRX_USERMODE_REFLECT_BLOCK   ReflectorInstance;

    //
    // Used in adding it to the reflect blocks list.
    //
    LIST_ENTRY                     ListEntry;

    //
    // The state of the work item.
    //
    USERMODE_WORKITEM_STATE        WorkItemState;

    //
    // The work item header which the user mode instance gets back to use.
    //
    union {
        UMRX_USERMODE_WORKITEM_HEADER   Header;
        UMRX_USERMODE_WORKITEM_HEADER;
    };

} UMRX_USERMODE_WORKITEM_ADDON, *PUMRX_USERMODE_WORKITEM_ADDON;

#if DBG
#define RlDavDbgPrint(_x_) DbgPrint _x_
#else
#define RlDavDbgPrint(_x_)
#endif

VOID
DereferenceReflectorBlock (
    PUMRX_USERMODE_REFLECT_BLOCK reflectorInstance
    );

ULONG
ReflectorSendSimpleFsControl(
    PUMRX_USERMODE_REFLECT_BLOCK ReflectorHandle,
    ULONG IoctlCode
    );

// global.h eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\reflector\kernel\umrx.c ===
/*++ Copyright (c) 1999  Microsoft Corporation

Module Name:

    umrx.c

Abstract:

    This module defines the types and functions which make up the reflector
    library. These functions are used by the miniredirs to reflect calls upto
    the user mode.

Author:

    Rohan Kumar     [rohank]     15-March-1999

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include <dfsfsctl.h>
#include "reflctor.h"

//
// Mentioned below are the prototypes of functions that are used only within
// this module (file). These functions should not be exposed outside.
//

NTSTATUS
UMRxCompleteUserModeRequest (
    IN PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItem,
    IN ULONG WorkItemLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
UMRxCompleteUserModeErroneousRequest(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    IN PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemHeaderLength
    );

NTSTATUS
UMRxAcquireMidAndFormatHeader (
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItem
    );

NTSTATUS
UMRxPrepareUserModeRequestBuffer (
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    IN  PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItem,
    IN  ULONG WorkItemLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
UMRxVerifyHeader (
    IN PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN PUMRX_USERMODE_WORKITEM_HEADER WorkItem,
    IN ULONG ReassignmentCmd,
    OUT PUMRX_ASYNCENGINE_CONTEXT *capturedAsyncEngineContext
    );

NTSTATUS
UMRxEnqueueUserModeCallUp(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    );

PUMRX_SHARED_HEAP
UMRxAddSharedHeap(
    PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    SIZE_T HeapSize
    );

PUMRX_ASYNCENGINE_CONTEXT
UMRxCreateAsyncEngineContext(
    IN PRX_CONTEXT RxContext,
    IN ULONG SizeToAllocate
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, UMRxResumeAsyncEngineContext)
#pragma alloc_text(PAGE, UMRxSubmitAsyncEngUserModeRequest)
#pragma alloc_text(PAGE, UMRxCreateAsyncEngineContext)
#pragma alloc_text(PAGE, UMRxFinalizeAsyncEngineContext)
#pragma alloc_text(PAGE, UMRxPostOperation)
#pragma alloc_text(PAGE, UMRxAcquireMidAndFormatHeader)
#pragma alloc_text(PAGE, UMRxPrepareUserModeRequestBuffer)
#pragma alloc_text(PAGE, UMRxCompleteUserModeErroneousRequest)
#pragma alloc_text(PAGE, UMRxVerifyHeader)
#pragma alloc_text(PAGE, UMRxCompleteUserModeRequest)
#pragma alloc_text(PAGE, UMRxEnqueueUserModeCallUp)
#pragma alloc_text(PAGE, UMRxAssignWork)
#pragma alloc_text(PAGE, UMRxReleaseCapturedThreads)
#pragma alloc_text(PAGE, UMRxAllocateSecondaryBuffer)
#pragma alloc_text(PAGE, UMRxFreeSecondaryBuffer)
#pragma alloc_text(PAGE, UMRxAddSharedHeap)
#pragma alloc_text(PAGE, UMRxInitializeDeviceObject)
#pragma alloc_text(PAGE, UMRxCleanUpDeviceObject)
#pragma alloc_text(PAGE, UMRxImpersonateClient)
#pragma alloc_text(PAGE, UMRxAsyncEngOuterWrapper)
#pragma alloc_text(PAGE, UMRxReadDWORDFromTheRegistry)
#endif

#if DBG
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, __UMRxAsyncEngAssertConsistentLinkage)
#pragma alloc_text(PAGE, UMRxAsyncEngShortStatus)
#pragma alloc_text(PAGE, UMRxAsyncEngUpdateHistory)
#endif
#endif

//
// The global list of all the currently active AsyncEngineContexts and the
// resource that is used to synchronize access to it.
//
LIST_ENTRY UMRxAsyncEngineContextList;
ERESOURCE UMRxAsyncEngineContextListLock;


//
// Implementation of functions begins here.
//

#if DBG
VOID
__UMRxAsyncEngAssertConsistentLinkage(
    PSZ MsgPrefix,
    PSZ File,
    unsigned Line,
    PRX_CONTEXT RxContext,
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    ULONG Flags
    )
/*++

Routine Description:

   This routine performs a variety of checks to ensure that the linkage between
   the RxContext and the AsyncEngineContext is correct and that various fields
   have correct values. If anything is bad, print stuff out and break into the
   debugger.

Arguments:

     MsgPrefix - An identifying message for debugging purposes.

     RxContext - The RDBSS context.

     AsyncEngineContext - The exchange to be conducted.

     Flags - The flags associated with the AsyncEngineContext.

Return Value:

    none

Notes:

--*/
{
    ULONG errors = 0;

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: Entering __UMRxAsyncEngAssertConsistentLinkage!!!!.\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: __UMRxAsyncEngAssertConsistentLinkage: "
                  "AsyncEngineContext: %08lx.\n", 
                  PsGetCurrentThreadId(), AsyncEngineContext));

    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: __UMRxAsyncEngAssertConsistentLinkage: "
                  "RxContext->MRxContext[0]: %08lx.\n", 
                  PsGetCurrentThreadId(), RxContext->MRxContext[0]));
    
    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: __UMRxAsyncEngAssertConsistentLinkage: "
                  "RxContext: %08lx.\n", PsGetCurrentThreadId(), RxContext));
    
    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: __UMRxAsyncEngAssertConsistentLinkage: "
                  "AsyncEngineContext->RxContext = %08lx.\n", 
                  PsGetCurrentThreadId(), AsyncEngineContext->RxContext));

    P__ASSERT(AsyncEngineContext->SerialNumber == RxContext->SerialNumber);
    P__ASSERT(NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT);
    P__ASSERT(NodeType(AsyncEngineContext) == UMRX_NTC_ASYNCENGINE_CONTEXT);
    P__ASSERT(AsyncEngineContext->RxContext == RxContext);
    P__ASSERT(AsyncEngineContext == (PUMRX_ASYNCENGINE_CONTEXT)RxContext->MRxContext[0]);
    if (!FlagOn(Flags, AECTX_CHKLINKAGE_FLAG_NO_REQPCKT_CHECK)) {
        // P__ASSERT(AsyncEngineContext->RxContextCapturedRequestPacket == RxContext->CurrentIrp);
    }

    if (errors == 0) {
        return;
    }

    UMRxDbgTrace(UMRX_TRACE_ERROR, 
                 ("%ld: ERROR: __UMRxAsyncEngAssertConsistentLinkage: %s "
                  "%d errors in file %s at line %d\n",
                  PsGetCurrentThreadId(), MsgPrefix, errors, File, Line));

    DbgBreakPoint();

    return;
}


ULONG
UMRxAsyncEngShortStatus(
    IN ULONG Status
    )
/*++

Routine Description:

    This routine calculates the short status.

Arguments:

    Status - The status value passed in.

Return Value:

    ULONG - The short status for the value passed in.

--*/
{
    ULONG ShortStatus;

    PAGED_CODE();

    ShortStatus = Status & 0xc0003fff;
    ShortStatus = ShortStatus | (ShortStatus >> 16);
    return(ShortStatus);
}


VOID
UMRxAsyncEngUpdateHistory(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    ULONG Tag1,
    ULONG Tag2
    )
/*++

Routine Description:

    This routine updates the histroy of the AsynEngineContext.

Arguments:

    AsyncEngineContext - The exchange to be conducted.

    Tag1, Tag2 - Tags used for the update.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    ULONG MyIndex, Long0, Long1;

    PAGED_CODE();

    MyIndex = InterlockedIncrement(&AsyncEngineContext->History.Next);
    MyIndex = (MyIndex - 1) & (UMRX_ASYNCENG_HISTORY_SIZE - 1);
    Long0 = (Tag1 << 16) | (Tag2 & 0xffff);
    Long1 = (UMRxAsyncEngShortStatus(AsyncEngineContext->Status) << 16)
            | AsyncEngineContext->Flags;
    AsyncEngineContext->History.Markers[MyIndex].Longs[0] = Long0;
    AsyncEngineContext->History.Markers[MyIndex].Longs[1] = Long1;
}

#endif


NTSTATUS
UMRxResumeAsyncEngineContext(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine resumes processing on an exchange. This is called when work is
   required to finish processing a request that cannot be completed at DPC
   level.  This happens either because the parse routine needs access to
   structures that are not locks OR because the operation is asynchronous and
   there maybe more work to be done. The two cases are regularized by delaying
   the parse if we know that we're going to post: this is indicated by the
   presense of a resume routine.

Arguments:

    RxContext  - The RDBSS context of the operation.

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext = NULL;

    PAGED_CODE();

    AsyncEngineContext = (PUMRX_ASYNCENGINE_CONTEXT)RxContext->MRxContext[0];

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxResumeAsyncEngineContext.\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxResumeAsyncEngineContext: "
                  "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                  PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    UMRxAsyncEngAssertConsistentLinkage("UMRxResumeAsyncEngineContext: ",
                                        AECTX_CHKLINKAGE_FLAG_NO_REQPCKT_CHECK);

    NtStatus = AsyncEngineContext->Status;

    UPDATE_HISTORY_WITH_STATUS('0c');

    UPDATE_HISTORY_WITH_STATUS('4c');
    
    //
    // Remove my references which were added when the AsyncEngineContext was 
    // placed on the KQueue. If I'm the last guy then finalize.
    //
    UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT, 
                 ("%ld: Leaving UMRxResumeAsyncEngineContext with NtStatus = "
                  "%08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
UMRxSubmitAsyncEngUserModeRequest(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN PUMRX_ASYNCENG_USERMODE_FORMAT_ROUTINE FormatRoutine,
    IN PUMRX_ASYNCENG_USERMODE_PRECOMPLETION_ROUTINE PrecompletionRoutine
    )
/*++

Routine Description:

   This routine sets some fields (see below) in the AsyncEnineContext structure
   and calls the UMRxEnqueueUserModeCallUp function.

Arguments:

    RxContext - The RDBSS context.

    AsyncEngineContext - The exchange to be conducted.

    FormatRoutine - The routine that formats the arguments of the I/O request
                    which is handled by a usermode process.

    PrecompletionRoutine - The routine that handles the post processing of an
                           I/O request. By post processing we mean after the 
                           request returns from the user mode.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN AsyncOperation = FlagOn(AsyncEngineContext->Flags,
                                    UMRX_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT, 
                 ("%ld: Entering UMRxSubmitAsyncEngUserModeRequest!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT, 
                 ("%ld: UMRxSubmitAsyncEngUserModeRequest: AsyncEngineContext:"
                  " %08lx, RxContext: %08lx.\n", 
                  PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    UMRxAsyncEngAssertConsistentLinkage("UMRxSubmitAsyncEngUserModeRequest:", 0);

    //
    // Set the Format, Precompletion and Secondary routines of the context.
    //
    AsyncEngineContext->UserMode.FormatRoutine = FormatRoutine;
    AsyncEngineContext->UserMode.PrecompletionRoutine = PrecompletionRoutine;

    if (AsyncOperation) {
        AsyncEngineContext->AsyncOperation = TRUE;
    }

    KeInitializeEvent(&RxContext->SyncEvent, NotificationEvent, FALSE);

    //
    // We need to add a reference to the AsyncEngineContext before adding it to
    // the Device object's KQueue.
    //
    InterlockedIncrement( &(AsyncEngineContext->NodeReferenceCount) );

    UPDATE_HISTORY_2SHORTS('eo', AsyncOperation?'!!':0);
    DEBUG_ONLY_CODE(InterlockedIncrement(&AsyncEngineContext->History.Submits);)

    //
    // Queue up the usermode request.
    //
    NtStatus = UMRxEnqueueUserModeCallUp(UMRX_ASYNCENGINE_ARGUMENTS);

    if (NtStatus != STATUS_PENDING) {
        BOOLEAN ReturnVal = FALSE;
        //
        // Too bad. We couldn't queue the request. Remove our reference on the
        // AsyncEngineContext and leave.
        //
        UMRxDbgTrace(UMRX_TRACE_ERROR, 
                     ("%ld: ERROR: UMRxSubmitAsyncEngUserModeRequest/"
                      "UMRxEnqueueUserModeCallUp: NtStatus = %08lx.\n",
                      PsGetCurrentThreadId(), NtStatus));
        ReturnVal = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
        ASSERT(!ReturnVal);
        AsyncEngineContext->Status = NtStatus;
        return NtStatus;
    }

    //
    // If this is an Async operation, we set this information in the context
    // and leave right away.
    //
    if (AsyncOperation) {
        UMRxDbgTrace(UMRX_TRACE_DETAIL, 
                     ("%ld: UMRxSubmitAsyncEngUserModeRequest: "
                      "Async Operation!!\n", PsGetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

    UPDATE_HISTORY_WITH_STATUS('1o');

    RxWaitSync(RxContext);

    UMRxAsyncEngAssertConsistentLinkage("BeforeResumeAsyncEngineContext: ", 0);

    NtStatus = UMRxResumeAsyncEngineContext(RxContext);

    UPDATE_HISTORY_WITH_STATUS('9o');

EXIT_THE_FUNCTION:
    
    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT, 
                 ("%ld: Leaving UMRxSubmitAsyncEngUserModeRequest with "
                  "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

   return(NtStatus);
}


PUMRX_ASYNCENGINE_CONTEXT
UMRxCreateAsyncEngineContext(
    IN PRX_CONTEXT RxContext,
    IN ULONG       SizeToAllocate
    )
/*++

Routine Description:

   This routine allocates and initializes a miniredir's context.

Arguments:

    RxContext      -  The RDBSS context.

    SizeToAllocate - The size to allocate for the new context. This value is
                     equal to the size of the miniredirs context which
                     encapsulates the AsynEngineContext.

Return Value:

    A miniredir context buffer ready to go, OR NULL.

Notes:

--*/
{
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext = NULL;
    BOOLEAN ReadWriteIrp = FALSE;

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxCreateAsyncEngineContext!!!!\n",
                  PsGetCurrentThreadId()));
    
    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxCreateAsyncEngineContext: RxContext: %08lx.\n", 
                  PsGetCurrentThreadId(), RxContext));

    //
    // Allocate the miniredir context. If the resources are unavailable, then
    // return NULL.
    //
    AsyncEngineContext = (PUMRX_ASYNCENGINE_CONTEXT)
                         RxAllocatePoolWithTag(NonPagedPool,
                                               SizeToAllocate,
                                               UMRX_ASYNCENGINECONTEXT_POOLTAG);
    if (AsyncEngineContext == NULL) {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxCreateAsyncEngineContext/"
                      "RxAllocatePoolWithTag.\n", PsGetCurrentThreadId()));
        return ((PUMRX_ASYNCENGINE_CONTEXT)NULL);
    }

    //
    // Initialize the header of the new (context) node.
    //
    ZeroAndInitializeNodeType(AsyncEngineContext,
                              UMRX_NTC_ASYNCENGINE_CONTEXT,
                              SizeToAllocate);
    //
    // Place a reference on the context until we are finished.
    //
    InterlockedIncrement( &(AsyncEngineContext->NodeReferenceCount) );

    DEBUG_ONLY_CODE(AsyncEngineContext->SerialNumber = RxContext->SerialNumber);

    //
    // Place a reference on the RxContext until we are finished.
    //
    InterlockedIncrement( &(RxContext->ReferenceCount) );

    //
    // Capture the RxContext.
    //
    AsyncEngineContext->RxContext = RxContext;

    InitializeListHead( &(AsyncEngineContext->AllocationList) );

    //
    // Capture the IRP.
    //
    DEBUG_ONLY_CODE(AsyncEngineContext->RxContextCapturedRequestPacket
                    = RxContext->CurrentIrp);

    //
    // Save MRxContext[0] incase we use it. The saved context is restored
    // just before returning back to RDBSS. This is done because the RDBSS
    // may have used MRxContext[0] for storing some information.
    //
    AsyncEngineContext->SavedMinirdrContextPtr = RxContext->MRxContext[0];
    RxContext->MRxContext[0] = (PVOID)AsyncEngineContext;

    //
    // If this is a Read or a Write IRP, we need to set ReadWriteIrp to TRUE.
    //
    if ( (RxContext->MajorFunction == IRP_MJ_READ) || (RxContext->MajorFunction == IRP_MJ_WRITE) ) {
        ReadWriteIrp = TRUE;
    }

    //
    // If ReadWriteIrp is TRUE, then we do not add the AsyncEngineContext that
    // was created to the global UMRxAsyncEngineContextList. This is because
    // we do not cancel read/write operations in the DAV Redir, so there is no
    // point in adding them to this list. Also, if the MappedPageWriter thread
    // is blocked on acquiring the UMRxAsyncEngineContextListLock, it can cause
    // a deadlock since the thread that has acquired the lock could be waiting
    // for the MM to free up some pages. MM (in this case) ofcourse is waiting
    // for the MappedPageWriter to finish.
    //
    if (ReadWriteIrp == FALSE) {

        //
        // Add the context to the global UMRxAsyncEngineContextList. We need to
        // synchronize this operation.
        //
        ExAcquireResourceExclusiveLite(&(UMRxAsyncEngineContextListLock), TRUE);
        InsertHeadList(&(UMRxAsyncEngineContextList), &(AsyncEngineContext->ActiveContextsListEntry));
        ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));

        //
        // Set the current system time as the creation time of the context.
        //
        KeQueryTickCount( &(AsyncEngineContext->CreationTimeInTickCount) );

    }

    return(AsyncEngineContext);
}


BOOLEAN
UMRxFinalizeAsyncEngineContext(
    IN OUT PUMRX_ASYNCENGINE_CONTEXT *AEContext
    )
/*++

Routine Description:

    This finalizes an AsyncEngineContext. If the reference on the context after
    the finalization is zero, it is freed. This function is not pagable. See
    below for details.

Arguments:

    AEContext - Pointer to the address of the AECTX to be finalized.

Return Value:

    TRUE if the context is freed occurs otherwise FALSE.

Notes:

--*/
{
    LONG result = 0;
    PIRP irp = NULL;
    PLIST_ENTRY listEntry;
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext = *AEContext;
    PRX_CONTEXT RxContext = AsyncEngineContext->RxContext;
    BOOLEAN AsyncOperation = FALSE, ReadWriteIrp = FALSE;

    FINALIZE_TRACKING_SETUP()

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxFinalizeAsyncEngineContext\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxFinalizeAsyncEngineContext: "
                  "AsyncEngineContext: %08lx, RxContext: %08lx\n",
                  PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    result =  InterlockedDecrement( &(AsyncEngineContext->NodeReferenceCount) );
    if (result != 0) {
        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxFinalizeAsyncEngineContext: Returning w/o "
                      "finalizing: (%d)\n", PsGetCurrentThreadId(), result));
        return FALSE;
    }

    FINALIZE_TRACKING(0x1);

    ASSERT(RxContext != NULL);

    //
    // If this is a Read or a Write IRP, we need to set ReadWriteIrp to TRUE.
    //
    if ( (RxContext->MajorFunction == IRP_MJ_READ) || (RxContext->MajorFunction == IRP_MJ_WRITE) ) {
        ReadWriteIrp = TRUE;
    }

    //
    // If the IRP was for Read or Write, we would not have added the context to
    // the global UMRxAsyncEngineContextList. For an explanation of why we do
    // not add AsyncEngineContexts that deal with read/write IRPs to this list,
    // look at the comment in UMRxCreateAsyncEngineContext where the context is
    // added to this list.
    //
    if (ReadWriteIrp == FALSE) {
        //
        // Remove the context from the global UMRxAsyncEngineContextList now that we
        // are going to free if after we do a few things. We need to synchronize
        // this operation.
        //
        ExAcquireResourceExclusiveLite(&(UMRxAsyncEngineContextListLock), TRUE);
        RemoveEntryList( &(AsyncEngineContext->ActiveContextsListEntry) );
        ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));
    }

    while ( !IsListEmpty(&AsyncEngineContext->AllocationList) ) {
        
        PUMRX_SECONDARY_BUFFER buf = NULL;

        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxFinalizeAsyncEngineContext: Freeing the "
                      "AllocationList of the AsyncEngineContext.\n",
                      PsGetCurrentThreadId()));

        listEntry = AsyncEngineContext->AllocationList.Flink;

        buf = CONTAINING_RECORD(listEntry,
                                UMRX_SECONDARY_BUFFER,
                                ListEntry);

        UMRxFreeSecondaryBuffer(AsyncEngineContext, (PBYTE)&buf->Buffer);

        //
        // If it didn't remove this from the list, we're looping.
        //
        ASSERT(listEntry != AsyncEngineContext->AllocationList.Flink);
    
    }

    AsyncOperation = FlagOn(AsyncEngineContext->Flags, UMRX_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);

    irp = AsyncEngineContext->CalldownIrp;

    //
    // If the CallDownIrp is not NULL, then we need to do the following.
    //
    if (irp != NULL) {

        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxFinalizeAsyncEngineContext: Freeing IRP = %08lx, MajorFn = %d\n",
                      PsGetCurrentThreadId(), irp, RxContext->MajorFunction));

        if (irp->MdlAddress) {
            IoFreeMdl(irp->MdlAddress);
        }
        
        //
        // We are done with this irp, so free it.
        //
        IoFreeIrp(irp);
        
        FINALIZE_TRACKING(0x20);

    }

    //
    // If this was an Async Operation, then we need to complete the original
    // irp since we would have returned STATUS_PENDING back earlier. To do
    // this, we do one of two things.
    // 1. Call into the RxLowIoCompletion function if the LowIoCompletion
    //    routine exists.
    // 2. Just complete the IRP if no such routine  exists.
    // Also, we do this only if ShouldCallLowIoCompletion is set to TRUE since
    // some Async calls do not need this. Eg: CreateSrvCall is async but doesn't
    // need it. Ofcourse, if the operation was cancelled then there is no need
    // to call this since the routine that handles the cancelling would have
    // taken care of this.
    //
    if (AsyncOperation && 
        AsyncEngineContext->ShouldCallLowIoCompletion &&
        AsyncEngineContext->AsyncEngineContextState != UMRxAsyncEngineContextCancelled) {

        ASSERT(RxContext != NULL);

        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxFinalizeAsyncEngineContext: Async Operation\n",
                      PsGetCurrentThreadId()));

        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxFinalizeAsyncEngineContext: Completing Irp = %08lx\n",
                      PsGetCurrentThreadId(), RxContext->CurrentIrp));

        if (RxContext->LowIoContext.CompletionRoutine) {
            //
            // Set the status and information values in the RxContext. These are
            // the values returned by the underlying file system for the read
            // or the write operation that was issued to them.
            //
            RxContext->StoredStatus = AsyncEngineContext->Status;
            RxContext->InformationToReturn = AsyncEngineContext->Information;
            //
            // Finally, call RxLowIoCompletion.
            //
            RxLowIoCompletion(RxContext);
        } else {
            //
            // Complete the request by calling RxCompleteRequest.
            //
            RxContext->CurrentIrp->IoStatus.Status = AsyncEngineContext->Status;
            RxContext->CurrentIrp->IoStatus.Information = AsyncEngineContext->Information;
            RxCompleteRequest(RxContext, AsyncEngineContext->Status);
        }

    }

    //
    // We took a reference on the RxContext when we created the AsyncEngineContext.
    // Since we are done with the AsyncEngineContext, we need to remove it now.
    //
    RxDereferenceAndDeleteRxContext(AsyncEngineContext->RxContext);

    FINALIZE_TRACE("Ready to Discard Exchange");

    RxFreePool(AsyncEngineContext);

    //
    // Set the AsyncEngineContext pointer to NULL.
    //
    *AEContext = NULL;

    FINALIZE_TRACKING(0x3000);

    FINALIZE_TRACKING(0x40000);

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxFinalizeAsyncEngineContext. Final State = "
                  "%x\n", PsGetCurrentThreadId(), Tracking.finalstate));

    return(TRUE);
}


NTSTATUS
UMRxAsyncEngineCalldownIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP CalldownIrp OPTIONAL,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the calldownirp is completed.

Arguments:

    DeviceObject - The device object in play.

    CalldownIrp -

    Context -

Return Value:

    RXSTATUS - STATUS_MORE_PROCESSING_REQUIRED

--*/
{
    PRX_CONTEXT RxContext = (PRX_CONTEXT)Context;
    
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext =
                            (PUMRX_ASYNCENGINE_CONTEXT)RxContext->MRxContext[0];
    
    BOOLEAN AsyncOperation = FlagOn(AsyncEngineContext->Flags,
                                    UMRX_ASYNCENG_CTX_FLAG_ASYNC_OPERATION);

    //
    // This is not Pageable code.
    //

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxAsyncEngineCalldownIrpCompletion!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxAsyncEngineCalldownIrpCompletion: "
                  "AsyncEngineContext: %08lx, RxContext: %08lx.\n",
                  PsGetCurrentThreadId(), AsyncEngineContext, RxContext));

    UPDATE_HISTORY_WITH_STATUS('ff');
    
    UMRxAsyncEngAssertConsistentLinkage("UMRxCalldownCompletion: ", 0);

    //
    // If the CallDownIrp is not NULL, then this means that the underlying
    // filesystem has completed the read or the write IRP that we had given it
    // using the IoCallDriver call.
    //
    if (CalldownIrp != NULL) {
        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxAsyncEngineCalldownIrpCompletion: "
                      "CallDownIrp = %08lx, MajorFunction = %d\n",
                      PsGetCurrentThreadId(), CalldownIrp, RxContext->MajorFunction));
        AsyncEngineContext->Status = CalldownIrp->IoStatus.Status;
        AsyncEngineContext->Information = CalldownIrp->IoStatus.Information;
    }

    if (AsyncOperation) {
        
        NTSTATUS PostStatus = STATUS_SUCCESS;
        
        if (RxContext->pRelevantSrvOpen) {
        
            UMRxDbgTrace(UMRX_TRACE_DETAIL,
                         ("%ld: UMRxAsyncEngineCalldownIrpCompletion: "
                          "ASync Resume. AsyncEngineContext = %08lx, RxContext "
                          "= %08lx, FileName = %wZ\n", 
                          PsGetCurrentThreadId(), AsyncEngineContext, RxContext,
                          RxContext->pRelevantSrvOpen->pAlreadyPrefixedName));
        }
        
        IF_DEBUG {
            //
            // Fill the workqueue structure with deadbeef. All the better to
            // diagnose a failed post.
            //
            ULONG i;
            for (i=0;
                 i + sizeof(ULONG) - 1 < sizeof(AsyncEngineContext->WorkQueueItem);
                 i += sizeof(ULONG)) {
                PBYTE BytePtr = ((PBYTE)&AsyncEngineContext->WorkQueueItem)+i;
                PULONG UlongPtr = (PULONG)BytePtr;
                *UlongPtr = 0xdeadbeef;
            }
        }
        
        PostStatus = RxPostToWorkerThread(RxContext->RxDeviceObject,
                                          CriticalWorkQueue,
                                          &(AsyncEngineContext->WorkQueueItem),
                                          UMRxResumeAsyncEngineContext,
                                          RxContext);
        
        ASSERT(PostStatus == STATUS_SUCCESS);
    
    } else {

        if (RxContext->pRelevantSrvOpen) {
        
            UMRxDbgTrace(UMRX_TRACE_DETAIL,
                         ("%ld: UMRxAsyncEngineCalldownIrpCompletion: "
                          "Sync Resume. AsyncEngineContext = %08lx, RxContext "
                          "= %08lx, FileName = %wZ\n", 
                          PsGetCurrentThreadId(), AsyncEngineContext, RxContext,
                          RxContext->pRelevantSrvOpen->pAlreadyPrefixedName));
        
        }
        
        //
        // Signal the thread that is waiting after queuing the workitem on the
        // KQueue.
        //
        RxSignalSynchronousWaiter(RxContext);
    
    }

    return(STATUS_MORE_PROCESSING_REQUIRED);
}


NTSTATUS
UMRxPostOperation(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN OUT PVOID PostedOpContext,
    IN PUMRX_POSTABLE_OPERATION Operation
    )
/*++

Routine Description:

Arguments:

    RxContext  - The RDBSS context.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status,PostStatus;

    PAGED_CODE();

    ASSERT_ASYNCENG_CONTEXT(AsyncEngineContext);

    KeInitializeEvent(&RxContext->SyncEvent,
                      NotificationEvent,
                      FALSE);

    AsyncEngineContext->PostedOpContext = PostedOpContext;

    IF_DEBUG {
        //
        // Fill the workqueue structure with deadbeef. All the better to
        // diagnose a failed post
        //
        ULONG i;
        for (i = 0; 
             i + sizeof(ULONG) - 1 < sizeof(AsyncEngineContext->WorkQueueItem);
             i += sizeof(ULONG)) {
            PBYTE BytePtr = ((PBYTE)&AsyncEngineContext->WorkQueueItem)+i;
            PULONG UlongPtr = (PULONG)BytePtr;
            *UlongPtr = 0xdeadbeef;
        }
    }

    PostStatus = RxPostToWorkerThread(RxContext->RxDeviceObject,
                                      DelayedWorkQueue,
                                      &AsyncEngineContext->WorkQueueItem,
                                      Operation,
                                      AsyncEngineContext);

    ASSERT(PostStatus == STATUS_SUCCESS);

    RxWaitSync(RxContext);

    Status = AsyncEngineContext->PostedOpStatus;

    return(Status);
}


NTSTATUS
UMRxAcquireMidAndFormatHeader(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE,
    IN PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader
    )
/*++

Routine Description:

    This routine gets a mid and formats the header. It waits until it can get a
    MID if all the MIDs are currently passed out.

Arguments:

    RxContext - The RDBSS context.

    AsyncEngineContext - The Reflector's AsynEngine's context.

    UMRefDeviceObject - The UMRef device object.

    WorkItemHeader - The work item header buffer.

Return Value:

    STATUS_SUCCESS. Later could be STATUS_CANCELLED.


--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PUMRX_WORKITEM_HEADER_PRIVATE PrivateWorkItemHeader =
                                (PUMRX_WORKITEM_HEADER_PRIVATE)WorkItemHeader;

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxAcquireMidAndFormatHeader!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxAcquireMidAndFormatHeader: WorkItem = %08lx, "
                  "AsyncEngineContext = %08lx, RxContext = %08lx.\n",
                  PsGetCurrentThreadId(), WorkItemHeader, AsyncEngineContext,
                  RxContext));

    RtlZeroMemory(WorkItemHeader, sizeof(UMRX_USERMODE_WORKITEM_HEADER));

    ExAcquireFastMutex(&UMRefDeviceObject->MidManagementMutex);

    //
    // Taken away as we disassociate the mid.
    //
    InterlockedIncrement( &(AsyncEngineContext->NodeReferenceCount) );

    if (IsListEmpty(&UMRefDeviceObject->WaitingForMidListhead)) {
        
        NtStatus = RxAssociateContextWithMid(UMRefDeviceObject->MidAtlas,
                                             AsyncEngineContext,
                                             &AsyncEngineContext->UserMode.CallUpMid);
        if (NtStatus != STATUS_SUCCESS) {
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxAcquireMidAndFormatHeader/"
                          "RxAssociateContextWithMid: NtStatus = %08lx\n", 
                          PsGetCurrentThreadId(), NtStatus));
        }
    
    } else {
        
        NtStatus = STATUS_UNSUCCESSFUL;
        
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxAcquireMidAndFormatHeader. "
                      "WaitingForMidList is not empty.\n", PsGetCurrentThreadId()));
    
    }

    if (NtStatus == STATUS_SUCCESS) {
        
        ExReleaseFastMutex(&UMRefDeviceObject->MidManagementMutex);
    
    } else {

        KeInitializeEvent(&AsyncEngineContext->UserMode.WaitForMidEvent,
                          NotificationEvent,
                          FALSE);
        
        InsertTailList(&UMRefDeviceObject->WaitingForMidListhead,
                                &AsyncEngineContext->UserMode.WorkQueueLinks);
        
        ExReleaseFastMutex(&UMRefDeviceObject->MidManagementMutex);
        
        KeWaitForSingleObject(&AsyncEngineContext->UserMode.WaitForMidEvent,
                              Executive,
                              UserMode,
                              FALSE,
                              NULL);

        NtStatus = STATUS_SUCCESS;
    }

    PrivateWorkItemHeader->AsyncEngineContext = AsyncEngineContext;
    
    AsyncEngineContext->UserMode.CallUpSerialNumber 
             = PrivateWorkItemHeader->SerialNumber
                  = InterlockedIncrement(&UMRefDeviceObject->NextSerialNumber);
    
    PrivateWorkItemHeader->Mid = AsyncEngineContext->UserMode.CallUpMid;

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxAcquireMidAndFormatHeader with NtStatus = "
                  "%08lx\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
UMRxPrepareUserModeRequestBuffer(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    IN  PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN  ULONG WorkItemHeaderLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    This routine dispatches to a usermode guy using the info in the asyncengine
    context. The workerirp is represented by the captureheader.

Arguments:

   AsyncEngineContext - The context associated with the request that is being
                        sent to the usermode.

    UMRefDeviceObject - The device object in play.

    WorkItemHeader - The workitem buffer.

    WorkItemHeaderLength - Length of the WorkItemHeader buffer.

    IoStatus - The reults of the assignment.

Return Value:

    STATUS_SUCCESS if the thread should be released with the IoStatus returned
    otherwise, don't release the thread.


--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PRX_CONTEXT RxContext;
    PUMRX_ASYNCENG_USERMODE_FORMAT_ROUTINE FormatRoutine;
    BOOL MidAcquired = FALSE, lockAcquired = FALSE, OperationCancelled = TRUE;

    PAGED_CODE();

    RxContext = AsyncEngineContext->RxContext;

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                ("%ld: Entering UMRxPrepareUserModeRequestBuffer!!!!\n",
                 PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxPrepareUserModeRequestBuffer: "
                  "WorkItemHeader = %08lx, AsyncEngineContext = %08lx, "
                  "RxContext = %08lx\n", PsGetCurrentThreadId(), WorkItemHeader,
                  AsyncEngineContext, RxContext));
    
    ASSERT(NodeType(RxContext) == RDBSS_NTC_RX_CONTEXT);
    ASSERT(AsyncEngineContext->RxContext == RxContext);

    //
    // We need to make sure that the request has not been cancelled since it 
    // was put on the KQueue. If it has been cancelled, then we don't need to
    // go to the usermode and can do the finalization right away. If it has not
    // been cancelled, the we keep the global ContextListlock, complete the
    // format routine and then release the lock.
    //

    ExAcquireResourceExclusiveLite(&(UMRxAsyncEngineContextListLock), TRUE);
    lockAcquired = TRUE;

    if (AsyncEngineContext->AsyncEngineContextState == UMRxAsyncEngineContextInUserMode) {
    
        //
        // Need checks that things are the right size.
        //
        if (UMRefDeviceObject != (PUMRX_DEVICE_OBJECT)(RxContext->RxDeviceObject)) {
            NtStatus = STATUS_INVALID_PARAMETER;
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxPrepareUserModeRequestBuffer: "
                          "Invalid DevObj.\n", PsGetCurrentThreadId()));
            goto EXIT_THE_FUNCTION;
        }

        FormatRoutine = AsyncEngineContext->UserMode.FormatRoutine;

        NtStatus = UMRxAcquireMidAndFormatHeader(UMRX_ASYNCENGINE_ARGUMENTS,
                                                 UMRefDeviceObject,
                                                 WorkItemHeader);
        if (NtStatus != STATUS_SUCCESS) {
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxPrepareUserModeRequestBuffer/"
                          "UMRxAcquireMidAndFormatHeader: Error Val = %08lx.\n",
                          PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        } 

        MidAcquired = TRUE;

        if (FormatRoutine != NULL) {
            NtStatus = FormatRoutine(UMRX_ASYNCENGINE_ARGUMENTS,
                                     WorkItemHeader,
                                     WorkItemHeaderLength,
                                     &IoStatus->Information);
            if (NtStatus != STATUS_SUCCESS) {
                UMRxDbgTrace(UMRX_TRACE_ERROR,
                             ("%ld: ERROR: UMRxPrepareUserModeRequestBuffer/"
                              "FormatRoutine: Error Val = %08lx.\n",
                              PsGetCurrentThreadId(), NtStatus));
                goto EXIT_THE_FUNCTION;
            } 
        }

        ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));
        lockAcquired = FALSE;

    } else {

        BOOLEAN ReturnVal;

        NtStatus = STATUS_CANCELLED;

        ASSERT(AsyncEngineContext->AsyncEngineContextState == UMRxAsyncEngineContextCancelled);

        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxPrepareUserModeRequestBuffer: OperationCancelled\n",
                      PsGetCurrentThreadId()));

        OperationCancelled = TRUE;

        ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));
        lockAcquired = FALSE;

        //
        // If this is an AsyncOperation, we need to Finalize the context now.
        // There MUST be 3 references on it. One was taken when the context was
        // created. The second was taken in the UMRxSubmitAsyncEngUserModeRequest
        // routine just before the context was placed on the KQueue. The third
        // one was taken in UMRxEnqueueUserModeCallUp to account for the cancel
        // logic. Read the comment in UMRxEnqueueUserModeCallUp for the reason.
        //
        if (AsyncEngineContext->AsyncOperation) {
            ReturnVal = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
            ASSERT(!ReturnVal);
            ReturnVal = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
            ASSERT(!ReturnVal);
            ReturnVal = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
            ASSERT(ReturnVal == TRUE);
        } else {
            //
            // If this is a synchronous operation, then there must be just one
            // reference on it which was taken in UMRxEnqueueUserModeCallUp. The
            // other two would have been taken out by the sync thread handling
            // the operation when it was cancelled.
            //
            ReturnVal = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
        }

    }

EXIT_THE_FUNCTION:

    IoStatus->Status = NtStatus;

    //
    // If some error occured while preparing the user mode buffer, then we
    // need to complete the request, returning the error and not go to the user
    // mode.
    //
    if (NtStatus != STATUS_SUCCESS) {

        NTSTATUS LocalStatus;

        //
        // If we failed after acquiring the MID, we need to release it.
        //
        if (MidAcquired) {
            LocalStatus = UMRxVerifyHeader(UMRefDeviceObject,
                                           WorkItemHeader,
                                           REASSIGN_MID,
                                           &(AsyncEngineContext));
            if (LocalStatus != STATUS_SUCCESS) {
                UMRxDbgTrace(UMRX_TRACE_ERROR,
                             ("%ld: ERROR: UMRxPrepareUserModeRequestBuffer/UMRxVerifyHeader:"
                              " NtStatus = %08lx.\n", PsGetCurrentThreadId(), LocalStatus));
                goto EXIT_THE_FUNCTION;
            }
        }

        //
        // If the operation was cancelled, we did not even Format the request,
        // so there is no point in calling UMRxCompleteUserModeErroneousRequest.
        // If this was an Async request, we would have already finalized the
        // AsyncEngineContext above.
        //
        if (!OperationCancelled) {
            AsyncEngineContext->Status = NtStatus;
            LocalStatus = UMRxCompleteUserModeErroneousRequest(AsyncEngineContext,
                                                               UMRefDeviceObject,
                                                               WorkItemHeader,
                                                               WorkItemHeaderLength);
        }

    }

    //
    // If we have the global context lock acquired, we need to release it now.
    // UMRxCompleteUserModeErroneousRequest has to be called (if needed) before
    // the lock is freed. This is very important.
    //
    if (lockAcquired) {
        ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));
        lockAcquired = FALSE;
    }

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxPrepareUserModeRequestBuffer with "
                  "NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
UMRxCompleteUserModeErroneousRequest(
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    IN PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemHeaderLength
    )
/*++

Routine Description:

    This routine is called to complete a request that failed while the user
    buffer was being formatted. 
    
    IMPORTANT!!!
    This can ONLY be called at one place, in the failure case of
    UMRxPrepareUserModeRequestBuffer. It cannot be used as a general routine.
    Its very important to keep this in mind.

Arguments:

   AsyncEngineContext - The context associated with the request that is being
                        sent to the usermode.

    UMRefDeviceObject - The device object in play.

    WorkItemHeader - The workitem buffer.

    WorkItemHeaderLength - Length of the WorkItemHeader buffer.

Return Value:

    STATUS_SUCCESS or the approprate error status value.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PRX_CONTEXT RxContext;
    PUMRX_ASYNCENG_USERMODE_PRECOMPLETION_ROUTINE PreCompletionRoutine;
    BOOL Call = FALSE;

    PAGED_CODE();

    RxContext = AsyncEngineContext->RxContext;

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxCompleteUserModeErroneousRequest!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxCompleteUserModeErroneousRequest: "
                  "WorkItemHeader = %08lx, AsyncEngineContext = %08lx, "
                  "RxContext = %08lx\n", PsGetCurrentThreadId(), WorkItemHeader,
                  AsyncEngineContext, RxContext));

    PreCompletionRoutine = AsyncEngineContext->UserMode.PrecompletionRoutine;

    if (PreCompletionRoutine != NULL) {
        Call = PreCompletionRoutine(UMRX_ASYNCENGINE_ARGUMENTS,
                                    WorkItemHeader,
                                    WorkItemHeaderLength,
                                    FALSE);
    }

    //
    // We now need to remove the reference taken to handle the cancel logic
    // of the timer thread correctly in UMRxEnqueueUserModeCallUp.
    //
    UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );

    //
    // The PreCompletion routine can finalize the AsyncEngineContext. In such 
    // a situation, we are done. All that the routine below does is to signal
    // the thread that is waiting for this request to complete.
    //
    if (Call) {
        UMRxAsyncEngineCalldownIrpCompletion(&UMRefDeviceObject->DeviceObject,
                                             NULL,
                                             RxContext);
    }

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxCompleteUserModeErroneousRequest with NtStatus = "
                  "%08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
UMRxVerifyHeader(
    IN PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG ReassignmentCmd,
    OUT PUMRX_ASYNCENGINE_CONTEXT *capturedAsyncEngineContext
    )
/*++

Routine Description:

    This routine makes sure that the header passed in is valid. That is, that
    it really refers to the operation encoded. if it does, then it reasigns or
    releases the MID as appropriate.

Arguments:

    UMRefDeviceObject - The reflctor's device object.

    WorkItemHeader - The work item buffer

    ReassignmentCmd -

    capturedAsyncEngineContext - The context associated with the WorkItemHeader.

Return Value:

    STATUS_SUCCESS if the header is good
    STATUS_INVALID_PARAMETER otherwise

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext = NULL;
    PRX_CONTEXT RxContext = NULL;
    UMRX_USERMODE_WORKITEM_HEADER capturedHeader;
    PUMRX_WORKITEM_HEADER_PRIVATE PrivateWorkItemHeader = NULL;

    PAGED_CODE();

    PrivateWorkItemHeader = (PUMRX_WORKITEM_HEADER_PRIVATE)(&capturedHeader);

    capturedHeader = *WorkItemHeader;

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxVerifyHeader!!!!\n", 
                  PsGetCurrentThreadId()));
    
    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxVerifyHeader: UMRefDeviceObject = %08lx, "
                  "WorkItemHeader = %08lx.\n", PsGetCurrentThreadId(), 
                  UMRefDeviceObject, WorkItemHeader)); 

    ExAcquireFastMutex( &(UMRefDeviceObject->MidManagementMutex) );

    AsyncEngineContext = RxMapMidToContext(UMRefDeviceObject->MidAtlas,
                                           PrivateWorkItemHeader->Mid);

    if ((AsyncEngineContext == NULL)
          || (AsyncEngineContext != PrivateWorkItemHeader->AsyncEngineContext)
          || (AsyncEngineContext->UserMode.CallUpMid 
                                                != PrivateWorkItemHeader->Mid)
          || (AsyncEngineContext->UserMode.CallUpSerialNumber 
                                       != PrivateWorkItemHeader->SerialNumber)
          || (&UMRefDeviceObject->RxDeviceObject
                        != AsyncEngineContext->RxContext->RxDeviceObject)  ) {
        //
        // This is a bad packet. Just release and get out.
        //
        ExReleaseFastMutex(&UMRefDeviceObject->MidManagementMutex);
        
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxVerifyHeader/RxMapMidToContext.\n",
                      PsGetCurrentThreadId()));
        
        DbgBreakPoint();
        
        NtStatus = STATUS_INVALID_PARAMETER;
    
    } else {
        
        BOOLEAN Finalized;
        
        RxContext = AsyncEngineContext->RxContext;

        UMRxAsyncEngAssertConsistentLinkage("UMRxVerifyHeaderAndReAssignMid: ", 0);
        
        *capturedAsyncEngineContext = AsyncEngineContext;
        
        if (ReassignmentCmd == DONT_REASSIGN_MID) {
            
            ExReleaseFastMutex(&UMRefDeviceObject->MidManagementMutex);
        
        } else {
            
            //
            // Remove the reference I put before I went off.
            //
            Finalized = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
            ASSERT(!Finalized);
            
            //
            // Now give up the MID. If there is someone waiting then give it to
            // him. Otherwise, just give it back
            //
            if (IsListEmpty(&UMRefDeviceObject->WaitingForMidListhead)) {
                
                PVOID DummyContext;
                
                UMRxDbgTrace(UMRX_TRACE_DETAIL,
                             ("%ld: UMRxVerifyHeader: Giving up mid.\n",
                              PsGetCurrentThreadId()));
                
                RxMapAndDissociateMidFromContext(UMRefDeviceObject->MidAtlas,
                                                 PrivateWorkItemHeader->Mid,
                                                 &DummyContext);
                
                ExReleaseFastMutex(&UMRefDeviceObject->MidManagementMutex);
            
            } else {
                
                PLIST_ENTRY ThisEntry = 
                     RemoveHeadList(&UMRefDeviceObject->WaitingForMidListhead);
                
                AsyncEngineContext = CONTAINING_RECORD(ThisEntry,
                                                       UMRX_ASYNCENGINE_CONTEXT,
                                                       UserMode.WorkQueueLinks);
                UMRxAsyncEngAssertConsistentLinkage(
                                         "UMRxVerifyHeaderAndReAssignMid: ", 0);
                
                UMRxDbgTrace(UMRX_TRACE_DETAIL,
                             ("%ld: UMRxVerifyHeader: Reassigning MID: %08lx.\n",
                              PsGetCurrentThreadId(), PrivateWorkItemHeader->Mid));
                
                RxReassociateMid(UMRefDeviceObject->MidAtlas,
                                 PrivateWorkItemHeader->Mid,
                                 AsyncEngineContext);
                
                ExReleaseFastMutex(&UMRefDeviceObject->MidManagementMutex);
                
                AsyncEngineContext->UserMode.CallUpMid = PrivateWorkItemHeader->Mid;
                
                KeSetEvent(&AsyncEngineContext->UserMode.WaitForMidEvent,
                           IO_NO_INCREMENT,
                           FALSE);
            }
        }
    }

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxVerifyHeader with NtStatus = %08lx.\n", 
                  PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
UMRxCompleteUserModeRequest(
    IN PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader,
    IN ULONG WorkItemHeaderLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    This routine dispatches to a usermode guy using the info in the asyncengine
    context. The workerirp is represented by the captureheader.

Arguments:

    UMRefDeviceObject - The device object in play.

    WorkItemHeader - The workitem buffer.

    WorkItemHeaderLength - Length of the WorkItemHeader buffer.

    IoStatus - The results of the assignment.

Return Value:

    STATUS_SUCCESS if the thread should be released with the IoStatus returned,
    otherwise don't release the thread.


--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext = NULL;
    PRX_CONTEXT RxContext = NULL;
    PUMRX_ASYNCENG_USERMODE_PRECOMPLETION_ROUTINE PreCompletionRoutine = NULL;
    BOOL Call = FALSE, OperationCancelled = FALSE;

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxCompleteUserModeRequest!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxCompleteUserModeRequest: UMRefDeviceObject: %08lx,"
                  " WorkItemHeader = %08lx.\n", PsGetCurrentThreadId(), 
                  UMRefDeviceObject, WorkItemHeader));

    NtStatus = UMRxVerifyHeader(UMRefDeviceObject,
                                WorkItemHeader,
                                REASSIGN_MID,
                                &AsyncEngineContext);
    if (NtStatus != STATUS_SUCCESS) {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxCompleteUserModeRequest/UMRxVerifyHeader:"
                      " NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // If the request has not been cancelled, then we change the state of the
    // context to UMRxAsyncEngineContextBackFromUserMode. If it has been cancelled,
    // we only need to do the cleanup.
    //

    ExAcquireResourceExclusiveLite(&(UMRxAsyncEngineContextListLock), TRUE);

    if (AsyncEngineContext->AsyncEngineContextState == UMRxAsyncEngineContextInUserMode) {
        AsyncEngineContext->AsyncEngineContextState = UMRxAsyncEngineContextBackFromUserMode;
    } else {
        ASSERT(AsyncEngineContext->AsyncEngineContextState == UMRxAsyncEngineContextCancelled);
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxCompleteUserModeRequest: UMRxAsyncEngineContextCancelled. AsyncEngineContext = %08lx\n",
                      PsGetCurrentThreadId(), AsyncEngineContext));
        OperationCancelled = TRUE;
    }

    ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));

    RxContext =  AsyncEngineContext->RxContext;

    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: UMRxCompleteUserModeRequest: AsyncEngineContext = %08lx"
                  ", RxContext = %08lx\n", PsGetCurrentThreadId(), 
                  AsyncEngineContext, RxContext));
    
    PreCompletionRoutine = AsyncEngineContext->UserMode.PrecompletionRoutine;
    
    AsyncEngineContext->Status = WorkItemHeader->Status;

    if (PreCompletionRoutine != NULL) {
        Call = PreCompletionRoutine(UMRX_ASYNCENGINE_ARGUMENTS,
                                    WorkItemHeader,
                                    WorkItemHeaderLength,
                                    OperationCancelled);
    }

    //
    // We now need to remove the reference taken to handle the cancel logic
    // of the timer thread correctly in UMRxEnqueueUserModeCallUp.
    //
    UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );

    //
    // The PreCompletion routine can finalize the AsyncEngineContext. In such 
    // a situation, we are done. All that the routine below does is to signal
    // the thread that is waiting for this request to complete. So, if the
    // operation has been cancelled, we do not need to call
    // UMRxAsyncEngineCalldownIrpCompletion.
    //
    if (Call && !OperationCancelled) {
        UMRxAsyncEngineCalldownIrpCompletion(&UMRefDeviceObject->DeviceObject,
                                             NULL,
                                             RxContext);
    }

EXIT_THE_FUNCTION:

    IoStatus->Status = NtStatus;

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxCompleteUserModeRequest with NtStatus = "
                  "%08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


NTSTATUS
UMRxEnqueueUserModeCallUp(
    UMRX_ASYNCENGINE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This routine enqueues a work request and returns STATUS_PENDING.

Arguments:

    RxContext - The RDBSS context.

    AsyncEngineContext - The reflector's context.

Return Value:

    STATUS_PENDING.

--*/
{
    NTSTATUS NtStatus = STATUS_PENDING;
    PUMRX_DEVICE_OBJECT UMRefDeviceObject
                            = (PUMRX_DEVICE_OBJECT)(RxContext->RxDeviceObject);

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxEnqueueUserModeCallUp!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxEnqueueUserModeCallUp: AsyncEngineContext: %08lx, "
                  "RxContext: %08lx.\n", PsGetCurrentThreadId(), 
                  AsyncEngineContext, RxContext));

    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: UMRxEnqueueUserModeCallUp: Try to Queue up the request.\n",
                  PsGetCurrentThreadId()));
    
    //
    // Before placing an item on the queue, we check to see if the user mode 
    // DAV process is still alive and accepting requests. If its not, we return
    // an error code.
    //
    ExAcquireResourceExclusiveLite(&(UMRefDeviceObject->Q.QueueLock), TRUE);
    if (!UMRefDeviceObject->Q.WorkersAccepted) {
        NtStatus = STATUS_REDIRECTOR_NOT_STARTED;
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: UMRxEnqueueUserModeCallUp: Requests no longer"
                      "accepted by the usermode process. NtStatus = %08lx.\n",
                       PsGetCurrentThreadId(), NtStatus));
        ExReleaseResourceLite(&(UMRefDeviceObject->Q.QueueLock));
        return NtStatus;
    }
    ExReleaseResourceLite(&(UMRefDeviceObject->Q.QueueLock));

    //
    // We need to make sure that the request has not been cancelled. If it has,
    // then we just return STATUS_CANCELLED.
    //

    ExAcquireResourceExclusiveLite(&(UMRxAsyncEngineContextListLock), TRUE);

    if (AsyncEngineContext->AsyncEngineContextState == UMRxAsyncEngineContextCancelled) {
        NtStatus = STATUS_CANCELLED;
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: UMRxEnqueueUserModeCallUp: NtStatus = %08lx.\n",
                       PsGetCurrentThreadId(), NtStatus));
        ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));
        return NtStatus;
    }

    //
    // We now change the state of the context to reflect that is has been sent
    // to the usermode.
    //
    AsyncEngineContext->AsyncEngineContextState = UMRxAsyncEngineContextInUserMode;

    ExReleaseResourceLite(&(UMRxAsyncEngineContextListLock));

    //
    // At this stage the reference count of the AsyncEngineContext should be 2.
    // We need to take another reference to make sure that the context stays 
    // alive in case this request was a synchronous one and got cancelled by
    // the Timeout thread. If the request is synchronous and is cancelled by 
    // the timeout thread, then the thread will remove both the references that
    // we have taken so far. This reference is taken out in before the request
    // is sent to the Format routine or the Precomplete routine depending on
    // when (and if) the request was cancelled.
    //
    InterlockedIncrement( &(AsyncEngineContext->NodeReferenceCount) );

    //
    // Increment the number of workitems.
    //
    InterlockedIncrement(&UMRefDeviceObject->Q.NumberOfWorkItems);

    KeInsertQueue(&UMRefDeviceObject->Q.Queue,
                  &AsyncEngineContext->UserMode.WorkQueueLinks);

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxEnqueueUserModeCallUp with NtStatus = "
                  "%08lx.\n", PsGetCurrentThreadId(), NtStatus));

    return(NtStatus);
}


VOID
UMRxAssignWork(
    IN PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER InputWorkItem,
    IN ULONG InputWorkItemLength,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER OutputWorkItem,
    IN ULONG OutputWorkItemLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    This routine assigns work to a worker thread. If no work is available then
    the thread is captured until work shows up.

Arguments:

    UMRefDeviceObject - The deviceobject that is in play.

    IoControlCode - The control code of the operation.

    InputWorkItem - The Input buffer that came down from the user mode.

    InputWorkItemLength - Length of the InputBuffer.

    OutputWorkItem - The Output buffer that came down from the user mode.

    OutputWorkItemLength - Length of the OutputBuffer.

    IoStatus - The results of the assignment.

Return Value:

    None.

--*/
{
    NTSTATUS NtStatus;
    PETHREAD CurrentThread = PsGetCurrentThread();
    ULONG i;
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext;
    PLIST_ENTRY pListEntry;
    ULONG NumberOfWorkerThreads;

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxAssignWork!!!!\n",
                 PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxAssignWork: UMRefDevObj: %08lx\n", 
                  PsGetCurrentThreadId(), UMRefDeviceObject));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxAssignWork: CurrentThread: %08lx\n", 
                  PsGetCurrentThreadId(), CurrentThread));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxAssignWork: InputWorkItem: %08lx\n", 
                  PsGetCurrentThreadId(), InputWorkItem));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxAssignWork: OutputWorkItem: %08lx\n", 
                  PsGetCurrentThreadId(), OutputWorkItem));

    IoStatus->Information = 0;
    IoStatus->Status = STATUS_CANNOT_IMPERSONATE;

    if (!UMRefDeviceObject->Q.WorkersAccepted) {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxAssignWork: No Workers accepted\n",
                      PsGetCurrentThreadId()));
        return;
    }

    if(OutputWorkItem != NULL) {
        if (OutputWorkItemLength < sizeof(PUMRX_USERMODE_WORKITEM_HEADER)) {
            IoStatus->Status = STATUS_BUFFER_TOO_SMALL;
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxAssignWork: Request buffer is too small\n",
                          PsGetCurrentThreadId()));
            return;
        }
    }

    //
    // We need to check if this IOCTL carries a response to an earlier request
    // with it. The response is present if the InputWorkItem is != NULL. If it 
    // does carry a response, we need to process that response.
    //
    if (InputWorkItem != NULL) {
        
        //
        // If this thread was impersonating a client, we need to revert back
        // and clear the flag.
        //
        if( (InputWorkItem->Flags & UMRX_WORKITEM_IMPERSONATING) ) {
            UMRxDbgTrace(UMRX_TRACE_DETAIL,
                         ("%ld: UMRxAssignWork: InputWorkItem had Impersonating"
                          " flag set.\n", PsGetCurrentThreadId()));
            UMRxRevertClient();
            InputWorkItem->Flags &= ~UMRX_WORKITEM_IMPERSONATING;
        }
        
        //
        // We need to disable APCs on this thread now.
        //
        FsRtlEnterFileSystem();
        
        //
        // Complete the request for which the response has been received.
        //
        NtStatus = UMRxCompleteUserModeRequest(UMRefDeviceObject,
                                               InputWorkItem,
                                               InputWorkItemLength,
                                               IoStatus);
        if (NtStatus != STATUS_SUCCESS) {
            
            IoStatus->Status = NtStatus;
            
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxAssignWork/UMRxCompleteUserModeRequest:"
                         " NtStatus = %08lx\n", PsGetCurrentThreadId(), NtStatus));
            
            FsRtlExitFileSystem();

            return;
        }
    
        FsRtlExitFileSystem();

    } else {
        
        ASSERT(OutputWorkItem != NULL);
        
        //
        // If this thread was impersonating a client, we need to revert back
        // and clear the flag.
        //
        if( (OutputWorkItem->Flags & UMRX_WORKITEM_IMPERSONATING) ) {
            UMRxDbgTrace(UMRX_TRACE_DETAIL,
                         ("%ld: UMRxAssignWork: OutputWorkItem had Impersonating"
                          " flag set.\n", PsGetCurrentThreadId()));
            UMRxRevertClient();
            OutputWorkItem->Flags &= ~UMRX_WORKITEM_IMPERSONATING;
        }
    
    }

    //
    // If this thread only carried a response, we should return now.
    //
    if (OutputWorkItem == NULL) {
        IoStatus->Status = NtStatus;
        return;
    }

    //
    // Now, increment the number of threads.
    //
    InterlockedIncrement( &(UMRefDeviceObject->Q.NumberOfWorkerThreads) );

    for (i = 1; ;i++) {
        
        pListEntry = KeRemoveQueue(&UMRefDeviceObject->Q.Queue, UserMode, NULL); // &UMRefDeviceObject->Q.TimeOut);
        
        if ((ULONG_PTR)pListEntry == STATUS_TIMEOUT) {
            ASSERT(!"STATUS_TIMEOUT Happened");
            if ((i % 5) == 0) {
                UMRxDbgTrace(UMRX_TRACE_DETAIL,
                             ("%ld: UMRxAssignWork/KeRemoveQueue: RepostCnt = "
                              "%d\n", PsGetCurrentThreadId(), i));
            }
            continue;
        }
        
        if ((ULONG_PTR)pListEntry == STATUS_USER_APC) {
            IoStatus->Status = STATUS_USER_APC;
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: UMRxAssignWork/KeRemoveQueue: UsrApc.\n",
                          PsGetCurrentThreadId()));
            break;
        }
        
        //
        // Check to see if the entry is a Poison one. If it is, it means that
        // the usermode process wants to cleanup the worker threads.
        //
        if (pListEntry == &UMRefDeviceObject->Q.PoisonEntry) {
            UMRxDbgTrace(UMRX_TRACE_DETAIL,
                         ("%ld: UMRxAssignWork/KeRemoveQueue: Poison Entry.\n",
                          PsGetCurrentThreadId()));
            KeInsertQueue(&UMRefDeviceObject->Q.Queue, pListEntry);
            goto FINALLY;
        }

        //
        // We need to disable APCs on this thread now.
        //
        FsRtlEnterFileSystem();

        //
        // Decrement the number of workitems.
        //
        InterlockedDecrement(&UMRefDeviceObject->Q.NumberOfWorkItems);
        
        AsyncEngineContext = CONTAINING_RECORD(pListEntry,
                                               UMRX_ASYNCENGINE_CONTEXT,
                                               UserMode.WorkQueueLinks);
        
        ASSERT(NodeType(AsyncEngineContext) == UMRX_NTC_ASYNCENGINE_CONTEXT);

        NtStatus = UMRxPrepareUserModeRequestBuffer(AsyncEngineContext,
                                                    UMRefDeviceObject,
                                                    OutputWorkItem,
                                                    OutputWorkItemLength,
                                                    IoStatus);
        if (NtStatus != STATUS_SUCCESS) {
            
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxAssignWork/"
                          "UMRxPrepareUserModeRequestBuffer: NtStatus = %08lx\n", 
                          PsGetCurrentThreadId(), NtStatus));
            
            FsRtlExitFileSystem();

            continue;
        }

        ASSERT(((IoStatus->Status == STATUS_SUCCESS) ||
                (IoStatus->Status == STATUS_INVALID_PARAMETER)));

        FsRtlExitFileSystem();

        break;
    
    }

FINALLY:
    //
    // Now, decrement the number of threads.
    //
    NumberOfWorkerThreads =
            InterlockedDecrement(&UMRefDeviceObject->Q.NumberOfWorkerThreads);

    //
    // Check to see if the threads are being cleaned up by the user mode 
    // process. When this happens, the WorkersAccepted field of the device
    // object is set to FALSE. If the threads are being cleaned up and if I was
    // the last thread waiting on the KQUEUE, its my responsibility to set the
    // RunDownEvent.
    //
    if ((NumberOfWorkerThreads == 0) && !UMRefDeviceObject->Q.WorkersAccepted){
        KeSetEvent(&UMRefDeviceObject->Q.RunDownEvent,
                   IO_NO_INCREMENT,
                   FALSE);
        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxAssignWork: Last Thread.\n",
                      PsGetCurrentThreadId()));
    }

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxAssignWork with IoStatus->Status = %08lx\n",
                 PsGetCurrentThreadId(), IoStatus->Status));

    return;
}


VOID
UMRxReleaseCapturedThreads(
    IN OUT PUMRX_DEVICE_OBJECT UMRefDeviceObject
    )
/*++

Routine Description:

    

Arguments:

    UMRefDeviceObject - Device object whose threads are to be released.

Return Value:

    none.
    
--*/
{
    LONG NumberWorkerThreads;

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxReleaseCapturedThreads!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxReleaseCapturedThreads: UMRefDeviceObject: %08lx.\n", 
                  PsGetCurrentThreadId(), UMRefDeviceObject));

    //
    // We need to disable APCs on this thread now.
    //
    FsRtlEnterFileSystem();
    
    //
    // The WorkersAccepted field is initialized to TRUE when the device object
    // gets created and it set to FALSE here. If more than one thread tries to
    // release the threads, only the first one should do the job. The rest
    // should just return. This check is performed below before the thread is
    // allowed to proceed with the release of ser mode worker threads.
    //
    ExAcquireResourceExclusiveLite(&(UMRefDeviceObject->Q.QueueLock), TRUE);

    if (!UMRefDeviceObject->Q.WorkersAccepted) {
        
        ExReleaseResourceLite(&(UMRefDeviceObject->Q.QueueLock));
        
        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: Worker threads have already returned.\n",
                      PsGetCurrentThreadId()));

        FsRtlExitFileSystem();

        return;
    
    }

    UMRefDeviceObject->Q.WorkersAccepted = FALSE;

    ExReleaseResourceLite(&(UMRefDeviceObject->Q.QueueLock));

    //
    // Insert the poison entry. When a worker thread sees this, it realizes that
    // the usermode process intends to cleanup the worker threads.
    //
    KeInsertQueue(&UMRefDeviceObject->Q.Queue,
                  &UMRefDeviceObject->Q.PoisonEntry);

    NumberWorkerThreads =
         InterlockedCompareExchange(&UMRefDeviceObject->Q.NumberOfWorkerThreads,
                                    0,
                                    0);

    if (NumberWorkerThreads != 0) {
        //
        // The RunDownEvent is set by the last thread just before it returns to
        // the usermode.
        //
        KeWaitForSingleObject(&UMRefDeviceObject->Q.RunDownEvent,
                              Executive,
                              UserMode,
                              FALSE,
                              NULL);
    }

    FsRtlExitFileSystem();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxReleaseCapturedThreads.\n",
                  PsGetCurrentThreadId()));
    
    return;
}


PBYTE
UMRxAllocateSecondaryBuffer(
    IN OUT PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    SIZE_T Length
    )
/*++

Routine Description:

    This routine allocates memory for the secondary buffer of the
    AsyncEngineContext.

Arguments:

    AsyncEngineContext - The reflector's context.

    Length - The length in bytes of the buffer to be allocated.

Return Value:

    Pointer to the buffer or NULL.

--*/
{
    PBYTE rv = NULL;
    PRX_CONTEXT RxContext = AsyncEngineContext->RxContext;
    PUMRX_DEVICE_OBJECT UMRefDeviceObject;
    PUMRX_SECONDARY_BUFFER buf = NULL;
    PUMRX_SHARED_HEAP sharedHeap;
    PLIST_ENTRY listEntry;

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxAllocateSecondaryBuffer.\n",
                  PsGetCurrentThreadId()));
    
    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxAllocateSecondaryBuffer: AsyncEngineContext: %08lx,"
                  " Bytes Asked: %d.\n",
                  PsGetCurrentThreadId(), AsyncEngineContext, Length));

    UMRefDeviceObject = (PUMRX_DEVICE_OBJECT)(RxContext->RxDeviceObject);
    
    if (Length > UMRefDeviceObject->NewHeapSize) {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxAllocateSecondaryBuffer: Length > NewHeapSize.\n",
                      PsGetCurrentThreadId()));
        return NULL;
    }

    ExAcquireResourceExclusiveLite(&UMRefDeviceObject->HeapLock, TRUE);

    listEntry = UMRefDeviceObject->SharedHeapList.Flink;

    //
    // We search the list of heaps for just the added safety of not letting
    // the user mode corrupt the pointer and us going off corrupting random
    // memory. Only the local shared heap should have the chance at corruption.
    //
    while (listEntry != &UMRefDeviceObject->SharedHeapList && buf == NULL) {

        sharedHeap = (PUMRX_SHARED_HEAP) CONTAINING_RECORD(listEntry,
                                                           UMRX_SHARED_HEAP,
                                                           HeapListEntry);
        listEntry = listEntry->Flink;

        if (sharedHeap->HeapFull) {
            continue;
        }

        buf = (PUMRX_SECONDARY_BUFFER)RtlAllocateHeap(
                                       sharedHeap->Heap,
                                       HEAP_NO_SERIALIZE,
                                       Length + sizeof(UMRX_SECONDARY_BUFFER));
        if (buf != NULL) {
            break;
        }
    }

    if (buf == NULL) {

        //
        // We won't get into the situation where the heap is too small for
        // the object we're trying to allocate even though we just allocated
        // a fresh heap.
        //

        SIZE_T heapSize = max(UMRefDeviceObject->NewHeapSize, 2 * Length);

        sharedHeap = UMRxAddSharedHeap(UMRefDeviceObject, heapSize);

        if (sharedHeap != NULL) {

            UMRxDbgTrace(UMRX_TRACE_DETAIL,
                         ("%ld: UMRxAllocateSecondaryBuffer: sharedHeap: %08lx.\n", 
                          PsGetCurrentThreadId(), sharedHeap));

            buf = (PUMRX_SECONDARY_BUFFER)
                               RtlAllocateHeap(
                                        sharedHeap->Heap,
                                        HEAP_NO_SERIALIZE,
                                        Length + sizeof(UMRX_SECONDARY_BUFFER));
        }
    }

    if (buf != NULL) {
        //
        // We insert into the list while holding the HeapLock so that we
        // don't have to worry about the list getting corrupted.
        //

        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxAllocateSecondaryBuffer: buf: %08lx.\n", 
                      PsGetCurrentThreadId(), buf));

        sharedHeap->HeapAllocationCount++;

        buf->Signature = UMRX_SECONDARY_BUFFER_SIGNATURE;
        buf->AllocationSize = Length;
        buf->SourceSharedHeap = sharedHeap;

        InsertHeadList(&AsyncEngineContext->AllocationList, &buf->ListEntry);

        rv = (PCHAR) &buf->Buffer[0];
    }

    ExReleaseResourceLite(&UMRefDeviceObject->HeapLock);

    if (rv == NULL) {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxAllocateSecondaryBuffer allocation failed"
                      ". Size = %08lx\n", PsGetCurrentThreadId(), Length));
        return(NULL);
    }
    
    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxAllocateSecondaryBuffer. rv = %08lx.\n",
                  PsGetCurrentThreadId(), rv));
    
    return rv;
}


NTSTATUS
UMRxFreeSecondaryBuffer(
    IN OUT PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext,
    PBYTE BufferToFree
    )
/*++

Routine Description:

    This routine frees up the memory allocated for the secondary buffer of the
    AsyncEngineContext.

Arguments:

    AsyncEngineContext - The reflector's context.

Return Value:

    none.

--*/
{
    PRX_CONTEXT RxContext = AsyncEngineContext->RxContext;
    PUMRX_DEVICE_OBJECT UMRefDeviceObject;
    PUMRX_SECONDARY_BUFFER buf;
    PUMRX_SHARED_HEAP sharedHeap;
    PLIST_ENTRY listEntry;
    BOOLEAN checkVal = FALSE;

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: Entering UMRxFreeSecondaryBuffer.\n",
                  PsGetCurrentThreadId()));
    
    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxFreeSecondaryBuffer: AsyncEngineContext: %08lx,"
                  " BufferToFree: %08lx.\n",
                  PsGetCurrentThreadId(), AsyncEngineContext, BufferToFree));
    
    UMRefDeviceObject = (PUMRX_DEVICE_OBJECT)(RxContext->RxDeviceObject);

    ASSERT(BufferToFree != NULL);

    buf = CONTAINING_RECORD(BufferToFree, UMRX_SECONDARY_BUFFER, Buffer);
    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: UMRxFreeSecondaryBuffer: buf: %08lx.\n", 
                  PsGetCurrentThreadId(), buf));
    
    ASSERT(buf->SourceSharedHeap);

    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: UMRxFreeSecondaryBuffer: buf->SourceSharedHeap: %08lx.\n", 
                  PsGetCurrentThreadId(), buf->SourceSharedHeap));
    

    ExAcquireResourceExclusiveLite(&UMRefDeviceObject->HeapLock, TRUE);

    listEntry = UMRefDeviceObject->SharedHeapList.Flink;

    //
    // We search the list of heaps for just the added safety of not letting
    // the user mode corrupt the pointer and us going off corrupting random
    // memory.  only the local shared heap should have the chance at corruption.
    //
    while (listEntry != &UMRefDeviceObject->SharedHeapList) {
        sharedHeap = (PUMRX_SHARED_HEAP) CONTAINING_RECORD(listEntry,
                                                           UMRX_SHARED_HEAP,
                                                           HeapListEntry);
        ASSERT(sharedHeap);
        
        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxFreeSecondaryBuffer: sharedHeap: %08lx.\n", 
                      PsGetCurrentThreadId(), sharedHeap));
        
        if (sharedHeap == buf->SourceSharedHeap) {
            break;
        }
        listEntry = listEntry->Flink;
    }

    ASSERT(listEntry != &UMRefDeviceObject->SharedHeapList);

    if (listEntry == &UMRefDeviceObject->SharedHeapList) {

        //
        // Ouch. This block isn't in any that we know about.
        //
        ExReleaseResourceLite(&UMRefDeviceObject->HeapLock);
        return STATUS_INVALID_PARAMETER;
    }

    RemoveEntryList(&buf->ListEntry);

    sharedHeap->HeapAllocationCount--;

    checkVal = RtlFreeHeap(sharedHeap->Heap, 0, buf);
    if (!checkVal) {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxFreeSecondaryBuffer/RtlFreeHeap.\n",
                      PsGetCurrentThreadId()));
    }
    
    UMRxDbgTrace(UMRX_TRACE_DETAIL,
                 ("%ld: UMRxFreeSecondaryBuffer: sharedHeap->Heap = %08lx.\n",
                  PsGetCurrentThreadId(), sharedHeap->Heap));
    
    sharedHeap->HeapFull = FALSE;

    if (sharedHeap->HeapAllocationCount == 0) {
        //
        //  If this was the last allocation in this heap, let's see if there's
        //  any other empty heaps. If there are, we'll free one of them.
        //  This prevents us from holding the max number of heaps during
        //  varying loads.
        //

        PUMRX_SHARED_HEAP secondarySharedHeap;

        listEntry = UMRefDeviceObject->SharedHeapList.Flink;

        while (listEntry != &UMRefDeviceObject->SharedHeapList) {

            secondarySharedHeap = (PUMRX_SHARED_HEAP) 
                                            CONTAINING_RECORD(listEntry,
                                                              UMRX_SHARED_HEAP,
                                                              HeapListEntry);
            
            if ( (secondarySharedHeap->HeapAllocationCount == 0) &&
                 (secondarySharedHeap != sharedHeap) ) {
                break;
            }
            listEntry = listEntry->Flink;
        }

        if (listEntry != &UMRefDeviceObject->SharedHeapList) {
            PVOID HeapHandle;
            
            RemoveEntryList(listEntry);
            
            HeapHandle = RtlDestroyHeap(secondarySharedHeap->Heap);
            if (HeapHandle != NULL) {
                UMRxDbgTrace(UMRX_TRACE_ERROR,
                             ("%ld: ERROR: UMRxFreeSecondaryBuffer/RtlDestroyHeap.\n",
                              PsGetCurrentThreadId()));
            }
            
            ZwFreeVirtualMemory(NtCurrentProcess(),
                                &secondarySharedHeap->VirtualMemoryBuffer,
                                &secondarySharedHeap->VirtualMemoryLength,
                                MEM_RELEASE);
            
            RxFreePool(secondarySharedHeap);
        }
    }

    ExReleaseResourceLite(&UMRefDeviceObject->HeapLock);
    
    return STATUS_SUCCESS;
}


PUMRX_SHARED_HEAP
UMRxAddSharedHeap(
    PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    SIZE_T HeapSize
    )
/*++

Routine Description:

    This routine allocates the shared heap which is used to pass stuff onto the 
    user mode. It allocated virtual memory, creates a heap and returns a pointer
    to it. If the functions fails a NULL is returned.

Arguments:

    UMRefDeviceObject - The Reflector's device object.
    
    HeapSize - The size of the heap being allocated.

Return Value:

    Pointer to the creatted heap or NULL.

--*/
{
    PBYTE buff = NULL;
    NTSTATUS err;
    PUMRX_SHARED_HEAP sharedHeap = NULL;

    PAGED_CODE();

    //
    //  We assume the device object's heap lock is held coming in here.
    //

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxAddSharedHeap.\n", PsGetCurrentThreadId()));
    
    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxAddSharedHeap: UMRefDeviceObject: %08lx, "
                  "HeapSize: %d.\n", 
                  PsGetCurrentThreadId(), UMRefDeviceObject, HeapSize));
    
    //
    // We allocate the heap structure in paged pool rather than in virtual
    // memory so that there is zero possiblity that user mode code could
    // corrupt our list of heaps.  It can still corrupt a heap, but that's
    // something we'll have to live with for now.
    //

    sharedHeap = RxAllocatePoolWithTag(PagedPool,
                                       sizeof(UMRX_SHARED_HEAP),
                                       UMRX_SHAREDHEAP_POOLTAG);
    if (sharedHeap == NULL) {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxAddSharedHeap/RxAllocatePoolWithTag: "
                      "Couldn't get the sharedHeap structure!\n",
                      PsGetCurrentThreadId()));
        return NULL;
    }

    sharedHeap->VirtualMemoryLength = HeapSize;
    sharedHeap->VirtualMemoryBuffer = NULL;
    sharedHeap->Heap = NULL;
    sharedHeap->HeapAllocationCount = 0;
    sharedHeap->HeapFull = FALSE;

    err = ZwAllocateVirtualMemory(NtCurrentProcess(),
                                  (PVOID *) &buff,
                                  0,
                                  &sharedHeap->VirtualMemoryLength,
                                  MEM_COMMIT,
                                  PAGE_READWRITE);
    if (NT_SUCCESS(err)) {
        SIZE_T ReserveSize = HeapSize;
        sharedHeap->Heap = RtlCreateHeap(HEAP_NO_SERIALIZE,
                                         (PVOID) buff,
                                         ReserveSize,
                                         PAGE_SIZE,
                                         NULL,
                                         0);
        if (sharedHeap->Heap == NULL) {
            err = STATUS_NO_MEMORY;
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxAddSharedHeap/RtlCreateHeap: "
                         "NtStatus = %08lx\n", PsGetCurrentThreadId(), err));
            ZwFreeVirtualMemory(NtCurrentProcess(),
                                (PVOID *) &buff,
                                &HeapSize,
                                MEM_RELEASE);
            RxFreePool(sharedHeap);
            sharedHeap = NULL;
        } else {
            UMRxDbgTrace(UMRX_TRACE_DETAIL,
                         ("%ld: UMRxAddSharedHeap: sharedHeap->Heap = %08lx.\n",
                          PsGetCurrentThreadId(), sharedHeap->Heap));

            sharedHeap->VirtualMemoryBuffer = buff;
            
            UMRxDbgTrace(UMRX_TRACE_DETAIL,
                         ("%ld: UMRxAddSharedHeap: "
                          "&UMRefDeviceObject->SharedHeapList: %08lx.\n",
                          PsGetCurrentThreadId(),
                          &UMRefDeviceObject->SharedHeapList));
            
            InsertHeadList(&UMRefDeviceObject->SharedHeapList,
                            &sharedHeap->HeapListEntry);
        }
    } else {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxAddSharedHeap/ZwAllocateVirtualMemory:"
                      " NtStatus = %08lx.\n", PsGetCurrentThreadId(), err));
        RxFreePool(sharedHeap);
        sharedHeap = NULL;
    }
    
    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxAddSharedHeap.\n", PsGetCurrentThreadId()));
    
    return sharedHeap;
}

#if DBG
#define UMRX_DEBUG_KEY L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\MRxDAV\\Parameters"
#define UMRX_DEBUG_VALUE L"UMRxDebugFlag"
#endif

NTSTATUS
UMRxInitializeDeviceObject(
    OUT PUMRX_DEVICE_OBJECT UMRefDeviceObject,
    IN USHORT MaxNumberMids,
    IN USHORT InitialMids,
    IN SIZE_T HeapSize
    )
/*++

Routine Description:

    This initializes the UMRX_DEVICE_OBJECT structure.  The shared heap
    is created for shared memory between kernel and user.

Arguments:

    UMRefDeviceObject - The reflector's device object to be initialized.

    MaxNumberMids - Maximum number of mids to be used.

    InitialMids - Initial number of mids allocated.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS err = STATUS_SUCCESS;
    PRX_MID_ATLAS MidAtlas = NULL;

    PAGED_CODE();

    //
    // This is the first reflector routine called by the Mini-Redir and so is
    // the place where the UMRxDebugVector should be initialized.
    //
#if DBG
    UMRxReadDWORDFromTheRegistry(UMRX_DEBUG_KEY, UMRX_DEBUG_VALUE, &(UMRxDebugVector));
#endif

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxInitializeDeviceObject!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxInitializeDeviceObject: UMRefDeviceObject: %08lx\n", 
                  PsGetCurrentThreadId(), UMRefDeviceObject));
    
    //
    // MidAtlas.
    //
    MidAtlas = RxCreateMidAtlas(MaxNumberMids, InitialMids);
    if (MidAtlas == NULL) {
        err = STATUS_INSUFFICIENT_RESOURCES;
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxInitializeDeviceObject/RxCreateMidAtlas:"
                      " NtStatus = %08lx.\n", PsGetCurrentThreadId(), err));
        return(err);
    }
    UMRefDeviceObject->MidAtlas = MidAtlas;
    InitializeListHead(&UMRefDeviceObject->WaitingForMidListhead);
    ExInitializeFastMutex(&UMRefDeviceObject->MidManagementMutex);

    //
    // Initialize the global AsyncEngineContext list and the mutex that is used
    // to synchronize access to it.
    //
    InitializeListHead( &(UMRxAsyncEngineContextList) );
    ExInitializeResourceLite( &(UMRxAsyncEngineContextListLock) );

    //
    // Heap.
    //
    UMRefDeviceObject->NewHeapSize = HeapSize;
    InitializeListHead(&UMRefDeviceObject->SharedHeapList);
    ExInitializeResourceLite(&UMRefDeviceObject->HeapLock);

    //
    // KQUEUE.
    //
    KeInitializeQueue(&UMRefDeviceObject->Q.Queue, 0);
    ExInitializeResourceLite(&(UMRefDeviceObject->Q.QueueLock));
    UMRefDeviceObject->Q.TimeOut.QuadPart  = -10 * TICKS_PER_SECOND;
    KeInitializeEvent(&UMRefDeviceObject->Q.RunDownEvent,
                      NotificationEvent,
                      FALSE);
    UMRefDeviceObject->Q.NumberOfWorkerThreads = 0;
    UMRefDeviceObject->Q.NumberOfWorkItems = 0;
    UMRefDeviceObject->Q.WorkersAccepted = TRUE;

    //
    // This specifies the alignment requirement for unbuffered writes. Assuming
    // that the sector size on disks is 512 bytes, the size of the writes should
    // be a multiple of the 512 (SectorSize).
    //
    UMRefDeviceObject->SectorSize = 512;

    RxMakeLateDeviceAvailable(&UMRefDeviceObject->RxDeviceObject);

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxInitializeDeviceObject with NtStatus = "
                  "%08lx.\n", PsGetCurrentThreadId(), STATUS_SUCCESS));

    return STATUS_SUCCESS;
}

NTSTATUS
UMRxCleanUpDeviceObject(
    PUMRX_DEVICE_OBJECT UMRefDeviceObject
    )
/*++

Routine Description:

    This destorys the instance data for a UMReflector device object.

Arguments:

    UMRefDeviceObject - The reflector's device object to be destroyed.

Return Value:

    NTSTATUS

--*/
{
    PLIST_ENTRY pFirstListEntry, pNextListEntry;
    BOOLEAN FoundPoisoner = FALSE;

    PAGED_CODE();

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxCleanUpDeviceObject!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxCleanUpDeviceObject: UMRefDeviceObject: %08lx.\n", 
                  PsGetCurrentThreadId(), UMRefDeviceObject));

    //
    // Delete the resource that was created to synchronize access to the 
    // AsyncEngineContext list.
    //
    ExDeleteResourceLite( &(UMRxAsyncEngineContextListLock) );

    //
    // Heap.
    //
    ExDeleteResourceLite(&UMRefDeviceObject->HeapLock);
    
    //
    // MidAtlas.
    //
    if (UMRefDeviceObject->MidAtlas != NULL) {
        RxDestroyMidAtlas(UMRefDeviceObject->MidAtlas, NULL);
    }

    //
    // KQUEUE.
    //
    pFirstListEntry = KeRundownQueue(&UMRefDeviceObject->Q.Queue);
    if (pFirstListEntry != NULL) {
        pNextListEntry = pFirstListEntry;
        do {
            PLIST_ENTRY ThisEntry =  pNextListEntry;
            pNextListEntry = pNextListEntry->Flink;
            if (ThisEntry != &UMRefDeviceObject->Q.PoisonEntry) {
                UMRxDbgTrace(UMRX_TRACE_ERROR,
                             ("%ld: ERROR: UMRxCleanUpDeviceObject: "
                              "Non Poisoner in the queue: %08lx\n", 
                              PsGetCurrentThreadId(), ThisEntry));
                DbgBreakPoint();
            } else {
                FoundPoisoner = TRUE;
            }
        } while (pNextListEntry != pFirstListEntry);
    }
    ExDeleteResourceLite(&(UMRefDeviceObject->Q.QueueLock));
    
    if (!FoundPoisoner) {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxCleanUpDeviceObject: "
                      "No Poisoner in queue.\n", PsGetCurrentThreadId()));
    }

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxCleanUpDeviceObject.\n",
                  PsGetCurrentThreadId()));

    return STATUS_SUCCESS;
}


NTSTATUS
UMRxImpersonateClient(
    IN PSECURITY_CLIENT_CONTEXT SecurityClientContext,
    IN OUT PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader
    )
/*++

Routine Description:

    This routine impersonates a worker thread to get the credentials of the
    client of the I/O operation.

Arguments:

    SecurityClientContext - The security context of the client used in the
                            impersonation call.
                            
    WorkItemHeader - The workitem associated with this request. If the 
                     impersonation succeeds, the UMRX_WORKITEM_IMPERSONATING
                     flag is set in the workitem.

Return Value:

    An NTSTATUS value.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(SecurityClientContext != NULL);

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxImpersonateClient!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxImpersonateClient: SecurityClientContext: %08lx.\n",
                  PsGetCurrentThreadId(), SecurityClientContext));

    NtStatus = SeImpersonateClientEx(SecurityClientContext, NULL);
    if (!NT_SUCCESS(NtStatus)) {
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxImpersonateClient/SeImpersonateClientEx"
                     ". NtStatus = %08lx.\n", PsGetCurrentThreadId(), NtStatus));
    } else {
        //
        // Set the impersonating flag in the workitem.
        //
        UMRxDbgTrace(UMRX_TRACE_DETAIL,
                     ("%ld: UMRxImpersonateClient: Setting the Impersonation"
                      " Flag.\n", PsGetCurrentThreadId()));
        WorkItemHeader->Flags |= UMRX_WORKITEM_IMPERSONATING;
    }

    return NtStatus;
}


NTSTATUS
UMRxAsyncEngOuterWrapper(
    IN PRX_CONTEXT RxContext,
    IN ULONG AdditionalBytes,
    IN PUMRX_ASYNCENG_CONTEXT_FORMAT_ROUTINE ContextFormatRoutine,
    USHORT FormatContext,
    IN PUMRX_ASYNCENG_CONTINUE_ROUTINE Continuation,
    IN PSZ RoutineName
    )
/*++

Routine Description:

   This routine is common to guys who use the async context engine. It has the
   responsibility for getting a context, initing, starting and finalizing it, 
   but the internal guts of the procesing is via the continuation routine 
   that is passed in.

Arguments:

    RxContext  - The RDBSS context.
    
    AdditionalBytes - The Additional bytes to be allocated for the context.
                      Some Mini-Redirs might need them.
    
    ContextFormatRoutine - The routine that formats the Mini-Redirs portion of
                           the context. This may be NULL if the Mini-Redir does
                           not need any extra context fields.              
                           
    FormatContext - The context passed to the ContextFormatRoutine. Its 
                    not relvant if the ContextFormatRoutine is NULL.                          
    
    Continuation - The Continuation routine which handles this I/O Request once 
                   AsynEngineContext has been setup.
                   
    RotuineName - The name of the entry routine that called this function.
    
Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PUMRX_ASYNCENGINE_CONTEXT AsyncEngineContext = NULL;
    ULONG SizeToAllocateInBytes;

    PAGED_CODE();
    
    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Entering UMRxAsyncEngOuterWrapper!!!!\n",
                  PsGetCurrentThreadId()));

    UMRxDbgTrace(UMRX_TRACE_CONTEXT,
                 ("%ld: UMRxAsyncEngOuterWrapper: "
                  "RxContext: %08lx, Calling Routine: %s.\n", 
                  PsGetCurrentThreadId(), RxContext, RoutineName));

    SizeToAllocateInBytes = SIZEOF_UMRX_ASYNCENGINE_CONTEXT + AdditionalBytes;

    //
    // Try to create an AsyncEngContext for this operation. If unsuccessful,
    // return failure.
    //
    AsyncEngineContext = UMRxCreateAsyncEngineContext(RxContext,
                                                      SizeToAllocateInBytes);

    if (AsyncEngineContext == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        UMRxDbgTrace(UMRX_TRACE_ERROR,
                     ("%ld: ERROR: UMRxAsyncEngOuterWrapper/"
                      "UMRxCreateAsyncEngineContext: Error Val = %08lx\n", 
                      PsGetCurrentThreadId(), NtStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Set the continuation routine.
    //
    AsyncEngineContext->Continuation = Continuation;

    //
    // If the Mini-Redir supplied a ContextFormatRoutine, now is the time to
    // call it.
    //
    if (ContextFormatRoutine) {
        NtStatus = ContextFormatRoutine(AsyncEngineContext, FormatContext);
        if (NtStatus != STATUS_SUCCESS) {
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxAsyncEngOuterWrapper/"
                          "ContextFormatRoutine: Error Val = %08lx\n", 
                          PsGetCurrentThreadId(), NtStatus));
            goto EXIT_THE_FUNCTION;
        }
    }

    //
    // Now that we have the context ready, call the continuation routine.
    //
    if (Continuation) {
        NtStatus = Continuation(UMRX_ASYNCENGINE_ARGUMENTS);
        if ( NtStatus != STATUS_SUCCESS && NtStatus != STATUS_PENDING ) {
            UMRxDbgTrace(UMRX_TRACE_ERROR,
                         ("%ld: ERROR: UMRxAsyncEngOuterWrapper/Continuation:"
                          " Error Val = %08lx, Calling Routine: %s.\n", 
                          PsGetCurrentThreadId(), NtStatus, RoutineName));
        }
    }

EXIT_THE_FUNCTION:

    if (NtStatus != STATUS_PENDING) {
        if (AsyncEngineContext) {
            BOOLEAN FinalizationComplete;
            FinalizationComplete = UMRxFinalizeAsyncEngineContext( &(AsyncEngineContext) );
        }
    }

    UMRxDbgTrace(UMRX_TRACE_ENTRYEXIT,
                 ("%ld: Leaving UMRxAsyncEngOuterWrapper with NtStatus = "
                  "%08lx\n", PsGetCurrentThreadId(), NtStatus));

    return (NtStatus);
}


NTSTATUS
UMRxReadDWORDFromTheRegistry(
    IN PWCHAR RegKey,
    IN PWCHAR ValueToRead,
    OUT LPDWORD DataRead
    )
/*++

Routine Description:

    This routine reads a DWORD value from the registry.

Arguments:

    RegKey - The registry key who value needs to be read.
    
    ValueToRead - The DWORD value to be read.
    
    DataRead - The data is copied into this and returned back to the caller.

Return Value:

    NTSTATUS value.    

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    HKEY SubKey = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeKeyName, UnicodeValueName;
    PKEY_VALUE_PARTIAL_INFORMATION PartialInfo = NULL;
    ULONG SizeInBytes = 0, SizeReturned = 0;

    PAGED_CODE();

    RtlInitUnicodeString(&(UnicodeKeyName), RegKey);

    InitializeObjectAttributes(&(ObjectAttributes),
                               &(UnicodeKeyName),
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = ZwOpenKey(&(SubKey), KEY_READ, &(ObjectAttributes));
    if (NtStatus != STATUS_SUCCESS) {
        DbgPrint("%ld: ERROR: UMRxReadDWORDFromTheRegistry/ZwOpenKey: NtStatus = %08lx\n",
                 PsGetCurrentThreadId(), NtStatus);
        goto EXIT_THE_FUNCTION;
    }

    RtlInitUnicodeString(&(UnicodeValueName), ValueToRead);

    //
    // The size we need has to be the size of the structure plus the size of a 
    // DWORD since thats what we are going to be reading.
    //
    SizeInBytes = ( sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD) );

    PartialInfo = RxAllocatePool(PagedPool, SizeInBytes);
    if (PartialInfo == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        DbgPrint("%ld: ERROR: UMRxReadDWORDFromTheRegistry/RxAllocatePool: NtStatus = %08lx\n",
                 PsGetCurrentThreadId(), NtStatus);
        goto EXIT_THE_FUNCTION;
    }

    NtStatus = ZwQueryValueKey(SubKey,
                               &(UnicodeValueName),
                               KeyValuePartialInformation,
                               (PVOID)PartialInfo,
                               SizeInBytes,
                               &(SizeReturned));
    if (NtStatus != STATUS_SUCCESS) {
        DbgPrint("%ld: ERROR: UMRxReadDWORDFromTheRegistry/ZwQueryValueKey: NtStatus = %08lx\n",
                 PsGetCurrentThreadId(), NtStatus);
        goto EXIT_THE_FUNCTION;
    }

    RtlCopyMemory(DataRead, PartialInfo->Data, PartialInfo->DataLength);

EXIT_THE_FUNCTION:

    if (SubKey) {
        NtClose(SubKey);
        SubKey = NULL;
    }

    if (PartialInfo) {
        RxFreePool(PartialInfo);
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\reflector\user\init.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This is the init/term entry points for the user mode library of the
    user mode reflector.  This implements UMReflectorRegister,
    UMReflectorUnregister, & UMReflectorReleaseThreads.

Author:

    Andy Herron (andyhe) 19-Apr-1999

Environment:

    User Mode - Win32

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop

#include <shlobj.h>


typedef 
BOOL 
(*PFN_GETWININET_CACHE_PATH) (
    HWND hwnd, 
    LPWSTR pszPath, 
    int csidl, 
    BOOL fCreate
    );


ULONG
UMReflectorRegister (
    PWCHAR DriverDeviceName,
    ULONG ReflectorVersion,
    PUMRX_USERMODE_REFLECT_BLOCK *Reflector
    )
/*++

Routine Description:

    This routine registers the user mode process with the kernel mode component.
    We'll register this user mode process with the driver's reflector.

Arguments:

    DriverDeviceName - Must be a valid name of the form L"\\Device\\foobar",
                       where foobar is the device name registered with
                       RxRegisterMinirdr.

    ReflectorVersion - The version of the library.

    Reflector - This is returned by the call and points to an opaque structure 
                that should be passed to subsequent calls.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    ULONG rc = STATUS_SUCCESS;
    ULONG sizeRequired;
    PUMRX_USERMODE_REFLECT_BLOCK reflectorInstance = NULL;
    UNICODE_STRING UMRxDeviceName;
    UNICODE_STRING DeviceObjectName;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG driverDeviceNameLength;

    if (ReflectorVersion != UMREFLECTOR_CURRENT_VERSION) {
        //
        // Whoops. Mismatch here. We should support backward levels but right
        // now there aren't any so we just bail.
        //
        rc = ERROR_NOT_SUPPORTED;
        goto errorExit;
    }

    if (DriverDeviceName == NULL || Reflector == NULL) {
        rc = ERROR_INVALID_PARAMETER;
        goto errorExit;
    }

    //
    // Calculate the size to be allocated for the UMRX_USERMODE_REFLECT_BLOCK
    // and the device name following it.
    //
    sizeRequired = sizeof(UMRX_USERMODE_REFLECT_BLOCK);
    driverDeviceNameLength = lstrlenW(DriverDeviceName) + 1;
    sizeRequired += driverDeviceNameLength * sizeof(WCHAR);

    reflectorInstance = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, sizeRequired);
    *Reflector = reflectorInstance;
    if (reflectorInstance == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto errorExit;
    }

    try {
        InitializeCriticalSection( &(reflectorInstance->Lock) );
    } except(EXCEPTION_EXECUTE_HANDLER) {
          rc = GetExceptionCode();
          RlDavDbgPrint(("%ld: ERROR: UMReflectorRegister/InitializeCriticalSection: "
                         "Exception Code = %08lx\n", GetCurrentThreadId(), rc));
          goto errorExit;
    }
    
    InitializeListHead(&reflectorInstance->WorkerList);
    InitializeListHead(&reflectorInstance->WorkItemList);
    InitializeListHead(&reflectorInstance->AvailableList);

    //
    // For being alive add a reference to the block.
    //
    reflectorInstance->ReferenceCount = 1;  
    reflectorInstance->Closing = FALSE;
    reflectorInstance->DeviceHandle = INVALID_HANDLE_VALUE;

    //
    // We copy the driver names into the bottom of our buffer so that we have
    // copies of them later on if needed.
    //
    reflectorInstance->DriverDeviceName = &reflectorInstance->DeviceNameBuffers[0];
    lstrcpyW(reflectorInstance->DriverDeviceName, DriverDeviceName);

    //
    // Attempt to connect up with the driver.
    //
    RtlInitUnicodeString(&UMRxDeviceName, reflectorInstance->DriverDeviceName);
    InitializeObjectAttributes(&ObjectAttributes,
                               &UMRxDeviceName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    rc = NtOpenFile(&reflectorInstance->DeviceHandle,
                    SYNCHRONIZE,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    FILE_SHARE_VALID_FLAGS,
                    FILE_SYNCHRONOUS_IO_NONALERT);
    if (rc == STATUS_SUCCESS) {
        ASSERT( reflectorInstance->DeviceHandle != INVALID_HANDLE_VALUE );
    } else {
        rc = RtlNtStatusToDosError(rc);
    }

errorExit:

    if (rc != STATUS_SUCCESS) {
        //
        // Things failed here. Let's clean up.
        //
        (void) UMReflectorUnregister(reflectorInstance);
        *Reflector = NULL;
    }

    return rc;
}


VOID
DereferenceReflectorBlock (
    PUMRX_USERMODE_REFLECT_BLOCK Reflector
    )
/*++

Routine Description:

    This routine dereferences the reflector block and if the reference becomes
    zero, finalizes it.

Arguments:

    Reflector - This is returned by the call and points to an opaque structure 
                that should be passed to subsequent calls.

Return Value:

    none.
    
--*/
{
    PLIST_ENTRY listEntry;
    PUMRX_USERMODE_WORKITEM_ADDON workItem;

    //
    //  The lock MUST be held coming in here.  This could free the block.
    //
    if (--Reflector->ReferenceCount > 0) {
        LeaveCriticalSection(&Reflector->Lock);
        return;
    }

    //
    // We're done with this block now, so let's delete it.
    //
    RlDavDbgPrint(("%ld: Finalizing the Reflector BLock: %08lx.\n",
                   GetCurrentThreadId(), Reflector));

    LeaveCriticalSection(&Reflector->Lock);
    DeleteCriticalSection(&Reflector->Lock);

    if (Reflector->DeviceHandle != INVALID_HANDLE_VALUE) {
        NtClose(Reflector->DeviceHandle);
        Reflector->DeviceHandle = INVALID_HANDLE_VALUE;
    }

    //
    // The work item list at this point really should be empty. If it isn't,
    // we're hosed as we've closed the device and shutdown all threads.
    //
    ASSERT(IsListEmpty(&Reflector->WorkItemList));

    //
    // Free up the AvailableList since this instance is now history.
    //
    while (!IsListEmpty(&Reflector->AvailableList)) {
        listEntry = RemoveHeadList(&Reflector->AvailableList);
        workItem = CONTAINING_RECORD(listEntry,
                                     UMRX_USERMODE_WORKITEM_ADDON,
                                     ListEntry);
        workItem->WorkItemState = WorkItemStateFree;
        LocalFree(workItem);
    }

    LocalFree(Reflector);

    return;
}


ULONG
UMReflectorUnregister (
    PUMRX_USERMODE_REFLECT_BLOCK Reflector
    )
/*++

Routine Description:

    Unregister us with the kernel driver and free all resources.

Arguments:

    Handle - The handle created by the reflector library.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    IO_STATUS_BLOCK     IoStatusBlock;
    UNICODE_STRING      UMRxDeviceName;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE              UMRdrHandle;
    ULONG               rc = ERROR_SUCCESS;

    if (Reflector == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    Reflector->Closing = TRUE;

    // rc = UMReflectorReleaseThreads(Reflector);

    EnterCriticalSection(&Reflector->Lock);

    //
    // If we don't have any worker threads active, delete this guy now.
    //
    DereferenceReflectorBlock(Reflector);

    return rc;
}


ULONG
ReflectorSendSimpleFsControl(
    PUMRX_USERMODE_REFLECT_BLOCK Reflector,
    ULONG IoctlCode
    )
/*++

Routine Description:

    This sends an FSCTL to the device object associated with the Reflector 
    block.

Arguments:

    Relector - The datastructure associated which was returned to the usermode
               process at initialization time.
               
    IoctlCode - The FsCtl code for the operation.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    ULONG rc;
    IO_STATUS_BLOCK IoStatusBlock;

    if (Reflector == NULL) {
        rc = ERROR_INVALID_PARAMETER;
        return rc;
    }

    //
    // Send the FSCTL to the Mini-Redir.
    //
    if (Reflector->DeviceHandle != INVALID_HANDLE_VALUE) {
        rc = NtFsControlFile(Reflector->DeviceHandle,
                             0,
                             NULL,
                             NULL,
                             &IoStatusBlock,
                             IoctlCode,
                             NULL,
                             0,
                             NULL,
                             0);
    } else {
        rc = ERROR_OPEN_FAILED;
    }

    return rc;
}


ULONG
UMReflectorStart(
    ULONG ReflectorVersion,
    PUMRX_USERMODE_REFLECT_BLOCK Reflector
    )
/*++

Routine Description:

    This routine sends an FSCTL to start the Mini-Redir. Before we send the 
    Fsctl, we find out the path to the WinInet cache on the local machine. We
    then send this down to the kernel via the Fsctl. The Dav MiniRedir stores
    the value of this path in a global variable and uses it to answer any volume
    information queries.

Arguments:

    ReflectorVersion - The reflector's version.

    Handle - The handle created by the reflector library.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PDAV_USERMODE_DATA DavUserModeData = NULL;
    PFN_GETWININET_CACHE_PATH pfnSHGetSpecialFolderPath;
    HMODULE hShell32 = NULL;
    BOOL ReturnVal;
    IO_STATUS_BLOCK IoStatusBlock;
    
    if (ReflectorVersion != UMREFLECTOR_CURRENT_VERSION) {
        //
        // Whoops. Mismatch here. We should support backward levels but right
        // now there aren't any so we just bail.
        //
        return ERROR_NOT_SUPPORTED;
    }

    if (Reflector == NULL) {
        RlDavDbgPrint(("%ld: ERROR: UMReflectorStart. Reflector == NULL\n",
                       GetCurrentThreadId()));
        WStatus = ERROR_INVALID_PARAMETER;
        goto EXIT_THE_FUNCTION;
    }

    DavUserModeData = LocalAlloc( (LMEM_FIXED | LMEM_ZEROINIT), sizeof(DAV_USERMODE_DATA));
    if (DavUserModeData == NULL) {
        WStatus = GetLastError();
        RlDavDbgPrint(("%ld: ERROR: UMReflectorStart/LocalAlloc. WStatus = %d\n",
                       GetCurrentThreadId(), WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Get the Path of the WinInet cache. To do this we need to load shell32.dll,
    // get the address of the function SHGetSpecialFolderPath and call it with
    // CSIDL_INTERNET_CACHE.
    //

    //
    // Store the Pid of the process.
    //
    DavUserModeData->ProcessId = GetCurrentProcessId();
    
    hShell32 = LoadLibraryW(L"shell32.dll");
    if (hShell32 == NULL) {
        WStatus = GetLastError();
        RlDavDbgPrint(("%ld: ERROR: UMReflectorStart/LoadLibrary:"
                       " WStatus = %08lx.\n", GetCurrentThreadId(), WStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    pfnSHGetSpecialFolderPath = (PFN_GETWININET_CACHE_PATH) 
                                        GetProcAddress(hShell32, 
                                                       "SHGetSpecialFolderPathW");
    if (pfnSHGetSpecialFolderPath == NULL) {
        WStatus = GetLastError();
        RlDavDbgPrint(("%ld: ERROR: UMReflectorStart/GetProcAddress:"
                       " WStatus = %08lx.\n", GetCurrentThreadId(), WStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    ReturnVal = pfnSHGetSpecialFolderPath(NULL,
                                          (LPWSTR)DavUserModeData->WinInetCachePath,
                                          CSIDL_INTERNET_CACHE,
                                          FALSE);
    if (!ReturnVal) {
        WStatus = ERROR_INVALID_PARAMETER;
        RlDavDbgPrint(("%ld: ERROR: UMReflectorStart/pfnSHGetSpecialFolderPath:"
                       " WStatus = %08lx.\n", GetCurrentThreadId(), WStatus));
        goto EXIT_THE_FUNCTION;
    }
    
    //
    // Now issue an FSCTL down to the MiniRedir.
    //
    if (Reflector->DeviceHandle != INVALID_HANDLE_VALUE) {
        WStatus = NtFsControlFile(Reflector->DeviceHandle,
                                  0,
                                  NULL,
                                  NULL,
                                  &IoStatusBlock,
                                  FSCTL_UMRX_START,
                                  DavUserModeData,
                                  sizeof(DAV_USERMODE_DATA),
                                  NULL,
                                  0);
        if (WStatus != ERROR_SUCCESS) {
            RlDavDbgPrint(("%ld: ERROR: UMReflectorStart/NtFsControlFile:"
                           " WStatus = %08lx.\n", GetCurrentThreadId(), WStatus));
            goto EXIT_THE_FUNCTION;
        }
    } else {
        WStatus = ERROR_OPEN_FAILED;
        RlDavDbgPrint(("%ld: ERROR: UMReflectorStart. DeviceHandle == INVALID_HANDLE_VALUE\n",
                       GetCurrentThreadId()));
        goto EXIT_THE_FUNCTION;
    }

EXIT_THE_FUNCTION:

    if (DavUserModeData) {
        LocalFree(DavUserModeData);
    }

    return WStatus;
}


ULONG
UMReflectorStop(
    PUMRX_USERMODE_REFLECT_BLOCK Reflector
    )
/*++

Routine Description:

    This routine sends an FSCTL to stop the Mini-Redir.

Arguments:

    ReflectorVersion - The reflector's version.

    Handle - The handle created by the reflector library.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    return ReflectorSendSimpleFsControl(Reflector, FSCTL_UMRX_STOP);
}


ULONG
UMReflectorReleaseThreads (
    PUMRX_USERMODE_REFLECT_BLOCK Reflector
    )
/*++

Routine Description:

    If any user mode threads are waiting for requests, they'll return
    immediately.

Arguments:

    Handle - The handle created by the reflector library.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    IO_STATUS_BLOCK IoStatusBlock;
    OVERLAPPED OverLapped;
    BOOL SuccessfulOperation;
    ULONG rc = ERROR_SUCCESS;

    if (Reflector == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (Reflector->DeviceHandle != INVALID_HANDLE_VALUE) {
        RtlZeroMemory(&OverLapped, sizeof(OverLapped));
        SuccessfulOperation = DeviceIoControl(Reflector->DeviceHandle,
                                              IOCTL_UMRX_RELEASE_THREADS,
                                              NULL,
                                              0,
                                              NULL,
                                              0,
                                              NULL,
                                              &OverLapped);
        if (!SuccessfulOperation) {
            rc = GetLastError();
        }
    }

    return rc;
}


ULONG
UMReflectorOpenWorker(
    IN PUMRX_USERMODE_REFLECT_BLOCK Reflector,
    OUT PUMRX_USERMODE_WORKER_INSTANCE *WorkerHandle
    )
/*++

Routine Description:

    This allocates a "per worker thread" structure for the app so that it can
    have multiple IOCTLs pending down into kernel on different threads.  If
    we just open them up asynchronous, then we don't use the fast path.  If
    we open them up synchronous and use the same handle, then only one thread
    gets past the I/O manager at any given time.

Arguments:

    Reflector - The reflector block allocated for the Mini-Redir. 
    
    WorkerHandle - The worker handle that is created and returned.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    ULONG rc = STATUS_SUCCESS;
    PUMRX_USERMODE_WORKER_INSTANCE worker;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING DeviceObjectName;

    worker = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, 
                        sizeof(UMRX_USERMODE_WORKER_INSTANCE));

    *WorkerHandle = worker;

    if (worker == NULL) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto errorExit;
    }

    worker->ReflectorInstance = Reflector;

    EnterCriticalSection( &(Reflector->Lock) );
    
    RtlInitUnicodeString(&DeviceObjectName, Reflector->DriverDeviceName);
    
    InitializeObjectAttributes(&ObjectAttributes,
                               &DeviceObjectName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    rc = NtOpenFile(&worker->ReflectorHandle,
                    SYNCHRONIZE,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    FILE_SHARE_VALID_FLAGS,
                    FILE_SYNCHRONOUS_IO_ALERT);
    if (rc != STATUS_SUCCESS) {
        LeaveCriticalSection(&Reflector->Lock);
        rc = RtlNtStatusToDosError(rc);
        goto errorExit;
    }

    //
    // Now we just add it to the list and we're done.
    //
    Reflector->ReferenceCount++;
    InsertTailList(&Reflector->WorkerList, &worker->WorkerListEntry);

    LeaveCriticalSection( &(Reflector->Lock) );

errorExit:

    if (rc != STATUS_SUCCESS) {
        //
        // Things failed here. Let's clean up.
        //
        if (worker != NULL) {
            LocalFree(worker);
        }
        *WorkerHandle = NULL;
    }
    
    return rc;
}


VOID
UMReflectorCloseWorker(
    PUMRX_USERMODE_WORKER_INSTANCE Worker
    )
/*++

Routine Description:

    This routine finalizes a worker structure.

Arguments:

    Worker - The worker structure for this thread.

Return Value:

    The return value is a Win32 error code.  STATUS_SUCCESS is returned on
    success.

--*/
{
    EnterCriticalSection( &(Worker->ReflectorInstance->Lock) );

    if (Worker->ReflectorHandle != INVALID_HANDLE_VALUE) {
        NtClose( Worker->ReflectorHandle );
        Worker->ReflectorHandle = INVALID_HANDLE_VALUE;
    }

    RemoveEntryList(&Worker->WorkerListEntry);

    DereferenceReflectorBlock(Worker->ReflectorInstance);

    LocalFree(Worker);

    return;
}


VOID
UMReflectorCompleteRequest(
    PUMRX_USERMODE_REFLECT_BLOCK ReflectorHandle,
    PUMRX_USERMODE_WORKITEM_HEADER WorkItemHeader
    )
/*++

Routine Description:

    This routine completes an async request being handled by an async queue 
    thread. These threads should not be confused with the worker threads that
    are spun by the DAV user mode process to reflect requests. This will just
    send a response down and come back.

Arguments:

    ReflectorHandle - Address of the Reflector block strucutre for this process.
    
    WorkItemHeader - The user mode work item header.

Return Value:

    none.
    
--*/
{
    ULONG WStatus = ERROR_SUCCESS;
    PUMRX_USERMODE_WORKER_INSTANCE WorkerHandle = NULL;

    //
    // Get a worker instance for this thread.
    //
    WStatus = UMReflectorOpenWorker(ReflectorHandle, &WorkerHandle);
    if (WStatus != ERROR_SUCCESS || WorkerHandle == NULL) {
        if (WStatus == ERROR_SUCCESS) {
            WStatus = ERROR_INTERNAL_ERROR;
        }
        RlDavDbgPrint(("%ld: ERROR: UMReflectorCompleteRequest/UMReflectorOpenWorker:"
                       " WStatus = %08lx.\n", GetCurrentThreadId(), WStatus));
        goto EXIT_THE_FUNCTION;
    }

    //
    // Send the response.
    //
    WStatus = UMReflectorSendResponse(WorkerHandle, WorkItemHeader);
    if (WStatus != ERROR_SUCCESS) {
        RlDavDbgPrint(("%ld: ERROR: UMReflectorCompleteRequest/UMReflectorSendResponse:"
                       " WStatus = %08lx.\n", GetCurrentThreadId(), WStatus));
    }

    //
    // If the request got cancelled in the kernelmode and we need to do some
    // cleanup, then the callWorkItemCleanup flag will be set to TRUE by the
    // Precomplete routine in the kernel. If it is TRUE then we call the cleanup
    // routine.
    //
    if (WorkItemHeader->callWorkItemCleanup) {
        DavCleanupWorkItem(WorkItemHeader);
    }

    //
    // Complete the work item.
    //
    WStatus = UMReflectorCompleteWorkItem(WorkerHandle, WorkItemHeader);
    if (WStatus != ERROR_SUCCESS) {
        RlDavDbgPrint(("%ld: ERROR: UMReflectorCompleteRequest/UMReflectorCompleteWorkItem:"
                       " WStatus = %08lx.\n", GetCurrentThreadId(), WStatus));
    }

EXIT_THE_FUNCTION:

    //
    // Free the worker instance now, since our job is done.
    //
    if (WorkerHandle) {  
        UMReflectorCloseWorker(WorkerHandle);
    }
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\reflector\user\security.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    security.c

Abstract:

    This code handles impersonating and reverting for the user mode
    reflector library.  This implements UMReflectorImpersonate and
    UMReflectorRevert.

Author:

    Andy Herron (andyhe) 20-Apr-1999

Environment:

    User Mode - Win32

Revision History:

--*/
#include "precomp.h"
#pragma hdrstop


ULONG
UMReflectorImpersonate(
    PUMRX_USERMODE_WORKITEM_HEADER IncomingWorkItem,
    HANDLE ImpersonationToken
    )
/*++

Routine Description:

   This routine impersonates the calling thread. 

Arguments:

    IncomingWorkItem - The workitem being handled by the thread.
    
    ImpersonationToken - The handle used to impersonate.

Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    PUMRX_USERMODE_WORKITEM_ADDON workItem = NULL;
    ULONG rc = STATUS_SUCCESS;
    BOOL ReturnVal;

    if (IncomingWorkItem == NULL || ImpersonationToken == NULL) {
        rc = ERROR_INVALID_PARAMETER;
        return rc;
    }

    //
    // We get back to our item by subtracting off of the item passed to us.
    // This is safe because we fully control allocation.
    //
    workItem = (PUMRX_USERMODE_WORKITEM_ADDON)(PCHAR)((PCHAR) IncomingWorkItem -
                FIELD_OFFSET(UMRX_USERMODE_WORKITEM_ADDON, Header));

    ASSERT(workItem->WorkItemState != WorkItemStateFree);
    ASSERT(workItem->WorkItemState != WorkItemStateAvailable);

    ReturnVal = ImpersonateLoggedOnUser(ImpersonationToken);
    if (!ReturnVal) {
        rc = GetLastError();
        RlDavDbgPrint(("%ld: ERROR: UMReflectorImpersonate/ImpersonateLoggedOnUser: "
                       "WStatus = %08lx.\n", GetCurrentThreadId(), rc));
    }

    return rc;
}

ULONG
UMReflectorRevert(
    PUMRX_USERMODE_WORKITEM_HEADER IncomingWorkItem
    )
/*++

Routine Description:

   This routine reverts the calling thread which was impersonated earlier. 

Arguments:

    IncomingWorkItem - The workitem being handled by the thread.
    
Return Value:

    ERROR_SUCCESS or the appropriate error value.

--*/
{
    PUMRX_USERMODE_WORKITEM_ADDON workItem = NULL;
    ULONG rc = STATUS_SUCCESS;
    BOOL ReturnVal;

    if (IncomingWorkItem == NULL) {
        rc = ERROR_INVALID_PARAMETER;
        return rc;
    }

    //
    // We get back to our item by subtracting off of the item passed to us.
    // This is safe because we fully control allocation.
    //
    workItem = (PUMRX_USERMODE_WORKITEM_ADDON)(PCHAR)((PCHAR) IncomingWorkItem -
                FIELD_OFFSET(UMRX_USERMODE_WORKITEM_ADDON, Header));

    ReturnVal = RevertToSelf();
    if (!ReturnVal) {
        rc = GetLastError();
        RlDavDbgPrint(("%ld: ERROR: UMReflectorRevert/RevertToSelf: "
                       "WStatus = %08lx.\n", GetCurrentThreadId(), rc));
    }

    return rc;
}

// security.c eof.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\client\davrpc_client.c ===
#include <davrpc_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\webdav\makefile.inc ===
#
# These are common to all sources files in this project.
# (Each sources file includes this file.)
#

C_DEFINES=-DWIN32 -DUNICODE -D_UNICODE
MSC_WARNING_LEVEL=/W3 /WX
RCOPTIONS=-N
UMTYPE=windows
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\rdr2\rdbss\dav.mrx\test\davtest.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    apitest.c

Abstract:

    Program to test DAV

Author:

    Shishir Pardikar (shishirp) 4-24-97

Environment:

    User Mode - Win32

Revision History:

--*/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <wininet.h>
#include <winnetwk.h>

//=================================================================================
#define MAX_COMMAND_ARGS    32
#define DEFAULT_BUFFER_SIZE 1024    // 1k
//=================================================================================

// The order of these must match the order in GlobalCommandInfo[]
typedef enum _COMMAND_CODE {
    CmdDAVGetProp,
    CmdDAVSetProp,
    CmdDAVEnumServer,
    CmdGetSpace,
    CmdFreeSpace,
    CmdHelp,
    CmdQuit,
    UnknownCommand
} COMMAND_CODE, *LPCOMMAND_CODE;

typedef struct _COMMAND_INFO {
    LPSTR CommandName;
    LPSTR CommandParams;
    COMMAND_CODE CommandCode;
} COMMAND_INFO, *LPCOMMAND_INFO;

DWORD
ProcessDAVSetProp(
    DWORD    argc,
    LPSTR   *argv
    );

DWORD
ProcessDAVGetProp(
    DWORD    argc,
    LPSTR   *argv
    );

DWORD
ProcessDAVEnumServer(
    DWORD   argc,
    LPSTR   *argv
    );


DWORD
ProcessDAVGetSpace(
    DWORD   argc,
    LPSTR   *argv
    );
    
DWORD
ProcessDAVFreeSpace(
    DWORD   argc,
    LPSTR   *argv
    );

DWORD
APIENTRY
DavFreeUsedDiskSpace(
    DWORD   dwPercent
    );


DWORD
APIENTRY
DavGetDiskSpaceUsage(
    LPWSTR      lptzLocation,
    DWORD       *lpdwSize,
    ULARGE_INTEGER   *lpMaxSpace,
    ULARGE_INTEGER   *lpUsedSpace
    );
//=================================================================================
FILE *UncList = NULL;
LPSTR g_lpWriteFileBuf = NULL;
FILE *DumpUncList = NULL;
DWORD cCommands = 0;
DWORD cFails = 0;
DWORD g_dwNumIterations = 1;
DWORD g_dwIteration = 0;
DWORD g_dwNumCmdIterations = 1;
DWORD g_dwCmdIteration = 0;
DWORD g_dwFileSize = 0;
DWORD g_dwDiskCache = 0;
BOOL g_bWriteFile = FALSE;
BOOL g_bQuietMode = FALSE;
BOOL g_bPerfMode = FALSE;
BOOL g_bUseFile = FALSE;

COMMAND_INFO GlobalCommandInfo[] = {
    {"GetProp",        "Server",                        CmdDAVGetProp},
    {"SetProp",        "Server Property Value",         CmdDAVSetProp},
    {"Enum",            "Enumerate shares",             CmdDAVEnumServer},
    {"GetSpace",        "Get Used Disk Space",          CmdGetSpace},
    {"FreeSpace",       "FreeSpace <percent of cache in decimal>",         CmdFreeSpace},
    {"Help",        "",                                 CmdHelp},
    {"Quit",         "",                                CmdQuit}
};

char szTestBuff[] = "00000888";
char szDavProviderName[] = "Web Client Network";

DWORD WINAPIV Format_String(LPSTR *plpsz, LPSTR lpszFmt, ...);
DWORD WINAPI Format_Error(DWORD dwErr, LPSTR *plpsz);
DWORD WINAPI Format_StringV(LPSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs);
DWORD WINAPI Format_MessageV(DWORD dwFlags, DWORD dwErr, LPSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs);

//=================================================================================

DWORD
ProcessCommandCode (
    DWORD CommandCode,
    DWORD CommandArgc,
    LPSTR *CommandArgv
    );


DWORD
GetLeafLenFromPath(
    LPSTR   lpszPath
    );


char rgXmlHeader[] = "Content-Type: text/xml; charset=\"utf-8\"";
char rgXmlData[] = 
//"<?xml version=\"1.0\" encoding=\"utf-8\" ?> \r <D:propertyupdate xmlns:D=\"DAV:\" xmlns:Z=\"http://www.w3.com\"> \r <D:set><D:prop><Z:Win32FileAttributes>3</Z:Win32FileAttributes></D:prop></D:set></D:propertyupdate>";
"<?xml version=\"1.0\" encoding=\"utf-8\" ?> \r <D:propertyupdate xmlns:D=\"DAV:\" xmlns:Z=\"http://www.w3.com\"> \r <D:set><D:prop><Z:Win32lastModifiedTime> 1000 2000 </Z:Win32lastModifiedTime></D:prop></D:set></D:propertyupdate>";
char rgXmlDataHeader[] = "<?xml version=\"1.0\" encoding=\"utf-8\" ?> \r <D:propertyupdate xmlns:D=\"DAV:\" xmlns:Z=\"http://www.w3.com\"> \r <D:set><D:prop>";
char rgXmlDataTrailer[] = "</D:prop></D:set></D:propertyupdate>";
char rgLastModifiedTimeTagHeader[] = "<Z:Win32lastModifiedTime>";
char rgLastModifiedTimeTagTrailer[] = "</Z:Win32lastModifiedTime>";

char Buffer[4096];


//=================================================================================
#if DBG

#define TestDbgAssert(Predicate) \
    { \
        if (!(Predicate)) \
            TestDbgAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }

VOID
TestDbgAssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    )
/*++

Routine Description:

    Assertion failed.

Arguments:

    FailedAssertion :

    FileName :

    LineNumber :

    Message :

Return Value:

    none.

--*/
{

    printf("Assert @ %s \n", FailedAssertion );
    printf("Assert Filename, %s \n", FileName );
    printf("Line Num. = %ld.\n", LineNumber );
    printf("Message is %s\n", Message );

    DebugBreak();
}
#else

#define TestDbgAssert(_x_)

#endif // DBG

//=================================================================================
VOID
ParseArguments(
    LPSTR InBuffer,
    LPSTR *CArgv,
    LPDWORD CArgc
    )
{
    LPSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr == ' ' ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != '\0') &&
                (*CurrentPtr != '\n') ) {
            if( *CurrentPtr == '"' ) {      // Deal with simple quoted args
                if( Cnt == 0 )
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                else
                    *CurrentPtr = '\0';     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == ' ') ||   // If we hit a space and no quotes yet we are done with this arg
                (*CurrentPtr == '\0') )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        *CurrentPtr++ = '\0';
    }

    *CArgc = i;
    return;
}

#ifdef MAYBE
//=================================================================================
LPSTR
GetUncFromFile ()
{
    if (!UncList)
    {
        UncList = fopen ("Unclist", "r");
        if (UncList == NULL)
            return NULL;
    }
    if (fgets( UncBuffer, DEFAULT_BUFFER_SIZE, UncList))
    {
        UncBuffer[strlen(UncBuffer) -1] = '\0';  //kill line feed for no param cmds
        return UncBuffer;
    }
    else
    {
        fclose (UncList);
        UncList = NULL;
        return GetUncFromFile();
    }
}

#endif
//=================================================================================
COMMAND_CODE
DecodeCommand(
    LPSTR CommandName
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalCommandInfo) / sizeof(COMMAND_INFO);
    TestDbgAssert( NumCommands <= UnknownCommand );
    for( i = 0; i < NumCommands; i++) {
        if(( lstrcmpi( CommandName, GlobalCommandInfo[i].CommandName ) == 0 )){
            return( GlobalCommandInfo[i].CommandCode );
        }
    }
    return( UnknownCommand );
}

//=================================================================================
VOID
PrintCommands(
    VOID
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalCommandInfo) / sizeof(COMMAND_INFO);
    TestDbgAssert( NumCommands <= UnknownCommand );
    for( i = 0; i < NumCommands; i++) {
        fprintf(stderr, "    %s (%s)\n",
            GlobalCommandInfo[i].CommandName,
            GlobalCommandInfo[i].CommandParams );
    }
}

//=================================================================================
VOID
DisplayUsage(
    VOID
    )
{
    DWORD dwTemp;
    char InBuffer[    DEFAULT_BUFFER_SIZE];

    memset(    InBuffer, 0, sizeof(InBuffer));
    if (dwTemp = GetEnvironmentVariable("USERPROFILE", InBuffer, DEFAULT_BUFFER_SIZE))
    {
        fprintf(stderr, "Got var %x\n", dwTemp );
        fprintf(stderr, "%S\n", InBuffer );
    }
    else
    {
        fprintf(stderr, "No var\n" );
        fprintf(stderr, "Error %x\n", GetLastError());
    }
    
    fprintf(stderr, "Usage: command <command parameters>\n" );
    
    sscanf(szTestBuff, "%x", &dwTemp);
    fprintf(stderr, "%x \n", dwTemp);

    fprintf(stderr, "Commands : \n");

        
    PrintCommands();

    return;
}

//=================================================================================
FILETIME
GetGmtTime(
    VOID
    )
{
    SYSTEMTIME SystemTime;
    FILETIME Time;

    GetSystemTime( &SystemTime );
    SystemTimeToFileTime( &SystemTime, &Time );

    return( Time );
}

//=================================================================================

//=================================================================================
DWORD
ProcessCommandCode (
    DWORD CommandCode,
    DWORD CommandArgc,
    LPSTR *CommandArgv
    )
{
    DWORD Error = ERROR_SUCCESS;

        switch( CommandCode ) {
            case CmdDAVGetProp:
                Error = ProcessDAVGetProp(CommandArgc, CommandArgv);
                break;
            case CmdDAVSetProp:
                Error = ProcessDAVSetProp(CommandArgc, CommandArgv);
                break;
            case CmdDAVEnumServer:
                Error = ProcessDAVEnumServer(CommandArgc, CommandArgv);
            case CmdGetSpace:
                Error = ProcessDAVGetSpace(CommandArgc, CommandArgv);
                break;
            case CmdFreeSpace:
                Error = ProcessDAVFreeSpace(CommandArgc, CommandArgv);
                break;
            case CmdHelp:
                DisplayUsage();
            break;
            case CmdQuit :
                exit (0);

        default:
            TestDbgAssert( FALSE );
            fprintf(stderr, "Unknown Command Specified.\n");
            DisplayUsage();
            break;
        }
        cCommands++;

        if( Error != ERROR_SUCCESS ) {
            LPSTR lpstr;

            cFails++;
            Format_Error(Error, &lpstr);
            printf("FAILED (%s), %ld-%s.\n",
                GlobalCommandInfo[CommandCode].CommandName, Error, lpstr );
            LocalFree(lpstr);
        }
        else {
            if(!g_bQuietMode)
                printf("Command (%s) successfully completed.\n", GlobalCommandInfo[CommandCode].CommandName );
        }
        return Error;
}


//=================================================================================
VOID
__cdecl
main(
    int argc,
    char *argv[]
    )
{

    DWORD Error;
    COMMAND_CODE CommandCode;
    CHAR InBuffer[DEFAULT_BUFFER_SIZE];
    DWORD CArgc;
    LPSTR CArgv[MAX_COMMAND_ARGS];
    unsigned u1 = 1, u2 = 0xffffffff;

    DWORD CommandArgc;
    LPSTR *CommandArgv;



    /* must check for batch mode.  if there are command line parms, assume batch mode */
    if (argc > 1)
    {
        //this means that the arguments translate directly into CommandArgc....
        CommandCode = DecodeCommand( argv[1] );
        if( CommandCode == UnknownCommand ) {
            printf("Unknown Command Specified.\n");
            return;
        }

        CommandArgc = argc - 2;
        CommandArgv = &argv[2];

        Error = ProcessCommandCode (CommandCode,CommandArgc,CommandArgv);

        if (DumpUncList)
            fclose(DumpUncList);
        if (UncList)
            fclose(UncList);

        return;
    }

    DisplayUsage();

    for(;;) {

        fprintf(stderr,  "Command : " );

        gets( InBuffer );

        CArgc = 0;
        ParseArguments( InBuffer, CArgv, &CArgc );

        if( CArgc < 1 ) {
            continue;
        }

        //
        // decode command.
        //

        CommandCode = DecodeCommand( CArgv[0] );
        if( CommandCode == UnknownCommand ) {
            fprintf(stderr, "Unknown Command Specified.\n");
            continue;
        }

        CommandArgc = CArgc - 1;
        CommandArgv = &CArgv[1];

        Error = ProcessCommandCode (CommandCode,CommandArgc,CommandArgv);

    }

    return;
}

//=================================================================================
DWORD
GetLeafLenFromPath(
    LPSTR   lpszPath
    )
{
    DWORD len;
    LPSTR   lpT;

    if(!lpszPath)
        return(0);

    len = lstrlen(lpszPath);

    if (len == 0) {

        return (len);

    }

    lpT = lpszPath+len-1;
    if (*lpT =='\\') {
        --lpT;
    }
    for (; lpT >= lpszPath; --lpT) {
        if (*lpT == '\\') {
            break;
        }
    }
    return (lstrlen(lpT));
}

//=================================================================================
DWORD WINAPIV Format_String(LPSTR *plpsz, LPSTR lpszFmt, ...)
{
    const char c_Func_Name[] = "[Format_String] ";
    DWORD dwRet;
    va_list vArgs;

    va_start (vArgs, lpszFmt);
    dwRet = Format_StringV(plpsz, lpszFmt, &vArgs);
    va_end (vArgs);

    return(dwRet);
}

//=================================================================================
DWORD WINAPI Format_Error(DWORD dwErr, LPSTR *plpsz)
{
    DWORD dwRet;

    if(dwErr != ERROR_SUCCESS)
    {
        dwRet = Format_MessageV(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            dwErr, plpsz, NULL, NULL);
    }
    else
    {
        const char szMsg[] = "No Error";
        Format_String(plpsz, (LPSTR)szMsg);
        dwRet = lstrlen(szMsg);
    }

    return(dwRet);
}

//=================================================================================
DWORD WINAPI Format_StringV(LPSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs)
{
    return(Format_MessageV(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        0, plpsz, lpszFmt, vArgs));
}

// ***************************************************************************
DWORD WINAPI Format_MessageV(DWORD dwFlags, DWORD dwErr, LPSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs)
{
    const char c_Func_Name[] = "[Format_MessageV]";

    DWORD dwRet;
    DWORD dwGLE;

    *plpsz = NULL;
    dwRet = FormatMessage(dwFlags, lpszFmt, dwErr, 0, (LPSTR) plpsz, 0, vArgs);

    if (!dwRet || !*plpsz)
    {
        dwGLE = GetLastError();
        printf("%s FormatMessage Failed: %s. dwRet: %#lx!. *plpsz:%#lx! GLE:%d\r\n", c_Func_Name, lpszFmt, dwRet, *plpsz, dwGLE);

        if (*plpsz)
            LocalFree ((HLOCAL) *plpsz);
        *plpsz = NULL;
        return 0;
    }

    return(dwRet);
}



DWORD
ProcessDAVGetProp(
    DWORD   argc,
    LPSTR   *argv
    )
{
    HINTERNET hDavOpen=NULL, hDavConnect = NULL, hRequest = NULL;
    DWORD   dwError = ERROR_SUCCESS;    
    LPSTR   lpRequestHeader=NULL, lpOptionalData = NULL, lpTemp;    

    if (argc < 2)
    {
        printf("GetProp Needs more args\n");
        return ERROR_INVALID_PARAMETER;
    }
    
    hDavOpen = InternetOpen("DAVtest",
                            INTERNET_OPEN_TYPE_PRECONFIG,
                            NULL,
                            NULL,
                            0);
    if (hDavOpen == NULL) {
        dwError = GetLastError();
        goto bailout;
    }

    hDavConnect = InternetConnect(  hDavOpen,
                                    argv[0],
                                    INTERNET_DEFAULT_HTTP_PORT,
                                    NULL,
                                    NULL,
                                    INTERNET_SERVICE_HTTP,
                                    0,
                                    0);
    if (hDavConnect == NULL)
    {
        dwError = GetLastError();
        goto bailout;
    }

    hRequest = HttpOpenRequest(hDavConnect,
                                "PROPFIND",
                                argv[1],
                                HTTP_VERSION,
                                NULL,
                                NULL,
                                INTERNET_FLAG_KEEP_CONNECTION |
                                INTERNET_FLAG_RELOAD          |
                                INTERNET_FLAG_NO_AUTO_REDIRECT,
                                0);
    if (hRequest == NULL)
    {
        dwError = GetLastError();
        goto bailout;
    }
    
     if (!HttpSendRequest(hRequest, NULL, 0, NULL, 0))
    {
        dwError = GetLastError();
    }
                
bailout:

    if (hRequest)
    {
        InternetCloseHandle(hRequest);    
    }
    if (hDavConnect)
    {
        InternetCloseHandle(hDavConnect);    
    }
    if (hDavOpen)
    {
        InternetCloseHandle(hDavOpen);    
    }
    
    return dwError;
}

DWORD
ProcessDAVSetProp(
    DWORD   argc,
    LPSTR   *argv
    )
{
    HINTERNET hDavOpen=NULL, hDavConnect = NULL, hRequest = NULL;
    DWORD   dwError = ERROR_SUCCESS, dwLen;    
    LPSTR   lpRequestHeader=NULL, lpOptionalData = NULL, lpTemp;    
    SYSTEMTIME  sSystemTime;
    char sTimeBuff[INTERNET_RFC1123_BUFSIZE+10];    
    
    if (argc < 2)
    {
        printf("SetProp Needs more args\n");
        return ERROR_INVALID_PARAMETER;
    }
    
    hDavOpen = InternetOpen("DAVtest",
                            INTERNET_OPEN_TYPE_PRECONFIG,
                            NULL,
                            NULL,
                            0);
    if (hDavOpen == NULL) {
        dwError = GetLastError();
        goto bailout;
    }

    hDavConnect = InternetConnect(  hDavOpen,
                                    argv[0],
                                    INTERNET_DEFAULT_HTTP_PORT,
                                    NULL,
                                    NULL,
                                    INTERNET_SERVICE_HTTP,
                                    0,
                                    0);
    if (hDavConnect == NULL)
    {
        dwError = GetLastError();
        goto bailout;
    }

#if 0
    hRequest = HttpOpenRequest(hDavConnect,
                                "PROPFIND",
                                argv[1],
                                HTTP_VERSION,
                                NULL,
                                NULL,
                                INTERNET_FLAG_KEEP_CONNECTION |
                                INTERNET_FLAG_RELOAD          |
                                INTERNET_FLAG_NO_AUTO_REDIRECT,
                                0);
    if (hRequest == NULL)
    {
        dwError = GetLastError();
        goto bailout;
    }
    
     if (!HttpSendRequest(hRequest, NULL, 0, NULL, 0))
    {
        dwError = GetLastError();
    }
#endif

    hRequest = HttpOpenRequest(hDavConnect,
                                "PROPPATCH",
                                argv[1],
                                HTTP_VERSION,
                                NULL,
                                NULL,
                                INTERNET_FLAG_KEEP_CONNECTION |
                                INTERNET_FLAG_RELOAD          |
                                INTERNET_FLAG_NO_AUTO_REDIRECT,
                                0);
    if (hRequest == NULL)
    {
        dwError = GetLastError();
        goto bailout;
    }

    memset(Buffer, 0, sizeof(Buffer));
    
    lpTemp = Buffer;
    
    strcpy(lpTemp, rgXmlDataHeader);

    lpTemp += (sizeof(rgXmlDataHeader)-1);

    memcpy(lpTemp, rgLastModifiedTimeTagHeader, (sizeof(rgLastModifiedTimeTagHeader)-1));
    
    lpTemp += (sizeof(rgLastModifiedTimeTagHeader)-1);
    
    GetSystemTime(&sSystemTime);

    InternetTimeFromSystemTimeA(&sSystemTime, INTERNET_RFC1123_FORMAT, sTimeBuff, sizeof(sTimeBuff));

    dwLen = strlen(sTimeBuff);
    
    memcpy(lpTemp, sTimeBuff, dwLen);
    
    lpTemp += dwLen;
        
    memcpy(lpTemp, rgLastModifiedTimeTagTrailer, (sizeof(rgLastModifiedTimeTagTrailer)-1));
    
    lpTemp += (sizeof(rgLastModifiedTimeTagTrailer)-1);
    
    strcpy(lpTemp, rgXmlDataTrailer);
        
     if (!HttpSendRequest(hRequest,
                                (LPVOID)rgXmlHeader,
                                strlen(rgXmlHeader),
                                (LPVOID)Buffer,
                                strlen(Buffer)))
    {
        dwError = GetLastError();
    }
                
bailout:

    if (hRequest)
    {
        InternetCloseHandle(hRequest);    
    }
    if (hDavConnect)
    {
        InternetCloseHandle(hDavConnect);    
    }
    if (hDavOpen)
    {
        InternetCloseHandle(hDavOpen);    
    }
    
    return dwError;
}


DWORD
ProcessDAVEnumServer(
    DWORD   argc,
    LPSTR   *argv
    )
{
    HINTERNET hDavOpen=NULL, hDavConnect = NULL, hRequest = NULL;
    DWORD   dwError = ERROR_SUCCESS;    
    LPSTR   lpRequestHeader=NULL, lpOptionalData = NULL, lpTemp;    
    NETRESOURCEA    sRes;
    HANDLE  hEnum = 0;
    char Buffer[4096];
    
        
    if (argc < 1)
    {
        printf("EnumResource Needs more args\n");
        return ERROR_INVALID_PARAMETER;
    }

    memset(&sRes, 0, sizeof(sRes));
    sRes.lpRemoteName = argv[0];
    sRes.lpProvider = szDavProviderName;
        
    if(WNetOpenEnumA(RESOURCE_GLOBALNET, RESOURCETYPE_DISK, RESOURCEUSAGE_CONTAINER, &sRes, &hEnum) == NO_ERROR)
    {
        DWORD   dwCount, dwSize;
        dwCount = 1;
        dwSize = sizeof(Buffer);
        while (WNetEnumResourceA(hEnum, &dwCount, Buffer, &dwSize)== NO_ERROR)
        {
            dwCount = 1;
            dwSize = sizeof(Buffer);
            printf("%s \n", ((LPNETRESOURCE)Buffer)->lpRemoteName);
        }
        WNetCloseEnum(hEnum);
    }
    else
    {
        dwError = GetLastError();
    }
    return d